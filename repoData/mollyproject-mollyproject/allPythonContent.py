__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# molly documentation build configuration file, created by
# sphinx-quickstart on Tue Mar  2 20:57:21 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os
import os.path
from datetime import datetime

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.intersphinx', 'sphinx.ext.todo', 'sphinx.ext.coverage',
              'sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.txt'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'molly'
copyright = u'%d, Molly Project and contributors' % datetime.now().year

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))
from molly import __version__ as molly_version

# The short X.Y version.
version = molly_version
# The full version, including alpha/beta/rc tags.
release = molly_version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'mollydoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'molly.tex', u'molly Documentation',
   u'University of Oxford', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {
    'http://docs.python.org/': None,
    'http://docs.djangoproject.com/en/dev/': 'http://docs.djangoproject.com/en/dev/_objects/',
}

########NEW FILE########
__FILENAME__ = forms
"""
Defines contact form fields
"""
from django import forms


class GenericContactForm(forms.Form):
    """ Defines Contact Form search field """
    query = forms.CharField()

########NEW FILE########
__FILENAME__ = models
"""
Empty file needed for django-staticfiles
"""

########NEW FILE########
__FILENAME__ = mit
from operator import itemgetter

import ldap
import ldap.filter

from molly.apps.contact.providers import BaseContactProvider, TooManyResults

class LDAPContactProvider(BaseContactProvider):
    
    # See http://en.wikipedia.org/wiki/Nobility_particle for more information.
    _NOBILITY_PARTICLES = set([
        'de', 'van der', 'te', 'von', 'van', 'du', 'di'
    ])
    
    def __init__(self, url, base_dn, phone_prefix='', phone_formatter=None,
                 alphabetical=False, query='(sn={surname})'):
        self._url = url
        self._base_dn = base_dn
        if phone_formatter is None:
            phone_formatter = lambda t: '%s%s' % (phone_prefix, t)
        self._phone_formatter = phone_formatter
        self.alphabetical = alphabetical
        self.query = query
    
    def normalize_query(self, cleaned_data, medium):
        # Examples of initial / surname splitting
        # William Bloggs is W, Bloggs
        # Bloggs         is  , Bloggs
        # W Bloggs       is W, Bloggs
        # Bloggs W       is W, Bloggs
        # Bloggs William is B, William
        parts = cleaned_data['query'].split(' ')
        parts = [p for p in parts if p]
        i = 0
        
        while i < len(parts)-1:
            if parts[i].lower() in self._NOBILITY_PARTICLES:
                parts[i:i+2] = [' '.join(parts[i:i+2])]
            elif parts[i] == '':
                parts[i:i+1] = []
            else:
                i += 1
        
        parts = parts[:2]
        if len(parts) == 1:
            surname, forename = parts[0], None
        elif parts[0].endswith(','):
            surname, forename = parts[0][:-1], parts[1]
        else:
            surname, forename = parts[1], parts[0]
        
        return {
            'surname': surname,
            'forename': forename,
        }

    def first_or_none(self, result, name):
        try:
            return result[1][name][0]
        except (KeyError, IndexError):
            return None

    def perform_query(self, surname, forename):
        
        ldap_server = ldap.initialize(self._url)
        
        if forename is None:
            forename = ''
        
        try:
            ldap_results = ldap_server.search_ext_s(
                self._base_dn, ldap.SCOPE_SUBTREE,
                self.query.format(
                    surname=ldap.filter.escape_filter_chars(surname),
                    forename=ldap.filter.escape_filter_chars(forename))
            )
        except ldap.NO_SUCH_OBJECT:
            return []
        except ldap.SIZELIMIT_EXCEEDED:
            raise TooManyResults()
        
        results = []
        for ldap_result in ldap_results:
            results.append({
                'cn': self.first_or_none(ldap_result, 'cn'),
                'sn': ldap_result[1].get('sn', []),
                'givenName': ldap_result[1].get('givenName', []),
                'telephoneNumber': map(self._phone_formatter,ldap_result[1].get('telephoneNumber', [])),
                'roomNumber': ldap_result[1].get('roomNumber', []),
                'title': ldap_result[1].get('title', []),
                'facsimileTelephoneNumber': ldap_result[1].get('facsimileTelephoneNumber', []),
                'ou': ldap_result[1].get('ou', []),
                'mail': ldap_result[1].get('mail', []),
            })
        
        if self.alphabetical:
            return sorted(results, key=itemgetter('sn', 'givenName'))
        else:
            return results

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from views import IndexView, ResultListView, ResultDetailView

urlpatterns = patterns('',
    (r'^$', IndexView, {}, 'index'),
    (r'^results/$', ResultListView, {}, 'result_list'),
    (r'^results/(?P<id>[^\/]+)/$', ResultDetailView, {}, 'result_detail'),
)

########NEW FILE########
__FILENAME__ = views
import simplejson
import hashlib
import urllib2
from datetime import timedelta

from django.http import HttpResponse, Http404
from django.utils.translation import ugettext as _

from molly.utils.views import BaseView
from molly.utils.breadcrumbs import *
from molly.apps.contact.providers import BaseContactProvider, TooManyResults

from molly.apps.contact.forms import GenericContactForm

class IndexView(BaseView):

    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name,
            None,
            _('Contact search'),
            lazy_reverse('index'),
        )

    def initial_context(self, request):
        return {
            'form': self.conf.provider.form(request.GET or None),
            'medium_choices': self.conf.provider.medium_choices,
        }

    def handle_GET(self, request, context):
        return self.render(request, context, 'contact/index',
                           expires=timedelta(days=28))


class ResultListView(IndexView):

    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('index'),
            _('Contact search'),
            lazy_reverse('result_list'),
        )

    def handle_GET(self, request, context):
        provider = self.conf.provider

        form = provider.form(request.GET or None)
        medium = request.GET.get('medium')
        if not medium in [m[0] for m in provider.medium_choices]:
            medium = provider.medium_choices[0][0]

        if form.is_valid():

            query = provider.normalize_query(form.cleaned_data, medium)

            try:
                people = provider.perform_query(**query)
            except TooManyResults:
                return self.handle_error(request, context,
                                         _("Your search returned too many results."))

            context.update({
                'results': people,
                'medium': medium,
            })

        context['form'] = form
        return self.render(request, context, 'contact/result_list',
                           expires=timedelta(days=7))

    def handle_error(self, request, context, message):
        context.update({
            'message': message,
        })

        return self.render(request, context, 'contact/result_list')


class ResultDetailView(BaseView):

    @BreadcrumbFactory
    def breadcrumb(self, request, context, id):
        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('result_list'),
            _('Contact search'),
            lazy_reverse('result_detail', id),
        )

    def handle_GET(self, request, context, id):
        try:
            context['result'] = self.conf.provider.fetch_result(id)
        except BaseContactProvider.NoSuchResult:
            raise Http404

        return self.render(request, context, 'contact/result_list')

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from .views import IndexView

urlpatterns = patterns('',
    (r'^$',
        IndexView, {},
        'index'),
)

########NEW FILE########
__FILENAME__ = views
import simplejson
import urllib2
import feedparser
import logging
from datetime import timedelta

from django.http import Http404, HttpResponse
from django.template import loader, TemplateDoesNotExist, RequestContext
from django.shortcuts import render_to_response
from django.core.cache import cache

from molly.utils.views import BaseView
from molly.utils.breadcrumbs import NullBreadcrumb

logger = logging.getLogger(__name__)

class IndexView(BaseView):

    def get_metadata(self, request):
        return {
            'exclude_from_search': True}

    breadcrumb = NullBreadcrumb

    def initial_context(self, request):
        return {
            'blog_feed': self._cache(self._get_blog_feed, 'blog',
                                        args=[getattr(self.conf,
                                        'blog_rss_url')], timeout=300),
            'blog_url': getattr(self.conf, 'blog_url', None),
            'facebook_url': getattr(self.conf, 'facebook_url', None),
            'twitter_username': getattr(self.conf, 'twitter_username', None),
            'twitter_widget_id': getattr(self.conf, 'twitter_widget_id', None),
        }

    def handle_GET(self, request, context):
        # Can't render fragment
        if 'fragment' in self.FORMATS: del self.FORMATS['fragment']
        return self.render(request, context, 'desktop/index',
                           expires=timedelta(days=1))

    def _cache(self, f, key, args=None, kwargs=None, timeout=None):
        key = '.'.join(['molly', self.conf.local_name, key])
        value = cache.get(key)
        if value is None:
            value = f(*(args or ()), **(kwargs or {}))
            cache.set(key, value, timeout)
        return value

    def _get_blog_feed(self, url):
        if not url:
            return None

        try:
            return feedparser.parse(url)
        except Exception, e:
            logger.warn("Failed to fetch blog feed.", exc_info=True)
            return None

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from models import *


class FeatureAdmin(admin.ModelAdmin):
    list_display = ('title', 'user_name', 'user_email', 'description', 'net_votes', 'is_public', 'is_removed')
    list_filter = ('is_public', 'is_removed')

admin.site.register(Feature, FeatureAdmin)

########NEW FILE########
__FILENAME__ = forms
from django import forms
from models import Feature
from django.utils.translation import ugettext as _

class FeatureForm(forms.ModelForm):
    user_name = forms.CharField(widget=forms.TextInput(), label=_("Your name"))
    title = forms.CharField(widget=forms.TextInput(), label=_("Feature title"))

    class Meta:
        fields = ('user_name', 'user_email', 'title', 'description')
        model = Feature

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Feature'
        db.create_table('feature_vote_feature', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user_name', self.gf('django.db.models.fields.TextField')()),
            ('user_email', self.gf('django.db.models.fields.EmailField')(max_length=75)),
            ('title', self.gf('django.db.models.fields.TextField')()),
            ('description', self.gf('django.db.models.fields.TextField')()),
            ('up_vote', self.gf('django.db.models.fields.IntegerField')(default=0)),
            ('down_vote', self.gf('django.db.models.fields.IntegerField')(default=0)),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('last_commented', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('is_public', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('is_removed', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('feature_vote', ['Feature'])


    def backwards(self, orm):
        
        # Deleting model 'Feature'
        db.delete_table('feature_vote_feature')


    models = {
        'feature_vote.feature': {
            'Meta': {'ordering': "('-last_commented', '-created')", 'object_name': 'Feature'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'down_vote': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_removed': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_commented': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'up_vote': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'user_email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'user_name': ('django.db.models.fields.TextField', [], {})
        }
    }

    complete_apps = ['feature_vote']

########NEW FILE########
__FILENAME__ = 0002_auto__add_field_feature_implemented_on
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Feature.implemented_on'
        db.add_column('feature_vote_feature', 'implemented_on', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Feature.implemented_on'
        db.delete_column('feature_vote_feature', 'implemented_on')


    models = {
        'feature_vote.feature': {
            'Meta': {'ordering': "('-last_commented', '-created')", 'object_name': 'Feature'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'down_vote': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'implemented_on': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_removed': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_commented': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'up_vote': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'user_email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'user_name': ('django.db.models.fields.TextField', [], {})
        }
    }

    complete_apps = ['feature_vote']

########NEW FILE########
__FILENAME__ = 0003_auto__add_field_feature_notifications_sent
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Feature.notifications_sent'
        db.add_column('feature_vote_feature', 'notifications_sent', self.gf('django.db.models.fields.BooleanField')(default=False), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Feature.notifications_sent'
        db.delete_column('feature_vote_feature', 'notifications_sent')


    models = {
        'feature_vote.feature': {
            'Meta': {'ordering': "('-last_commented', '-created')", 'object_name': 'Feature'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'down_vote': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'implemented_on': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_removed': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_commented': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'notifications_sent': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'up_vote': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'user_email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'user_name': ('django.db.models.fields.TextField', [], {})
        }
    }

    complete_apps = ['feature_vote']

########NEW FILE########
__FILENAME__ = models
from datetime import datetime, timedelta

from django.db import models
from django.core.urlresolvers import reverse
from django.utils.translation import ugettext_lazy as _
from django.contrib.sessions.models import Session
from django.contrib.comments.moderation import CommentModerator, moderator

from molly.apps.home.models import UserMessage
from molly.utils import send_email

class Feature(models.Model):
    
    #: Name of the submitting user
    user_name = models.TextField(verbose_name=_('Your name'))
    
    #: E-mail address of the submitting user
    user_email = models.EmailField(verbose_name=_('E-mail address'))
    
    #: Title of the feature request
    title = models.TextField(verbose_name=_('Feature title'))
    
    #: More verbose description of the feature request
    description = models.TextField(verbose_name=_('Description'))

    #: The number of up-votes this feature request has received
    up_vote = models.IntegerField(default=0)
    
    #: The number of down-votes this feature request has received
    down_vote = models.IntegerField(default=0)

    #: The date this feature request was submitted
    created = models.DateTimeField(auto_now_add=True)
    
    #: The date this was last commented on
    last_commented = models.DateTimeField(blank=True, null=True)
    
    #: Whether or not this has been moderated to be displayed
    is_public = models.BooleanField(default=False)
    
    #: Whether or not this has been removed (e.g., after completion)
    is_removed = models.BooleanField(default=False)
    
    #: The date this feature was implemented
    implemented_on = models.DateTimeField(blank=True, null=True,
                                          verbose_name=_('Date this feature was implemented'))
    
    #: Whether or not notifications have been sent to users about if this has been implemented or not
    notifications_sent = models.BooleanField(default=False)

    class Meta:
        ordering = ('-last_commented', '-created')

    def __unicode__(self):
        return self.title

    def simplify_for_render(self, simplify_value, simplify_model):
        return simplify_model(self)

    REMOVE_AFTER_IMPLEMENTED_FOR = timedelta(weeks=4)

    def check_remove(self, request):
        """
        Marks a feature as removed a month after it's been implemented
        """
        if self.implemented_on and not self.notifications_sent:
            
            # Send notifications that this feature's been implemented
            # First to the original requesting user
            send_email(request, {
                'feature': self,
            }, 'feature_vote/implemented.eml', to_email=(self.user_email,))
            self.notifications_sent = True
            self.save()
            
            # And now, using the developer messages framework, to all voting
            # users
            voting_sessions = set()
            for session in Session.objects.all():
                if 'feature_vote:votes' in session.get_decoded():
                    if self.id in session.get_decoded()['feature_vote:votes']:
                        voting_sessions.add(session.session_key)
            
            for session_key in voting_sessions:
                UserMessage.objects.create(session_key=session_key,
                                           message="A feature you voted on (%s), has now been implemented!" % self.title)
            
        if not self.is_removed and self.implemented_on and \
          self.implemented_on + self.REMOVE_AFTER_IMPLEMENTED_FOR < datetime.now():
            self.is_removed = True
            self.save()

    @property
    def net_votes(self):
        """
        The combined number of votes for this suggestion
        """
        return self.up_vote - self.down_vote

    def get_absolute_url(self):
        return reverse('feature_vote:feature-detail', args=[self.id])


class FeatureModerator(CommentModerator):
    """Comments are only enabled on public features and are always moderated.
    This means individual comments need to be marked public. Email
    notifications are sent for each new comment posted.
    """
    email_notification = True
    auto_moderate_field = 'created'
    moderate_after = 0
    enable_field = 'is_public'

moderator.register(Feature, FeatureModerator)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from .views import IndexView, FeatureDetailView

urlpatterns = patterns('',
    (r'^$', IndexView, {}, 'index'),
    (r'^(?P<id>\d+)/$', FeatureDetailView, {}, 'feature-detail'),
)

########NEW FILE########
__FILENAME__ = views
from operator import attrgetter

from django.shortcuts import get_object_or_404
from django.core.urlresolvers import reverse
from django.utils.translation import ugettext as _

from molly.utils.views import BaseView
from molly.utils.breadcrumbs import *
from molly.utils import send_email

from molly.apps.feature_vote.models import Feature
from molly.apps.feature_vote.forms import FeatureForm


class IndexView(BaseView):
    # A mapping from (old, new) to (delta down, delta up)
    vote_transitions = {
        (-1,-1): ( 0, 0),  ( 0,-1): (+1, 0),  (+1,-1): (+1,-1),
        (-1, 0): (-1, 0),  ( 0, 0): ( 0, 0),  (+1, 0): ( 0,-1),
        (-1,+1): (-1,+1),  ( 0,+1): ( 0,+1),  (+1,+1): ( 0, 0),
    }
    #  ++    -
    # -      -
    # -    ++

    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name,
            None,
            _('Feature suggestions'),
            lazy_reverse('index'),
        )

    def initial_context(self, request):
        if not 'feature_vote:votes' in request.session:
            request.session['feature_vote:votes'] = {}

        for feature in Feature.objects.filter(is_public=True, is_removed=False):
            feature.check_remove(request)

        features = Feature.objects.filter(is_public=True, is_removed=False)
        for feature in sorted(features[:], key=attrgetter('net_votes'),
                              reverse=True):
            feature.vote = request.session['feature_vote:votes'].get(feature.id, 0)

        return {
            'features': features,
            'form': FeatureForm(request.POST or None),
            'submitted': request.GET.get('submitted') == 'true',
        }

    def handle_GET(self, request, context):
        return self.render(request, context, 'feature_vote/index')

    def handle_POST(self, request, context):
        form = context['form']
        post = request.POST.copy()

        if 'vote_up.x' in post:
            post['vote_up'] = post['vote_up.x']

        if 'vote_down.x' in post:
            post['vote_down'] = post['vote_down.x']

        if 'vote_up' in post or 'vote_down' in post:
            feature = get_object_or_404(Feature, id=post.get('id', 0))
            previous_vote = request.session['feature_vote:votes'].get(feature.id, 0)
            vote = previous_vote + (1 if 'vote_up' in post else -1)
            vote = min(max(-1, vote), 1)
            request.session['feature_vote:votes'][feature.id] = vote
            request.session.modified = True

            feature.down_vote += self.vote_transitions[(previous_vote, vote)][0]
            feature.up_vote += self.vote_transitions[(previous_vote, vote)][1]

            feature.save()

            if request.POST.get('return_url', '').startswith('/'):
                return self.redirect(request.POST['return_url'], request,
                                     'seeother')
            else:
                return self.redirect(reverse('feature_vote:index'), request,
                                     'seeother')

        if form.is_valid():
            form.save()

            send_email(request, {
                'name': form.cleaned_data['user_name'],
                'email': form.cleaned_data['user_email'],
                'title': form.cleaned_data['title'],
                'description': form.cleaned_data['description'],
                'feature': form.instance,
            }, 'feature_vote/feature_create.eml', self)

            return self.redirect(reverse('feature_vote:index') + '?submitted=true',
                                 request, 'seeother')
        else:
            return self.handle_GET(request, context)


class FeatureDetailView(BaseView):

    @BreadcrumbFactory
    def breadcrumb(self, request, context, id):
        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('index'),
            context['feature'].title,
            lazy_reverse('feature-detail'),
        )

    def initial_context(self, request, id):
        if not 'feature_vote:votes' in request.session:
            request.session['feature_vote:votes'] = {}
        feature = get_object_or_404(Feature, id=id, is_public=True)
        feature.vote = request.session['feature_vote:votes'].get(feature.id, 0)
        return {
            'feature': feature,
        }

    def handle_GET(self, request, context, id):
        return self.render(request, context, 'feature_vote/feature_detail')

########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.utils.translation import ugettext_lazy as _

class FeedbackForm(forms.Form):
    email = forms.EmailField(label=_("Your e-mail address (optional)"),
                             required=False)
    email.widget.input_type = 'email'
    body = forms.CharField(widget=forms.Textarea(), label=_("Feedback"))

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from views import IndexView

urlpatterns = patterns('',
    (r'^$',
        IndexView, {},
        'index'),
    )

########NEW FILE########
__FILENAME__ = views
import urllib
from datetime import timedelta

from django.conf import settings
from django.core.urlresolvers import reverse
from django.utils.translation import ugettext as _

from molly.utils.views import BaseView
from molly.utils.breadcrumbs import BreadcrumbFactory, Breadcrumb, lazy_reverse
from molly.utils import send_email

from forms import FeedbackForm

class IndexView(BaseView):

    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name, None, _('Feedback'),
            lazy_reverse('index'))

    def initial_context(self, request):
        return {
            'feedback_form': FeedbackForm(request.POST or None)}

    def handle_GET(self, request, context):
        context.update({
           'sent': request.GET.get('sent') == 'true',
           'feedback_referrer': request.GET.get('referer', ''),
        })
        return self.render(request, context, 'feedback/index',
                           expires=timedelta(days=365))

    def handle_POST(self, request, context):
        form = context['feedback_form']
        if form.is_valid():
            # Send an e-mail to the managers notifying of feedback.
            email = send_email(request, {
                'email': form.cleaned_data['email'],
                'referer': request.POST.get('referer', ''),
                'body': form.cleaned_data['body'],
            }, 'feedback/email.txt', self)

            qs = urllib.urlencode({
                'sent': 'true',
                'referer': request.POST.get('referer', ''),
            })

            return self.redirect('%s?%s' % (reverse('feedback:index'), qs),
                                 request)

        else:
            return self.handle_GET(request, context)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from models import Feed, Item

class FeedAdmin(admin.ModelAdmin):
    list_display = ('title', 'entity', 'rss_url')
    # excluded because not used and causes performance
    # problems when you have 47622 entities...
    exclude = ('entity',)

class ItemAdmin(admin.ModelAdmin):
    list_display = ('title', 'last_modified', 'feed')
    list_filter = ('feed', 'last_modified')

admin.site.register(Feed, FeedAdmin)
admin.site.register(Item, ItemAdmin)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from .views import IndexView, ItemListView, ItemDetailView

urlpatterns = patterns('',
   (r'^$',
       IndexView, {},
       'index'),
   (r'^(?P<slug>[a-z\-]+)/$',
       ItemListView, {},
       'item-list'),
   (r'^(?P<slug>[a-z\-]+)/(?P<id>\d+)/$',
       ItemDetailView, {},
       'item-detail'),
)
########NEW FILE########
__FILENAME__ = views
from datetime import datetime, timedelta
from xml.sax.saxutils import escape

from django.core.paginator import Paginator, EmptyPage, InvalidPage
from django.http import HttpResponse
from django.shortcuts import get_object_or_404
from django.utils.translation import ugettext as _
from django.utils.translation import get_language
from django.db.models import Q

from molly.utils.views import BaseView
from molly.utils.breadcrumbs import *

from ..models import Feed, Item

class IndexView(BaseView):
    def get_metadata(self, request):
        return {
            'title': _('Events'),
            'additional': _('View events from across the University.'),
        }

    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name, None, _('Events'), lazy_reverse('index')
        )

    def handle_GET(self, request, context):
        feeds = Feed.events.all()
        
        # Only actually care about showing feeds in the right language, not
        # dialect, so only match on before the -
        lang_code = get_language()
        if '-' in lang_code:
            lang_code = lang_code.split('-')[0]
        
        all_feeds = feeds.count()
        if 'all' not in request.GET:
            feeds = feeds.filter(
                Q(language__startswith=lang_code) | Q(language=None)
            )
        lang_feeds = feeds.count()
        
        context= {
            'feeds': feeds,
            'more_in_all': lang_feeds != all_feeds,
        }
        return self.render(request, context, 'feeds/events/index',
                           expires=timedelta(days=7))

class ItemListView(BaseView):
    def get_metadata(self, request, slug):
        feed = get_object_or_404(Feed.events, slug=slug)

        # Translators: Feed last modified [date format] otherwise _('never_updated')
        last_modified = feed.last_modified.strftime('%a, %d %b %Y') if feed.last_modified else _('never updated')
        return {
            'last_modified': feed.last_modified,
            'title': feed.title,
            'additional': '<strong>Events feed</strong>, %s' % last_modified,
        }

    @BreadcrumbFactory
    def breadcrumb(self, request, context, slug):
        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('index'),
            _('Events feed'),
            lazy_reverse('item-list', args=[slug])
        )

    def handle_GET(self, request, context, slug):
        feed = get_object_or_404(Feed.events, slug=slug)
        context['feed'] = feed
        context['feed_items'] = feed.item_set.filter(dt_start__gte=datetime.today()).order_by('dt_start')
        return self.render(request, context, 'feeds/events/item_list')

class ItemDetailView(BaseView):
    def get_metadata(self, request, slug, id):
        item = get_object_or_404(Item, feed__slug=slug, id=id)

        last_modified = item.last_modified.strftime('%a, %d %b %Y') if item.last_modified else _('never updated')
        return {
            'last_modified': item.last_modified,
            'title': item.title,
            'additional': '<strong>Events item</strong>, %s, %s' % (escape(item.feed.title), last_modified),
            'feed_title': escape(item.feed.title),
        }

    @BreadcrumbFactory
    def breadcrumb(self, request, context, slug, id):
        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('item-list', slug=slug),
            _('Events item'),
            lazy_reverse('item-detail', args=[slug,id])
        )

    def handle_GET(self, request, context, slug, id):
        item = get_object_or_404(Item, feed__slug=slug, id=id)
        context.update({
            'item': item,
            'description': item.get_description_display(request.device)
        })
        return self.render(request, context, 'feeds/events/item_detail')

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Tag'
        db.create_table('feeds_tag', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('value', self.gf('django.db.models.fields.CharField')(max_length=128)),
        ))
        db.send_create_signal('feeds', ['Tag'])

        # Adding model 'Feed'
        db.create_table('feeds_feed', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('title', self.gf('django.db.models.fields.TextField')()),
            ('unit', self.gf('django.db.models.fields.CharField')(max_length=10, null=True, blank=True)),
            ('rss_url', self.gf('django.db.models.fields.URLField')(max_length=200)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=50, db_index=True)),
            ('last_modified', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('ptype', self.gf('django.db.models.fields.CharField')(max_length=1)),
            ('provider', self.gf('django.db.models.fields.CharField')(max_length=128)),
        ))
        db.send_create_signal('feeds', ['Feed'])

        # Adding M2M table for field tags on 'Feed'
        db.create_table('feeds_feed_tags', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('feed', models.ForeignKey(orm['feeds.feed'], null=False)),
            ('tag', models.ForeignKey(orm['feeds.tag'], null=False))
        ))
        db.create_unique('feeds_feed_tags', ['feed_id', 'tag_id'])

        # Adding model 'vCard'
        db.create_table('feeds_vcard', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('uri', self.gf('django.db.models.fields.TextField')()),
            ('name', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('address', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('telephone', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('location', self.gf('django.contrib.gis.db.models.fields.PointField')(null=True)),
            ('entity', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['places.Entity'], null=True, blank=True)),
        ))
        db.send_create_signal('feeds', ['vCard'])

        # Adding model 'Series'
        db.create_table('feeds_series', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('feed', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['feeds.Feed'])),
            ('guid', self.gf('django.db.models.fields.TextField')()),
            ('title', self.gf('django.db.models.fields.TextField')()),
            ('unit', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['feeds.vCard'], null=True, blank=True)),
        ))
        db.send_create_signal('feeds', ['Series'])

        # Adding M2M table for field tags on 'Series'
        db.create_table('feeds_series_tags', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('series', models.ForeignKey(orm['feeds.series'], null=False)),
            ('tag', models.ForeignKey(orm['feeds.tag'], null=False))
        ))
        db.create_unique('feeds_series_tags', ['series_id', 'tag_id'])

        # Adding model 'Item'
        db.create_table('feeds_item', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('feed', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['feeds.Feed'])),
            ('title', self.gf('django.db.models.fields.TextField')()),
            ('guid', self.gf('django.db.models.fields.TextField')()),
            ('description', self.gf('django.db.models.fields.TextField')()),
            ('link', self.gf('django.db.models.fields.URLField')(max_length=200)),
            ('last_modified', self.gf('django.db.models.fields.DateTimeField')()),
            ('ptype', self.gf('django.db.models.fields.CharField')(max_length=16)),
            ('organiser', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='organising_set', null=True, to=orm['feeds.vCard'])),
            ('speaker', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='speaking_set', null=True, to=orm['feeds.vCard'])),
            ('venue', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='venue_set', null=True, to=orm['feeds.vCard'])),
            ('contact', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='contact_set', null=True, to=orm['feeds.vCard'])),
            ('series', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['feeds.Series'], null=True, blank=True)),
            ('ordinal', self.gf('django.db.models.fields.IntegerField')(null=True)),
            ('track', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('dt_start', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('dt_end', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('dt_has_time', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('feeds', ['Item'])

        # Adding M2M table for field tags on 'Item'
        db.create_table('feeds_item_tags', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('item', models.ForeignKey(orm['feeds.item'], null=False)),
            ('tag', models.ForeignKey(orm['feeds.tag'], null=False))
        ))
        db.create_unique('feeds_item_tags', ['item_id', 'tag_id'])


    def backwards(self, orm):
        
        # Deleting model 'Tag'
        db.delete_table('feeds_tag')

        # Deleting model 'Feed'
        db.delete_table('feeds_feed')

        # Removing M2M table for field tags on 'Feed'
        db.delete_table('feeds_feed_tags')

        # Deleting model 'vCard'
        db.delete_table('feeds_vcard')

        # Deleting model 'Series'
        db.delete_table('feeds_series')

        # Removing M2M table for field tags on 'Series'
        db.delete_table('feeds_series_tags')

        # Deleting model 'Item'
        db.delete_table('feeds_item')

        # Removing M2M table for field tags on 'Item'
        db.delete_table('feeds_item_tags')


    models = {
        'feeds.feed': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Feed'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modified': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'provider': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'ptype': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            'rss_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['feeds.Tag']", 'symmetrical': 'False', 'blank': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'unit': ('django.db.models.fields.CharField', [], {'max_length': '10', 'null': 'True', 'blank': 'True'})
        },
        'feeds.item': {
            'Meta': {'ordering': "('-last_modified',)", 'object_name': 'Item'},
            'contact': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'contact_set'", 'null': 'True', 'to': "orm['feeds.vCard']"}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'dt_end': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'dt_has_time': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'dt_start': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'feed': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.Feed']"}),
            'guid': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modified': ('django.db.models.fields.DateTimeField', [], {}),
            'link': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'ordinal': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'organiser': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'organising_set'", 'null': 'True', 'to': "orm['feeds.vCard']"}),
            'ptype': ('django.db.models.fields.CharField', [], {'max_length': '16'}),
            'series': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.Series']", 'null': 'True', 'blank': 'True'}),
            'speaker': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'speaking_set'", 'null': 'True', 'to': "orm['feeds.vCard']"}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['feeds.Tag']", 'symmetrical': 'False', 'blank': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'track': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'venue': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'venue_set'", 'null': 'True', 'to': "orm['feeds.vCard']"})
        },
        'feeds.series': {
            'Meta': {'object_name': 'Series'},
            'feed': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.Feed']"}),
            'guid': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['feeds.Tag']", 'symmetrical': 'False', 'blank': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'unit': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.vCard']", 'null': 'True', 'blank': 'True'})
        },
        'feeds.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'feeds.vcard': {
            'Meta': {'object_name': 'vCard'},
            'address': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'telephone': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'uri': ('django.db.models.fields.TextField', [], {})
        },
        'places.entity': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_stack': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_sublocation': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"}),
            'title': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'places.entitytype': {
            'Meta': {'ordering': "('verbose_name',)", 'object_name': 'EntityType'},
            'article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'verbose_name': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_plural': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        }
    }

    complete_apps = ['feeds']

########NEW FILE########
__FILENAME__ = 0002_auto__add_field_feed_language
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Feed.language'
        db.add_column('feeds_feed', 'language', self.gf('django.db.models.fields.CharField')(max_length=10, null=True), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Feed.language'
        db.delete_column('feeds_feed', 'language')


    models = {
        'feeds.feed': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Feed'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language': ('django.db.models.fields.CharField', [], {'max_length': '10', 'null': 'True'}),
            'last_modified': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'provider': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'ptype': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            'rss_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['feeds.Tag']", 'symmetrical': 'False', 'blank': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'unit': ('django.db.models.fields.CharField', [], {'max_length': '10', 'null': 'True', 'blank': 'True'})
        },
        'feeds.item': {
            'Meta': {'ordering': "('-last_modified',)", 'object_name': 'Item'},
            'contact': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'contact_set'", 'null': 'True', 'to': "orm['feeds.vCard']"}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'dt_end': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'dt_has_time': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'dt_start': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'feed': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.Feed']"}),
            'guid': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modified': ('django.db.models.fields.DateTimeField', [], {}),
            'link': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'ordinal': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'organiser': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'organising_set'", 'null': 'True', 'to': "orm['feeds.vCard']"}),
            'ptype': ('django.db.models.fields.CharField', [], {'max_length': '16'}),
            'series': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.Series']", 'null': 'True', 'blank': 'True'}),
            'speaker': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'speaking_set'", 'null': 'True', 'to': "orm['feeds.vCard']"}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['feeds.Tag']", 'symmetrical': 'False', 'blank': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'track': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'venue': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'venue_set'", 'null': 'True', 'to': "orm['feeds.vCard']"})
        },
        'feeds.series': {
            'Meta': {'object_name': 'Series'},
            'feed': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.Feed']"}),
            'guid': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['feeds.Tag']", 'symmetrical': 'False', 'blank': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'unit': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.vCard']", 'null': 'True', 'blank': 'True'})
        },
        'feeds.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'feeds.vcard': {
            'Meta': {'object_name': 'vCard'},
            'address': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'telephone': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'uri': ('django.db.models.fields.TextField', [], {})
        },
        'places.entity': {
            'Meta': {'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_stack': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_sublocation': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitytype': {
            'Meta': {'object_name': 'EntityType'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityTypeCategory']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        }
    }

    complete_apps = ['feeds']

########NEW FILE########
__FILENAME__ = 0003_auto__add_field_feed_entity
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Feed.entity'
        db.add_column('feeds_feed', 'entity', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['places.Entity'], null=True), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Feed.entity'
        db.delete_column('feeds_feed', 'entity_id')


    models = {
        'feeds.feed': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Feed'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language': ('django.db.models.fields.CharField', [], {'max_length': '10', 'null': 'True'}),
            'last_modified': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'provider': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'ptype': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            'rss_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['feeds.Tag']", 'symmetrical': 'False', 'blank': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'unit': ('django.db.models.fields.CharField', [], {'max_length': '10', 'null': 'True', 'blank': 'True'})
        },
        'feeds.item': {
            'Meta': {'ordering': "('-last_modified',)", 'object_name': 'Item'},
            'contact': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'contact_set'", 'null': 'True', 'to': "orm['feeds.vCard']"}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'dt_end': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'dt_has_time': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'dt_start': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'feed': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.Feed']"}),
            'guid': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modified': ('django.db.models.fields.DateTimeField', [], {}),
            'link': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'ordinal': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'organiser': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'organising_set'", 'null': 'True', 'to': "orm['feeds.vCard']"}),
            'ptype': ('django.db.models.fields.CharField', [], {'max_length': '16'}),
            'series': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.Series']", 'null': 'True', 'blank': 'True'}),
            'speaker': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'speaking_set'", 'null': 'True', 'to': "orm['feeds.vCard']"}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['feeds.Tag']", 'symmetrical': 'False', 'blank': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'track': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'venue': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'venue_set'", 'null': 'True', 'to': "orm['feeds.vCard']"})
        },
        'feeds.series': {
            'Meta': {'object_name': 'Series'},
            'feed': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.Feed']"}),
            'guid': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['feeds.Tag']", 'symmetrical': 'False', 'blank': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'unit': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.vCard']", 'null': 'True', 'blank': 'True'})
        },
        'feeds.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'feeds.vcard': {
            'Meta': {'object_name': 'vCard'},
            'address': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'telephone': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'uri': ('django.db.models.fields.TextField', [], {})
        },
        'places.entity': {
            'Meta': {'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_entrance': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitytype': {
            'Meta': {'object_name': 'EntityType'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityTypeCategory']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        }
    }

    complete_apps = ['feeds']

########NEW FILE########
__FILENAME__ = 0004_unit_to_entity
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models
from django.core.exceptions import ObjectDoesNotExist

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        for feed in orm.Feed.objects.filter(unit__isnull=False):
            try:
                # Move from legacy Oxford 'unit' schema to associations with entities
                entity = orm['places.Entity'].objects.get(
                             _identifiers__scheme='oucs',
                             _identifiers__value=feed.unit)
            except ObjectDoesNotExist:
                pass
            else:
                feed.entity = entity
                feed.save()


    def backwards(self, orm):
        "Write your backwards methods here."
        for feed in orm.Feed.objects.filter(entity__isnull=False):
            try:
                # Move from legacy Oxford 'unit' schema to associations with entities
                unit = feed.entity.identifiers['oucs']
            except KeyError:
                pass
            else:
                feed.unit = unit
                feed.save()


    models = {
        'feeds.feed': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Feed'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language': ('django.db.models.fields.CharField', [], {'max_length': '10', 'null': 'True'}),
            'last_modified': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'provider': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'ptype': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            'rss_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['feeds.Tag']", 'symmetrical': 'False', 'blank': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'unit': ('django.db.models.fields.CharField', [], {'max_length': '10', 'null': 'True', 'blank': 'True'})
        },
        'feeds.item': {
            'Meta': {'ordering': "('-last_modified',)", 'object_name': 'Item'},
            'contact': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'contact_set'", 'null': 'True', 'to': "orm['feeds.vCard']"}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'dt_end': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'dt_has_time': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'dt_start': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'feed': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.Feed']"}),
            'guid': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modified': ('django.db.models.fields.DateTimeField', [], {}),
            'link': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'ordinal': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'organiser': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'organising_set'", 'null': 'True', 'to': "orm['feeds.vCard']"}),
            'ptype': ('django.db.models.fields.CharField', [], {'max_length': '16'}),
            'series': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.Series']", 'null': 'True', 'blank': 'True'}),
            'speaker': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'speaking_set'", 'null': 'True', 'to': "orm['feeds.vCard']"}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['feeds.Tag']", 'symmetrical': 'False', 'blank': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'track': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'venue': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'venue_set'", 'null': 'True', 'to': "orm['feeds.vCard']"})
        },
        'feeds.series': {
            'Meta': {'object_name': 'Series'},
            'feed': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.Feed']"}),
            'guid': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['feeds.Tag']", 'symmetrical': 'False', 'blank': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'unit': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.vCard']", 'null': 'True', 'blank': 'True'})
        },
        'feeds.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'feeds.vcard': {
            'Meta': {'object_name': 'vCard'},
            'address': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'telephone': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'uri': ('django.db.models.fields.TextField', [], {})
        },
        'places.entity': {
            'Meta': {'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_entrance': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitytype': {
            'Meta': {'object_name': 'EntityType'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityTypeCategory']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        }
    }

    complete_apps = ['feeds']

########NEW FILE########
__FILENAME__ = 0005_auto__del_field_feed_unit
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting field 'Feed.unit'
        db.delete_column('feeds_feed', 'unit')


    def backwards(self, orm):
        
        # Adding field 'Feed.unit'
        db.add_column('feeds_feed', 'unit', self.gf('django.db.models.fields.CharField')(max_length=10, null=True, blank=True), keep_default=False)


    models = {
        'feeds.feed': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Feed'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language': ('django.db.models.fields.CharField', [], {'max_length': '10', 'null': 'True'}),
            'last_modified': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'provider': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'ptype': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            'rss_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['feeds.Tag']", 'symmetrical': 'False', 'blank': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'feeds.item': {
            'Meta': {'ordering': "('-last_modified',)", 'object_name': 'Item'},
            'contact': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'contact_set'", 'null': 'True', 'to': "orm['feeds.vCard']"}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'dt_end': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'dt_has_time': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'dt_start': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'feed': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.Feed']"}),
            'guid': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modified': ('django.db.models.fields.DateTimeField', [], {}),
            'link': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'ordinal': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'organiser': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'organising_set'", 'null': 'True', 'to': "orm['feeds.vCard']"}),
            'ptype': ('django.db.models.fields.CharField', [], {'max_length': '16'}),
            'series': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.Series']", 'null': 'True', 'blank': 'True'}),
            'speaker': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'speaking_set'", 'null': 'True', 'to': "orm['feeds.vCard']"}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['feeds.Tag']", 'symmetrical': 'False', 'blank': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'track': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'venue': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'venue_set'", 'null': 'True', 'to': "orm['feeds.vCard']"})
        },
        'feeds.series': {
            'Meta': {'object_name': 'Series'},
            'feed': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.Feed']"}),
            'guid': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['feeds.Tag']", 'symmetrical': 'False', 'blank': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'unit': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.vCard']", 'null': 'True', 'blank': 'True'})
        },
        'feeds.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'feeds.vcard': {
            'Meta': {'object_name': 'vCard'},
            'address': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'telephone': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'uri': ('django.db.models.fields.TextField', [], {})
        },
        'places.entity': {
            'Meta': {'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_entrance': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitytype': {
            'Meta': {'object_name': 'EntityType'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityTypeCategory']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        }
    }

    complete_apps = ['feeds']

########NEW FILE########
__FILENAME__ = 0006_feed_item_last_modified_nullable
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Changing field 'Item.last_modified'
        db.alter_column('feeds_item', 'last_modified', self.gf('django.db.models.fields.DateTimeField')(null=True))


    def backwards(self, orm):

        # Migrating data to a default value when null
        db.start_transaction()
        for item in orm.Item.objects.filter(last_modified__isnull=True):
            item.last_modified = datetime.datetime.now()
            item.save()
        db.commit_transaction()
        print "Migrated"
        # Changing field 'Item.last_modified'
        db.alter_column('feeds_item', 'last_modified', self.gf('django.db.models.fields.DateTimeField')(null=False))
        print "Altered"


    models = {
        'feeds.feed': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Feed'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language': ('django.db.models.fields.CharField', [], {'max_length': '10', 'null': 'True'}),
            'last_modified': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'provider': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'ptype': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            'rss_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['feeds.Tag']", 'symmetrical': 'False', 'blank': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'feeds.item': {
            'Meta': {'ordering': "('-last_modified',)", 'object_name': 'Item'},
            'contact': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'contact_set'", 'null': 'True', 'to': "orm['feeds.vCard']"}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'dt_end': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'dt_has_time': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'dt_start': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'feed': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.Feed']"}),
            'guid': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modified': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True'}),
            'link': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'ordinal': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'organiser': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'organising_set'", 'null': 'True', 'to': "orm['feeds.vCard']"}),
            'ptype': ('django.db.models.fields.CharField', [], {'max_length': '16'}),
            'series': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.Series']", 'null': 'True', 'blank': 'True'}),
            'speaker': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'speaking_set'", 'null': 'True', 'to': "orm['feeds.vCard']"}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['feeds.Tag']", 'symmetrical': 'False', 'blank': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'track': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'venue': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'venue_set'", 'null': 'True', 'to': "orm['feeds.vCard']"})
        },
        'feeds.series': {
            'Meta': {'object_name': 'Series'},
            'feed': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.Feed']"}),
            'guid': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['feeds.Tag']", 'symmetrical': 'False', 'blank': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'unit': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['feeds.vCard']", 'null': 'True', 'blank': 'True'})
        },
        'feeds.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'feeds.vcard': {
            'Meta': {'object_name': 'vCard'},
            'address': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'telephone': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'uri': ('django.db.models.fields.TextField', [], {})
        },
        'places.entity': {
            'Meta': {'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_entrance': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitytype': {
            'Meta': {'object_name': 'EntityType'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityTypeCategory']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        }
    }

    complete_apps = ['feeds']

########NEW FILE########
__FILENAME__ = models
from dateutil.tz import tzutc, tzlocal
from lxml import etree

from django.core.urlresolvers import reverse
from django.contrib.gis.db import models
from django.conf import settings
from django.utils.translation import ugettext_lazy as _

from molly.external_media import resize_external_image
from molly.apps.places.models import Entity
from molly.conf.provider import queue_post_save

FEED_TYPE_CHOICES = (
    ('n', 'news'),
    ('e', 'event'),
)


PROVIDER_CHOICES = tuple(
    (provider().class_path, provider().verbose_name)
        for app in settings.APPLICATIONS
        for provider in app.providers
        if app.application_name == 'molly.apps.feeds'
)


FORMAT_CHOICES = tuple((x, x) for x in (
    'lecture', 'class', 'tutorial', 'seminar', 'performance', 'workshop',
    'exhibition', 'meeting',
))


class EventsManager(models.Manager):
    def get_query_set(self):
        return super(EventsManager, self).get_query_set().filter(ptype='e')


class NewsManager(models.Manager):
    def get_query_set(self):
        return super(NewsManager, self).get_query_set().filter(ptype='n')


class Tag(models.Model):
    value = models.CharField(max_length=128)

    def __unicode__(self):
        return self.value


@queue_post_save
class Feed(models.Model):
    title = models.TextField(help_text=_("Feed title"))
    entity = models.ForeignKey(Entity, null=True, blank=True,
                               help_text=_('Place which this feed belongs to'))
    rss_url = models.URLField(help_text=_("URL of feed"),
            verbose_name=_("URL"))
    slug = models.SlugField(help_text=_("Slug of feed, e.g. oucs-news"))
    # this one is in UTC
    last_modified = models.DateTimeField(null=True, blank=True)
    language = models.CharField(max_length=10, choices=settings.LANGUAGES,
                                null=True)

    # Provider type
    ptype = models.CharField(max_length=1, choices=FEED_TYPE_CHOICES)
    provider = models.CharField(max_length=128, choices=PROVIDER_CHOICES)

    objects = models.Manager()
    events = EventsManager()
    news = NewsManager()

    tags = models.ManyToManyField(Tag, blank=True)

    def __unicode__(self):
        return self.title

    def get_absolute_url(self):
        if self.ptype == 'n':
            return reverse('news:item-list', args=[self.slug])
        else:
            return reverse('events:item-list', args=[self.slug])

    class Meta:
        ordering = ('title',)


class vCard(models.Model):
    uri = models.TextField()

    name = models.TextField(blank=True)
    address = models.TextField(blank=True)
    telephone = models.TextField(blank=True)
    location = models.PointField(null=True)
    entity = models.ForeignKey(Entity, null=True, blank=True)


class Series(models.Model):
    feed = models.ForeignKey(Feed)
    guid = models.TextField()
    title = models.TextField()
    unit = models.ForeignKey(vCard, null=True, blank=True)
    tags = models.ManyToManyField(Tag, blank=True)


class Item(models.Model):
    feed = models.ForeignKey(Feed)
    title = models.TextField(help_text=_("Title of feed item"))
    guid = models.TextField()
    description = models.TextField(help_text=_("Description of feed item"))
    link = models.URLField(help_text=_("URL to feed item"))
    last_modified = models.DateTimeField(null = True)  # this one is also in UTC

    ptype = models.CharField(max_length=16, choices=FEED_TYPE_CHOICES)

    organiser = models.ForeignKey(vCard, related_name='organising_set',
                                  null=True, blank=True)
    speaker = models.ForeignKey(vCard, related_name='speaking_set',
                                null=True, blank=True)
    venue = models.ForeignKey(vCard, related_name='venue_set',
                              null=True, blank=True)
    contact = models.ForeignKey(vCard, related_name='contact_set',
                                null=True, blank=True)

    series = models.ForeignKey(Series, null=True, blank=True)
    ordinal = models.IntegerField(null=True)
    track = models.TextField(blank=True)

    tags = models.ManyToManyField(Tag, blank=True)

    objects = models.Manager()
    events = EventsManager()
    news = NewsManager()

    dt_start = models.DateTimeField(null=True, blank=True)
    dt_end = models.DateTimeField(null=True, blank=True)
    dt_has_time = models.BooleanField(default=False)

    @property
    def location_mobile_url(self):
        return self.location_url.replace('/reviews/venue/',
                                         '/reviews/phone/venue/')

    @property
    def last_modified_local(self):
        try:
            return self.last_modified.replace(tzinfo=tzutc())\
                .astimezone(tzlocal())
        except Exception, e:
            return repr(e)

    def get_absolute_url(self):
        if self.ptype == 'n':
            return reverse('news:item-detail', args=[self.feed.slug, self.id])
        else:
            return reverse('events:item-detail',
                           args=[self.feed.slug, self.id])

    def get_description_display(self, device):
        html = etree.fromstring('<div>%s</div>' % self.description,
                                parser=etree.HTMLParser())
        for img in html.findall('.//img'):
            eis = resize_external_image(img.attrib['src'],
                                        device.max_image_width - 40)
            if eis != None:
                img.attrib['src'] = eis.get_absolute_url()
                img.attrib['width'] = '%d' % eis.width
                img.attrib['height'] = '%d' % eis.height
        return etree.tostring(html.find('.//div'), method="html")[5:-6]

    def save(self, *args, **kwargs):
        self.ptype = self.feed.ptype
        super(Item, self).save(*args, **kwargs)

    class Meta:
        ordering = ('-last_modified',)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from .views import IndexView, ItemListView, ItemDetailView

urlpatterns = patterns('',
   (r'^$',
       IndexView, {},
       'index'),
   (r'^(?P<slug>[a-z\-]+)/$',
       ItemListView, {},
       'item-list'),
   (r'^(?P<slug>[a-z\-]+)/(?P<id>\d+)/$',
       ItemDetailView, {},
       'item-detail'),
)
########NEW FILE########
__FILENAME__ = views
from datetime import timedelta
from xml.sax.saxutils import escape

from django.core.paginator import Paginator, EmptyPage, InvalidPage
from django.http import HttpResponse
from django.shortcuts import get_object_or_404
from django.utils.translation import ugettext as _
from django.utils.translation import get_language
from django.db.models import Q

from molly.utils.views import BaseView
from molly.utils.breadcrumbs import *

from ..models import Feed, Item

class IndexView(BaseView):
    def get_metadata(self, request):
        return {
            'title': _('News'),
            'additional': _('View news from across the University.'),
        }
        
    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name, None, _('News'), lazy_reverse('index')
        )
        
    def handle_GET(self, request, context):
        feeds = Feed.news.all()
        
        # Only actually care about showing feeds in the right language, not
        # dialect, so only match on before the -
        lang_code = get_language()
        if '-' in lang_code:
            lang_code = lang_code.split('-')[0]
        
        
        all_feeds = feeds.count()
        if 'all' not in request.GET:
            feeds = feeds.filter(
                Q(language__startswith=lang_code) | Q(language=None)
            )
        lang_feeds = feeds.count()
        
        context= {
            'feeds': feeds,
            'more_in_all': lang_feeds != all_feeds,
        }
        return self.render(request, context, 'feeds/news/index',
                           expires=timedelta(days=7))

class ItemListView(BaseView):
    def get_metadata(self, request, slug):
        feed = get_object_or_404(Feed.news, slug=slug)
        
        last_modified = feed.last_modified.strftime('%a, %d %b %Y') if feed.last_modified else _('never updated')
        return {
            'last_modified': feed.last_modified,
            'title': feed.title,
            'additional': '<strong>News feed</strong>, %s' % last_modified,
        }

    @BreadcrumbFactory
    def breadcrumb(self, request, context, slug):
        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('index'),
            'News feed',
            lazy_reverse('item-list', args=[slug])
        )
        
    def handle_GET(self, request, context, slug):
        feed = get_object_or_404(Feed.news, slug=slug)
        context['feed'] = feed
        context['feed_items'] = feed.item_set.all()
        return self.render(request, context, 'feeds/news/item_list')

class ItemDetailView(BaseView):
    def get_metadata(self, request, slug, id):
        item = get_object_or_404(Item, feed__slug=slug, id=id)
        
        last_modified = item.last_modified.strftime('%a, %d %b %Y') if item.last_modified else 'never updated'
        return {
            'last_modified': item.last_modified,
            'title': item.title,
            'additional': '<strong>News item</strong>, %s, %s' % (escape(item.feed.title), last_modified),
        }

    @BreadcrumbFactory
    def breadcrumb(self, request, context, slug, id):
        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('item-list', slug=slug),
            'News item',
            lazy_reverse('item-detail', args=[slug,id])
        )
        
    def handle_GET(self, request, context, slug, id):
        item = get_object_or_404(Item, feed__slug=slug, id=id)
        context.update({
            'item': item,
            'description': item.get_description_display(request.device)
        })
        return self.render(request, context, 'feeds/news/item_detail')

########NEW FILE########
__FILENAME__ = ical
from datetime import datetime, timedelta
import urllib2
import logging
from icalendar import Calendar
from icalendar.prop import vDatetime, vDate, vText
import socket
socket.setdefaulttimeout(5)

from molly.external_media import sanitise_html
from molly.conf.provider import task

from molly.apps.feeds.providers import BaseFeedsProvider

__all__ = ['ICalFeedsProvider']

logger = logging.getLogger(__name__)


class ICalFeedsProvider(BaseFeedsProvider):
    """
    This is a basic iCal feeds provider.
    Tested with Google Calendar feeds.
    Doesn't react well with non standard iCal feeds.
    """
    verbose_name = 'iCal'

    @task(run_every=timedelta(minutes=60))
    def import_data(self, **metadata):
        """
        Pulls iCal feeds
        """
        from molly.apps.feeds.models import Feed
        for feed in Feed.objects.filter(provider=self.class_path):
            logger.debug("Importing: %s - %s" % (feed.title, feed.rss_url))
            self.import_feed.delay(feed)
        return metadata

    @task()
    def import_feed(self, feed):
        from molly.apps.feeds.models import Item, vCard

        calendar = Calendar.from_string(urllib2.urlopen(feed.rss_url).read())

        items = set()
        for component in calendar.walk():

            if component.name == 'VEVENT':
                item, created = Item.objects.get_or_create(feed=feed,
                        guid=str(component.get('UID')))
                # Do not create the event if one the property is not correct,
                # first tries to parse DT as datetime then as date, if it still
                # fails, then ignore
                try:
                    try:
                        item.dt_start = vDatetime.from_ical(str(
                            component.get('DTSTART')))
                    except ValueError, ve:
                        item.dt_start = vDate.from_ical(str(
                            component.get('DTSTART')))

                    if component.get('DTEND'):
                        try:
                            item.dt_end = vDatetime.from_ical(str(
                                component.get('DTEND')))
                        except ValueError, ve:
                            item.dt_end = vDate.from_ical(str(
                                component.get('DTEND')))

                    item.title = vText.from_ical(str(
                        component.get('SUMMARY')).strip())

                    if component.get('URL'):
                        item.link = str(component.get('URL'))

                    if component.get('DESCRIPTION'):
                        item.description = sanitise_html(vText.from_ical(str(
                            component.get('DESCRIPTION'))))

                    if str(component.get('LOCATION')) != '':
                        location, created = vCard.objects.get_or_create(
                                name=vText.from_ical(str(
                                    component.get('LOCATION')).strip()))
                        # in the future, we could imagine to (try to) geocode
                        # the location to get a point field...
                        location.save()
                        item.venue = location

                    try:
                        item.last_modified = vDatetime.from_ical(str(
                            component.get('LAST-MODIFIED')))
                    except Exception, e:
                        item.last_modified = datetime.now()

                    item.save()
                    items.add(item)
                except ValueError, v:
                    logger.error('Could not parse event %s' % v)

        for item in Item.objects.filter(feed=feed):
            if item not in items:
                item.delete()

        return items

########NEW FILE########
__FILENAME__ = rss
from datetime import datetime, timedelta
import feedparser
import time
import logging
import socket
socket.setdefaulttimeout(5)

from molly.external_media import sanitise_html
from molly.conf.provider import task

from molly.apps.feeds.providers import BaseFeedsProvider

__all__ = ['RSSFeedsProvider']


def parse_date(s):
    return struct_to_datetime(feedparser._parse_date(s))


def struct_to_datetime(s):
    return datetime.fromtimestamp(time.mktime(s))

logger = logging.getLogger(__name__)


class RSSFeedsProvider(BaseFeedsProvider):
    verbose_name = 'RSS'

    @task(run_every=timedelta(minutes=60))
    def import_data(self, **metadata):
        """
        Pulls RSS feeds
        """

        from molly.apps.feeds.models import Feed
        for feed in Feed.objects.filter(provider=self.class_path):
            logger.debug("Importing: %s - %s" % (feed.title, feed.rss_url))
            self.import_feed.delay(feed)
        return metadata

    @task(default_retry_delay=5, max_retries=3)
    def import_feed(self, feed):
        from molly.apps.feeds.models import Item

        feed_data = feedparser.parse(feed.rss_url)
        try:
            feed.last_modified = \
                struct_to_datetime(feed_data.feed.updated_parsed)
        except:
            feed.last_modified = \
                parse_date(feed_data.headers.get('last-modified',
                    datetime.now().strftime("%a, %d %b %Y %H:%M:%S +0000")))

        feed.save(update_last_modified=True)

        items = set()
        for x_item in feed_data.entries:
            if hasattr(x_item, 'id'):
                guid = x_item.id
            else:
                # Some stupid feeds don't have any GUIDs, fall back to the URL
                # and hope it's unique
                guid = x_item.link

            try:
                last_modified = datetime(*x_item.date_parsed[:7])
            except:
                last_modified = None

            for i in items:
                if i.guid == guid:
                    item = i
                    break
            else:
                try:
                    item = Item.objects.get(guid=guid, feed=feed)
                except Item.DoesNotExist:
                    item = Item(guid=guid,
                        last_modified=datetime(1900, 1, 1), feed=feed)

            if True or item.last_modified < last_modified:
                item.title = x_item.title
                item.description = sanitise_html(x_item.get('description', ''))
                item.link = x_item.link
                item.last_modified = last_modified
                item.save()

            items.add(item)

        for item in Item.objects.filter(feed=feed):
            if item not in items:
                item.delete()

########NEW FILE########
__FILENAME__ = talks_cam
from datetime import datetime, timedelta
from lxml import etree
import urllib2
import logging
import socket
socket.setdefaulttimeout(5)

from molly.external_media import sanitise_html
from molly.conf.provider import task

from molly.apps.feeds.providers import BaseFeedsProvider

__all__ = ['TalksCamFeedsProvider']

logger = logging.getLogger(__name__)


class TalksCamFeedsProvider(BaseFeedsProvider):
    verbose_name = 'TalksCam'

    @task(run_every=timedelta(minutes=60))
    def import_data(self, **metadata):
        """
        Pulls TalksCam feeds
        """
        from molly.apps.feeds.models import Feed
        for feed in Feed.objects.filter(provider=self.class_path):
            logger.debug("Importing: %s - %s" % (feed.title, feed.rss_url))
            self.import_feed.delay(feed)
        return metadata

    @task()
    def import_feed(self, feed):
        from molly.apps.feeds.models import Item, vCard

        xml = etree.parse(urllib2.urlopen(feed.rss_url))

        feed.last_modified = datetime.now()
        feed.save(update_last_modified=True)

        items = set()
        for talk in xml.findall('talk'):
            item, created = Item.objects.get_or_create(feed=feed, guid=talk.find('id').text)

            item.last_modified = self.parse_date(talk.find('updated_at').text)
            item.title = talk.find('title').text.strip()
            item.description = sanitise_html(talk.find('abstract').text.strip())
            item.link = talk.find('url').text
            item.dt_start = self.parse_date(talk.find('start_time').text)
            item.dt_end = self.parse_date(talk.find('end_time').text)
            
            location, created = vCard.objects.get_or_create(name=talk.find('venue').text.strip())
            location.save()
            item.venue = location
            
            item.save()

            items.add(item)

        for item in Item.objects.filter(feed=feed):
            if item not in items:
                item.delete()

        return items

    def parse_date(self, date):
        """
        Parse date as Tue, 21 Feb 2012 23:49:34 +0000
        """
        return datetime.strptime(date[:-6], "%a, %d %b %Y %H:%M:%S")

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from models import *

admin.site.register(UserMessage)

########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.forms.models import modelformset_factory

from models import UserMessage

class UserMessageForm(forms.ModelForm):
    fields = ()
    
UserMessageFormSet = modelformset_factory(
    UserMessage, UserMessageForm,
    extra=0, can_delete=True)




########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Config'
        db.create_table('home_config', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('key', self.gf('django.db.models.fields.SlugField')(max_length=50, db_index=True)),
            ('value', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('home', ['Config'])

        # Adding model 'UserMessage'
        db.create_table('home_usermessage', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('session_key', self.gf('django.db.models.fields.TextField')()),
            ('message', self.gf('django.db.models.fields.TextField')()),
            ('read', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('when', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
        ))
        db.send_create_signal('home', ['UserMessage'])


    def backwards(self, orm):
        
        # Deleting model 'Config'
        db.delete_table('home_config')

        # Deleting model 'UserMessage'
        db.delete_table('home_usermessage')


    models = {
        'home.config': {
            'Meta': {'object_name': 'Config'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'value': ('django.db.models.fields.TextField', [], {})
        },
        'home.usermessage': {
            'Meta': {'object_name': 'UserMessage'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message': ('django.db.models.fields.TextField', [], {}),
            'read': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'session_key': ('django.db.models.fields.TextField', [], {}),
            'when': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['home']

########NEW FILE########
__FILENAME__ = models
from django.contrib.gis.db import models

class Config(models.Model):
    key = models.SlugField()
    value = models.TextField()

class UserMessage(models.Model):
    session_key = models.TextField()
    message = models.TextField()
    read = models.BooleanField(default=False)
    when = models.DateTimeField(auto_now_add=True)


########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from .views import (
    IndexView, UserMessageView,
    StaticDetailView,
)

urlpatterns = patterns('',

    (r'^$',
        IndexView, {},
        'index'),
    
    (r'^about/$',
        StaticDetailView,
        {'title':'About', 'template':'about'},
        'static_about'),

    (r'^messages/$',
        UserMessageView, {},
        'messages'),
        
)

########NEW FILE########
__FILENAME__ = views
from datetime import datetime, timedelta

from django.http import HttpResponse
from django.core.urlresolvers import reverse
from django.conf import settings
from django.template import loader, Context, RequestContext
from django import forms
from django.shortcuts import render_to_response
from django.utils.translation import ugettext as _

from molly.utils.views import BaseView
from molly.utils.breadcrumbs import *
from molly.favourites import get_favourites
from molly.wurfl import device_parents
from molly.conf.applications import app_by_application_name, has_app_by_application_name, has_app, all_apps
from molly.apps.weather.models import Weather

from models import UserMessage
from forms import UserMessageFormSet

class IndexView(BaseView):
    """
    Renders the portal home page
    """

    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(self.conf.local_name,
                          None,
                          _('Home'),
                          lazy_reverse('index'))

    def handle_GET(self, request, context):
        # Check whether the referer header is from the same host as the server
        # is responding as
        try:
            referer_host = request.META.get('HTTP_REFERER', '').split('/')[2]
            internal_referer = referer_host == request.META.get('HTTP_HOST')
        except IndexError:
            internal_referer = False

        # Redirects if the user is a desktop browser who hasn't been referred
        # from this site. Also extra checks for preview mode and DEBUG.
        if ("generic_web_browser" in device_parents[request.device.devid]
            and not request.session.get('home:desktop_shown', False)
            and not request.GET.get('preview') == 'true'
            and not internal_referer
            and not settings.DEBUG
            and has_app('molly.apps.desktop')
            and request.REQUEST.get('format') is None):
            return self.redirect(reverse('desktop:index'), request)
        
        messages = []
        # Add any one-off messages to be shown to this user
        if UserMessage.objects.filter(
                read=False, session_key=request.session.session_key).count():
            messages.append({
                'url': reverse('home:messages'),
                'body': _('You have a message from the developers')
            })
        
        # Warn users who use Opera devices
        if not request.session.get('home:opera_mini_warning', False) \
          and request.browser.mobile_browser == u'Opera Mini':
            messages.append(
                { 'body': _("""Please note that the "Mobile View" on Opera Mini does not display this site correctly. To ensure correct operation of this site, ensure "Mobile View" is set to Off in Opera settings""") })
            request.session['home:opera_mini_warning'] = True
        
        if has_app_by_application_name('molly.apps.weather'):
            weather_id = app_by_application_name('molly.apps.weather').location_id
            try:
                weather = Weather.objects.get(ptype='o', location_id=weather_id)
            except Weather.DoesNotExist:
                weather = None
        else:
            weather = None
        
        applications = [{
            'application_name': app.application_name,
            'local_name': app.local_name,
            'title': app.title,
            'url': reverse('%s:index' % app.local_name) \
                    if app.has_urlconf else None,
            'display_to_user': app.display_to_user,
        } for app in all_apps()]

        # Add accesskeys to the first 9 apps to be displayed to the user
        for i, app in enumerate(
                [app for app in applications if app['display_to_user']][:9]
            ):
            app['accesskey'] = i + 1

        context = {
            'applications': applications,
            'hide_feedback_link': True,
            'messages': messages,
            'favourites': get_favourites(request),
            'weather': weather,
        }
        return self.render(request, context, 'home/index',
                           expires=timedelta(minutes=10))

    def get_metadata(self, request):
        return {
            'exclude_from_search': True,
        }

    def handle_POST(self, request, context):
        no_desktop_about = request.POST.get('no_desktop_about')
        if no_desktop_about  == 'true':
            request.session['home:desktop_about_shown'] = True
        elif no_desktop_about  == 'false':
            request.session['home:desktop_about_shown'] = False

        return self.redirect(reverse('home:index'), request)

class StaticDetailView(BaseView):
    @BreadcrumbFactory
    def breadcrumb(self, request, context, title, template):
        return Breadcrumb(
            self.conf.local_name, None, title,
            lazy_reverse('static', args=[template])
        )

    def handle_GET(self, request, context, title, template):
        t = loader.get_template('static/%s.html' % template)

        context.update({
            'title': title,
            'content': t.render(Context()),
        })
        return self.render(request, context, 'home/static_detail',
                           expires=timedelta(days=365))

class UserMessageView(BaseView):
    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name, None, _('View messages from the developers'),
            lazy_reverse('messages')
        )

    def initial_context(self, request):
        try:
            formset = UserMessageFormSet(
                request.POST or None,
                queryset=UserMessage.objects.filter(
                    session_key=request.session.session_key
                )
            )
        except forms.ValidationError:
            formset = UserMessageFormSet(
                None,
                queryset=UserMessage.objects.filter(
                    session_key=request.session.session_key
                )
            )
        return {
            'formset': formset,
        }

    def handle_GET(self, request, context):
        messages = UserMessage.objects.filter(
                session_key=request.session.session_key
            )
        messages.update(read=True)
        return self.render(request, context, 'home/messages')

    def handle_POST(self, request, context):
        if context['formset'].is_valid():
            context['formset'].save()

        return self.redirect(reverse('home:messages'), request)

########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.utils.translation import ugettext_lazy as _

class SearchForm(forms.Form):
    author = forms.CharField(required=False, label=_("Author"))
    title = forms.CharField(required=False, label=_("Title"))
    isbn = forms.CharField(required=False, label=_("ISBN"))
    
########NEW FILE########
__FILENAME__ = models
from django.http import Http404
from django.utils.translation import ugettext as _

from molly.conf.applications import app_by_local_name
from molly.apps.places import get_entity
from molly.apps.places.models import Entity

class LibrarySearchQuery:
    """
    An object which gets passed to library search providers containing a library
    search query
    """
    
    STOP_WORDS = frozenset( (
    # Translators: A list of stop words to be filtered out during library searches
    _("a,able,about,across,after,all,almost,also,am,among,an,and,any,are,as,at,be,because,been,but,by,can,cannot,could,dear,did,do,does,either,else,ever,every,for,from,get,got,had,has,have,he,her,hers,him,his,how,however,i,if,in,into,is,it,its,just,least,let,like,likely,may,me,might,most,must,my,neither,no,nor,not,of,off,often,on,only,or,other,our,own,rather,said,say,says,she,should,since,so,some,than,that,the,their,them,then,there,these,they,this,tis,to,too,twas,us,wants,was,we,were,what,when,where,which,while,who,whom,why,will,with,would,yet,you,your")).split(',') )
    
    class InconsistentQuery(ValueError):
        def __init__(self, msg):
            self.msg = msg
        
    @staticmethod
    def _clean_isbn(isbn):
        """
        Tidy up ISBN input - limit to only allowed characters, replacing * with
        X
        """
        
        # Replace * with X
        isbn = isbn.replace('*', 'X')
        
        # Replace extroneous characters
        isbn = ''.join(c for c in isbn if (c in '0123456789X'))
        
        return isbn
    
    @staticmethod
    def _clean_input(input):
        """
        Remove stop words from the input
        
        @return: The cleaned string and a set of removed stop words
        @rtype: str, frozenset
        """
        
        # Cheap and nasty tokenisation
        cleaned = []
        removed = set()
        for word in input.split(' '):
            if word in LibrarySearchQuery.STOP_WORDS:
                removed.add(word)
            else:
                cleaned.append(word)
        return ' '.join(cleaned), frozenset(removed)
    
    def __init__(self, title=None, author=None, isbn=None, issn=None):
        """
        @param title: The title of the book to search for
        @type title: str or None
        @param author: The author of the book to search for
        @type author: str or None
        @param isbn: an ISBN number to search for - can contain * in place of X.
        @type isbn: str or None
        @param issn: an ISSN number to search for - can contain * in place of X.
        @type issn: str or None
        @raise LibrarySearchQuery.InconsistentQuery: If the query parameters are
            inconsistent (e.g., isbn specified alongside title and author, or no
            queries present)
        """
        
        if isbn and issn:
            raise self.InconsistentQuery(
                _("You cannot specify both an ISBN and an ISSN."))
        
        if (title or author) and (isbn or issn):
            raise self.InconsistentQuery(
                _("You cannot specify both an ISBN and a title or author."))
        
        if not (title or author or isbn or issn):
            raise self.InconsistentQuery(
                _("You must supply some subset of title or author, and ISBN."))
        
        self.removed = set()
        
        if title:
            self.title, removed = self._clean_input(title)
            self.removed |= removed
        else:
            self.title = None
        
        if author:
            self.author, removed = self._clean_input(author)
            self.removed |= removed
        else:
            self.author = None
        
        if isbn:
            self.isbn = self._clean_isbn(isbn)
        else:
            self.isbn = None
        
        if issn:
            self.issn = self._clean_isbn(issn)
        else:
            self.issn = None


class LibrarySearchResult(object):
    """
    An object holding an individual result from a search
    """
    
    id = ''
    """
    @ivar id: A unique ID to reference this item in the database
    @type id: str
    """
    
    title = ''
    """
    @ivar title: The title of this book
    @type title: str
    """
    
    publisher = ''
    """
    @ivar publisher: The publisher of this book
    @type publisher: str
    """
    
    author = ''
    """
    @ivar author: The author(s) of this book
    @type author: str
    """
    
    description = ''
    """
    @ivar description: A description of this book
    @type description: str
    """
    
    edition = ''
    """
    @ivar edition: The edition of this book
    @type edition: str
    """
    
    copies = 0
    """
    @ivar copies: The number of copies of this book held
    @type copies: int
    """
    
    holding_libraries = 0
    """
    @ivar holding_libraries: The number of libraries which hold copies of this
                             book
    @type holding_libraries: int
    """
    
    isbns = []
    """
    @ivar isbns: The ISBNs associated with this item
    @type isbns: list of strings
    """
    
    issns = []
    """
    @ivar isbns: The ISSNs associated with this item
    @type isbns: list of strings
    """
    
    holdings = {}
    """
    @ivar holdings: A dictionary where library names are keys and the value is
                    a list of dictionaries, one for each copy of the item held.
                    This dictionary has the following keys: due (the due date),
                    availability (one of the AVAIL_ keys below),
                    availability_display (the display text for availability
                    status) and materials_specified (an additional value
                    typically indicating what issue of a copy this is)
    @type holdings: dict
    """
    
    AVAIL_UNAVAILABLE, AVAIL_UNKNOWN, AVAIL_STACK, AVAIL_REFERENCE, \
    AVAIL_AVAILABLE = range(5)

    def simplify_for_render(self, simplify_value, simplify_model):
        return {
            '_type': 'library.LibrarySearchResult',
            '_pk': self.id,
            'control_number': self.control_number,
            'title': self.title,
            'publisher': self.publisher,
            'author': self.author,
            'description': self.description,
            'edition': self.edition,
            'copies': self.copies,
            'holding_libraries': self.holding_libraries,
            'isbns': simplify_value(self.isbns),
            'issns': simplify_value(self.issns),
            'holdings': simplify_value(self.libraries),
        }

    def __unicode__(self):
        return self.title


class Library(object):
    """
    An object representing a library (used in holdings)
    
    @ivar location: an identifier for this library
    """
    
    def __init__(self, location):
        self.location = tuple(location)
    
    def __unicode__(self):
        return "/".join(self.location)
    __repr__ = __unicode__

    def __hash__(self):
        return hash((type(self), self.location))

    def __eq__(self, other):
        return self.location == other.location
    
    def get_entity(self):
        """
        Gets the entity for this library. This look up is done using the
        identifier namespace defined in the config. Returns None if no
        identifier can be found.
        """
        if hasattr(app_by_local_name('library'), 'library_identifier'):
            library_identifier = app_by_local_name('library').library_identifier
            try:
                return get_entity(library_identifier, '/'.join(self.location))
            except (Http404, Entity.MultipleObjectsReturned):
                return None
        else:
            return None

    def simplify_for_render(self, simplify_value, simplify_model):
        entity = self.get_entity()
        return {
            '_type': 'library.Library',
            'location_code': simplify_value(self.location),
            'entity': simplify_value(entity),
            'display_name': entity.title if entity else "/".join(self.location),
        }
    


class LibrarySearchError(Exception):
    
    def __init__(self, message):
        self.message = message
    
    def __repr__(self):
        return '%s: %s' % (self.__class__.__name__, self.message)

########NEW FILE########
__FILENAME__ = google
import simplejson
from urllib import quote_plus
from urllib2 import urlopen, HTTPError
from logging import getLogger

from django.conf import settings

from molly.apps.library.providers import BaseMetadataProvider

logger = getLogger(__name__)

class GoogleBooksProvider(BaseMetadataProvider):
    
    # There's a double % here, because this is going to be sprintf'd twice -
    # once now, and then once later to build the query
    BOOK_SEARCH_ENDPOINT = 'https://www.googleapis.com/books/v1/volumes?q=%%s&key=%s' % settings.API_KEYS.get('google_books', '')
    
    def annotate(self, books):
        """
        @param books: The books to be annotated
        @type books: [LibrarySearchResult]
        @rtype: None
        """

        for book in books:
            # ISBNs from OLIS aren't always well-formed
            for isbn in [isbn.split()[0] for isbn in book.isbns]:
                try:
                    results = simplejson.load(
                        urlopen(self.BOOK_SEARCH_ENDPOINT % quote_plus(isbn)))
                    result = results['items'][0]
                except HTTPError, KeyError:
			logger.info('Google Books lookup failed', exc_info=True)
                else:
                    # Get the image
                    image_links = result.get('volumeInfo',{}
                                             ).get('imageLinks', [])

                    # Find the biggest one we have as a basis for resize
                    for image_size in ('extraLarge', 'large', 'medium',
                                       'small', 'thumbnail',
                                       'smallThumbnail'):
                        if image_size in image_links:
                            book.cover_image = image_links[image_size]
                            break

                    # Annotate epub link
                    book.epub = result.get('accessInfo', {}).get(
                        'epub', {}).get('downloadLink')

                    # Annotate PDF link
                    book.pdf = result.get('accessInfo', {}).get(
                        'pdf', {}).get('downloadLink')

                    # This ISBN got us a cover image, don't look up anymore
                    if hasattr(book, 'cover_image'):
                        break

########NEW FILE########
__FILENAME__ = z3950
from datetime import datetime
from xml.dom import minidom

from PyZ3950 import zoom
from PyZ3950.zmarc import MARC, MARC8_to_Unicode

from django.utils.translation import ugettext_lazy

from molly.apps.library.models import (LibrarySearchResult, Library,
                                       LibrarySearchError)
from molly.apps.library.providers import BaseLibrarySearchProvider

class SearchResult(LibrarySearchResult):
    
    AVAILABILITIES = {
        'Available': LibrarySearchResult.AVAIL_AVAILABLE,
        'Reference': LibrarySearchResult.AVAIL_REFERENCE,
        'Confined': LibrarySearchResult.AVAIL_REFERENCE,
        'Check shelf': LibrarySearchResult.AVAIL_UNKNOWN,
        'Please check shelf': LibrarySearchResult.AVAIL_UNKNOWN,
        'In place': LibrarySearchResult.AVAIL_STACK,
        'Missing': LibrarySearchResult.AVAIL_UNAVAILABLE,
        'Temporarily missing': LibrarySearchResult.AVAIL_UNAVAILABLE,
        'Reported Missing': LibrarySearchResult.AVAIL_UNAVAILABLE,
        'Withdrawn': LibrarySearchResult.AVAIL_UNAVAILABLE,
        '': LibrarySearchResult.AVAIL_UNKNOWN,
    }


class USMARCSearchResult(SearchResult):
    USM_CONTROL_NUMBER = 1
    USM_ISBN = 20
    USM_ISSN = 22
    USM_AUTHOR = 100
    USM_TITLE_STATEMENT = 245
    USM_EDITION = 250
    USM_PUBLICATION = 260
    USM_PHYSICAL_DESCRIPTION = 300
    USM_LOCATION = 852

    def __init__(self, result, results_encoding):
        self.str = str(result)
        self.metadata = {self.USM_LOCATION: []}

        items = self.str.split('\n')[1:]
        for item in items:
            heading, data = item.split(' ', 1)
            heading = int(heading)
            if heading == self.USM_CONTROL_NUMBER:
                self.control_number = data

            # We'll use a slice as data may not contain that many characters.
            # LCN 12110145 is an example where this would otherwise fail.
            if data[2:3] != '$':
                continue

            subfields = data[3:].split(' $')
            subfields = [(s[0], s[1:]) for s in subfields]

            if not heading in self.metadata:
                self.metadata[heading] = []

            m = {}
            for subfield_id, content in subfields:
                if not subfield_id in m:
                    m[subfield_id] = []
                m[subfield_id].append(content)
            self.metadata[heading].append(m)
        
        if results_encoding == 'marc8':
            self.metadata = marc_to_unicode(self.metadata)

        self.libraries = {}

        for datum in self.metadata[self.USM_LOCATION]:
            library = Library(datum['b'] + datum.get('c', []))
            if not 'p' in datum:
                availability = LibrarySearchResult.AVAIL_UNKNOWN
                datum['y'] = ['Check web OPAC']
                due_date = None
            elif not 'y' in datum:
                due_date = None
                availability = LibrarySearchResult.AVAIL_UNKNOWN
            elif datum['y'][0].startswith('DUE BACK: '):
                due_date = datetime.strptime(datum['y'][0][10:], '%d/%m/%y')
                availability = LibrarySearchResult.AVAIL_UNAVAILABLE
            else:
                due_date = None
                availability = self.AVAILABILITIES.get(datum['y'][0],
                                    LibrarySearchResult.AVAIL_UNAVAILABLE)

            if 'h' in datum:
                shelfmark = datum['h'][0]
                if 't' in datum:
                    shelfmark = "%s (copy %s)" % (shelfmark, datum['t'][0])
            elif 't' in datum:
                shelfmark = "Copy %s" % datum['t'][0]
            else:
                shelfmark = None

            materials_specified = datum['3'][0] if '3' in datum else None

            if not library in self.libraries:
                self.libraries[library] = []
            self.libraries[library].append( {
                'due': due_date,
                'availability': availability,
                'availability_display': ugettext_lazy(datum['y'][0]) if 'y' in datum else None,
                'shelfmark': shelfmark,
                'materials_specified': materials_specified,
            } )

        for library in self.libraries:
            library.availability = max(l['availability'] for l in self.libraries[library])

    def _metadata_property(heading, sep=' '):
        def f(self):
            if not heading in self.metadata:
                    return None
            field = self.metadata[heading][0]
            return sep.join(' '.join(field[k]) for k in sorted(field))
        return property(f)

    title = _metadata_property(USM_TITLE_STATEMENT)
    publisher = _metadata_property(USM_PUBLICATION)
    author = _metadata_property(USM_AUTHOR)
    description = _metadata_property(USM_PHYSICAL_DESCRIPTION)
    edition = _metadata_property(USM_EDITION)
    copies = property(lambda self: len(self.metadata[self.USM_LOCATION]))
    holding_libraries = property(lambda self: len(self.libraries))
    
    @property
    def isbns(self):
        if self.USM_ISBN in self.metadata:
            return [a.get('a', ["%s (invalid)" % a.get('z', ['Unknown'])[0]])[0] for a in self.metadata[self.USM_ISBN]]
        else:
            return []

    @property
    def issns(self):
        if self.USM_ISSN in self.metadata:
            return [a['a'][0] for a in self.metadata[self.USM_ISSN]]
        else:
            return []


def get_text(nodelist):
    rc = []
    for node in nodelist:
        if node.nodeType == node.TEXT_NODE:
            rc.append(node.data)
    return ''.join(rc)


class XMLSearchResult(SearchResult):
    
    COPAC_HOLDINGS_NS = 'http://copac.ac.uk/schemas/holdings/v1'
    
    def _handleRecordInfo(self, node):
        for child in node.childNodes:
            if child.nodeType == child.ELEMENT_NODE and child.tagName == 'recordIdentifier':
                self.id = get_text(child.childNodes)
                self.control_number = self.id
    
    def _handleOriginInfo(self, node):
        for child in node.childNodes:
            if child.nodeType == child.ELEMENT_NODE:
                if child.tagName == 'edition':
                    self.edition = get_text(child.childNodes)
                elif child.tagName == 'publisher':
                    self.publisher = get_text(child.childNodes)
    
    def _handleTitleInfo(self, node):
        for child in node.childNodes:
            if child.nodeType == child.ELEMENT_NODE and child.tagName == 'title':
                self.title = get_text(child.childNodes)
    
    def _handleName(self, node):
        for child in node.childNodes:
            if child.nodeType == child.ELEMENT_NODE and child.tagName == 'namePart':
                self.author.append(get_text(child.childNodes))
    
    def _handlePhysicalDescription(self, node):
        for child in node.childNodes:
            if child.nodeType == child.ELEMENT_NODE and child.tagName == 'extent':
                self.description = get_text(child.childNodes)
    
    def _handleIdentifier(self, node):
        if node.getAttribute('type') == 'isbn':
            self.isbns.append(get_text(node.childNodes))
        elif node.getAttribute('type') == 'issn':
            self.issns.append(get_text(node.childNodes))
    
    def _handleCOPACHoldings(self, node):
        if node.localName == 'localHolds':
            self._handleCOPACLocation(node)
    
    def _handleCOPACLocation(self, node):
        location = None
        location_code = None
        libraries = []
        for child in node.childNodes:
            if child.localName == 'org':
                location_code = get_text(child.childNodes)
                location = child.getAttribute('displayName')
            elif child.localName == 'holds':
                libraries += self._handleCOPACGetLibraries(child)
        
        for library_name, library_code, shelfmark, note in libraries:
            library = Library((location + ' - ' + library_name, location_code + ':' + library_code))
            if library not in self.libraries:
                self.libraries[library] = []
            self.libraries[library].append( {
                'due': None,
                'availability': LibrarySearchResult.AVAIL_UNKNOWN,
                'availability_display': ugettext_lazy('Availability Unknown'),
                'shelfmark': shelfmark,
                'materials_specified': note,
            } )
    
    def _handleCOPACGetLibraries(self, node):
        libraries = []
        for child in node.childNodes:
            if child.localName == 'item':
                libraries.append(self._handleCOPACGetLibrary(child))
        return libraries
    
    def _handleCOPACGetLibrary(self, node):
        location = None
        location_code = None
        shelfmark = None
        note = None
        for child in node.childNodes:
            if child.localName == 'loc':
                location_code = get_text(child.childNodes)
                location = child.getAttribute('displayName')
            elif child.localName == 'shelfmark':
                shelfmark = get_text(child.childNodes)
            elif child.localName == 'copyNote':
                note = get_text(child.childNodes)
        
        return (location, location_code, shelfmark, note)
    
    def __init__(self, result, results_encoding):
    
        self.id = ''
        self.control_number = ''
        self.title = ''
        self.publisher = ''
        self.author = []
        self.description = ''
        self.edition = ''
        self.isbns = []
        self.issns = []
        self.libraries = {}
    
        xml = minidom.parseString(str(result)[9:])
        for node in xml.documentElement.childNodes:
            if node.nodeType == node.ELEMENT_NODE:
                if node.tagName == 'recordInfo':
                    self._handleRecordInfo(node)
                elif node.tagName == 'originInfo':
                    self._handleOriginInfo(node)
                elif node.tagName == 'titleInfo':
                    self._handleTitleInfo(node)
                elif node.tagName == 'name':
                    self._handleName(node)
                elif node.tagName == 'physicalDescription':
                    self._handlePhysicalDescription(node)
                elif node.tagName == 'identifier':
                    self._handleIdentifier(node)
                elif node.tagName == 'extension':
                    for child in node.childNodes:
                        if child.namespaceURI == self.COPAC_HOLDINGS_NS:
                            self._handleCOPACHoldings(child)
        
        self.author = ' / '.join(self.author)
        self.copies = sum((len(holdings) for holdings in self.libraries.values()))
        self.holding_libraries = len(self.libraries)


class Z3950(BaseLibrarySearchProvider):
    
    class Results:
        """
        A thing that pretends to be a list for lazy parsing of search results
        """
        
        def __init__(self, results, wrapper, results_encoding):
            self.results = results
            self._wrapper = wrapper
            self._results_encoding = results_encoding
        
        def __iter__(self):
            for result in self.results:
                yield self._wrapper(result,
                                    results_encoding=self._results_encoding)
        
        def __len__(self):
            return len(self.results)
        
        def __getitem__(self, key):
            if isinstance(key, slice):
                if key.step:
                    raise NotImplementedError("Stepping not supported")
                return (self._wrapper(r, results_encoding=self._results_encoding) \
                        for r in self.results.__getslice__(key.start, key.stop))
            else:
                return self._wrapper(self.results[key],
                                     results_encoding=self._results_encoding)
    
    def __init__(self, host, database, port=210, syntax='USMARC',
                 charset='UTF-8', control_number_key='12',
                 results_encoding='marc8'):
        """
        @param host: The hostname of the Z39.50 instance to connect to
        @type host: str
        @param database: The database name
        @type database: str
        @param port: An optional port for the Z39.50 database
        @type port: int
        @param syntax: The Z39.50 syntax to use, or an object which does parsing
                       of the result
        @type syntax: str or object
        @param charset: The charset to make the connection in
        @type charset: str
        @param control_number_key: The use attribute for the control number when
                                   querying
        @param results_encoding: The encoding (either unicode or marc8) of data
                                 this server returns
        """
        
        # Could create a persistent connection here
        self._host = host
        self._database = database
        self._port = port
        self._syntax = syntax
        self._wrapper = {
            'USMARC': USMARCSearchResult,
            'XML': XMLSearchResult,
        }.get(syntax, syntax)
        self._control_number_key = control_number_key
        self._charset = charset
        self._results_encoding = results_encoding
    
    def _make_connection(self):
        """
        Returns a connection to the Z39.50 server
        """
        # Create connection to database
        connection = zoom.Connection(
            self._host,
            self._port,
            charset = self._charset,
        )
        connection.databaseName = self._database
        connection.preferredRecordSyntax = self._syntax
        
        return connection
    
    def library_search(self, query):
        """
        @param query: The query to be performed
        @type query: molly.apps.library.models.LibrarySearchQuery
        @return: A list of results
        @rtype: [LibrarySearchResult]
        """
        
        connection = self._make_connection()
        
        # Convert Query object into a Z39.50 query - we escape for the query by
        # removing quotation marks
        z3950_query = []
        if query.author != None:
            z3950_query.append('(au="%s")' % query.author.replace('"', ''))
        if query.title != None:
            z3950_query.append('(ti="%s")' % query.title.replace('"', ''))
        if query.isbn != None:
            z3950_query.append('(isbn="%s")' % query.isbn.replace('"', ''))
        if query.issn != None:
            z3950_query.append('((1,8)="%s")' % query.issn.replace('"', ''))
        
        z3950_query = zoom.Query('CCL', 'and'.join(z3950_query))
        
        try:
            results = self.Results(connection.search(z3950_query),
                                   self._wrapper, self._results_encoding)
        except zoom.Bib1Err as e:
            # 31 = Resources exhausted - no results available 
            if e.condition in (31,):
                return []
            else:
                raise LibrarySearchError(e.message)
        else:
            return results
    
    def control_number_search(self, control_number):
        """
        @param control_number: The unique ID of the item to be looked up
        @type control_number: str
        @return: The item with this control ID, or None if none can be found
        @rtype: LibrarySearchResult
        """
        
        # Escape input
        control_number = control_number.replace('"', '')
        
        z3950_query = zoom.Query(
            'CCL', '(1,%s)="%s"' % (self._control_number_key, control_number))
        connection = self._make_connection()
        results = self.Results(connection.search(z3950_query), self._wrapper,
                               self._results_encoding)
        if len(results) > 0:
            return results[0]
        else:
            return None


def marc_to_unicode(x):
    translator = MARC8_to_Unicode()
    def f(y):
        if isinstance(y, dict):
            return dict((k,f(y[k])) for k in y)
        elif isinstance(y, tuple):
            return tuple(f(e) for e in y)
        elif isinstance(y, list):
            return [f(e) for e in y]
        elif isinstance(y, str):
            if any((ord(c) > 127) for c in y):
                # "The ESC character 0x1B is mapped to the no-break space
                #  character, unless it is part of a valid ESC sequence"
                #      -- http://unicode.org/Public/MAPPINGS/ETSI/GSM0338.TXT
                return translator.translate(y).replace(u'\x1b', u'\xa0')
            else:
                return y.decode('ascii').replace(u'\x1b', u'\xa0')
    return f(x)


########NEW FILE########
__FILENAME__ = search
import simplejson
import re
from itertools import cycle

from django.core.urlresolvers import reverse

from molly.apps.library.models import LibrarySearchQuery

def validate_isxn(s):

    def encode(s):
        return ''.join(str(d) if d < 10 else 'X' for d in s)
    def decode(s):
        return [10 if d=='X' else int(d) for d in s]
    def isxn_checksum(s, initial=None):
        if not initial:
            initial = len(s)
        cs = 0
        for d in s:
            cs, initial = (cs + (d*initial)) % 11, initial - 1
        return cs
    def ean_checksum(s):
        return sum(d*m for d,m in zip(s, cycle([1,3]))) % 10

    s = re.sub('[*#]', 'X', s.replace('-','').strip().upper())
    if not re.match("97[789]\d{10}|\d{7}(\d{2})?[\dX]$", s):
        return None, None
    s = decode(s)

    if len(s) == 13:
        if ean_checksum(s) != 0:
            return None, None
        if s[2] == 7:
            s = s[3:10] + [(11-isxn_checksum(s[3:10], initial=8)) % 11]
            return encode(s), 'issn'
        else:
            return encode(s), 'isbn'
    else:
        cs, n = 0, len(s)
        for d in s:
            cs, n = (cs + (d*n)) % 11, n - 1
        if cs != 0:
            return None, None
        return encode(s), ('issn' if len(s) == 8 else 'isbn')

# Application Search
class ApplicationSearch(object):
    
    def __init__(self, application):
        self.conf = application
    
    def perform_search(self, request, query, only_app):
        number, number_type = validate_isxn(query)
        if not number_type:
            return []
        else:
            query = {
                number_type: number
            }
        
        query = LibrarySearchQuery(**query)
        
        results = []
        for item in self.conf.provider.library_search(query):
            results.append({
                'title': item.title,
                'redirect_if_sole_result': True,
                'application': 'library',
                'excerpt': '',
                'additional': '<strong>Library item</strong>, Publisher: %s' % item.publisher,
                'url': reverse('library:item-detail', args=[item.control_number]),
            })
        
        return results

########NEW FILE########
__FILENAME__ = tests
import urllib

from django.utils import unittest
from django.test import TestCase
from django.conf import settings
from django.core.management import call_command

from PyZ3950 import z3950 as z3950_
from PyZ3950 import zoom

from molly.apps.library.models import LibrarySearchQuery
from molly.apps.library.providers import z3950

TEST_DATA = [
"00927nam  2200301 a 4500001001500000003000600015005001700021008004100038010001700079015001900096016001800115020002500133020002200158035002300180035001300203040004900216042001400265050002800279082001500307100003200322245006100354260003300415300003500448500002000483650001800503700001500521852008900536\x1eUkOxUb16686899\x1eUkOxU\x1e20080430135602.0\x1e071012s2007    cc a          001 0 eng d\x1e  \x1fa  2007278140\x1e  \x1faGBA709991\x1f2bnb\x1e7 \x1fa013660805\x1f2Uk\x1e  \x1fa9780596529260 (pbk.)\x1e  \x1fa0596529260 (pbk.)\x1e  \x1fa(OCoLC)ocm82671871\x1e  \x1fa15042568\x1e  \x1faUKM\x1fcUKM\x1fdBAKER\x1fdBTCTA\x1fdYDXCP\x1fdDPL\x1fdIXA\x1fdDLC\x1e  \x1falccopycat\x1e00\x1faTK5105.88813\x1fb.R53 2007\x1e04\x1fa006.76\x1f222\x1e1 \x1faRichardson, Leonard,\x1fd1979-\x1e10\x1faRESTful web services /\x1fcLeonard Richardson and Sam Ruby.\x1e  \x1faFarnham :\x1fbO'Reilly,\x1fcc2007.\x1e  \x1faxxiv, 419 p. :\x1fbill. ;\x1fc24 cm.\x1e  \x1faIncludes index.\x1e 0\x1faWeb services.\x1e1 \x1faRuby, Sam.\x1e  \x1faUkOxU\x1fbRadcl.Science\x1fbRSL Level 2\x1fhTK 5105.88813 RIC\x1f720689922\x1fp306162820\x1fyReference\x1e\x1d",
'01567nam  2200361 a 45M0001001500000003000600015005001700021008004100038010001500079020001500094024001900109035002700128050002200155082001400177092001600191100001700207245007700224250001100301260005700312300003200369440004600401504002900447504001900476650001500495650002500510971000800535852008500543852009000628852013700718852011100855852011100966852012801077\x1eUkOxUb10017358\x1eUkOxU\x1e20000224140527.0\x1e890215s1988    maua      b   001 0 eng d\x1e  \x1falc87009205\x1e  \x1fa0201060353\x1e2 \x1fa19372295\x1fc+LCX\x1e  \x1faCURL 05lc87009205(Lon)\x1e 0\x1faQA76.6\x1fb.B25 1988\x1e  \x1fa519.7\x1f219\x1e  \x1faD0400017640\x1e1 \x1faBaase, Sara.\x1e10\x1faComputer algorithms :\x1fbintroduction to design and analysis /\x1fcSara Baase\x1e  \x1fa2nd ed\x1e  \x1faReading, Mass ;\x1faWokingham :\x1fbAddison-Wesley,\x1fcc1988\x1e  \x1faxv, 415 p. :\x1fbill. ;\x1fc25 cm\x1e 0\x1faAddison-Wesley series in computer science\x1e  \x1faBibliography: p. 397-403\x1e  \x1faIncludes index\x1e 0\x1faAlgorithms\x1e 0\x1faComputer programming\x1e  \x1facmw\x1e  \x1faUkOxU\x1fbEngineering\x1fbENG Main Libr\x1fhPT2.baa\x1f712749035\x1fp302102211\x1fyCheck the Shelf\x1e  \x1faUkOxU\x1fbPembroke Coll\x1fbPEM Main Libr\x1fhM 9.4 BAA\x1f712749034\x1fp302890267\x1fx91193\x1fyAvailable\x1e  \x1faUkOxU\x1fbRadcl.Science\x1fbRSL Offsite\x1fh00.E05482\x1f712749033\x1fm(Box B000001063108)\x1fp300206976\x1fyIn place\x1fzformerly at Comp. Cj 10\x1f5300206976\x1e  \x1faUkOxU\x1fbWadham Coll.\x1fbWAD Main Libr\x1fhM 40 (B)\x1f712749030\x1fm2nd copy\x1fp303455625\x1fx1989/856\x1fy\x1fzBNA 33943M \xb926.78\x1e  \x1faUkOxU\x1fbWadham Coll.\x1fbWAD Main Libr\x1fhM 40 (B)\x1f712749031\x1fm1st copy\x1fp303455624\x1fx1989/855\x1fy\x1fzBNA 33943M \xb926.78\x1e  \x1faUkOxU\x1fbWadham Coll.\x1fbWAD Main Libr\x1fhM 40 (B)\x1f712749032\x1fmThird copy\x1fp300606910\x1fx1992/717\x1fxGift of Dr W McColl October 1992\x1fy\x1e\x1d',
]

TEST_METADATA = [
    {
#        'author': '',
        'title': 'RESTful web services / Leonard Richardson and Sam Ruby.',
        'publisher': "Farnham : O'Reilly, c2007.",
        'description': 'xxiv, 419 p. : ill. ; 24 cm.',
    },
    {
        'title': 'Computer algorithms : introduction to design and analysis / Sara Baase',
        'publisher': "Reading, Mass ; Wokingham : Addison-Wesley, c1988",
        'description': 'xv, 415 p. : ill. ; 25 cm',
    },
]

class FakeOLISResult(z3950.USMARCSearchResult):
    def __init__(self, data):
        db_name = 'MAIN*BIBMAST'
        super(FakeOLISResult, self).__init__(
            zoom.Record(
                z3950_.Z3950_RECSYN_USMARC_ov, data, db_name
        ))

class USMARCTestCase(TestCase):

    def testGetDetails(self):
        for data, metadata in zip(TEST_DATA, TEST_METADATA):
            result = FakeOLISResult(data)
            for k in metadata:
                self.assertEqual(getattr(result, k), metadata[k])


TEST_ISBNS = [
    '1903402557', '0134841891', '0262041677', '0340811293', '1565925858',
]
               
TEST_AUTHORS = [
    'Adolf Hitler', 'Peter F Hamilton', 'Rushdie', 'Jeremy Clarkson', 'Gandhi',
    'Jeremy Black', 'Stewart III',
]

TEST_HOST = 'library.ox.ac.uk'
TEST_DATABASE = 'MAIN*BIBMAST'

class SearchTestCase(TestCase):
    
    def testAuthorSearch(self):
        
        for author in TEST_AUTHORS:
            response = self.client.get('/library/search/?%s' % urllib.urlencode({
                'author': author,
                'title': '',
                'isbn': '',
            }))
            self.assertEqual(response.status_code, 200)
            
    def testOLISSearch(self):
        for author in TEST_AUTHORS:
            q = LibrarySearchQuery(author=author)
            results = z3950.Z3950(TEST_HOST, TEST_DATABASE).library_search(q)
            self.assert_(len(results) > 0)

    def testISBNSearch(self):
        for isbn in TEST_ISBNS:
            q = LibrarySearchQuery(isbn=isbn)
            results = z3950.Z3950(TEST_HOST, TEST_DATABASE).library_search(q)
            self.assert_(len(results) > 0, "No results for ISBN %s" % isbn)
    

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from views import (
    IndexView, SearchDetailView,
    ItemDetailView, ItemHoldingsView,
)

urlpatterns = patterns('',
    (r'^$',
        IndexView, {},
        'index'),
    (r'^search/$',
        SearchDetailView, {},
        'search'),

    (r'^item:(?P<control_number>[^/]+)/$',
        ItemDetailView, {},
        'item-detail'),
    (r'^item:(?P<control_number>[^/]+)/(?P<sublocation>.+)/$',
        ItemHoldingsView, {},
        'item-holdings-detail'),
)

########NEW FILE########
__FILENAME__ = views
from datetime import timedelta

from django.core.paginator import Paginator
from django.http import Http404
from django.utils.translation import ugettext as _

from molly.utils import haversine
from molly.utils.views import BaseView, ZoomableView
from molly.utils.breadcrumbs import *
from molly.maps import Map

from molly.apps.library.forms import SearchForm
from molly.apps.library.models import LibrarySearchQuery, LibrarySearchError

class IndexView(BaseView):
    """
    Index page of the library app
    """
    
    def get_metadata(self, request):
        return {
            'title': _('Library search'),
            'additional': _("View libraries' contact information and find library items."),
        }
    
    def initial_context(self, request):
        return {
            'search_form': SearchForm()
        }
    
    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(self.conf.local_name, None, _('Library search'), lazy_reverse('index'))
    
    def handle_GET(self, request, context):
        return self.render(request, context, 'library/index',
                           expires=timedelta(days=28))

class SearchDetailView(BaseView):
    """
    Search results page
    """
    
    def get_metadata(self, request):
        return {
            'show_in_results': False,
        }
    
    def initial_context(self, request):
        return {
            'search_form': SearchForm(request.GET),
        }
    
    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        if 'item' in context or context['search_form'].is_valid():
            title = _('Search Results')
        else:
            title = _('Library search')
        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('index'),
            title,
            lazy_reverse('search'),
        )
    
    def handle_GET(self, request, context):
        search_form = context['search_form']
        
        if not (request.GET and search_form.is_valid()):
            # No form data received
            return self.render(request, context, 'library/item_list')
        
        # Build a query object to pass to providers here
        try:
            query = LibrarySearchQuery(
                search_form.cleaned_data['title'],
                search_form.cleaned_data['author'],
                search_form.cleaned_data['isbn']
            )
        except LibrarySearchQuery.InconsistentQuery, e:
            return self.handle_error(request, context, e.msg)
        
        # Call provider
        try:
            results = self.conf.provider.library_search(query)
        except LibrarySearchError as e:
            return self.handle_error(request, context, e.message)
        
        # Paginate results
        paginator = Paginator(results, 10)
        
        try:
            page_index = int(request.GET['page'])
        except (ValueError, KeyError):
            page_index = 1
        else:
            page_index = min(max(1, page_index), paginator.num_pages)
        
        page = paginator.page(page_index)
        
        # Add cover image
        if hasattr(self.conf, 'additional_metadata_provider'):
            
            self.conf.additional_metadata_provider.annotate(page.object_list)
        
        # Without this, the object_list doesn't render when using fragment
        # rendering...
        page.object_list = list(page.object_list)
        
        # Render results page
        context.update({
            'removed': query.removed,
            'results': paginator,
            'page': page,
        })
        return self.render(request, context, 'library/item_list',
                           expires=timedelta(hours=1))
    
    def handle_error(self, request, context, message):
        context['error_message'] = message
        return self.render(request, context, 'library/item_list')

AVAIL_COLORS = ['red', 'amber', 'purple', 'blue', 'green']

class ItemDetailView(ZoomableView):
    """
    More detail about the item page
    """
    
    def initial_context(self, request, control_number):
        context = super(ItemDetailView, self).initial_context(request)
        item = self.conf.provider.control_number_search(control_number)
        if item is None:
            raise Http404()
        
        context.update({
            'item': item,
            'control_number': control_number,
        })
        return context

    @BreadcrumbFactory
    def breadcrumb(self, request, context, control_number):
        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('search'),
            _('Search result'),
            lazy_reverse('item-detail', args=[control_number]),
        )

    def handle_GET(self, request, context, control_number):
        
        # Build a map of all the libraries that have this book, with markers
        # corresponding to colours
        
        user_location = request.session.get('geolocation:location')
        
        points = []
        point_libraries = []
        lbs = context['item'].libraries.items()
        
        for library, books in lbs:
            library.entity = library.get_entity()

        if user_location:
            lbs = sorted(lbs, key=lambda (l,b): (haversine(user_location, l.entity.location)
                if l.entity and l.entity.location else float('inf')))

        for library, books in lbs:
            if library.entity != None and library.entity.location != None:
                colour = AVAIL_COLORS[max(b['availability'] for b in books)]
                points.append((library.entity.location[0],
                               library.entity.location[1],
                               colour,
                               library.entity.title))
                point_libraries.append(library)
        
        if len(points) > 0:
            context['map'] = Map(
                centre_point = (user_location[0], user_location[1], 'green', '')
                                if user_location != None else None,
                points = points,
                min_points = 0 if context['zoom'] else len(points),
                zoom = context['zoom'],
                width = request.map_width,
                height = request.map_height,
            )
            
            # Yes, this is weird. fit_to_map() groups libraries with the same
            # location so here we add a marker_number to each library to display
            # in the template.
            lib_iter = iter(point_libraries)
            for i, (a,b) in enumerate(context['map'].points):
                for j in range(len(b)):
                    lib_iter.next().marker_number = i + 1
        
        context.update({
            'sorted_libraries': lbs,
        })
        
        return self.render(request, context, 'library/item_detail')

class ItemHoldingsView(ZoomableView):
    """
    Specific details of holdings of a particular item
    """
    
    def initial_context(self, request, control_number, sublocation):
        
        context = super(ItemHoldingsView, self).initial_context(request)
        
        # Get item from database
        item = self.conf.provider.control_number_search(control_number)
        if item is None:
            raise Http404
        
        # Find which particular library we're interested in
        library = None
        for item_library in item.libraries:
            if item_library.location == tuple(sublocation.split('/')):
                library = item_library
        
        if library is None:
            raise Http404

        context.update({
            'item': item,
            'library': library,
            'control_number': control_number,
            'books': item.libraries[library],
        })
        return context

    def get_metadata(self, request, control_number, sublocation):
        return {
            'show_in_results': False,
        }

    @BreadcrumbFactory
    def breadcrumb(self, request, context, control_number, sublocation):
        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('item-detail', control_number=control_number),
            _('Item holdings information'),
            lazy_reverse('item-holdings-detail', args=[control_number,sublocation]),
        )

    def handle_GET(self, request, context, control_number, sublocation):
        return self.render(request, context, 'library/item_holdings_detail')

########NEW FILE########
__FILENAME__ = admin
from django.contrib.gis import admin
from models import (Entity, EntityName, EntityType, EntityTypeName, EntityGroup,
                    EntityGroupName, Route, StopOnRoute, Journey)

class EntityTypeNameInline(admin.TabularInline):
    model = EntityTypeName
    fk_name = "entity_type"


class EntityGroupNameInline(admin.TabularInline):
    model = EntityGroupName
    fk_name = "entity_group"


class EntityNameInline(admin.TabularInline):
    model = EntityName
    fk_name = "entity"


class EntityTypeAdmin(admin.ModelAdmin):
    inlines = [
        EntityTypeNameInline,
    ]


class EntityGroupAdmin(admin.ModelAdmin):
    inlines = [
        EntityGroupNameInline,
    ]


class EntityAdmin(admin.OSMGeoAdmin):
    list_display = ('title', 'absolute_url', 'primary_type')
    list_filter = ('source', 'primary_type', )
    inlines = [
        EntityNameInline,
    ]

class StopOnRouteInline(admin.StackedInline):
    model = StopOnRoute
    fk_name = 'route'

class RouteAdmin(admin.ModelAdmin):
    inlines = [
        StopOnRouteInline
    ]

admin.site.register(Entity, EntityAdmin)
admin.site.register(EntityType, EntityTypeAdmin)
admin.site.register(EntityGroup, EntityGroupAdmin)
admin.site.register(Route, RouteAdmin)
admin.site.register(Journey)

########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.utils.translation import ugettext_lazy as _

YES_NO_DEFAULT = (
    ('', ''),
    ('yes', 'Yes'),
    ('no', 'No'),
)


class UpdateOSMForm(forms.Form):
    contributor_name = forms.CharField(required=False, label=_('Your name'))
    contributor_email = forms.EmailField(required=False, label=_('Your e-mail address'))
    contributor_attribute = forms.BooleanField(required=False, label=_('Include name in update'))


    name = forms.CharField(required=False)
    operator = forms.CharField(required=False)
    opening_hours = forms.CharField(required=False, label=_('Opening hours'))
    cuisine = forms.CharField(required=False, label=_('Cuisine'))

    phone = forms.CharField(required=False, label=_('Phone number'))

    food = forms.ChoiceField(required=False, label=_('Food served'), choices=YES_NO_DEFAULT)
    food__hours = forms.CharField(required=False, label=_('Hours food is served'))

    atm = forms.ChoiceField(required=False, label=_('ATM present'), choices=YES_NO_DEFAULT)

    url = forms.CharField(required=False, label=_('Website'))

    ref = forms.CharField(required=False, label=_("Reference (e.g. 'OX1 123')"))
    collection_times = forms.CharField(required=False, label=_('Collection times'))

    capacity = forms.CharField(required=False, label=_('Capacity'))

    notes = forms.CharField(required=False, widget = forms.Textarea())

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Adding model 'Source'
        db.create_table('places_source', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('module_name', self.gf('django.db.models.fields.CharField')(max_length=128)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=128)),
            ('last_updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
        ))
        db.send_create_signal('places', ['Source'])

        # Adding model 'EntityType'
        db.create_table('places_entitytype', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=50, db_index=True)),
            ('article', self.gf('django.db.models.fields.CharField')(max_length=2)),
            ('verbose_name', self.gf('django.db.models.fields.TextField')()),
            ('verbose_name_plural', self.gf('django.db.models.fields.TextField')()),
            ('show_in_nearby_list', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('show_in_category_list', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('note', self.gf('django.db.models.fields.TextField')(null=True)),
        ))
        db.send_create_signal('places', ['EntityType'])

        # Adding M2M table for field subtype_of on 'EntityType'
        db.create_table('places_entitytype_subtype_of', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('from_entitytype', models.ForeignKey(orm['places.entitytype'], null=False)),
            ('to_entitytype', models.ForeignKey(orm['places.entitytype'], null=False))
        ))
        db.create_unique('places_entitytype_subtype_of', ['from_entitytype_id', 'to_entitytype_id'])

        # Adding M2M table for field subtype_of_completion on 'EntityType'
        db.create_table('places_entitytype_subtype_of_completion', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('from_entitytype', models.ForeignKey(orm['places.entitytype'], null=False)),
            ('to_entitytype', models.ForeignKey(orm['places.entitytype'], null=False))
        ))
        db.create_unique('places_entitytype_subtype_of_completion', ['from_entitytype_id', 'to_entitytype_id'])

        # Adding model 'Identifier'
        db.create_table('places_identifier', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('scheme', self.gf('django.db.models.fields.CharField')(max_length=32)),
            ('value', self.gf('django.db.models.fields.CharField')(max_length=256)),
        ))
        db.send_create_signal('places', ['Identifier'])

        # Adding model 'Entity'
        db.create_table('places_entity', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('title', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('source', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['places.Source'])),
            ('primary_type', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['places.EntityType'], null=True)),
            ('location', self.gf('django.contrib.gis.db.models.fields.PointField')(null=True)),
            ('geometry', self.gf('django.contrib.gis.db.models.fields.GeometryField')(null=True)),
            ('_metadata', self.gf('django.db.models.fields.TextField')(default='{}')),
            ('absolute_url', self.gf('django.db.models.fields.TextField')()),
            ('parent', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['places.Entity'], null=True)),
            ('is_sublocation', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('is_stack', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('identifier_scheme', self.gf('django.db.models.fields.CharField')(max_length=32)),
            ('identifier_value', self.gf('django.db.models.fields.CharField')(max_length=256)),
        ))
        db.send_create_signal('places', ['Entity'])

        # Adding M2M table for field all_types on 'Entity'
        db.create_table('places_entity_all_types', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('entity', models.ForeignKey(orm['places.entity'], null=False)),
            ('entitytype', models.ForeignKey(orm['places.entitytype'], null=False))
        ))
        db.create_unique('places_entity_all_types', ['entity_id', 'entitytype_id'])

        # Adding M2M table for field all_types_completion on 'Entity'
        db.create_table('places_entity_all_types_completion', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('entity', models.ForeignKey(orm['places.entity'], null=False)),
            ('entitytype', models.ForeignKey(orm['places.entitytype'], null=False))
        ))
        db.create_unique('places_entity_all_types_completion', ['entity_id', 'entitytype_id'])

        # Adding M2M table for field _identifiers on 'Entity'
        db.create_table('places_entity__identifiers', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('entity', models.ForeignKey(orm['places.entity'], null=False)),
            ('identifier', models.ForeignKey(orm['places.identifier'], null=False))
        ))
        db.create_unique('places_entity__identifiers', ['entity_id', 'identifier_id'])


    def backwards(self, orm):

        # Deleting model 'Source'
        db.delete_table('places_source')

        # Deleting model 'EntityType'
        db.delete_table('places_entitytype')

        # Removing M2M table for field subtype_of on 'EntityType'
        db.delete_table('places_entitytype_subtype_of')

        # Removing M2M table for field subtype_of_completion on 'EntityType'
        db.delete_table('places_entitytype_subtype_of_completion')

        # Deleting model 'Identifier'
        db.delete_table('places_identifier')

        # Deleting model 'Entity'
        db.delete_table('places_entity')

        # Removing M2M table for field all_types on 'Entity'
        db.delete_table('places_entity_all_types')

        # Removing M2M table for field all_types_completion on 'Entity'
        db.delete_table('places_entity_all_types_completion')

        # Removing M2M table for field _identifiers on 'Entity'
        db.delete_table('places_entity__identifiers')


    models = {
        'places.entity': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_stack': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_sublocation': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"}),
            'title': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'places.entitytype': {
            'Meta': {'ordering': "('verbose_name',)", 'object_name': 'EntityType'},
            'article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'verbose_name': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_plural': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        }
    }

    complete_apps = ['places']

########NEW FILE########
__FILENAME__ = 0002_auto__add_entitygroup
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'EntityGroup'
        db.create_table('places_entitygroup', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('title', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('source', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['places.Source'])),
            ('ref_code', self.gf('django.db.models.fields.CharField')(max_length=256)),
        ))
        db.send_create_signal('places', ['EntityGroup'])

        # Adding M2M table for field groups on 'Entity'
        db.create_table('places_entity_groups', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('entity', models.ForeignKey(orm['places.entity'], null=False)),
            ('entitygroup', models.ForeignKey(orm['places.entitygroup'], null=False))
        ))
        db.create_unique('places_entity_groups', ['entity_id', 'entitygroup_id'])


    def backwards(self, orm):
        
        # Deleting model 'EntityGroup'
        db.delete_table('places_entitygroup')

        # Removing M2M table for field groups on 'Entity'
        db.delete_table('places_entity_groups')


    models = {
        'places.entity': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_stack': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_sublocation': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"}),
            'title': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"}),
            'title': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'places.entitytype': {
            'Meta': {'ordering': "('verbose_name',)", 'object_name': 'EntityType'},
            'article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'verbose_name': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_plural': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        }
    }

    complete_apps = ['places']

########NEW FILE########
__FILENAME__ = 0003_auto__add_entitytypecategory
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'EntityTypeCategory'
        db.create_table('places_entitytypecategory', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('places', ['EntityTypeCategory'])


    def backwards(self, orm):
        
        # Deleting model 'EntityTypeCategory'
        db.delete_table('places_entitytypecategory')


    models = {
        'places.entity': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_stack': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_sublocation': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"}),
            'title': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"}),
            'title': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'places.entitytype': {
            'Meta': {'ordering': "('verbose_name',)", 'object_name': 'EntityType'},
            'article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'verbose_name': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_plural': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        }
    }

    complete_apps = ['places']

########NEW FILE########
__FILENAME__ = 0004_auto__add_field_entitytype_category
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

from molly.apps.places.models import EntityTypeCategory

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'EntityType.category'
        default, created = EntityTypeCategory.objects.get_or_create(name='Uncategorised')
        db.add_column('places_entitytype', 'category', self.gf('django.db.models.fields.related.ForeignKey')(default=default.pk, to=orm['places.EntityTypeCategory']), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'EntityType.category'
        db.delete_column('places_entitytype', 'category_id')


    models = {
        'places.entity': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_stack': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_sublocation': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"}),
            'title': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"}),
            'title': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'places.entitytype': {
            'Meta': {'ordering': "('verbose_name',)", 'object_name': 'EntityType'},
            'article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityTypeCategory']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'verbose_name': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_plural': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        }
    }

    complete_apps = ['places']

########NEW FILE########
__FILENAME__ = 0005_auto__add_entitytypecategoryname__add_entityname__add_entitygroupname_
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models
from django.conf import settings
from molly.utils.i18n import name_in_language

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Adding model 'EntityName'
        db.create_table('places_entityname', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('entity', self.gf('django.db.models.fields.related.ForeignKey')(related_name='names', to=orm['places.Entity'])),
            ('title', self.gf('django.db.models.fields.TextField')()),
            ('language_code', self.gf('django.db.models.fields.CharField')(max_length=10)),
        ))
        db.send_create_signal('places', ['EntityName'])

        # Adding model 'EntityGroupName'
        db.create_table('places_entitygroupname', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('entity_group', self.gf('django.db.models.fields.related.ForeignKey')(related_name='names', to=orm['places.EntityGroup'])),
            ('title', self.gf('django.db.models.fields.TextField')()),
            ('language_code', self.gf('django.db.models.fields.CharField')(max_length=10)),
        ))
        db.send_create_signal('places', ['EntityGroupName'])

        # Adding model 'EntityTypeName'
        db.create_table('places_entitytypename', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('entity_type', self.gf('django.db.models.fields.related.ForeignKey')(related_name='names', to=orm['places.EntityType'])),
            ('language_code', self.gf('django.db.models.fields.CharField')(max_length=10)),
            ('verbose_name_singular', self.gf('django.db.models.fields.TextField')()),
            ('verbose_name', self.gf('django.db.models.fields.TextField')()),
            ('verbose_name_plural', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('places', ['EntityTypeName'])
        
        # Convert EntityType names to the new model
        for et in orm.EntityType.objects.all():
            et.names.create(language_code=settings.LANGUAGE_CODE,
                            verbose_name_singular = '%s %s' % (et.article, et.verbose_name),
                            verbose_name=et.verbose_name,
                            verbose_name_plural=et.verbose_name_plural,
                            )

        for eg in orm.EntityGroup.objects.all():
            eg.names.create(language_code=settings.LANGUAGE_CODE,
                            title=eg.title)

        for e in orm.Entity.objects.all():
            e.names.create(language_code=settings.LANGUAGE_CODE,
                            title=e.title)
        
        # Deleting field 'Entity.title'
        db.delete_column('places_entity', 'title')


    def backwards(self, orm):

        # Deleting model 'EntityName'
        db.delete_table('places_entityname')

        # Deleting model 'EntityGroupName'
        db.delete_table('places_entitygroupname')

        # Deleting model 'EntityTypeName'
        db.delete_table('places_entitytypename')


    models = {
        'places.entity': {
            'Meta': {'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_stack': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_sublocation': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"}),
            'title': ('django.db.models.fields.TextField', [], {}),
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitygroupname': {
            'Meta': {'object_name': 'EntityGroupName'},
            'entity_group': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.EntityGroup']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entityname': {
            'Meta': {'object_name': 'EntityName'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytype': {
            'Meta': {'object_name': 'EntityType'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityTypeCategory']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'article': ('django.db.models.fields.CharField', [], {'max_length': 2}),
            'verbose_name': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_plural': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytypename': {
            'Meta': {'object_name': 'EntityTypeName'},
            'verbose_name_singular': ('django.db.models.fields.TextField', [], {}),
            'entity_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.EntityType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'verbose_name': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_plural': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        }
    }

    complete_apps = ['places']

########NEW FILE########
__FILENAME__ = 0007_auto__add_unique_entitytypecategoryname_entity_type_category_language_
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting field 'EntityType.verbose_name_plural'
        db.delete_column('places_entitytype', 'verbose_name_plural')

        # Deleting field 'EntityType.article'
        db.delete_column('places_entitytype', 'article')

        # Deleting field 'EntityType.verbose_name'
        db.delete_column('places_entitytype', 'verbose_name')

        # Deleting field 'EntityGroup.title'
        db.delete_column('places_entitygroup', 'title')

        # Adding unique constraint on 'EntityName', fields ['language_code', 'entity']
        db.create_unique('places_entityname', ['language_code', 'entity_id'])

        # Adding unique constraint on 'EntityGroupName', fields ['entity_group', 'language_code']
        db.create_unique('places_entitygroupname', ['entity_group_id', 'language_code'])

        # Adding unique constraint on 'EntityTypeName', fields ['language_code', 'entity_type']
        db.create_unique('places_entitytypename', ['language_code', 'entity_type_id'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'EntityTypeName', fields ['language_code', 'entity_type']
        db.delete_unique('places_entitytypename', ['language_code', 'entity_type_id'])

        # Removing unique constraint on 'EntityGroupName', fields ['entity_group', 'language_code']
        db.delete_unique('places_entitygroupname', ['entity_group_id', 'language_code'])

        # Removing unique constraint on 'EntityName', fields ['language_code', 'entity']
        db.delete_unique('places_entityname', ['language_code', 'entity_id'])
        
        # Adding field 'EntityGroup.title'
        db.add_column('places_entitygroup', 'title', self.gf('django.db.models.fields.TextField')(default='', blank=True), keep_default=False)
        
        for eg in orm.EntityGroup.objects.all():
            eg.title = name_in_category(eg, 'title')
        
        # Adding field 'Entity.title'
        db.add_column('places_entity', 'title', self.gf('django.db.models.fields.TextField')(default='', blank=True), keep_default=False)

        for e in orm.Entity.objects.all():
            e.title = name_in_category(eg, 'title')
        
        # Adding field 'EntityType.verbose_name_plural'
        db.add_column('places_entitytype', 'verbose_name_plural', self.gf('django.db.models.fields.TextField')(default='', blank=True), keep_default=False)

        # Adding field 'EntityType.article'
        db.add_column('places_entitytype', 'article', self.gf('django.db.models.fields.CharField')(default='', blank=True, max_length=2), keep_default=False)

        # Adding field 'EntityType.verbose_name'
        db.add_column('places_entitytype', 'verbose_name', self.gf('django.db.models.fields.TextField')(default='', blank=True), keep_default=False)

        for e in orm.Entity.objects.all():
            e.article = name_in_category(eg, 'verbose_name_singular').split()[0]
            e.verbose_name = name_in_category(eg, 'verbose_name')
            e.verbose_name_plural = name_in_category(eg, 'verbose_name_plural')


    models = {
        'places.entity': {
            'Meta': {'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_stack': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_sublocation': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroupname': {
            'Meta': {'unique_together': "(('entity_group', 'language_code'),)", 'object_name': 'EntityGroupName'},
            'entity_group': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.EntityGroup']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entityname': {
            'Meta': {'unique_together': "(('entity', 'language_code'),)", 'object_name': 'EntityName'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytype': {
            'Meta': {'object_name': 'EntityType'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityTypeCategory']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytypename': {
            'Meta': {'unique_together': "(('entity_type', 'language_code'),)", 'object_name': 'EntityTypeName'},
            'entity_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.EntityType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'verbose_name': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_plural': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_singular': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        }
    }

    complete_apps = ['places']

########NEW FILE########
__FILENAME__ = 0008_auto__add_route__add_stoponroute
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Route'
        db.create_table('places_route', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('service_id', self.gf('django.db.models.fields.TextField')()),
            ('operator', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('service_name', self.gf('django.db.models.fields.TextField')(null=True)),
            ('external_ref', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('places', ['Route'])

        # Adding model 'StopOnRoute'
        db.create_table('places_stoponroute', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('entity', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['places.Entity'])),
            ('route', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['places.Route'])),
            ('order', self.gf('django.db.models.fields.IntegerField')()),
        ))
        db.send_create_signal('places', ['StopOnRoute'])


    def backwards(self, orm):
        
        # Deleting model 'Route'
        db.delete_table('places_route')

        # Deleting model 'StopOnRoute'
        db.delete_table('places_stoponroute')


    models = {
        'places.entity': {
            'Meta': {'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_stack': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_sublocation': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroupname': {
            'Meta': {'unique_together': "(('entity_group', 'language_code'),)", 'object_name': 'EntityGroupName'},
            'entity_group': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.EntityGroup']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entityname': {
            'Meta': {'unique_together': "(('entity', 'language_code'),)", 'object_name': 'EntityName'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytype': {
            'Meta': {'object_name': 'EntityType'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityTypeCategory']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytypename': {
            'Meta': {'unique_together': "(('entity_type', 'language_code'),)", 'object_name': 'EntityTypeName'},
            'entity_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.EntityType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'verbose_name': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_plural': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_singular': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.route': {
            'Meta': {'object_name': 'Route'},
            'external_ref': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'operator': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'service_id': ('django.db.models.fields.TextField', [], {}),
            'service_name': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'stops': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Entity']", 'through': "orm['places.StopOnRoute']", 'symmetrical': 'False'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'places.stoponroute': {
            'Meta': {'object_name': 'StopOnRoute'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'order': ('django.db.models.fields.IntegerField', [], {}),
            'route': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Route']"})
        }
    }

    complete_apps = ['places']

########NEW FILE########
__FILENAME__ = 0009_auto__add_journey__add_scheduledstop
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Journey'
        db.create_table('places_journey', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('route', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['places.Route'])),
            ('external_ref', self.gf('django.db.models.fields.TextField')()),
            ('notes', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('runs_on_monday', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('runs_on_tuesday', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('runs_on_wednesday', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('runs_on_thursday', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('runs_on_friday', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('runs_on_saturday', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('runs_on_sunday', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('runs_in_termtime', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('runs_in_school_holidays', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('runs_on_bank_holidays', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('runs_on_non_bank_holidays', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('runs_from', self.gf('django.db.models.fields.DateField')()),
            ('runs_until', self.gf('django.db.models.fields.DateField')()),
            ('vehicle', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('places', ['Journey'])

        # Adding model 'ScheduledStop'
        db.create_table('places_scheduledstop', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('entity', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['places.Entity'])),
            ('journey', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['places.Journey'])),
            ('order', self.gf('django.db.models.fields.IntegerField')()),
            ('sta', self.gf('django.db.models.fields.TimeField')(null=True, blank=True)),
            ('std', self.gf('django.db.models.fields.TimeField')(null=True, blank=True)),
            ('times_estimated', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('fare_stage', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('activity', self.gf('django.db.models.fields.CharField')(default='B', max_length=1)),
        ))
        db.send_create_signal('places', ['ScheduledStop'])


    def backwards(self, orm):
        
        # Deleting model 'Journey'
        db.delete_table('places_journey')

        # Deleting model 'ScheduledStop'
        db.delete_table('places_scheduledstop')


    models = {
        'places.entity': {
            'Meta': {'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_stack': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_sublocation': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroupname': {
            'Meta': {'unique_together': "(('entity_group', 'language_code'),)", 'object_name': 'EntityGroupName'},
            'entity_group': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.EntityGroup']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entityname': {
            'Meta': {'unique_together': "(('entity', 'language_code'),)", 'object_name': 'EntityName'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytype': {
            'Meta': {'object_name': 'EntityType'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityTypeCategory']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytypename': {
            'Meta': {'unique_together': "(('entity_type', 'language_code'),)", 'object_name': 'EntityTypeName'},
            'entity_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.EntityType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'verbose_name': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_plural': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_singular': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.journey': {
            'Meta': {'object_name': 'Journey'},
            'external_ref': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'notes': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'route': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Route']"}),
            'runs_from': ('django.db.models.fields.DateField', [], {}),
            'runs_in_school_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_in_termtime': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_bank_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_friday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_monday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_non_bank_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_saturday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_sunday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_thursday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_tuesday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_wednesday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_until': ('django.db.models.fields.DateField', [], {}),
            'vehicle': ('django.db.models.fields.TextField', [], {})
        },
        'places.route': {
            'Meta': {'object_name': 'Route'},
            'external_ref': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'operator': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'service_id': ('django.db.models.fields.TextField', [], {}),
            'service_name': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'stops': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Entity']", 'through': "orm['places.StopOnRoute']", 'symmetrical': 'False'})
        },
        'places.scheduledstop': {
            'Meta': {'ordering': "['order']", 'object_name': 'ScheduledStop'},
            'activity': ('django.db.models.fields.CharField', [], {'default': "'B'", 'max_length': '1'}),
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']"}),
            'fare_stage': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'journey': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Journey']"}),
            'order': ('django.db.models.fields.IntegerField', [], {}),
            'sta': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'std': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'times_estimated': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'places.stoponroute': {
            'Meta': {'ordering': "['order']", 'object_name': 'StopOnRoute'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'order': ('django.db.models.fields.IntegerField', [], {}),
            'route': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Route']"})
        }
    }

    complete_apps = ['places']

########NEW FILE########
__FILENAME__ = 0010_auto__del_field_entity_is_stack__del_field_entity_is_sublocation
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting field 'Entity.is_stack'
        db.delete_column('places_entity', 'is_stack')

        # Deleting field 'Entity.is_sublocation'
        db.delete_column('places_entity', 'is_sublocation')


    def backwards(self, orm):
        
        # Adding field 'Entity.is_stack'
        db.add_column('places_entity', 'is_stack', self.gf('django.db.models.fields.BooleanField')(default=False), keep_default=False)

        # Adding field 'Entity.is_sublocation'
        db.add_column('places_entity', 'is_sublocation', self.gf('django.db.models.fields.BooleanField')(default=False), keep_default=False)


    models = {
        'places.entity': {
            'Meta': {'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroupname': {
            'Meta': {'unique_together': "(('entity_group', 'language_code'),)", 'object_name': 'EntityGroupName'},
            'entity_group': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.EntityGroup']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entityname': {
            'Meta': {'unique_together': "(('entity', 'language_code'),)", 'object_name': 'EntityName'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytype': {
            'Meta': {'object_name': 'EntityType'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityTypeCategory']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytypename': {
            'Meta': {'unique_together': "(('entity_type', 'language_code'),)", 'object_name': 'EntityTypeName'},
            'entity_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.EntityType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'verbose_name': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_plural': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_singular': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.journey': {
            'Meta': {'object_name': 'Journey'},
            'external_ref': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'notes': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'route': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Route']"}),
            'runs_from': ('django.db.models.fields.DateField', [], {}),
            'runs_in_school_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_in_termtime': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_bank_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_friday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_monday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_non_bank_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_saturday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_sunday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_thursday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_tuesday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_wednesday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_until': ('django.db.models.fields.DateField', [], {}),
            'vehicle': ('django.db.models.fields.TextField', [], {})
        },
        'places.route': {
            'Meta': {'object_name': 'Route'},
            'external_ref': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'operator': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'service_id': ('django.db.models.fields.TextField', [], {}),
            'service_name': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'stops': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Entity']", 'through': "orm['places.StopOnRoute']", 'symmetrical': 'False'})
        },
        'places.scheduledstop': {
            'Meta': {'ordering': "['order']", 'object_name': 'ScheduledStop'},
            'activity': ('django.db.models.fields.CharField', [], {'default': "'B'", 'max_length': '1'}),
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']"}),
            'fare_stage': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'journey': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Journey']"}),
            'order': ('django.db.models.fields.IntegerField', [], {}),
            'sta': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'std': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'times_estimated': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'places.stoponroute': {
            'Meta': {'ordering': "['order']", 'object_name': 'StopOnRoute'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'order': ('django.db.models.fields.IntegerField', [], {}),
            'route': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Route']"})
        }
    }

    complete_apps = ['places']

########NEW FILE########
__FILENAME__ = 0011_auto__add_field_entity_is_entrance
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Entity.is_entrance'
        db.add_column('places_entity', 'is_entrance', self.gf('django.db.models.fields.BooleanField')(default=False), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Entity.is_entrance'
        db.delete_column('places_entity', 'is_entrance')


    models = {
        'places.entity': {
            'Meta': {'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_entrance': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroupname': {
            'Meta': {'unique_together': "(('entity_group', 'language_code'),)", 'object_name': 'EntityGroupName'},
            'entity_group': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.EntityGroup']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entityname': {
            'Meta': {'unique_together': "(('entity', 'language_code'),)", 'object_name': 'EntityName'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytype': {
            'Meta': {'object_name': 'EntityType'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityTypeCategory']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytypename': {
            'Meta': {'unique_together': "(('entity_type', 'language_code'),)", 'object_name': 'EntityTypeName'},
            'entity_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.EntityType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'verbose_name': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_plural': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_singular': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.journey': {
            'Meta': {'object_name': 'Journey'},
            'external_ref': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'notes': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'route': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Route']"}),
            'runs_from': ('django.db.models.fields.DateField', [], {}),
            'runs_in_school_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_in_termtime': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_bank_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_friday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_monday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_non_bank_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_saturday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_sunday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_thursday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_tuesday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_wednesday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_until': ('django.db.models.fields.DateField', [], {}),
            'vehicle': ('django.db.models.fields.TextField', [], {})
        },
        'places.route': {
            'Meta': {'object_name': 'Route'},
            'external_ref': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'operator': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'service_id': ('django.db.models.fields.TextField', [], {}),
            'service_name': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'stops': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Entity']", 'through': "orm['places.StopOnRoute']", 'symmetrical': 'False'})
        },
        'places.scheduledstop': {
            'Meta': {'ordering': "['order']", 'object_name': 'ScheduledStop'},
            'activity': ('django.db.models.fields.CharField', [], {'default': "'B'", 'max_length': '1'}),
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']"}),
            'fare_stage': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'journey': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Journey']"}),
            'order': ('django.db.models.fields.IntegerField', [], {}),
            'sta': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'std': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'times_estimated': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'places.stoponroute': {
            'Meta': {'ordering': "['order']", 'object_name': 'StopOnRoute'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'order': ('django.db.models.fields.IntegerField', [], {}),
            'route': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Route']"})
        }
    }

    complete_apps = ['places']

########NEW FILE########
__FILENAME__ = 0012_add_index_Identifier_scheme
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding index on 'Identifier', fields ['scheme']
        db.create_index('places_identifier', ['scheme'])


    def backwards(self, orm):
        
        # Removing index on 'Identifier', fields ['scheme']
        db.delete_index('places_identifier', ['scheme'])


    models = {
        'places.entity': {
            'Meta': {'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_entrance': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroupname': {
            'Meta': {'unique_together': "(('entity_group', 'language_code'),)", 'object_name': 'EntityGroupName'},
            'entity_group': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.EntityGroup']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entityname': {
            'Meta': {'unique_together': "(('entity', 'language_code'),)", 'object_name': 'EntityName'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytype': {
            'Meta': {'object_name': 'EntityType'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityTypeCategory']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytypename': {
            'Meta': {'unique_together': "(('entity_type', 'language_code'),)", 'object_name': 'EntityTypeName'},
            'entity_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.EntityType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'verbose_name': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_plural': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_singular': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.journey': {
            'Meta': {'object_name': 'Journey'},
            'external_ref': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'notes': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'route': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Route']"}),
            'runs_from': ('django.db.models.fields.DateField', [], {}),
            'runs_in_school_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_in_termtime': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_bank_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_friday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_monday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_non_bank_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_saturday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_sunday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_thursday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_tuesday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_wednesday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_until': ('django.db.models.fields.DateField', [], {}),
            'vehicle': ('django.db.models.fields.TextField', [], {})
        },
        'places.route': {
            'Meta': {'object_name': 'Route'},
            'external_ref': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'operator': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'service_id': ('django.db.models.fields.TextField', [], {}),
            'service_name': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'stops': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Entity']", 'through': "orm['places.StopOnRoute']", 'symmetrical': 'False'})
        },
        'places.scheduledstop': {
            'Meta': {'ordering': "['order']", 'object_name': 'ScheduledStop'},
            'activity': ('django.db.models.fields.CharField', [], {'default': "'B'", 'max_length': '1'}),
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']"}),
            'fare_stage': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'journey': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Journey']"}),
            'order': ('django.db.models.fields.IntegerField', [], {}),
            'sta': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'std': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'times_estimated': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'places.stoponroute': {
            'Meta': {'ordering': "['order']", 'object_name': 'StopOnRoute'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'order': ('django.db.models.fields.IntegerField', [], {}),
            'route': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Route']"})
        }
    }

    complete_apps = ['places']

########NEW FILE########
__FILENAME__ = 0013_add_index_Identifier_value
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding index on 'Identifier', fields ['value']
        db.create_index('places_identifier', ['value'])


    def backwards(self, orm):
        
        # Removing index on 'Identifier', fields ['value']
        db.delete_index('places_identifier', ['value'])


    models = {
        'places.entity': {
            'Meta': {'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_entrance': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroupname': {
            'Meta': {'unique_together': "(('entity_group', 'language_code'),)", 'object_name': 'EntityGroupName'},
            'entity_group': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.EntityGroup']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entityname': {
            'Meta': {'unique_together': "(('entity', 'language_code'),)", 'object_name': 'EntityName'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytype': {
            'Meta': {'object_name': 'EntityType'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityTypeCategory']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytypename': {
            'Meta': {'unique_together': "(('entity_type', 'language_code'),)", 'object_name': 'EntityTypeName'},
            'entity_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.EntityType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'verbose_name': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_plural': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_singular': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.journey': {
            'Meta': {'object_name': 'Journey'},
            'external_ref': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'notes': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'route': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Route']"}),
            'runs_from': ('django.db.models.fields.DateField', [], {}),
            'runs_in_school_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_in_termtime': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_bank_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_friday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_monday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_non_bank_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_saturday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_sunday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_thursday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_tuesday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_wednesday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_until': ('django.db.models.fields.DateField', [], {}),
            'vehicle': ('django.db.models.fields.TextField', [], {})
        },
        'places.route': {
            'Meta': {'object_name': 'Route'},
            'external_ref': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'operator': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'service_id': ('django.db.models.fields.TextField', [], {}),
            'service_name': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'stops': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Entity']", 'through': "orm['places.StopOnRoute']", 'symmetrical': 'False'})
        },
        'places.scheduledstop': {
            'Meta': {'ordering': "['order']", 'object_name': 'ScheduledStop'},
            'activity': ('django.db.models.fields.CharField', [], {'default': "'B'", 'max_length': '1'}),
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']"}),
            'fare_stage': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'journey': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Journey']"}),
            'order': ('django.db.models.fields.IntegerField', [], {}),
            'sta': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'std': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'times_estimated': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'places.stoponroute': {
            'Meta': {'ordering': "['order']", 'object_name': 'StopOnRoute'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'order': ('django.db.models.fields.IntegerField', [], {}),
            'route': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Route']"})
        }
    }

    complete_apps = ['places']

########NEW FILE########
__FILENAME__ = 0014_add_index_EntityName_language_code
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding index on 'EntityName', fields ['language_code']
        db.create_index('places_entityname', ['language_code'])


    def backwards(self, orm):
        
        # Removing index on 'EntityName', fields ['language_code']
        db.delete_index('places_entityname', ['language_code'])


    models = {
        'places.entity': {
            'Meta': {'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_entrance': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroupname': {
            'Meta': {'unique_together': "(('entity_group', 'language_code'),)", 'object_name': 'EntityGroupName'},
            'entity_group': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.EntityGroup']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entityname': {
            'Meta': {'unique_together': "(('entity', 'language_code'),)", 'object_name': 'EntityName'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytype': {
            'Meta': {'object_name': 'EntityType'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityTypeCategory']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytypename': {
            'Meta': {'unique_together': "(('entity_type', 'language_code'),)", 'object_name': 'EntityTypeName'},
            'entity_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.EntityType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'verbose_name': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_plural': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_singular': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.journey': {
            'Meta': {'object_name': 'Journey'},
            'external_ref': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'notes': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'route': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Route']"}),
            'runs_from': ('django.db.models.fields.DateField', [], {}),
            'runs_in_school_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_in_termtime': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_bank_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_friday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_monday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_non_bank_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_saturday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_sunday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_thursday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_tuesday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_wednesday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_until': ('django.db.models.fields.DateField', [], {}),
            'vehicle': ('django.db.models.fields.TextField', [], {})
        },
        'places.route': {
            'Meta': {'object_name': 'Route'},
            'external_ref': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'operator': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'service_id': ('django.db.models.fields.TextField', [], {}),
            'service_name': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'stops': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Entity']", 'through': "orm['places.StopOnRoute']", 'symmetrical': 'False'})
        },
        'places.scheduledstop': {
            'Meta': {'ordering': "['order']", 'object_name': 'ScheduledStop'},
            'activity': ('django.db.models.fields.CharField', [], {'default': "'B'", 'max_length': '1'}),
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']"}),
            'fare_stage': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'journey': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Journey']"}),
            'order': ('django.db.models.fields.IntegerField', [], {}),
            'sta': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'std': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'times_estimated': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'places.stoponroute': {
            'Meta': {'ordering': "['order']", 'object_name': 'StopOnRoute'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'order': ('django.db.models.fields.IntegerField', [], {}),
            'route': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Route']"})
        }
    }

    complete_apps = ['places']

########NEW FILE########
__FILENAME__ = 0015_add_index_EntityTypeName_language_code_add_index_EntityGroupName_language_code
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding index on 'EntityTypeName', fields ['language_code']
        db.create_index('places_entitytypename', ['language_code'])

        # Adding index on 'EntityGroupName', fields ['language_code']
        db.create_index('places_entitygroupname', ['language_code'])


    def backwards(self, orm):
        
        # Removing index on 'EntityGroupName', fields ['language_code']
        db.delete_index('places_entitygroupname', ['language_code'])

        # Removing index on 'EntityTypeName', fields ['language_code']
        db.delete_index('places_entitytypename', ['language_code'])


    models = {
        'places.entity': {
            'Meta': {'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_entrance': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroupname': {
            'Meta': {'unique_together': "(('entity_group', 'language_code'),)", 'object_name': 'EntityGroupName'},
            'entity_group': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.EntityGroup']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entityname': {
            'Meta': {'unique_together': "(('entity', 'language_code'),)", 'object_name': 'EntityName'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytype': {
            'Meta': {'object_name': 'EntityType'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityTypeCategory']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.entitytypename': {
            'Meta': {'unique_together': "(('entity_type', 'language_code'),)", 'object_name': 'EntityTypeName'},
            'entity_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['places.EntityType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'verbose_name': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_plural': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_singular': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.journey': {
            'Meta': {'object_name': 'Journey'},
            'external_ref': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'notes': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'route': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Route']"}),
            'runs_from': ('django.db.models.fields.DateField', [], {}),
            'runs_in_school_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_in_termtime': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_bank_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_friday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_monday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_non_bank_holidays': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_saturday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_sunday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_thursday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_tuesday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_on_wednesday': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'runs_until': ('django.db.models.fields.DateField', [], {}),
            'vehicle': ('django.db.models.fields.TextField', [], {})
        },
        'places.route': {
            'Meta': {'object_name': 'Route'},
            'external_ref': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'operator': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'service_id': ('django.db.models.fields.TextField', [], {}),
            'service_name': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'stops': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Entity']", 'through': "orm['places.StopOnRoute']", 'symmetrical': 'False'})
        },
        'places.scheduledstop': {
            'Meta': {'ordering': "['order']", 'object_name': 'ScheduledStop'},
            'activity': ('django.db.models.fields.CharField', [], {'default': "'B'", 'max_length': '1'}),
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']"}),
            'fare_stage': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'journey': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Journey']"}),
            'order': ('django.db.models.fields.IntegerField', [], {}),
            'sta': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'std': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'times_estimated': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'places.stoponroute': {
            'Meta': {'ordering': "['order']", 'object_name': 'StopOnRoute'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'order': ('django.db.models.fields.IntegerField', [], {}),
            'route': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Route']"})
        }
    }

    complete_apps = ['places']

########NEW FILE########
__FILENAME__ = models
from calendar import weekday, monthrange
from datetime import date, timedelta
from math import atan2, degrees

import simplejson
from dateutil.easter import easter

from django.conf import settings
from django.contrib.gis.db import models
from django.core.urlresolvers import reverse, NoReverseMatch
from django.contrib.gis.geos import Point
from django.utils.translation import get_language
from django.utils.translation import ugettext_lazy as _

from molly.utils import haversine
from molly.utils.i18n import name_in_language

# Translators: These are compass points
COMPASS_POINTS = (_('N'), _('NE'), _('E'), _('SE'),
                  _('S'), _('SW'), _('W'), _('NW'))

def bearing_to_compass(bearing):
    """
    Translates a bearing in degrees to a human readable direction (N, S, E, etc)
    """
    compass_point = (int(bearing + 22.5) % 360) // 45
    return COMPASS_POINTS[compass_point]

class Source(models.Model):
    """
    Defines the data source of an Entity
    """

    module_name = models.CharField(max_length=128)
    name = models.CharField(max_length=128)
    last_updated = models.DateTimeField(auto_now=True)

    def __unicode__(self):
        return self.name

IDENTIFIER_SCHEME_PREFERENCE = getattr(
    settings,
    'IDENTIFIER_SCHEME_PREFERENCE',
    ('atco', 'osm', 'naptan', 'postcode', 'bbc-tpeg', 'tiploc'))


class EntityTypeCategory(models.Model):
    """
    Defines a category for an entity type to be part of e.g. a bus stop will be
    part of the 'Transport' Entity Type Category.
    """

    name = models.TextField(blank=False)

    def __unicode__(self):
        return self.name

class EntityTypeManager(models.Manager):
    
    def get_or_create(self, defaults, *args, **kwargs):
        """
        Simplifies the creation of multilingual EntityTypes - takes an
        additional argument in defaults of 'verbose_names' which is a dictionary
        mapping language codes to verbose_name, verbose_name_singular and
        verbose_name plural
        """
        
        verbose_names = defaults.pop('verbose_names', {})
        kwargs['defaults'] = defaults
        entity_type, created = super(
            EntityTypeManager, self).get_or_create(*args, **kwargs)
        if created:
            for language, (verbose, singular, plural) in verbose_names.items():
                EntityTypeName.objects.create(
                    entity_type=entity_type,
                    language_code=language,
                    verbose_name=verbose,
                    verbose_name_singular=singular,
                    verbose_name_plural=plural
                )
        return entity_type, created


class EntityType(models.Model):
    """
    Defines a 'type' for each Entity. E.g. an entity could be of 'bus stop'
    Entity Type
    """

    slug = models.SlugField()
    
    @property
    def verbose_name(self):
        return name_in_language(self, 'verbose_name', self.slug)
    
    @property
    def verbose_name_singular(self):
        return name_in_language(self, 'verbose_name_singular', self.slug)
    
    @property
    def verbose_name_plural(self):
        return name_in_language(self, 'verbose_name_plural', self.slug)
    
    show_in_nearby_list = models.BooleanField()
    show_in_category_list = models.BooleanField()
    note = models.TextField(null=True, blank=True)
    category = models.ForeignKey(EntityTypeCategory)

    subtype_of = models.ManyToManyField('self', blank=True, symmetrical=False,
                                        related_name="subtypes")
    subtype_of_completion = models.ManyToManyField('self',
            blank=True, symmetrical=False, related_name="subtypes_completion")

    def __unicode__(self):
        return self.verbose_name

    def save(self, *args, **kwargs):
        super(EntityType, self).save(*args, **kwargs)
        
        subtypes_of = set([self])
        for subtype_of in self.subtype_of.all():
            subtypes_of |= set(subtype_of.subtype_of_completion.all())
        
        if set(self.subtype_of_completion.all()) != subtypes_of:
            self.subtype_of_completion = subtypes_of
            for et in self.subtypes.all():
                et.save()
            for e in self.entities_completion.all():
                e.save()
        else:
            super(EntityType, self).save(*args, **kwargs)
    
    objects = EntityTypeManager()


class EntityTypeName(models.Model):
    entity_type = models.ForeignKey(EntityType, related_name='names')
    language_code = models.CharField(max_length=10, choices=settings.LANGUAGES)
    verbose_name = models.TextField()
    verbose_name_singular = models.TextField()
    verbose_name_plural = models.TextField()
    
    class Meta:
        unique_together = ('entity_type', 'language_code')


class Identifier(models.Model):
    """
    Abstract identifier code for various identifier schemes such as ATCO, OSM,
    NaPTAN (e.g. 910GYSTRADM) etc.
    """

    scheme = models.CharField(max_length=32)
    value = models.CharField(max_length=256)

    def __unicode__(self):
        return self.scheme + ': ' + self.value


class EntityGroup(models.Model):
    """
    Used to express relationships between entities
    """
    
    @property
    def title(self):
        return name_in_language(self, 'title', '')

    source = models.ForeignKey(Source)
    ref_code = models.CharField(max_length=256)

    def __unicode__(self):
        return self.title


class EntityGroupName(models.Model):
    entity_group = models.ForeignKey(EntityGroup, related_name='names')
    title = models.TextField(blank=False)
    language_code = models.CharField(max_length=10, choices=settings.LANGUAGES)
    
    class Meta:
        unique_together = ('entity_group', 'language_code')


class EntityManager(models.GeoManager):
    
    def get_entity(self, scheme, value):
        return self.filter(_identifiers__scheme=scheme,
                           _identifiers__value=value)
    
    def create(self, *args, **kwargs):
        """
        Simplifies the creation of multilingual Entitys - takes an
        additional argument in defaults of 'titles' which is a dictionary
        mapping language codes to names.
        """
        
        titles = kwargs.pop('titles', {})
        identifiers = kwargs.pop('identifiers', {})
        entity = super(EntityManager, self).create(*args, **kwargs)
        for language, title in titles.items():
            EntityName.objects.create(
                entity=entity,
                language_code=language,
                title=title
            )
        if len(identifiers) > 0:
            entity.save(identifiers=identifiers)
        return entity


class Entity(models.Model):
    """
    An Entity represents a geo-spatial point with attached metadata. This
    includes all DB stored Points regardless of data source.
    """
    
    @property
    def title(self):
        return name_in_language(self, 'title',
                    '%s:%s' % (self.identifier_scheme, self.identifier_value))
    
    source = models.ForeignKey(Source)

    primary_type = models.ForeignKey(EntityType, null=True)
    all_types = models.ManyToManyField(EntityType, blank=True,
                                       related_name='entities')
    all_types_completion = models.ManyToManyField(EntityType, blank=True,
                                            related_name='entities_completion')
    
    location = models.PointField(srid=4326, null=True)
    geometry = models.GeometryField(srid=4326, null=True)
    _metadata = models.TextField(default='{}')
    
    absolute_url = models.TextField()
    
    parent = models.ForeignKey('self', null=True)
    is_entrance = models.BooleanField(default=False)

    _identifiers = models.ManyToManyField(Identifier)
    identifier_scheme = models.CharField(max_length=32)
    identifier_value = models.CharField(max_length=256)

    groups = models.ManyToManyField(EntityGroup)

    @property
    def identifiers(self):
        try:
            return self.__identifiers
        except AttributeError:
            if not self.pk:
                return dict()
            self.__identifiers = dict()
            for identifier in self._identifiers.all():
                scheme, value = identifier.scheme, identifier.value
                if scheme in self.__identifiers:
                    # Multi-valued list - first check if we've converted this
                    # key to a list already
                    if getattr(self.__identifiers[scheme], '__iter__', False) \
                     and not \
                     isinstance(self.__identifiers[scheme], basestring):
                        # We have, so just add it to the current list
                        self.__identifiers[scheme].append(value)
                    else:
                        # convert this into a list
                        self.__identifiers[scheme] = [
                            self.__identifiers[scheme],
                            value]
                else:
                    self.__identifiers[scheme] = value

            return self.__identifiers
    
    def get_metadata(self):
        try:
            return self.__metadata
        except AttributeError:
            self.__metadata = simplejson.loads(self._metadata)
            return self.__metadata

    def set_metadata(self, metadata):
        self.__metadata = metadata
    metadata = property(get_metadata, set_metadata)
    

    def get_bearing(self, p1):
        """
        Returns a compass point direction from current Entity to another Point
        """
        p2 = self.location
        lat_diff, lon_diff = p2[0] - p1[0], p2[1] - p1[1]
        return bearing_to_compass(degrees(atan2(lon_diff, lat_diff)))

    def get_distance_and_bearing_from(self, point):
        """
        Returns a distance and compass direction from current Entity to
        another point
        """
        if point is None or not self.location:
            return None, None
        return haversine(point, self.location), self.get_bearing(point)
    
    def save(self, *args, **kwargs):
        try:
            self._metadata = simplejson.dumps(self.__metadata)
        except AttributeError:
            pass
        
        identifiers = kwargs.pop('identifiers', None)
        if identifiers is not None:
            self.absolute_url = self._get_absolute_url(identifiers)
        
        super(Entity, self).save(*args, **kwargs)

        if identifiers is not None:
            self._identifiers.all().delete()
            id_objs = []
            for scheme, value in identifiers.items():
                if getattr(value, '__iter__', False) and \
                  not isinstance(value, basestring):
                    # Is an iterable, but not a string
                    for val in value:
                        id_obj = Identifier(scheme=scheme, value=val)
                        id_obj.save()
                        id_objs.append(id_obj)
                else:
                    id_obj = Identifier(scheme=scheme, value=value)
                    id_obj.save()
                    id_objs.append(id_obj)
            self._identifiers.add(*id_objs)
        self.update_all_types_completion()

    def update_all_types_completion(self):
        all_types = set()
        for t in self.all_types.all():
            all_types |= set(t.subtype_of_completion.all())
        if set(self.all_types_completion.all()) != all_types:
            self.all_types_completion = all_types
            self.metadata['types'] = [t.slug for t in all_types]

    @property
    def all_types_slugs(self):
        try:
            return self.metadata['types']
        except:
            self.metadata['types'] = [t.slug
                                      for t in self.all_types_completion.all()]
            self.save()
            return self.metadata['types']

    def delete(self, *args, **kwargs):
        for identifier in self._identifiers.all():
            identifier.delete()
        super(Entity, self).delete()
    
    objects = EntityManager()

    def _get_absolute_url(self, identifiers):
        for scheme in IDENTIFIER_SCHEME_PREFERENCE:
            if scheme in identifiers:
                self.identifier_scheme = scheme
                self.identifier_value = identifiers[scheme]
                return reverse('places:entity',
                               args=[scheme, identifiers[scheme]])
        if len(identifiers) > 0:
            for scheme, identifier in identifiers.items():
                try:
                    url = reverse('places:entity', args=[scheme, identifier])
                except NoReverseMatch:
                    continue
                else:
                    self.identifier_scheme = scheme
                    self.identifier_value = identifier
                    return url
        raise AssertionError

    def get_absolute_url(self):
        return self.absolute_url
    
    def __unicode__(self):
        return self.title
    
    @property
    def display_id(self):
        for et in self.all_types.all():
            if et.slug == 'postcode':
                return getattr(self, et.id_field).strip()
            else:
                return getattr(self, et.id_field)
    
    def routing_point(self, origin=None):
        """
        Returns the location to where the user should go when being routed to
        this entity - can pass in the start location (e.g., if there are
        entrances) on two sides, the user will then be routed to the one closest
        to them.
        """
        
        entrances_in_group = Entity.objects.filter(
            groups__entity=self,
            is_entrance=True
        )
        
        # There are no entrances in the groups
        if entrances_in_group.count() == 0:
            return self
        
        if origin:
            entrances_in_group = entrances_in_group.distance(origin).order_by('distance')
        
        return entrances_in_group[0]
    
    def simplify_for_render(self, simplify_value, simplify_model):
        simplified = {
            '_type': '%s.%s' % (self.__module__[:-7], self._meta.object_name),
            '_pk': self.pk,
            '_url': self.get_absolute_url(),
            'location': self.location,
            'geometry': self.geometry,
            'routing_point': self.routing_point().location,
            'parent': simplify_model(self.parent, terse=True),
            'is_entrance': self.is_entrance,
            'groups': self.groups.all(),
            'all_types': [simplify_model(t, terse=True)
                          for t in self.all_types_completion.all()],
            'primary_type': simplify_model(self.primary_type, terse=True),
            'metadata': self.metadata,
            'title': self.title,
            'identifiers': self.identifiers,
            'identifier_scheme': self.identifier_scheme,
            'identifier_value': self.identifier_value
        }
        
        for field in list(dir(self)):
            try:
                if field[0] != '_' \
                 and field not in ('objects', 'all_types_slugs') \
                 and not isinstance(getattr(self, field), models.Field):
                    try:
                        simplified[field] = simplify_value(getattr(self, field))
                    except NotImplementedError:
                        pass
            except AttributeError:
                pass
        
        return simplify_value(simplified)


class EntityName(models.Model):
    entity = models.ForeignKey(Entity, related_name='names')
    title = models.TextField(blank=False)
    language_code = models.CharField(max_length=10, choices=settings.LANGUAGES)
    
    class Meta:
        unique_together = ('entity', 'language_code')


class Route(models.Model):
    """
    A class representing a route which a public transport service takes
    """
    
    # A publically displayed "ID" for this service, e.g., "4C"
    service_id = models.TextField()
    
    # The operator of this service, e.g., "Oxford Bus Company" or "First"
    operator = models.TextField(null=True, blank=True)
    
    # A longer name for this service, e.g., "4 to City & Abingdon"
    service_name = models.TextField(null=True, blank=False)
    
    # A primary key used in the external dataset
    external_ref = models.TextField()
    
    stops = models.ManyToManyField(Entity, through='StopOnRoute')
    
    def __unicode__(self):
        return u'%s: %s' % (self.service_id, self.service_name)


class StopOnRoute(models.Model):
    
    entity = models.ForeignKey(Entity)
    route = models.ForeignKey(Route)
    
    # The number stop which this is on this route
    order = models.IntegerField()
    
    class Meta:
        ordering = ['order']
    
    def __unicode__(self):
        return self.entity.title


class Journey(models.Model):
    """
    This is a scheduled public transport journey between entities
    """
    
    # The route this journey runs on (note that the stops RelatedManager should
    # contain where the bus actually stops - if it's different from the
    # indicated route)
    route = models.ForeignKey(Route)
    
    # A primary key used in the external dataset
    external_ref = models.TextField()
    
    # Any notes relating to this journey
    notes = models.TextField(null=True, blank=True)
    
    runs_on_monday = models.BooleanField()
    runs_on_tuesday = models.BooleanField()
    runs_on_wednesday = models.BooleanField()
    runs_on_thursday = models.BooleanField()
    runs_on_friday = models.BooleanField()
    runs_on_saturday = models.BooleanField()
    runs_on_sunday = models.BooleanField()
    runs_in_termtime = models.BooleanField()
    runs_in_school_holidays = models.BooleanField()
    runs_on_bank_holidays = models.BooleanField()
    runs_on_non_bank_holidays = models.BooleanField()
    runs_from = models.DateField()
    runs_until = models.DateField()
    
    def get_bank_holidays(self, year):
        
        def nth_dow_to_day((m, dow, n), y):
            """
            Figures out the day of the nth day-of-week in the month m and year y as an
            integer
            
            e.g., 2nd Wednesday in July 2010:
                  nth_dow_to_day((7, 3, 2), 2010)
            
            Conversion from GUTime
            https://github.com/cnorthwood/ternip/blob/master/ternip/rule_engine/normalisation_functions/date_functions.py
            """
            
            if dow == 7:
                dow = 0
            
            first_dow, num_days = monthrange(y, m) # the dow of the first of the month
            first_dow += 1
            if first_dow == 7:
                first_dow = 0
            
            shift = dow - first_dow
            if shift < 0:
                shift += 7
            
            if n == -1:
                while (shift + (7 * n) - 6) <= num_days:
                    n += 1
                n -= 1
            return date(y, m, shift + (7 * n) - 6)
        
        bank_holidays = [
            date(year, 1, 1), # New Year's Day
            easter(year) - timedelta(days=2), # Good Friday
            easter(year) + timedelta(days=1), # Easter Monday
            nth_dow_to_day((5, 1, 1), year), # May Day
            nth_dow_to_day((5, 1, -1), year) if year != 2012 else date(2012, 6, 4), # Spring Bank Holiday
            nth_dow_to_day((8, 1, -1), year), # Late Summer Bank Holiday
            date(year, 12, 25), # Christmas Day
            date(year, 12, 26), # Boxing Day
        ]
        if year == 2011:
            bank_holidays.append(date(2011, 4, 29)) # Royal Wedding
        if year == 2012:
            bank_holidays.append(date(2012, 6, 5)) # Diamond Jubilee
        
        # Now figure out if any of those are on a weekend and if so add the
        # Monday 'day in lieu' day
        for bank_holiday in bank_holidays[:]:
            if weekday(bank_holiday.year, bank_holiday.month, bank_holiday.day) == 5:
                new_date = bank_holiday + timedelta(days=2)
            elif weekday(bank_holiday.year, bank_holiday.month, bank_holiday.day) == 6:
                new_date = bank_holiday + timedelta(days=1)
            else:
                continue
            # Deal with the case of Christmas Day and Boxing Day both being on
            # a weekend
            while new_date in bank_holidays:
                new_date += timedelta(days=1)
            bank_holidays.append(new_date)
        return bank_holidays
    
    def runs_on(self, date):
        """
        Checks if the service runs on the given date
        """
        
        if date < self.runs_from:
            # Before this service starts
            return False
        
        if date > self.runs_until:
            # After this service finished
            return False
        
        if date in self.get_bank_holidays(date.year):
            # Bank holiday
            return self.runs_on_bank_holidays
        
        elif self.runs_on_non_bank_holidays:
            
            # TODO: Check for term time - fortunately this flag appears to be
            # unused in Greater Manchester. If more places release ATCO-CIF
            # dumps that do implement this, we should do this at a later date
            
            day = ['monday',
                   'tuesday',
                   'wednesday',
                   'thursday',
                   'friday',
                   'saturday',
                   'sunday'][weekday(date.year, date.month, date.day)]
            
            return getattr(self, 'runs_on_%s' % day)
        
        else:
            # Not a bank holiday, but this is a bank holiday only service
            return False
    
    vehicle = models.TextField()
    
    @property
    def destination(self):
        destination = self.scheduledstop_set.all().reverse()[0].entity.title
        
        # Now try and tidy up destination
        destination = destination.split(', ')[-1]
        if '(' in destination:
            destination = destination[:destination.find('(')].strip()
        
        if destination.endswith('Rail Station'):
            destination = destination[:-13]
        
        return destination
    
    def __unicode__(self):
        return self.route.__unicode__()


class ScheduledStop(models.Model):
    """
    This is a scheduled route stop
    """
    
    entity = models.ForeignKey(Entity)
    journey = models.ForeignKey(Journey)
    
    order = models.IntegerField()
    
    sta = models.TimeField(verbose_name=_('Scheduled time of arrival'),
                           null=True, blank=True)
    
    std = models.TimeField(verbose_name=_('Scheduled time of departure'),
                           null=True, blank=True)
    
    times_estimated = models.BooleanField()
    fare_stage = models.BooleanField()
    activity = models.CharField(max_length=1, choices=(
            ('O', _('Service starts here')),
            ('B', _('Scheduled stop')),
            ('P', _('Service picks up here only')),
            ('D', _('Service does not pick up here')),
            ('N', _('Service does not stop here')),
            ('F', _('Service finishes here')),
        ), default='B')
    
    class Meta:
        ordering = ['order']
    
    def __unicode__(self):
        return self.entity.title


########NEW FILE########
__FILENAME__ = acislive
import threading
from datetime import datetime, timedelta
from lxml import etree
import re
import logging
from string import ascii_lowercase
import socket
socket.setdefaulttimeout(5)
from urllib2 import urlopen

from django.db import transaction, reset_queries, connection
from django.http import Http404

from molly.apps.places.models import Route, StopOnRoute, Entity, Source, EntityType
from molly.apps.places.providers import BaseMapsProvider
from molly.apps.places import get_entity
from molly.apps.places.providers.naptan import NaptanMapsProvider
from molly.utils.i18n import set_name_in_language
from molly.conf.provider import task

logger = logging.getLogger(__name__)

class ACISLiveMapsProvider(BaseMapsProvider):
    """
    Populates bus stop entities with real time departure metadata using the ACIS
    Live interface
    """
    
    ACISLIVE_URLS = {
        # The key is the atco regional prefix - the value is a tuple consisting
        # of the base URL for the ACIS Live instance, a function to determine
        # the identifier to use for the live bus times board, and a function to
        # determine the identifier to use for the bus stop messages board
        '010': ('http://bristol.acislive.com/',
                lambda entity: entity.identifiers.get('atco'),
                lambda entity: entity.identifiers.get('atco'),
               ), # Bristol
        '040': ('http://bucks.acislive.com/',
                lambda entity: entity.identifiers.get('atco'),
                lambda entity: entity.identifiers.get('atco'),
               ), # Buckinghamshire
        '050': ('http://www.cambridgeshirebus.info/',
                lambda entity: entity.identifiers.get('atco'),
                lambda entity: entity.identifiers.get('atco'),
               ), # Cambridgeshire
        '060': ('http://cheshire.acislive.com/',
                lambda entity: entity.identifiers.get('atco'),
                lambda entity: entity.identifiers.get('atco'),
               ), # Cheshire East
        '080': ('http://cornwall.acislive.com/',
                lambda entity: entity.identifiers.get('atco'),
                lambda entity: entity.identifiers.get('atco'),
               ), # Cornwall
        '160': ('http://gloucestershire.acislive.com/',
                lambda entity: entity.identifiers.get('atco'),
                lambda entity: entity.identifiers.get('atco'),
                ), # Gloucestershire
        '240': ('http://kent.acislive.com/',
                lambda entity: entity.identifiers.get('atco'),
                lambda entity: entity.identifiers.get('atco'),
                ), # Kent
        '250': ('http://lancashire.acislive.com/',
                lambda entity: entity.identifiers.get('atco'),
                lambda entity: entity.identifiers.get('atco'),
                ), # Lancashire
        '329': ('http://wymetro.acislive.com/',
                lambda entity: '329%05d' % int(entity.identifiers.get('plate')),
                lambda entity: '329%05d' % int(entity.identifiers.get('plate'))
               ), # York
        '340': ('http://www.oxontime.com/',
                lambda entity: entity.identifiers.get('naptan'),
                lambda entity: entity.identifiers.get('atco'),
               ), # Oxfordshire
        '370': ('http://sypte.acislive.com/',
                lambda entity: entity.identifiers.get('atco')[:3] + entity.identifiers.get('atco')[4:],
                lambda entity: entity.identifiers.get('atco')[:3] + entity.identifiers.get('atco')[4:],
                ), # South Yorkshire
        '440': ('http://westsussex.acislive.com/',
                lambda entity: entity.identifiers.get('atco'),
                lambda entity: entity.identifiers.get('atco'),
                ), # Wessex
        '450': ('http://wymetro.acislive.com/',
                lambda entity: entity.identifiers.get('plate'),
                lambda entity: entity.identifiers.get('plate'),
               ), # West Yorkshire
        '450': ('http://swindon.acislive.com/',
                lambda entity: entity.identifiers.get('atco'),
                lambda entity: entity.identifiers.get('atco'),
               ), # Swindon
        '571': ('http://cardiff.acislive.com/',
                lambda entity: entity.identifiers.get('atco'),
                lambda entity: entity.identifiers.get('atco'),
               ), # Cardiff
    }
    
    def get_acislive_base(self, entity):
        """
        Gets the ACIS live information for this entity
        
        @return: A tuple of base URL, identifier for realtime info, identifier
                 for messages
        """
        
        if entity.identifiers.get('naptan', '').startswith('272'):
            # Made up Oxontime codes
            return ('http://www.oxontime.com/',
                    entity.identifiers.get('naptan'), None)
        
        if entity.identifiers.get('atco', '')[:3] in self.ACISLIVE_URLS:
            base, departures, messages = self.ACISLIVE_URLS[entity.identifiers['atco'][:3]]
            return base, departures(entity), messages(entity)
        else:
            raise NoACISLiveInstanceException
    
    def get_realtime_url(self, entity):
        """
        Gets the appropriate URL for the realtime departure board for that
        entity.
        
        @return: A string of the URL for that stop departure board, or None if
                 there is no known departure board for that stop
        """
        base, departures, messages = self.get_acislive_base(entity)
        return base + 'pip/stop.asp?naptan=%s&textonly=1' % departures
    
    def get_messages_url(self, entity):
        """
        Gets the URL for the bus stop messages associated for that entity
        
        @return: A string of the URL for that stop departure board, or None if
                 there is no known messages URL for that stop
        """
        base, departures, messages = self.get_acislive_base(entity)
        if messages:
            return base + 'pip/stop_simulator_message.asp?NaPTAN=%s' % messages
        else:
            return None
        
    
    def augment_metadata(self, entities, routes=[], **kwargs):
        threads = []
        for entity in entities:
            
            bus_et = EntityType.objects.get(slug='bus-stop')
            
            if bus_et not in entity.all_types.all():
                continue
            
            thread = threading.Thread(target=self.get_times,
                                      args=[entity, routes])
            thread.start()
            threads.append(thread)
        
        for thread in threads:
            thread.join()
    
    def get_times(self, entity, routes):
        try:
            try:
                realtime_url = self.get_realtime_url(entity)
                xml = etree.parse(urlopen(realtime_url),
                                  parser = etree.HTMLParser())
            except (TypeError, IOError):
                rows = []
                pip_info = []
            except NoACISLiveInstanceException:
                return
            else:
                try:
                    cells = xml.find('.//table').findall('td')
                    rows = [cells[i:i+4] for i in range(0, len(cells), 4)]
                except AttributeError:
                    rows = []
                
                # Get the messages associated with that bus stop
                try:
                    messages_url = self.get_messages_url(entity)
                    if messages_url != None:
                        messages_page = urlopen(messages_url).read()
                        pip_info = re.findall(r'msgs\[\d+\] = "(?P<message>[^"]+)"',
                                              messages_page)
                        pip_info = filter(lambda pip: pip != '&nbsp;', pip_info)
                    else:
                        pip_info = []
                except:
                    pip_info = []
            
            services = {}
            for row in rows:
                service, destination, proximity = [row[i].text.encode('utf8').replace('\xc2\xa0', '') for i in range(3)]
                
                # Skip routes we're not interested in
                if routes and service not in routes:
                    continue
                
                # Handle scheduled departures (non-realtime)
                if ':' in proximity:
                    now = datetime.now()
                    hour, minute = map(int, proximity.split(':'))
                    diff = (datetime(now.year, now.month, now.day, hour, minute) - datetime.now()).seconds / 60
                elif proximity.lower() == 'due':
                    diff = 0
                else:
                    diff = int(proximity.split(' ')[0])
    
                if not service in services:
                    services[service] = (destination, (proximity, diff), [])
                else:
                    services[service][2].append((proximity, diff))
    
            services = [(s[0], s[1][0], s[1][1], s[1][2]) for s in services.items()]
            services.sort(key= lambda x: ( ' '*(5-len(x[0]) + (1 if x[0][-1].isalpha() else 0)) + x[0] ))
            services.sort(key= lambda x: x[2][1])
            
            services = [{
                'service': s[0],
                'destination': s[1],
                'next': s[2][0],
                'following': [f[0] for f in s[3]],
                'route': self._get_route(s[0], entity)
            } for s in services]
            
            entity.metadata['real_time_information'] = {
                'services': services,
                'pip_info': pip_info,
            }
            entity.metadata['meta_refresh'] = 30
        
        except Exception as e:
            logger.exception('Failed to get RTI from ACIS Live')
        finally:
            connection.close()
    
    def _get_route(self, service, entity):
        return Route.objects.filter(service_id=service, stops=entity).exists()

class NoACISLiveInstanceException(Exception):
    """
    An exception to indicate that there is no ACIS Live instance to determine
    real-time bus information for the passed in entity
    """
    pass

class ACISLiveRouteProvider(BaseMapsProvider):
    
    SEARCH_PAGE = '%s/web/public_service.asp?service=%s&web_search=1'

    def __init__(self, urls=None):
        """
        A list of ACIS Live URLs to scrape when importing
        """
        if urls is None:
            urls = [instance[0] for instance in ACISLiveMapsProvider.ACISLIVE_URLS.items()]
        self.urls = urls

    @task(run_every=timedelta(days=7))
    def import_data(self, **metadata):
        # Searching can flag up the same results again and again, so store
        # which ones we've found
        found_routes = set()
        
        for url in self.urls:
            
            # Try and find all bus routes in the system
            for term in list(ascii_lowercase) + map(str, range(0,9)):
                found_routes = self._scrape_search(
                    url, self.SEARCH_PAGE % (url, term), found_routes)
            
            # Now try and find buses that don't exist on that system any more
            for route in Route.objects.filter(external_ref__startswith=url):
                if route.external_ref not in found_routes:
                    logger.info('Removed route not found on system: %s', route)
                    route.delete()
    
    def _scrape_search(self, url, search_page, found_routes):
        results = etree.parse(urlopen(search_page), parser = etree.HTMLParser())
        for tr in results.find('.//table').findall('tr')[1:]:
            reset_queries()
            try:
                service, operator, destination = tr.findall('td')
            except ValueError:
                pass
            else:
                service = service.text
                operator = operator.text
                link = url + destination[0].attrib['href']
                destination = destination[0].text
                if link not in found_routes:
                    found_routes.add(link)
                    with transaction.commit_on_success():
                        route, created = Route.objects.get_or_create(
                            external_ref=link,
                            defaults={
                                'service_id': service,
                                'operator': operator,
                                'service_name': destination,
                            }
                        )
                        if not created:
                            route.service_id = service
                            route.operator = operator
                            route.service_name = destination
                            route.save()
                        self._scrape(route, link)
        
        return found_routes
    
    def _scrape(self, route, url):
        url += '&showall=1'
        service = etree.parse(urlopen(url), parser = etree.HTMLParser())
        route.stops.clear()
        for i, tr in enumerate(service.find('.//table').findall('tr')[1:]):
            
            try:
                stop_code = tr[1][0].text
            except IndexError:
                
                # Stops on ACIS Live that don't have codes, e.g., out of county
                # stops
                stop_name = tr[3][0].text
                try:
                    entity = Entity.objects.get(source=self._get_source(),
                                                _identifiers__scheme='acisroute',
                                                _identifiers__value=stop_name)
                except Entity.DoesNotExist:
                    entity = Entity(source=self._get_source())
                
                entity_type = self._get_entity_type()
                entity.primary_type = entity_type
                identifiers = { 'acisroute': stop_name }
                entity.save(identifiers=identifiers)
                set_name_in_language(entity, 'en', title=stop_name)
                entity.all_types = (entity_type,)
                entity.update_all_types_completion()
            
            else:
                if stop_code.startswith('693') or stop_code.startswith('272') \
                  or stop_code.startswith('734') or stop_code.startswith('282'):
                    # Oxontime uses NaPTAN code
                    scheme = 'naptan'
                elif stop_code.startswith('450'):
                    # West Yorkshire uses plate code
                    scheme = 'plate'
                else:
                    # Everyone else uses ATCO
                    scheme = 'atco'
                    if stop_code.startswith('370'):
                        # Except South Yorkshire, which mangles the code
                        stop_code = '3700%s' % stop_code[3:]
                try:
                    entity = get_entity(scheme, stop_code)
                    if entity.source == self._get_source():
                        # Raise Http404 if this is a bus stop we came up with,
                        # so any name changes, etc, get processed
                        raise Http404()
                except Http404:
                    # Out of zone bus stops with NaPTAN codes - alternatively,
                    # the fake bus stops Oxontime made up for the TUBE route
                    try:
                        entity = Entity.objects.get(source=self._get_source(),
                                                    _identifiers__scheme=scheme,
                                                    _identifiers__value=stop_code)
                    except Entity.DoesNotExist:
                        entity = Entity(source=self._get_source())
                    identifiers = {scheme: stop_code}
                    entity_type = self._get_entity_type()
                    entity.primary_type = entity_type
                    entity.save(identifiers=identifiers)
                    set_name_in_language(entity, 'en', title=tr[3][0].text)
                    entity.all_types = (entity_type,)
                    entity.update_all_types_completion()
                    entity.save()
                
            StopOnRoute.objects.create(route=route, entity=entity, order=i)
    
    def _get_source(self):
        source, created = Source.objects.get_or_create(module_name=__name__,
                                                       name='ACIS Route Scraper')
        source.save()
        return source
    
    def _get_entity_type(self):
        return NaptanMapsProvider(None)._get_entity_types()['BCT'][0]


########NEW FILE########
__FILENAME__ = atcocif
import random
import sys
from collections import namedtuple, defaultdict
from datetime import datetime, date, time, timedelta
from logging import getLogger
from operator import itemgetter
from StringIO import StringIO
from urllib2 import urlopen
from zipfile import ZipFile

from django.http import Http404
from django.db import transaction, reset_queries

from molly.apps.places import EntityCache
from molly.apps.places.models import (Entity, Route, StopOnRoute, Source,
                                      Journey, ScheduledStop)
from molly.apps.places.providers import BaseMapsProvider, NaptanMapsProvider
from molly.conf.provider import task
from molly.utils.i18n import set_name_in_language

logger = getLogger(__name__)

weekbool = namedtuple('weekbool', 'mon tue wed thu fri sat sun')

class AtcoCifTimetableProvider(BaseMapsProvider):
    """
    This provider loads ATCO-CIF dumps and parses them to extract timetable
    data. This only handles a subset of the ATCO-CIF standard, in particular,
    it deals with the TfGM released data (the only released data atm)
    """
    
    def __init__(self, url):
        """
        URL to an ATCO-CIF zip to be used
        """
        self._url = url
        self._cache = EntityCache()
        self._entity_type = NaptanMapsProvider(None)._get_entity_types()['BCT'][0]
    
    @task(run_every=timedelta(days=7))
    def import_data(self, **metadata):
        
        deleted_routes = set(Route.objects.filter(external_ref__startswith=self._url).values_list('external_ref'))
        archive = ZipFile(StringIO(urlopen(self._url).read()))
        for file in archive.namelist():
            logger.info(file)
            routes = self._import_cif(archive.open(file))
            logger.info(': %d routes in file\n' % len(routes))
            self._import_routes(routes)
            deleted_routes -= set(self._url + route['id'] for route in routes)
        archive.close()
        
        for route in deleted_routes:
            Route.objects.filter(external_ref=route).delete()
    
    def _parse_cif_date(self, datestring):
        return date(int(datestring[0:4]), int(datestring[4:6]),
                    int(datestring[6:8]))
    
    def _parse_cif_time(self, timestring):
        return time(int(timestring[0:2]) % 24, int(timestring[2:4]))
    
    @transaction.commit_on_success
    def _import_cif(self, cif):
        """
        Parse a CIF file
        """
        
        # Clear cache once per file - avoid high memory usage
        self._cache = EntityCache()
        
        # Also reset SQL queries log
        reset_queries()
        
        routes = []
        
        this_journey = None
        
        for line in cif:
            
            if line[:2] == 'QS':
                # Journey header
                if this_journey is not None:
                    routes[-1]['journies'].append(this_journey)
                if line[2] == 'D':
                    this_journey = None
                    continue
                this_journey = {
                    'operator-code': line[3:7],
                    'id': line[7:13],
                    'start-date': self._parse_cif_date(line[13:21]),
                    'end-date': self._parse_cif_date(line[21:29]),
                    'days': weekbool(
                        line[29] == '1', # Monday
                        line[30] == '1', # Tuesday
                        line[31] == '1', # Wednesday
                        line[32] == '1', # Thursday
                        line[33] == '1', # Friday
                        line[34] == '1', # Saturday
                        line[35] == '1', # Sunday
                    ),
                    'school-holidays': {
                        'S': 'term-time',
                        'H': 'holidays'
                    }.get(line[36], 'all'),
                    'bank-holidays': {
                        'A': 'additional',
                        'B': 'holidays',
                        'X': 'non-holidays'
                    }.get(line[37], 'all'),
                    'route': line[38:42],
                    'vehicle': line[48:56].strip(),
                    'direction': line[64],
                    'notes': [],
                    'stops': [],
                }
            
            elif line[:2] in ('QN', 'ZN'):
                # Notes
                this_journey['notes'].append(line[7:])
            
            elif line[:2] == 'QO':
                # Journey start
                try:
                    this_journey['stops'].append({
                        'entity': self._cache['atco:%s' % line[2:14].strip()],
                        'sta': None,
                        'std': self._parse_cif_time(line[14:18]),
                        'activity': 'O',
                        'estimated': line[22] == '0',
                        'fare-stage': line[24] == '1'
                    })
                except Http404:
                    pass
            
            elif line[:2] == 'QI':
                # Journey intermediate stop
                try:
                    this_journey['stops'].append({
                        'entity': self._cache['atco:%s' % line[2:14].strip()],
                        'sta': self._parse_cif_time(line[14:18]),
                        'std': self._parse_cif_time(line[18:22]),
                        'activity': line[22],
                        'estimated': line[27] == '0',
                        'fare-stage': line[29] == '1'
                    })
                except Http404:
                    pass
            
            elif line[:2] == 'QT':
                # Journey complete
                try:
                    this_journey['stops'].append({
                        'entity': self._cache['atco:%s' % line[2:14].strip()],
                        'sta': self._parse_cif_time(line[14:18]),
                        'std': None,
                        'activity': 'F',
                        'estimated': line[22] == '0',
                        'fare-stage': line[24] == '1'
                    })
                except Http404:
                    pass
            
            elif line[:2] == 'ZL':
                # Route ID
                route_id = line[2:]
            
            elif line[:2] == 'ZD':
                # Days route ID
                route_id += line[18:-1]
            
            elif line[:2] == 'ZS':
                # Route
                
                if this_journey is not None:
                    routes[-1]['journies'].append(this_journey)
                
                routes.append({
                    'id': route_id,
                    'number': line[10:14].strip(),
                    'description': line[14:-1],
                    'stops': [],
                    'journies': []
                })
            
            elif line[:2] == 'ZA':
                
                stop_code = line[3:15].strip()
                
                try:
                    entity = self._cache['atco:%s' % stop_code]
                    if entity.source == self._get_source():
                        # Raise Http404 if this is a bus stop we came up with,
                        # so any name changes, etc, get processed
                        raise Http404()
                except Http404:
                    # Out of zone bus stops with NaPTAN codes
                    try:
                        entity = Entity.objects.get(source=self._get_source(),
                                                    _identifiers__scheme='atco',
                                                    _identifiers__value=stop_code)
                    except Entity.DoesNotExist:
                        entity = Entity(source=self._get_source())
                    identifiers = { 'atco': stop_code }
                    entity_type = self._entity_type
                    entity.primary_type = entity_type
                    entity.save(identifiers=identifiers)
                    set_name_in_language(entity, 'en', title=line[15:63].strip())
                    entity.all_types = (entity_type,)
                    entity.update_all_types_completion()
                    entity.save()
                routes[-1]['stops'].append(entity)
        
        if this_journey is not None:
            routes[-1]['journies'].append(this_journey)
        
        return routes
    
    def _import_routes(self, routes):
        for r in routes:
            route, created = Route.objects.get_or_create(
                external_ref=self._url + r['id'],
                defaults={
                    'service_id': r['number'],
                    'service_name': r['description'],
                }
            )
            if not created:
                route.service_id = r['number']
                route.service_name = r['description']
                route.save()
            route.stops.clear()
            for i, stop in enumerate(r['stops']):
                StopOnRoute.objects.create(route=route, entity=stop, order=i)
            
            route.journey_set.all().delete()
            for journey in r['journies']:
                self._add_journey(route, journey)
    
    def _add_journey(self, route, journey):
        j = Journey.objects.create(
            route=route,
            external_ref=self._url + journey['id'],
            notes='\n'.join(journey['notes']),
            runs_on_monday=journey['days'].mon,
            runs_on_tuesday=journey['days'].tue,
            runs_on_wednesday=journey['days'].wed,
            runs_on_thursday=journey['days'].thu,
            runs_on_friday=journey['days'].fri,
            runs_on_saturday=journey['days'].sat,
            runs_on_sunday=journey['days'].sun,
            runs_in_termtime=journey['school-holidays'] in ('all', 'term-time'),
            runs_in_school_holidays=journey['school-holidays'] in ('all', 'holidays'),
            runs_on_bank_holidays=journey['bank-holidays'] in ('all', 'holidays', 'additional'),
            runs_on_non_bank_holidays=journey['bank-holidays'] in ('all', 'non-holidays'),
            runs_from=journey['start-date'],
            runs_until=journey['end-date'],
            vehicle=journey['vehicle'])
        
        for i, stop in enumerate(journey['stops']):
            ScheduledStop.objects.create(
                journey=j,
                entity=stop['entity'],
                order=i,
                sta=stop['sta'],
                std=stop['std'],
                times_estimated=stop['estimated'],
                fare_stage=stop['fare-stage'],
                activity=stop['activity']
            )
    
    def _get_source(self):
        source, created = Source.objects.get_or_create(module_name=__name__,
                                                       name='ATCO-CIF Importer')
        return source


if __name__ == '__main__':
    AtcoCifTimetableProvider('http://store.datagm.org.uk/sets/TfGM/GMPTE_CIF.zip').import_data({})

########NEW FILE########
__FILENAME__ = bbc_tpeg
import os, os.path, urllib, random, zipfile, tempfile
from lxml import etree
from datetime import timedelta

from django.contrib.gis.geos import Point, LineString
from django.conf import settings
from django.utils.translation import ugettext as _
from django.utils.translation import ugettext_noop

from molly.apps.places.providers import BaseMapsProvider
from molly.apps.places.models import Source, Entity, EntityType, EntityTypeCategory
from molly.conf.provider import task
from molly.utils.i18n import override, set_name_in_language

class BBCTPEGResolver(etree.Resolver):
    """
    Resolves the DTD references in a BBC TPEG feed.
    
    Fetches and unzips the DTDs and entity references, storing them locally
    in $CACHE_DIR/bbc_tpeg/.
    """
    
    _DTD_URLS = (
        'http://www.bbc.co.uk/travelnews/xml/tpegml_dtds.zip',
        'http://www.bbc.co.uk/travelnews/xml/english_ent.zip',
    )
    
    _RESOLVE_DIR = os.path.join(settings.CACHE_DIR, 'bbc_tpeg')

    def resolve(self, url, context, id):
        if not os.path.exists(self._RESOLVE_DIR):
            self._fetch_dtds()
        filename = os.path.join(self._RESOLVE_DIR, url.split('/')[-1])
        return self.resolve_filename(filename, context)
    
    def _fetch_dtds(self):
        os.makedirs(self._RESOLVE_DIR)
        for url in self._DTD_URLS:
            f, filename = tempfile.mkstemp()
            try:
                os.close(f)
                urllib.urlretrieve(url, filename)
                archive = zipfile.ZipFile(filename)
                archive.extractall(self._RESOLVE_DIR)
            finally:
                os.unlink(filename)

class BBCTPEGPlacesProvider(BaseMapsProvider):
    _TPEG_URL = 'http://www.bbc.co.uk/travelnews/tpeg/en/local/rtm/rtm_tpeg.xml'
    
    def __init__(self, url=_TPEG_URL):
        self._tpeg_url = url
    
    @task(run_every=timedelta(minutes=3))
    def import_data(self, **metadata):
        source, entity_type = self._get_source(), self._get_entity_type()
        
        parser = etree.XMLParser(load_dtd=True)
        parser.resolvers.add(BBCTPEGResolver())
        xml = etree.parse(urllib.urlopen(self._tpeg_url), parser=parser)
        
        entities, seen = {}, set()
        for entity in Entity.objects.filter(source=source):
            if 'bbc-tpeg' in entity.identifiers:
                entities[entity.identifiers['bbc-tpeg']] = entity
        
        for message in xml.getroot().findall('tpeg_message'):
            id = message.find('road_traffic_message').attrib['message_id']
            road_traffic_message = message.find('road_traffic_message')
            
            try:
                entity = entities[id]
            except KeyError:
                entity = Entity()
                entities[id] = entity
            
            entity.source = source
            entity.primary_type = entity_type
            
            locs = map(self._wgs84_to_point, road_traffic_message.findall('location_container/location_coordinates/WGS84'))
            if len(locs) > 1:
                entity.geometry = LineString(*locs)
            elif len(locs) == 1:
                entity.geometry = locs[0]
            else:
                continue
            entity.location = Point(
                sum(p.x for p in locs)/len(locs), 
                sum(p.y for p in locs)/len(locs), 
                srid=4326,
            )
            
            entity.metadata['bbc_tpeg'] = {
                'xml': etree.tostring(message),
                'severity': road_traffic_message.attrib['severity_factor'],
                'generated': road_traffic_message.attrib['message_generation_time'],
                'version': int(road_traffic_message.attrib['version_number']),
            }
            
            entity.save(identifiers={'bbc-tpeg': id})
            set_name_in_language(entity, 'en',
                                 title = message.find('summary').text)
            entity.all_types = [entity_type]
            entity.update_all_types_completion()
            seen.add(entity.pk)
        
        for entity in Entity.objects.filter(source=source):
            if not entity.pk in seen:
                entity.delete()
    
    def _wgs84_to_point(self, elem):
        attrib = elem.attrib
        return Point(float(attrib['longitude']), float(attrib['latitude']), srid=4326)

    def _get_source(self):
        try:
            source = Source.objects.get(module_name="molly.providers.apps.maps.bbc_tpeg")
        except Source.DoesNotExist:
            source = Source(module_name="molly.providers.apps.maps.bbc_tpeg")

        source.name = "BBC TPEG"
        source.save()

        return source
    
    def _get_entity_type(self):
        try:
            entity_type = EntityType.objects.get(slug='travel-alert')
            created = False
        except EntityType.DoesNotExist:
            entity_type = EntityType(slug='travel-alert')
            created = True
        category, etc_created = EntityTypeCategory.objects.get_or_create(name=ugettext_noop('Transport'))
        if created:
            entity_type.show_in_nearby_list = False
            entity_type.show_in_category_list = False
        entity_type.category = category
        entity_type.save()
        for lang_code, lang_name in settings.LANGUAGES:
            with override(lang_code):
                set_name_in_language(entity_type, lang_code,
                                     verbose_name=_('travel alert'),
                                     verbose_name_singular=_('a travel alert'),
                                     verbose_name_plural=_('travel alerts'))
        return entity_type

########NEW FILE########
__FILENAME__ = cif
"""
The CIF standard is documented at
http://www.atoc.org/clientfiles/File/RSPDocuments/20070801.pdf and is a file
format created by (and used by) Network Rail to expose rail timetables. It is
only used for UK rail timetables.

It is dissimilar, but related to, the ATCO-CIF standard
"""

from datetime import date, time, timedelta
from string import capwords

from django.core.exceptions import ObjectDoesNotExist
from django.db import transaction, reset_queries
from django.utils.translation import ugettext_noop as _

from molly.apps.places.models import (Entity, EntityType, EntityTypeCategory,
                                      Source, Route, Journey, ScheduledStop)
from molly.apps.places.providers import BaseMapsProvider
from molly.conf.provider import task


class CifTimetableProvider(BaseMapsProvider):

    def __init__(self,
                 entity_manager=Entity.objects,
                 entity_type_manager=EntityType.objects,
                 entity_type_category_manager=EntityTypeCategory.objects,
                 source_manager=Source.objects,
                 route_manager=Route.objects,
                 journey_manager=Journey.objects,
                 scheduled_stop_manager=ScheduledStop.objects,
                 filename=None):
        self._entity_manager = entity_manager
        self._entity_type_manager = entity_type_manager
        self._entity_type_category_manager = entity_type_category_manager
        self._source_manager = source_manager
        self._route_manager = route_manager
        self._journey_manager = journey_manager
        self._scheduled_stop_manager = scheduled_stop_manager
        self._tiplocs = {}
        self._routes = {}
        self._filename = filename

    def _parse_tiploc(self, line):
        tiploc = line[2:9].strip()
        entities = self._entity_manager.get_entity("tiploc", tiploc)
        try:
            entity = entities[0]
        except ObjectDoesNotExist:
            entity = self._entity_manager.create(
                source=self.source,
                primary_type=self.entity_type,
                identifiers={'tiploc': tiploc},
                titles={'en': capwords(line[18:44].strip())}
            )
        self._tiplocs[tiploc] = entity

    def save_journey(self):
        pass

    def _parse_cif_date(self, cifdate):
        y = int(cifdate[:2])
        m = int(cifdate[2:4])
        d = int(cifdate[4:])
        if y < 60:
            y += 2000
        else:
            y += 1900
        return date(y, m, d)

    def _parse_cif_time(self, ciftime):
        if ciftime.strip() == '':
            return None
        h = int(ciftime[:2])
        m = int(ciftime[2:4])
        s = 30 if ciftime[4] == 'H' else 0
        return time(h, m, s)

    def _parse_basic_schedule(self, line):
        if hasattr(self, '_current_journey'):
            reset_queries()
            with transaction.commit_on_success():
                self._save_stops(self._save_journey(self._save_route()))

        self._current_journey = {
            'external_ref': line[3:9],
            'runs_from': self._parse_cif_date(line[9:15]),
            'runs_until': self._parse_cif_date(line[15:21]),
            'runs_on_monday': line[21] == '1',
            'runs_on_tuesday': line[22] == '1',
            'runs_on_wednesday': line[23] == '1',
            'runs_on_thursday': line[24] == '1',
            'runs_on_friday': line[25] == '1',
            'runs_on_saturday': line[26] == '1',
            'runs_on_sunday': line[27] == '1',
            'runs_in_termtime': True,
            'runs_on_bank_holidays': line[28] not in ('X', 'E', 'G'),
            'runs_on_non_bank_holidays': True,
            # TODO: Extract category/class/catering for more information here
            'vehicle': 'TRAIN'
        }
        self._current_route = {
            'external_ref': line[3:9],
            'service_id': line[32:36]
        }
        self._stops = []

    def _parse_extended_schedule(self, line):
        # TODO: Map to full name
        self._current_route['operator'] = line[11:13]

    def _parse_origin(self, line):
        self._stops.append({
            'entity': self._tiplocs[line[2:9].strip()],
            'std': self._parse_cif_time(line[10:15]),
            'activity': 'O'
        })

    def _parse_intermediate(self, line):
        sta = self._parse_cif_time(line[10:15])
        std = self._parse_cif_time(line[15:20])
        if sta is None and std is None:
            std = self._parse_cif_time(line[20:25])
            activity = 'N'
        else:
            for i in range(42, 54, 2):
                activity = {
                    'D': 'D',
                    'T': 'B',
                    'U': 'P',
                }.get(line[i:i + 2].strip())
                if activity is not None:
                    break
            else:
                activity = 'N'
        self._stops.append({
            'entity': self._tiplocs[line[2:9].strip()],
            'sta': sta,
            'std': std,
            'activity': activity,
            'times_estimated': False
        })

    def _parse_terminate(self, line):
        self._stops.append({
            'entity': self._tiplocs[line[2:9].strip()],
            'sta': self._parse_cif_time(line[10:15]),
            'activity': 'F'
        })

    def _save_route(self):
        route, created = self._route_manager.get_or_create(
            external_ref=self._current_route['external_ref'],
            defaults=self._current_route
        )
        if not created:
            for key, value in self._current_route.items():
                setattr(route, key, value)
            route.save()
        return route

    def _save_journey(self, route):
        self._current_journey['route'] = route
        journey, created = self._journey_manager.get_or_create(
            external_ref=self._current_journey['external_ref'],
            defaults=self._current_journey
        )
        if not created:
            for key, value in self._current_journey.items():
                setattr(journey, key, value)
            journey.save()
        return journey

    def _save_stops(self, journey):
        journey.scheduledstop_set.all().delete()
        for order, stop in enumerate(self._stops):
            stop['journey'] = journey
            stop['order'] = order
            self._scheduled_stop_manager.create(**stop)

    def import_from_string(self, cif):
        # TODO: changes en route
        for line in cif.split('\n'):
            self._handle_line(line)
        if hasattr(self, '_current_journey'):
            with transaction.commit_on_success():
                self._save_stops(self._save_journey(self._save_route()))

    @task(run_every=timedelta(days=7))
    def import_from_file(self, **metadata):
        with open(self._filename) as file:
            for line in file:
                self._handle_line(line)
        if hasattr(self, '_current_journey'):
            with transaction.commit_on_success():
                self._save_stops(self._save_journey(self._save_route()))

    def _handle_line(self, line):
        if line[:2] == "TI":
            self._parse_tiploc(line)
        elif line[:2] == 'BS':
            self._parse_basic_schedule(line)
        elif line[:2] == 'BX':
            self._parse_extended_schedule(line)
        elif line[:2] == 'LO':
            self._parse_origin(line)
        elif line[:2] == 'LI':
            self._parse_intermediate(line)
        elif line[:2] == 'LT':
            self._parse_terminate(line)

    @property
    def source(self):
        if not hasattr(self, '_source'):
            self._source = self._source_manager.get_or_create(
                module_name=__name__,
                defaults={'name': 'CIF Timetable Provider'}
            )[0]
        return self._source

    @property
    def entity_type(self):
        if not hasattr(self, '_entity_type'):
            category = self._entity_type_category_manager.get_or_create(
                name=_('Transport'))[0]
            self._entity_type = self._entity_type_manager.get_or_create(
                slug='rail-timing-point',
                category=category,
                defaults={
                    'verbose_names': {
                        'en': ('rail network timing point',
                               'a rail network timing point',
                               'rail network timing points')
                    }
                }
            )[0]
        return self._entity_type

########NEW FILE########
__FILENAME__ = cloudamber
import threading
import logging
import socket

from urllib2 import urlopen
from itertools import chain
from datetime import timedelta
from lxml import etree

from molly.apps.places import get_entity
from molly.apps.places.models import Route, EntityType, StopOnRoute, Source, Entity
from molly.apps.places.providers import BaseMapsProvider
from molly.apps.places.providers.naptan import NaptanMapsProvider
from molly.conf.provider import task
from molly.utils.i18n import set_name_in_language

socket.setdefaulttimeout(5)
logger = logging.getLogger(__name__)

# Maps operator encoded names to known "friendly versions"
OPERATOR_NAMES = {'SOX': 'Stagecoach',
        'TT': 'Thames Travel',
        'OBC': 'Oxford Bus Company',
        '*Voyager_PD_RAV(en-GB)*': 'ARRIVA',
        }


class CloudAmberBusRouteProvider(BaseMapsProvider):
    """Sends an empty search string to the cloudamber route search.
    This returns all routes which we can scrape to collect the
    route information.
    """
    def __init__(self, url):
        self.url = "%s/Naptan.aspx?rdExactMatch=any&hdnSearchType=searchbyServicenumber&hdnChkValue=any" % url

    @task(run_every=timedelta(days=7))
    def import_data(self, **metadata):
        logger.info("Importing Route data from %s" % self.url)
        self._scrape_search()

    def _scrape_search(self):
        """Scrapes the search page and queues tasks for scraping the results"""
        e = etree.parse(self.url, parser=etree.HTMLParser())
        rows = e.findall('.//div[@class="cloud-amber"]')[0].findall('.//table')[1].findall('tbody/tr')
        for row in rows:
            route_no, operator, dest = row.getchildren()
            route_no = route_no.text
            operator = operator.find('span').text
            operator = OPERATOR_NAMES.get(operator, operator)
            route = dest.find('a').text
            route_href = dest.find('a').get('href')
            logger.debug("Found route: %s - %s - %s" % (route_no, operator, route))
            route, created = Route.objects.get_or_create(
                external_ref=route_href,
                defaults={
                    'service_id': route_no,
                    'service_name': route,
                    'operator': operator,
                }
            )
            if created:
                logging.debug("Created new route: %s" % route.service_name)
            self._scrape_route.delay(route.id, route_href)

    def _get_entity(self, stop_code, stop_name, source, entity_type):
        """Finds a bus stop entity or creates one if it cannot be found.
        If multiple entities are found we clean them up.
        """
        scheme = 'naptan'
        try:
            entity = get_entity(scheme, stop_code)
        except:
            try:
                entity = Entity.objects.get(_identifiers__scheme=scheme,
                        _identifiers__value=stop_code)
                logger.debug("Found Entity: %s" % entity)
            except Entity.DoesNotExist:
                logger.debug("Entity does not exist: %s-%s" % (stop_code, stop_name))
                entity = Entity()
            except Entity.MultipleObjectsReturned:
                logger.warning("Multiple Entities found for : %s-%s" % (stop_code, stop_name))
                Entity.objects.filter(_identifiers__scheme=scheme,
                        _identifiers__value=stop_code).delete()
                entity = Entity()
            entity.primary_type = entity_type
            entity.source = source
            identifiers = {scheme: stop_code}
            set_name_in_language(entity, 'en', title=stop_name)
            entity.all_types = (entity_type,)
            entity.save(identifiers=identifiers)
        return entity

    @task(max_retries=1)
    def _scrape_route(self, route_id, href):
        """Load route data from our Cloudamber provider and capture the stop data."""
        logger.info("Scraping route: %s" % href)
        e = etree.parse(href, parser=etree.HTMLParser())
        rows = e.findall('.//div[@class="cloud-amber"]')[0].findall('.//table')[1].findall('tbody/tr')
        source = self._get_source()
        entity_type = self._get_entity_type()
        for i, row in enumerate(rows):
            expand, naptan, map_href, stop_name, town = row.getchildren()
            stop_code = naptan.text
            stop_name = stop_name.find('a').text
            entity = self._get_entity(stop_code, stop_name, source, entity_type)
            StopOnRoute.objects.create(route_id=route_id, entity=entity, order=i)

    def _get_source(self):
        """Create or get a reference to this provider"""
        source, created = Source.objects.get_or_create(module_name=__name__,
                name='CloudAmber Route Scraper')
        source.save()
        return source

    def _get_entity_type(self):
        """Get the Entity type for BCT - Bus/Coach/Tram stop"""
        return NaptanMapsProvider(None)._get_entity_types()['BCT'][0]

class CloudAmberBusRtiProvider(BaseMapsProvider):
    """
    Populates bus stop entities with real time departure metadata using the
    Cloud Amber interface
    An example live instance should be hosted at http://www.oxontime.com
    """

    def __init__(self, url):
        """ url is CloudAmber instance """
        self.url = url

    def get_url(self, naptan):
        """ Constructs URL containing RTI for a given naptan busstop id """
        url = "%s/Naptan.aspx?t=departure&sa=%s&dc=&ac=96&vc=&x=0&y=0&format=xhtml" % (
                self.url, naptan)
        return url

    def augment_metadata(self, entities, routes=[], **kwargs):
        """ """
        threads = []
        for entity in entities:
            bus_et = EntityType.objects.get(slug='bus-stop')
            if bus_et not in entity.all_types.all():
                continue
            thread = threading.Thread(target=self.get_times,
                                      args=[entity, routes])
            thread.start()
            threads.append(thread)
        for thread in threads:
            thread.join()
   
    def parse_html(self, content):
        """
        Parse HTML content (Cloud Amber's HTML) from a string
        """
        services = {}
        messages = []
        try:
            xml = etree.fromstring(content, parser=etree.HTMLParser())
            # we need the second table
            cells = xml.findall('.//div[@class="cloud-amber"]')[0].findall('.//table')[1].findall('tbody/tr/td')

            # retrieved all cells, splitting every CELLS_PER_ROW to get rows
            CELLS_PER_ROW = 5
            rows = [cells[i:i+CELLS_PER_ROW] for i in range(0, len(cells), CELLS_PER_ROW)]

            for row in rows:
                service, destination, proximity = [row[i].text.encode('utf8').replace('\xc2\xa0', '') 
                        for i in range(3)]
                if proximity.lower() == 'due':
                    diff = 0
                else:
                    diff = int(proximity.split(' ')[0])

                if not service in services:
                    # first departure of this service
                    services[service] = (destination, (proximity, diff), [])
                else:
                    # following departure of this service
                    services[service][2].append((proximity, diff))

            services = [(s[0], s[1][0], s[1][1], s[1][2]) for s in services.items()]
            services.sort(key = lambda x: ( ' '*(5-len(x[0]) + (1 if x[0][-1].isalpha() else 0)) + x[0] ))
            services.sort(key = lambda x: x[2][1])

            services = [{
                'service': s[0],
                'destination': s[1],
                'next': s[2][0],
                'following': [f[0] for f in s[3]],
            } for s in services]

            # messages that can be displayed (bus stop)
            cells = xml.findall('.//table')[0].findall('tr/td')

            try:
                messages = cells[3]
                parts = ([messages.text] +
                    list(chain(*([c.text, etree.tostring(c), c.tail] for c in messages.getchildren()))) +
                    [messages.tail])
                messages = ''.join([p for p in parts if p])
                messages = [messages]
            except IndexError:
                pass
                # no message

        except Exception:
            logger.info('Unable to parse HTML', exc_info=True, extra={
                'data': {
                    'html_content': content,
                },
            })

        return services, messages

    def get_times(self, entity, routes):
        """
        Retrieve RTI information from one entity
        Get page, scrape it.
        If it fails, set the meta_refresh to get the page on
        ERROR_REFRESH_INTERVAL rather than REFRESH_INTERVAL
        Assign a route to each service if it exists in our DB.
        """
        REFRESH_INTERVAL = 30
        ERROR_REFRESH_INTERVAL = 5

        try:
            content = urlopen(self.get_url(entity.identifiers.get('naptan'))).read()
            services, messages = self.parse_html(content)
        except:
            logger.info('Unable to retrieve RTI information', exc_info=True,
                extra={
                    'data': {
                        'naptan_id': entity.identifiers.get('naptan', 0),
                    },
                })
            # if an exception occured, send empty metadata.
            entity.metadata['real_time_information'] = {
                'services': {},
                'pip_info': [],
            }
            # Get the client to refresh sooner if an exception
            entity.metadata['meta_refresh'] = ERROR_REFRESH_INTERVAL
        else:
            # Assign route to each service
            for service in services:
                service['route'] = self._get_route(service['service'], entity)

            entity.metadata['real_time_information'] = {
                'services': services,
                'pip_info': messages,
            }
            entity.metadata['meta_refresh'] = REFRESH_INTERVAL

    def _get_route(self, service, entity):
        return Route.objects.filter(service_id=service, stops=entity).exists()

########NEW FILE########
__FILENAME__ = ldb
import logging
import suds, suds.sudsobject
from suds.sax.element import Element

from django.utils.translation import ugettext_lazy
from django.utils.translation import ugettext as _
from django.conf import settings

from molly.apps.places.models import Entity
from molly.apps.places.providers import BaseMapsProvider

logger = logging.getLogger(__name__)

class LiveDepartureBoardPlacesProvider(BaseMapsProvider):
    _WSDL_URL = "https://realtime.nationalrail.co.uk/ldbws/wsdl.aspx"
    _ATTRIBUTION = { 'title': _("Powered by National Rail Enquiries"),
                  'url': "http://www.nationalrail.co.uk",
                  'picture': settings.STATIC_URL + "places/images/powered-by-nre.png" }

    def __init__(self, token, max_services=15, max_results=1):
        self._max_services = max_services
        self._max_results = max_results
        self._token = token

    def delayed(self, eta, sta, etd, std):
        """
        Try and figure out if a service is delayed based on free text values
        for estimated/scheduled times of arrival/depature
        """
        if eta in ('Delayed', 'Cancelled') or etd in ('Delayed', 'Cancelled'):
            # Easy case
            return True
        else:
            # More complex case, have to parse time stamps
            try:
                # Compare scheduled and expected arrival times
                schedh, schedm = sta.split(':')
                exph, expm = eta.rstrip('*').split(':')
            except ValueError:
                pass
            else:
                # Minutes since midnight, as we can't compare time objects
                sched_msm = int(schedh) * 60 + int(schedm)
                exp_msm = int(exph) * 60 + int(expm)
                
                if exp_msm < sched_msm:
                    # Deal with wraparound at midnight
                    sched_msm += 1440
                
                if exp_msm - sched_msm >= 5:
                    # 5 minute delay
                    return True
            
            try:
                # Compare scheduled and expected departure times
                schedh, schedm = std.split(':')
                exph, expm = etd.rstrip('*').split(':')
            except ValueError:
                pass
            else:
                # Minutes since midnight, as we can't compare time objects
                sched_msm = int(schedh) * 60 + int(schedm)
                exp_msm = int(exph) * 60 + int(expm)
                
                if exp_msm < sched_msm:
                    # Deal with wraparound at midnight
                    sched_msm += 1440
                
                if exp_msm - sched_msm >= 5:
                    # 5 minute delay
                    return True
            
            return False

    def augment_metadata(self, entities, board='departures', **kwargs):
        station_entities = []
        for entity in entities:
            if not entity.identifiers.get('crs'):
                continue
            station_entities.append(entity)

        station_entities = station_entities[:self._max_results]
        if not station_entities:
            return
        
        try:
            ldb = suds.client.Client(self._WSDL_URL, soapheaders=Element('AccessToken').insert(Element('TokenValue').setText(self._token)))
        except Exception, e:
            logger.warning("Could not instantiate suds client for live departure board.", exc_info=True, extra={'wsdl_url': self._WSDL_URL})
            self._add_error(station_entities)
            return
        
        for entity in station_entities:
            try:
                if board == 'arrivals':
                    db = ldb.service.GetArrivalBoard(self._max_services, entity.identifiers['crs'])
                else:
                    db = ldb.service.GetDepartureBoard(self._max_services, entity.identifiers['crs'])
                db = self.transform_suds(db)
                entity.metadata['ldb'] = db
                entity.metadata['service_details'] = lambda s: self.service_details(s, entity)
                entity.metadata['ldb_service'] = lambda s: self.transform_suds(ldb.service.GetServiceDetails(s))
                entity.metadata['service_type'] = 'ldb'
                
                # Show bus services too
                if board == 'arrivals':
                    db = self.transform_suds(
                        ldb.service.GetDepartureBoard(self._max_services,
                                                     entity.identifiers['crs']))
                
                if 'trainServices' in db:
                    for service in db['trainServices']['service']:
                        service['problems'] = self.delayed(
                            service.get('eta', ''), service.get('sta', ''),
                            service.get('etd', ''), service.get('std', ''))

                if 'busServices' in db:
                    for service in db['busServices']['service']:
                        entity.metadata['real_time_information'] = {
                            'services':
                                [{
                                    'service': 'BUS',
                                    'destination': service['destination']['location'][0]['locationName'],
                                    'next': service['std'],
                                    'following': [],
                                }]
                        }
                
            except Exception, e:
                logger.warning("Could not retrieve departure board for station: %r", entity.identifiers.get('crs'),
                               exc_info=True)
                self._add_error((entity,))
            entity.metadata['meta_refresh'] = 60
    
    def service_details(self, service, entity):
        try:
            service = entity.metadata['ldb_service'](service)
        except suds.WebFault as f:
            if f.fault['faultstring'] == 'Unexpected server error: Invalid length for a Base-64 char array.':
                raise Http404
            else:
                return({'error': f.fault['faultstring']})
        if service is None:
            return None
        
        # Trains can split and join, which makes figuring out the list of
        # calling points a bit difficult. The LiveDepartureBoards documentation
        # details how these should be handled. First, we build a list of all
        # the calling points on the "through" train.
        calling_points = service['previousCallingPoints']['callingPointList'][0]['callingPoint'] if len(service['previousCallingPoints']) else []

        # Then attach joining services to our thorough route in the correct
        # point, but only if there is a list of previous calling points
        if len(service['previousCallingPoints']):
            for i, points in enumerate(service['previousCallingPoints']['callingPointList'][1:]):
                # If the other half of the split ends up here, it's not a split, but
                # a change between rail replacement bus of train
                for j, point in enumerate(calling_points):
                    if points['callingPoint'][-1]['crs'] == point['crs']:
                        if j > 0:
                            point['joining'] = points['callingPoint']
                        else:
                            point['service_change'] = service['previousCallingPoints']['callingPointList'][i]['_serviceType']
                            calling_points = points['callingPoint'] + calling_points
                            break
        
        # Add our current station
        calling_points += [{
            'locationName': service['locationName'],
            'crs': service['crs'],
            'st': service['std'] if 'std' in service else service['sta'],
            'et': service['etd'] if 'etd' in service else service['eta'] if 'eta' in service else '',
            'at': service['atd'] if 'atd' in service else '',
        }]
        
        if len(service['subsequentCallingPoints']):
            if service['serviceType'] != service['subsequentCallingPoints']['callingPointList'][0]['_serviceType']:
                calling_points[-1]['service_change'] = ugettext_lazy(service['subsequentCallingPoints']['callingPointList'][0]['_serviceType'])
        
        if len(service['previousCallingPoints']):
            if service['serviceType'] != service['previousCallingPoints']['callingPointList'][0]['_serviceType']:
                calling_points[-1]['service_change'] = ugettext_lazy(service['serviceType'])
        
        # Now add services going forward
        if len(service['subsequentCallingPoints']):
            calling_points += service['subsequentCallingPoints']['callingPointList'][0]['callingPoint']
        
        # And do the same with splitting services
        if len(service['subsequentCallingPoints']):
            for i, points in enumerate(service['subsequentCallingPoints']['callingPointList'][1:]):
                # Now we have to handle changes between trains and rail replacement services
                if service['subsequentCallingPoints']['callingPointList'][i]['callingPoint'][-1]['crs'] == points['callingPoint'][0]['crs']:
                    calling_points += points['callingPoint']
                    points['callingPoint'][0]['service_change'] = ugettext_lazy(points['_serviceType'])
                else:
                    for point in calling_points:
                        if points['callingPoint'][0]['crs'] == point['crs']:
                            point['splitting'] = {'destination': points['callingPoint'][-1]['locationName'], 'list': points['callingPoint']}
            
        sources = [calling_points[0]['locationName']]
        for point in calling_points:
            if 'joining' in point:
                sources.append(point['joining'][0]['locationName'])
        
        destinations = [calling_points[-1]['locationName']]
        for point in calling_points:
            if 'splitting' in point:
                destinations.append(point['splitting']['destination'])
        
        stop_entities = []
        
        # Now get a list of the entities for the stations (if they exist)
        # to plot on a map, and figure out if this stop is delayed or not
        for point in calling_points:
            
            point['problems'] = self.delayed(
                point.get('et', ''), point.get('st', ''), '', '')
            
            if 'joining' in point:
                for jpoint in point['joining']:
                    
                    jpoint['problems'] = self.delayed(
                        jpoint.get('et', ''), jpoint.get('st', ''), '', '')
                    
                    point_entity = Entity.objects.filter(_identifiers__scheme='crs', _identifiers__value=str(jpoint['crs']))
                    if len(point_entity):
                        point_entity = point_entity[0]
                        jpoint['entity'] = point_entity
                        stop_entities.append(point_entity)
                        jpoint['stop_num'] = len(stop_entities)

            point_entity = Entity.objects.filter(_identifiers__scheme='crs', _identifiers__value=str(point['crs']))
            if len(point_entity):
                point_entity = point_entity[0]
                point['entity'] = point_entity
                stop_entities.append(point_entity)
                point['stop_num'] = len(stop_entities)

            if 'splitting' in point:
                for spoint in point['splitting']['list']:
                    
                    spoint['problems'] = self.delayed(
                        spoint.get('et', ''), spoint.get('st', ''), '', '')
                    
                    point_entity = Entity.objects.filter(_identifiers__scheme='crs', _identifiers__value=str(spoint['crs']))
                    if len(point_entity):
                        point_entity = point_entity[0]
                        spoint['entity'] = point_entity
                        stop_entities.append(point_entity)
                        spoint['stop_num'] = len(stop_entities)
        
        if 'std' in service:
            title = service['std'] + ' ' + service['locationName'] + ' to ' + ' and '.join(destinations)
        else:
            # This service arrives here
            title = service['sta'] + ' from ' + ' and '.join(sources)
        
        messages = service.get('adhocAlerts', [])
        
        if 'disruptionReason' in service:
            messages.append(service['disruptionReason'])
        
        if 'overdueMessage' in service:
            messages.append(service['overdueMessage'])
        
        return {
            'title': title,
            'entities': stop_entities,
            'ldb': service,
            'calling_points': calling_points,
            'has_timetable': True,
            'has_realtime': True,
            'operator': service.get('operator'),
            'platform': service.get('platform'),
            'messages': messages
        }
    
    def transform_suds(self, o):
        if isinstance(o, suds.sudsobject.Object):
            return dict((k, self.transform_suds(v)) for k,v in o)
        elif isinstance(o, list):
            return map(self.transform_suds, o)
        else:
            return o

    def _add_error(self, entities):
        for entity in entities:
            entity.metadata['ldb'] = {'error': True}

########NEW FILE########
__FILENAME__ = naptan
import ftplib
import os
import urllib
import zipfile
import tempfile
import random
import re
import csv
from warnings import warn
from collections import defaultdict
from datetime import timedelta
try:
    from cStringIO import StringIO
except:
    from StringIO import StringIO

from xml.sax import ContentHandler, make_parser
import yaml

from django.db import transaction
from django.conf import settings
from django.contrib.gis.geos import Point
from django.utils.translation import ugettext_noop as _
from django.utils.translation import ugettext, get_language

from molly.apps.places.providers import BaseMapsProvider
from molly.apps.places.models import EntityType, Entity, EntityGroup, Source, EntityTypeCategory
from molly.conf.provider import task
from molly.utils.i18n import override, set_name_in_language

class NaptanContentHandler(ContentHandler):

    meta_names = {
        ('AtcoCode',): 'atco-code',
        ('NaptanCode',): 'naptan-code',
        ('PlateCode',): 'plate-code',
        ('Descriptor','CommonName'): 'common-name',
        ('AlternativeDescriptors', 'Descriptor','CommonName'): 'common-name',
        ('Descriptor','Indicator'): 'indicator',
        ('Descriptor','Street'): 'street',
        ('Place','NptgLocalityRef'): 'locality-ref',
        ('Place','Location','Translation','Longitude'): 'longitude',
        ('Place','Location','Translation','Latitude'): 'latitude',
        ('AdministrativeAreaRef',): 'area',
        ('StopAreas', 'StopAreaRef'): 'stop-area',
        ('StopClassification', 'StopType'): 'stop-type',
        ('StopClassification', 'OffStreet', 'Rail', 'AnnotatedRailRef', 'CrsRef'): 'crs',
        ('StopClassification', 'OffStreet', 'Rail', 'AnnotatedRailRef', 'TiplocRef'): 'tiploc',
        ('StopAreaCode',): 'area-code',
        ('Name',): 'name',
    }

    @staticmethod
    def naptan_dial(c):
        """
        Convert a alphabetical NaPTAN code in the database to the numerical code
        used on bus stops
        """
        if c.isdigit():
            return c
        return unicode(min(9, (ord(c)-91)//3))

    def __init__(self, entity_types, source, nptg_localities = None, areas=None):
        self.name_stack = []
        self.entity_types, self.source = entity_types, source
        self.entities = set()
        self.nptg_localities = {} if nptg_localities is None else nptg_localities
        self.areas = areas
        with open(os.path.join(os.path.dirname(__file__), '..', 'data', 'tube-references.yaml')) as fd:
            self.tube_references = yaml.load(fd)

    def startElement(self, name, attrs):
        self.name_stack.append(name)

        if name == 'StopPoint':
            self.stop_areas = []
            self.meta = defaultdict(str)
            self.names = dict()
        elif name == 'StopArea':
            self.meta = defaultdict(str)
            self.names = dict()
        elif name in ('CommonName', 'Name'):
            if 'xml:lang' in attrs:
                self.lang = attrs['xml:lang'].lower()
            else:
                self.lang = None
    
    def endElement(self, name):
        self.name_stack.pop()

        if name == 'StopPoint':
            try:
                # Classify metro stops according to their particular system
                if self.meta['stop-type'] == 'MET':
                    try:
                        entity_type, is_entrance = self.entity_types[self.meta['stop-type'] + ':' + self.meta['atco-code'][6:8]]
                    except KeyError:
                        entity_type, is_entrance = self.entity_types['MET']
                else:
                    entity_type, is_entrance = self.entity_types[self.meta['stop-type']]
            except KeyError:
                pass
            else:
                entity = self.add_stop(self.meta, entity_type, self.source, is_entrance)
                if entity:
                    self.entities.add(entity)
        
        elif name == 'StopAreaRef':
            self.stop_areas.append(self.meta['stop-area'])
            del self.meta['stop-area']
        
        elif name == 'StopArea':
            if self.areas != None:
                in_area = False
                for area in self.areas:
                    if self.meta['area-code'].startswith(area):
                        in_area = True
                if not in_area:
                    return
            
            sa, created = EntityGroup.objects.get_or_create(
                source=self.source,
                ref_code=self.meta['area-code'])
            sa.save()
            for lang_code, name in self.names.items():
                if lang_code is None: lang_code = 'en'
                set_name_in_language(sa, lang_code, title=name)
        
        elif name == 'CommonName':
            if self.lang not in self.names:
                self.names[self.lang] = self.meta['common-name']
        
        elif name == 'Name' and self.meta['name'] != '':
            if self.lang not in self.names:
                self.names[self.lang] = self.meta['name']

    def endDocument(self):
        # Delete all entities which have been deleted in the NaPTAN
        Entity.objects.filter(source=self.source).exclude(id__in=(e.id for e in self.entities)).delete()

    def characters(self, text):
        top = tuple(self.name_stack[3:])

        try:
            self.meta[self.meta_names[top]] += text
        except KeyError:
            pass

    def add_stop(self, meta, entity_type, source, is_entrance):
        
        # Check this entity is in an area
        if self.areas != None:
            in_area = False
            for area in self.areas:
                if meta['atco-code'].startswith(area):
                    in_area = True
            if not in_area:
                return
        
        # See if we're updating an existing object, or creating a new one
        try:
            entity = Entity.objects.get(source=source,
                                        _identifiers__scheme='atco',
                                        _identifiers__value=meta['atco-code'])
        except Entity.DoesNotExist:
            entity = Entity(source=source)
        except Entity.MultipleObjectsReturned:
            # Handle clashes
            Entity.objects.filter(source=source,
                                 _identifiers__scheme='atco',
                                 _identifiers__value=meta['atco-code']).delete()
            entity = Entity(source=source)
        
        common_name, indicator, locality, street = [meta.get(k) for k in
                    ('common-name', 'indicator', 'locality-ref', 'street')]
        
        if (common_name or '').endswith(' DEL') or \
           (indicator or '').lower() == 'not in use' or \
           'to define route' in (common_name or '') or \
           'to def rte' in (common_name or '') or \
           'to def route' in (common_name or '') or \
           'def.rte' in (common_name or ''):
            # In the NaPTAN list, but indicates it's an unused stop
            return
        
        if self.meta['stop-type'] in ('MET','GAT','FER', 'RLY'):
            names = self.names
        else:
            
            names = dict()
            
            for lang_code, lang_name in settings.LANGUAGES:
                with override(lang_code):
                    
                    # Try and find one in our preferred order
                    for lang in (lang_code, 'en', None):
                        if lang in self.names:
                            common_name = self.names[lang]
                            break
                
                    # Expand abbreviations in indicators
                    if indicator is not None:
                        parts = []
                        for part in indicator.split():
                            parts.append({
                                # Translators: This is referring to bus stop location descriptions
                                'op': ugettext('Opposite'),
                                'opp': ugettext('Opposite'),
                                'opposite': ugettext('Opposite'),
                                # Translators: This is referring to bus stop location descriptions
                                'adj': ugettext('Adjacent'),
                                # Translators: This is referring to bus stop location descriptions
                                'outside': ugettext('Outside'),
                                'o/s': ugettext('Outside'),
                                # Translators: This is referring to bus stop location descriptions
                                'nr': ugettext('Near'),
                                # Translators: This is referring to bus stop location descriptions
                                'inside': ugettext('Inside'),
                                # Translators: This is referring to bus stop location descriptions
                                'stp': ugettext('Stop'),
                            }.get(part.lower(), part))
                        indicator = ' '.join(parts)
                    
                    if indicator is None and self.meta['stop-type'] in ('AIR', 'FTD', 'RSE', 'TMU', 'BCE'):
                        # Translators: This is referring to public transport entities
                        title = ugettext('Entrance to %s') % common_name
                    
                    elif indicator is None and self.meta['stop-type'] in ('FBT',):
                        # Translators: This is referring to ferry ports
                        title = ugettext('Berth at %s') % common_name
                    
                    elif indicator is None and self.meta['stop-type'] in ('RPL','PLT'):
                        # Translators: This is referring to rail and metro stations
                        title = ugettext('Platform at %s') % common_name
                    
                    elif indicator is not None and indicator.lower() != 'none' \
                        and indicator not in common_name:
                        title = indicator + ' ' + common_name
                    
                    else:
                        title = common_name
                    
                    if street not in (None, '-', '---'):
                        # Deal with all-caps street names
                        if street.upper() == street:
                            fixedstreet = ''
                            wordstart = True
                            for letter in street:
                                if wordstart:
                                    wordstart = False
                                    fixedstreet += letter
                                    continue
                                elif letter == ' ':
                                    wordstart = True
                                    fixedstreet += letter
                                    continue
                                else:
                                    fixedstreet += letter.lower()
                            street = fixedstreet
                        
                        if street not in title:
                            title += ', ' + street
                    
                    locality_lang = self.nptg_localities.get(locality)
                    if locality_lang != None:
                        for lang in (lang_code, 'en', 'cy'):
                            if lang in locality_lang:
                                if locality_lang[lang] != street:
                                    title += ', ' + locality_lang[lang]
                                break
                    
                    names[lang_code] = title
        
        entity.primary_type = entity_type
        entity.is_entrance = is_entrance
        
        if not entity.metadata:
            entity.metadata = {}
        entity.metadata['naptan'] = meta
        entity.location = Point(float(meta['longitude']), float(meta['latitude']), srid=4326)
        entity.geometry = entity.location
        
        if meta['atco-code'] in self.tube_references:
            entity.metadata['london-underground-identifiers'] = self.tube_references[meta['atco-code']]
        
        identifiers = {
            'atco': meta['atco-code'],
        }
        if 'naptan-code' in meta:
            meta['naptan-code'] = ''.join(map(self.naptan_dial, meta['naptan-code']))
            identifiers['naptan'] = meta['naptan-code']
        if 'plate-code' in meta:
            identifiers['plate'] = meta['plate-code']
        if 'crs' in meta:
            identifiers['crs'] = meta['crs']
        if 'tiploc' in meta:
            identifiers['tiploc'] = meta['tiploc']
        if indicator != None and re.match('Stop [A-Z]\d\d?', indicator):
            identifiers['stop'] = indicator[5:]
        
        entity.save(identifiers=identifiers)
        
        for lang_code, name in names.items():
            # This is the NaPTAN, so default to English
            if lang_code is None: lang_code = 'en'
            set_name_in_language(entity, lang_code, title=name)
        
        entity.all_types = (entity_type,)
        entity.update_all_types_completion()
        entity.groups.clear()
        for stop_area in self.stop_areas:
            sa, created = EntityGroup.objects.get_or_create(source=source, ref_code=stop_area)
            entity.groups.add(sa)
        entity.save()
        
        return entity


class NaptanMapsProvider(BaseMapsProvider):

    HTTP_URL = "http://www.dft.gov.uk/NaPTAN/snapshot/NaPTANxml.zip"
    HTTP_CSV_URL = "http://www.dft.gov.uk/NaPTAN/snapshot/NaPTANcsv.zip"
    HTTP_NTPG_URL = "http://www.dft.gov.uk/nptg/snapshot/nptgcsv.zip"
    FTP_SERVER = 'journeyweb.org.uk'
    TRAIN_STATION = object()
    BUS_STOP_DEFINITION = {
            'slug': 'bus-stop',
            'verbose-name': _('bus stop'),
            'verbose-name-singular': _('a bus stop'),
            'verbose-name-plural': _('bus stops'),
            'nearby': True, 'category': False,
            'uri-local': 'BusStop',
            'is-entrance': False,
        }
    TAXI_RANK_DEFINITION = {
        'slug': 'taxi-rank',
        'verbose-name': _('taxi rank'),
        'verbose-name-singular': _('a taxi rank'),
        'verbose-name-plural': _('taxi ranks'),
        'nearby': False, 'category': False,
        'uri-local': 'TaxiRank',
            'is-entrance': False,
    }
    RAIL_STATION_DEFINITION = {
            'slug': 'rail-station',
            'verbose-name': _('rail station'),
            'verbose-name-singular': _('a rail station'),
            'verbose-name-plural': _('rail stations'),
            'nearby': True, 'category': False,
            'uri-local': 'RailStation',
            'is-entrance': False,
        }
    HERITAGE_RAIL_STATION_DEFINITION = {
            'slug': 'heritage-rail-station',
            'verbose-name': _('heritage rail station'),
            'verbose-name-singular': _('a heritage rail station'),
            'verbose-name-plural': _('heritage rail stations'),
            'nearby': True, 'category': False,
            'uri-local': 'HeritageRailStation',
            'is-entrance': False,
        }

    entity_type_definitions = {
        'BCT': BUS_STOP_DEFINITION,
        'BCS': BUS_STOP_DEFINITION,
        'BCQ': BUS_STOP_DEFINITION,
        'BSE': {
            'slug': 'bus-station-entrance',
            'verbose-name': _('bus station entrance'),
            'verbose-name-singular': _('a bus station entrance'),
            'verbose-name-plural': _('bus station entrances'),
            'nearby': False, 'category': False,
            'uri-local': 'BusStationEntrance',
            'is-entrance': True,
        },
        'TXR': TAXI_RANK_DEFINITION,
        'STR': TAXI_RANK_DEFINITION,
        'RLY': RAIL_STATION_DEFINITION,
        'RSE': {
            'slug': 'rail-station-entrance',
            'verbose-name': _('rail station entrance'),
            'verbose-name-singular': _('a rail station entrance'),
            'verbose-name-plural': _('rail station entrances'),
            'nearby': False, 'category': False,
            'uri-local': 'RailStationEntrance',
            'is-entrance': True,
        },
        'RPL': {
            'slug': 'rail-platform',
            'verbose-name': _('rail platform'),
            'verbose-name-singular': _('a rail platform'),
            'verbose-name-plural': _('rail platforms'),
            'nearby': False, 'category': False,
            'uri-local': 'RailPlatform',
            'is-entrance': False,
        },
        'TMU': {
            'slug': 'metro-entrance',
            # Translators: This is the generic term for rapid transit systems
            'verbose-name': _('metro station entrance'),
            # Translators: This is the generic term for rapid transit systems
            'verbose-name-singular': _('a metro station entrance'),
            # Translators: This is the generic term for rapid transit systems
            'verbose-name-plural': _('metro station entrances'),
            'nearby': False, 'category': False,
            'uri-local': 'MetroEntrance',
            'is-entrance': True,
        },
        'PLT': {
            'slug': 'platform',
            # Translators: This is the generic term for rapid transit systems
            'verbose-name': _('metro station platform'),
            # Translators: This is the generic term for rapid transit systems
            'verbose-name-singular': _('a metro station platform'),
            # Translators: This is the generic term for rapid transit systems
            'verbose-name-plural': _('metro station platforms'),
            'nearby': False, 'category': False,
            'uri-local': 'MetroPlatform',
            'is-entrance': False,
        },
        'MET': {
            'slug': 'metro-station',
            # Translators: This is the generic term for rapid transit systems
            'verbose-name': _('metro station'),
            # Translators: This is the generic term for rapid transit systems
            'verbose-name-singular': _('a metro station'),
            # Translators: This is the generic term for rapid transit systems
            'verbose-name-plural': _('metro stations'),
            'nearby': False, 'category': False,
            'uri-local': 'MetroStation',
            'is-entrance': False,
        },
        'MET:AV': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:BB': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:BF': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:BK': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:BL': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:BP': {
            'slug': 'tramway-stop',
            # Translators: This is the Blackpool tram system
            'verbose-name': _('tramway stop'),
            # Translators: This is the Blackpool tram system
            'verbose-name-singular': _('a tramway stop'),
            # Translators: This is the Blackpool tram system
            'verbose-name-plural': _('tramway stops'),
            'nearby': True, 'category': False,
            'uri-local': 'TramwayStop',
            'is-entrance': False,
        },
        'MET:BV': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:CA': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:CR': {
            'slug': 'tramlink-stop',
            'verbose-name': _('tram stop'),
            'verbose-name-singular': _('a tram stop'),
            'verbose-name-plural': _('tram stops'),
            'nearby': True, 'category': False,
            'uri-local': 'TramlinkStop',
            'is-entrance': False,
        },
        'MET:CV': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:CW': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:DF': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:DL': {
            'slug': 'dlr-station',
            # Translators: This is the Docklands Light Railway
            'verbose-name': _('DLR station'),
            # Translators: This is the Docklands Light Railway
            'verbose-name-singular': _('a DLR station'),
            # Translators: This is the Docklands Light Railway
            'verbose-name-plural': _('DLR stations'),
            'nearby': True, 'category': False,
            'uri-local': 'DLRStation',
            'is-entrance': False,
        },
        'MET:DM': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:EB': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:EK': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:EL': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:EV': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:FB': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:FF': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:GC': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:GL': {
            'slug': 'subway-station',
            # Translators: This is the Glasgow Subway
            'verbose-name': _('Subway station'),
            # Translators: This is the Glasgow Subway
            'verbose-name-singular': _('a Subway station'),
            # Translators: This is the Glasgow Subway
            'verbose-name-plural': _('Subway stations'),
            'nearby': True, 'category': False,
            'uri-local': 'SubwayStation',
            'is-entrance': False,
        },
        'MET:GO': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:GW': {
            'slug': 'shuttle-station',
            # Translators: This is the Gatwick airport shuttle
            'verbose-name': _('shuttle station'),
            # Translators: This is the Gatwick airport shuttle
            'verbose-name-singular': _('a shuttle station'),
            # Translators: This is the Gatwick airport shuttle
            'verbose-name-plural': _('shuttle stations'),
            'nearby': True, 'category': False,
            'uri-local': 'ShuttleStation',
            'is-entrance': False,
        },
        'MET:GR': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:IW': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:KD': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:KE': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:KW': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:LH': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:LL': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:LU': {
            'slug': 'tube-station',
            # Translators: This is the London Underground (Tube)
            'verbose-name': _('Underground station'),
            # Translators: This is the London Underground (Tube)
            'verbose-name-singular': _('an Underground station'),
            # Translators: This is the London Underground (Tube)
            'verbose-name-plural': _('Underground stations'),
            'nearby': True, 'category': False,
            'uri-local': 'TubeStation',
            'is-entrance': False,
        },
        'MET:MA': {
            'slug': 'metrolink-station',
            # Translators: This is the Manchester tram system
            'verbose-name': _('Metrolink station'),
            # Translators: This is the Manchester tram system
            'verbose-name-singular': _('a Metrolink station'),
            # Translators: This is the Manchester tram system
            'verbose-name-plural': _('Metrolink stations'),
            'nearby': True, 'category': False,
            'uri-local': 'MetrolinkStation',
            'is-entrance': False,
        },
        'MET:MH': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:MN': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:NN': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:NO': {
            'slug': 'net-stop',
            'verbose-name': _('tram stop'),
            'verbose-name-singular': _('a tram stop'),
            'verbose-name-plural': _('tram stops'),
            'nearby': True, 'category': False,
            'uri-local': 'NETStop',
            'is-entrance': False,
        },
        'MET:NV': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:NY': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:PD': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:PR': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:RE': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:RH': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:SD': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:SL': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:SM': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:SP': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:SR': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:ST': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:SV': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:SY': {
            'slug': 'supertram-stop',
            # Translators: This is the Sheffield tram system
            'verbose-name': _('Supertram stop'),
            # Translators: This is the Sheffield tram system
            'verbose-name-singular': _('a Supertram stop'),
            # Translators: This is the Sheffield tram system
            'verbose-name-plural': _('Supertram stops'),
            'nearby': True, 'category': False,
            'uri-local': 'SupertramStop',
            'is-entrance': False,
        },
        'MET:TL': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:TW': {
            'slug': 'tyne-and-wear-metro-station',
            # Translators: This is the Tyne & Wear metro system
            'verbose-name': _('Metro station'),
            # Translators: This is the Tyne & Wear metro system
            'verbose-name-singular': _('a Metro station'),
            # Translators: This is the Tyne & Wear metro system
            'verbose-name-plural': _('Metro stations'),
            'nearby': True, 'category': False,
            'uri-local': 'TyneAndWearMetroStation',
            'is-entrance': False,
        },
        'MET:TY': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:VR': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:WD': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:WH': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:WL': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:WM': {
            'slug': 'midland-metro-stop',
            # Translators: This is the Midland Metro system
            'verbose-name': _('Midland Metro stop'),
            # Translators: This is the Midland Metro system
            'verbose-name-singular': _('a Midland Metro stop'),
            # Translators: This is the Midland Metro system
            'verbose-name-plural': _('Midland Metro stops'),
            'nearby': True, 'category': False,
            'uri-local': 'MidlandMetroStation',
            'is-entrance': False,
        },
        'MET:WS': HERITAGE_RAIL_STATION_DEFINITION,
        'MET:WW': HERITAGE_RAIL_STATION_DEFINITION,
        'GAT': {
            'slug': 'airport',
            'verbose-name': _('airport'),
            'verbose-name-singular': _('an airport'),
            'verbose-name-plural': _('airports'),
            'nearby': True, 'category': False,
            'uri-local': 'Airport',
            'is-entrance': False,
        },
        'AIR': {
            'slug': 'airport-entrance',
            'verbose-name': _('airport entrance'),
            'verbose-name-singular': _('an airport entrance'),
            'verbose-name-plural': _('airport entrances'),
            'nearby': False, 'category': False,
            'uri-local': 'AirportEntrance',
            'is-entrance': True,
        },
        'FER': {
            'slug': 'ferry-terminal',
            'verbose-name': _('ferry terminal'),
            'verbose-name-singular': _('a ferry terminal'),
            'verbose-name-plural': _('ferry terminals'),
            'nearby': True, 'category': False,
            'uri-local': 'FerryTerminal',
            'is-entrance': False,
        },
        'FTD': {
            'slug': 'ferry-terminal-entrance',
            'verbose-name': _('ferry terminal entrance'),
            'verbose-name-singular': _('a ferry terminal entrance'),
            'verbose-name-plural': _('ferry terminal entrances'),
            'nearby': False, 'category': False,
            'uri-local': 'FerryTerminalEntrance',
            'is-entrance': True,
        },
        'FBT': {
            'slug': 'ferry-berth',
            'verbose-name': _('ferry berth'),
            'verbose-name-singular': _('a ferry berth'),
            'verbose-name-plural': _('ferry berths'),
            'nearby': False, 'category': False,
            'uri-local': 'FerryBerth',
            'is-entrance': False,
        },
        None: {
            'slug': 'public-transport-access-node',
            'verbose-name': _('public transport access node'),
            'verbose-name-singular': _('a public transport access node'),
            'verbose-name-plural': _('public transport access nodes'),
            'nearby': False, 'category': False,
            'uri-local': 'PublicTransportAccessNode',
            'is-entrance': False,
        }
    }


    def __init__(self, method=None, areas=None, username=None, password=None):
        self._username, self._password = username, password
        self._method = method
        if self._method:
            warn('method is deprecated, only HTTP is now supported', DeprecationWarning)
        
        # Add 910 because we always want to import railway stations
        if areas is not None:
            areas += ('910',)
        self._areas = areas

    @task(run_every=timedelta(days=7))
    def import_data(self, **metadata):
        username, password = self._username, self._password

        self._source = self._get_source()
        self._entity_types = self._get_entity_types()
        
        # Get NPTG localities
        archive = zipfile.ZipFile(StringIO(urllib.urlopen(self.HTTP_NTPG_URL).read()))
        f = StringIO(archive.read('Localities.csv'))
        falt = StringIO(archive.read('LocalityAlternativeNames.csv'))
        localities = self._get_nptg_alt_names(falt, self._get_nptg(f))
        
        with tempfile.TemporaryFile() as temp:
            temp.write(urllib.urlopen(self.HTTP_URL).read())
            archive = zipfile.ZipFile(temp)
            if hasattr(archive, 'open'):
                f = archive.open('NaPTAN.xml')
            else:
                f = StringIO(archive.read('NaPTAN.xml'))
            self._import_from_pipe(f, localities, areas=self._areas)
            archive.close()

    @transaction.commit_on_success
    def _import_from_pipe(self, pipe_r, localities, areas=None):
        parser = make_parser()
        parser.setContentHandler(NaptanContentHandler(self._entity_types, self._source, localities, areas))
        parser.parse(pipe_r)

    def _get_nptg(self, f):
        localities=defaultdict(dict)
        csvfile = csv.reader(f)
        csvfile.next()
        for line in csvfile:
            if line[2].lower() not in localities[line[0]]:
                localities[line[0]][line[2].lower()] = line[1]
        return localities

    def _get_nptg_alt_names(self, f, localities):
        csvfile = csv.reader(f)
        csvfile.next()
        for line in csvfile:
            if line[3].lower() not in localities[line[0]]:
                localities[line[0]][line[3].lower()] = line[2]
        return localities

    def _get_entity_types(self):

        entity_types = {}
        category, created = EntityTypeCategory.objects.get_or_create(name=_('Transport'))
        category.save()
        
        for stop_type in self.entity_type_definitions:
            et = self.entity_type_definitions[stop_type]
            
            try:
                entity_type = EntityType.objects.get(slug=et['slug'])
            except EntityType.DoesNotExist:
                entity_type = EntityType(slug=et['slug'])
            
            entity_type.category = category
            entity_type.uri = "http://mollyproject.org/schema/maps#%s" % et['uri-local']
            if created:
                entity_type.show_in_nearby_list = et['nearby']
                entity_type.show_in_category_list = et['category']
            entity_type.save()
            for lang_code, lang_name in settings.LANGUAGES:
                with override(lang_code):
                    set_name_in_language(entity_type, lang_code,
                                         verbose_name=ugettext(et['verbose-name']),
                                         verbose_name_singular=ugettext(et['verbose-name-singular']),
                                         verbose_name_plural=ugettext(et['verbose-name-plural']))
            
            entity_types[stop_type] = (entity_type, et['is-entrance'])

        for stop_type, (entity_type, is_entrance) in entity_types.items():
            if entity_type.slug == 'public-transport-access-node':
                continue
            entity_type.subtype_of.add(entity_types[None][0])
            if stop_type.startswith('MET') and stop_type != 'MET' and entity_type.slug != self.RAIL_STATION_DEFINITION['slug']:
                entity_type.subtype_of.add(entity_types['MET'][0])
        
        return entity_types

    def _get_source(self):
        try:
            source = Source.objects.get(module_name="molly.providers.apps.maps.naptan")
        except Source.DoesNotExist:
            source = Source(module_name="molly.providers.apps.maps.naptan")

        source.name = "National Public Transport Access Nodes (NaPTAN) database"
        source.save()

        return source

try:
    from secrets import SECRETS
except ImportError:
    pass
else:
    if __name__ == '__main__':
        p = NaptanMapsProvider(method='ftp', username=SECRETS.journeyweb[0], password=SECRETS.journeyweb[1], areas=('340',))
        p.import_data()

########NEW FILE########
__FILENAME__ = osm
# -*- coding: utf-8 -*-
import urllib2
import bz2
import subprocess
import sys
import random
import os
import yaml
import logging

from xml.sax import saxutils, handler, make_parser
from datetime import timedelta

from django.db import reset_queries
from django.contrib.gis.geos import Point, LineString, LinearRing
from django.conf import settings
from django.utils.translation import ugettext as _
from django.utils.translation import ugettext_noop
from django.utils.translation import get_language

from molly.apps.places import get_entity
from molly.apps.places.models import (Entity, EntityType, Source,
                                      EntityTypeCategory, EntityName)
from molly.apps.places.providers import BaseMapsProvider
from molly.utils.misc import AnyMethodRequest
from molly.utils.i18n import override, set_name_in_language
from molly.geolocation import reverse_geocode
from molly.conf.provider import task


logger = logging.getLogger(__name__)

def node_id(id):
    return "N%d" % int(id)
def way_id(id):
    return "W%d" % int(id)

class OSMHandler(handler.ContentHandler):
    def __init__(self, source, entity_types, find_types, lat_north=None,
                 lat_south=None, lon_west=None, lon_east=None, identities={}):
        self.source = source
        self.entity_types = entity_types
        self.find_types = find_types
        self._lat_north = lat_north
        self._lat_south = lat_south
        self._lon_west = lon_west
        self._lon_east = lon_east
        self.identities = identities

    def startDocument(self):
        self.ids = set()
        self.tags = {}
        self.valid_node = True
        
        self.create_count, self.modify_count = 0,0
        self.delete_count, self.unchanged_count = 0,0
        self.ignore_count = 0
        
        self.node_locations = {}

    def startElement(self, name, attrs):
        
        if name == 'node':
            lon, lat = float(attrs['lon']), float(attrs['lat'])
            
            # Always import if restrictions aren't set
            if self._lat_north is None:
                self.valid = True
            else:
                self.valid = (self._lat_south < lat < self._lat_north \
                              and self._lon_west < lon < self._lon_east)
                if not self.valid:
                    return
            
            id = node_id(attrs['id'])
            self.node_location = lon, lat
            self.attrs = attrs
            self.id = id
            self.ids.add(id)
            self.tags = {}
            self.node_locations[id] = lon, lat
        
        elif name == 'tag' and self.valid:
            self.tags[attrs['k']] = attrs['v']
        
        elif name == 'way':
            self.nodes = []
            self.tags = {}
            self.valid = True
            
            id = way_id(attrs['id'])
            
            self.id = id
            self.ids.add(id)
        
        elif name == 'nd':
            self.nodes.append( node_id(attrs['ref']) )
    
    def endElement(self, name):
        if name in ('node','way') and self.valid:
            try:
                types = self.find_types(self.tags)
            except ValueError:
                self.ignore_count += 1
                return
            
            # Ignore ways that lay partly outside our bounding box
            if name == 'way' and not all(id in self.node_locations for id in self.nodes):
                return
            
            # Ignore disused and under-construction entities
            if self.tags.get('life_cycle', 'in_use') != 'in_use' or self.tags.get('disused') in ('1', 'yes', 'true'):
                return
            
            # Memory management in debug mode
            reset_queries()
            
            if self.id in self.identities:
                entity = get_entity(*self.identities[self.id].split(':'))
                
                entity.metadata['osm'] = {
                    'attrs': dict(self.attrs),
                    'tags': dict(zip((k.replace(':', '_') for k in self.tags.keys()), self.tags.values()))
                }
                
                identifiers = entity.identifiers
                identifiers.update({
                    'osm': self.id
                })
                entity.save(identifiers=identifiers)
                entity.all_types = set(entity.all_types.all()) | set(self.entity_types[et] for et in types)
                entity.update_all_types_completion()
                self.ids.remove(self.id)
                
            else:
                try:
                    entity = Entity.objects.get(source=self.source,
                                                _identifiers__scheme='osm',
                                                _identifiers__value=self.id)
                    created = False
                except Entity.DoesNotExist:
                    entity = Entity(source=self.source)
                    created = True
            
                if not 'osm' in entity.metadata or \
                  entity.metadata['osm'].get('attrs', {}).get('timestamp', '') < self.attrs['timestamp']:
                    
                    if created:
                        self.create_count += 1
                    else:
                        self.modify_count += 1
                    
                    if name == 'node':
                        entity.location = Point(self.node_location, srid=4326)
                        entity.geometry = entity.location
                    elif name == 'way':
                        cls = LinearRing if self.nodes[0] == self.nodes[-1] else LineString
                        entity.geometry = cls([self.node_locations[n] for n in self.nodes], srid=4326)
                        min_, max_ = (float('inf'), float('inf')), (float('-inf'), float('-inf'))
                        for lon, lat in [self.node_locations[n] for n in self.nodes]:
                            min_ = min(min_[0], lon), min(min_[1], lat) 
                            max_ = max(max_[0], lon), max(max_[1], lat)
                        entity.location = Point( (min_[0]+max_[0])/2 , (min_[1]+max_[1])/2 , srid=4326)
                    else:
                        raise AssertionError("There should be no other types of entity we're to deal with.")
                    
                    names = dict()
                    
                    for lang_code, lang_name in settings.LANGUAGES:
                        with override(lang_code):
                        
                            if '-' in lang_code:
                                tags_to_try = ('name:%s' % lang_code, 'name:%s' % lang_code.split('-')[0], 'name', 'operator')
                            else:
                                tags_to_try = ('name:%s' % lang_code, 'name', 'operator')
                                name = None
                                for tag_to_try in tags_to_try:
                                    if self.tags.get(tag_to_try):
                                        name = self.tags.get(tag_to_try)
                                        break
                            
                            if name is None:
                                try:
                                    name = reverse_geocode(*entity.location)[0]['name']
                                    if not name:
                                        raise IndexError
                                    name = u"↝ %s" % name
                                except IndexError:
                                    name = u"↝ %f, %f" % (self.node_location[1], self.node_location[0])
                            
                            names[lang_code] = name
                    
                    entity.metadata['osm'] = {
                        'attrs': dict(self.attrs),
                        'tags': dict(zip((k.replace(':', '_') for k in self.tags.keys()), self.tags.values()))
                    }
                    entity.primary_type = self.entity_types[types[0]]
                    
                    identifiers = entity.identifiers
                    identifiers.update({
                        'osm': self.id
                    })
                    entity.save(identifiers=identifiers)
                    
                    for lang_code, name in names.items():
                        set_name_in_language(entity, lang_code, title=name)
                    
                    entity.all_types = [self.entity_types[et] for et in types]
                    entity.update_all_types_completion()
                
                else:
                    self.unchanged_count += 1

    def endDocument(self):
        for entity in Entity.objects.filter(source=self.source):
            if entity.identifiers.get('osm') not in self.ids:
                entity.delete()
                self.delete_count += 1
        
        logger.info("""\
Complete
  Created:   %6d
  Modified:  %6d
  Deleted:   %6d
  Unchanged: %6d
  Ignored:   %6d
""" % (
            self.create_count,
            self.modify_count,
            self.delete_count,
            self.unchanged_count,
            self.ignore_count,
        ))

class OSMMapsProvider(BaseMapsProvider):

    def __init__(self, lat_north=None, lat_south=None,
                 lon_west=None, lon_east=None,
                 url='http://download.geofabrik.de/openstreetmap/europe/great_britain/england.osm.bz2',
                 entity_type_data_file=None,
                 osm_tags_data_file=None,
                 identities_file=None):
        """
        @param lat_north: A limit of the northern-most latitude to import points
                          for
        @type lat_north: float
        @param lat_south: A limit of the southern-most latitude to import points
                          for
        @type lat_south: float
        @param lon_west: A limit of the western-most longitude to import points
                          for
        @type lon_west: float
        @param lon_east: A limit of the eastern-most longitude to import points
                          for
        @type lon_east: float
        @param url: The URL of the OSM planet file to download (defaults to
                    England)
        @type url: str
        @param entity_type_data_file: A YAML file defining the entity types
                                      which the OSM importer should create
        @type entity_type_data_file: str
        @param osm_tags_data_file: A YAML file defining the OSM tags which
                                   should be imported, and how these map to
                                   Molly's entity types
        @type osm_tags_data_file: str
        @param identities_file: A YAML file containing a mapping from OSM IDs
                                to any other namespace of entities. When an ID
                                is matched in this file, a new entitity is not
                                created, but instead associated with the other one
        @type identities_file: str
        """
        self._lat_north = lat_north
        self._lat_south = lat_south
        self._lon_west = lon_west
        self._lon_east = lon_east
        self._url = url
        
        if entity_type_data_file is None:
            entity_type_data_file = os.path.join(os.path.dirname(__file__),
                                                 '..', 'data', 'osm-entity-types.yaml')
        with open(entity_type_data_file) as fd:
            self._entity_types = yaml.load(fd)
            
        if osm_tags_data_file is None:
            osm_tags_data_file = os.path.join(os.path.dirname(__file__),
                                                 '..', 'data', 'osm-tags.yaml')
        with open(osm_tags_data_file) as fd:
            def to_tuple(tag):
                """
                Converts the new-style OSM tag file into the old-style tuple
                representation
                """
                if 'subtags' in tag:
                    return (tag['osm-tag'],
                            map(to_tuple, tag['subtags']),
                            tag['entity-type'])
                else:
                    return (tag['osm-tag'],
                            tag['entity-type'])
            self._osm_tags = map(to_tuple, yaml.load(fd))
        
        if identities_file is not None:
            with open(identities_file) as fd:
                self.identities = yaml.load(fd)
        else:
            self.identities = {}

    @task(run_every=timedelta(days=7))
    def import_data(self, **metadata):
        "Imports places data from OpenStreetMap"
        
        old_etag = metadata.get('etag', '')
        
        request = AnyMethodRequest(self._url, method='HEAD')
        response = urllib2.urlopen(request)
        new_etag = response.headers['ETag'][1:-1]
        
        if not settings.DEBUG and new_etag == old_etag:
            logger.info('OSM data not updated. Not updating.\n')
            return
        
        parser = make_parser(['xml.sax.xmlreader.IncrementalParser'])
        parser.setContentHandler(OSMHandler(self._get_source(),
                                            self._get_entity_types(),
                                            lambda tags, type_list=None: self._find_types(tags, self._osm_tags if type_list is None else type_list),
                                            self._lat_north,
                                            self._lat_south,
                                            self._lon_west,
                                            self._lon_east,
                                            self.identities))
        
        # Parse in 8k chunks
        osm = urllib2.urlopen(self._url)
        buffer = osm.read(8192)
        bunzip = bz2.BZ2Decompressor()
        while buffer:
            parser.feed(bunzip.decompress(buffer))
            buffer = osm.read(8192)
        parser.close()
        
        for lang_code, lang_name in settings.LANGUAGES:
            with override(lang_code):
                self.disambiguate_titles(self._get_source())
        
        return {
            'etag': new_etag,
        }

    def _get_source(self):
        try:
            source = Source.objects.get(module_name="molly.providers.apps.maps.osm")
        except Source.DoesNotExist:
            source = Source(module_name="molly.providers.apps.maps.osm")
        
        source.name = "OpenStreetMap"
        source.save()
        
        return source

    def _get_entity_types(self):
        
        entity_types = {}
        new_entity_types = set()
        for slug, et in self._entity_types.items():
            et_category, created = EntityTypeCategory.objects.get_or_create(name=et['category'])
            try:
                entity_type = EntityType.objects.get(slug=slug)
                created = False
            except EntityType.DoesNotExist:
                entity_type = EntityType(slug=slug)
                created = True
            entity_type.category = et_category
            entity_type.slug = slug
            if created:
                entity_type.show_in_nearby_list = et['show_in_nearby_list']
                entity_type.show_in_category_list = et['show_in_category_list']
            entity_type.save()
            for lang_code, lang_name in settings.LANGUAGES:
                with override(lang_code):
                    set_name_in_language(entity_type, lang_code,
                                         verbose_name=_(et['verbose_name']),
                                         verbose_name_singular=_(et['verbose_name_singular']),
                                         verbose_name_plural=_(et['verbose_name_plural']))
            new_entity_types.add(slug)
            entity_types[slug] = entity_type
        
        for slug in new_entity_types:
            subtype_of = self._entity_types[slug]['parent-types']
            entity_types[slug].subtype_of.clear()
            for s in subtype_of:
                entity_types[slug].subtype_of.add(entity_types[s])
            entity_types[slug].save()
        
        return entity_types

    def _find_types(self, tags, type_list):
        found_types = []
        for item in type_list:
            tag, value = item[0].split('=')
            if tags.get(tag) == value:
                if len(item) == 2:
                    found_types.append(item[1])
                else:
                    try:
                        found_types += self._find_types(tags, item[1])
                    except ValueError:
                        found_types.append(item[2])
        if found_types:
            return found_types
        else:
            raise ValueError

    def disambiguate_titles(self, source):
        lang_code = get_language()
        entities = Entity.objects.filter(source=source)
        inferred_names = {}
        if '-' in lang_code:
            tags_to_try = ('name-%s' % lang_code, 'name-%s' % lang_code.split('-')[0], 'name', 'operator')
        else:
            tags_to_try = ('name-%s' % lang_code, 'name', 'operator')
        for entity in entities:
            inferred_name = None
            for tag_to_try in tags_to_try:
                if entity.metadata['osm']['tags'].get(tag_to_try):
                    inferred_name = entity.metadata['osm']['tags'].get(tag_to_try)
                    break
            if not inferred_name:
                continue
            if not inferred_name in inferred_names:
                inferred_names[inferred_name] = set()
            inferred_names[inferred_name].add(entity)
        
        for inferred_name, entities in inferred_names.items():
            if len(entities) > 1:
                for entity in entities:
                    if entity.metadata['osm']['tags'].get('addr_street'):
                        title = u"%s, %s" % (inferred_name, entity.metadata['osm']['tags'].get('addr_street'))
                    else:
                        try:
                            place_name = reverse_geocode(entity.location[0], entity.location[1])[0]['name']
                            if place_name:
                                title = u"%s, %s" % (inferred_name, place_name)
                                entity.save()
                            else:
                                title = inferred_name
                        except:
                            logger.info("Couldn't geocode for %s\n" % inferred_name)
                            title = inferred_name
                    try:
                        name = entity.names.get(language_code=lang_code)
                    except EntityName.DoesNotExist:
                        name = entity.names.create(language_code=lang_code,
                                                   title=title)
                    else:
                        name.title = title
                    finally:
                        name.save()

if __name__ == '__main__':
    provider = OSMMapsProvider()
    provider.import_data()

# IGNORE BELOW HERE! These are dummy EntityType definitions that exist so they
# get picked up as ready to translate
# THIS CODE DOES NOTHING, CHANGING HERE WON'T DO WHAT YOU THINK IT DOES
DUMMY = {
    'atm': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('ATM'),
        'verbose_name_plural': ugettext_noop('ATMs'),
        'verbose_name_singular': ugettext_noop('an ATM')
    },
    'bank': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('bank'),
        'verbose_name_plural': ugettext_noop('banks'),
        'verbose_name_singular': ugettext_noop('a bank')
    },
    'bar': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('bar'),
        'verbose_name_plural': ugettext_noop('bars'),
        'verbose_name_singular': ugettext_noop('a bar')
    },
    'bench': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('bench'),
        'verbose_name_plural': ugettext_noop('benches'),
        'verbose_name_singular': ugettext_noop('a bench')
    },
    'bicycle-parking': {
        'category': ugettext_noop('Transport'),
        'verbose_name': ugettext_noop('bicycle rack'),
        'verbose_name_plural': ugettext_noop('bicycle racks'),
        'verbose_name_singular': ugettext_noop('a bicycle rack')
    },
    'cafe': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop(u'café'),
        'verbose_name_plural': ugettext_noop(u'cafés'),
        'verbose_name_singular': ugettext_noop(u'a café')
    },
    'car-park': {
        'category': ugettext_noop('Transport'),
        'verbose_name': ugettext_noop('car park'),
        'verbose_name_plural': ugettext_noop('car parks'),
        'verbose_name_singular': ugettext_noop('a car park')
    },
    'cathedral': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('cathedral'),
        'verbose_name_plural': ugettext_noop('cathedrals'),
        'verbose_name_singular': ugettext_noop('a cathedral')
    },
    'chapel': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('chapel'),
        'verbose_name_plural': ugettext_noop('chapels'),
        'verbose_name_singular': ugettext_noop('a chapel')
    },
    'church': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('church'),
        'verbose_name_plural': ugettext_noop('churches'),
        'verbose_name_singular': ugettext_noop('a church')
    },
    'cinema': {
        'category': ugettext_noop('Leisure'),
        'verbose_name': ugettext_noop('cinema'),
        'verbose_name_plural': ugettext_noop('cinemas'),
        'verbose_name_singular': ugettext_noop('a cinema')
    },
    'cycle-shop': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('cycle shop'),
        'verbose_name_plural': ugettext_noop('cycle shops'),
        'verbose_name_singular': ugettext_noop('a cycle shop')
    },
    'dispensing-pharmacy': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('dispensing pharmacy'),
        'verbose_name_plural': ugettext_noop('dispensing pharmacies'),
        'verbose_name_singular': ugettext_noop('a dispensing pharmacy')
    },
    'doctors': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop("doctor's surgery"),
        'verbose_name_plural': ugettext_noop("doctors' surgeries"),
        'verbose_name_singular': ugettext_noop("a doctor's surgery")
    },
    'fast-food': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('fast food outlet'),
        'verbose_name_plural': ugettext_noop('fast food outlets'),
        'verbose_name_singular': ugettext_noop('a fast food outlet')
    },
    'food': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('place to eat'),
        'verbose_name_plural': ugettext_noop('places to eat'),
        'verbose_name_singular': ugettext_noop('a place to eat')
    },
    'hospital': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('hospital'),
        'verbose_name_plural': ugettext_noop('hospitals'),
        'verbose_name_singular': ugettext_noop('a hospital')
    },
    'ice-cream': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop(u'ice cream café'),
        'verbose_name_plural': ugettext_noop(u'ice cream cafés'),
        'verbose_name_singular': ugettext_noop(u'an ice cream café')
    },
    'ice-rink': {
        'category': ugettext_noop('Leisure'),
        'verbose_name': ugettext_noop('ice rink'),
        'verbose_name_plural': ugettext_noop('ice rinks'),
        'verbose_name_singular': ugettext_noop('an ice rink')
    },
    'library': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('library'),
        'verbose_name_plural': ugettext_noop('libraries'),
        'verbose_name_singular': ugettext_noop('a library')
    },
    'mandir': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('mandir'),
        'verbose_name_plural': ugettext_noop('mandirs'),
        'verbose_name_singular': ugettext_noop('a mandir')
    },
    'medical': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('place relating to health'),
        'verbose_name_plural': ugettext_noop('places relating to health'),
        'verbose_name_singular': ugettext_noop('a place relating to health')
    },
    'mosque': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('mosque'),
        'verbose_name_plural': ugettext_noop('mosques'),
        'verbose_name_singular': ugettext_noop('a mosque')
    },
    'museum': {
        'category': ugettext_noop('Leisure'),
        'verbose_name': ugettext_noop('museum'),
        'verbose_name_plural': ugettext_noop('museums'),
        'verbose_name_singular': ugettext_noop('a museum')
    },
    'park': {
        'category': ugettext_noop('Leisure'),
        'verbose_name': ugettext_noop('park'),
        'verbose_name_plural': ugettext_noop('parks'),
        'verbose_name_singular': ugettext_noop('a park')
    },
    'park-and-ride': {
        'category': ugettext_noop('Transport'),
        'verbose_name': ugettext_noop('park and ride'),
        'verbose_name_plural': ugettext_noop('park and rides'),
        'verbose_name_singular': ugettext_noop('a park and ride')
    },
    'pharmacy': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('pharmacy'),
        'verbose_name_plural': ugettext_noop('pharmacies'),
        'verbose_name_singular': ugettext_noop('a pharmacy')
    },
    'place-of-worship': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('place of worship'),
        'verbose_name_plural': ugettext_noop('places of worship'),
        'verbose_name_singular': ugettext_noop('a place of worship')
    },
    'post-box': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('post box'),
        'verbose_name_plural': ugettext_noop('post boxes'),
        'verbose_name_singular': ugettext_noop('a post box')
    },
    'post-office': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('post office'),
        'verbose_name_plural': ugettext_noop('post offices'),
        'verbose_name_singular': ugettext_noop('a post office')
    },
    'pub': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('pub'),
        'verbose_name_plural': ugettext_noop('pubs'),
        'verbose_name_singular': ugettext_noop('a pub')
    },
    'public-library': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('public library'),
        'verbose_name_plural': ugettext_noop('public libraries'),
        'verbose_name_singular': ugettext_noop('a public library')
    },
    'punt-hire': {
        'category': ugettext_noop('Leisure'),
        'verbose_name': ugettext_noop('place to hire punts'),
        'verbose_name_plural': ugettext_noop('places to hire punts'),
        'verbose_name_singular': ugettext_noop('a place to hire punts')
    },
    'recycling': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('recycling facility'),
        'verbose_name_plural': ugettext_noop('recycling facilities'),
        'verbose_name_singular': ugettext_noop('a recycling facility')
    },
    'restaurant': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('restaurant'),
        'verbose_name_plural': ugettext_noop('restaurants'),
        'verbose_name_singular': ugettext_noop('a restaurant')
    },
    'shop': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('shop'),
        'verbose_name_plural': ugettext_noop('shops'),
        'verbose_name_singular': ugettext_noop('a shop')
    },
    'sport': {
        'category': ugettext_noop('Leisure'),
        'verbose_name': ugettext_noop('place relating to sport'),
        'verbose_name_plural': ugettext_noop('places relating to sport'),
        'verbose_name_singular': ugettext_noop('a place relating to sport')
    },
    'sports-centre': {
        'category': ugettext_noop('Leisure'),
        'verbose_name': ugettext_noop('sports centre'),
        'verbose_name_plural': ugettext_noop('sports centres'),
        'verbose_name_singular': ugettext_noop('a sports centre')
    },
    'swimming-pool': {
        'category': ugettext_noop('Leisure'),
        'verbose_name': ugettext_noop('swimming pool'),
        'verbose_name_plural': ugettext_noop('swimming pools'),
        'verbose_name_singular': ugettext_noop('a swimming pool')
    },
    'synagogue': {
        'category': ugettext_noop('Amenities'),
        'verbose_name': ugettext_noop('synagogue'),
        'verbose_name_plural': ugettext_noop('synagogues'),
        'verbose_name_singular': ugettext_noop('a synagogue')
    },
    'taxi-rank': {
        'category': ugettext_noop('Transport'),
        'verbose_name': ugettext_noop('taxi rank'),
        'verbose_name_plural': ugettext_noop('taxi ranks'),
        'verbose_name_singular': ugettext_noop('a taxi rank')
    },
    'theatre': {
        'category': ugettext_noop('Leisure'),
        'verbose_name': ugettext_noop('theatre'),
        'verbose_name_plural': ugettext_noop('theatres'),
        'verbose_name_singular': ugettext_noop('a theatre')
    },
    'tourist-information': {
        'category': ugettext_noop('Leisure'),
        'verbose_name': ugettext_noop('tourist information point'),
        'verbose_name_plural': ugettext_noop('tourist information points'),
        'verbose_name_singular': ugettext_noop('a tourist information point')
    },
    'tourist-attraction': {
        'category': ugettext_noop('Leisure'),
        'verbose_name': ugettext_noop('tourist attraction'),
        'verbose_name_plural': ugettext_noop('tourist attractions'),
        'verbose_name_singular': ugettext_noop('a tourist attraction')
    },
}

########NEW FILE########
__FILENAME__ = postcodes
import simplejson
import urllib
import random
import csv
import zipfile
import tempfile
import urllib2
import os.path
import re

from datetime import timedelta
from django.db import transaction, reset_queries
from django.conf import settings
from django.contrib.gis.geos import Point
from django.utils.translation import ugettext_noop
from django.utils.translation import ugettext as _

from molly.apps.places.providers import BaseMapsProvider
from molly.apps.places.models import Entity, EntityType, Source, EntityTypeCategory
from molly.utils.i18n import override, set_name_in_language

from molly.conf.provider import task

class PostcodesMapsProvider(BaseMapsProvider):
    def __init__(self, codepoint_path, import_areas=None):
        self.codepoint_path = codepoint_path
        self.import_areas = import_areas

    CODEPOINT_OPEN_URL = 'http://freepostcodes.org.uk/static/code-point-open/codepo_gb.zip'
    MODULE_NAME = "molly.providers.apps.maps.postcodes"

    def _download_codepoint_open(self):

            archive_url = urllib2.urlopen(self.CODEPOINT_OPEN_URL)
            archive_file = open(self.codepoint_path, 'wb')
            archive_file.write(archive_url.read())
            archive_file.close()

    @task(run_every=timedelta(days=365))
    def import_data(self, **metadata):

        entity_type, source = self._get_entity_type(), self._get_source()
        
        if not os.path.exists(self.codepoint_path):
            self._download_codepoint_open()
        
        try:
            archive = zipfile.ZipFile(self.codepoint_path)
        except zipfile.BadZipfile:
            self._download_codepoint_open()
            archive = zipfile.ZipFile(self.codepoint_path)
        
        if self.import_areas:
            filenames = ['Code-Point Open/Data/%s.csv' % code.lower() for code in self.import_areas]
        else:
            filenames = [path for path in archive.namelist() if re.match(r'Code\-Point Open\/Data\/[a-z]{1,2}.csv', path)]

        for filename in filenames:
            reset_queries()
            with transaction.commit_on_success():
                if hasattr(archive, 'open'):
                    f = archive.open(filename)
                else:
                    f = tempfile.TemporaryFile()
                    f.write(archive.read(filename))
                    f.seek(0)
                reader = csv.reader(f)
                self._load_from_csv(reader, entity_type, source)
                del f

    def _load_from_csv(self, reader, entity_type, source):
        j = 0
        for i, line in enumerate(reader):
            postcode_abbrev, (easting, northing) = line[0], line[10:12]
            postcode_abbrev = postcode_abbrev.replace(' ', '')
            
            # Now try to figure out where to put the space in
            if re.match(r'[A-Z][0-9]{2}[A-Z]{2}', postcode_abbrev):
                # A9 9AA
                postcode = '%s %s' % (postcode_abbrev[:2], postcode_abbrev[2:])
            elif re.match(r'[A-Z][0-9]{3}[A-Z]{2}', postcode_abbrev):
                # A99 9AA
                postcode = '%s %s' % (postcode_abbrev[:3], postcode_abbrev[3:])
            elif re.match(r'[A-Z]{2}[0-9]{2}[A-Z]{2}', postcode_abbrev):
                # AA9 9AA
                postcode = '%s %s' % (postcode_abbrev[:3], postcode_abbrev[3:])
            elif re.match(r'[A-Z]{2}[0-9]{3}[A-Z]{2}', postcode_abbrev):
                # AA99 9AA
                postcode = '%s %s' % (postcode_abbrev[:4], postcode_abbrev[4:])
            elif re.match(r'[A-Z][0-9][A-Z][0-9][A-Z]{2}', postcode_abbrev):
                # A9A 9AA
                postcode = '%s %s' % (postcode_abbrev[:3], postcode_abbrev[3:])
            elif re.match(r'[A-Z]{2}[0-9][A-Z][0-9][A-Z]{2}', postcode_abbrev):
                # AA9A 9AA
                postcode = '%s %s' % (postcode_abbrev[:4], postcode_abbrev[4:])
            else:
                postcode = postcode_abbrev
            
            try:
                easting, northing = int(easting), int(northing)
            except ValueError:
                continue
                
            j += 1
            
            try:
                entity = Entity.objects.get(source=source, _identifiers__scheme='postcode', _identifiers__value=postcode_abbrev)
            except Entity.DoesNotExist:
                entity = Entity(source=source)
            
            entity.location = Point(easting, northing, srid=27700)
            entity.geometry = entity.location
            entity.primary_type = entity_type
            
            identifiers = {
                'postcode': postcode_abbrev,
                'postcode-canonical': postcode,
            }
            entity.save(identifiers=identifiers)
            set_name_in_language(entity, 'en',
                                 title = postcode)
            entity.all_types.add(entity_type)
            entity.update_all_types_completion()

    def _get_entity_type(self):
        category, created = EntityTypeCategory.objects.get_or_create(name=ugettext_noop('Uncategorised'))
        verbose_names = {}
        for lang_code, lang_name in settings.LANGUAGES:
            verbose_names[lang_code] = (_('postcode'), _('a postcode'), _('postcodes'))
        defaults = {'verbose_names': verbose_names }
        entity_type, created = EntityType.objects.get_or_create(
            slug='post-code', category=category, defaults=defaults)
        if created:
            entity_type.show_in_nearby_list = False
            entity_type.show_in_category_list = False
            entity_type.save()
        return entity_type

    def _get_source(self):
        try:
            source = Source.objects.get(module_name=self.MODULE_NAME)
        except Source.DoesNotExist:
            source = Source(module_name=self.MODULE_NAME)

        source.name = "Postcodes"
        source.save()

        return source

########NEW FILE########
__FILENAME__ = tfl
from urllib2 import urlopen
from xml.dom import minidom
from collections import defaultdict
import threading
import logging

from django.utils.translation import ugettext_lazy as _

from molly.apps.places.providers import BaseMapsProvider

logger = logging.getLogger(__name__)

class TubeRealtimeProvider(BaseMapsProvider):
    """
    Populates tube station entities with real-time departure information
    """
    
    TRACKERNET_STATUS_URL = 'http://cloud.tfl.gov.uk/TrackerNet/StationStatus'
    TRACKERNET_PREDICTION_URL = 'http://cloud.tfl.gov.uk/TrackerNet/PredictionDetailed/%s/%s'
    
    def get_statuses(self):
        statuses = {}
        xml = minidom.parseString(urlopen(self.TRACKERNET_STATUS_URL).read())
        for stationstatus in xml.getElementsByTagName('StationStatus'):
            name = stationstatus.getElementsByTagName('Station')[0].getAttribute('Name')
            status = stationstatus.getElementsByTagName('Status')[0].getAttribute('Description')
            status += ' ' + stationstatus.getAttribute('StatusDetails')
            statuses[name] = status
        return statuses
    
    def augment_metadata(self, entities, **kwargs):
        threads = []
        
        for entity in filter(lambda e: e.primary_type.slug == 'tube-station', entities):
            
            # Try and match up entity with StationStatus name
            for station, status in self.get_statuses().items():
                if entity.title.startswith(station):
                    entity.metadata['real_time_information'] = {
                        'pip_info': [status] if status != 'Open ' else [],
                    }
            if 'real_time_information' not in entity.metadata:
                entity.metadata['real_time_information'] = {}
            
            if 'london-underground-identifiers' in entity.metadata:
                thread = threading.Thread(target=self.get_times, args=[entity])
                thread.start()
                threads.append(thread)
        
        for thread in threads:
            thread.join()
    
    def get_times(self, entity):
        
        try:
            services = []
            
            station = entity.metadata['london-underground-identifiers']['station-code']
            for line in entity.metadata['london-underground-identifiers']['line-codes']:
                
                xml = minidom.parseString(urlopen(self.TRACKERNET_PREDICTION_URL % (line, station)).read())
                for platform in xml.getElementsByTagName('P'):
                    next_info = defaultdict(list)
                    for tag in platform.getElementsByTagName('T'):
                        dest = '%s (%s)' % (
                            tag.getAttribute('Destination'),
                            xml.getElementsByTagName('LineName')[0].childNodes[0].nodeValue
                        )
                        next_info[dest].append(int(tag.getAttribute('SecondsTo')))
                    
                    for dest, eta in next_info.items():
                        services.append({
                            'service': _('Plat %s') % platform.getAttribute('Num'),
                            'destination': dest,
                            'etas': eta
                        })
            
            services.sort(key=lambda s: s['etas'][0])
            for service in services:
                etas = [round(e/60) for e in service['etas']]
                # Translators: This refers to arrival times of trains, in minutes
                etas = [_('DUE') if e == 0 else _('%d mins') % e for e in etas]
                service['next'] = etas[0]
                service['following'] = etas[1:]
                del service['etas']
            entity.metadata['real_time_information']['services'] = services
            entity.metadata['meta_refresh'] = 30
        
        except Exception as e:
            logger.exception('Failed to get RTI from Trackernet')

########NEW FILE########
__FILENAME__ = timetables
from collections import namedtuple, defaultdict
from datetime import datetime, time, timedelta
from logging import getLogger
from operator import itemgetter

from django.db.models import Q

from molly.apps.places.providers import BaseMapsProvider

class TimetableAnnotationProvider(BaseMapsProvider):
    """
    This provider adds scheduled transport information to entites
    """
    
    def augment_metadata(self, entities, **kwargs):
        
        # Some routes finish the day after they start on, but for the
        # "does this service run today" question, they consider the day
        # before, e.g., Metrolink saturday timetable finishes early
        # Sunday morning. We're going to assume a break of 4am - but
        # this might not be accurate!
        
        today = datetime.now()
        if today.time() < time(4):
            today -= timedelta(days=1)
            
        def midnight_4am(left, right):
            """
            Search comparison function where before 4 am is later than midnight
            """
            return cmp((left.hour if left.hour >= 4 else left.hour + 24, left.minute, left.second),
                       (right.hour if right.hour >= 4 else right.hour + 24, right.minute, right.second))
        
        for entity in entities:
            
            # Skip stops we have no schedules for
            if entity.scheduledstop_set.all().count() == 0:
                continue
            
            services = defaultdict(list)
            if today.time() < time(22):
                until = [
                    Q(sta__gte=today.time())
                    | Q(std__gte=today.time()), Q(sta__lt=(today + timedelta(hours=2)).time())
                    | Q(std__lt=(today + timedelta(hours=2)).time())
                ]
            else:
                until = [
                    Q(sta__gte=today.time())
                    | Q(std__gte=today.time())
                    | Q(sta__lt=(today + timedelta(hours=2)).time())
                    | Q(std__lt=(today + timedelta(hours=2)).time())
                ]
            
            for stop in entity.scheduledstop_set.filter(
                *until).exclude(activity__in=('D','N','F')):
                
                if not stop.journey.runs_on(today.date()):
                    continue
                
                service_id = stop.journey.route.service_id
                destination = stop.journey.destination
                
                services[(service_id, destination)].append(
                    (stop.journey, stop.std or stop.sta))
            
            services = ((route, sorted(ss, key=itemgetter(1), cmp=midnight_4am))
                for route, ss in services.items())
            
            services = [{
                'service': service_id,
                'destination': destination,
                'next': ss[0][1].strftime('%H:%M'),
                'following': map(lambda t: t[1].strftime('%H:%M'), ss[1:4]),
                'journey': ss[0][0]
            } for (service_id, destination), ss in sorted(
                services, key=lambda x: x[1][0][1])]
            
            entity.metadata['real_time_information'] = {
                'services': services,
                'pip_info': [],
            }
            entity.metadata['meta_refresh'] = 60


########NEW FILE########
__FILENAME__ = search
import re
import simplejson
import urllib2
from itertools import chain

from django.core.urlresolvers import reverse
from django.db.models import Q
from django.utils.translation import ugettext as _

from molly.apps.places import get_point
from views import NearbyDetailView, EntityDetailView
from models import Entity, EntityType, EntityName, EntityTypeName, Route, StopOnRoute


class ApplicationSearch(object):

    def __init__(self, conf):
        self.conf = conf

    def perform_search(self, request, query, is_single_app_search):
        return chain(
            self.bus_service_search(request, query, is_single_app_search),
            self.entity_search(request, query, is_single_app_search),
            self.entity_type_search(request, query, is_single_app_search),
        )

    def entity_search(self, request, query, is_single_app_search):
        entities = Entity.objects.all()
        if hasattr(self.conf, 'search_identifiers'):
            entities = entities.filter(
                _identifiers__scheme__in = self.conf.search_identifiers,
                _identifiers__value__iexact = query,
            )
        else:
            entities = entities.filter(
                _identifiers__value__iexact = query,
            )

        entities = chain(
            (en.entity for en in EntityName.objects.filter(title__iexact = query)),
            entities,
        )

        for entity in entities:
            result = {
                'url': entity.get_absolute_url(),
                'application': self.conf.local_name,
                'redirect_if_sole_result': True,
            }
            result.update(EntityDetailView(self.conf).get_metadata(request, entity.identifier_scheme, entity.identifier_value))
            yield result

    def entity_type_search(self, request, query, is_single_app_search):
        entity_types = (etn.entity_type for etn in EntityTypeName.objects.filter(
            Q(verbose_name__iexact = query) | Q(verbose_name_plural__iexact = query)))

        for entity_type in entity_types:
            result = {
                'url': reverse('places:nearby-detail', args=[entity_type.slug]),
                'application': self.conf.local_name,
                'redirect_if_sole_result': True,
            }
            result.update(NearbyDetailView(self.conf).get_metadata(request, entity_type.slug))
            yield result
    
    def bus_service_search(self, request, query, is_single_app_search):
        routes = Route.objects.filter(service_id__iexact=query)
        stops = Entity.objects.filter(stoponroute__route__in=routes)
        location = get_point(request, None)
        if location:
            stops = stops.distance(location).order_by('distance')
        
        for stop in stops:
            result = {
                'url': stop.get_absolute_url(),
                'application': self.conf.local_name,
                'redirect_if_sole_result': True,
            }
            result.update(EntityDetailView(self.conf).get_metadata(request, stop.identifier_scheme, stop.identifier_value))
            yield result

########NEW FILE########
__FILENAME__ = molly_osm
from xml.sax.saxutils import escape as xml_escape
from django import template
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext as _

register = template.Library()

def yesno(s):
    return {
        'yes': _('Yes'),
        'no': _('No'),
        'true': _('Yes'),
        'false': _('No')
        }.get(s.lower())

def verbatim(name):
    return lambda t,s,tags: (name, _(s))

def tag_wifi(t, s, tags):
    return _('wi-fi access'), yesno(s)
    
def tag_atm(t, s, tags):
    return _('has ATM'), yesno(s)
    
def tag_food(t, s, tags):
    return _('serves food'), yesno(s) or s
    
def tag_opening_hours(t, s, tags):
    return _('opening hours'), s

def tag_collection_times(t, s, tags):
    return _('collection times'), s

def tag_capacity(t, s, tags):
    try:
        return _('capacity'), int(s)
    except:
        return None

def tag_cuisine(t, s, tags):
    try:
        cuisines = [_(w.capitalize().replace('_', ' ')) for w in s.split(';')]
        if len(cuisines) == 1:
            return _('cuisine'), ', '.join(cuisines)
        else:
            return _('cuisines'), ', '.join(cuisines)
    except:
        return None

tag_operator = verbatim(_('operator'))
tag_note = verbatim(_('note'))
    
def tag_dispensing(t, s, tags):
    if t == 'pharmacy':
        return _('dispensing'), yesno(s)

TAGS, funcs = {}, locals().copy()
for func_name in funcs:
    if func_name.startswith('tag_'):
        TAGS[func_name[4:]] = locals()[func_name]

@register.filter(name='osm_tags')
def osm_tags(entity):
    if not 'osm' in entity.metadata:
        return []
    tags = entity.metadata['osm']['tags']
    entity_type = entity.primary_type.slug
    
    return_tags = []
    for tag in tags:
        if tag in TAGS:
            return_tag = TAGS[tag](entity_type, tags[tag], tags)
            if not return_tag is None:
                return_tags.append(return_tag)
    
    return return_tags

@register.filter(name='osm_tag_wikipedia_uri')
def tag_wikipedia_uri(value):
    if value.startswith("http://en.wikipedia.org/wiki/"):
        value = value[29:]
    return value


########NEW FILE########
__FILENAME__ = test_atcocif
from datetime import date

from mockito import *

from django.test.client import Client
from django.utils import unittest

from molly.apps.places.models import Entity, Journey
from molly.apps.places.providers.cif import CifTimetableProvider

import httplib

class AtcoCifTestCase(unittest.TestCase):
    
    def testBankHolidays(self):
        j = Journey()
        
        # 10 bank hols in 2010
        hols = j.get_bank_holidays(2010)
        self.assertEquals(len(hols), 10)
        self.assertTrue(date(2010, 1, 1) in hols) # New Year's Day
        self.assertTrue(date(2010, 4, 2) in hols) # Good Friday
        self.assertTrue(date(2010, 4, 5) in hols) # Easter Monday
        self.assertTrue(date(2010, 5, 3) in hols) # Early May Bank Holiday
        self.assertTrue(date(2010, 5, 31) in hols) # Spring Bank Holiday
        self.assertTrue(date(2010, 8, 30) in hols) # Summer Bank Holiday
        self.assertTrue(date(2010, 12, 25) in hols) # Christmas Day
        self.assertTrue(date(2010, 12, 26) in hols) # Boxing Day
        self.assertTrue(date(2010, 12, 27) in hols) # Christmas Day (in lieu)
        self.assertTrue(date(2010, 12, 28) in hols) # Boxing Day (in lieu)
        
        # 11 bank hols in 2011
        hols = j.get_bank_holidays(2011)
        self.assertEquals(len(hols), 11)
        self.assertTrue(date(2011, 1, 1) in hols) # New Year's Day
        self.assertTrue(date(2011, 1, 3) in hols) # New Year's Day (in lieu)
        self.assertTrue(date(2011, 4, 22) in hols) # Good Friday
        self.assertTrue(date(2011, 4, 25) in hols) # Easter Monday
        self.assertTrue(date(2011, 4, 29) in hols) # Royal Wedding
        self.assertTrue(date(2011, 5, 2) in hols) # Early May Bank Holiday
        self.assertTrue(date(2011, 5, 30) in hols) # Spring Bank Holiday
        self.assertTrue(date(2011, 8, 29) in hols) # Summer Bank Holiday
        self.assertTrue(date(2011, 12, 25) in hols) # Christmas Day
        self.assertTrue(date(2011, 12, 26) in hols) # Christmas Day (in lieu)
        self.assertTrue(date(2011, 12, 27) in hols) # Boxing Day
        
        # 10 bank hols in 2012
        hols = j.get_bank_holidays(2012)
        self.assertEquals(len(hols), 10)
        self.assertTrue(date(2012, 1, 1) in hols) # New Year's Day
        self.assertTrue(date(2012, 1, 2) in hols) # New Year's Day (in lieu)
        self.assertTrue(date(2012, 4, 6) in hols) # Good Friday
        self.assertTrue(date(2012, 4, 9) in hols) # Easter Monday
        self.assertTrue(date(2012, 5, 7) in hols) # Early May Bank Holiday
        self.assertTrue(date(2012, 6, 4) in hols) # Spring Bank Holiday
        self.assertTrue(date(2012, 6, 5) in hols) # Diamond Jubilee
        self.assertTrue(date(2012, 8, 27) in hols) # Summer Bank Holiday
        self.assertTrue(date(2012, 12, 25) in hols) # Christmas Day
        self.assertTrue(date(2012, 12, 26) in hols) # Boxing Day

class LocationTestCase(unittest.TestCase):
    def testLocationRequiredViewSubclass(self):
        c = Client()
        path = '/places/nearby/'
        latitude = 51.752274
        longitude = -1.255875
        accuracy = 10
        
        # Trying to get a LocationRequiredView with no location set should
        # cause a redirect
        response = c.get(path)
        self.assertEquals(response.status_code, httplib.SEE_OTHER)
        
        # Trying to get a LocationRequiredView with latitude and longitude
        # query params returns OK
        response = c.get(path, data={ 'latitude':latitude, 'longitude': longitude })
        self.assertEquals(response.status_code, httplib.OK)
        
        # Trying to get a LocationRequiredView with latitude, longitude
        # and accuracy query params returns OK
        response = c.get(path, data={ 'latitude':latitude, 'longitude': longitude, 'accuracy': accuracy })
        self.assertEquals(response.status_code, httplib.OK)

        # Trying to get a LocationRequiredView with an X-Current-Location (no accuracy)
        # HTTP header returns OK
        response = c.get(path, HTTP_X_CURRENT_LOCATION="latitude=%.6f,longitude=%.6f" % (latitude, longitude))
        self.assertEquals(response.status_code, httplib.OK)

        # Trying to get a LocationRequiredView with an X-Current-Location (including accuracy)
        # HTTP header returns OK
        response = c.get(path, HTTP_X_CURRENT_LOCATION="latitude=%.6f,longitude=%.6f,accuracy=%d" % (latitude, longitude, accuracy))
        self.assertEquals(response.status_code, httplib.OK)


class CifTestCase(unittest.TestCase):
    
    sample_file = \
"""
HDTPS.UCFCATE.PD1201131301122139DFTTISX       FA130112300912                    
TIAACHEN 00081601LAACHEN                    00005   0                           
TIABCWM  00385964VABERCWMBOI                78128   0
"""
    
    class MockQuerySet():
        
        def __init__(self, mockObj):
            self._mock = mockObj
        
        def count(self):
            return 1
        
        def __getitem__(self, index):
            return self._mock
    
    def setUp(self):
        self.mock_entity_manager = mock()
        self.provider = CifTimetableProvider(
            entity_manager=self.mock_entity_manager
        )
        
        self.empty_query_set = mock()
        self.entity_query_set = self.MockQuerySet(mock())
        when(self.empty_query_set).count().thenReturn(0)
        when(self.mock_entity_manager).get_entity(
            'tiploc', 'ABCWM').thenReturn(self.empty_query_set)
        when(self.mock_entity_manager).get_entity(
            "tiploc", 'AACHEN').thenReturn(self.entity_query_set)
    
    def testThatTiplocsAreLookedUp(self):
        self.provider.import_from_string(self.sample_file)
        verify(self.mock_entity_manager, times=2).get_entity(any(), any())
    
    def testThatTiplocsAreLookedUpWithCorrectNamespace(self):
        self.provider.import_from_string(self.sample_file)
        verify(self.mock_entity_manager, times=2).get_entity("tiploc", any())
    
    def testThatTiplocsAreLookedUpWithName(self):
        self.provider.import_from_string(self.sample_file)
        verify(self.mock_entity_manager).get_entity("tiploc", "AACHEN")
    
    def testThatTiplocsAreLookedUpWithStrippedName(self):
        self.provider.import_from_string(self.sample_file)
        verify(self.mock_entity_manager).get_entity('tiploc', 'ABCWM')
    
    def testThatTiplocsAreCreatedWhenNoneAreReturned(self):
        self.provider.import_from_string(self.sample_file)
        
        # Annoyingly mockito doesn't properly support assertions on the args
        verify(self.mock_entity_manager).create(
            source=any(),
            primary_type=any(),
            identifiers=any(),
            titles=any()
        )
    
    def testThatTiplocsAreCreatedWithCorrectSource(self):
        self.provider = CifTimetableProvider()
        self.provider.import_from_string(self.sample_file)
        entity = Entity.objects.get_entity('tiploc', 'ABCWM')
        self.assertEquals(self.provider.source, entity[0].source)
    
    def testThatTiplocsAreCreatedWithCorrectType(self):
        self.provider = CifTimetableProvider()
        self.provider.import_from_string(self.sample_file)
        entity = Entity.objects.get_entity('tiploc', 'ABCWM')
        self.assertEquals(self.provider.entity_type, entity[0].primary_type)
    
    def testThatTiplocsAreCreatedWithCorrectName(self):
        self.provider = CifTimetableProvider()
        self.provider.import_from_string(self.sample_file)
        entity = Entity.objects.get_entity('tiploc', 'ABCWM')
        self.assertEquals('Abercwmboi', entity[0].title)
    
    def testGetSource(self):
        self.assertEquals(
            'molly.apps.places.providers.cif',
            self.provider.source.module_name
        )
    
    def testGetEntityTypeVerboseName(self):
        self.assertEquals(
            'rail network timing point',
            self.provider.entity_type.verbose_name
        )
    
    def testGetEntityTypeVerboseNamePlural(self):
        self.assertEquals(
            'rail network timing points',
            self.provider.entity_type.verbose_name_plural
        )
    
    def testGetEntityTypeVerboseNameSingular(self):
        self.assertEquals(
            'a rail network timing point',
            self.provider.entity_type.verbose_name_singular
        )


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_cloudamber
import unittest2
import mock

from molly.apps.places.providers.cloudamber import CloudAmberBusRtiProvider, CloudAmberBusRouteProvider, Route, StopOnRoute


class CloudAmberBusRouteProviderTest(unittest2.TestCase):
    """Simple tests which asssert the correct numbers of Routes and StopOnRoute
    objects are being created from a stored data.
    """
    def test_scrape_search(self):
        provider = CloudAmberBusRouteProvider('foo')
        provider.url = 'molly/apps/places/tests/data/cloudamber-search.html'
        provider._scrape_route = mock.Mock()
        Route.objects.get_or_create = mock.Mock(return_value=[mock.Mock(), True])
        provider._scrape_search()
        # Attempts to create 200 routes
        self.assertEqual(Route.objects.get_or_create.call_count, 201)

    def test_scrape_route(self):
        provider = CloudAmberBusRouteProvider('foo')
        provider._get_entity = mock.Mock(return_value='bar')
        StopOnRoute.objects.create = mock.Mock()
        provider._scrape_route(6, 'molly/apps/places/tests/data/cloudamber-route.html')
        self.assertEqual(StopOnRoute.objects.create.call_count, 18)

class CloudAmberBusRtiProviderTest(unittest2.TestCase):

    def test_info(self):
        """
        Test case covering stop's services and departure times
        """

        # HTML retrived from http://oxontime.voyagertest.com/Naptan.aspx?t=departure&sa=69327545&dc=&ac=96&vc=&x=0&y=0&format=xhtml
        with open('molly/apps/places/tests/data/cloudamber-info.html') as f:
            content = f.read()
            f.close()
       
        # What we are testing
        sms_number = 69327545
        stop_name = 'George Street B1'
        first_stop_service_number = '14A'
        first_stop_destination = 'JR Hospital'
        first_stop_departure_time = 'DUE'
        first_stop_next_departure_time = '3 mins'
        #first_stop_operator = 'SOX'
        last_stop_service_number = '17'
        last_stop_destination = 'Cutteslowe'
        last_stop_departure_time = '41 mins'
        #last_stop_operator = 'SOX'

        provider = CloudAmberBusRtiProvider('foo.bar')
        services, messages = provider.parse_html(content)

        self.assertEqual(messages, [])

        # first service (NOT BUS) expected at the bus stop
        first = services[0]
        self.assertEqual(first.get('service'), first_stop_service_number)
        self.assertEqual(first.get('destination'), first_stop_destination)
        self.assertEqual(first.get('next'), first_stop_departure_time)
        self.assertEqual(first.get('following')[0], first_stop_next_departure_time)

        # last service (NOT BUS) expected at the bus stop
        last = services[-1]
        self.assertEqual(last.get('service'), last_stop_service_number)
        self.assertEqual(last.get('destination'), last_stop_destination)
        self.assertEqual(last.get('next'), last_stop_departure_time)

    def test_messages(self):
        """
        Test case covering messages added to a bus stop
        """

        # HTML retrieved from http://oxontime.voyagertest.com/Naptan.aspx?t=departure&sa=69327545&dc=&ac=96&vc=&x=0&y=0&format=xhtml
        with open('molly/apps/places/tests/data/cloudamber-messages.html') as f:
            content = f.read()
            f.close()

        message = '-The terminus for the inbound S1 is at stop B1 (west end of George St) <br/> -For the S2 & S3 go to Gloucester Green (bus station) <br/> -Stop closed - long term closure to allow demolition & rebuilding works <br/> -Please refer to notices posted at the stop'

        provider = CloudAmberBusRtiProvider('foo.bar')
        services, messages = provider.parse_html(content)
        self.assertEqual(messages[0], message)


if __name__ == "__main__":
    unittest2.main()

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from molly.apps.home.views import StaticDetailView

from views import (
    IndexView,
    NearbyListView, NearbyDetailView,
    EntityDetailView,
    EntityUpdateView,
    RouteView,

    NearbyEntityListView, NearbyEntityDetailView,
    CategoryListView, CategoryDetailView,
    
    ServiceDetailView, EntityDirectionsView, TimetableView,
)

urlpatterns = patterns('',
    (r'^$',
        IndexView, {},
        'index'),

    (r'^nearby/$', 
        NearbyListView, {},
        'nearby-list'),
    (r'^nearby/(?P<ptypes>[^/;]+(\;[^/;]+)*)/$',
        NearbyDetailView, {},
        'nearby-detail'),

    (r'^category/$',
        CategoryListView, {},
        'category-list'),
    (r'^category/(?P<ptypes>[^/;]+(\;[^/;]+)*)/$',
        CategoryDetailView, {},
        'category-detail'),

    (r'^route:(?P<route>[^/]+)/(?P<id>\d+)?$',
        RouteView, {},
        'route'),

    (r'^(?P<scheme>[a-z_\-]+):(?P<value>[^/]+)/$',
        EntityDetailView, {},
        'entity'),
    
    (r'^(?P<scheme>[a-z_\-]+):(?P<value>[^/]+)/directions/$',
        EntityDirectionsView, {},
        'entity-directions'),
    
    (r'^(?P<scheme>[a-z_\-]+):(?P<value>[^/]+)/service$',
        ServiceDetailView, {},
        'service-detail'),
    
    #(r'^(?P<scheme>[a-z_\-]+):(?P<value>[^/]+)/timetable/((?P<year>\d{4})\-(?P<month>\d{2})\-(?P<day>\d{2})/)?$',
    #    TimetableView, {},
    #    'timetable'),
    
    (r'^(?P<scheme>[a-z_\-]+):(?P<value>[^/]+)/nearby/$',
        NearbyEntityListView, {},
        'entity-nearby-list'),
    (r'^(?P<scheme>[a-z_\-]+):(?P<value>[^/]+)/nearby/(?P<ptype>[^/]+)/$',
        NearbyEntityDetailView, {},
        'entity-nearby-detail'),

    (r'^(?P<scheme>[a-z_\-]+):(?P<value>[^/]+)/update/$',
        EntityUpdateView, {},
        'entity-update'),

    (r'^openstreetmap/$',
        StaticDetailView,
        {'title':'About OpenStreetMap', 'template':'openstreetmap'},
        'static-openstreetmap'),
)

########NEW FILE########
__FILENAME__ = views
from __future__ import division

from collections import defaultdict
from itertools import chain
import simplejson
import copy
import math
from urllib import unquote
from datetime import datetime, timedelta, date
from urllib import unquote

from suds import WebFault

from django.contrib.gis.geos import Point
from django.http import Http404, HttpResponse
from django.shortcuts import get_object_or_404
from django.core.urlresolvers import reverse
from django.template.defaultfilters import capfirst, date as djangodate
from django.core.paginator import Paginator, InvalidPage, EmptyPage
from django.utils.translation import ugettext as _
from django.utils.translation import ungettext
from django.contrib.gis.measure import D

from molly.utils import haversine
from molly.utils.views import BaseView, ZoomableView
from molly.utils.templatetags.molly_utils import humanise_distance
from molly.utils.breadcrumbs import *
from molly.favourites.views import FavouritableView
from molly.geolocation.views import LocationRequiredView

from molly.maps import Map
from molly.maps.osm.models import OSMUpdate

from molly.routing import generate_route, ALLOWED_ROUTING_TYPES

from molly.apps.places.models import Entity, EntityType, Route, Journey
from molly.apps.places import get_entity, get_point, bus_route_sorter
from molly.apps.places.forms import UpdateOSMForm


class IndexView(BaseView):

    def get_metadata(self, request):
        return {
            'title': _('places'),
            'additional': _('Find University buildings and units, along with bus stops and local amenities'), }

    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            'places',
            None,
            _('Places'),
            lazy_reverse('index'))

    def initial_context(self, request):
        return {
            'return_url': request.get_full_path(),
        }

    def handle_GET(self, request, context):
        return self.render(request, context, 'places/index')


class NearbyListView(LocationRequiredView):

    def get_metadata(self, request, entity=None):
        return {
            'title': _('Find things nearby'),
            'additional': _('Search for things based on your current location'),
        }

    @BreadcrumbFactory
    def breadcrumb(self, request, context, entity=None):
        return Breadcrumb(
            'places',
            lazy_parent('index'),
            _('Things nearby'),
            url = lazy_reverse('nearby-list'),
        )

    def handle_GET(self, request, context, entity=None):
        point = get_point(request, entity)
        
        if point is None:
            return self.render(request, { 'entity': entity },
                               'places/entity_without_location')
        
        if entity:
            return_url = reverse('places:entity-nearby-list',
                      args=[entity.identifier_scheme, entity.identifier_value])
        else:
            return_url = reverse('places:nearby-list')

        # Get entity types to show on nearby page
        entity_types = EntityType.objects.filter(show_in_nearby_list=True)
        
        for et in entity_types:
            # For each et, get the entities that belong to it
            et.max_distance = humanise_distance(0)
            et.entities_found = 0
            es = et.entities_completion.filter(location__isnull=False,
                                               location__distance_lt=(point, D(km=5))).distance(point).order_by('distance')
            for e in es:
                # Selection criteria for whether or not to count this entity
                if (e.distance.m ** 0.75) * (et.entities_found + 1) > 500:
                    break
                et.max_distance = humanise_distance(e.distance.m)
                et.entities_found += 1

        categorised_entity_types = defaultdict(list)
        for et in filter(lambda et: et.entities_found > 0, entity_types):
            categorised_entity_types[_(et.category.name)].append(et)
        categorised_entity_types = dict(
            (k, sorted(v, key=lambda x: x.verbose_name.lower()))
            for k, v in categorised_entity_types.items())

        context.update({
            'entity_types': categorised_entity_types,
            'entity': entity,
            'return_url': return_url,
            # entity is None => we've searched around the user's location
            'exposes_user_data': entity is None, 
        })
        if entity and not entity.location:
            return self.render(request, context, 'places/entity_without_location')
        return self.render(request, context, 'places/nearby_list')


class NearbyDetailView(LocationRequiredView, ZoomableView):

    def initial_context(self, request, ptypes, entity=None):
        point = get_point(request, entity)

        entity_types = tuple(get_object_or_404(EntityType, slug=t) for t in ptypes.split(';'))

        if point:
            entities = Entity.objects.filter(location__isnull=False)
            for et in entity_types:
                entities = entities.filter(all_types_completion=et)
            
            entities = entities.distance(point).order_by('distance')[:99]
        else:
            entities = []

        context = super(NearbyDetailView, self).initial_context(request, ptypes, entities)
        context.update({
            'entity_types': entity_types,
            'point': point,
            'entities': entities,
            'entity': entity,
            # entity is None => point is the user's location
            'exposes_user_data': entity is None, 
        })
        return context

    @BreadcrumbFactory
    def breadcrumb(self, request, context, ptypes, entity=None):
        title = NearbyDetailView.get_metadata(self, request, ptypes, entity)['title']
        return Breadcrumb('places',
                          lazy_parent('nearby-list'),
                          title,
                          lazy_reverse('nearby-detail', args=[ptypes]))

    def get_metadata(self, request, ptypes, entity=None):
        context = NearbyDetailView.initial_context(self, request, ptypes, entity)

        if len(context['entity_types']) == 0:
            return {
                'exclude_from_search': True,
                'title': _('Things near %(title)s') % {'title': entity.title}
            }

        et_name = capfirst(context['entity_types'][0].verbose_name_plural)
        if entity is not None:
            title = _('%(entity_type)s near %(entity)s') % {
                                                        'entity_type':et_name,
                                                        'title': entity.title
                                                    }
        else:
            title = _('%(et)s nearby') % {'et': et_name}
            
        if len(context['entity_types']) > 1:
            return {
                'exclude_from_search': True,
                'title': title}
        
        number = len([e for e in context['entities']
                      if haversine(e.location, context['point']) <= 1000])
        entity_type = context['entity_types'][0].verbose_name_plural

        return {
            'title': title,
            'additional': _('<strong>%(number)d %(entity_type)s</strong> within 1km') \
                % {'number': number, 'entity_type': entity_type}
        }

    def handle_GET(self, request, context, ptypes, entity=None):

        entity_types, entities, point = (
            context['entity_types'], context['entities'],
            context['point'],
        )

        if entity and not point:
            context = {'entity': entity}
            return self.render(request, context, 'places/entity_without_location')

        if context['zoom'] is None:
            min_points = 5
        else:
            min_points = 0

        entity_map = Map(
            centre_point = (point[0], point[1], 'green', ''),
            points = [(e.location[0], e.location[1], 'red', e.title)
                for e in entities],
            min_points = min_points,
            zoom = context['zoom'],
            width = request.map_width,
            height = request.map_height,
        )

        entities = [[entities[i] for i in b] for a, b in entity_map.points]

        found_entity_types = set()
        for e in chain(*entities):
            e.bearing = e.get_bearing(point)
            found_entity_types |= set(e.all_types.all())
        found_entity_types -= set(entity_types)
        
        # If there are no entities, return a 404. This should only happen if URLs are manually formed by user.
        if len(entities) == 0:
            raise Http404()
        
        context.update({
            'entities': entities,
            'map': entity_map,
            'count': sum(map(len, entities)),
            'entity_types': entity_types,
            'found_entity_types': found_entity_types,
        })
        return self.render(request, context, 'places/nearby_detail')

class EntityDetailView(ZoomableView, FavouritableView):
    default_zoom = 16

    def get_metadata(self, request, scheme, value):
        entity = get_entity(scheme, value)
        user_location = request.session.get('geolocation:location')
        distance, bearing = entity.get_distance_and_bearing_from(user_location)
        additional = '<strong>%s</strong>' % capfirst(entity.primary_type.verbose_name)
        if distance:
            additional += ', ' + _('about %(distance)s %(bearing)s') % {
                                    'distance': humanise_distance(distance),
                                    'bearing': bearing }
        routes = sorted(set(sor.route.service_id for sor in entity.stoponroute_set.all()),
                        key=bus_route_sorter)
        if routes:
            additional += ', ' + ungettext('service %(services)s stops here',
                                           'services %(services)s stop here',
                                           len(routes)) % {
                                                'services': ' '.join(routes)
                                            }
        return {
            'title': entity.title,
            'additional': additional,
            'entity': entity,
        }

    def initial_context(self, request, scheme, value):
        context = super(EntityDetailView, self).initial_context(request)
        entity = get_entity(scheme, value)
        associations = []
        if hasattr(self.conf, 'associations'):
            for association in self.conf.associations:
                id_type, id, associated_entities = association
                try:
                    if id in entity.identifiers[id_type]:
                        associations += [{'type': type, 'entities': [get_entity(ns, value) for ns, value in es]} for type, es in associated_entities]
                except (KeyError, Http404):
                    pass

        for entity_group in entity.groups.all():
            group_entities = filter(lambda e: e != entity,
                                   Entity.objects.filter(groups=entity_group))

            if len(group_entities) > 0:
                associations.append({
                    'type': entity_group.title,
                    'entities': group_entities,
                })

        board = request.GET.get('board', 'departures')
        if board != 'departures':
            board = 'arrivals'

        context.update({
            'entity': entity,
            'board': board,
            'entity_types': entity.all_types.all(),
            'associations': associations,
        })
        return context

    @BreadcrumbFactory
    def breadcrumb(self, request, context, scheme, value):
        if request.session.get('geolocation:location'):
            parent_view = 'nearby-detail'
        else:
            parent_view = 'category-detail'
        entity = get_entity(scheme, value)
        return Breadcrumb(
            'places',
            lazy_parent(parent_view, ptypes=entity.primary_type.slug),
            context['entity'].title,
            lazy_reverse('entity', args=[scheme, value]),
        )

    def handle_GET(self, request, context, scheme, value):
        entity = context['entity']

        if unquote(entity.absolute_url) != request.path:
            return self.redirect(entity.absolute_url, request, 'perm')

        entities = []
        for association in context['associations']:
            entities += association['entities']

        for provider in reversed(self.conf.providers):
            provider.augment_metadata((entity, ), board=context['board'])
            provider.augment_metadata([e for atypes in context['associations'] for e in atypes['entities']], board=context['board'])

        return self.render(request, context, 'places/entity_detail')


class EntityUpdateView(ZoomableView):
    default_zoom = 16

    def get_metadata(self, request, scheme, value):
        return {
            'exclude_from_search': True,
        }

    def initial_context(self, request, scheme, value):
        return dict(
            super(EntityUpdateView, self).initial_context(request),
            entity=get_entity(scheme, value),
        )

    @BreadcrumbFactory
    def breadcrumb(self, request, context, scheme, value):
        return Breadcrumb(
            'places',
            lazy_parent('entity', scheme=scheme, value=value),
            _('Update place'),
            lazy_reverse('entity-update', args=[scheme, value]))

    def handle_GET(self, request, context, scheme, value):
        entity = context['entity']
        if entity.source.module_name != 'molly.providers.apps.maps.osm':
            raise Http404

        if request.GET.get('submitted') == 'true':
            return self.render(request, context, 'places/update_osm_done')

        data = dict((k.replace(':', '__'), v) for (k, v) in entity.metadata['osm']['tags'].items())

        form = UpdateOSMForm(data)

        context['form'] = form
        return self.render(request, context, 'places/update_osm')

    def handle_POST(self, request, context, scheme, value):
        entity = context['entity'] = get_entity(scheme, value)
        if entity.source.module_name != 'molly.providers.apps.maps.osm':
            raise Http404

        form = UpdateOSMForm(request.POST)
        if form.is_valid():
            new_metadata = copy.deepcopy(entity.metadata['osm'])
            for k in ('name', 'operator', 'phone', 'opening_hours', 'url', 'cuisine', 'food', 'food__hours', 'atm', 'collection_times', 'ref', 'capacity'):
                tag_name = k.replace('__', ':')
                if tag_name in new_metadata and not form.cleaned_data[k]:
                    del new_metadata['osm']['tags'][tag_name]
                elif form.cleaned_data[k]:
                    new_metadata['tags'][tag_name] = form.cleaned_data[k]

            new_metadata['attrs']['version'] = str(int(new_metadata['attrs']['version'])+1)

            osm_update = OSMUpdate(
                contributor_name = form.cleaned_data['contributor_name'],
                contributor_email = form.cleaned_data['contributor_email'],
                contributor_attribute = form.cleaned_data['contributor_attribute'],
                entity = entity,
                old = simplejson.dumps(entity.metadata),
                new = simplejson.dumps(new_metadata),
                notes = form.cleaned_data['notes'],
            )
            osm_update.save()

            return self.redirect(
                reverse('places:entity-update', args=[scheme, value]) + '?submitted=true',
                request)
        else:
            context['form'] = form
            return self.render(request, context, 'places/update_osm')


class NearbyEntityListView(NearbyListView):

    def is_location_required(self, request, scheme, value):
        return False

    def get_metadata(self, request, scheme, value):
        entity = get_entity(scheme, value)
        return super(NearbyEntityListView, self).get_metadata(request, entity)

    def initial_context(self, request, scheme, value):
        return {
            'entity': get_entity(scheme, value),
        }

    @BreadcrumbFactory
    def breadcrumb(self, request, context, scheme, value):
        return Breadcrumb(
            'places',
            lazy_parent('entity', scheme=scheme, value=value),
            _('Things near %s') % context['entity'].title,
            lazy_reverse('entity-nearby-list', args=[scheme, value]))

    def handle_GET(self, request, context, scheme, value):
        entity = context['entity']
        return super(NearbyEntityListView, self).handle_GET(request, context, entity)


class NearbyEntityDetailView(NearbyDetailView):

    def is_location_required(self, request, scheme, value, ptype):
        return False

    def initial_context(self, request, scheme, value, ptype):
        entity = get_entity(scheme, value)
        context = super(NearbyEntityDetailView, self).initial_context(request, ptype, entity)
        context['entity'] = entity
        return context

    @BreadcrumbFactory
    def breadcrumb(self, request, context, scheme, value, ptype):
        entity_type = get_object_or_404(EntityType, slug=ptype)
        return Breadcrumb(
            'places',
            lazy_parent('entity-nearby-list', scheme=scheme, value=value),
            _('%(entity_type)s near %(entity)s') % {
                    'entity_type': capfirst(entity_type.verbose_name_plural),
                    'entity': context['entity'].title
                },
            lazy_reverse('places:entity_nearby_detail', args=[scheme, value, ptype]))

    def get_metadata(self, request, scheme, value, ptype):
        entity = get_entity(type_slug, id)
        return super(NearbyEntityDetailView, self).get_metadata(request, ptype, entity)

    def handle_GET(self, request, context, scheme, value, ptype):
        entity = context['entity']
        return super(NearbyEntityDetailView, self).handle_GET(request, context, ptype, entity)


class CategoryListView(BaseView):

    def initial_context(self, request):
        categorised_entity_types = defaultdict(list)
        for et in EntityType.objects.filter(show_in_category_list=True):
            categorised_entity_types[_(et.category.name)].append(et)
        # Need to do this other Django evalutes .items as ['items']
        categorised_entity_types = dict(
            (k, sorted(v, key=lambda x: x.verbose_name.lower()))
            for k, v in categorised_entity_types.items())
        return {
            'entity_types': categorised_entity_types,
        }

    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            'places',
            lazy_parent('index'),
            _('Categories'),
            lazy_reverse('category-list'),
        )

    def handle_GET(self, request, context):
        return self.render(request, context, 'places/category_list',
                           expires=timedelta(days=28))


class CategoryDetailView(BaseView):

    def initial_context(self, request, ptypes):
        entity_types = tuple(get_object_or_404(EntityType, slug=t) for t in ptypes.split(';'))

        entities = Entity.objects.all()
        for entity_type in entity_types:
            entities = entities.filter(all_types_completion=entity_type)

        entities = sorted(entities, key=lambda e: e.title)
        paginator = Paginator(entities, 100)

        try:
            page = int(request.GET.get('page', '1'))
        except ValueError:
            page = 1

        try:
            paged_entities = paginator.page(page)
        except (EmptyPage, InvalidPage):
            paged_entities = paginator.page(1)

        found_entity_types = set()
        for e in entities:
            found_entity_types |= set(e.all_types.all())
        found_entity_types -= set(entity_types)

        return {
            'entity_types': entity_types,
            'count': len(entities),
            'entities': paged_entities,
            'found_entity_types': found_entity_types,
        }

    @BreadcrumbFactory
    def breadcrumb(self, request, context, ptypes):
        return Breadcrumb(
            'places',
            lazy_parent('category-list'),
            capfirst(context['entity_types'][0].verbose_name_plural),
            lazy_reverse('category-detail', args=[ptypes]),
        )

    def get_metadata(self, request, ptypes):
        context = CategoryDetailView.initial_context(self, request, ptypes)

        if len(context['entity_types']) > 1:
            return {
                'exclude_from_search': True,
                'title': 'All %s' % context['entity_types'][0].verbose_name_plural,
            }

        return {
            'title': 'All %s' % context['entity_types'][0].verbose_name_plural,
            'additional': '<strong>%d %s</strong>' % (
                context['entities'].paginator.count,
                context['entity_types'][0].verbose_name_plural,
            ),
        }

    def handle_GET(self, request, context, ptypes):
        return self.render(request, context, 'places/category_detail',
                           expires=timedelta(days=1))

class EntityDirectionsView(LocationRequiredView):
    default_zoom = 16

    def get_metadata(self, request, scheme, value):
        entity = get_entity(scheme, value)
        return {
            'title': _('Directions to %s') % entity.title,
            'entity': entity,
        }

    def initial_context(self, request, scheme, value):
        context = super(EntityDirectionsView, self).initial_context(request)
        entity = get_entity(scheme, value)
        
        allowed_types = ALLOWED_ROUTING_TYPES
        type = request.GET.get('type')
        if type:
            request.session['places:directions-type'] = type
        else:
            type = request.session.get('places:directions-type', 'foot')
        
        if type not in allowed_types:
            type = 'foot'
        
        context.update({
            'entity': entity,
            'type': type,
            'allowed_types': allowed_types,
        })
        return context

    @BreadcrumbFactory
    def breadcrumb(self, request, context, scheme, value):
        entity = get_entity(scheme, value)
        return Breadcrumb(
            'places',
            lazy_parent('entity', scheme=scheme, value=value),
            _('Directions to %s') % context['entity'].title,
            lazy_reverse('entity-directions', args=[scheme, value]),
        )

    def handle_GET(self, request, context, scheme, value):
        
        user_location = request.session.get('geolocation:location')
        if user_location is not None:
            user_location = Point(user_location)
        destination = context['entity'].routing_point(user_location)
        
        if destination.location is not None:
            context['route'] = generate_route([user_location,
                                              destination.location],
                                              context['type'])
            if not 'error' in context['route']:
                context['map'] = Map(
                    (user_location[0], user_location[1], 'green', ''),
                    [(w['location'][0], w['location'][1], 'red', w['instruction'])
                        for w in context['route']['waypoints']],
                    len(context['route']['waypoints']),
                    None,
                    request.map_width,
                    request.map_height,
                    extra_points=[(destination.location[0],
                                   destination.location[1],
                                   'red', destination.title)],
                    paths=[(context['route']['path'], '#3c3c3c')])

        return self.render(request, context, 'places/entity_directions')

class ServiceDetailView(BaseView):
    """
    A view showing details of a particular transport service leaving from a place
    """

    @BreadcrumbFactory
    def breadcrumb(self, request, context, scheme, value):
        return Breadcrumb(
            'places',
            lazy_parent('entity', scheme=scheme, value=value),
            context['title'],
            lazy_reverse('service-detail', args=[scheme, value]))

    def get_metadata(self, request, scheme, value):
        return {}

    def initial_context(self, request, scheme, value):

        context = super(ServiceDetailView, self).initial_context(request)
        
        service_id = request.GET.get('id')
        route_id = request.GET.get('route')
        route_pk = request.GET.get('routeid')
        journey = request.GET.get('journey')
        
        if service_id or route_id or route_pk or journey:
            entity = get_entity(scheme, value)
        else:
            raise Http404()
        
        context.update({
            'entity': entity,
        })
        
        if service_id:
            # Add live information from the providers
            for provider in reversed(self.conf.providers):
                provider.augment_metadata((entity, ))
    
            # If we have no way of getting further journey details, 404
            if 'service_details' not in entity.metadata:
                raise Http404
    
            # Deal with train service data
            if entity.metadata['service_type'] == 'ldb':
                # LDB has + in URLs, but Django converts that to space
                service = entity.metadata['service_details'](service_id.replace(' ', '+'))
            else:
                service = entity.metadata['service_details'](service_id)
            
            if service is None:
                raise Http404
            if 'error' in service:
                context.update({
                    'title': _('An error occurred'),
                    'service': {
                        'error': service['error'],
                    },
                })
                return context

            context.update({
                'service': service,
                'title': service['title'],
                'zoom_controls': False,
            })
        
        elif route_id or route_pk:
            
            if route_id:
            
                route = entity.route_set.filter(service_id=route_id).distinct()
                if route.count() == 0:
                    raise Http404()
                elif route.count() > 1:
                    context.update({
                        'title': _('Multiple routes found'),
                        'multiple_routes': route
                    })
                    return context
                else:
                    route = route[0]
            
            else:
                
                route = get_object_or_404(Route, id=route_pk)
            
            i = 1
            calling_points = []
            previous = True
            for stop in route.stoponroute_set.all():
                if stop.entity == entity:
                    previous = False
                calling_point = {
                    'entity': stop.entity,
                    'at': previous,
                    #'activity': stop.activity
                }
                if stop.entity.location is not None:
                    calling_point['stop_num'] = i
                    i += 1
                calling_points.append(calling_point)
            service = {
                    'entities': route.stops.all().order_by('stoponroute__order'),
                    'operator': route.operator,
                    'has_timetable': False,
                    'has_realtime': False,
                    'calling_points': calling_points
                }
            if entity not in service['entities']:
                raise Http404()
            context.update({
                'title': '%s: %s' % (route.service_id, route.service_name),
                'service': service                
            })
        
        elif journey:
            
            journey = get_object_or_404(Journey, id=journey)
            route = journey.route
            entity_passed = False
            i = 1
            calling_points = []
            
            for stop in journey.scheduledstop_set.all():
                
                if stop.entity == entity:
                    entity_passed = True
                
                if not entity_passed and stop.std < datetime.now().time():
                    
                    calling_point = {
                        'entity': stop.entity,
                        'st': stop.std.strftime('%H:%M'),
                        'at': True,
                        'activity': stop.activity
                    }
                
                else:
                    
                    calling_point = {
                        'entity': stop.entity,
                        # Show arrival time (if it exists, else departure time)
                        # if this stop is AFTER where we currently are, otherwise
                        # show the time the bus left stops before this one (if
                        # it exists)
                        'st': ((stop.sta or stop.std) if entity_passed else (stop.std or stop.sta)).strftime('%H:%M'),
                        'at': False,
                        'activity': stop.activity
                    }
                
                if stop.entity.location is not None:
                    calling_point['stop_num'] = i
                    i += 1
                calling_points.append(calling_point)
            
            service = {
                    'entities': [s.entity for s in journey.scheduledstop_set.all()],
                    'operator': journey.route.operator,
                    'has_timetable': True,
                    'has_realtime': False,
                    'calling_points': calling_points,
                    'notes': journey.notes
                }
            if entity not in service['entities']:
                raise Http404()
            context.update({
                'title': '%s: %s' % (route.service_id, route.service_name),
                'service': service                
            })
        
        if entity.location or len(filter(lambda e: e.location is not None, service['entities'])):
            map = Map(
                centre_point = (entity.location[0], entity.location[1],
                                'green', entity.title) if entity.location else None,
                points = [(e.location[0], e.location[1], 'red', e.title)
                    for e in service['entities'] if e.location is not None],
                min_points = len(service['entities']),
                zoom = None,
                width = request.map_width,
                height = request.map_height,
            )
    
            context.update({
                    'map': map
                })

        return context

    def handle_GET(self, request, context, scheme, value):
        return self.render(request, context, 'places/service_details')


class RouteView(BaseView):
    
    @BreadcrumbFactory
    def breadcrumb(self, request, context, route, id):
        return Breadcrumb(
            'places',
            lazy_parent('index'),
            context['title'],
            lazy_reverse('route', args=[route, id]))
    
    def initial_context(self, request, route, id):
        
        context = super(RouteView, self).initial_context(request)
        
        if id is None:
            
            context.update({
                'title': _('Select a route'),
                'multiple_routes': Route.objects.filter(service_id=route)
            })
            
        else:
            
            route = get_object_or_404(Route, id=id)
            
            i = 1
            calling_points = []
            
            for stop in route.stoponroute_set.all():
                
                calling_point = {'entity': stop.entity}
                if stop.entity.location is not None:
                    calling_point['stop_num'] = i
                    i += 1
                calling_points.append(calling_point)
            
            service = {
                    'entities': route.stops.all().order_by('stoponroute__order'),
                    'operator': route.operator,
                    'has_timetable': False,
                    'has_realtime': False,
                    'calling_points': calling_points
                }
            
            context.update({
                'title': '%s: %s' % (route.service_id, route.service_name),
                'service': service,
                'route': route
            })
        
        return context
    
    def handle_GET(self, request, context, route, id):
        
        if len(context.get('multiple_routes', [])) == 1:
            # Only one alternative, redirect straight there
            route = context['multiple_routes'][0]
            return self.redirect(reverse('places:route', args=[route.service_id,
                                                               route.pk]), request)
        
        elif id is not None and route != context['route'].service_id:
            # Redirect if the route doesn't match the ID
            return self.redirect(reverse('places:route', args=[context['route'].service_id, id]), request)
        else:
            return self.render(request, context, 'places/service_details')


class TimetableView(BaseView):
    """
    A view which shows the timetable of all departures for a stop.
    """
    
    @BreadcrumbFactory
    def breadcrumb(self, request, context, scheme, value, year, month, day):
        return Breadcrumb(
            'places',
            lazy_parent('entity', scheme=scheme, value=value),
            context['title'],
            lazy_reverse('timetable', args=[scheme, value]))
    
    def initial_context(self, request, scheme, value, year, month, day):
        
        context = super(TimetableView, self).initial_context(request)
        
        context['entity'] = get_entity(scheme, value)
        
        if year and month and day:
            try:
                context['date'] = date(int(year), int(month), int(day))
            except ValueError:
                raise Http404()
        else:
            context['date'] = date.today()
        
        if context['entity'].scheduledstop_set.all().count() == 0:
            # 404 on entities which don't have timetables
            raise Http404()
        
        services = context['entity'].scheduledstop_set.filter(
           journey__runs_from__lte=context['date'],
            journey__runs_until__gte=context['date']
        ).exclude(activity__in=('D','N','F')).order_by('std')
        
        context['timetable'] = filter(lambda s: s.journey.runs_on(context['date']),
                                      services)
        
        context['title'] = _('Timetable for %(title)s on %(date)s') % {
            'title': context['entity'].title,
            'date': djangodate(context['date'])
        }
        
        return context
    
    def handle_GET(self, request, context, scheme, value, year, month, day):
        
        return self.render(request, context, 'places/timetable')

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from models import *

class PodcastCategoryNameInline(admin.TabularInline):
    model = PodcastCategoryName
    fk_name = "podcast_category"

class PodcastCategoryAdmin(admin.ModelAdmin):
    list_display = ('slug', 'name')
    inlines = [
        PodcastCategoryNameInline,
    ]

class PodcastAdmin(admin.ModelAdmin):
    list_display = ('category', 'title')
    list_filter = ('category',)

class PodcastItemAdmin(admin.ModelAdmin):
    list_display = ('podcast', 'title', 'published_date', 'duration')
    list_filter = ('podcast',)


admin.site.register(Podcast, PodcastAdmin)
admin.site.register(PodcastCategory, PodcastCategoryAdmin)
admin.site.register(PodcastItem, PodcastItemAdmin)
admin.site.register(PodcastEnclosure)

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'PodcastCategory'
        db.create_table('podcasts_podcastcategory', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=50, db_index=True)),
            ('name', self.gf('django.db.models.fields.TextField')()),
            ('order', self.gf('django.db.models.fields.IntegerField')(null=True)),
        ))
        db.send_create_signal('podcasts', ['PodcastCategory'])

        # Adding model 'Podcast'
        db.create_table('podcasts_podcast', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=50, db_index=True)),
            ('title', self.gf('django.db.models.fields.TextField')(null=True)),
            ('description', self.gf('django.db.models.fields.TextField')(null=True)),
            ('rss_url', self.gf('django.db.models.fields.URLField')(max_length=200)),
            ('last_updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('category', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['podcasts.PodcastCategory'], null=True)),
            ('most_recent_item_date', self.gf('django.db.models.fields.DateTimeField')(null=True)),
            ('medium', self.gf('django.db.models.fields.CharField')(max_length=8, null=True)),
            ('provider', self.gf('django.db.models.fields.TextField')()),
            ('license', self.gf('django.db.models.fields.URLField')(max_length=200, null=True)),
            ('logo', self.gf('django.db.models.fields.URLField')(max_length=200, null=True)),
        ))
        db.send_create_signal('podcasts', ['Podcast'])

        # Adding model 'PodcastItem'
        db.create_table('podcasts_podcastitem', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('podcast', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['podcasts.Podcast'])),
            ('title', self.gf('django.db.models.fields.TextField')(null=True)),
            ('description', self.gf('django.db.models.fields.TextField')(null=True)),
            ('published_date', self.gf('django.db.models.fields.DateTimeField')(null=True)),
            ('author', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('duration', self.gf('django.db.models.fields.PositiveIntegerField')(null=True)),
            ('guid', self.gf('django.db.models.fields.TextField')()),
            ('order', self.gf('django.db.models.fields.IntegerField')(null=True)),
            ('license', self.gf('django.db.models.fields.URLField')(max_length=200, null=True)),
        ))
        db.send_create_signal('podcasts', ['PodcastItem'])

        # Adding model 'PodcastEnclosure'
        db.create_table('podcasts_podcastenclosure', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('podcast_item', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['podcasts.PodcastItem'])),
            ('url', self.gf('django.db.models.fields.URLField')(max_length=200)),
            ('length', self.gf('django.db.models.fields.IntegerField')(null=True)),
            ('mimetype', self.gf('django.db.models.fields.TextField')(null=True)),
        ))
        db.send_create_signal('podcasts', ['PodcastEnclosure'])


    def backwards(self, orm):
        
        # Deleting model 'PodcastCategory'
        db.delete_table('podcasts_podcastcategory')

        # Deleting model 'Podcast'
        db.delete_table('podcasts_podcast')

        # Deleting model 'PodcastItem'
        db.delete_table('podcasts_podcastitem')

        # Deleting model 'PodcastEnclosure'
        db.delete_table('podcasts_podcastenclosure')


    models = {
        'podcasts.podcast': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Podcast'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['podcasts.PodcastCategory']", 'null': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'license': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True'}),
            'logo': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True'}),
            'medium': ('django.db.models.fields.CharField', [], {'max_length': '8', 'null': 'True'}),
            'most_recent_item_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True'}),
            'provider': ('django.db.models.fields.TextField', [], {}),
            'rss_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {'null': 'True'})
        },
        'podcasts.podcastcategory': {
            'Meta': {'ordering': "('order', 'name')", 'object_name': 'PodcastCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {}),
            'order': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'})
        },
        'podcasts.podcastenclosure': {
            'Meta': {'object_name': 'PodcastEnclosure'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'length': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'mimetype': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'podcast_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['podcasts.PodcastItem']"}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'})
        },
        'podcasts.podcastitem': {
            'Meta': {'object_name': 'PodcastItem'},
            'author': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'duration': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True'}),
            'guid': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'license': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True'}),
            'order': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'podcast': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['podcasts.Podcast']"}),
            'published_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {'null': 'True'})
        }
    }

    complete_apps = ['podcasts']

########NEW FILE########
__FILENAME__ = 0002_auto__add_unique_podcast_slug
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding unique constraint on 'Podcast', fields ['slug']
        db.create_unique('podcasts_podcast', ['slug'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Podcast', fields ['slug']
        db.delete_unique('podcasts_podcast', ['slug'])


    models = {
        'podcasts.podcast': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Podcast'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['podcasts.PodcastCategory']", 'null': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'license': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True'}),
            'logo': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True'}),
            'medium': ('django.db.models.fields.CharField', [], {'max_length': '8', 'null': 'True'}),
            'most_recent_item_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True'}),
            'provider': ('django.db.models.fields.TextField', [], {}),
            'rss_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50', 'db_index': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {'null': 'True'})
        },
        'podcasts.podcastcategory': {
            'Meta': {'ordering': "('order', 'name')", 'object_name': 'PodcastCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {}),
            'order': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'})
        },
        'podcasts.podcastenclosure': {
            'Meta': {'object_name': 'PodcastEnclosure'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'length': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'mimetype': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'podcast_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['podcasts.PodcastItem']"}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'})
        },
        'podcasts.podcastitem': {
            'Meta': {'object_name': 'PodcastItem'},
            'author': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'duration': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True'}),
            'guid': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'license': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True'}),
            'order': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'podcast': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['podcasts.Podcast']"}),
            'published_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {'null': 'True'})
        }
    }

    complete_apps = ['podcasts']

########NEW FILE########
__FILENAME__ = 0003_auto__add_field_podcast_language
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Podcast.language'
        db.add_column('podcasts_podcast', 'language', self.gf('django.db.models.fields.CharField')(max_length=10, null=True), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Podcast.language'
        db.delete_column('podcasts_podcast', 'language')


    models = {
        'podcasts.podcast': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Podcast'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['podcasts.PodcastCategory']", 'null': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language': ('django.db.models.fields.CharField', [], {'max_length': '10', 'null': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'license': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True'}),
            'logo': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True'}),
            'medium': ('django.db.models.fields.CharField', [], {'max_length': '8', 'null': 'True'}),
            'most_recent_item_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True'}),
            'provider': ('django.db.models.fields.TextField', [], {}),
            'rss_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50', 'db_index': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {'null': 'True'})
        },
        'podcasts.podcastcategory': {
            'Meta': {'ordering': "('order', 'name')", 'object_name': 'PodcastCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {}),
            'order': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'})
        },
        'podcasts.podcastenclosure': {
            'Meta': {'object_name': 'PodcastEnclosure'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'length': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'mimetype': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'podcast_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['podcasts.PodcastItem']"}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'})
        },
        'podcasts.podcastitem': {
            'Meta': {'object_name': 'PodcastItem'},
            'author': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'duration': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True'}),
            'guid': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'license': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True'}),
            'order': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'podcast': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['podcasts.Podcast']"}),
            'published_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {'null': 'True'})
        }
    }

    complete_apps = ['podcasts']

########NEW FILE########
__FILENAME__ = 0004_auto__add_podcastcategoryname
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'PodcastCategoryName'
        db.create_table('podcasts_podcastcategoryname', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('podcast_category', self.gf('django.db.models.fields.related.ForeignKey')(related_name='names', to=orm['podcasts.PodcastCategory'])),
            ('language_code', self.gf('django.db.models.fields.CharField')(max_length=10)),
            ('name', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('podcasts', ['PodcastCategoryName'])


    def backwards(self, orm):
        
        # Deleting model 'PodcastCategoryName'
        db.delete_table('podcasts_podcastcategoryname')


    models = {
        'podcasts.podcast': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Podcast'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['podcasts.PodcastCategory']", 'null': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language': ('django.db.models.fields.CharField', [], {'max_length': '10', 'null': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'license': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True'}),
            'logo': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True'}),
            'medium': ('django.db.models.fields.CharField', [], {'max_length': '8', 'null': 'True'}),
            'most_recent_item_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True'}),
            'provider': ('django.db.models.fields.TextField', [], {}),
            'rss_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50', 'db_index': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {'null': 'True'})
        },
        'podcasts.podcastcategory': {
            'Meta': {'ordering': "('order', 'name')", 'object_name': 'PodcastCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {}),
            'order': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'})
        },
        'podcasts.podcastcategoryname': {
            'Meta': {'object_name': 'PodcastCategoryName'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'name': ('django.db.models.fields.TextField', [], {}),
            'podcast_category': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['podcasts.PodcastCategory']"})
        },
        'podcasts.podcastenclosure': {
            'Meta': {'object_name': 'PodcastEnclosure'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'length': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'mimetype': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'podcast_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['podcasts.PodcastItem']"}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'})
        },
        'podcasts.podcastitem': {
            'Meta': {'object_name': 'PodcastItem'},
            'author': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'duration': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True'}),
            'guid': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'license': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True'}),
            'order': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'podcast': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['podcasts.Podcast']"}),
            'published_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {'null': 'True'})
        }
    }

    complete_apps = ['podcasts']

########NEW FILE########
__FILENAME__ = 0005_i18n_categories
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models
from django.conf import settings
from molly.utils.i18n import name_in_language

class Migration(DataMigration):

    def forwards(self, orm):
        """
        Move category names to the new i18n format
        """
        for pc in orm.PodcastCategory.objects.all():
            pc.names.create(language_code=settings.LANGUAGE_CODE,
                            name=pc.name)


    def backwards(self, orm):
        """
        Move category names from the new i18n format
        """
        for pc in orm.PodcastCategory.objects.all():
            pc.name = name_in_language(pc, 'name')


    models = {
        'podcasts.podcast': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Podcast'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['podcasts.PodcastCategory']", 'null': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language': ('django.db.models.fields.CharField', [], {'max_length': '10', 'null': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'license': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True'}),
            'logo': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True'}),
            'medium': ('django.db.models.fields.CharField', [], {'max_length': '8', 'null': 'True'}),
            'most_recent_item_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True'}),
            'provider': ('django.db.models.fields.TextField', [], {}),
            'rss_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50', 'db_index': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {'null': 'True'})
        },
        'podcasts.podcastcategory': {
            'Meta': {'ordering': "('order', 'name')", 'object_name': 'PodcastCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {}),
            'order': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'})
        },
        'podcasts.podcastcategoryname': {
            'Meta': {'object_name': 'PodcastCategoryName'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'name': ('django.db.models.fields.TextField', [], {}),
            'podcast_category': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['podcasts.PodcastCategory']"})
        },
        'podcasts.podcastenclosure': {
            'Meta': {'object_name': 'PodcastEnclosure'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'length': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'mimetype': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'podcast_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['podcasts.PodcastItem']"}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'})
        },
        'podcasts.podcastitem': {
            'Meta': {'object_name': 'PodcastItem'},
            'author': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'duration': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True'}),
            'guid': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'license': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True'}),
            'order': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'podcast': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['podcasts.Podcast']"}),
            'published_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {'null': 'True'})
        }
    }

    complete_apps = ['podcasts']

########NEW FILE########
__FILENAME__ = 0006_auto__del_field_podcastcategory_name
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting field 'PodcastCategory.name'
        db.delete_column('podcasts_podcastcategory', 'name')


    def backwards(self, orm):
        
        # Adding field 'PodcastCategory.name'
        db.add_column('podcasts_podcastcategory', 'name', self.gf('django.db.models.fields.TextField')(default=''), keep_default=False)


    models = {
        'podcasts.podcast': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Podcast'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['podcasts.PodcastCategory']", 'null': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language': ('django.db.models.fields.CharField', [], {'max_length': '10', 'null': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'license': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True'}),
            'logo': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True'}),
            'medium': ('django.db.models.fields.CharField', [], {'max_length': '8', 'null': 'True'}),
            'most_recent_item_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True'}),
            'provider': ('django.db.models.fields.TextField', [], {}),
            'rss_url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50', 'db_index': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {'null': 'True'})
        },
        'podcasts.podcastcategory': {
            'Meta': {'ordering': "('order',)", 'object_name': 'PodcastCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'order': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'})
        },
        'podcasts.podcastcategoryname': {
            'Meta': {'object_name': 'PodcastCategoryName'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'name': ('django.db.models.fields.TextField', [], {}),
            'podcast_category': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['podcasts.PodcastCategory']"})
        },
        'podcasts.podcastenclosure': {
            'Meta': {'object_name': 'PodcastEnclosure'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'length': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'mimetype': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'podcast_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['podcasts.PodcastItem']"}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'})
        },
        'podcasts.podcastitem': {
            'Meta': {'object_name': 'PodcastItem'},
            'author': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'duration': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True'}),
            'guid': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'license': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True'}),
            'order': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'podcast': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['podcasts.Podcast']"}),
            'published_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {'null': 'True'})
        }
    }

    complete_apps = ['podcasts']

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.conf import settings
from django.core.urlresolvers import reverse
from django.utils.translation import ugettext_lazy as _
from django.utils.translation import ugettext_noop

from molly.apps.podcasts.data import licenses
from molly.external_media import resize_external_image
from molly.utils.i18n import name_in_language

MEDIUM_CHOICES = (
    ('audio', _('audio')),
    ('video', _('video')),
    ('document', _('document')),
)

class PodcastCategory(models.Model):
    slug = models.SlugField()
    order = models.IntegerField(null=True)
    
    @property
    def name(self):
        return name_in_language(self, 'name')
    
    def get_absolute_url(self):
        return reverse('podcasts:category', args=[self.slug])
        
    def __unicode__(self):
        return self.name or ''
    class Meta:
        verbose_name = _('Podcast category')
        verbose_name_plural = _('Podcast categories')
        ordering = ('order',)


class PodcastCategoryName(models.Model):
    podcast_category = models.ForeignKey(PodcastCategory, related_name='names')
    language_code = models.CharField(max_length=10, choices=settings.LANGUAGES)
    name = models.TextField()
    

class Podcast(models.Model):
    slug = models.SlugField(unique=True)
    title = models.TextField(null=True)
    description = models.TextField(null=True)
    rss_url = models.URLField()
    last_updated = models.DateTimeField(auto_now=True)
    category = models.ForeignKey(PodcastCategory, null=True)
    most_recent_item_date = models.DateTimeField(null=True)
    medium = models.CharField(max_length=8, choices=MEDIUM_CHOICES, null=True)
    provider = models.TextField()
    license = models.URLField(null=True)
    logo = models.URLField(null=True)
    language = models.CharField(max_length=10, choices=settings.LANGUAGES,
                                null=True)
    
    def get_absolute_url(self):
        return reverse('podcasts:podcast', args=[self.slug])
        
    def __unicode__(self):
        return self.title or ''
    
    @property
    def license_data(self):
        return licenses.get(self.license)

    class Meta:
        verbose_name = _('Podcast feed')
        verbose_name_plural = _('Podcast feeds')
        ordering = ('title',)
    
    def simplify_for_render(self, simplify_value, simplify_model):
        simplified = simplify_model(self)
        simplified.update({
            'resized_logo': simplify_model(resize_external_image(self.logo, 60))
        })
        return simplified


class PodcastItem(models.Model):
    podcast = models.ForeignKey(Podcast)
    title = models.TextField(null=True)
    description = models.TextField(null=True)
    published_date = models.DateTimeField(null=True)
    author = models.TextField(null=True, blank=True)
    duration = models.PositiveIntegerField(null=True)
    guid = models.TextField()
    order = models.IntegerField(null=True)
    license = models.URLField(null=True)

    def __unicode__(self):
        return self.title or ''
        
    @property
    def license_data(self):
        return licenses.get(self.license) or licenses.get(self.podcast.license)

    class Meta:
        verbose_name = _('Podcast item')
        verbose_name_plural = _('Podcast items')
    
    def simplify_for_render(self, simplify_value, simplify_model):
        return {
            'podcast': simplify_model(self.podcast, terse=True),
            'title': simplify_value(self.title),
            'description': simplify_value(self.description),
            'published_date': simplify_value(self.published_date),
            'author': simplify_value(self.author),
            'duration': simplify_value(self.duration),
            'guid': simplify_value(self.guid),
            'order': simplify_value(self.order),
            'license_data': simplify_value(self.license_data),
            'enclosures': simplify_value(self.podcastenclosure_set.all())
        }

MIMETYPES = {
    'audio/x-mpeg': _('MP3 audio'),
    'video/mp4': _('MP4 video'),
    'MPEG4 Video': _('MP4 video'),
    'text/html': _('HTML document'),
    'audio/mpeg': _('MP3 audio'),
    'video/x-ms-wmv': _('WMV video'),
    'text/plain': _('plain text'),
    'application/pdf': _('PDF document'),
    'audio/x-m4b': _('MP4 audio'),
    'application/octet-stream': _('unknown'),
    'video/mpeg': _('MPEG video'),
    'video/x-m4v': _('MP4 video'),
    'audio/x-m4a': _('MP4 audio'),
    'application/epub+zip': _('ePub eBook')
}    

class PodcastEnclosure(models.Model):
    podcast_item = models.ForeignKey(PodcastItem)
    url = models.URLField()
    length = models.IntegerField(null=True)
    mimetype = models.TextField(null=True)
    
    @property
    def medium(self):
        medium = {
                'application/pdf': ugettext_noop('document'),
                'MPEG4 Video': ugettext_noop('video')
            }.get(self.mimetype)
        if medium:
            return medium
        elif not self.mimetype:
            return self.podcast_item.podcast.medium or ugettext_noop('unknown')
        elif self.mimetype.startswith('audio/'):
            return ugettext_noop('audio')
        elif self.mimetype.startswith('video/'):
            return ugettext_noop('video')
        else:
            return self.podcast_item.podcast.medium or ugettext_noop('unknown')
    
    def get_mimetype_display(self):
        return MIMETYPES.get(self.mimetype, _('unknown'))
    
    class Meta:
        verbose_name = _('Podcast enclosed data')
        verbose_name_plural = _('Podcast enclosed data')
    
    def simplify_for_render(self, simplify_value, simplify_model):
        return {
            'podcast_item': simplify_model(self.podcast_item, terse=True),
            'url': simplify_value(self.url),
            'length': simplify_value(self.length),
            'mimetype': simplify_value(self.mimetype),
            'mimetype_display': simplify_value(self.get_mimetype_display()),
            'medium': simplify_value(self.medium),
        }


########NEW FILE########
__FILENAME__ = opml
from xml.etree import ElementTree as ET
from datetime import datetime, timedelta
import urllib
import re
import email
import random
import logging
import traceback

from django.template.defaultfilters import slugify
from django.utils.translation import ugettext_noop as _

from molly.conf.provider import task
from molly.utils.i18n import set_name_in_language
from molly.apps.podcasts.providers import BasePodcastsProvider
from molly.apps.podcasts.models import Podcast, PodcastItem, PodcastCategory, PodcastEnclosure
from molly.apps.podcasts.providers.rss import RSSPodcastsProvider

logger = logging.getLogger(__name__)

class OPMLPodcastsProvider(RSSPodcastsProvider):
    def __init__(self, url, rss_re, lang_code='en'):
        self.url = url
        self.medium = None
        self.rss_re = re.compile(rss_re)
        self._category = None
        self.lang_code = lang_code

    CATEGORY_ORDERS = {}

    CATEGORY_RE = re.compile('/([^\/]+)/([^,]+)')
    
    def extract_medium(self, url):
        return 'audio'
    
    def extract_slug(self, url):
        match_groups = self.rss_re.match(url).groups()
        return match_groups[0]
    
    def decode_category(self, attrib):
        if self._category is None:
            cat = 'Uncategorised'
        else:
            cat = self._category
        
        slug = slugify(cat)
        
        podcast_category, created = PodcastCategory.objects.get_or_create(slug=slug)
        set_name_in_language(podcast_category, self.lang_code, name=cat)
        
        try:
            podcast_category.order = self.CATEGORY_ORDERS[slug]
        except KeyError:
            self.CATEGORY_ORDERS[slug] = len(self.CATEGORY_ORDERS)
            podcast_category.order = self.CATEGORY_ORDERS[slug]
        
        podcast_category.save()
        return podcast_category

    def parse_outline(self, outline):
        attrib = outline.attrib
        podcast, created = Podcast.objects.get_or_create(
            provider=self.class_path,
            rss_url=attrib['xmlUrl'])
        
        podcast.medium = self.extract_medium(attrib['xmlUrl'])
        podcast.category = self.decode_category(attrib)
        podcast.slug = self.extract_slug(attrib['xmlUrl'])
        podcast.save()
        
        self.update_podcast.delay(podcast)

    @task(run_every=timedelta(minutes=60))
    def import_data(self, **metadata):
        
        self._category = None

        xml = ET.parse(urllib.urlopen(self.url))

        rss_urls = []

        podcast_elems = xml.findall('.//body/outline')

        failure_logged = False

        for outline in podcast_elems:
            if 'xmlUrl' in outline.attrib:
                try:
                    self.parse_outline(outline)
                    rss_urls.append(outline.attrib['xmlUrl'])
                except Exception, e:
                    if not failure_logged:
                        logger.exception("Update of podcast %r failed.", outline.attrib['xmlUrl'])
                        failure_logged = True
            else:
                self._category = outline.attrib['text']
                # Assume this is an outline which contains other outlines
                for outline in outline.findall('./outline'):
                    if 'xmlUrl' in outline.attrib:
                        try:
                            self.parse_outline(outline)
                            rss_urls.append(outline.attrib['xmlUrl'])
                        except Exception, e:
                            if not failure_logged:
                                logger.exception("Update of podcast %r failed.", outline.attrib['xmlUrl'])
                                failure_logged = True
                self._category = None

        for podcast in Podcast.objects.filter(provider=self.class_path):
            if not podcast.rss_url in rss_urls:
                podcast.delete()
        
        return metadata

########NEW FILE########
__FILENAME__ = pp
from lxml import etree
from datetime import datetime, timedelta
import urllib
import re
import email
import random

from django.conf import settings

from molly.conf.provider import task
from molly.apps.podcasts.providers import BasePodcastsProvider
from molly.apps.podcasts.models import Podcast, PodcastItem, PodcastCategory, PodcastEnclosure
from molly.utils.i18n import set_name_in_language

from rss import RSSPodcastsProvider

class PodcastProducerPodcastsProvider(RSSPodcastsProvider):
    def __init__(self, url):
        self.url = url

    @task(run_every=timedelta(minutes=60))
    def import_data(self, **metadata):
        atom = self.atom
        xml = etree.parse(urllib.urlopen(self.url))

        rss_urls = []

        category_elems = xml.getroot().findall(atom('entry'))
        
        for i, category_elem in enumerate(category_elems):
            link = category_elem.find(atom('link')+"[@rel='alternate']")
            slug = link.attrib['href'].split('/')[-1]
            
            category, created = PodcastCategory.objects.get_or_create(slug=slug)
            set_name_in_language(category, lang_code, name=category_elem.find(atom('title')).text)
            category.order = i
            category.save()
            
            category_xml = etree.parse(urllib.urlopen(link.attrib['href']))
            
            for podcast_elem in category_xml.getroot().findall(atom('entry')):
                url = podcast_elem.find(atom('link')+"[@rel='alternate']").attrib['href']
                slug = url.split('/')[-1]
                podcast, created = Podcast.objects.get_or_create(
                    provider=self.class_path,
                    slug=slug)
                podcast.rss_url = url
        
                podcast.category = category
        
                rss_urls.append(url)
        
                self.update_podcast.delay(podcast)

        for podcast in Podcast.objects.filter(provider=self.class_path):
            if not podcast.rss_url in rss_urls:
                podcast.delete()
        
        return metadata


########NEW FILE########
__FILENAME__ = rss
import random, urllib, email
from lxml import etree
from datetime import datetime, timedelta

from molly.conf.provider import task
import dateutil.parser

from molly.apps.podcasts.providers import BasePodcastsProvider
from molly.apps.podcasts.models import Podcast, PodcastItem, PodcastEnclosure

class Namespace(object):
    def __init__(self, ns):
        self.ns = ns
    def __call__(self, local):
        return '{%s}%s' % (self.ns, local)

class RSSPodcastsProvider(BasePodcastsProvider):
    @property
    def PODCAST_ATTRS(self):
        atom = self.atom
        return (
            ('guid', ('guid', atom('id'),)),
            ('title', ('title', atom('title'),)),
            ('author', ('{itunes:}author',)),
            ('duration', ('{itunes:}duration',)),
            ('published_date', ('pubDate', atom('published'),)),
            ('description', ('description', atom('summary'),)),
    #       ('itunesu_code', '{itunesu:}code'),
        )

    def __init__(self, podcasts, medium=None):
        self.podcasts = podcasts
        self.medium = medium
    
    @property
    def atom(self):
        return Namespace('http://www.w3.org/2005/Atom')
    
    @task(run_every=timedelta(minutes=60))
    def import_data(self, **metadata):
        for slug, url in self.podcasts:
            podcast, url = Podcast.objects.get_or_create(
                provider=self.class_path,
                rss_url=url,
                defaults={'slug': slug})
            if self.medium: 
                podcast.medium = self.medium
                
            podcast.slug = slug
            self.update_podcast.delay(podcast)
            
    def determine_license(self, o):
        license = o.find('{http://purl.org/dc/terms/}license') or \
                  o.find('{http://backend.userland.com/creativeCommonsRssModule}license')
        
        return getattr(license, 'text', None)
        
    @task()
    def update_podcast(self, podcast):
        atom = self.atom
        def gct(node, names):
            for name in names:
                if node.find(name) is None:
                    continue
                value = node.find(name).text
                if name == 'pubDate':
                    value = datetime.fromtimestamp(
                        email.utils.mktime_tz(
                            email.utils.parsedate_tz(value)))
                elif name == atom('published'):
                    value = dateutil.parser.parse(value)
                elif name == '{itunes:}duration':
                    value = int(value)
                return value
            return None

        xml = etree.parse(urllib.urlopen(podcast.rss_url)).getroot()

        try:
            podcast.title = xml.find('.//channel/title').text
            podcast.description = xml.find('.//channel/description').text
        except AttributeError:
            podcast.title = xml.find(atom('title')).text
            podcast.description = xml.find(atom('subtitle')).text
        
        podcast.license = self.determine_license(xml.find('.//channel'))
        if self.medium is not None:
            podcast.medium = self.medium

        logo = xml.find('.//channel/image/url')
        podcast.logo = logo.text if logo is not None else None

        ids = []
        for item in xml.findall('.//channel/item') or xml.findall(atom('entry')):
            id = gct(item, ('guid', atom('id'),))
            if not id:
                continue
            
            try:
                podcast_item, created = PodcastItem.objects.get_or_create(podcast=podcast, guid=id)
            except PodcastItem.MultipleObjectsReturned:
                PodcastItem.objects.filter(podcast=podcast, guid=id).delete()
                podcast_item, created = PodcastItem.objects.get_or_create(podcast=podcast, guid=id)

            old_order = podcast_item.order
            try:
                podcast_item.order = int(item.find('{http://ns.ox.ac.uk/namespaces/oxitems/TopDownloads}position').text)
            except (AttributeError, TypeError):
                pass

            require_save = old_order != podcast_item.order
            for attr, x_attrs in self.PODCAST_ATTRS:
                if getattr(podcast_item, attr) != gct(item, x_attrs):
                    setattr(podcast_item, attr, gct(item, x_attrs))
                    require_save = True
            license = self.determine_license(item)
            if require_save or podcast_item.license != license:
                podcast_item.license = license
                podcast_item.save()

            enc_urls = []
            for enc in item.findall('enclosure') or item.findall(atom('link')):
                attrib = enc.attrib
                url = attrib.get('url', attrib.get('href'))
                podcast_enc, updated = PodcastEnclosure.objects.get_or_create(podcast_item=podcast_item, url=url)
                try:
                    podcast_enc.length = int(attrib['length']) 
                except ValueError:
                    podcast_enc.length = None
                podcast_enc.mimetype = attrib['type']
                podcast_enc.save()
                enc_urls.append(url)

            encs = PodcastEnclosure.objects.filter(podcast_item = podcast_item)
            for enc in encs:
                if not enc.url in enc_urls:
                    enc.delete()

            ids.append( id )

        for podcast_item in PodcastItem.objects.filter(podcast=podcast):
            if not podcast_item.guid in ids:
                podcast_item.podcastenclosure_set.all().delete()
                podcast_item.delete()

        #podcast.most_recent_item_date = max(i.published_date for i in PodcastItem.objects.filter(podcast=podcast))
        podcast.save()

########NEW FILE########
__FILENAME__ = tests
import sys
from django.utils import unittest

from django.core.management import call_command
from django.test.client import Client

from molly.apps.podcasts.models import Podcast, PodcastCategory
from molly.apps.podcasts.providers import OPMLPodcastsProvider

class PodcastsTestCase(unittest.TestCase):
    def setUp(self):
        if not Podcast.objects.count():
            opml = OPMLPodcastsProvider(url = 'http://www.bbc.co.uk/radio/opml/bbc_podcast_opml_v2.xml',
                                        rss_re = r'http://downloads.bbc.co.uk/podcasts/(.+)/rss.xml')
            opml.class_path = 'molly.providers.apps.podcasts.opml.OPMLPodcastsProvider'
            opml.import_data({})
        
    def testPodcasts(self):
        podcasts = Podcast.objects.all()
        
        c = Client()
        for podcast in podcasts:
            
            r = c.get('/podcasts/%s/' % podcast.category.slug)
            r = c.get('/podcasts/%s/%s/' % (podcast.category.slug, podcast.slug))
            self.assertTrue(r.context['podcast'].podcastitem_set.count() > 0)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from views import (
    IndexView, PodcastDetailView, CategoryDetailView,
    ITunesURedirectView
)

urlpatterns = patterns('',
    (r'^$',
        IndexView, {},
        'index'),
        
    (r'^category:(?P<category>[\dA-Z\-a-z]+)/$',
        CategoryDetailView, {},
        'category'),
    (r'^category:(?P<category>[\dA-Z\-a-z]+)/(?P<medium>[a-z]+)/$',
        CategoryDetailView, {},
        'category-medium'),

    (r'^itunesu_redirect/$',
        ITunesURedirectView, {},
        'itunesu-redirect'),

    (r'^(?P<slug>[a-zA-Z\d_@.\-/]+)/$',
        PodcastDetailView, {},
        'podcast'),

)


########NEW FILE########
__FILENAME__ = views
import urllib
from datetime import timedelta
from xml.etree import ElementTree as ET

from django.http import HttpResponse, Http404
from django.core.urlresolvers import reverse
from django.shortcuts import get_object_or_404
from django.utils.translation import ugettext as _
from django.utils.translation import get_language
from django.db.models import Q

from molly.utils.views import BaseView
from molly.utils.breadcrumbs import *

from molly.wurfl import device_parents

from molly.apps.podcasts.models import Podcast, PodcastCategory


class IndexView(BaseView):
    def get_metadata(self, request):
        return {
            'title': _('Podcasts'),
            'additional': _('Browse and listen to podcasts from around the University.')
        }
        
    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(self.conf.local_name, None,
                          _('Podcasts'), lazy_reverse('index'))
        
    def handle_GET(self, request, context):
        show_itunesu_link = request.session.get('podcasts:use_itunesu') == None
        if 'show_itunesu_link' in request.GET:
            show_itunesu_link = request.GET['show_itunesu_link'] != 'false'
        
        context.update({
            'categories': [c for c in PodcastCategory.objects.all()
                                        if c.podcast_set.all().count() > 0],
            'show_itunesu_link': show_itunesu_link,
            'podcasts': Podcast.objects.filter(category__isnull=True)
        })
        return self.render(request, context, 'podcasts/index',
                           expires=timedelta(days=7))

class CategoryDetailView(BaseView):
    def get_metadata(self, request, category, medium=None):
        if medium:
            raise Http404
            
        category = get_object_or_404(PodcastCategory, slug=category)
        return {
            'title': category.name,
            'additional': '<strong>' + _('Podcast category') + '</strong>'
        }
        
    def initial_context(self, request, category, medium=None):
        category = get_object_or_404(PodcastCategory, slug=category)
        
        # Only actually care about showing podcasts in the right language, not
        # dialect, so only match on before the -
        lang_code = get_language()
        if '-' in lang_code:
            lang_code = lang_code.split('-')[0]
        
        # Show all podcasts with no language
        podcasts = Podcast.objects.filter(category=category)
        if medium not in (None, 'all'):
            podcasts = podcasts.filter(medium=medium)
    
        all_podcasts = podcasts.count()
        if medium != 'all':
            podcasts = podcasts.filter(
                Q(language__startswith=lang_code) | Q(language=None)
            )
        lang_podcasts = podcasts.count()
    
        return {
            'category': category,
            'podcasts': podcasts,
            'medium': medium,
            'more_in_all': lang_podcasts != all_podcasts,
        }

    @BreadcrumbFactory
    def breadcrumb(self, request, context, category, medium=None):
        if medium:
            url = lazy_reverse('category-medium', args=[category,medium])
        else:
            url = lazy_reverse('category', args=[category])
        
        return Breadcrumb(self.conf.local_name, lazy_parent('index'),
                          context['category'].name,
                          url)
        
    def handle_GET(self, request, context, category, medium=None):
        return self.render(request, context, 'podcasts/category_detail',
                           expires=timedelta(hours=4))

class PodcastDetailView(BaseView):
    class RespondThus(Exception):
        def __init__(self, response):
            self.response = response
            
    def get_metadata(self, request, slug=None, podcast=None):
        if not podcast:
            try:
                podcast = get_object_or_404(Podcast, slug=slug)
            except Podcast.MultipleObjectsReturned:
                for podcast in Podcast.objects.filter(slug=slug)[1:]:
                    podcast.delete()
                podcast = get_object_or_404(Podcast, slug=slug)
        
        return {
            'title': podcast.title,
            'category': _('podcast'),
            'category_display': _('podcast'),
            'last_updated': podcast.last_updated,
            'additional': '<strong>' + _('Podcast') + '</strong> %s' % podcast.last_updated.strftime('%d %b %Y')
        }
        
    def initial_context(self, request, slug=None, podcast=None):
        if not podcast:
            try:
                podcast = get_object_or_404(Podcast, slug=slug)
            except Podcast.MultipleObjectsReturned:
                for podcast in Podcast.objects.filter(slug=slug)[1:]:
                    podcast.delete()
                podcast = get_object_or_404(Podcast, slug=slug)
        return {
            'podcast': podcast,
            'category': podcast.category,
        }
    
    @BreadcrumbFactory
    def breadcrumb(self, request, context, slug=None, podcast=None):
        if context['podcast'].category:
            parent = lazy_parent('category',
                                 category=context['podcast'].category.slug)
        else:
            parent = lazy_parent('index')
        return Breadcrumb(self.conf.local_name,
                          parent,
                          context['podcast'].title,
                          lazy_reverse('podcast'))
        
    def handle_GET(self, request, context, slug=None, podcast=None):
        if 'response' in context:
            return context['response']        
        
        items = context['podcast'].podcastitem_set.order_by('order','-published_date')
        
        context.update({
            'items': items,
        })
        return self.render(request, context, 'podcasts/podcast_detail',
                           expires=timedelta(hours=1))

class ITunesURedirectView(BaseView):
    breadcrumb = NullBreadcrumb
    
    def handle_POST(self, request, context):
        use_itunesu = request.POST.get('use_itunesu') == 'yes'
        remember = 'remember' in request.POST
        
        if remember:
            request.session['podcasts:use_itunesu'] = use_itunesu
        
        if request.method == 'POST' and 'no_redirect' in request.POST:
            return HttpResponse('', mimetype="text/plain")
        elif request.method == 'POST' and not use_itunesu:
            if remember:
                return self.redirect(reverse('podcasts:index'), request)
            else:
                return self.redirect(
                    reverse('podcasts:index') + '?show_itunesu_link=false',
                    request)
        else:
            # TODO Remove hard link to Oxford's iTunes U library
            return self.redirect(
                "http://deimos.apple.com/WebObjects/Core.woa/Browse/ox-ac-uk-public",
                request)

########NEW FILE########
__FILENAME__ = models
from django.db import models

# Create your models here.

########NEW FILE########
__FILENAME__ = molly_sakai
from __future__ import division
from datetime import datetime
from django import template
from django.utils.translation import ugettext as _

register = template.Library()

@register.filter
def from_sakai_timestamp(value):
    return datetime.fromtimestamp(value/1000)

@register.filter    
def places_left(value):
    return (value["maxNoOfAttendees"]-len(value["attendees"]))

@register.filter
def signup_status(ts, event):
    if ts["signedUp"]:
        return 'signed-up'
    elif not places_left(ts):
        if event["allowWaitList"]:
            if ts["onWaitList"]:
                return 'on-waiting-list'
            else:
                return 'waiting-list'
        else:
            return 'full'
    else:
        return 'available'

@register.filter
def signup_status_human(value):
    return {
        'signed-up': _('Signed Up'),
        'on-waiting-list': _('On Waiting List'),
        'waiting-list': _('Waiting List Available'),
        'full': _('Full'),
        'available': _('Available')
    }[value]
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from views import (
    IndexView, SiteView, DirectView,

    SignupIndexView, SignupSiteView, SignupEventView,
    PollIndexView, PollDetailView,
    EvaluationIndexView, EvaluationDetailView,
    AnnouncementView
)

urlpatterns = patterns('',
    (r'^$',
        IndexView, {},
        'index'),

    (r'^signups/$',
        SignupIndexView, {},
        'signup-index'),
    (r'^signups/(?P<site>[^/]+)/$',
        SignupSiteView, {},
        'signup-site'),
    (r'^signups/(?P<site>[^/]+)/(?P<event_id>\d+)/$',
        SignupEventView, {},
        'signup-event'),

    (r'^polls/$',
        PollIndexView, {},
        'poll-index'),
    (r'^polls/(?P<id>\d+)/$',
        PollDetailView, {},
        'poll-detail'),

    (r'^surveys/$',
        EvaluationIndexView, {},
        'evaluation-index'),
    (r'^surveys/(?P<id>\d+)/$',
        EvaluationDetailView, {},
        'evaluation-detail'),

    (r'^announcements/(?P<id>[^/]+)/$',
        AnnouncementView, {},
        'announcement'),

    (r'^sites/$',
        SiteView, {},
        'sites-index'),

    (r'^direct/$',
        DirectView, {},
        'direct-index'),
)

########NEW FILE########
__FILENAME__ = views
import logging
import urllib
import urllib2
import simplejson
import urlparse
import dateutil.parser
import socket
from lxml import etree
from dateutil.tz import tzutc
from StringIO import StringIO
from datetime import datetime, timedelta
from contextlib import contextmanager
from simplejson.decoder import JSONDecodeError

from django.core.urlresolvers import reverse
from django.core.exceptions import PermissionDenied
from django.shortcuts import render_to_response
from django.template import RequestContext
from django.utils.translation import ugettext_lazy as _
from django.http import Http404, HttpResponseBadRequest

from molly.auth.models import UserIdentifier
from molly.auth.oauth.clients import OAuthHTTPError
from molly.utils.views import BaseView
from molly.utils.xslt import transform, add_children_to_context
from molly.utils.breadcrumbs import (NullBreadcrumb, BreadcrumbFactory,
        Breadcrumb, lazy_reverse, lazy_parent)


SAKAI_TIMEOUT = 5
logger = logging.getLogger(__name__)


def parse_iso_8601(s):
    return dateutil.parser.parse(s).replace(tzinfo=tzutc())


@contextmanager
def make_sakai_request(seconds):
    """Set the default timeout to something reasonable.
    This also helps debug problems on the Sakai endpoint.
    """
    original = socket.getdefaulttimeout()
    socket.setdefaulttimeout(seconds)
    try:
        yield
    except:
        logger.info("Error accessing Sakai", exc_info=True)
        raise
    finally:
        socket.setdefaulttimeout(original)


class SakaiView(BaseView):
    breadcrumb = NullBreadcrumb
    abstract = True

    def build_url(self, url):
        return '%s%s' % (self.conf.host, url)

    def get_sakai_resource(self, request, resource_name, format='json', data=None):
        """Consistent API for accessing Sakai resources."""
        url = self.build_url(resource_name)
        logger.debug("Sakai request - %s" % url)
        with make_sakai_request(SAKAI_TIMEOUT):
            resource = request.urlopen(url, data=data)
        if format == 'json':
            resource = simplejson.load(resource)
        elif format == 'xml':
            resource = etree.parse(resource)
        return resource

    def get_site_title(self, request, id):
        if not 'sakai_site_titles' in request.secure_session:
            request.secure_session['sakai_site_titles'] = {}
        json = self.get_sakai_resource(request, 'direct/site.json')
        for site in json['site_collection']:
            request.secure_session['sakai_site_titles'][site['id']] = site['title']
        return request.secure_session['sakai_site_titles'].get(id, 'Unknown site(%s)' % id)

    def add_user_identifiers(self, request):
        user_details = self.get_sakai_resource(request, 'direct/user/current.json')
        for target, identifier in self.conf.identifiers:
            value = user_details
            for i in identifier:
                if not i in (value or ()):
                    break
                value = value[i]
            else:
                UserIdentifier.set(request.user, target, value)


class IndexView(SakaiView):

    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        # TODO Remove 'WebLearn' as the standard name for Sakai
        return Breadcrumb(
            self.conf.local_name,
            None,
            _('WebLearn'),
            lazy_reverse('index'),
        )

    def initial_context(self, request):
        try:
            announcements = self.get_sakai_resource(request, 'direct/announcement/user.json')
        except Http404:
            #  NOTE: we get a 404 from WebLearn when the user has no sites with announcements.
            #  OAuth views re-raises this as a Django Http404.
            announcements = {'announcement_collection': []}
        return {
            'user_details': self.get_sakai_resource(request, 'direct/user/current.json'),
            'announcements': announcements,
            'tools': [{
                'name': tool[0],
                'title': tool[1],
                'url': reverse('sakai:%s-index' % tool[0]),
            } for tool in self.conf.tools],
        }

    def handle_GET(self, request, context):
        if 'force_login' in request.GET:
            if len(context['user_details']['id']) == 0:
                # pretend we got a 401 error, this will force the auth framework
                # to reauthenticate
                raise OAuthHTTPError(urllib2.HTTPError('', 401, '', '', StringIO()))
        return self.render(request, context, 'sakai/index', expires=timedelta(days=-1))


class SignupIndexView(SakaiView):
    force_auth = True

    def initial_context(self, request):
        sites = self.get_sakai_resource(request, 'direct/site.json')
        return {
            'sites': [
                (e['id'], e['entityTitle'])
                for e in sites['site_collection']
            ],
            'complex_shorten': True,
        }

    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('index'),
            _('Sign-ups'),
            lazy_reverse('signup-index'),
        )

    def handle_GET(self, request, context):
        if not 'sakai_site_titles' in request.secure_session:
            request.secure_session['sakai_site_titles'] = {}
        for site_id, title in context['sites']:
            request.secure_session['sakai_site_titles'][site_id] = title
        return self.render(request, context, 'sakai/signup/index', expires=timedelta(days=-1))


class SignupSiteView(SakaiView):
    def initial_context(self, request, site):
        events_et = self.get_sakai_resource(request,
                'direct/signupEvent/site/%s.xml' % site, format='xml')
        events_et = events_et.getroot().findall('signupEvent')
        events = []
        for event_et in events_et:
            event = {
                'start': parse_iso_8601(event_et.find('startTime').attrib['date']),
                'end': parse_iso_8601(event_et.find('endTime').attrib['date']),
                'location': event_et.find('location').text,
                'title': event_et.find('title').text,
                'id': event_et.find('id').text,
                'permission': dict((p.tag, p.text == 'true') for p in event_et.findall('permission/*'))
            }
            if event['end'] >= datetime.utcnow().replace(tzinfo=tzutc()):
                events.append(event)
        return {
            'site': site,
            'events': events,
            'title': self.get_site_title(request, site),
            'complex_shorten': True,
            'now': datetime.utcnow(),
        }

    @BreadcrumbFactory
    def breadcrumb(self, request, context, site):
        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('signup-index'),
            context.get('title', 'Sign-ups'),
            lazy_reverse('signup-site', args=[site]),
        )

    def handle_GET(self, request, context, site):
        return self.render(request, context, 'sakai/signup/list', expires=timedelta(days=-1))


class SignupEventView(SakaiView):
    def initial_context(self, request, site, event_id):
        try:
            # This request does absolutely nothing, except force some cache to be
            # reset, making sure the data we receive subsequently is up-to-date.
            # This should be reported as a bug in Sakai.
            data = urllib.urlencode({
                'siteId': site,
                'allocToTSid': '0',
                'userActionType': 'invalidAction',
                })
            self.get_sakai_resource(request, 'direct/signupEvent/%s/edit' % event_id, data=data, format=None)
            event = self.get_sakai_resource(request, 'direct/signupEvent/%s.json?siteId=%s' % (event_id, site))
        except PermissionDenied, e:
            if isinstance(e, OAuthHTTPError) and e.code != 403:
                raise
            else:
                context = {
                    'permission_denied': True,
                    'text': _('Permission Denied')
                }
                return context
        return {
            'event': event,
            'signedUp': any(e['signedUp'] for e in event['signupTimeSlotItems']),
        }

    @BreadcrumbFactory
    def breadcrumb(self, request, context, site, event_id):
        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('signup-site', site),
            context['event']['title'] if 'event' in context else 'Sign-ups',
            lazy_reverse('signup-detail', args=[site, event_id]),
        )

    def handle_GET(self, request, context, site, event_id):
        if 'permission_denied' in context:
            response = render_to_response('sakai/permission_denied.html',
                                          RequestContext(request, context))
            response.status_code = 403
            return response
        return self.render(request, context, 'sakai/signup/detail', expires=timedelta(days=-1))

    def handle_POST(self, request, context, site, event_id):
        try:
            data = urllib.urlencode({
                'siteId': site,
                'allocToTSid': request.POST['timeslot_id'],
                'userActionType': request.POST['action'],
                })
            self.get_sakai_resource(request, 'direct/signupEvent/%s/edit' % event_id,
                    data=data, format=None)
        except urllib2.HTTPError, e:
            if e.code != 204:
                raise
        return self.redirect(request.path, request, 'seeother')


class SiteView(SakaiView):
    force_auth = True

    def handle_GET(self, request, context):
        sites = self.get_sakai_resource(request, 'direct/site.xml', format='xml')
        context['sites'] = [e.find('entityTitle').text for e in sites.getroot()]
        return self.render(request, context, 'sakai/sites', expires=timedelta(days=-1))


class DirectView(SakaiView):
    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('index'),
            _('User information'),
            lazy_reverse('direct-index'),
        )

    def handle_GET(self, request, context):
        context['user_details'] = self.get_sakai_resource(request,
                'direct/user/current.json')
        return self.render(request, context, 'sakai/direct/index', expires=timedelta(days=-1))


def annotate_poll(poll):
    """
    Annotates a poll object as returned from Sakai with some useful derived information.
    """
    poll['voteOpen'] = datetime.fromtimestamp(poll['voteOpen'] / 1000)
    poll['voteClose'] = datetime.fromtimestamp(poll['voteClose'] / 1000)
    poll.update({
        'multiVote': poll['maxOptions'] > 1,
        'hasOpened': datetime.now() > poll['voteOpen'],
        'hasClosed': datetime.now() > poll['voteClose'],
        'hasVoted': bool(poll['currentUserVotes']),
    })
    poll['isOpen'] = poll['hasOpened'] and not poll['hasClosed']
    poll['mayVote'] = poll['isOpen'] and not poll['hasVoted']


class PollIndexView(SakaiView):
    force_auth = True

    def initial_context(self, request):
        json = self.get_sakai_resource(request, 'direct/poll.json')
        polls = []
        for poll in json['poll_collection']:
            poll['siteTitle'] = self.get_site_title(request, poll['siteId'])
            annotate_poll(poll)
            polls.append(poll)
        polls.sort(key=lambda p: (p['siteTitle'], p['voteClose']))

        return {
            'polls': polls,
            'complex_shorten': True,
        }

    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('index'),
            'Polls',
            lazy_reverse('poll-index'),
        )

    def handle_GET(self, request, context):
        return self.render(request, context, 'sakai/poll/index', expires=timedelta(days=-1))


class PollDetailView(SakaiView):
    def initial_context(self, request, id):
        try:
            poll = self.get_sakai_resource(request, 'direct/poll/%s.json' % id)
            options = self.get_sakai_resource(request, 'direct/poll/%s/option.json' % id)
            options = options['poll-option_collection']
        except (PermissionDenied, JSONDecodeError), e:
            if isinstance(e, OAuthHTTPError) and e.code != 403:
                raise
            else:
                context = {
                    'poll': {
                        'permission_denied': True,
                        'text': _('Permission Denied')
                    }
                }
                return context

        try:
            votes = self.get_sakai_resource(request, 'direct/poll/%s/vote.json' % id)
            votes = votes["poll-vote_collection"]
        except PermissionDenied:
            max_votes, vote_count = None, None
        else:
            pollOptions, max_votes, vote_count = {}, 0, len(votes)
            for option in options:
                option['voteCount'] = 0
                pollOptions[option['optionId']] = option
            for vote in votes:
                pollOptions[vote['pollOption']]['voteCount'] += 1
                max_votes = max(max_votes, pollOptions[vote['pollOption']]['voteCount'])

        # Add votedFor attributes if the user voted for any given option
        userVotes = [vote['pollOption'] for vote in poll['currentUserVotes']]
        for option in options:
            option['votedFor'] = option['optionId'] in userVotes

        annotate_poll(poll)

        return {
            'poll': poll,
            'options': options,
            'site_title': self.get_site_title(request, poll['siteId']),
            'max_votes': max_votes,
            'vote_count': vote_count,
            'sakai_host': self.conf.host,
            'service_name': self.conf.service_name,
        }

    @BreadcrumbFactory
    def breadcrumb(self, request, context, id):
        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('poll-index'),
            context['poll']['text'],
            lazy_reverse('poll-detail'),
        )

    def handle_GET(self, request, context, id):
        if 'permission_denied' in context['poll']:
            response = render_to_response('sakai/permission_denied.html',
                                          RequestContext(request, context))
            response.status_code = 403
            return response
        return self.render(request, context, 'sakai/poll/detail', expires=timedelta(days=-1))

    def handle_POST(self, request, context, id):
        if not context['poll']['mayVote']:
            return self.redirect(request.path, request, 'seeother')
        # Check poll boundaries
        if len(request.POST.getlist('pollOption')) > context['poll']['maxOptions'] or \
           len(request.POST.getlist('pollOption')) < context['poll']['minOptions']:
            context['error'] = 'You must select between %d and %d options' % (context['poll']['minOptions'], context['poll']['maxOptions'])
            return self.handle_GET(request, context, id)
        try:
            data = [('pollId', int(id))]
            for option in request.POST.getlist('pollOption'):
                if not int(option) in (option['optionId'] for option in context['options']):
                    return HttpResponseBadRequest()
                data.append(('pollOption', int(option)))
            self.get_sakai_resource(request,
                'direct/poll-vote/%s' % ('vote.json' if len(request.POST.getlist('pollOption')) > 1 else 'new'),
                data=urllib.urlencode(data),
                )
        except urllib2.HTTPError, e:
            if e.code in (201, 204):
                pass
            else:
                raise

        return self.redirect(request.path, request, 'seeother')


class EvaluationIndexView(SakaiView):
    force_auth = True

    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('index'),
            _('Surveys'),
            lazy_reverse('evaluation-index'),
        )

    def initial_context(self, request):
        summary = self.get_sakai_resource('direct/eval-evaluation/1/summary',
                format='xml', parser=etree.HTMLParser(recover=False))
        summary = transform(summary, 'sakai/evaluation/summary.xslt', {'id': id})
        evaluations = []
        for node in summary.findall('evaluation'):
            if not node.find('title').text is None:
                evaluations.append({
                    'title': node.find('title').text,
                    'site': node.find('site').text,
                    'start': node.find('start').text,
                    'end': node.find('end').text,
                    'status': node.find('status').text,
                    'id': urlparse.parse_qs(urlparse.urlparse(node.find('url').text).query)['evaluationId'][0] if node.find('url') is not None else None,
                })
        return {
            'evaluations': evaluations,
        }

    def handle_GET(self, request, context):
        return self.render(request, context, 'sakai/evaluation/index', expires=timedelta(days=-1))


class EvaluationDetailView(SakaiView):
    def initial_context(self, request, id):
        url = self.build_url('direct/eval-evaluation/%s' % id)
        data = request.raw_post_data if request.method == 'POST' else None
        with make_sakai_request(SAKAI_TIMEOUT):
            response = request.urlopen(url, data)
        evaluation = etree.parse(response, parser=etree.HTMLParser(recover=False))
        evaluation = transform(evaluation, 'sakai/evaluation/detail.xslt', {'id': id})

        # The evaluations tool doesn't give us a non-OK status if we need to authenticate. Instead,
        # we need to check for the login box (handily picked out by the XSL stylesheet).
        if evaluation.find('.//require_auth').text == 'true':
            raise OAuthHTTPError(urllib2.HTTPError(url, 403, _('Authentication required'), {}, StringIO()))

        context = {
            'evaluation': evaluation,
            'id': id,
            'url': url,
            'response_url': response.geturl(),
        }
        add_children_to_context(evaluation, context)
        return context

    @BreadcrumbFactory
    def breadcrumb(self, request, context, id):
        if not 'evaluation' in context:
            context = self.initial_context(request, id)

        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('evaluation-index'),
            context.get('title', 'Survey'),
            lazy_reverse('evaluation-detail', args=[id]),
        )

    def handle_GET(self, request, context, id):
        if context['state'] == 'forbidden':
            raise PermissionDenied(context.get('state_message'))
        elif context['state'] == 'closed':
            context = {
                'state': 'closed',
                'breadcrumbs': context['breadcrumbs'],
                'id': id,
            }
            return self.render(request, context, 'sakai/evaluation/closed', expires=timedelta(days=-1))
        return self.render(request, context, 'sakai/evaluation/detail', expires=timedelta(days=-1))

    def handle_POST(self, request, context, id):
        if context['response_url'].startswith(self.build_url('direct/eval-evaluation/%s/take_eval?' % id)):
            return self.handle_GET(request, context, id)
        context = {
            'suppress_evaluations': True,
            'submitted': True,
        }
        return self.render(request, context, 'sakai/evaluation/index', expires=timedelta(days=-1))


class AnnouncementView(SakaiView):
    """
    Displays the detail of an anouncement
    """

    @BreadcrumbFactory
    def breadcrumb(self, request, context, id):
        if not 'announcement' in context:
            context = self.initial_context(request, id)

        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('index'),
            context['announcement']['title'],
            lazy_reverse('announcement', args=[id]),
        )

    def initial_context(self, request, id):
        announcement = self.get_sakai_resource(request, 'direct/announcement/%s.json' % id)
        return {
            'announcement': announcement
        }

    def handle_GET(self, request, context, id):
        return self.render(request, context, 'sakai/announcement/detail', expires=timedelta(days=-1))

########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.utils.translation import ugettext_lazy as _

from molly.conf import all_apps

# We can't pick up the list of applications when this module is imported, as
# that could lead to a circular import dependency.[0] Instead, wait until a
# SearchForm instance is requested before calling all_apps.
#
# Instead, (the outer) SearchForm creates the desired class when an instance
# is first required and transparently returns the result of calling its
# constructor.
#
# [0] e.g. Another app is being loaded which depends on molly.apps.search.
#     molly.apps.search.forms then tries to call all_apps, which would attempt
#     to load the other app again (and fail).

class SearchForm(object):
    def __new__(self, *args, **kwargs):
        try:
            return self._search_form_class(*args, **kwargs)
        except AttributeError:
            self._search_form_class = self._get_search_form_class()
            return self._search_form_class(*args, **kwargs)

    @classmethod
    def _get_search_form_class(self):
        APPLICATION_CHOICES = (
            ('', _('Show all')),
        ) + tuple((app.local_name, app.title) for app in all_apps() if app.application_name)

        class SearchForm(forms.Form):
            query = forms.CharField(label=_('Search'))
            application = forms.ChoiceField(
                label='Filter',
                widget=forms.HiddenInput(),
                choices=APPLICATION_CHOICES,
                required=False,
            )

        return SearchForm

########NEW FILE########
__FILENAME__ = models
from django.db import models

# Create your models here.

########NEW FILE########
__FILENAME__ = application_search
import logging

from molly.apps.search.providers import BaseSearchProvider

from molly.conf import all_apps

logger = logging.getLogger(__name__)

class ApplicationSearchProvider(BaseSearchProvider):
    def __init__(self, local_names=None):
        self.local_names = local_names
        self.applications = None
        
    def perform_search(self, request, query, application=None):
        if self.applications == None:
            self.find_applications()
        
        if application:
            if not application in self.applications:
                return []
            apps = [self.applications[application]]
        else:
            apps = self.applications.values()

        results = []
        for app in apps:
            try:
                results += app.perform_search(request, query, application != None)
            except Exception, e:
                logger.exception("Application search provider raised exception: %r", e)

        return results
        
    def find_applications(self):
        self.applications = {}
        for application in all_apps():
            
            if self.local_names and not application in self.local_names:
                continue
            try:
                search_module_name = '%s.search' % application.application_name
                _temp = __import__(search_module_name,
                                   globals(), locals(),
                                   ['ApplicationSearch'], -1)
                if not hasattr(_temp, 'ApplicationSearch'):
                    raise ImportError
            except ImportError:
                continue
            else:
                search_provider = _temp.ApplicationSearch(application)

            self.applications[application.local_name] = search_provider
########NEW FILE########
__FILENAME__ = google_search_appliance
import urllib
import urllib2
import logging
import re

import xml.etree
import xml.parsers.expat

from lxml import etree

from django.http import Http404
from django.core.urlresolvers import Resolver404, reverse

from molly.apps.search.providers import BaseSearchProvider

logger = logging.getLogger(__name__)

class GSASearchProvider(BaseSearchProvider):

    SCHEME_HOST_RE = re.compile(r'[a-z\d]+:\/\/[a-z.\-\d]+\/')

    def __init__(self, search_url, domain, params={}, title_clean_re=None):
        self.search_url, self.domain, self.params = search_url, domain, params
        self.title_clean_re = re.compile(title_clean_re) if title_clean_re else None

    def perform_search(self, request, query, application=None):

        if application:
            domain = self.domain + reverse('%s:index' % application)[:-1]
        else:
            domain = self.domain

        query = self._perform_query_expansion(query)
        query = ' '.join(('(%s)' % (' OR '.join(((('"%s"' % t) if ' ' in t else t) for t in terms))) for terms in query[:]))

        params = dict(self.params)
        params.update({
            'q': query.encode('utf-8'),
            'output': 'xml',
            'ie': 'utf8',
            'oe': 'utf8',
            'as_sitesearch': domain,
        })

        try:
            response = urllib2.urlopen('?'.join((self.search_url, urllib.urlencode(params))))
        except urllib2.HTTPError, e:
            logger.exception("Couldn't fetch results from Google Search Appliance")
            return []

        try:
            xml_root = etree.parse(response)
        except xml.parsers.expat.ExpatError, e:
            logger.exception("Couldn't parse results from Google Search Appliance")
            return []

        results = []

        for result in xml_root.findall('.//RES/R'):
            # Retrieve the URL and chop off the scheme and host parts, leaving
            # just the local part.
            url = result.find('U').text
            url = self.SCHEME_HOST_RE.sub('/', url)

            title = result.find('T').text
            try:
                title = self.title_clean_re.match(title).group(1)
            except AttributeError:
                pass

            metadata = {
                'url': url,
                'excerpt': (result.find('S').text or '').replace('<br>', ''),
                'title': title,
            }

            try:
                metadata.update(self.get_metadata(request, url))
            except (Resolver404, Http404):
                continue

            results.append(metadata)

        return results
        
########NEW FILE########
__FILENAME__ = molly_search
from django import template

from molly.apps.search.forms import SearchForm

register = template.Library()

@register.tag
def search_form(parser, token):
    return SearchFormNode(*token.split_contents()[1:])
    
class SearchFormNode(template.Node):
    """
    Adds a SearchForm instance to the context.
    """

    def __init__(self, prefix=None, name="search_form"):
        self.prefix = prefix
        self.name = name
        
    def render(self, context):
        context[self.name] = SearchForm(prefix=self.prefix)
        return ''

########NEW FILE########
__FILENAME__ = tests
import sys
import inspect

from django.utils import unittest
from django.conf import settings
from django.utils.importlib import import_module

from molly.utils.views import BaseView
from molly.utils.breadcrumbs import NullBreadcrumb

class Argspec(tuple):
    args = property(lambda self: self[0])
    varargs = property(lambda self: self[1])
    keywords = property(lambda self: self[2])
    defaults = property(lambda self: self[3])

def getargspec(*args, **kwargs):
    return Argspec(inspect.getargspec(*args, **kwargs))

class GenericSearchTestCase(unittest.TestCase):
    def testViewSignatures(self):
        for app_name in settings.INSTALLED_APPS:
            try:
                views = import_module(app_name+'.views')
            except ImportError:
                continue

            for view_name in dir(views):

                view = getattr(views, view_name)

                if not isinstance(view, type):
                    continue

                if not BaseView in view.__mro__:
                    continue

                metadata_sig = None
                breadcrumb_sig = None
                handler_sigs = []
                initial_context_sig = None

                for func_name in dir(view):
                    func = getattr(view, func_name)
                    
                    
                    if func_name == 'get_metadata':
                        metadata_sig = getargspec(func)
                    elif func_name == 'initial_context':
                        initial_context_sig = getargspec(func)
                    elif func_name.startswith('handle_') and func_name[7:].upper() == func_name[7:]:
                        handler_sigs.append( (func_name, getargspec(func)) )
                    elif func_name == 'breadcrumb':
                        if func is BaseView.breadcrumb:
                            breadcrumb_sig = True
                            continue
                        # If it's not gone through BreadcrumbFactory
                        elif type(func) == type(BaseView.breadcrumb):
                            breadcrumb_sig = getargspec(func)
                        else:
                            breadcrumb_sig = getargspec(func.breadcrumb_func)
                    else:
                        continue

                if not handler_sigs:
                    continue
                    
                if not breadcrumb_sig:
                    self.fail('%s.%s does not define a breadcrumb' % (app_name, view_name))

                # Keep track of the first handler sig to compare things to
                fhn, fhs = handler_sigs[0]
                
                self.assertEqual(
                    fhs.args[:3],
                    ['self','request','context'],
                    "View handler %s.views.%s.%s must take (self, request, context) as its first three arguments" % (
                        app_name, view_name, fhn,
                    )
                )

                for handler_name, argspec in handler_sigs:
                    if handler_name != 'handle_HEAD':
                        self.assertEqual(
                            fhs.args, argspec.args,
                            'View handler signatures differ for %s.views.%s: %s and %s' % (
                                app_name, view_name, fhn, handler_name
                            ),
                        )
                    #self.assertEqual(
                    #    argspec.varargs, None,
                    #    "View handler %s.views.%s.%s takes *%s when it shouldn't" % (
                    #        app_name, view_name, handler_name, argspec.varargs
                    #    ),
                    #)
                    #self.assertEqual(
                    #    argspec.keywords, None,
                    #    "View handler %s.views.%s.%s takes **%s when it shouldn't" % (
                    #        app_name, view_name, handler_name, argspec.keywords
                    #    ),
                    #)

                if not (initial_context_sig.varargs or initial_context_sig.keywords):
                    self.assertEqual(
                        initial_context_sig.args,
                        fhs.args[:2] + fhs.args[3:],
                        "initial_context for %s.views.%s has a signature inconsistent with the handlers" % (
                            app_name, view_name,
                        )
                    )

                if metadata_sig:
                    self.assertEqual(
                        metadata_sig.args,
                        fhs.args[:2] + fhs.args[3:],
                        "get_metadata for %s.views.%s has a signature inconsistent with the handlers" % (
                            app_name, view_name,
                        )
                    )
                    self.assertEqual(
                        metadata_sig.varargs, None,
                        "get_metadata() for %s.views.%s takes *%s when it shouldn't" % (
                            app_name, view_name, metadata_sig.varargs
                        ),
                    )
                    self.assertEqual(
                        metadata_sig.keywords, None,
                        "get_metadata() for %s.views.%s takes **%s when it shouldn't" % (
                            app_name, view_name, metadata_sig.keywords
                        ),
                    )
                
                if breadcrumb_sig != True:
                    if breadcrumb_sig[0][0] != 'self':
                        fhs = (fhs[0][1:], fhs[1], fhs[2], fhs[3])
                        self.assertEqual(
                            breadcrumb_sig, fhs,
                            "breadcrumb signature for %s.%s differs from its view handlers (%s, %s)" % (
                                app_name, view_name, breadcrumb_sig, fhs
                            )
                        )
                    else:
                        self.assertEqual(
                            breadcrumb_sig, fhs,
                            "breadcrumb signature for %s.%s differs from its view handlers (%s, %s)" % (
                                app_name, view_name, breadcrumb_sig, fhs
                            )
                        )
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from views import IndexView

urlpatterns = patterns('',
    (r'^$', IndexView, {}, 'index'),
)

########NEW FILE########
__FILENAME__ = views
from datetime import timedelta

from molly.utils.views import BaseView
from molly.utils.breadcrumbs import *

from forms import SearchForm

class IndexView(BaseView):
    def initial_context(self, request):
        return {
            'search_form': getattr(self.conf, 'form', SearchForm(request.GET or None))
        }

    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            'search', None, 'Search', lazy_reverse('index')
        )

    def handle_GET(self, request, context):
        if context['search_form'].is_valid():
            return self.handle_search(request, context)

        return self.render(request, context, 'search/index',
                           expires=timedelta(minutes=30))

    def handle_search(self, request, context):
        application = context['search_form'].cleaned_data['application'] or None
        query = context['search_form'].cleaned_data['query']

        results = []
        for provider in self.conf.providers:
            results += provider.perform_search(request, query, application)

        seen_urls, i = set(), 0
        while i < len(results):
            url = results[i]['url']
            if url in seen_urls:
                results[i:i+1] = []
            else:
                seen_urls.add(url)
                i += 1

        # Remove results deemed irrelevant
        results = [r for r in results if not r.get('exclude_from_search')]

        if len(results) == 1 and results[0].get('redirect_if_sole_result'):
            return self.redirect(results[0]['url'], request)

        context.update({
            'results': list(results)[:20],
        })

        return self.render(request, context, 'search/index')

########NEW FILE########
__FILENAME__ = models
from django.db import models

# Create your models here.

########NEW FILE########
__FILENAME__ = rss_module
from molly.conf.provider import Provider
from datetime import datetime
import dateutil.parser
import feedparser

class RSSModuleServiceStatusProvider(Provider):
    def __init__(self, name, slug, url):
        self.name, self.slug, self.url = name, slug, url

    def parse_date(self, s):
        try:
            return dateutil.parser.parse(s)
        except (TypeError, ValueError):
            return None

    def safe_parse(self, f, s):
        try:
            return f(s)
        except (TypeError, ValueError):
            return None

    def get_status(self):
        services_feed = feedparser.parse(self.url)
        
        try:
            lastBuildDate = self.parse_date(services_feed.entries[0].get('ss_lastchecked'))
        except IndexError, e:
            try:
                lastBuildDate = self.parse_date(services_feed.headers['last-modified'])
            except Exception, e:
                lastBuildDate = None
            
        
        services = []
        for service in services_feed.entries:
            services.append({
                'source': self.slug,
                'source_name': self.name,
                'name': service.title,

                'responding': {'true':True,'false':False}.get(service.get('ss_responding')),
                'lastChecked': self.parse_date(service.get('ss_lastchecked')),
                'lastSeen': self.parse_date(service.get('ss_lastseen')),
                'availability': self.safe_parse(int, service.get('ss_availability')),
                'averageResponseTime': self.safe_parse(float, service.get('ss_averageresponsetime')),
                'statusMessage': service.get('ss_statusmessage'),
            })
            services[-1]['status'] = {0: 'down', 100: 'up', None: {True: 'up', False: 'down', }.get(services[-1]['responding'], 'unknown')}.get(services[-1]['availability'], 'partial')
            
        return {
            'services': services,
            'lastBuildDate': lastBuildDate,
        }

    def get_announcements(self):
        return []

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from views import IndexView

urlpatterns = patterns('',
   (r'^$', IndexView, {}, 'index'),
)

########NEW FILE########
__FILENAME__ = views
from collections import namedtuple
import logging

from django.utils.translation import ugettext as _

from molly.utils.views import BaseView
from molly.utils.breadcrumbs import *

logger = logging.getLogger(__name__)

Service = namedtuple('Service', ['slug', 'name', 'last_updated',
                                 'services', 'announcements'])

class IndexView(BaseView):
    """
    View to display service status information
    """

    def get_metadata(self, request):
        return {
            'title': _('Service status'),
            'additional': _('Check whether services are available'),
        }

    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb('service_status', None,
                          _('Service Status'),
                          lazy_reverse('index'))

    def handle_GET(self, request, context):
        services = []
        for provider in self.conf.providers:
            try:
                status = provider.get_status()
            except Exception, e:
                logger.warn("Failed to load service status", exc_info=True)
            else:
                services.append(Service(
                    provider.slug, provider.name,
                    status['lastBuildDate'], status['services'],
                    provider.get_announcements(),
                ))

        
        context['services'] = services

        return self.render(request, context, 'service_status/index')

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Tour'
        db.create_table('tours_tour', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
        ))
        db.send_create_signal('tours', ['Tour'])

        # Adding M2M table for field stops on 'Tour'
        db.create_table('tours_tour_stops', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('tour', models.ForeignKey(orm['tours.tour'], null=False)),
            ('entity', models.ForeignKey(orm['places.entity'], null=False))
        ))
        db.create_unique('tours_tour_stops', ['tour_id', 'entity_id'])

        # Adding model 'StopOnTour'
        db.create_table('tours_stopontour', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('tour', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['tours.Tour'])),
            ('entity', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['places.Entity'])),
            ('order', self.gf('django.db.models.fields.IntegerField')()),
        ))
        db.send_create_signal('tours', ['StopOnTour'])


    def backwards(self, orm):
        
        # Deleting model 'Tour'
        db.delete_table('tours_tour')

        # Removing M2M table for field stops on 'Tour'
        db.delete_table('tours_tour_stops')

        # Deleting model 'StopOnTour'
        db.delete_table('tours_stopontour')


    models = {
        'places.entity': {
            'Meta': {'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_stack': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_sublocation': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitytype': {
            'Meta': {'object_name': 'EntityType'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityTypeCategory']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'tours.stopontour': {
            'Meta': {'ordering': "['order']", 'object_name': 'StopOnTour'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'order': ('django.db.models.fields.IntegerField', [], {}),
            'tour': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tours.Tour']"})
        },
        'tours.tour': {
            'Meta': {'object_name': 'Tour'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'stops': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Entity']", 'symmetrical': 'False'})
        }
    }

    complete_apps = ['tours']

########NEW FILE########
__FILENAME__ = 0002_auto__add_field_tour_name
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Tour.name'
        db.add_column('tours_tour', 'name', self.gf('django.db.models.fields.TextField')(default='Unnamed tour'), keep_default=False)

        # Removing M2M table for field stops on 'Tour'
        db.delete_table('tours_tour_stops')


    def backwards(self, orm):
        
        # Deleting field 'Tour.name'
        db.delete_column('tours_tour', 'name')

        # Adding M2M table for field stops on 'Tour'
        db.create_table('tours_tour_stops', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('tour', models.ForeignKey(orm['tours.tour'], null=False)),
            ('entity', models.ForeignKey(orm['places.entity'], null=False))
        ))
        db.create_unique('tours_tour_stops', ['tour_id', 'entity_id'])


    models = {
        'places.entity': {
            'Meta': {'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_stack': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_sublocation': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitytype': {
            'Meta': {'object_name': 'EntityType'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityTypeCategory']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'tours.stopontour': {
            'Meta': {'ordering': "['order']", 'object_name': 'StopOnTour'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'order': ('django.db.models.fields.IntegerField', [], {}),
            'tour': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tours.Tour']"})
        },
        'tours.tour': {
            'Meta': {'object_name': 'Tour'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {}),
            'stops': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Entity']", 'through': "orm['tours.StopOnTour']", 'symmetrical': 'False'})
        }
    }

    complete_apps = ['tours']

########NEW FILE########
__FILENAME__ = 0003_auto__add_field_tour_type
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Tour.type'
        db.add_column('tours_tour', 'type', self.gf('django.db.models.fields.SlugField')(default='legacy', max_length=50, db_index=True), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Tour.type'
        db.delete_column('tours_tour', 'type')


    models = {
        'places.entity': {
            'Meta': {'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_entrance': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitytype': {
            'Meta': {'object_name': 'EntityType'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityTypeCategory']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'tours.stopontour': {
            'Meta': {'ordering': "['order']", 'object_name': 'StopOnTour'},
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'order': ('django.db.models.fields.IntegerField', [], {}),
            'tour': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['tours.Tour']"})
        },
        'tours.tour': {
            'Meta': {'object_name': 'Tour'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {}),
            'stops': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Entity']", 'through': "orm['tours.StopOnTour']", 'symmetrical': 'False'}),
            'type': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'})
        }
    }

    complete_apps = ['tours']

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.core.urlresolvers import reverse

from molly.utils.i18n import languages_to_try

from molly.apps.places.models import Entity

class Tour(models.Model):
    
    name = models.TextField()
    stops = models.ManyToManyField(Entity, through='StopOnTour')
    type = models.SlugField()
    
    def get_absolute_url(self):
        return reverse('tours:tour-start', args=[self.id])
    
    def __unicode__(self):
        return self.name


class StopOnTour(models.Model):
    
    tour = models.ForeignKey(Tour)
    entity = models.ForeignKey(Entity)
    order = models.IntegerField()
    
    class Meta:
        ordering = ['order']
    
    def get_absolute_url(self):
        return reverse('tours:tour', args=[self.tour.id, self.order])
    
    @property
    def description(self):
        
        descriptions = self.entity.metadata.get('tours', {}).get(self.tour.type, {})
        for language in languages_to_try():
            if language in descriptions:
                return descriptions[language]
        return None


########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from views import IndexView, CreateView, SaveView, TourView, PaperView

urlpatterns = patterns('',
    
    (r'^$',
        IndexView, {},
        'index'),
    
    (r'^(?P<slug>[a-z_\-0-9]+)/create/(?P<entities>([a-z_\-]+:[^/]+/)*)?$',
        CreateView, {},
        'create'),
    
    (r'^(?P<slug>[a-z_\-0-9]+)/create/(?P<entities>([a-z_\-]+:[^/]+/)*)save/$',
        SaveView, {},
        'save'),
    
    (r'^(?P<tour>\d+)/$',
        TourView, {},
        'tour-start'),
    
    (r'^(?P<tour>\d+)/print/$',
        PaperView, {},
        'tour-print'),
    
    (r'^(?P<tour>\d+)/(?P<page>\d+)/$',
        TourView, {},
        'tour'),
    
    )

########NEW FILE########
__FILENAME__ = views
from datetime import datetime
from operator import attrgetter

from django.core.urlresolvers import reverse
from django.contrib.gis.geos import Point
from django.contrib.gis.measure import D
from django.db import connection
from django.db.models import Q
from django.utils.translation import ugettext_lazy as _
from django.shortcuts import get_object_or_404
from django.http import Http404

from molly.apps.places import get_entity
from molly.apps.places.models import Entity, EntityType, StopOnRoute
from molly.maps import Map
from molly.utils.breadcrumbs import *
from molly.utils.views import BaseView
from molly.wurfl import device_parents
from molly.routing import generate_route, optimise_points
from molly.apps.tours.models import Tour, StopOnTour
from molly.url_shortener import get_shortened_url


class IndexView(BaseView):
    
    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name,
            None,
            _('Tours'),
            lazy_reverse('index'),
        )
    
    def initial_context(self, request):
        context = super(IndexView, self).initial_context(request)
        
        context['types'] = [(slug, vs['name']) for slug, vs in self.conf.types.items()]
        
        if 'tours:visited' in request.session:
            context.update({
                'tours': Tour.objects.filter(id__in=request.session['tours:visited'])
            })
        
        return context
    
    def handle_GET(self, request, context):
        return self.render(request, context, 'tours/index')


class CreateView(BaseView):
    
    @BreadcrumbFactory
    def breadcrumb(self, request, context, slug, entities):
        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('index'),
            _('Create a tour'),
            lazy_reverse('create'),
        )
    
    def initial_context(self, request, slug, entities):
        context = super(CreateView, self).initial_context(request)
        
        try:
            tour_type = self.conf.types[slug]
        except KeyError:
            raise Http404()
        else:
            tour_type['slug'] = slug
        
        context.update({
            'tour_type': tour_type,
            'entities': [],
            'attractions': dict(
                (et, sorted(et.entities_completion.filter(location__isnull=False),
                            key=attrgetter('title')))
                    for et in EntityType.objects.filter(
                        slug__in=tour_type['attraction_types'])),
            'all_pois': sorted(Entity.objects.filter(
                all_types_completion__slug__in=tour_type['attraction_types']),
                key=attrgetter('title'))
        })
        
        for entity in entities.split('/'):
            try:
                scheme, value = entity.split(':')
            except ValueError:
                continue
            context['entities'].append(get_entity(scheme, value))
        
        return context
    
    def handle_GET(self, request, context, slug, entities):
        
        if 'generic_web_browser' in device_parents[request.browser.devid]:
            # Desktop
            return self.render(request, context, 'tours/create_desktop')
        else:
            return self.render(request, context, 'tours/create')


class SaveView(CreateView):
    
    def handle_GET(self, request, context, slug, entities):
        
        if len(context['entities']) < 2:
            # Need at least 2 entities to be a tour
            return self.bad_request(request)
        
        # Now attempt to order entities optimally
        if len(context['entities']) > 2 and len(context['entities']) <= 10:
            context['entities'] = optimise_points(
                [(entity, entity.routing_point().location)
                    for entity in context['entities']])
            context['optimised_entities'] = True
        
        # Come up with a name for this tour
        name = _('%(type)s; visiting %(number)d places (created on %(creation)s)') % {
                    'type': _(context['tour_type']['name']),
                    'number': len(context['entities']),
                    'creation': datetime.now().strftime('%c')
                }
        
        # Save back to database
        tour = Tour.objects.create(name=name, type=context['tour_type']['slug'])
        for i, entity in enumerate(context['entities']):
            StopOnTour.objects.create(entity=entity, tour=tour, order=i)
        
        # Add any suggested "passing-by" entities to the context to be presented
        # back to the user. We can only do this query if the database backend
        # supports distance operations on geographies (i.e., things more complex
        # than points)
        if 'suggested_entities' in context['tour_type'] \
        and connection.ops.geography and request.GET.get('nosuggestions') is None:
            route = generate_route([e.location for e in context['entities']], 'foot')
            suggestion_filter = Q()
            for sv in context['tour_type']['suggested_entities']:
                scheme, value = sv.split(':')
                suggestion_filter |= Q(_identifiers__scheme=scheme,
                                       _identifiers__value=value)
            context['suggestions'] = Entity.objects.filter(
                suggestion_filter,
                location__distance_lt=(route['path'],
                        D(m=getattr(self.conf, 'suggestion_distance', 100)))
                ).exclude(id__in=[e.pk for e in context['entities']])
        
        context.update({
            'tour': tour,
            'short_url': get_shortened_url(tour.get_absolute_url(), request),
        })
        
        if 'generic_web_browser' in device_parents[request.browser.devid]:
            # Desktop
            return self.render(request, context, 'tours/save_desktop')
        else:
            # Redirect if no suggestions, otherwise show suggestions page
            if len(context.get('suggestions', [])) > 0:
                return self.render(request, context, 'tours/save')
            else:
                return self.redirect(
                    context['tour'].get_absolute_url() + '?created', request)


class TourView(BaseView):
    
    @BreadcrumbFactory
    def breadcrumb(self, request, context, tour, page=None):
        
        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('index'),
            context['stop'].entity.title if page else context['tour'].name,
            lazy_reverse('tour', args=(context['tour'].pk, page)),
        )
    
    def arrival_route_location(self, first_stop, arrival_route):
        """
        Given a route which the user is entering the city by, then suggest the
        best place to get off the route, and directions from that point to the
        first stop
        """
        
        closest_stop = Entity.objects.filter(
                    stoponroute__route__service_id=arrival_route,
                ).distance(first_stop.location).order_by('distance')
        if closest_stop.count() > 0:
            closest_stop = closest_stop[0]
            start_location = closest_stop
        else:
            start_location = None
        return start_location
    
    def arrival_point_location(self, first_stop, arrival_point):
        """
        Given an arrival point (which may be a park and ride, in which case
        directions using public transport are given), figure out directions to
        the first location
        """
        
        sv, p_and_r, routes = self.conf.arrival_points[int(arrival_point)]
        entity = get_entity(*sv.split(':'))
        if p_and_r:
            
            # Get closest bus stop to first stop on route
            closest_stops = Entity.objects.filter(
                    stoponroute__route__service_id__in=routes,
                ).distance(first_stop.location).order_by('distance')
            
            # Now, check that this stop comes *after* where we get on
            closest_stop = None
            
            # Go through all of our stops until we find the closest
            # one which matches our criteria
            for stop in closest_stops:
                
                # Now, check for each route that goes through this
                # stop that are the ones we're considering
                for route in stop.route_set.filter(service_id__in=routes):
                    
                    stoponroute = StopOnRoute.objects.get(entity=stop,
                                                          route=route)
                    
                    # Get the closest stop to the origin that serves
                    # this route
                    closest_origin = Entity.objects.filter(
                            stoponroute__route=route,
                        ).distance(entity.location).order_by('distance')[0]
                    origin_stop = StopOnRoute.objects.get(route=route,
                                                          entity=closest_origin)
                    
                    if stoponroute.order > origin_stop.order:
                        # now check that this stop comes after our
                        # first stop...
                        closest_stop = stop
                        break
                    
                if closest_stop:
                    break
            
            p_and_r_context = {
                'start': entity,
                'routes': set(routes) & set(sor.route.service_id for sor in closest_stop.stoponroute_set.all()),
                'origin_stop': origin_stop,
                'closest_stop': closest_stop
            }
            start_location = closest_stop
        else:
            # Directions from that point to first stop
            start_location, p_and_r_context = entity, {}
        return start_location, p_and_r_context
    
    def initial_context(self, request, tour, page=None):
        
        context = super(TourView, self).initial_context(request)
        tour = get_object_or_404(Tour, id=tour)
        context.update({
            'tour': tour,
            'stops': StopOnTour.objects.filter(tour=tour)
        })
        
        if page is not None:
            stop = get_object_or_404(StopOnTour, tour=tour, order=page)
            context['stop'] = stop
            
            try:
                context['next_stop'] = StopOnTour.objects.get(tour=tour, order=int(page)+1)
            except StopOnTour.DoesNotExist:
                pass
            
            try:
                context['previous_stop'] = StopOnTour.objects.get(tour=tour, order=int(page)-1)
            except StopOnTour.DoesNotExist:
                pass
        
        else:
            
            try:
                arrival_point = int(request.GET.get('arrival_point'))
            except (ValueError, TypeError):
                arrival_point = None
            arrival_route = request.GET.get('arrival_route')
            
            if arrival_point is not None or arrival_route:
                
                first_stop = tour.stops.all()[0]
                
                if arrival_point is not None:
                
                    start_location, p_and_r_context = self.arrival_point_location(first_stop, arrival_point)
                    context['p_and_r'] = p_and_r_context
                
                elif arrival_route is not None:
                
                    start_location = self.arrival_route_location(first_stop, arrival_route)
                    context['arrival_route'] = arrival_route
                
                if start_location is not None:
                    context['first_directions'] = generate_route(
                        [start_location.location, first_stop.location], 'foot')
                    if 'error' not in context['first_directions']:
                        context['directions_start'] = start_location
                        context['directions_end'] = first_stop
                        context['directions_map'] = Map(
                            (start_location.location[0], start_location.location[1], 'green', ''),
                            [(w['location'][0], w['location'][1], 'red', w['instruction'])
                                for w in context['first_directions']['waypoints']],
                            len(context['first_directions']['waypoints']),
                            None,
                            request.map_width,
                            request.map_height,
                            extra_points=[(first_stop.location[0],
                                           first_stop.location[1],
                                           'red', first_stop.title)],
                            paths=[(context['first_directions']['path'], '#3c3c3c')])
            
            else:
            
                arrival_points = []
                for i, arrival_point in enumerate(getattr(self.conf, 'arrival_points', [])):
                    arrival_points.append((i, get_entity(*arrival_point[0].split(':'))))
                context.update({
                    'arrival_points': arrival_points,
                    'arrival_routes': getattr(self.conf, 'arrival_routes', []),
                    'created': 'created' in request.GET
                })
            
        return context
    
    def handle_GET(self, request, context, tour, page=None):
        
        if 'tours:visited' in request.session:
            request.session['tours:visited'].add(context['tour'].id)
        else:
            request.session['tours:visited'] = set((context['tour'].id,))
        request.session.save()
        
        user_location = request.session.get('geolocation:location')
        if user_location is None and 'previous_stop' in context:
            user_location = context['previous_stop'].entity.routing_point(context['stop'].entity.location).location
        else:
            user_location = Point(user_location)
        
        if 'stop' in context and \
          context['stop'].entity.routing_point(user_location).location is not None and \
          user_location is not None:
            
            entrance = context['stop'].entity.routing_point(user_location)
            
            context['route'] = generate_route(
                [user_location, entrance.location], 'foot')
            
            context['route_map'] = Map(
                (user_location[0], user_location[1], 'green', ''),
                [(w['location'][0], w['location'][1], 'red', w['instruction'])
                    for w in context['route']['waypoints']],
                len(context['route']['waypoints']),
                None,
                request.map_width,
                request.map_height,
                extra_points=[(entrance.location[0],
                               entrance.location[1],
                               'red', entrance.title)],
                paths=[(context['route']['path'], '#3c3c3c')])
        
        return self.render(request, context, 'tours/tour')


class PaperView(TourView):
    
    def handle_GET(self, request, context, tour):
        # Map QuerySet to list
        context['stops'] = list(context['stops'])
        for i, stop in enumerate(context['stops'][1:], start=1):
            stop.directions_to = generate_route([
                context['stops'][i-1].entity.routing_point(stop.entity.location).location,
                stop.entity.routing_point(context['stops'][i-1].entity.location).location],
                'foot')
        return self.render(request, context, 'tours/paper')


########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = tfl
import urllib
from xml.dom import minidom
from django.utils.translation import ugettext as _

from molly.apps.transport.providers import BaseTransitLineStatusProvider

class TubeStatusProvider(BaseTransitLineStatusProvider):
    
    LINESTATUS_URL = 'http://cloud.tfl.gov.uk/TrackerNet/LineStatus'
    
    def get_status(self):
        
        statuses = []
        
        status_xml = minidom.parse(urllib.urlopen(self.LINESTATUS_URL))
        
        for node in status_xml.documentElement.childNodes:
            if node.nodeType == node.ELEMENT_NODE and node.tagName == 'LineStatus':
                line_status = {
                    'disruption_reason': node.getAttribute('StatusDetails'),
                }
                for child in node.childNodes:
                    if child.nodeType == child.ELEMENT_NODE and child.tagName == 'Line':
                        line_status['line_id'] = 'tube-%s' % child.getAttribute('ID')
                        line_status['line_name'] = child.getAttribute('Name')
                    elif child.nodeType == child.ELEMENT_NODE and child.tagName == 'Status':
                        line_status['status'] = child.getAttribute('Description')
                statuses.append(line_status)
        
        return {
                'service_name': _('London Underground'),
                'line_statuses': statuses,
            }
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from views import (IndexView, RailView, TravelNewsView, ParkAndRideView,
                   PublicTransportView, RoutesView)

urlpatterns = patterns('',
   (r'^$', IndexView, {}, 'index'),
   (r'^rail/$', RailView, {}, 'rail'),
   (r'^travel-news/$', TravelNewsView, {}, 'travel-news'),
   (r'^park-and-ride/$', ParkAndRideView, {}, 'park-and-ride'),
   (r'^(?P<key>[^/]+)/$', PublicTransportView, {}, 'public-transport'),
   (r'^(?P<key>[^/]+)/routes/$', RoutesView, {}, 'routes'),
)

########NEW FILE########
__FILENAME__ = views
import re
from operator import itemgetter

from django.contrib.gis.geos import Point
from django.utils.translation import ugettext as _
from django.core.urlresolvers import reverse
from django.http import Http404
from django.template.defaultfilters import capfirst

from molly.conf import app_by_application_name

from molly.utils.views import BaseView
from molly.utils.breadcrumbs import *
from molly.favourites import get_favourites

from molly.apps.places import get_entity, bus_route_sorter
from molly.apps.places.models import Entity, EntityType, Route

class TransportView(BaseView):
    
    def record_page(self, request, page):
        request.session['transport:last'] = page
        request.session.save()
    
    def augment_metadata(self, entities, **kwargs):
        # Get any real-time information for all the places we're about to display
        places_conf = app_by_application_name('molly.apps.places')
        for provider in reversed(places_conf.providers):
            provider.augment_metadata(entities, **kwargs)
    
    def initial_context(self, request):
        
        context = super(TransportView, self).initial_context(request)
        
        # Get our location for location sorting
        location = request.session.get('geolocation:location')
        if location:
            location = Point(location, srid=4326)
        
        context['location'] = location
        
        # Determine what's enabled so we can show it in base.html
        context['train_station'] = hasattr(self.conf, 'train_station')
        context['travel_alerts'] = getattr(self.conf, 'travel_alerts', False)
        context['park_and_rides'] = hasattr(self.conf, 'park_and_rides')
        context['public_transport'] = dict((key, True)
                                    for key in getattr(self.conf, 'nearby', {}))
        
        return context


class IndexView(BaseView):
    
    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name,
            None,
            _('Transport'),
            lazy_reverse('%s:index' % self.conf.local_name),
        )
    
    def handle_GET(self, request, context):
        last_part = request.session.get('transport:last',
                                        getattr(self.conf, 'default_page', 'bus'))
        if last_part in ('rail', 'park-and-ride', 'travel-news'):
            redirect_to = reverse('transport:%s' % last_part)
        else:
            redirect_to = reverse('transport:public-transport', args=[last_part])
        return self.redirect(redirect_to, request)


class RailView(TransportView):
    
    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name,
            None,
            _('Rail departures') if context['board'] == 'departures' else _('Rail arrivals'),
            lazy_reverse('%s:rail' % self.conf.local_name),
        )
    
    def initial_context(self, request):
        
        context = super(RailView, self).initial_context(request)
        
        if context['train_station']:
            if getattr(self.conf, 'train_station_nearest', False) \
              and context['location']:
                et = EntityType.objects.get(slug='rail-station')
                entity = et.entities_completion.filter(location__isnull=False)
                entity = entity.distance(context['location']).order_by('distance')[0]
            else:
                scheme, value = self.conf.train_station.split(':')
                entity = get_entity(scheme, value)
                
            context['entity'] = entity
        else:
            raise Http404()
            
        places_conf = app_by_application_name('molly.apps.places')
        attributions = [provider._ATTRIBUTION for provider in places_conf.providers
                      if hasattr(provider, '_ATTRIBUTION')]
        context['attributions'] = attributions

        context['board'] = request.GET.get('board', 'departures')

        self.augment_metadata([entity], board=context['board'])
        
        return context
    
    def handle_GET(self, request, context):
        self.record_page(request, 'rail')
        return self.render(request, context, 'transport/rail')


class TravelNewsView(TransportView):
    
    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name,
            None,
            _('Travel alerts'),
            lazy_reverse('%s:travel-news' % self.conf.local_name),
        )
    
    def initial_context(self, request):
        
        context = super(TravelNewsView, self).initial_context(request)
            
        if context['travel_alerts']:
            es = Entity.objects.filter(primary_type__slug='travel-alert')
            if context['location']:
                es = es.filter(location__isnull=False).distance(location).order_by('distance')
            else:
                es = es.order_by('title')
            context['travel_alerts'] = es
        else:
            raise Http404()
        
        return context
    
    def handle_GET(self, request, context):
        self.record_page(request, 'travel-news')
        return self.render(request, context, 'transport/travel_news')


class ParkAndRideView(TransportView):
    
    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name,
            None,
            _('Park and Ride'),
            lazy_reverse('%s:park-and-ride' % self.conf.local_name),
        )
    
    def initial_context(self, request):
        
        context = super(ParkAndRideView, self).initial_context(request)
        
        # If park and ride variable is set, then include those too:
        if context['park_and_rides']:
            park_and_rides = []
            for park_and_ride in self.conf.park_and_rides:
                scheme, value = park_and_ride.split(':')
                entity = get_entity(scheme, value)
                park_and_rides.append(entity)
            context['park_and_rides'] = park_and_rides
        else:
            raise Http404()

        self.augment_metadata(park_and_rides)
        return context
    
    def handle_GET(self, request, context):
        self.record_page(request, 'park-and-ride')
        return self.render(request, context, 'transport/park_and_ride')


class PublicTransportView(TransportView):
    
    @BreadcrumbFactory
    def breadcrumb(self, request, context, key):
        type_slug, count = self.conf.nearby[key]
        et = EntityType.objects.get(slug=type_slug)
        return Breadcrumb(
            self.conf.local_name,
            None,
            capfirst(et.verbose_name_plural),
            lazy_reverse('%s:public-transport' % self.conf.local_name,
                         kwargs={'key': key}),
        )
    
    def initial_context(self, request, key):
        
        context = super(PublicTransportView, self).initial_context(request)
        
        location = context['location']
        selected_routes = request.GET.getlist('route')
        
        if key not in getattr(self.conf, 'nearby', {}):
            raise Http404()
        
        # If service status provider is set, then include those too:
        if hasattr(self.conf, '%s_status_provider' % key):
            provider = getattr(self.conf, '%s_status_provider' % key)
            context['line_status'] = provider.get_status()
        
        type_slug, count = self.conf.nearby[key]
        et = EntityType.objects.get(slug=type_slug)
        
        favourites = filter(
            lambda e: e is not None and et in e.all_types_completion.all(),
            [f.metadata.get('entity') for f in get_favourites(request)])
        
        if selected_routes:
            
            if location:
                es = et.entities_completion.filter(
                    location__isnull=False, route__service_id__in=selected_routes)
                es = es.distinct().distance(location).order_by('distance')[:count]
            else:
                es = []
        
        else:
            
            if location:
                es = et.entities_completion.filter(location__isnull=False)
                es = es.distance(location).order_by('distance')[:count]
            else:
                es = []
        
        for e in (e for e in es if hasattr(e, 'distance')):
            distance, e.bearing = e.get_distance_and_bearing_from(location)
        
        self.augment_metadata(es, routes=selected_routes)
        
        for e in (e for e in favourites if hasattr(e, 'distance')):
            distance, e.bearing = e.get_distance_and_bearing_from(location)
        self.augment_metadata(favourites)
        
        context.update({
            'pageslug': key,
            'type': et,
            'entities': es,
            'favourites': favourites
        })
        
        # Only show routes which serve this type of thing
        routes = Route.objects.filter(stoponroute__entity__all_types_completion=et).distinct()
        route_ids = routes.values_list('service_id').distinct()
        
        context['route_ids'] = sorted(map(itemgetter(0), route_ids), key=bus_route_sorter)
        context['selected_routes'] = selected_routes
        
        return context
    
    def handle_GET(self, request, context, key):
        return self.render(request, context, 'transport/public_transport')


class RoutesView(TransportView):
    
    @BreadcrumbFactory
    def breadcrumb(self, request, context, key):
        return Breadcrumb(
            self.conf.local_name,
            lazy_parent('transport:public-transport', key=key),
            _('Routes'),
            lazy_reverse('%s:route' % self.conf.local_name),
        )
    
    def initial_context(self, request, key):
        
        context = super(RoutesView, self).initial_context(request)
        
        type_slug, count = self.conf.nearby[key]
        et = EntityType.objects.get(slug=type_slug)
        
        if key not in getattr(self.conf, 'nearby', {}):
            raise Http404()
        
        location = context['location']
        
        # Only show routes which serve this type of thing
        routes = Route.objects.filter(stoponroute__entity__all_types_completion=et).distinct()
        
        if location:
            routes = list(routes)
            for route in routes:
                route.nearest = Entity.objects.filter(route=route).distance(location).order_by('distance')[0]
                route.nearest_distance, route.nearest_bearing = route.nearest.get_distance_and_bearing_from(location)
        
        context['routes'] = sorted(routes, key=lambda x: bus_route_sorter(x.service_id))
        
        return context
    
    def handle_GET(self, request, context, key):
        return self.render(request, context, 'transport/routes')
    

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from molly.apps.weather.models import Weather

class WeatherAdmin(admin.ModelAdmin):
    list_display = [
        'observed_date', 'temperature', 'min_temperature', 'max_temperature',
        'sunset', 'sunrise', 'wind_speed', 'wind_direction', 'humidity',
        'pressure'
    ]
    list_filter = ['ptype']
    
admin.site.register(Weather, WeatherAdmin)

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Weather'
        db.create_table('weather_weather', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('location_id', self.gf('django.db.models.fields.CharField')(max_length=16)),
            ('ptype', self.gf('django.db.models.fields.CharField')(max_length=1)),
            ('name', self.gf('django.db.models.fields.TextField')(null=True)),
            ('outlook', self.gf('django.db.models.fields.CharField')(max_length=3, null=True)),
            ('published_date', self.gf('django.db.models.fields.DateTimeField')(null=True)),
            ('observed_date', self.gf('django.db.models.fields.DateTimeField')(null=True)),
            ('modified_date', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('temperature', self.gf('django.db.models.fields.IntegerField')(null=True)),
            ('wind_direction', self.gf('django.db.models.fields.CharField')(max_length=3, null=True)),
            ('wind_speed', self.gf('django.db.models.fields.IntegerField')(null=True)),
            ('humidity', self.gf('django.db.models.fields.IntegerField')(null=True)),
            ('pressure', self.gf('django.db.models.fields.PositiveIntegerField')(null=True)),
            ('pressure_state', self.gf('django.db.models.fields.CharField')(max_length=1, null=True)),
            ('visibility', self.gf('django.db.models.fields.CharField')(max_length=2, null=True)),
            ('location', self.gf('django.contrib.gis.db.models.fields.PointField')(null=True)),
            ('min_temperature', self.gf('django.db.models.fields.IntegerField')(null=True)),
            ('max_temperature', self.gf('django.db.models.fields.IntegerField')(null=True)),
            ('uv_risk', self.gf('django.db.models.fields.CharField')(max_length=1, null=True)),
            ('pollution', self.gf('django.db.models.fields.CharField')(max_length=1, null=True)),
            ('sunset', self.gf('django.db.models.fields.TimeField')(null=True)),
            ('sunrise', self.gf('django.db.models.fields.TimeField')(null=True)),
        ))
        db.send_create_signal('weather', ['Weather'])


    def backwards(self, orm):
        
        # Deleting model 'Weather'
        db.delete_table('weather_weather')


    models = {
        'weather.weather': {
            'Meta': {'object_name': 'Weather'},
            'humidity': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'location_id': ('django.db.models.fields.CharField', [], {'max_length': '16'}),
            'max_temperature': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'min_temperature': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'modified_date': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'observed_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True'}),
            'outlook': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True'}),
            'pollution': ('django.db.models.fields.CharField', [], {'max_length': '1', 'null': 'True'}),
            'pressure': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True'}),
            'pressure_state': ('django.db.models.fields.CharField', [], {'max_length': '1', 'null': 'True'}),
            'ptype': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            'published_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True'}),
            'sunrise': ('django.db.models.fields.TimeField', [], {'null': 'True'}),
            'sunset': ('django.db.models.fields.TimeField', [], {'null': 'True'}),
            'temperature': ('django.db.models.fields.IntegerField', [], {'null': 'True'}),
            'uv_risk': ('django.db.models.fields.CharField', [], {'max_length': '1', 'null': 'True'}),
            'visibility': ('django.db.models.fields.CharField', [], {'max_length': '2', 'null': 'True'}),
            'wind_direction': ('django.db.models.fields.CharField', [], {'max_length': '3', 'null': 'True'}),
            'wind_speed': ('django.db.models.fields.IntegerField', [], {'null': 'True'})
        }
    }

    complete_apps = ['weather']

########NEW FILE########
__FILENAME__ = models
from datetime import datetime, time

from django.contrib.gis.db import models
from django.utils.translation import ugettext_lazy as _

PTYPE_OBSERVATION = 'o'
PTYPE_FORECAST = 'f'
PTYPE_CHOICES = (
    (PTYPE_OBSERVATION, _('observation')),
    (PTYPE_FORECAST, _('forecast')),
)

PRESSURE_STATE_CHOICES = (
    # Translators: Weather pressure states
    ('+', _('rising')),
    ('-', _('falling')),
    ('~', _('steady')),
    ('c', _('no change')),
)

VISIBILITY_CHOICES = (
    ('vp', _('very poor visibility')),
    ('p',  _('poor visibility ')),
    ('vg', _('very good visibility')),
    ('g', _('good visibility')),
    ('df', _('dense fog')),
    ('f', _('fog')),
    ('e', _('excellent visibility')),
    ('m', _('moderate visibility')),
)

OUTLOOK_CHOICES = (
    ('si', _('sunny intervals')),
    ('gc', _('grey cloud')),
    ('hr', _('heavy rain')),
    ('s', _('sunny')),
    ('lr', _('light rain')),
    ('pc', _('partly cloudy')),
    ('f', _('fog')),
    ('wc', _('white cloud')),
    ('tst', _('thunder storm')),
    ('m', _('mist')),
    ('tsh', _('thundery shower')),
    ('lrs', _('light rain shower')),
    ('cs', _('clear sky')),
    ('d', _('drizzle')),
    ('h', _('hail')),
    ('lsn', _('light snow')),
    ('sn', _('snow')),
    ('hsn', _('heavy snow')),
    ('unk', _('n/a')),
)

OUTLOOK_TO_ICON = {
    'si':  'cloudy2',
    'gc':  'overcast',
    'hr':  'shower3',
    's':   'sunny',
    'lr':  'light_rain',
    'pc':  'cloudy3%(night)s',
    'f':   'fog%(night)s',
    'wc':  'cloudy5',
    'tst': 'tstorm1',
    'm':   'mist%(night)s',
    'tsh': 'tstorm3',
    'lrs': 'shower2%(night)s',
    'cs':  'sunny%(night)s',
    'd':   'shower1%(night)s',
    'h':   'hail',
    'lsn': 'snow1%(night)s',
    'sn':  'snow3%(night)s',
    'hsn': 'snow5',
    'unk': 'dunno',
}

SCALE_CHOICES = (
    ('l', _('low')),
    ('m', _('medium')),
    ('h', _('high')),
)

class Weather(models.Model):
    location_id = models.CharField(max_length=16)

    ptype = models.CharField(max_length=1, choices=PTYPE_CHOICES)

    name = models.TextField(null=True)

    outlook = models.CharField(null=True, max_length=3, choices=OUTLOOK_CHOICES)

    published_date = models.DateTimeField(null=True)
    observed_date = models.DateTimeField(null=True)
    modified_date = models.DateTimeField(auto_now=True)

    temperature = models.IntegerField(null=True)
    wind_direction = models.CharField(null=True, max_length=3)
    wind_speed = models.IntegerField(null=True)
    humidity = models.IntegerField(null=True)
    pressure = models.PositiveIntegerField(null=True)
    pressure_state = models.CharField(null=True, max_length=1,
                                      choices=PRESSURE_STATE_CHOICES)
    visibility = models.CharField(null=True, max_length=2,
                                  choices=VISIBILITY_CHOICES)

    location = models.PointField(srid=4326, null=True)

    min_temperature = models.IntegerField(null=True)
    max_temperature = models.IntegerField(null=True)
    uv_risk = models.CharField(max_length=1, choices=SCALE_CHOICES, null=True)
    pollution = models.CharField(max_length=1, choices=SCALE_CHOICES, null=True)
    sunset = models.TimeField(null=True)
    sunrise = models.TimeField(null=True)
    
    @property
    def icon(self):
        now = datetime.now().time()
        if now < time(7) or now > time(21):
            night = '_night'
        else:
            night = ''
        return OUTLOOK_TO_ICON.get(self.outlook, 'dunno') % {'night':night}


########NEW FILE########
__FILENAME__ = bbc
from datetime import datetime, tzinfo, timedelta
import email
import logging
import random
import re
import socket
import traceback
import urllib
from xml.etree import ElementTree as ET

from dateutil.tz import tzoffset
from django.contrib.gis.geos import Point
from django.utils.translation import ugettext_lazy as _

from molly.conf.provider import Provider, task
from molly.apps.weather.models import (
    Weather, OUTLOOK_CHOICES, VISIBILITY_CHOICES, PRESSURE_STATE_CHOICES,
    SCALE_CHOICES, PTYPE_OBSERVATION, PTYPE_FORECAST
)

logger = logging.getLogger(__name__)

class BBCWeatherProvider(Provider):
    """
    Scrapes BBC RSS feeds to obtain weather information
    """

    ATTRIBUTION = {
        'title': _('BBC Weather'),
        'url': _('http://bbc.co.uk/weather/')
    }

    FRESHNESS = timedelta(hours=3)

    def __init__(self, location_id):
        self.location_id = location_id
        self.id = 'bbc/%d' % location_id

    def fetch_observation(self):
        return Weather.objects.get(location_id=self.id,
                                   ptype=PTYPE_OBSERVATION)

    def fetch_forecasts(self):
        return Weather.objects.filter(
                location_id=self.id, ptype=PTYPE_FORECAST,
                observed_date__gte=datetime.now().date()
            ).order_by('observed_date')

    @staticmethod
    def _rfc_2822_datetime(value):
        time_tz = email.utils.parsedate_tz(value)
        tz = tzoffset(time_tz[9], time_tz[9])

        return datetime(*(time_tz[:6] + (0, tz)))

    @staticmethod
    def _find_choice_match(choices, verbose):
        matches = [a for a,b in choices if (verbose or '').lower() == b]
        if len(matches) == 1:
            return matches[0]
        else:
            return None

    _OBSERVATIONS_URL = \
        'http://newsrss.bbc.co.uk/weather/forecast/%d/ObservationsRSS.xml'
    _OBSERVATIONS_RE = re.compile(
          r'Temperature: (?P<temperature>-?\d+|N\/A).+'
        + r'Wind Direction: '
        + r'(?P<wind_direction>[NESW]{0,2}|N\/A)'
        + r', Wind Speed: (?P<wind_speed>\d+|N\/A).+'
        + r'Relative Humidity: (?P<humidity>\d+|N\/A).+'
        + r'Pressure: (?P<pressure>\d+|N\/A).+'
        + r' (?P<pressure_state>rising|falling|steady|no change|N\/A), '
        + r'Visibility: (?P<visibility>[A-Za-z\/ ]+)')

    _OBSERVATIONS_TITLE_RE = re.compile(
        r'(?P<day>[A-Za-z]+) at (?P<time>\d\d:\d\d).+' +
        r'\n(?P<outlook>[A-Za-z\/ ]+)\.'
    )

    _FORECAST_URL = \
        'http://newsrss.bbc.co.uk/weather/forecast/%d/Next3DaysRSS.xml'
    _FORECAST_RE = re.compile(
        r'Max Temp:\s*(?P<max_temperature>-?\d+|N\/A).+'
        + r'Min Temp:\s*(?P<min_temperature>-?\d+|N\/A)'
        + r'.+Wind Direction:\s*(?P<wind_direction>[NESW]{0,3}|N\/A),\s*'
        + r'Wind Speed:\s*(?P<wind_speed>\d+|N\/A).+'
        + r'Visibility:\s*(?P<visibility>[A-Za-z\/ ]+),\s*'
        + r'Pressure:\s*(?P<pressure>\d+|N\/A).+'
        + r'Humidity:\s*(?P<humidity>\d+|N\/A).+'
        + r'(UV risk:\s*(?P<uv_risk>[A-Za-z]+|N\/A),)?\s*'
        + r'Pollution:\s*(?P<pollution>[A-Za-z]+|N\/A),\s*'
        + r'Sunrise:\s*(?P<sunrise>\d\d:\d\d).+,\s*'
        + r'Sunset:\s*(?P<sunset>\d\d:\d\d).+'
    )

    _FORECAST_TITLE_RE = re.compile(
        r'(?P<day>[A-Za-z]+): (?P<outlook>[A-Za-z\/ ]+),'
    )

    _CHANNEL_TITLE_RE = re.compile(
        r'BBC - Weather Centre - '
        + r'(Latest Observations|Forecast) for (?P<name>.+)'
    )

    @task(run_every=timedelta(minutes=15))
    def import_data(self, **metadata):
        """
        Pulls weather data from the BBC
        """
        socket.setdefaulttimeout(5)
        try:
            observations = self.get_observations_data()
            forecasts = self.get_forecast_data()
        except Exception as e:
            logger.exception("Error importing weather data from BBC")
            return metadata

        # We only keep the most recent observation. This avoids the DB growing
        # without limit. We also may not have a right to store this data.
        weathers = [(
            Weather.objects.get_or_create(
                location_id=self.id, ptype=PTYPE_OBSERVATION)[0],
            observations
        )]

        for observation_date, forecast in forecasts['forecasts'].items():
            weathers.append( (
                Weather.objects.get_or_create(
                    location_id=self.id, ptype=PTYPE_FORECAST,
                    observed_date=observation_date)[0],
                forecast
            ) )

        VERBATIM = [
            'temperature', 'wind_speed', 'humidity', 'pressure',
            'wind_direction', 'sunset', 'sunrise', 'observed_date',
            'published_date', 'name', 'min_temperature', 'max_temperature',
        ]
        LOOKUP = [
            ('outlook', OUTLOOK_CHOICES),
            ('visibility', VISIBILITY_CHOICES),
            ('pressure_state', PRESSURE_STATE_CHOICES),
            ('uv_risk', SCALE_CHOICES),
            ('pollution', SCALE_CHOICES),
        ]

        for weather, data in weathers:
            for feature in VERBATIM:
                if feature in data:
                    setattr(weather, feature, data[feature])

            for feature, values in LOOKUP:
                if feature in data:
                    setattr(weather, feature,
                            self._find_choice_match(values, data[feature]))

            weather.location = Point(data['location'], srid=4326)
            weather.save()

        return metadata

    def get_observations_data(self):
        xml = ET.parse(urllib.urlopen(
            self._OBSERVATIONS_URL % self.location_id))

        description = xml.find('.//item/description').text
        title = xml.find('.//item/title').text
        channel_title = xml.find('.//channel/title').text

        # Extract the data from the RSS item using regular expressions.
        data = self._OBSERVATIONS_TITLE_RE.match(title).groupdict()
        data.update(self._OBSERVATIONS_RE.match(description).groupdict())

        data.update(self._CHANNEL_TITLE_RE.match(channel_title).groupdict())

        # Normalise integer fields with None for unknown values
        for k in ['temperature','wind_speed','humidity','pressure']:
            try:
                data[k] = int(data[k])
            except ValueError:
                data[k] = None
        for k in data:
            if data[k] in ['','N/A']:
                data[k] = None

        # Calculate datetimes for observed and published dates
        published_date = xml.find('.//item/pubDate').text
        observed_date = published_date
        observed_date = observed_date[:17] + data['time'] + observed_date[22:]
        observed_date = self._rfc_2822_datetime(observed_date)
        # If the time is greater than the current time of day, it must have been
        # at least yesterday that this weather was observed
        if published_date[17:22] < data['time']:
            observed_date -= timedelta(1)
        # Keep going back in time until we find the right day
        while observed_date.strftime('%A') != data['day']:
            observed_date -= timedelta(1)
        published_date = self._rfc_2822_datetime(published_date)

        data['published_date'] = published_date
        data['observed_date'] = observed_date

        data['location'] = (
            float(xml.find(
                './/{http://www.w3.org/2003/01/geo/wgs84_pos#}lat').text),
            float(xml.find(
                './/{http://www.w3.org/2003/01/geo/wgs84_pos#}long').text),
        )

        return data

    def get_forecast_data(self):
        xml = ET.parse(urllib.urlopen(self._FORECAST_URL % self.location_id))

        channel_title = xml.find('.//channel/title').text
        data = self._CHANNEL_TITLE_RE.match(channel_title).groupdict()
        data['forecasts'] = {}
        data['modified_date'] = self._rfc_2822_datetime(
            xml.find('.//pubDate').text)

        for item in xml.findall('.//item'):
            desc = self._FORECAST_RE.match(
                item.find('description').text).groupdict()
            title = self._FORECAST_TITLE_RE.match(
                item.find('title').text).groupdict()

            published_date = item.find('pubDate').text
            dt = self._rfc_2822_datetime(published_date)
            while dt.strftime('%A') != title['day']:
                dt += timedelta(1)

            forecast = data['forecasts'][dt.date()] = {}
            forecast['observed_date'] = dt.date()

            forecast.update(desc)
            forecast.update(title)

            forecast['sunset'] = self._rfc_2822_datetime(
                published_date[:17] + forecast['sunset']
                + ':00' + published_date[25:]
            ).time()
            forecast['sunrise'] = self._rfc_2822_datetime(
                published_date[:17] + forecast['sunrise']
                + ':00' + published_date[25:]
            ).time()

            forecast['location'] = (
                float(xml.find(
                    './/{http://www.w3.org/2003/01/geo/wgs84_pos#}lat').text),
                float(xml.find(
                    './/{http://www.w3.org/2003/01/geo/wgs84_pos#}long').text),
            )

        return data

########NEW FILE########
__FILENAME__ = metoffice
import logging
from urllib2 import urlopen
from lxml import etree
from datetime import datetime, timedelta, date, time
import socket
socket.setdefaulttimeout(5)

from django.conf import settings
from django.utils.translation import ugettext_lazy as _

from molly.conf.provider import Provider, task
from molly.apps.weather.models import (
    Weather, PTYPE_OBSERVATION, PTYPE_FORECAST)

logger = logging.getLogger(__name__)


METOFFICE_OUTLOOK_CHOICES = (
    ('NA', 'unk'),
    (0, 'cs'),
    (1, 's'),
    (2, 'pc'),     # night
    (3, 'si'),
    (4, 'unk'),    # DUST ??
    (5, 'm'),
    (6, 'f'),
    (7, 'gc'),     # Medium-level cloud
    (8, 'gc'),     # Low-level cloud
    (9, 'lrs'),    # night
    (10, 'lrs'),
    (11, 'd'),
    (12, 'lr'),
    (13, 'hr'),   # Heavy rain shower (night)??
    (14, 'hr'),   # Heavy rain shower (day)??
    (15, 'hr'),
    (16, 'hr'),   # Sleet shower (night)??
    (17, 'hr'),   # Sleet shower (day)??
    (18, 'hr'),   # Sleet??
    (19, 'h'),   # Hail shower (night)
    (20, 'h'),   # Hail shower (day)
    (21, 'h'),   # Hail
    (22, 'lsn'),   # Light snow shower (night)
    (23, 'lsn'),   # Light snow shower (day)
    (24, 'lsn'),   # Light snow
    (25, 'hsn'),   # Heavy snow shower (night)
    (26, 'hsn'),   # Heavy snow shower (day)
    (27, 'hsn'),   # Heavy snow
    (28, 'tsh'),   # Thundery shower (night)
    (29, 'tsh'),   # Thundery shower (day)
    (30, 'tst'),   # Thunder storm
    (31, 'tst'),   # Tropical storm
    (32, 'unk'),   # NOT USED?
    (33, 'h'),   # Haze
    )

BASE_METOFFICE_URL = "http://datapoint.metoffice.gov.uk/public/data/val"


class MetOfficeProvider(Provider):
    """
    Scrapes MetOffice DataPoint / observations API
    Documentation is available at: http://www.metoffice.gov.uk/public/ddc/datasets-documentation.html#DailyForecast
    TODO: this class should be splitted in two (observations and forecasts).
    """

    ATTRIBUTION = {
        'title': _('MetOffice'),
        'url': _('http://www.metoffice.gov.uk/')
    }

    FRESHNESS = timedelta(hours=3)

    def __init__(self, forecasts_location_id, observations_location_id):
        self.forecasts_location_id = forecasts_location_id
        self.observations_location_id = observations_location_id

    def fetch_observation(self):
        return Weather.objects.get(location_id=self.observations_location_id,
            ptype=PTYPE_OBSERVATION)

    def fetch_forecasts(self):
        return Weather.objects.filter(
            location_id=self.forecasts_location_id, ptype=PTYPE_FORECAST,
            observed_date__gte=datetime.now().date()
        ).order_by('observed_date')

    @task(run_every=timedelta(minutes=15), default_retry_delay=2, max_retries=3)
    def import_forecasts(self, **metadata):
        api = ApiWrapper()
        forecasts, location = api.get_daily_forecasts_by_location(self.forecasts_location_id)
        for fc in forecasts:
            f = forecasts[fc]
            forecast, created = Weather.objects.get_or_create(
                    location_id=self.forecasts_location_id,
                    observed_date=fc,
                    ptype=PTYPE_FORECAST)
            forecast.name = location['name']
            forecast.min_temperature = float(f['Night']['Nm'])
            forecast.max_temperature = float(f['Day']['Dm'])
            outlooks = dict(METOFFICE_OUTLOOK_CHOICES)
            forecast.outlook = outlooks[int(f['Day']['W'])]
            forecast.observed_date = datetime.combine(fc, time(hour=0))
            forecast.save()

    @task(run_every=timedelta(minutes=15), default_retry_delay=2, max_retries=3)
    def import_observation(self, **metadata):
        api = ApiWrapper()
        observations, location = api.get_observations_by_location(self.observations_location_id)
        latest_day = sorted(observations)[-1]
        latest_hour = sorted(observations[latest_day], key=lambda x: int(x))[-1]
        latest = observations[latest_day][latest_hour]
        observation, created = Weather.objects.get_or_create(
            location_id=self.observations_location_id,
            ptype=PTYPE_OBSERVATION)
        observation.name = location['name']
        observation.temperature = float(latest['T'])
        observation.wind_speed = int(latest['S'])
        observation.wind_direction = latest['D']
        observation.pressure = int(latest['P'])
        observation.observed_date = datetime.combine(latest_day,
                time(int(latest_hour)/60))
        outlooks = dict(METOFFICE_OUTLOOK_CHOICES)
        observation.outlook = outlooks[int(latest['W'])]
        #observation.humidity = not available
        #observation.pressure_state = not available
        observation.save()

    @task(run_every=timedelta(hours=1))
    def delete_old_forecasts(self, **metadata):
        delete_until = datetime.now() - timedelta(days=2)
        logger.debug('Deleting old weather objects until %s' % delete_until)
        Weather.objects.filter(observed_date__lte=delete_until).delete()

class ApiWrapper(object):
    """
    Scrape the XML API
    """

    FORECAST_FRAGMENT_URL = '/wxfcs/all/xml'

    OBSERVATIONS_FRAGMENT_URL = '/wxobs/all/xml'

    def get_daily_forecasts_by_location(self, location_id):
        url = '{0}{1}/{2}?res=daily&key={3}'.format(BASE_METOFFICE_URL,
                self.FORECAST_FRAGMENT_URL, location_id, settings.API_KEYS['metoffice'])
        logger.debug('MetOffice: %s' % url)
        content = urlopen(url).read()
        return self.scrape_xml(content)

    def get_observations_by_location(self, location_id):
        url = '{0}{1}/{2}?res=hourly&key={3}'.format(
            BASE_METOFFICE_URL,
            self.OBSERVATIONS_FRAGMENT_URL,
            location_id,
            settings.API_KEYS['metoffice']
        )
        logger.debug('MetOffice: %s' % url)
        content = urlopen(url).read()
        return self.scrape_xml(content)

    def scrape_xml(self, content):
        """
        Scrape XML from MetOffice DataPoint API.
        Can be used to parse Forecasts/Daily, Forecasts/3hourly, Observations
        Returns a list of representations, information about the location
        """
        xml = etree.fromstring(content)
        location = xml.find('.//Location')
        l = {}
        for k in location.attrib:
            l[k] = location.attrib[k]
        periods = xml.findall('.//Period')
        p = {}
        for period in periods:
            date_val = period.get('value')
            date_parsed = date(year=int(date_val[0:4]),
                month=int(date_val[5:7]), day=int(date_val[8:10]))
            p[date_parsed] = {}
            reps = period.findall('.//Rep')
            for rep in reps:
                # rep.txt represents the number of minutes since midnight
                p[date_parsed][rep.text] = {}
                # set of attributes depends on type forecasts vs. observations,
                # but also if it's a forecast for the day or night (e.g. min temperature is
                # only available for a night forecast...
                for k in rep.attrib:
                    p[date_parsed][rep.text][k] = rep.attrib[k]
        return p, l

########NEW FILE########
__FILENAME__ = test_metoffice
import unittest2
import mock
from datetime import date, time

from molly.apps.weather.providers.metoffice import ApiWrapper


class MetOfficeObservationsProviderTest(unittest2.TestCase):
    """
    Tests for MetOffice/Observations provider
    """

    def test_scrape_xml_daily_forecasts(self):
        with open('molly/apps/weather/tests/data/metoffice_forecast_daily.xml') as f:
            content = f.read()
            f.close()

        provider = ApiWrapper()
        result, location = provider.scrape_xml(content)

        self.assertEqual(location['name'], 'OXFORD')

        # 5 periods
        self.assertEqual(len(result), 5)
        first = result[date(year=2012, month=6, day=8)]
        self.assertIsNotNone(first)
        # 2 reps
        self.assertEqual(len(first), 2)
        self.assertEqual(first['Day']['U'], '2')

########NEW FILE########
__FILENAME__ = views
from datetime import datetime, timedelta
from django.utils.translation import ugettext as _

from molly.conf.urls import url
from molly.utils.views import BaseView
from molly.utils.breadcrumbs import *

from molly.apps.weather.models import Weather

@url(r'^$', 'index')
class IndexView(BaseView):
    """
    Displays current weather observations and forecasts for the next 3 days
    """
    
    def _is_fresh(self, observation, freshness):
        return datetime.now() - freshness < observation.observed_date
    
    def initial_context(self, request):
        try:
            observation = self.conf.provider.fetch_observation()
        except Weather.DoesNotExist:
            observation = None

        return {
            'observation': observation,
            'attribution': self.conf.provider.ATTRIBUTION,
            'fresh': self._is_fresh(observation, self.conf.provider.FRESHNESS),
            'forecasts': self.conf.provider.fetch_forecasts(),
            }

    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            'weather',
            None,
            _('Weather'),
            lazy_reverse('index'),
        )

    def handle_GET(self, request, context):
        return self.render(request, context, 'weather/index',
                           expires=timedelta(minutes=10))

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from models import Webcam, WebcamName

class WebcamNameInline(admin.TabularInline):
    model = WebcamName
    fk_name = "webcam"


class WebcamAdmin(admin.ModelAdmin):
    list_display = ('title', 'description', 'credit',)
    inlines = [
        WebcamNameInline,
    ]


admin.site.register(Webcam, WebcamAdmin)
########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Webcam'
        db.create_table('webcams_webcam', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=50, db_index=True)),
            ('url', self.gf('django.db.models.fields.URLField')(max_length=200)),
            ('fetch_period', self.gf('django.db.models.fields.PositiveIntegerField')()),
            ('title', self.gf('django.db.models.fields.TextField')()),
            ('description', self.gf('django.db.models.fields.TextField')(null=True)),
            ('credit', self.gf('django.db.models.fields.TextField')(null=True)),
        ))
        db.send_create_signal('webcams', ['Webcam'])


    def backwards(self, orm):
        
        # Deleting model 'Webcam'
        db.delete_table('webcams_webcam')


    models = {
        'webcams.webcam': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Webcam'},
            'credit': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'fetch_period': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'})
        }
    }

    complete_apps = ['webcams']

########NEW FILE########
__FILENAME__ = 0002_auto__add_webcamname
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'WebcamName'
        db.create_table('webcams_webcamname', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('webcam', self.gf('django.db.models.fields.related.ForeignKey')(related_name='names', to=orm['webcams.Webcam'])),
            ('language_code', self.gf('django.db.models.fields.CharField')(max_length=10)),
            ('title', self.gf('django.db.models.fields.TextField')()),
            ('description', self.gf('django.db.models.fields.TextField')()),
            ('credit', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('webcams', ['WebcamName'])


    def backwards(self, orm):
        
        # Deleting model 'WebcamName'
        db.delete_table('webcams_webcamname')


    models = {
        'webcams.webcam': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Webcam'},
            'credit': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'fetch_period': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'})
        },
        'webcams.webcamname': {
            'Meta': {'object_name': 'WebcamName'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'credit': ('django.db.models.fields.TextField', [], {}),
            'webcam': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['webcams.Webcam']"})
        }
    }

    complete_apps = ['webcams']

########NEW FILE########
__FILENAME__ = 0003_i18n_webcam_names
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models
from django.conf import settings
from molly.utils.i18n import name_in_language

class Migration(DataMigration):

    def forwards(self, orm):
        """
        Move webcam names to i18n object
        """
        for webcam in orm.Webcam.objects.all():
            webcam.names.create(language_code=settings.LANGUAGE_CODE,
                                title=webcam.title,
                                credit=webcam.credit,
                                description=webcam.description)


    def backwards(self, orm):
        """
        Move i18n names to webcam object
        """
        for webcam in orm.Webcam.objects.all():
            webcam.title = name_in_language(webcam, 'title')
            webcam.description = name_in_language(webcam, 'description')
            webcam.credit = name_in_language(webcam, 'credit')

    models = {
        'webcams.webcam': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Webcam'},
            'credit': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'fetch_period': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'})
        },
        'webcams.webcamname': {
            'Meta': {'object_name': 'WebcamName'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'credit': ('django.db.models.fields.TextField', [], {}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'webcam': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['webcams.Webcam']"})
        }
    }

    complete_apps = ['webcams']

########NEW FILE########
__FILENAME__ = 0004_auto__del_field_webcam_title
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting field 'Webcam.title'
        db.delete_column('webcams_webcam', 'title')
        db.delete_column('webcams_webcam', 'credit')
        db.delete_column('webcams_webcam', 'description')


    def backwards(self, orm):
        
        # Adding field 'Webcam.title'
        db.add_column('webcams_webcam', 'title', self.gf('django.db.models.fields.TextField')(default=''), keep_default=False)
        db.add_column('webcams_webcam', 'credit', self.gf('django.db.models.fields.TextField')(default=''), keep_default=False)
        db.add_column('webcams_webcam', 'description', self.gf('django.db.models.fields.TextField')(default=''), keep_default=False)


    models = {
        'webcams.webcam': {
            'Meta': {'object_name': 'Webcam'},
            'fetch_period': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'})
        },
        'webcams.webcamname': {
            'Meta': {'object_name': 'WebcamName'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language_code': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'title': ('django.db.models.fields.TextField', [], {}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'credit': ('django.db.models.fields.TextField', [], {}),
            'webcam': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'names'", 'to': "orm['webcams.Webcam']"})
        }
    }

    complete_apps = ['webcams']

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.conf import settings
from django.utils.translation import ugettext_lazy as _
from molly.utils.i18n import name_in_language

WEBCAM_WIDTHS = (100, 300, 200)

class Webcam(models.Model):
    
    slug = models.SlugField()
    
    url = models.URLField()
    """
    Represents the original URL of the image for this webcam, except in the case
    of the ``webcam`` view, where url is set to the resized version of the
    image.
    """
    
    fetch_period = models.PositiveIntegerField(help_text=_('in seconds'))
    
    @property
    def title(self):
        """
        The title for this webcam in the current language
        """
        return name_in_language(self, 'title')
    
    @property
    def description(self):
        """
        The description for this webcam in the current language
        """
        return name_in_language(self, 'description')
    
    @property
    def credit(self):
        """
        The credit for this webcam in the current language
        """
        return name_in_language(self, 'credit')


class WebcamName(models.Model):
    webcam = models.ForeignKey(Webcam, related_name='names')
    language_code = models.CharField(max_length=10, choices=settings.LANGUAGES)
    title = models.TextField()
    description = models.TextField()
    credit = models.TextField()

########NEW FILE########
__FILENAME__ = views
from datetime import timedelta
from xml.sax.saxutils import escape

from django.shortcuts import get_object_or_404
from django.http import Http404
from django.utils.translation import ugettext as _

from molly.conf.urls import url
from molly.utils.breadcrumbs import *
from molly.utils.views import BaseView
from molly.favourites.views import FavouritableView
from molly.external_media import resize_external_image

from molly.apps.webcams.models import Webcam, WEBCAM_WIDTHS

import datetime

@url(r'^$', 'index')
class IndexView(BaseView):
    def get_metadata(self, request):
        return {
            'title': _('Webcams'),
            'additional': _('View webcams from around the city and University'),
        }
        
    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(self.conf.local_name, None, _('Webcams'), lazy_reverse('index'))
        
    def handle_GET(self, request, context):
        webcams = Webcam.objects.all()
        context['webcams'] = webcams
        return self.render(request, context, 'webcams/index',
                           expires=timedelta(days=7))


@url(r'^(?P<slug>[a-zA-Z0-9\-]+)/$', 'webcam')
class WebcamDetailView(FavouritableView):
    def get_metadata(self, request, slug):
        webcam = get_object_or_404(Webcam, slug=slug)
        return {
            'title': webcam.title,
            'additional': _('<strong>Webcam</strong>, %(description)s') % { 'description' : escape(webcam.description)}
        }
        
    def initial_context(self, request, slug):
        context = super(WebcamDetailView, self).initial_context(request)
        context.update({'webcam': get_object_or_404(Webcam, slug=slug)})
        return context

    @BreadcrumbFactory
    def breadcrumb(self, request, context, slug):
        return Breadcrumb(self.conf.local_name, lazy_parent('index'),
                          _('Webcam'), lazy_reverse('webcams', args=[slug]))
        
    def handle_GET(self, request, context, slug):
        try:
            eis = resize_external_image(
                context['webcam'].url,
                request.map_width, timeout=5)
        except:
            eis = None
        
        context['eis'] = eis
        return self.render(request, context, 'webcams/webcam_detail')

########NEW FILE########
__FILENAME__ = forms
from django import forms

from django.forms.models import BaseModelFormSet, modelformset_factory
from django.utils.translation import ugettext_lazy as _

from .models import ExternalServiceToken, UserSession

# This is required as Django <= 1.2 checks whether a fields parameter has been
# passed to modelformset_factory by taking the truth value of fields, instead
# of testing that it isn't None. See http://code.djangoproject.com/ticket/14119
# for more information. When Molly moves to support Django 1.3 this can be
# removed, and a normal empty tuple passed in its place.
class TrueEmptyTuple(tuple):
    def __init__(self):
        super(TrueEmptyTuple, self).__init__(())
    def __nonzero__(self):
        return True

class PreferencesForm(forms.Form):
    old_pin = forms.RegexField(r'[0-9a-zA-Z]{4,}',
        label=_('Old PIN'),
        required=False,
        widget=forms.PasswordInput())
    new_pin_a = forms.RegexField(r'[0-9a-zA-Z]{4,}',
        label=_('New PIN'),
        required=False,
        widget=forms.PasswordInput())
    new_pin_b = forms.RegexField(r'[0-9a-zA-Z]{4,}',
        label=_('Repeat PIN'),
        required=False,
        widget=forms.PasswordInput())

    timeout_period = forms.IntegerField(
        min_value=5,
        max_value=720)

def UserSessionFormSet(request, *args, **kwargs):
    formset = modelformset_factory(UserSession, fields=TrueEmptyTuple(), extra=0, can_delete=True)
    return formset(
        queryset=UserSession.objects.filter(user=request.user).order_by('-last_used'),
        prefix="user-sessions",
        *args, **kwargs
    )

def ExternalServiceTokenFormSet(request, *args, **kwargs):
    formset = modelformset_factory(ExternalServiceToken, fields=TrueEmptyTuple(), extra=0, can_delete=True)
    return formset(
        queryset=ExternalServiceToken.objects.filter(user=request.user, authorized=True),
        prefix="external-service-tokens",
        *args, **kwargs
    )

########NEW FILE########
__FILENAME__ = middleware
import time, random

from django.conf import settings
from django.utils.cache import patch_vary_headers
from django.utils.http import cookie_date
from django.utils.importlib import import_module
from django.http import HttpResponsePermanentRedirect, HttpResponseForbidden
from django.contrib.auth.models import User

from .views import SecureView
from .models import UserSession
from molly.utils.views import BaseView
from molly.utils.i18n import javascript_catalog

class SecureSessionMiddleware(object):
    def process_request(self, request):
        if request.is_secure() or settings.DEBUG_SECURE:
            engine = import_module(settings.SESSION_ENGINE)
            secure_session_key = request.COOKIES.get('secure_session_id', None)
            request.secure_session = engine.SessionStore(secure_session_key)
            
            # If this is a new session, mark it as being secure so we can
            # refuse requests where session keys have been swapped about.
            if secure_session_key is None:
                request.secure_session['is_secure'] = True

            secure_session_key = request.secure_session.session_key

            try:
                if request.user.is_authenticated():
                    user = request.user
                else:
                    user_session = UserSession.objects.get(secure_session_key=secure_session_key)
                    user_session.save()
                    user = user_session.user
            except UserSession.DoesNotExist:
                if request.user.is_authenticated():
                    user = request.user
                else:
                    username = ''.join(('%x' % random.randint(0, 15)) for i in range(16))
                    user = User.objects.create(
                        username = username,
                        password = '!',
                    )
                user_session = UserSession.objects.create(
                    user = user,
                    secure_session_key = secure_session_key,
                    device_name = ' '.join((request.device.brand_name, request.device.model_name)),
                )
            request.user = user
        else:
            request.secure_session = None

    def process_view(self, request, view_func, view_args, view_kwargs):
        if settings.DEBUG_SECURE:
            return
        secure_request = request.is_secure()
        secure_view = isinstance(view_func, SecureView)
        # If the non-secure session is marked secure, refuse the request.
        # Likewise, if the secure session isn't marked secure, refuse the
        # request and delete the cookie.
        if request.session.get('is_secure'):
            return HttpResponseForbidden('Invalid session_id', mimetype='text/plain')
        if request.secure_session and not request.secure_session.get('is_secure'):
            resp = HttpResponseForbidden('Invalid secure_session_id', mimetype='text/plain')
            resp.delete_cookie('secure_session_id')
            return resp
        # The js catalog is used for translation on the client side
        # this can be served off either https or http
        if view_func == javascript_catalog:
            return
        if secure_view and not secure_request:
            uri = request.build_absolute_uri().split(':', 1)
            uri = 'https:' + uri[1]
            return view_func.redirect(uri, request, 'secure')
        if not secure_view and secure_request:
            uri = request.build_absolute_uri().split(':', 1)
            uri = 'http:' + uri[1]
            if uri == 'http://%s/' % request.META.get('HTTP_HOST', ''):
                uri += '?preview=true'
            if isinstance(view_func, BaseView):
                return view_func.redirect(uri, request, 'secure')
            else:
                return HttpResponsePermanentRedirect(uri)

    def process_response(self, request, response):
        """
        If request.secure_session was modified, or if the configuration is to
        save the session every time, save the changes and set a session cookie.
        """
        
        if not (request.is_secure() or settings.DEBUG_SECURE):
            return response
            
        try:
            accessed = request.secure_session.accessed
            modified = request.secure_session.modified
        except AttributeError:
            pass
        else:
            if accessed:
                patch_vary_headers(response, ('Cookie',))
            if modified or settings.SESSION_SAVE_EVERY_REQUEST:
                if request.session.get_expire_at_browser_close():
                    max_age = None
                    expires = None
                else:
                    max_age = request.secure_session.get_expiry_age()
                    expires_time = time.time() + max_age
                    expires = cookie_date(expires_time)
                # Save the session data and refresh the client cookie.
                request.secure_session.save()
                response.set_cookie('secure_session_id',
                        request.secure_session.session_key, max_age=max_age,
                        expires=expires, domain=settings.SESSION_COOKIE_DOMAIN,
                        path=settings.SESSION_COOKIE_PATH,
                        secure=not settings.DEBUG_SECURE)
        return response

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Permission'
        db.create_table('auth_permission', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=50)),
            ('content_type', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['contenttypes.ContentType'])),
            ('codename', self.gf('django.db.models.fields.CharField')(max_length=100)),
        ))
        db.send_create_signal('auth', ['Permission'])

        # Adding unique constraint on 'Permission', fields ['content_type', 'codename']
        db.create_unique('auth_permission', ['content_type_id', 'codename'])

        # Adding model 'Group'
        db.create_table('auth_group', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(unique=True, max_length=80)),
        ))
        db.send_create_signal('auth', ['Group'])

        # Adding M2M table for field permissions on 'Group'
        db.create_table('auth_group_permissions', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('group', models.ForeignKey(orm['auth.group'], null=False)),
            ('permission', models.ForeignKey(orm['auth.permission'], null=False))
        ))
        db.create_unique('auth_group_permissions', ['group_id', 'permission_id'])

        # Adding model 'User'
        db.create_table('auth_user', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('username', self.gf('django.db.models.fields.CharField')(unique=True, max_length=30)),
            ('first_name', self.gf('django.db.models.fields.CharField')(max_length=30, blank=True)),
            ('last_name', self.gf('django.db.models.fields.CharField')(max_length=30, blank=True)),
            ('email', self.gf('django.db.models.fields.EmailField')(max_length=75, blank=True)),
            ('password', self.gf('django.db.models.fields.CharField')(max_length=128)),
            ('is_staff', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('is_active', self.gf('django.db.models.fields.BooleanField')(default=True)),
            ('is_superuser', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('last_login', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime.now)),
            ('date_joined', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime.now)),
        ))
        db.send_create_signal('auth', ['User'])

        # Adding M2M table for field groups on 'User'
        db.create_table('auth_user_groups', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('user', models.ForeignKey(orm['auth.user'], null=False)),
            ('group', models.ForeignKey(orm['auth.group'], null=False))
        ))
        db.create_unique('auth_user_groups', ['user_id', 'group_id'])

        # Adding M2M table for field user_permissions on 'User'
        db.create_table('auth_user_user_permissions', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('user', models.ForeignKey(orm['auth.user'], null=False)),
            ('permission', models.ForeignKey(orm['auth.permission'], null=False))
        ))
        db.create_unique('auth_user_user_permissions', ['user_id', 'permission_id'])

        # Adding model 'Message'
        db.create_table('auth_message', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(related_name='_message_set', to=orm['auth.User'])),
            ('message', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('auth', ['Message'])

        # Adding model 'UserIdentifier'
        db.create_table('auth_useridentifier', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('namespace', self.gf('django.db.models.fields.CharField')(max_length=32)),
            ('value', self.gf('django.db.models.fields.CharField')(max_length=128)),
            ('updated', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
        ))
        db.send_create_signal('auth', ['UserIdentifier'])

        # Adding model 'UserSession'
        db.create_table('auth_usersession', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('secure_session_key', self.gf('django.db.models.fields.CharField')(max_length=40)),
            ('device_name', self.gf('django.db.models.fields.TextField')()),
            ('last_used', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
        ))
        db.send_create_signal('auth', ['UserSession'])

        # Adding model 'ExternalServiceToken'
        db.create_table('auth_externalservicetoken', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('namespace', self.gf('django.db.models.fields.CharField')(max_length=32)),
            ('authorized', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('value', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('auth', ['ExternalServiceToken'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Permission', fields ['content_type', 'codename']
        db.delete_unique('auth_permission', ['content_type_id', 'codename'])

        # Deleting model 'Permission'
        db.delete_table('auth_permission')

        # Deleting model 'Group'
        db.delete_table('auth_group')

        # Removing M2M table for field permissions on 'Group'
        db.delete_table('auth_group_permissions')

        # Deleting model 'User'
        db.delete_table('auth_user')

        # Removing M2M table for field groups on 'User'
        db.delete_table('auth_user_groups')

        # Removing M2M table for field user_permissions on 'User'
        db.delete_table('auth_user_user_permissions')

        # Deleting model 'Message'
        db.delete_table('auth_message')

        # Deleting model 'UserIdentifier'
        db.delete_table('auth_useridentifier')

        # Deleting model 'UserSession'
        db.delete_table('auth_usersession')

        # Deleting model 'ExternalServiceToken'
        db.delete_table('auth_externalservicetoken')


    models = {
        'auth.externalservicetoken': {
            'Meta': {'object_name': 'ExternalServiceToken'},
            'authorized': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'namespace': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'value': ('django.db.models.fields.TextField', [], {})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.message': {
            'Meta': {'object_name': 'Message'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message': ('django.db.models.fields.TextField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_message_set'", 'to': "orm['auth.User']"})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'auth.useridentifier': {
            'Meta': {'object_name': 'UserIdentifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'namespace': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'auth.usersession': {
            'Meta': {'ordering': "('user', 'device_name', 'secure_session_key')", 'object_name': 'UserSession'},
            'device_name': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_used': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'secure_session_key': ('django.db.models.fields.CharField', [], {'max_length': '40'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['auth']

########NEW FILE########
__FILENAME__ = 0002_auto__add_unique_usersession_secure_session_key
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding unique constraint on 'UserSession', fields ['secure_session_key']
        db.create_unique('auth_usersession', ['secure_session_key'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'UserSession', fields ['secure_session_key']
        db.delete_unique('auth_usersession', ['secure_session_key'])


    models = {
        'auth.externalservicetoken': {
            'Meta': {'object_name': 'ExternalServiceToken'},
            'authorized': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'namespace': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'value': ('django.db.models.fields.TextField', [], {})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.message': {
            'Meta': {'object_name': 'Message'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'message': ('django.db.models.fields.TextField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'_message_set'", 'to': "orm['auth.User']"})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'auth.useridentifier': {
            'Meta': {'object_name': 'UserIdentifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'namespace': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'auth.usersession': {
            'Meta': {'ordering': "('user', 'device_name', 'secure_session_key')", 'object_name': 'UserSession'},
            'device_name': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_used': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'secure_session_key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '40'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['auth']

########NEW FILE########
__FILENAME__ = models
try:
    raise ImportError
    import cPickle as pickle
except ImportError:
    import pickle

from django.db import models
from django.core.urlresolvers import reverse
from django.contrib.auth.models import User

from molly.conf import app_by_local_name

class UserIdentifier(models.Model):
    user = models.ForeignKey(User)
    namespace = models.CharField(max_length=32)
    value = models.CharField(max_length=128)

    updated = models.DateTimeField(auto_now_add=True)

    @classmethod
    def get(self, user, namespace):
        try:
            identifier = self.objects.get(user=user, namespace=namespace)
            return identifier.value
        except self.DoesNotExist:
            return None

    @classmethod
    def set(self, user, namespace, value):
        try:
            identifer = self.objects.get(user=user, namespace=namespace)
        except self.DoesNotExist:
            identifer = self(user=user, namespace=namespace)
        identifer.value = value
        identifer.save()

class UserSession(models.Model):
    user = models.ForeignKey(User)
    secure_session_key = models.CharField(max_length=40, unique=True)

    device_name = models.TextField()
    last_used = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ('user', 'device_name', 'secure_session_key',)

class ExternalServiceToken(models.Model):
    user = models.ForeignKey(User)
    namespace = models.CharField(max_length=32)
    authorized = models.BooleanField(default=False)
    value = models.TextField()

    @property
    def service_name(self):
        return app_by_local_name(self.namespace).title

    @property
    def service_url(self):
        return reverse(self.namespace + ':index')

    @classmethod
    def get(self, user, namespace, default=None):
        try:
            token = self.objects.get(user=user, namespace=namespace)
            return pickle.loads(str(token.value))
        except self.DoesNotExist:
            return default

    @classmethod
    def set(self, user, namespace, value, authorized = None):
        try:
            token = self.objects.get(user=user, namespace=namespace)
        except self.DoesNotExist:
            token = self(user=user, namespace=namespace)
        if authorized is not None:
            token.authorized = authorized
        token.value = pickle.dumps(value)
        token.save()

    @classmethod
    def remove(self, user, namespace):
        self.objects.filter(user=user, namespace=namespace).delete()

########NEW FILE########
__FILENAME__ = clients
import urllib2

from oauth import oauth

from django.core.exceptions import PermissionDenied

class OAuthHTTPError(urllib2.HTTPError, PermissionDenied):
    def __init__(self, e):
        self.exception = e
    
    def __getattr__(self, key):
        return getattr(self.__dict__['exception'], key)
    def __setattr__(self, key, value):
        if key == 'exception':
            super(OAuthHTTPError, self).__setattr__(key, value)
        else:
            setattr(self.__dict__['exception'], key, value)

class OAuthOpener(object):
    def __init__(self, opener):
        self.__dict__['_opener'] = opener
    
    # Pass everything through to the inner opener
    def __getattr__(self, name):
        return getattr(self._opener, name)
    def __setattr__(self, name, value):
        return setattr(self._opener, name, value)
    def __delattr__(self, name):
        return delattr(self._opener, name)
        
    def open(self, *args, **kwargs):
        try:
            return self.__dict__['_opener'].open(*args, **kwargs)
        except urllib2.HTTPError, e:
            if e.code in (401, 403):
                raise OAuthHTTPError(e)
            else:
                raise
    

class OAuthHandler(urllib2.BaseHandler):
    def __init__(self, consumer, access_token, signature_method):
        self.consumer, self.access_token = consumer, access_token
        self.signature_method = signature_method
        
    def https_request(self, request):
        oauth_request = oauth.OAuthRequest.from_consumer_and_token(self.consumer,
                                                                   self.access_token)

        if self.access_token:
            oauth_request.sign_request(self.signature_method,
                                       self.consumer,
                                       self.access_token)
            request.add_header('Authorization',
                               oauth_request.to_header()['Authorization'])
        return request
    http_request = https_request

class OAuthClient(oauth.OAuthClient):

    def __init__(self, request_token_url='', access_token_url='', authorization_url=''):
        self.request_token_url = request_token_url
        self.access_token_url = access_token_url
        self.authorization_url = authorization_url

    def fetch_request_token(self, oauth_request):
        # via headers
        # -> OAuthToken
        request = urllib2.Request(self.request_token_url, headers=oauth_request.to_header())
        response = urllib2.urlopen(request) 
        return oauth.OAuthToken.from_string(response.read())

    def fetch_access_token(self, oauth_request):
        # via headers
        # -> OAuthToken
        request = urllib2.Request(self.access_token_url, headers=oauth_request.to_header())
        response = urllib2.urlopen(request) 
        return oauth.OAuthToken.from_string(response.read())

    def authorize_token(self, oauth_request):
        # via url
        # -> typically just some okay response
        response = urllib2.urlopen(oauth_request.to_url()) 
        return response.read()
        
    def get_opener(self, consumer, access_token, signature_method):
        return OAuthOpener(urllib2.build_opener(OAuthHandler(consumer,
                                                             access_token,
                                                             signature_method)))

########NEW FILE########
__FILENAME__ = views
from __future__ import absolute_import
import urlparse
import urllib
import urllib2
from datetime import timedelta

if not hasattr(urlparse, 'parse_qs'):
    import cgi
    urlparse.parse_qs = cgi.parse_qs
    del cgi

from oauth import oauth

from django.http import Http404, HttpResponseBadRequest
from django.core.urlresolvers import reverse
from django.core.exceptions import PermissionDenied, ImproperlyConfigured

from molly.utils.views import BaseView

from molly.auth import unify_users
from molly.auth.models import ExternalServiceToken
from molly.auth.oauth.clients import OAuthClient, OAuthHTTPError

class OAuthView(BaseView):
    """
    Private 'abstract' view implementing OAuth authentication.

    See the docstring for OAuthView for more details.
    """

    def __call__(self, request, *args, **kwargs):

        token_type, access_token = ExternalServiceToken.get(request.user, self.conf.local_name, (None, None))

        self.add_consumer_to_request(request)

        if 'oauth_token' in request.GET and token_type == 'request':
            return self.access_token(request, *args, **kwargs)

        self.add_opener_to_request(request, access_token if token_type == 'access' else None)

        # If we aren't authenticated but the view requires it then try
        # to obtain a valid oauth token immediately.
        if token_type != 'access' and getattr(self, 'force_auth', False):
            return self.authorize(request, *args, **kwargs)

        try:
            return super(OAuthView, self).__call__(request, *args, **kwargs)
        except OAuthHTTPError, e:
            if e.code in (401, 403) and not (token_type == 'request' and 'oauth_token' in request.GET):
                return self.authorize(request, *args, **kwargs)
            else:
                return self.handle_error(request, e.exception, *args, **kwargs)

    def authorize(self, request, *args, **kwargs):

        scheme, netloc, path, params, query, fragment = urlparse.urlparse(request.build_absolute_uri())
        args = urlparse.parse_qs(query)
        if 'format' in args:
            del args['format']
        query = urllib.urlencode(args)
        callback_uri = urlparse.urlunparse((scheme, netloc, path, params, query, fragment))
        
        oauth_request = oauth.OAuthRequest.from_consumer_and_token(
            request.consumer,
            callback=callback_uri,
            http_url = request.client.request_token_url,
        )
        
        try:
            oauth_request.sign_request(self.signature_method, request.consumer, None)
        except TypeError, e:
            raise ImproperlyConfigured("No OAuth shared secret has been set for app %r. Check that the server is configured with the right credentials." % self.conf.local_name)

        try:
            token = request.client.fetch_request_token(oauth_request)
        except urllib2.HTTPError, e:
            if e.code == 401:
                raise ImproperlyConfigured("OAuth shared secret not accepted by service %r. Check that the server is configured with the right credentials." % self.conf.service_name)
            else:
                return self.handle_error(request, e)

        ExternalServiceToken.set(request.user, self.conf.local_name, ('request', token), authorized=False)

        oauth_request = oauth.OAuthRequest.from_token_and_callback(
            token=token,
            http_url=request.client.authorization_url,
        )

        if getattr(self.conf, 'oauth_authorize_interstitial', True) and not request.GET.get('skip_interstitial') == 'true':
            index_url = reverse('%s:index' % self.conf.local_name)
            context = {
                'return_url': request.META.get('HTTP_REFERER', index_url),
                'authorize_url': oauth_request.to_url(),
                'service_name': self.conf.service_name,
                'breadcrumbs': (
                    self.conf.local_name,
                    (self.conf.service_name, index_url),
                    (self.conf.service_name, index_url),
                    True,
                    'Authorization required',
                ),
            }
            return self.render(request, context, 'auth/oauth/authorize', expires=timedelta(days=-1))
        else:
            return self.redirect(oauth_request.to_url(), request, 'seeother')

    def access_token(self, request, *args, **kwargs):
        token_type, request_token = ExternalServiceToken.get(request.user, self.conf.local_name, (None, None))
        if token_type != 'request':
            return HttpResponseBadRequest()
        if request_token.key != request.GET.get('oauth_token'):
            return HttpResponseBadRequest()

        oauth_request = oauth.OAuthRequest.from_consumer_and_token(
            request.consumer,
            token=request_token,
            verifier=request.GET.get('oauth_verifier'),
            http_url = request.client.access_token_url,
        )

        oauth_request.sign_request(self.signature_method, request.consumer, request_token)

        try:
            access_token = request.client.fetch_access_token(oauth_request)
        except urllib2.HTTPError, e:
            return self.handle_error(request, e, 'request_token', *args, **kwargs)

        ExternalServiceToken.set(request.user, self.conf.local_name, ('access', access_token), authorized=True)

        self.add_opener_to_request(request, access_token)
        self.add_user_identifiers(request)
        unify_users(request)

        return self.redirect(request.path, request)

    def handle_error(self, request, exception, token_type='access', *args, **kwargs):
        body = exception.read()
        try:
            d = urlparse.parse_qs(body)
        except ValueError:
            error = 'unexpected_response'
            oauth_problem = None
        else:
            error = 'oauth_problem'
            oauth_problem = d.get('oauth_problem', [None])[0]

        ExternalServiceToken.remove(request.user, self.conf.local_name)

        try:
            breadcrumbs = self.breadcrumb(request, {'oauth_problem': True}, *args, **kwargs)
        except Exception, e:
            breadcrumbs = (
                self.conf.local_name,
                (reverse('%s:index' % self.conf.local_name), self.conf.title),
                (reverse('%s:index' % self.conf.local_name), self.conf.title),
                True,
                'Authentication error',
            )

        context = {
            'breadcrumbs': breadcrumbs,
            'error':error,
            'oauth_problem': oauth_problem,
            'token_type': token_type,
            'service_name': self.conf.service_name,
        }
        return self.render(request, context, 'auth/oauth/error', expires=timedelta(days=-1))

    def add_consumer_to_request(self, request):

        request.consumer = oauth.OAuthConsumer(*self.secret)

        request.client = OAuthClient(
            self.base_url+self.request_token_url,
            self.base_url+self.access_token_url,
            self.base_url+self.authorize_url,
        )

    def add_opener_to_request(self, request, access_token):
        request.opener = request.client.get_opener(
            request.consumer,
            access_token,
            self.signature_method)

        def urlopen(*args, **kwargs):
            try:
                return request.opener.open(*args, **kwargs)
            except urllib2.HTTPError, e:
                if e.code == 404:
                    raise Http404
                elif e.code == 403 and access_token is not None:
                    raise PermissionDenied
                else:
                    raise
        request.urlopen = urlopen

    def add_user_identifiers(request):
        pass


########NEW FILE########
__FILENAME__ = molly_auth
from django import template
from django.utils.translation import ungettext

register = template.Library()

@register.filter
def externalservicetoken_count(user):
    count = user.externalservicetoken_set.filter(authorized=True).count()
    return ungettext('%(count)d service', '%(count)d services', count) % {
        'count': count
    }

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from views import IndexView, ClearSessionView

urlpatterns = patterns('',
    (r'^$',
        IndexView, {},
        'index'),
        
    (r'^clear-session/$',
        ClearSessionView, {},
        'clear-session'),
)

########NEW FILE########
__FILENAME__ = views
import urllib
import urllib2
import urlparse
import logging
from datetime import datetime, timedelta

from django.conf import settings
from django.contrib.auth import logout
from django.core.urlresolvers import reverse
from django.http import HttpResponse
from django.forms.util import ErrorList
from django.utils.translation import ugettext as _

from molly.utils.views import BaseView
from molly.utils.breadcrumbs import BreadcrumbFactory, Breadcrumb, static_reverse, lazy_reverse, static_parent

from .forms import PreferencesForm, UserSessionFormSet, ExternalServiceTokenFormSet
from .models import UserSession

class SecureView(BaseView):
    """
    An 'abstract' view for all secure pages.
    
    Implements a timeout so that people will need to reauthenticate if a
    secure page hasn't been accessed recently. The SecureMidddleware checks
    for this class in a view's MRO in order to enforce an HTTPS connection.
    """

    def __call__(self, request, *args, **kwargs):
        """
        Enforces timeouts for idle sessions.
        """

        # If the SecureMiddleware hasn't redirected requests over !HTTPS
        # something has gone wrong. We ignore this for debugging purposes.
        assert settings.DEBUG_SECURE or request.is_secure()

        last_accessed = request.secure_session.get('last_accessed', datetime.now())
        timeout_period = request.secure_session.get('timeout_period', 15)
        if last_accessed < datetime.now() - timedelta(minutes=timeout_period) and getattr(self.conf, 'enforce_timeouts', True):
            return TimedOutView(request, self, *args, **kwargs)
        request.secure_session['last_accessed'] = datetime.now()

        return super(SecureView, self).__call__(request, *args, **kwargs)

class TimedOutView(BaseView):
    """
    Handles the case where a user's secure session has been inactive for too
    long.
    
    This view should not be included in a urlconf as it is referenced only by
    SecureView.
    """

    def initial_context(self, request, view, *args, **kwargs):
        return {
            'has_pin': 'pin' in request.secure_session,
        }    
    
    @BreadcrumbFactory
    def breadcrumb(self, request, context, view, *args, **kwargs):
        return Breadcrumb(
            view.conf.local_name,
            None,
            _('Session expired'),
            static_reverse(request.get_full_path()),
        )
    
    def handle_GET(self, request, context, view, *args, **kwargs):
        return self.render(request, context, 'auth/timed_out')
            
    def handle_POST(self, request, context, view, *args, **kwargs):
        if 'clear_session' in request.POST:
            for key in request.secure_session.keys():
                del request.secure_session[key]
            request.secure_session['is_secure'] = True
            return self.redirect('.', request)
        elif 'reauthenticate' in request.POST and context['has_pin']:
            valid_pin = request.POST.get('pin') == request.secure_session['pin']
            if valid_pin:
                # Reauthenticating brings the inactivity measure to zero
                request.secure_session['last_accessed'] = datetime.now()
                return self.redirect('.', request)
            else:
                context['incorrect_pin'] = True
                return self.render(request, context, 'auth/timed_out')
        else:
            return HttpResponse('', status=400)
        
class IndexView(SecureView):
    app_name = 'secure'
    
    def initial_context(self, request):
        return {
            'form': PreferencesForm(request.POST or {
                'timeout_period': request.secure_session.get('timeout_period', 15),
            }),
            'has_pin': 'pin' in request.secure_session,
            'session_key': request.secure_session.session_key,
            'user_sessions': UserSessionFormSet(request, request.POST or None),
            'external_service_tokens': ExternalServiceTokenFormSet(request, request.POST or None),
        }
        
    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name,
            None,
            _('Authentication preferences'),
            lazy_reverse('auth:index'),
        )
        
    def handle_GET(self, request, context):
        return self.render(request, context, 'auth/index')
    
    def handle_POST(self, request, context):
        forms = context['form'], context['user_sessions'], context['external_service_tokens']
        
        if not all(form.is_valid() for form in forms):
            return self.render(request, context, 'auth/index')
            
        if context['has_pin'] and form.cleaned_data['old_pin'] != request.secure_session['pin']:
            form.errors['old_pin'] = ErrorList(['You supplied an incorrect PIN. Please try again.'])
            return self.render(request, context, 'auth/index')

        form = context['form']
        request.secure_session['timeout_period'] = form.cleaned_data['timeout_period']
        
        if form.cleaned_data['new_pin_a']:
            if form.cleaned_data['new_pin_a'] == form.cleaned_data['new_pin_b']:
                request.secure_session['pin'] = form.cleaned_data['new_pin_a']
            else:
                form.errors['new_pin_b'] = ErrorList(['Your repeated PIN did not match.'])
                return self.render(request, context, 'auth/index')

        for form in forms:
            if hasattr(form, 'save'):
                form.save()
        
        return self.redirect('.', request)

    
class ClearSessionView(SecureView):
    
    def initial_context(self, request):
        return {
            'return_url': request.REQUEST.get('return_url', '/'),
            'suppress_clear_session_link': True,
        }
    
    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name,
            static_parent(context['return_url'], 'Back'),
            _('Clear session'),
            lazy_reverse('auth:clear-session'),
            
        )
     
    def handle_GET(self, request, context):
        return self.render(request, context, 'auth/clear_session')
    
    def handle_POST(self, request, context):
        UserSession.objects.filter(secure_session_key = request.secure_session.session_key).delete()
        logout(request)
        return self.redirect(context['return_url'], request)

########NEW FILE########
__FILENAME__ = createsite
import os
from shutil import copytree

def command(path):
    
    copytree(os.path.join(os.path.dirname(__file__), 'site_template'), path)
    os.makedirs(os.path.join(path, 'site_media'))
    os.makedirs(os.path.join(path, 'compiled_media'))
    print "Template created at", os.path.abspath(path)

########NEW FILE########
__FILENAME__ = findtemplates
import re, sys, os, os.path

"""
Quick and dirty script to try and figure out unused templates - it's used
something like this:

    find .. -name \*.pyc -exec cat {} \; | molly-admin findtemplates

"""

def command():
    templates = ''
    temps = set()
    for (dirpath, dirnames, filenames) in os.walk('.'):
        path, dir = os.path.split(os.path.normpath(dirpath))
        path, tdir = os.path.split(os.path.normpath(os.path.join(dirpath, '..')))
        path, t2dir = os.path.split(os.path.normpath(os.path.join(dirpath, '..', '..')))
        if tdir == 'templates':
            for filename in filenames:
                file, ext = os.path.splitext(filename)
                temps.add(dir + '/' + file)
                with open(os.path.join(dirpath, filename)) as fd:
                    templates += fd.read()
        elif t2dir == 'templates' and tdir != 'site-media':
            for filename in filenames:
                file, ext = os.path.splitext(filename)
                temps.add(tdir + '/' + dir + '/' + file)
                with open(os.path.join(dirpath, filename)) as fd:
                    templates += fd.read()
    
    used_temps = set()
    for m in re.finditer(r"(render\(\s*.+?\s*,\s*.+?\s*,|get_template\()\s*'(.+?)'\s*\)", sys.stdin.read()):
        used_temps.add(m.group(2))
    
    for m  in re.finditer(r'{% (include|extends) "(.+?).x?html" %}', templates):
        used_temps.add(m.group(2))
    
    
    print "The following templates exist are are used:"
    for t in sorted(temps & used_temps):
        print t
    print
    
    print "The following templates exist, but are not used:"
    for t in sorted(temps - used_temps):
        print t
    print
    
    print "The following templates are used, but do not exist:"
    for t in sorted(used_temps - temps):
        print t
    print

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
import imp
try:
    imp.find_module('settings') # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n" % __file__)
    sys.exit(1)

import settings

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
# Molly Settings File
#
# This file contains a sample Molly configuration file. It follows the format
# of a standard Django file: https://docs.djangoproject.com/en/dev/topics/settings/
#
# This is also a Python file, so you can define Python strings in here.
#
# The documentation for this file and the settings within it is at:
# http://docs.mollyproject.org/dev/getting-started/configuring.html
#
# It is recommended you use that as a reference whilst moving through this file.

# This next block of code is preamble that is used later on, you can safely
# skip it:
import os
import imp
from molly.conf.settings import Application, extract_installed_apps
from molly.conf.settings import ProviderConf as Provider
from molly.conf.celery_util import prepare_celery
from molly.conf.default_settings import *
from molly.utils.media import get_compress_groups

# Celery configuration
BROKER_URL = "amqp://molly:molly@localhost:5672//"
CELERYBEAT_SCHEDULER = "djcelery.schedulers.DatabaseScheduler"
CELERYD_CONCURRENCY = 1
CELERY_RETRY_DELAY = 3 * 60
CELERY_MAX_RETRIES = 3

# Register Django-Celery and initialise our providers.
prepare_celery()

# The following import and mimetypes.add_types correct the - possibly wrong - mime type of svg files
# in certain versions of Django.
import mimetypes

mimetypes.add_type("image/svg+xml", ".svg", True)
mimetypes.add_type("image/svg+xml", ".svgz", True)

# The following creates two useful variables - a path to where Molly is
# installed, and also to the root of where your site is installed. These can be
# used in place of absolute URLs so you can move your installation around
MOLLY_ROOT = imp.find_module('molly')[1]
PROJECT_ROOT = os.path.normpath(os.path.dirname(__file__))

# The next setting defines whether or not the site is in debug mode. In debug
# mode, more verbose logging is available, as well as more information about
# errors which occur. It is recommended to have this turned on when developing
# the site, but to set it to False when running a live site.
DEBUG = True

# This setting decides whether or not the secure parts of the site should be in
# 'debug' mode - when True, this allows Secure parts of the site to be accessed
# over regular HTTP. It defaults to the same value as DEBUG.
DEBUG_SECURE = DEBUG

# This setting decides whether or not template debugging information is shown
# when a template error occurs. It defaults to the same value as DEBUG.
TEMPLATE_DEBUG = DEBUG

# The next setting defines which users receive e-mail notifications of events on
# the site, such as errors, submitted feedback, etc. Multiple e-mail addresses
# can be added multiple comma-seperated tuples.
ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)
MANAGERS = ADMINS

# This is the name of this site which is used in various templates throughout
# the site
SITE_NAME = 'Mobile Portal'

# This defines the database connections for this project
DATABASES = {
    'default': {
        # The next line defines which database type is used. Molly heavily
        # relies on a spatial database, and recommends Postgres/Postgis for this
        # The default below should be fine and not need to change
        'ENGINE': 'django.contrib.gis.db.backends.postgis',
        
        # The name of the database to connect to
        'NAME': 'molly',
        
        # The username to connect as
        'USER': 'molly',
        
        # The password to connect with
        'PASSWORD': 'molly',
        
        # The address of the database server - an empty string = localhost
        'HOST': '',
        
        # The port of the database server - an empty string = the server default
        'PORT': '',
    }
}

# This is the e-mail address which Molly uses to send e-mails from
SERVER_EMAIL = 'molly@example.com'

# This is the hostname for the SMTP server to use to send e-mails through
EMAIL_HOST = 'localhost'

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'Europe/London'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en'

# This list defines which languages are available for your users to use. At
# present, only English is supported, although you can add custom translation
# packs of your own, or add languages when Molly supports them at a later date
LANGUAGES = (
        ('en', 'English'),
    )

# Absolute filesystem path to the directory that will hold user-uploaded files.
# This setting is unused in Molly.
MEDIA_ROOT = os.path.join(PROJECT_ROOT, 'site_media')

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
# This setting is unused in Molly.
MEDIA_URL = '/site-media/'

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# This defaults to the 'compiled_media' folder in your project.
STATIC_ROOT = os.path.join(PROJECT_ROOT, 'compiled_media')

# URL prefix for static files - this is the address that Molly expects your
# static files to be served from. Apache should be set up to serve the directory
# specified above at this URL
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# URL prefix for admin static files -- CSS, JavaScript and images.
# Make sure to use a trailing slash.
# Examples: "http://foo.com/static/admin/", "/static/admin/".
# Defaults to the 'admin' subdirectory of the static URL set above
ADMIN_MEDIA_PREFIX = STATIC_URL + 'admin/'

# This specifies the path to where Molly caches files (e.g., generated map
# images, resized images, etc)
CACHE_DIR = os.path.join(PROJECT_ROOT, 'cache')

# This specifies where Molly should cache pre-generated map markers. The
# default is in a subdirectory called 'markers' in the cache directory
MARKER_DIR = os.path.join(CACHE_DIR, 'markers')

# This specifies where your external images should be cached. By default, this
# happens under the CACHE_DIR
#EXTERNAL_IMAGES_DIR = '/var/cache/molly-images'

# Additional locations of static files
# This defaults to your local site media folder with highest priority, then any
# default media that Molly comes with, as well as the markers used for slippy
# maps
STATICFILES_DIRS = (
    ('', os.path.join(PROJECT_ROOT, 'site_media')),
    ('', os.path.join(MOLLY_ROOT, 'media')),
    ('markers', MARKER_DIR),
)

# This uses a Molly convenience function to find the CSS and JS to be compressed
# and which should be concatenated together
PIPELINE_CSS, PIPELINE_JS = get_compress_groups(STATIC_ROOT)

# This determines how the CSS should be compressed
# CSS filter is custom-written since the provided one mangles it too much
PIPELINE_CSS_COMPRESSOR = 'molly.utils.compress.MollyCSSFilter'

# This determines how the JavaScript should be compressed
PIPELINE_JS_COMPRESSOR = 'pipeline.compressors.jsmin.JSMinCompressor'

# Make this unique, and don't share it with anybody. It's used to salt passwords
SECRET_KEY = ''

# This defines the places Django looks for templates, in order of priority
TEMPLATE_DIRS = (
    os.path.join(PROJECT_ROOT, 'templates'), # first look in the 'templates' folder in your local site
    os.path.join(MOLLY_ROOT, 'templates'), # secondly, look in Molly's default templates
)

# This is used to store API keys for various external services that Molly uses
API_KEYS = {
    
    # This is used for geocoding and location settings. You can obtain an API
    # key by registering at Cloudmade.com and then going to your user profile
    # page: http://cloudmade.com/user/show
    'cloudmade': '',
    
    # This is the web property ID for your Google Analytics account
    'google_analytics': '',

    # This is used by the weather app - if you want to use the MetOffice
    # provider. You need to get an API key at http://www.metoffice.gov.uk/public/ddc/index.html
    'metoffice': '',
}

# Each entity has a primary identifier which is used to generate the absolute
# URL of the entity page. We can define a list of identifier preferences, so
# that when an entity is imported, these identifier namespaces are looked at in
# order until a value in that namespace is chosen. This is then used as the
# primary identifer. The default is shown in the sample below, and is optional:
#IDENTIFIER_SCHEME_PREFERENCE = ('atco', 'osm', 'naptan', 'postcode', 'bbc-tpeg')

# When converting distances into human readable units, several schemes are
# available: metric (metres and kilometres), imperial (yards and miles) and
# british (metres and miles) - the default.
#DISTANCE_UNITS = 'british'

# This is where you define which applications are used in your Molly install
# The order in this file defines the order in which applications appear on the
# home screen
APPLICATIONS = [
    
    # Application definitions look a little bit like this:
    #
    #Application('mysite.myapp', 'myapp', 'My App',
    #    enable_foo = False,
    #    enable_bar = True,
    #),
    #
    # The first argument is the Python package which provides this app, the
    # second is the "local name", which is used as a namespace for URL resolving
    # and as the first part of the URL for all pages in this app. The final
    # part is the application name, as rendered on the home screen. Any options
    # are then listed below as keyword arguments. For more information on the
    # applications framework, as well as all supported references, please see
    # http://docs.mollyproject.org/dev/getting-started/configuring.html#applications
    
    # The home screen - this app must be loaded
    Application('molly.apps.home', 'home', 'Home',
        # This setting is valid on every app, and is used to determine whether
        # or not this app should be included in the list of apps on the home
        # page. It defaults to True, but you can suppress an app from being
        # displayed in the icon grid by setting it to be False
        display_to_user = False,
    ),

    # The desktop page - users with desktop browsers are redirected here to
    # see more information about the app
    Application('molly.apps.desktop', 'desktop', 'Desktop',
        display_to_user = False,
        
        # A stream of tweets can be shown on the desktop page. If this is set,
        # then this feed is fetched and shown. To disable this functionality,
        # just comment out the next line.
        twitter_username = 'mollyproject',
        
        # When this is set, any tweets which contain this URL are filtered out
        # of being displayed - the aim of this is if blog entries are fed into
        # your tweets, then you don't get duplication between showing your blog
        # feed and your feed of tweets
        twitter_ignore_urls = 'http://blog.mollyproject.org',
        
        # If set, then an RSS feed is fetched and rendered on the front page
        blog_rss_url = 'http://blog.mollyproject.org/rss',
    ),

    # A contact search app
    Application('molly.apps.contact', 'contact', 'Contact search',
        
        # Molly ships with an LDAP provider out of the box, however you can
        # write your own provider to do contact search if you desire by changing
        # the package name (first argument) in the line below
        provider = Provider('molly.apps.contact.providers.LDAPContactProvider',
                        # The URL setting defines the URL of the LDAP server to connect to
                        url='ldap://ldap.mit.edu:389',
                        
                        # The base_dn setting specifies the DN to use when querying
                        # the LDAP server
                        base_dn='dc=mit,dc=edu'
                        
                        # This next option allows you to add a prefix to phone
                        # numbers that makes them externally diallable, e.g.,
                        # if your LDAP server stores extension numbers only
                        # The prefix should be international format
                        #phone_prefix='+44123456',
                        
                        # The next option gives you more power than this, by
                        # allowing you to specify a function which filters all
                        # phone numbers and returns a complete string.
                        #phone_formatter=my_custom_function,
                        
                        # Whether or not results from the LDAP server should be
                        # sorted alphabetically by surname
                        #alphabetical=True,
                        
                        # Determines the LDAP query passed to the server,
                        # using {surname} and {forename} as substitutes for the
                        # user to search for
                        #query='(sn={surname})',
            ),
    ),

    # Places is used to store a location database and can be used find places
    # This is required by the transport and library apps
    Application('molly.apps.places', 'places', 'Places',
        
        # This app accepts a list of providers which provide place information
        providers = [
            
            # The NaPTAN is the database of 'Public Transport Access Nodes',
            # that is, places on the public transport network, e.g., train
            # stations, bus stops, etc...
            Provider('molly.apps.places.providers.NaptanMapsProvider',                
                # This specifies which areas of the NaPTAN are to be imported.
                # The full list of codes is available at http://www.dft.gov.uk/naptan/smsPrefixes.htm
                # and the 'ATCO' column is the relevant code here. Also available
                # are areas "920", "930" and "940" which refer to airports,
                # ferry terminals and metro stations respectively. Area '910'
                # represents rail stations and are always imported.
                areas=('340','940'),
            ),
            
            # The postcode importer uses the CodePoint Open database to import
            # postcode areas.
            Provider('molly.apps.places.providers.PostcodesMapsProvider',
                
                # This is the path to where the CodePoint Open file lives on
                # disk. If this file doesn't exist, it is created by downloading
                # from http://www.freepostcodes.org.uk/
                codepoint_path = CACHE_DIR + '/codepo_gb.zip',
                
                # This option specifies which postcode areas are to be imported
                # A postcode area is the first alphabetical component of a
                # postcode, e.g., OX for 'OX2 6NN', YO for 'YO10 5DD'. A full
                # list of postcode areas is available at
                # http://en.wikipedia.org/wiki/List_of_postcode_areas_in_the_United_Kingdom
                # Disabling this setting will import the entire country, but
                # this is not recommended due to the size of the dataset!
                import_areas = ('OX',),
            ),
            
            # This next provider provides real time bus information if you are
            # in an area where ACIS Live provides the infrastructure for real
            # time passenger information. It is recommended that you speak to
            # your local public transport executive/council before enabling this
            # service.
            #
            #'molly.apps.places.providers.ACISLiveMapsProvider',
            
            # The next provider is related to the previous and can extract route
            # details from an ACIS Live instance to provide information about
            # all the bus stops on a particular route. As with the previous one,
            # it is recommended you talk to your council before enabling this
            # service
            #
            #Provider('molly.apps.places.providers.ACISLiveRouteProvider',
            #    # This next option specifies the URLs for the ACIS Live instances
            #    # which are to be scraped to obtain the route data.
            #    urls = ('http://www.oxontime.com',),
            #),
            
            # The next provider uses the Trackernet API to provide real-time
            # information on Tube departures at London Underground stations
            'molly.apps.places.providers.TubeRealtimeProvider',
            
            # This provider uses OpenStreetMap data to provide points of
            # interest for the places app.
            Provider('molly.apps.places.providers.OSMMapsProvider',
                     
                     # The following specify a bounding box for the OSM data
                     # to be imported. It uses decimal latitude and longitude
                     # degrees
                     lat_north=52.1, # The northern limit on the bounding box
                     lat_south=51.5, # The southern limit on the bounding box
                     lon_west=-1.6, # The western limit on the bounding box
                     lon_east=-1.0 # The eastern limit on the bounding box
                     
                     # The following URL specifies a link to a bzip2'd OSM dump
                     # file to use. It defaults to the English file. Using the
                     # most specific file for your needs will improve running
                     # time. http://download.geofabrik.de/osm/ contains country
                     # and region specific data dumps
                     #url='http://download.geofabrik.de/osm/europe/great_britain/england.osm.bz2',
                     
                     # The following setting specifies that instead of using the
                     # default mapping from OSM tags to entity types inside of
                     # Molly, then a different mapping should be used. The second
                     # file contains the specifications for the Molly entity types
                     # which the OSM importer uses.
                     # For more information see http://docs.mollyproject.org/dev/ref/apps/places.html#molly-apps-places-providers-osmmapsprovider
                     #
                     #osm_tags_data_file=os.path.join(PROJECT_ROOT, 'data', 'osm_tags.yaml'),
                     #entity_type_data_file=os.path.join(PROJECT_ROOT, 'data', 'osm_entity_types.yaml')
            ),
            
            # The following provider provides real-time rail departure
            # information from the National Rail Enquiries "Darwin" Live
            # Departure Boards API. You will need an access token to use this
            # service, which can be obtained by contacting National Rail:
            # http://realtime.nationalrail.co.uk/ldbws/
            
            #Provider('molly.apps.places.providers.LiveDepartureBoardPlacesProvider',
            #    token = ''
            #),
            
            # The following provider uses the BBC TPEG feeds to import travel
            # alerts. Please note that the BBC appear to have discontinued these
            # feeds, so this provider is only included for legacy purposes.
            
            #Provider('molly.apps.places.providers.BBCTPEGPlacesProvider',
            #    # This URL is the URL to the TPEG feed to be imported
            #    url='http://www.bbc.co.uk/travelnews/tpeg/en/local/rtm/oxford_tpeg.xml',
            #),
            
            # The following provider takes timetable and route dumps in ATCO-CIF
            # format and imports those into Molly, allowing for scheduled bus
            # departures to be shown alongside the bus stop
            
            #Provider('molly.apps.places.providers.AtcoCifTimetableProvider',
            #    url = 'http://store.datagm.org.uk/sets/TfGM/GMPTE_CIF.zip'
            #),
            
            # The following provider takes timetable and route dumps from the
            # multiple timetable sources and shows them on the entity page
            
            Provider('molly.apps.places.providers.TimetableAnnotationProvider'),

            # Provider used to provide real-time information for buses, scraped from
            # a website powered by CloudAmber solutions.
            #Provider('molly.apps.places.providers.cloudamber.CloudAmberBusRtiProvider',
            #    url = 'http://www.oxontime.com',
            #),
        ],
        
        # This setting can be used to associate entities with each other. At
        # present this simply means a list of associated entries, with any
        # real-time information, is shown below the original entity on the
        # entity detail page.
        #
        # The format is a list of tuples, where the format is:
        # (identifier_scheme, identifier_value, entity_groups), and
        # entity_groups is then a list of tuples of entity group names and then
        # a list of entities in that group (tuples of identifier scheme and value).
        # The entity scheme and values can be found by looking at the URL for
        # the entity, e.g., http://example.com/places/atco:9100OXFD/ has a
        # scheme of 'atco' and a value of '9100OXFD'
        #
        # Below is an example definition for associating bus stops near Oxford
        # rail station (those in the Forecourt, and then those a little bit
        # further away, on Frideswide Square) with the station.
        #
        #associations = [
        #    ('atco', '9100OXFD', [
        #        ('Station Forecourt', [
        #            ('atco', '340000006R1'),
        #            ('atco', '340000006R2'),
        #            ('atco', '340000006R3'),
        #            ('atco', '340000006R4'),
        #            ('atco', '340000006R5'),
        #            ('atco', '340000006R6'),
        #        ]),
        #        ('Frideswide Square', [
        #            ('atco', '340002070R7'),
        #            ('atco', '340002070R8'),
        #            ('atco', '340002070R9'),
        #            ('atco', '340002070R10'),
        #        ]),
        #    ]),
        #]

    ),

    # The following app enables library searching
    Application('molly.apps.library', 'library', 'Library search',
        
        # If your libraries exist as entities in the places app, and they have
        # identifiers which correspond to the location codes returned by your
        # library catalogue, then you can set the namespace for this identifier
        # here and it is used for location sensitive library searching
        #library_identifier = 'olis',
        
        # The provider which provides the search backend. At present, only
        # Z39.50 is supported
        provider = Provider('molly.apps.library.providers.Z3950',
                            
                            # The hostname of the Z39.50 endpoint to connect to
                            host = 'library.example.ac.uk',
                            
                            # The database name to use
                            database = 'Default',
                            
                            # Optionals - specifies the port to connect to on
                            # the server
                            #port=210,
                            
                            # Optional - defaults to USMARC, the syntac which
                            # records are returned in (USMARC and XML supported)
                            syntax='USMARC',
                            
                            # Optional - the charset to use when communicating
                            # with the server - defaults to UTF-8
                            #charset = 'ascii',
                            
                            # Optional - the 'use attribute' to use when looking
                            # up by control number, defaults to 12
                            #control_number_key='1032',
                            
                            # Optional - the encoding which is used on results
                            # from the server, only unicode or marc8 are
                            # supported. Aleph supplies unicode, and marc8 is
                            # default
                            #results_encoding='unicode',
                            ),
    ),

    # Gathers together places and data relating to transport and shows them all
    # in one place
    Application('molly.apps.transport', 'transport', 'Transport',
        
        # If set, then specifies the ID of the rail station to show on the
        # transport page. You can specify the CRS code by using crs:CODE, where
        # code is a station from this list: http://www.nationalrail.co.uk/stations/codes/
        #train_station = 'crs:OXF',
        
        # If set to True, then instead of the train station specified above,
        # then the closest train station to the user is shown. The train station
        # specified above is then only used as a fallback
        train_station_nearest = False,
        
        # This specifies which tabs are created for different transport entity
        # types. It is a dictionary where the key represents the slug of the
        # pagewhich contains it, and the value is a tuple of type slug (i.e.,
        # from http://example.com/places/category/TYPE-SLUG/) and the number to
        # show by default
        nearby = {
            
            # This shows the 5 nearest bus stops
            'bus': ('bus-stop', 5),
            
            # This shows the 3 nearest Supertram stops
            #'supertram': ('supertram-stop', 3),
            
            # This shows the 3 nearest Tube stations
            #'tube': ('tube-station', 3),
        },
        
        # The nearby pages above can be augmented with a "status" provider which
        # typically shows information about the different lines currently on
        # that transit network. These settings are called TYPE_status_provider,
        # where the first word (TYPE) is replaced with the key of the nearby
        # page as defined in the setting above
        #
        # Molly comes with a single provider for transit line statuses, which is
        # the London Underground line statuses. Using the example setting above,
        # where Tube stations are exposed with the key 'tube', the following
        # setting will show the current Tube status on the 'tube' page:
        #tube_status_provider = 'molly.apps.transport.providers.TubeStatusProvider',
        
        # When set, then this shows the park and rides specified below on the
        # transport page. These are in the form SCHEME:VALUE
        #park_and_rides = [
        #    'osm:W4333225',
        #    'osm:W4329908',
        #    'osm:W34425625',
        #    'osm:W24719725',
        #    'osm:W2809915'],
        
        # When set to True, this shows current travel alerts on the transport
        # page
        travel_alerts = False,
    ),
    
    # The following app allows for podcasts to be shown
    Application('molly.apps.podcasts', 'podcasts', 'Podcasts',
        # The following setting lists all the sources for podcasts for this app
        # Any provider can appear multiple times, for example to import multiple
        # OPML feeds
        providers = [
            
            # The following provider enables import from an OPML feed
            Provider('molly.apps.podcasts.providers.OPMLPodcastsProvider',
                
                # This specifies the URL of the feed to be imported
                url = 'http://www.bbc.co.uk/radio/opml/bbc_podcast_opml_v2.xml',
                
                # The following is a regex where the matching group is extracted
                # to be used as the slug in the URLs generated inside Molly
                rss_re = r'http://downloads.bbc.co.uk/podcasts/(.+)/rss.xml'
            ),
            
            # The following provider enables import from an PodcastProducer feed
            Provider('molly.apps.podcasts.providers.PodcastProducerPodcastsProvider',
                
                # This specifies the URL of the feed to be imported
                url = 'http://www.example.com/feed.pp',
                
            ),
            
            # The following provider imports single RSS feeds
            Provider('molly.apps.podcasts.providers.RSSPodcastsProvider',
                podcasts = [
                    # The feeds to import are specified here in the form:
                    #('slug', 'http://example.com/feed.rss'),
                ],
                
                # The setting below determines the type of this set of RSS feeds
                # either 'audio' or 'video'. If omitted, it defaults to undefined.
                #medium = 'audio'
            ),
        ]
    ),
    
    # The tours app allows for users to build their own walking tours of a city
    # or University by choosing their own points of interest from a list
    # presented to them. Tours displays metadata stored with an entity in the
    # places database depending on the type of tour that is created. For more
    # information, see http://docs.mollyproject.org/dev/ref/apps/tours.html.
    #Application('molly.apps.tours', 'tours', 'Tours',
    #            
    #            # The types setting defines the different "types" of tours that
    #            # can be created. The tour type determines which descriptions
    #            # are shown to people on the tour, as well as what categories
    #            # of entities are shown to the user when creating the tour.
    #            types={
    #                
    #                # The dictionary key refers to the 'slug' of the tour
    #                # creation page (e.g., /tours/*admissions*/create/) and should
    #                # be all lower case with only letters, - or numbers
    #                'admissions': {
    #                    
    #                    # This is the name of the tour as shown to users. If you
    #                    # are using i18n, you will want to manually add this
    #                    # string to your custom .po files to ensure it is
    #                    # correctly translated
    #                    'name': 'Admissions tour',
    #                    
    #                    # This is a list of entity types which are shown to the
    #                    # user, and should consist of slugs for the EntityType.
    #                    'attraction_types': ['department', 'hall-of-residence'],
    #                    
    #                    # This next setting is optional, and if set, will
    #                    # suggest particular entities to the user (as defined by
    #                    # identifier scheme and value in the same form as is
    #                    # used in entity URLs) if the user will be passing by
    #                    # them.
    #                    'suggested_entities': ['oxpoints:23233759'],
    #                },
    #                
    #                # To create more types, simply copy and paste the template
    #                # above in this list.
    #            },
    #            
    #            # This setting defines the points where visitors can arrive to
    #            # start their tours
    #            arrival_points=[
    #                    # scheme:value, is_park_and_ride, park_and_ride_routes
    #                    
    #                    # The first value is the identifier scheme and value for
    #                    # the arrival point, the second is whether or not this
    #                    # is Park & Ride site (in which case, users will
    #                    # continue to their tour starting point by bus) and the
    #                    # final defines which bus routes serve that point, if
    #                    # that point is a Park & Ride site
    #                    
    #                    # This example defines the arrival point of Oxford rail
    #                    # station which is a non-Park&Ride site
    #                    ('crs:OXF', False, []),
    #                    
    #                    # This example defines the arrival point of a Park&Ride
    #                    # which is served by the bus route 300.
    #                    ('osm:W4333225', True, ['300']),
    #                ],
    #            
    #            # This setting defines the long distance routes (e.g., coach
    #            # services) that can be used to access the University.
    #            arrival_routes=[
    #                    
    #                    # The first element is the service ID (which should
    #                    # match up with a route in the places database) and then
    #                    # a human-readable name for that route.
    #                    ('TUBE', 'Oxford Tube'),
    #                    ('X90', 'Oxford Espress (X90)'),
    #                    ('X70', 'Gatwick Airline (X70)'),
    #                    ('X80', 'Heathrow Airline (X80)'),
    #                ],
    #            
    #            # This optional setting which defines how far that suggested
    #            # entities should be looked for off the currently plotted route
    #            # e.g., with the default setting of 100 metres, then if any
    #            # suggested entities are within 100 metres of the route the user
    #            # would be walking anyway, then those entities are suggested to
    #            # the user
    #            suggestion_distance = 100,
    #
    #),

    # The following app enables webcams in Molly, comment it out or delete it
    # to disable it. There are no additional settings, as webcams are added
    # using the web interface at http://example.com/adm/
    Application('molly.apps.webcams', 'webcams', 'Webcams'),

    # The following app displays the current weather on the front page and a
    # 3-day forecast on a specific weather page
    Application('molly.apps.weather', 'weather', 'Weather',
        
        # This specifies which weather is to be rendered. It is specified in the
        # form PROVIDER/ID - for the default BBC provider, it should be bbc/ID,
        # where ID is the location specific ID in the URL for that area. e.g.,
        # http://news.bbc.co.uk/weather/forecast/9 is the page for Manchester,
        # and the number at the end (9) indicates the location ID
        location_id = 'bbc/9',
        
        # This specifies where Molly gets its weather data from.

        #provider = Provider('molly.apps.weather.providers.BBCWeatherProvider',
            # This is the BBC location ID, discovered in the same way as
            # described above
        #    location_id = 9,
        #),

        provider = Provider('molly.apps.weather.providers.metoffice.MetOfficeProvider',
            forecasts_location_id = 310118,
            observations_location_id = 3658,
        ),
    ),

    # This app allows you to display service status information about your
    # systems
    Application('molly.apps.service_status', 'service-status', 'Service status',
        
        # Below, we specify the sources of service status information. Providers
        # can be repeated in order to specify multiple sources in the same format
        providers = [
            
            # The only provider that ships with Molly is one which parses RSS
            # service status feeds (http://web.resource.org/rss/1.0/modules/servicestatus/)
            Provider('molly.apps.service_status.providers.RSSModuleServiceStatusProvider',
                
                # This is the name for the group of services represented in this RSS feed
                name='IT Services',
                
                # This is a slug for this feed
                slug='itserv',
                
                # This is the source URL of the feed
                url='http://example.com/servicestatus.rss')
        ],
    ),

    # The following app enables site-wide search in Molly. It can be disabled,
    # but this does not remove UI elements that refer to it, so it is recommended
    # this is kept enabled for now
    Application('molly.apps.search', 'search', 'Search',
        
        # Below you can provide a list of sources of search results, which will
        # be tried in order
        providers = [
            
            # This provider attempts to do internal search, e.g., by matching
            # names of podcasts, places, etc. This also provides functionality
            # like bus stop code lookup and bus route lookup. It has no options.
            Provider('molly.apps.search.providers.ApplicationSearchProvider'),
            
            # This provider allows the site to use an institutional Google
            # Search Appliance, which provides full-text searching over the
            # entire site
            #Provider('molly.apps.search.providers.GSASearchProvider',
            #    # This is the URL of the GSA search endpoint
            #    search_url = 'http://gsa.example.ac.uk/search',
            #
            #    # This is the domain to search in - it should be the domain of
            #    # your Molly deployment
            #    domain = 'example.ac.uk',
            #
            #    # This is a list of extra parameters which are put in the
            #    # request sent to the Google Search Applicance - optional
            #    #params = {
            #    #    'client': 'molly',
            #    #    'frontend': 'mobile',
            #    #},
            #
            #    # This is a regex which cleans up page titles to show them in
            #    # their normal form - optional
            #    title_clean_re = r'molly \| (.*)',
            #),
        ],
        
        # A query expansion file can be specified (using Google Search Appliance
        # syntax) which is applied to the search terms before they are executed
        #query_expansion_file = os.path.join(project_root, 'data', 'query_expansion.txt'),
        
        display_to_user = False,
    ),

    # This is a utility app for Molly to support feed importing
    Application('molly.apps.feeds', 'feeds', 'Feeds',
        # The providers specify the kind of feeds this feed importer supports
        providers = [
            Provider('molly.apps.feeds.providers.RSSFeedsProvider'),
            Provider('molly.apps.feeds.providers.ICalFeedsProvider'),
            Provider('molly.apps.feeds.providers.TalksCamFeedsProvider'),
        ],
        display_to_user = False,
    ),

    # This enables the 'News' app in Molly. This has no options here, and new
    # news feeds are added to the backend at http://example.com/adm/
    Application('molly.apps.feeds.news', 'news', 'News'),
    
    # This enables the 'Events' app in Molly. This has no options here, and new
    # event feeds are added to the backend at http://example.com/adm/
    Application('molly.apps.feeds.events', 'events', 'Events'),

    # This is a utility app to support rendering maps
    Application('molly.maps', 'maps', 'Maps',
        display_to_user = False,
    ),

    # This app is a required app that allows users set their locations within
    # Molly
    Application('molly.geolocation', 'geolocation', 'Geolocation',
        
        # If you want to limit the ability of your users to set their location
        # to only the area your app covers, you can specify this below. The
        # first two parts are the latitude and longitude of the centre of your
        # area, and the last is the distance in metres which the area should be
        # limited to - this does not apply to users who set their location
        # automatically using the JavaScript Geolocation APIs
        #prefer_results_near = (-1.25821, 51.75216, 5000),
        
        # The following providers define how Molly attempts to find a user's
        # location when it's set in a freeform text box
        providers = [
            
            # This provider allows people to set their location to be the
            # same as place Molly knows about - this can be a postcode, for
            # example
            Provider('molly.geolocation.providers.PlacesGeolocationProvider'
                     
                     # The following setting limits this to certain identifier
                     # namespaces, rather than all namespaces and entity names
                     #search_identifiers=('postcode',),
            ),
            
            # This uses Cloudmade's freeform geocoding API to try and identify
            # user input
            Provider('molly.geolocation.providers.CloudmadeGeolocationProvider',

                # All parameters are optional but search_around and search_distance
                # are highly recommended
                # Central point of the search area.
                search_around = (-1.25821, 51.75216),
                # Radius of the search area. (distance in meters)
                search_distance = 20000,
                # Make a second call to the API to retrieve the name of the
                # area, for each search result
                get_area = True,
            ),
        ],
        
        # The next setting controls how often users' phones are asked for a new
        # location, in seconds
        #location_request_period = 900,
        
        display_to_user = False,
    ),
    
    # This enables Molly's feedback functionality (an e-mail feedback form)
    # This has no options
    Application('molly.apps.feedback', 'feedback', 'Feedback',
        display_to_user = False,
    ),

    # This is a utility app that allows for images to be resized to an appropriate
    # size for the phone. It has no configuration.
    Application('molly.external_media', 'external-media', 'External Media',
        display_to_user = False,
    ),

    # This app represents Molly's device detection facility
    Application('molly.wurfl', 'device-detection', 'Device detection',
        display_to_user = False,
        
        # When set to True, this exposes a single page at http://example.com/device-detection/
        # which allows users to see what phone the site thinks they are using
        # This is useful for debugging
        expose_view = True,
    ),

    # This app implements the URL shortening functionality inside Molly
    Application('molly.url_shortener', 'url-shortener', 'URL Shortener',
        display_to_user = False,
    ),

    # This app represents Molly's core utilities. It has no configuration.
    Application('molly.utils', 'utils', 'Molly utility services',
        display_to_user = False,
    ),

    # This app represents a feature voting system, where users can suggest
    # features and then vote on ones they would like to see implemented. It has
    # no configuration and is managed from the admin interface.
    Application('molly.apps.feature_vote', 'feature-suggestions', 'Feature suggestions',
        display_to_user = False,
    ),

    # This supports authentication within Molly
    Application('molly.auth', 'auth', 'Authentication',
        display_to_user = False,
        
        # This specifies that this page can only be seen over a HTTPS connection
        # when in non-debug mode
        secure = True,
        
        # The following setting determines which user identifiers are used when
        # considering if two different user sessions are indeed the same (single
        # sign on for linked services)
        unify_identifiers = ('weblearn:id',),
    ),

    # This enables mobile integration with the Sakai VLE
    #Application('molly.apps.sakai', 'sakai', 'Sakai',
    #    
    #    # This is the hostname of the Sakai endpoint to connect to
    #    host = 'https://sakai.example.ac.uk/',
    #    
    #    # This is the name which shows up in the manage authentication screen
    #    service_name = 'Sakai',
    #    
    #    # This limits access to this service to HTTPS only
    #    secure = True,
    #    
    #    # The following list defines which Sakai tools are exposed to users, and
    #    # the publicly facing name which is used
    #    tools = [
    #        ('signup', 'Sign-ups'),
    #        ('poll', 'Polls'),
    #        ('direct', 'User information'),
    #        ('sites', 'Sites'),
    #        ('evaluation', 'Surveys'),
    #    ],
    #    
    #    # The following enables OAuth integration between Sakai and Molly. Any
    #    # custom apps wishing to use OAuth can follow this template
    #    extra_bases = (
    #        ExtraBase('molly.auth.oauth.views.OAuthView',
    #            # This should be your OAuth secret token
    #            secret = '',
    #            
    #            # This is how the OAuth request is signed
    #            signature_method = OAuthSignatureMethod_PLAINTEXT(),
    #            
    #            # This is the base URL to the OAuth endpoint
    #            base_url = 'https://weblearn.ox.ac.uk/oauth-tool/',
    #            
    #            # The following 3 settings define what should be appended to the
    #            # URL above to get the request token, access token and authorise
    #            # endpoints, respectively
    #            request_token_url = 'request_token',
    #            access_token_url = 'access_token',
    #            authorize_url = 'authorize',
    #        ),
    #    ),
    #    
    #    # When set to True, this means that users will be logged out after a
    #    # period of inactivity. When False, they will stay logged in until they
    #    # manually log out
    #    enforce_timeouts = False,
    #    
    #    # The following defines the mapping between Sakai user identifiers and
    #    # Molly user identifiers
    #    identifiers = (
    #        ('oxford:sso', ('props', 'aid',)),
    #        ('weblearn:id', ('id',)),
    #        ('oxford:oss', ('props', 'oakOSSID',)),
    #        ('oxford:ldap', ('props', 'udp.dn',)),
    #        ('weblearn:email', ('email',)),
    #    ),
    #),
    
    # This app allows for users to favourite pages which can then be jumped to
    # immediately from the front page, or rendered on the nearby page. It has no
    # configuration.
    Application('molly.favourites', 'favourites', 'Favourite pages',
        display_to_user = False,
    ),
    
    # This app provides utilities to other apps which want to generate a route
    # between 2 points
    Application('molly.routing', 'routing', 'Routing',
        display_to_user = False,
    ),

]

# This is where any non-Molly apps are added to the configuration
INSTALLED_APPS = extract_installed_apps(APPLICATIONS) + INSTALLED_APPS

########NEW FILE########
__FILENAME__ = smoketest
#!/usr/bin/env python

import sys
import urllib2

USER_AGENTS={
    
    # iPhone 3 - gets smart styling
    'smart': 'Mozilla/5.0 (iPhone; U; CPU iPhone OS 3_0 like Mac OS X; en-us) AppleWebKit/528.18 (KHTML, like Gecko) Version/4.0 Mobile/7A341 Safari/528.16',
    
    # iPaq - gets dumb styling
    'dumb': 'Mozilla/4.0 (compatible; MSIE 4.01; Windows CE; PPC; 240x320; HP iPAQ h6300)',
}

URLS=[
    '/contact/',
    '/contact/results/',
    '/contact/results/?query=northwood',
    '/desktop/',
    '/feature-suggestions/',
    '/feature-suggestions/1/',
    '/feedback/',
    '/news/',
    '/news/molly/',
    '/news/molly/272/',
    '/',
    '/about/',
    '/messages/',
    '/library/',
    '/library/search/',
    '/library/search/?title=erewhon&author=&isbn=',
    '/library/item:701036753/',
    '/library/item:701036753/NLS:0Hall/',
    '/places/',
    #'/places/nearby/',
    #'/places/nearby/bus-stop/',
    '/places/category/',
    '/places/category/unit/',
    '/places/atco:9100OXFD/',
    '/places/atco:9100OXFD/?board=arrivals',
    '/places/atco:9100OXFD/nearby/',
    '/places/atco:9100OXFD/nearby/bus-stop/',
    '/places/osm:N295953659/update/',
    '/places/atco:340001903OUT/service?route=S5',
    '/places/openstreetmap/',
    #'/places/api/',
    '/podcasts/',
    '/podcasts/category:bbc-radio-1/',
    '/podcasts/radio1/moyles/',
    #'/podcasts/itunesu_redirect/',
    '/search/',
    '/search/?query=molly+project',
    '/service-status/',
    '/transport/bus/',
    '/transport/rail/',
    '/transport/park-and-ride/',
    '/weather/',
    '/webcams/',
    '/webcams/york-minster/',
    '/auth/',
    '/auth/clear-session/',
    '/favourites/',
    '/geolocation/',
    #'/geolocation/clear/',
    #'/geolocation/favourites/',
    '/maps/touchmaplite/',
    '/maps/osm/about/',
    '/maps/osm/gpx/foo/',
    '/url-shortener/?path=/',
    '/device-detection/',
    '/weblearn/',
    '/weblearn/?force_login',
]

def verify_200(url, ua):
    try:
        request = urllib2.Request(url, headers={
            'User-Agent': ua,
        })
        file = urllib2.urlopen(url)
        if file.geturl() != url:
            # Redirected
            file2 = urllib2.urlopen(file.geturl())
            if file2.geturl() != file.geturl():
                # still redirected, let's assume it's
                # not a normal behaviour?
                return file2, 300
            else:
                return file2, 200
            # avoid infinite loop
            #return verify_200(file.geturl(), ua)
        else:
            return file, 200
    except urllib2.HTTPError, e:
        return None, e.code

def smoke_test(base_url):
    tests = 0
    status = 0
    print "MOLLY SMOKER %s" % base_url
    print "------------"

    for type, ua in USER_AGENTS.items():
        print
        print "Simulating", type
        for url in URLS:
            tests += 1
            file, code = verify_200(base_url + url, ua)
            if code == 404:
                print "SKIP", url
            elif code != 200:
                status += 1
                print "FAIL", code, url
            else:
                print " OK ", code, url
    
    print "SUMMARY"
    print "-------"
    print
    print "Ran", tests, "tests"
    if status == 0:
        print "All passed - well done"
    else:
        print status, "tests failed"
    
    return status

def command(base_url='http://localhost:8000'):
    sys.exit(smoke_test(base_url))

if __name__ == "__main__":
    if len(sys.argv) > 1:
        command(base_url=sys.argv[1])
    else:
        command()

########NEW FILE########
__FILENAME__ = testlanguage
#!/usr/bin/env python
# coding: utf-8

from codecs import open

INVERSIONS = dict(zip(
    [ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 
    'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
    'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
    '1','2','3','4','5','6','7','8','9','0',
    '!','?','"',',','\'',')','(','_','^',
    
    '[',']','{','}','\\','/','<','>','.']
    ,
    
    [ u'ɐ', u'q', u'ɔ', u'p', u'ə', u'ɟ', u'ƃ', u'ɥ', u'ı', u'ɾ', u'ʞ', u'l', 
    u'ɯ', u'u', u'o', u'd', u'b', u'ɹ', u's', u'ʇ', u'n', u'ʌ', u'ʍ', u'x', u'ʎ', u'z',
    u'∀', u'q', u'Ɔ', u'p', u'Ǝ', u'Ⅎ', u'פ', u'H', u'I', u'ſ', u'丬', u'˥', u'W', u'N',
    u'O', u'Ԁ', u'Ό', u'ᴚ', u'S', u'⊥', u'∩', u'Λ', u'M', u'X', u'ʎ', u'Z',
    u'Ɩ', u'ᄅ', u'Ɛ', u'ㄣ', u'ϛ', u'9', u'Ɫ', u'8', u'6', u'0',
    u'¡', u'¿', u'„', u'\'', u',', u'(', u')', u'‾', u'v',
    
    u']', u'[', u'}', u'{', u'/', u'\\\\', u'>', u'<', u'˙']
))

def invert(chars):
    r = u''
    in_formatter = 0
    for char in chars:
        if char in ('%', '<'):
            in_formatter = 1
        if in_formatter > 0:
            r += char
            if in_formatter == 2:
                in_formatter = 0
            if char == ')':
                in_formatter = 2
            if char == '>':
                in_formatter = 0
        else:
            r += INVERSIONS.get(char, char)
    return r

def command(language_file):
    import sys
    
    msgs = []
    this_msg = ''
    this_plural = ''
    in_msgid = False
    
    with open(language_file, encoding='utf-8') as fd:
        for line in fd:
            if line[:12] == 'msgid_plural':
                in_msgid = 'p'
                this_plural += line[14:-2] + '\n'
            elif line[:5] == 'msgid':
                in_msgid = 's'
                this_msg += line[7:-2] + '\n'
            elif line[:6] == 'msgstr':
                in_msgid = False
                if this_msg or this_plural:
                    msgs.append((this_msg, this_plural))
                this_msg = ''
                this_plural = ''
            elif in_msgid:
                if in_msgid == 's':
                    this_msg += line[1:-2] + '\n'
                else:
                    this_plural += line[1:-2] + '\n'
    with open(language_file, 'w', encoding='utf-8') as fd:
        print >>fd, """
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\\n"
"Report-Msgid-Bugs-To: \\n"
"POT-Creation-Date: 2011-05-26 18:56+0100\\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n"
"Language-Team: LANGUAGE <LL@li.org>\\n"
"Language: \\n"
"MIME-Version: 1.0\\n"
"Content-Type: text/plain; charset=UTF-8\\n"
"Content-Transfer-Encoding: 8bit\\n"
"""
        for msg, plural in msgs:
            if msg == '\n':
                continue
            print >>fd, "msgid ",
            for line in msg.split('\n')[:-1]:
                print >> fd, "\"%s\"" % line
            if plural:
                print >>fd, "msgid_plural ",
                for line in plural.split('\n')[:-1]:
                    print >> fd, "\"%s\"" % line
                print >>fd, "msgstr[0] ",
                for line in invert(msg).split('\n')[:-1]:
                    print >> fd, "\"%s\"" % line
                print >>fd, "msgstr[1] ",
                for line in invert(plural).split('\n')[:-1]:
                    print >> fd, "\"%s\"" % line
            else:
                print >>fd, "msgstr ",
                for line in invert(msg).split('\n')[:-1]:
                    print >> fd, "\"%s\"" % line

########NEW FILE########
__FILENAME__ = admin
from celery.app import current_app
from molly.conf.celery_util import init_providers
from djcelery.admin import PeriodicTaskAdmin


def run_now(modeladmin, request, queryset):
    app = current_app()
    for pt in queryset:
        try:
            app.tasks[pt.task].apply_async()
        except KeyError:
            init_providers()
            app.tasks[pt.task].apply_async()
run_now.short_description = "Place this task on queue to run now."


class RunnablePeriodicTaskAdmin(PeriodicTaskAdmin):
    actions = [run_now]

########NEW FILE########
__FILENAME__ = applications
from __future__ import with_statement

from threading import Lock

from django.conf import settings as django_settings

__all__ = [
    'app_by_local_name',
    'app_by_application_name',
    'apps_by_application_name',
    'all_apps',
    'get_app',
    'applications',
    'has_app_by_local_name',
    'has_app_by_application_name',
    'has_app',
]

_load_lock = Lock()
_by_local_name = {}
_by_application_name = {}

def _require_loaded_apps(f):
    def g(*args, **kwargs):
        if not _loaded:
            _load_apps()
        return f(*args, **kwargs)
    return g

def _load_app(filter_func):
    with _load_lock:
        for application in django_settings.APPLICATIONS:
            if not filter_func(application):
                continue
            app = application.get()
            _by_local_name[app.local_name] = app
            if not app.application_name in _by_application_name:
                _by_application_name[app.application_name] = []
            _by_application_name[app.application_name].append(app)

def app_by_local_name(local_name):
    try:
        return _by_local_name[local_name]
    except KeyError:
        _load_app(lambda app: app.local_name == local_name)
        return _by_local_name[local_name]

def app_by_application_name(application_name):
    try:
        return _by_application_name[application_name][0]
    except KeyError:
        _load_app(lambda app: app.application_name == application_name)
        return _by_application_name[application_name][0]

def apps_by_application_name(application_name):
    try:
        return _by_application_name[application_name]
    except KeyError:
        _load_app(lambda app: app.application_name == application_name)
        return _by_application_name[application_name]

def get_app(application_name=None, local_name=None):
    if local_name:
        return app_by_local_name(local_name)
    else:
        return app_by_application_name(application_name)

def all_apps():
    return [app.get() for app in django_settings.APPLICATIONS]

def has_app_by_application_name(application_name):
    try:
        app_by_application_name(application_name)
    except KeyError:
        return False
    else:
        return True

def has_app_by_local_name(local_name):
    try:
        app_by_local_name(local_name)
    except KeyError:
        return False
    else:
        return True

def has_app(application_name=None, local_name=None):
    if local_name:
        return has_app_by_local_name(local_name)
    else:
        return has_app_by_application_name(application_name)

class Applications(object):
    def __getattr__(self, key):
        return app_by_local_name(key)
    __getitem__ = __getattr__

applications = Applications()

########NEW FILE########
__FILENAME__ = celery_util
import djcelery

from molly.conf.applications import all_apps
from celery.signals import beat_init, worker_init


def init_providers():
    """Calls all the providers which in turns registers any Celery tasks
    attached to that provider.
    """
    for app in all_apps():
        for p in app.providers:
            p()


def celeryd_discover_tasks(sender=None, conf=None, **kwargs):
    init_providers()


def beat_update_schedule(sender=None, conf=None, **kwargs):
    """Calling get_schedule will sync the schedule with any discovered tasks."""
    celeryd_discover_tasks()
    sender.get_scheduler().get_schedule()


def prepare_celery():
    """Runs the djcelery loader which is required to set the correct backend/scheduler
    Then adds some signal callbacks to ensure all tasks are registered correctly.
    """
    djcelery.setup_loader()
    beat_init.connect(beat_update_schedule)
    worker_init.connect(celeryd_discover_tasks)

########NEW FILE########
__FILENAME__ = default_settings
# default_settings.py: Default Django settings that it makes sense to apply
# across all installations.

# This refers to Django's 'Site' framework, which Molly does not use. It is
# recommended to leave this at its default setting
SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale
USE_L10N = True

# When set, then a version number is added to compressed files, this means
# changing a file also changes its URL - when combined with far future expires,
# then this solves caching issues
PIPELINE_VERSION = True

# We set this to False for a performance optimisation - we don't want CSS and JS
# to be regenerated on the server, just once at deploy time. If you do want
# this, then change it to True
PIPELINE_AUTO = False

# This list is used to specifiy which classes are used to help Django find
# templates to be rendered. In most circumstances, there is no reason to change
# this
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader', # First try the templates in the directories specified by TEMPLATE_DIRS
    'django.template.loaders.app_directories.Loader', # Then try the ones that come with the bundled apps
    'molly.utils.template_loaders.MollyDefaultLoader' # Finally, use Molly's molly_default virtual directory
)

# This specifies that Django should use Molly's automatically generated Urlconf
# If you're using any non-Molly apps with Molly, you will need to create a
# custom Urlconf
ROOT_URLCONF = 'molly.urls'

# This defines the view that is rendered when a CSRF validation failure occurs
# The default is to use Molly's default templates. If you want to change this
# view, it is instead recommended that you create a new template
# 'csrf_failure.html' in your templates folder and customise that
CSRF_FAILURE_VIEW = 'molly.utils.views.CSRFFailureView'

# This disables Django's built in logger, as Molly comes with its own logging
# framework which can sometimes conflict with Django's
LOGGING_CONFIG = None

# This list specifies which Django middleware clases are used when processing
# requests and responses. For more information about Django middleware, please
# see https://docs.djangoproject.com/en/dev/topics/http/middleware/
# The defaults are fine for most installs
MIDDLEWARE_CLASSES = (
    'django.middleware.csrf.CsrfViewMiddleware', # This enables Django's cross-site request forgery protection framework
    'molly.wurfl.middleware.WurflMiddleware', # This enables Molly's device detection capability (required)
    'django.middleware.common.CommonMiddleware', # This incorporates some convenience functions from Django (required)
    'django.contrib.sessions.middleware.SessionMiddleware', # This enables Django's session storage framework (required)
    'molly.utils.middleware.LocationMiddleware', # This annotates requests with a user_location attribute
    'molly.utils.middleware.CookieLocaleMiddleware', # This enables i18n support in Molly (required)
    'molly.utils.middleware.ErrorHandlingMiddleware', # This enables Molly's error handling and reporting framework
    'django.contrib.auth.middleware.AuthenticationMiddleware', # This allows for users to be logged in in Django (required)
    'molly.auth.middleware.SecureSessionMiddleware', # This adds the capability to have secure sessions (sessions which are HTTPS only)
    'molly.url_shortener.middleware.URLShortenerMiddleware', # This enables Molly's URL shortening functionality
)

# This list specifies "context processors" which add things to the context which
# are then available in the templates. The defaults are fine for most installs.
TEMPLATE_CONTEXT_PROCESSORS = (
    'django.contrib.auth.context_processors.auth', # This adds information about the currently logged in user to the context
    'django.core.context_processors.debug', # This allows templates to check whether or not they are in debug mode
    'django.core.context_processors.request', # This adds the current request to the template context
    'molly.utils.context_processors.ssl_media', # This adds STATIC_URL to the template context, which is the base URL to be used for rendering
                                                # when the request is over HTTPS, then STATIC_URL is also changed to be HTTPS if it's a full URI
    'molly.wurfl.context_processors.wurfl_device', # This adds information about the current device to the context
    'molly.wurfl.context_processors.device_specific_media', # This adds information to the context about the capability group this device has been put in
                                                            # for more information about capability groups, see: http://docs.mollyproject.org/dev/topics/supported_devices.html
    'molly.geolocation.context_processors.geolocation', # This adds the current known location of the user to the context
    'molly.utils.context_processors.full_path', # This allows for templates to know the full path to the currently rendered page
    'molly.utils.context_processors.google_analytics', # This adds settings related to Google Analytics to the template contect
    'molly.utils.context_processors.site_name', # This adds the globally configured site name to the template context
    'molly.utils.context_processors.languages', # This adds information about the current and available languages to the context
    'django.core.context_processors.csrf', # This adds a CSRF token to the context which is used for form rendering
)

INSTALLED_APPS = (
    'django.contrib.auth', # Django's user authentication system
    'django.contrib.admin', # Django's admin backend
    'django.contrib.contenttypes', # Django's Content Types API - this is a prerequisite for the admin interface
    'django.contrib.sessions', # Django's sessions API - this is required
    'django.contrib.sites', # Django's sites API, this is a prerequisite for the comments API
    'django.contrib.gis', # Geodjango - this is required
    'django.contrib.comments', # Django's comments API - used in the feature vote app
    'django.contrib.staticfiles', # Staticfiles handles media for Molly
    'pipeline', # Pipeline is an external library that minifies JS and CSS
    'south', # South handles changes to database schema
    'djcelery', # Celery tasks run our periodic batch processing
)

# Don't do South migrations when running unit tests - just do a syncdb
# See http://south.aeracode.org/docs/settings.html#south-tests-migrate
SOUTH_TESTS_MIGRATE = False

########NEW FILE########
__FILENAME__ = provider
try:
    import json
except ImportError:
    import simplejson as json

from django.conf import settings
from djcelery.models import PeriodicTask as PerodicTaskModel
from celery.task import PeriodicTask, Task
from celery.app import current_app


class Provider(object):

    def __call__(self):
        return self

    @classmethod
    def register_tasks(cls, *args, **kwargs):
        """Constructor, looks for decorated tasks and registers them with Celery,
        this is done in a non-standard way as Celery tasks can only be functions, not methods.

        Tasks with the run_every option set are subclasses of BatchTask which
        handles storing a cache of metadata between each task execution.
        """
        ins = cls(*args, **kwargs)
        for attr_name in dir(cls):
            if callable(getattr(cls, attr_name)):
                fun = getattr(cls, attr_name)
            else:
                continue
            if hasattr(fun, 'task'):
                # This is a decorated method
                periodic_task = 'run_every' in fun.task
                name = "%s.%s.%s" % (cls.__module__, cls.__name__, attr_name)
                new_attr_name = '__task_%s' % attr_name
                if periodic_task:
                    base = BatchTask

                    def run(self, **kwargs):
                        meth = getattr(self.provider, self.true_method)
                        metadata = self.get_metadata()
                        try:
                            return meth(**metadata)
                        except Exception, exc:
                            self.get_logger().warning(
                                    "Exception raised, retrying: %s" % exc)
                            self.retry(exc=exc, countdown=self.default_retry_delay,
                                    max_retries=self.max_retries)
                else:
                    base = Task

                    def run(self, *args, **kwargs):
                        meth = getattr(self.provider, self.true_method)
                        try:
                            return meth(*args)
                        except Exception, exc:
                            self.get_logger().warning(
                                    "Exception raised, retrying: %s" % exc)
                            self.retry(exc=exc, countdown=self.default_retry_delay,
                                    max_retries=self.max_retries)

                def __init__(self, provider=ins, base=base, kwargs=fun.task):
                    self.provider = provider
                    self.metadata = kwargs.get('initial_metadata', dict())
                    self.run_every = kwargs.get('run_every', None)
                    base.__init__(self)  # Only 1 base class, so this is safe.
                    self.default_retry_delay = kwargs.get('default_retry_delay',
                            settings.CELERY_RETRY_DELAY)
                    self.max_retries = kwargs.get('max_retries',
                            settings.CELERY_MAX_RETRIES)
                t = type(name, (base,), {'__init__': __init__,
                    '__module__': cls.__module__,
                    'run': run,
                    'name': name,
                    'true_method': new_attr_name,
                    })
                # We rename the decorated method to __task_<method_name>
                # and set the old method to the Task instance.
                setattr(ins, new_attr_name, getattr(ins, attr_name))
                setattr(ins, attr_name, t())
        return ins


class BatchTask(PeriodicTask):
    """Subclass of Celery's PeriodicTask which handles a local
    cache of metadata. This metadata is stored in the kwargs field on the
    djcelery.PeriodicTask model as JSON encoded kwargs.

    Our task metadata represents the return values from each task execution.
    This means you can cache (for example an ETag - see OSM provider) between
    task runs and save making uncecessary calls. Metadata is provided as the
    keyword arguments to all BatchTasks

    Tasks decorated which don't specify 'run_every' cannot store metadata.
    """
    abstract = True

    def get_metadata(self):
        """Metadata getter, the null value for metadata is an empty dict"""
        pt = PerodicTaskModel.objects.get(task=self.name)
        metadata = pt.kwargs or self.metadata
        if metadata:
            return json.loads(metadata)
        else:
            return {}

    def set_metadata(self, metadata, expires=None):
        PerodicTaskModel.objects.filter(task=self.name).update(
                kwargs=json.dumps(metadata))

    def after_return(self, status, value, *args, **kwargs):
        if value and isinstance(value, dict):
            try:
                self.set_metadata(value)
            except:
                self.get_logger().exception("Unable to store metadata.")


def task(**kwargs):
    """Sets a .task attribute on each function decorated, this indictes
    this function should be registered as a task with Celery

    TODO: Extend this functionality to implement a wrapping function to
    capture the kwargs passed through by celery.
    """
    def dec(fun):
        fun.task = kwargs
        return fun
    return dec


def queue_post_save(cls):
    """Overrides the save method, attempts to find the correct provider and
    schedule all periodic tasks to run on that provider.
    Use case: Add/Edit a Feed object and update the feeds

    NOTE: We use update_last_modified so we don't recursively queue this task
    """
    original_save = cls.save

    def save(self, update_last_modified=False, *arg, **kwargs):
        if not update_last_modified:
            app = current_app()
            provider = self.provider.split('.')[-1]
            for task in app.tasks:
                try:
                    if not app.tasks[task].run_every and task.find(provider) != -1:
                        app.tasks[task].apply_async(args=(self,))
                except:
                    pass
        return original_save(self, *arg, **kwargs)
    cls.save = save
    return cls

########NEW FILE########
__FILENAME__ = settings
import imp

from django.utils.importlib import import_module
from django.conf.urls.defaults import include as urlconf_include
from django.core.urlresolvers import RegexURLResolver, RegexURLPattern
from django.conf import settings

"""
Provides a framework for Molly application objects.

An Application object wraps a Django application, and allows Molly to
extend an application with configuration information, and add extra base
classes to views to mix-in deployment-specific functionality.
"""

# This module does a lot of dynamically creating class objects using the
# second form of the 'type' function.[0]
#
# [0] http://docs.python.org/library/functions.html#type

class ApplicationConf(object):
    pass

class Application(object):
    def __init__(self, application_name, local_name, title, **kwargs):
        self.application_name, self.local_name = application_name, local_name
        self.title = title

        self.authentication = kwargs.pop('authentication', None)
        self.secure = kwargs.pop('secure', False)
        self.extra_bases = kwargs.pop('extra_bases', ())
        self.urlconf = kwargs.pop('urlconf', application_name+'.urls')
        self.kwargs = kwargs
        self.conf = None

        kwargs['display_to_user'] = kwargs.get('display_to_user', True)

        self.providers = kwargs.pop('providers', ())
        for key in kwargs.copy():
            if key == 'provider':
                self.providers += (kwargs.pop(key),)

    def get(self):
        if self.conf:
            return self.conf

        providers = []
        for provider in self.providers:
            if isinstance(provider, ProviderConf):
                providers.append(provider())
            else:
                providers.append(ProviderConf(provider)())

        bases = tuple(base() for base in self.extra_bases)
        if self.secure:
            from molly.auth.views import SecureView
            bases = (SecureView,) + bases

        has_urlconf = self._module_exists(self.urlconf)
        if not has_urlconf and self._module_exists(self.application_name+'.views'):
            views = import_module(self.application_name+'.views')
            patterns = [getattr(views, v).pattern for v in dir(views) if hasattr(getattr(views, v), 'pattern')]
            
            if len(patterns):
                urls = self._get_urls_property(bases, patterns)
            else:
                urls = None
        
        elif has_urlconf:
            urls = self._get_urls_property(bases, import_module(self.urlconf).urlpatterns)
        
        else:
            urls = None

        self.kwargs.update({
            'application_name': self.application_name,
            'local_name': self.local_name,
            'title': self.title,
            'providers': providers,
            'provider': providers[-1] if len(providers) else None,
            'urls': urls,
            'has_urlconf': urls is not None,
        })
        
        # Handle "other" providers - i.e., singletons which end with
        # 'provider' and perhaps provide specialised providers
        for key in self.kwargs:
            if key != 'provider' and key.endswith('provider'):
                provider = self.kwargs[key]
                if not isinstance(provider, ProviderConf):
                    provider = ProviderConf(provider)
                providers.append(provider())
                self.kwargs[key] = provider()
        self.conf = type(self.local_name.capitalize()+'Conf', (ApplicationConf,), self.kwargs)()

        for provider in self.conf.providers:
            provider.conf = self.conf

        self.conf.display_to_user = self.kwargs['display_to_user'] and self.kwargs['has_urlconf']

        return self.conf

    def add_conf_to_pattern(self, pattern, conf, bases):
        """
        Coalesces an Application's configuration with the views in its urlconf.

        Takes a RegexURLPattern or RegexURLResolver, a conf object and a tuple
        of extra base classes to inherit from. Returns an object of the same
        type as its first argument with callbacks replaced with new views using
        conf and bases.
        """

        # Don't import at module scope as this module will be imported from a
        # settings file.
        from molly.utils.views import BaseView

        if isinstance(pattern, RegexURLResolver):
            # Recurse through the patterns
            patterns = []
            for subpattern in pattern.url_patterns:
                patterns.append(self.add_conf_to_pattern(subpattern, conf, bases))
            # Create a new RegexURLResolver with the new patterns
            return RegexURLResolver(pattern.regex.pattern, # The regex pattern string
                                    patterns,
                                    pattern.default_kwargs,
                                    pattern.app_name,
                                    pattern.namespace)
        elif isinstance(pattern, RegexURLPattern):
            # Get the callback and make sure it derives BaseView
            callback = pattern.callback
            if not issubclass(callback, BaseView):
                return callback
            
            if bases:
                # Create a new callback with the extra bases
                callback = type(callback.__name__ + 'Extended', (callback,) + bases, {})
                callback.__module__ = pattern.callback.__module__
            
            # Instantiate the callback with the conf object
            callback = callback(conf)
                
            # Transplant this new callback into a new RegexURLPattern, keeping
            # the same regex, default_args and name.
            return RegexURLPattern(pattern.regex.pattern,
                                   callback,
                                   pattern.default_args,
                                   pattern.name)
        else:
            raise TypeError("Expected RegexURLResolver or RegexURLPattern instance, got %r." % type(pattern))

    def _get_urls_property(self, bases, urlpatterns):
        """
        Returns a property object that will load and cache the urlconf for an app.

        This will add base classes to the views as necessary and pass the conf to
        each view instance.
        """

        @property
        def urls(conf):
            if hasattr(conf, '_urls_cache'):
                return conf._urls_cache
            new_urlpatterns = []
            for pattern in urlpatterns:
                # Call to recursively apply the conf and bases to each of the
                # views referenced in the urlconf.
                new_urlpatterns.append(self.add_conf_to_pattern(pattern, self.conf, bases))
            conf._urls_cache = urlconf_include(new_urlpatterns, app_name=self.application_name.split('.')[-1], namespace=self.local_name)
            return conf._urls_cache
        return urls
    
    def _module_exists(self, module_name):
        """
        Returns True iff module_name exists (but isn't necessarily importable).
        """

        # imp.find_module doesn't handle hierarchical module names, so we split
        # on full stops and keep feeding it the path it returns until we run
        # out of module name.

        module_name, path = module_name.split('.'), None
        while module_name:
            try:
                path = [imp.find_module(module_name.pop(0), path)[1]]
            except ImportError, e:
                return False
        return True

class Authentication(object):
    def __init__(klass, **kwargs):
        pass

class ExtraBase(object):
    def __init__(self, klass, **kwargs):
        self.klass, self.kwargs = klass, kwargs

    def __call__(self):
        mod_name, cls_name = self.klass.rsplit('.', 1)
        module = import_module(mod_name)
        klass = getattr(module, cls_name)
        base = type(cls_name, (klass,), self.kwargs)
        base.__module__ = mod_name
        return base

def extract_installed_apps(applications):
    return tuple(app.application_name for app in applications)

class ProviderConf(object):
    def __init__(self, klass, **kwargs):
        self.klass, self.kwargs = klass, kwargs

    def __call__(self):
        try:
            return self._provider
        except:
            mod_name, cls_name = self.klass.rsplit('.', 1)
            module = import_module(mod_name)
            klass = getattr(module, cls_name)
            self._provider = klass.register_tasks(**self.kwargs)
            self._provider.class_path = self.klass
            return self._provider

########NEW FILE########
__FILENAME__ = test_settings
from molly.commands.site_template.settings import *
from os import path

DATABASES = {
    'default': {
        'ENGINE': 'django.contrib.gis.db.backends.postgis',
        'NAME': 'molly',
        'USER': 'postgres'
    }
}

TEST_RUNNER = 'discover_runner.DiscoverRunner'
TEST_DISCOVER_TOP_LEVEL = path.dirname(path.dirname(__file__))
TEST_DISCOVER_ROOT = TEST_DISCOVER_TOP_LEVEL

########NEW FILE########
__FILENAME__ = urls
from django.core.urlresolvers import RegexURLPattern

def url(pattern, name=None, extra={}):
    
    def url_annotator(view):
        view.pattern = RegexURLPattern(pattern, view, extra, name)
        return view
    
    return url_annotator

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'ExternalImage'
        db.create_table('external_media_externalimage', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('url', self.gf('django.db.models.fields.URLField')(max_length=200)),
            ('etag', self.gf('django.db.models.fields.TextField')(null=True)),
            ('last_modified', self.gf('django.db.models.fields.TextField')(null=True)),
            ('last_updated', self.gf('django.db.models.fields.DateTimeField')()),
            ('width', self.gf('django.db.models.fields.PositiveIntegerField')(null=True)),
            ('height', self.gf('django.db.models.fields.PositiveIntegerField')(null=True)),
        ))
        db.send_create_signal('external_media', ['ExternalImage'])

        # Adding model 'ExternalImageSized'
        db.create_table('external_media_externalimagesized', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('external_image', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['external_media.ExternalImage'])),
            ('width', self.gf('django.db.models.fields.PositiveIntegerField')()),
            ('height', self.gf('django.db.models.fields.PositiveIntegerField')()),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=50, db_index=True)),
            ('content_type', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('external_media', ['ExternalImageSized'])


    def backwards(self, orm):
        
        # Deleting model 'ExternalImage'
        db.delete_table('external_media_externalimage')

        # Deleting model 'ExternalImageSized'
        db.delete_table('external_media_externalimagesized')


    models = {
        'external_media.externalimage': {
            'Meta': {'object_name': 'ExternalImage'},
            'etag': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modified': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {}),
            'url': ('django.db.models.fields.URLField', [], {'max_length': '200'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True'})
        },
        'external_media.externalimagesized': {
            'Meta': {'object_name': 'ExternalImageSized'},
            'content_type': ('django.db.models.fields.TextField', [], {}),
            'external_image': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['external_media.ExternalImage']"}),
            'height': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'width': ('django.db.models.fields.PositiveIntegerField', [], {})
        }
    }

    complete_apps = ['external_media']

########NEW FILE########
__FILENAME__ = models
from __future__ import division

import os.path
import random
import urllib
from datetime import datetime
try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

from PIL import Image

from django.db import models
from django.conf import settings
from django.core.urlresolvers import reverse


class ExternalImage(models.Model):
    url = models.URLField()
    etag = models.TextField(null=True)
    last_modified = models.TextField(null=True)
    last_updated = models.DateTimeField() # This one is in UTC
    width = models.PositiveIntegerField(null=True)
    height = models.PositiveIntegerField(null=True)

    def save(self, force_insert=False, force_update=False, *args, **kwargs):
        self.last_updated = datetime.utcnow()
        super(ExternalImage, self).save(force_insert=False, force_update=False, **kwargs)


def get_external_image_dir():
    return getattr(settings, 'EXTERNAL_IMAGE_DIR', os.path.join(settings.CACHE_DIR, 'external_images'))


class ExternalImageSized(models.Model):
    external_image = models.ForeignKey(ExternalImage)
    width = models.PositiveIntegerField()
    height = models.PositiveIntegerField()
    slug = models.SlugField()
    content_type = models.TextField()

    def get_filename(self):
        external_image_dir = get_external_image_dir()
        if not self.slug:
            while not self.slug or ExternalImageSized.objects.filter(slug=self.slug).count():
                self.slug = "%08x" % random.randint(0, 16**8-1)
        if not os.path.exists(external_image_dir):
            os.makedirs(external_image_dir)
        return os.path.join(external_image_dir, self.slug)

    def get_absolute_url(self):
        return reverse('external_media:image', args=[self.slug])

    def save(self, force_insert=False, force_update=False, *args, **kwargs):
        if not self.id:
            response = urllib.urlopen(self.external_image.url)
            data = StringIO(response.read())
            im = Image.open(data)

            size = im.size
            ratio = size[1] / size[0]

            if self.width >= size[0]:
                resized = im
            else:
                try:
                    resized = im.resize((self.width, int(round(self.width*ratio))), Image.ANTIALIAS)
                except IOError, e:
                    if e.message == "cannot read interlaced PNG files":
                        # Ain't nothing can be done until you upgrade PIL to 1.1.7
                        resized = im
                    else:
                        raise
            self.width, self.height = resized.size

            try:
                resized.save(self.get_filename(), format='jpeg')
                self.content_type = 'image/jpeg'
            except IOError, e:
                try:
                    resized.convert('RGB').save(self.get_filename(), format='jpeg')
                    self.content_type = 'image/jpeg'
                except IOError:
                    open(self.get_filename(), 'wb').write(data.getvalue())
                    self.content_type = response.headers['content-type']

            self.external_image.width = size[0]
            self.external_image.height = size[1]

        super(ExternalImageSized, self).save(force_insert=False, force_update=False, **kwargs)

    def delete(self):
        try:
            os.unlink(self.get_filename())
        except OSError:
            # Ignore errors where we're trying to delete a file that's already
            # been deleted
            pass
        super(ExternalImageSized, self).delete()

########NEW FILE########
__FILENAME__ = molly_external_media
from logging import getLogger

from django import template

from molly.external_media import resize_external_image

register = template.Library()

logger = getLogger(__name__)

@register.tag(name='external_image')
def external_image(parser, token):
    args = token.split_contents()
    if not len(args) in (2, 3, 4):
        raise template.TemplateSyntaxError, "%r takes one argument (the image location)" % token.contents.split()[0]

    try:
        max_width = template.Variable(args[2])
    except (ValueError, IndexError):
        max_width = None
    if 'asdiv' in args:
        return ExternalImageNode(template.Variable(args[1]), max_width, False)
    else:
        return ExternalImageNode(template.Variable(args[1]), max_width)


class ExternalImageNode(template.Node):
    """
    Takes the form {% external_image url %} and renders as a URL pointing at
    the given image resized to match the device's max_image_width.
    """

    def __init__(self, url, max_width, just_url=True):
        self.url, self.max_width, self.just_url = url, max_width, just_url

    def render(self, context):
        try:
            width = int(self.max_width.resolve(context))
        except Exception:
            width = float('inf')

        url, width = self.url.resolve(context), min(width, context['device'].max_image_width)
        
        try:
            eis = resize_external_image(url, width)
        except IOError:
            logger.warn('Resizing external image failed', exc_info=True)
            eis = None

        if self.just_url:
            return eis.get_absolute_url() if eis != None else url
        elif eis is None:
            return """<div class="backgrounded-image" style="background-image:url('%s');"> </div>""" % (eis.get_absolute_url() if eis != None else url)
        else:
            return """<div class="backgrounded-image" style="background-image:url('%s'); height:%dpx"> </div>""" % (eis.get_absolute_url(), eis.height)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from views import IndexView, ExternalImageView

urlpatterns = patterns('',
    (r'^$',
        IndexView, {},
        'index'),

    (r'^external_images/(?P<slug>[0-9a-f]{8})/$',
        ExternalImageView, {},
        'image'),

)

########NEW FILE########
__FILENAME__ = views
from email.utils import formatdate
from datetime import datetime, timedelta
from time import mktime

from django.shortcuts import get_object_or_404
from django.http import HttpResponse, Http404

from molly.utils.views import BaseView
from molly.utils.breadcrumbs import NullBreadcrumb

from models import ExternalImageSized


class IndexView(BaseView):
    breadcrumb = NullBreadcrumb

    def handle_GET(self, request, context):
        raise Http404


class ExternalImageView(BaseView):

    breadcrumb = NullBreadcrumb

    def handle_GET(self, request, context, slug):
        eis = get_object_or_404(ExternalImageSized, slug=slug)
        try:
            response = HttpResponse(open(eis.get_filename(), 'rb').read(),
                                    mimetype=eis.content_type.encode('ascii'))
        except IOError:
            eis.delete()
            raise Http404()

        response['ETag'] = slug
        response['Expires'] = formatdate(mktime((datetime.now() + timedelta(days=7)).timetuple()))
        response['Last-Modified'] = formatdate(mktime(eis.external_image.last_updated.timetuple()))
        return response

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Favourite'
        db.create_table('favourites_favourite', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['auth.User'])),
            ('url', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('favourites', ['Favourite'])


    def backwards(self, orm):
        
        # Deleting model 'Favourite'
        db.delete_table('favourites_favourite')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'favourites.favourite': {
            'Meta': {'object_name': 'Favourite'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'url': ('django.db.models.fields.TextField', [], {}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['auth.User']"})
        }
    }

    complete_apps = ['favourites']

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.contrib.auth.models import User
from django.http import Http404
from django.core.urlresolvers import resolve

class Favourite(models.Model):
    """
    A record of a favourite page
    """
    
    user = models.ForeignKey(User)
    url = models.TextField()
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from views import IndexView

urlpatterns = patterns('',
    (r'^$',
        IndexView, {},
        'index'),
    )
########NEW FILE########
__FILENAME__ = views
import logging

from django.http import Http404
from django.core.urlresolvers import resolve, reverse
from django.utils.translation import ugettext as _

from molly.utils.views import BaseView
from molly.utils.breadcrumbs import lazy_reverse, Breadcrumb, BreadcrumbFactory

from molly.favourites import get_favourites
from molly.favourites.models import Favourite

logger = logging.getLogger(__name__)

class FavouritableView(BaseView):
    """
    A view to inherit from if you want to be favouritable
    """
    
    def initial_context(self, request, *args, **kwargs):
        
        context = super(FavouritableView, self).initial_context(request, *args, **kwargs)
        
        # Add whether or not this is favouritable to the context
        context['is_favouritable'] = True
        
        # Also, add whether or not this particular thing already is favourited
        context['is_favourite'] = request.path_info in [f.url for f in get_favourites(request)]
        
        # And the URL of this page (so it can be favourited)
        context['favourite_url'] = request.path_info
        
        return context

class IndexView(BaseView):
    """
    Allows for favourites management
    """
    
    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name,
            None,
            _('Favourites'),
            lazy_reverse('index'),
        )
    
    def handle_GET(self, request, context):
        """
        Show a list of favourited things, and allow removal of these
        """
        context['favourites'] = get_favourites(request)
        return self.render(request, context, 'favourites/index')
    
    def handle_POST(self, request, context):
        """
        Add and remove favourites. Favourites are stored as URLs (the part of
        them Django is interested in anyway) in the database, if the user is
        logged in - otherwise, it is stored in the session, and then migrated
        to the database when the user logs in. This has the downside of breaking
        favourites if URLs change.
        """
        
        # Alter favourites list
        if 'URL' in request.POST:
            if 'favourite' in request.POST:
                # Add
                try:
                    resolve(request.POST['URL'])
                except Http404:
                    # This means that they tried to save a URL that doesn't exist
                    # or isn't on our site
                    logger.debug('Attempted to favourite a non-existant URL')
                    return self.redirect(lazy_reverse('favourites:index'), request)
                else:
                    if request.user.is_anonymous():
                        logger.debug('User is anonymous, storing favourites in session')
                        if 'favourites' not in request.session:
                            request.session['favourites'] = set()
                        request.session['favourites'].add(request.POST['URL'])
                        request.session.modified = True
                    else:
                        logger.debug('User is logged in, storing favourites in database')
                        Favourite(user=request.user, url=request.POST['URL']).save()
            
            elif 'unfavourite' in request.POST:
                if not request.user.is_anonymous():
                    try:
                        favourite = Favourite.objects.get(user=request.user,
                                                          url = request.POST['URL'])
                    except Favourite.DoesNotExist:
                        pass
                    else:
                        favourite.delete()
                else:
                    if request.POST['URL'] in request.session.get('favourites', set()):
                        request.session['favourites'].remove(request.POST['URL'])
                        request.session.modified = True
        
            # If the source was the favourites page, redirect back there
            if 'return_to_favourites' in request.POST:
                return self.redirect(reverse('favourites:index'), request)
            
            # else the source
            else:
                return self.redirect(request.POST['URL'], request)
            
        else:
            # Missing POST data, probably a bad request
            return self.redirect(reverse('favourites:index'), request)

########NEW FILE########
__FILENAME__ = context_processors
from datetime import datetime, timedelta

from molly.conf import app_by_application_name

def geolocation(request):
    """
    Provides location-based information to the template (i.e. lat/long, google
    placemark data, and whether we would like to request the device's location
    information.
    """

    # Use the epoch in the place of -inf; a time it has been a while since.
    epoch = datetime(1970,1,1, 0, 0, 0)
    
    # Only request a location if our current location is older than one minute
    # and the user isn't updating their location manually.
    # The one minute timeout applies to the more recent of a request and an
    # update.
    
    location = request.session.get('geolocation:location')
    requested = request.session.get('geolocation:requested', epoch)
    updated = request.session.get('geolocation:updated', epoch)
    method = request.session.get('geolocation:method')

    period = getattr(app_by_application_name('molly.geolocation'), 'location_request_period', 180)    
    
    if max(requested, updated) + timedelta(0, period) < datetime.now() \
     and method in ('html5', 'gears', 'html5request', None):
        require_location = True
        request.session['geolocation:requested'] = datetime.now()
    else:
        require_location = False
    return {
        'require_location': require_location,
        'geolocation': {
            'location': request.session.get('geolocation:location'),
            'name': request.session.get('geolocation:name'),
            'accuracy': request.session.get('geolocation:accuracy'),
            'history': request.session.get('geolocation:history'),
            'favourites': request.session.get('geolocation:favourites'),
            'method': request.session.get('geolocation:method'),
        },
        'location_error': request.GET.get('location_error'),
    }
########NEW FILE########
__FILENAME__ = forms
# -*- coding: utf-8 -*-
import re

from django import forms
from django.forms.util import ErrorList
from django.utils.translation import ugettext_lazy as _

from molly.conf import applications
from molly.geolocation import geocode, reverse_geocode

METHOD_CHOICES = (
    ('html5', 'HTML5'),
    ('html5request', 'HTML5 (triggered by the user)'),
    ('gears', 'Google Gears'),
    ('manual', 'Manual update'),
    ('geocoded', 'Geocoded'),
    ('other', 'Other method'),
    ('denied', 'Update denied by user'),
    ('error', 'Error updating location'),
    ('favourite', 'Manually selected from favourite location list'),
)

# From http://en.wikipedia.org/wiki/Postcodes_in_the_United_Kingdom
POSTCODE_RE = r'(((A[BL]|B[ABDHLNRSTX]?|C[ABFHMORTVW]|D[ADEGHLNTY]|E[HNX]?|' + \
              r'F[KY]|G[LUY]?|H[ADGPRSUX]|I[GMPV]|JE|K[ATWY]|L[ADELNSU]?|M[' + \
              r'EKL]?|N[EGNPRW]?|O[LX]|P[AEHLOR]|R[GHM]|S[AEGKLMNOPRSTY]?|T' + \
              r'[ADFNQRSW]|UB|W[ADFNRSV]|YO|ZE)[1-9]?[0-9]|((E|N|NW|SE|SW|W' + \
              r')1|EC[1-4]|WC[12])[A-HJKMNPR-Y]|(SW|W)([2-9]|[1-9][0-9])|EC' + \
              r'[1-9][0-9]) [0-9][ABD-HJLNP-UW-Z]{2})'

class LocationUpdateForm(forms.Form):
    latitude = forms.FloatField(required=False)
    longitude = forms.FloatField(required=False)
    accuracy = forms.FloatField(required=False)
    method = forms.ChoiceField(required=False, choices=METHOD_CHOICES)
    name = forms.CharField(required=False)
 
    def clean_latitude(self):
        latitude = self.cleaned_data.get('latitude')
        if latitude is not None and not (-180 <= latitude < 180):
            raise forms.ValidationError(_('Must be in the range [-180, 180).'))
        return latitude

    def clean_longitude(self):
        longitude = self.cleaned_data.get('longitude')
        if longitude is not None and not (-90 <= longitude < 90):
            raise forms.ValidationError(_('Must be in the range [-90, 90).'))
        return longitude

    def clean(self):
        cleaned_data = self.cleaned_data

        if cleaned_data['method'] in ('html5', 'html5request', 'gears','manual', 'geocoded', 'other', 'favourite'):
            if cleaned_data['method'] == 'geocoded':
                
                if not cleaned_data['name'].strip():
                    raise forms.ValidationError(_("You must enter a location"))
                
                results = geocode(cleaned_data['name'])
                if len(results) > 0:
                    cleaned_data.update(results[0])
                    cleaned_data['longitude'], cleaned_data['latitude'] = cleaned_data['location']
                    # Ignore alternatives for postcodes
                    if not re.match(POSTCODE_RE, cleaned_data['name'].upper()):
                        cleaned_data['alternatives'] = results[1:]
                    else:
                        cleaned_data['alternatives'] = []
                else:
                    raise forms.ValidationError(_("Unable to find a location that matches '%s'.") % cleaned_data['name'])

            for key in ('latitude', 'longitude', 'accuracy'):
                if cleaned_data.get(key) is None:
                    self._errors[key] = ErrorList(['method requires that ' + key + ' must be specified'])

            if not self._errors:
                cleaned_data['location'] = cleaned_data['longitude'], cleaned_data['latitude']
                if not cleaned_data.get('name'):
                    try:
                        cleaned_data['name'] = reverse_geocode(
                            self.cleaned_data['longitude'],
                            self.cleaned_data['latitude'])[0]['name']
                    except:
                        cleaned_data['name'] = u"↝ %f, %f" % (self.cleaned_data['longitude'], self.cleaned_data['latitude'])
        elif cleaned_data['method'] in ('denied', 'error'):
            for key in ('latitude', 'longitude', 'accuracy'):
                if cleaned_data.get(key) is None:
                    self._errors[key] = ErrorList(['method requires that ' + key + ' must be specified'])
        else:
            self._errors['method'] = ErrorList(['method is required'])

        return cleaned_data

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Geocode'
        db.create_table('geolocation_geocode', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('lon', self.gf('django.db.models.fields.FloatField')(null=True)),
            ('lat', self.gf('django.db.models.fields.FloatField')(null=True)),
            ('query', self.gf('django.db.models.fields.TextField')(null=True)),
            ('_results', self.gf('django.db.models.fields.TextField')(default='null')),
            ('updated', self.gf('django.db.models.fields.DateTimeField')()),
            ('local_name', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('geolocation', ['Geocode'])


    def backwards(self, orm):
        
        # Deleting model 'Geocode'
        db.delete_table('geolocation_geocode')


    models = {
        'geolocation.geocode': {
            'Meta': {'object_name': 'Geocode'},
            '_results': ('django.db.models.fields.TextField', [], {'default': "'null'"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lat': ('django.db.models.fields.FloatField', [], {'null': 'True'}),
            'local_name': ('django.db.models.fields.TextField', [], {}),
            'lon': ('django.db.models.fields.FloatField', [], {'null': 'True'}),
            'query': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {})
        }
    }

    complete_apps = ['geolocation']

########NEW FILE########
__FILENAME__ = models
from datetime import datetime, timedelta

import simplejson

from django.db import models

class RecentManager(models.Manager):
    def get_query_set(self):
        return super(RecentManager, self).get_query_set().filter(updated__gt=datetime.utcnow() - timedelta(14))

class Geocode(models.Model):
    lon = models.FloatField(null=True)
    lat = models.FloatField(null=True)
    query = models.TextField(null=True)

    _results = models.TextField(default='null')
    updated = models.DateTimeField()
    local_name = models.TextField()
    
    recent = RecentManager()
    objects = models.Manager()

    def _get_results(self):
        try:
            return self._cached_results
        except AttributeError:
            self._cached_results = simplejson.loads(self._results)
            return self._cached_results
    def _set_results(self, value):
        self._cached_results = value
    results = property(_get_results, _set_results)

    def save(self, *args, **kwargs):
        if hasattr(self, '_cached_results'):
            self._results = simplejson.dumps(self._cached_results)
        self.updated = datetime.utcnow()
        super(Geocode, self).save(*args, **kwargs)

########NEW FILE########
__FILENAME__ = cloudmade
import urllib
import urllib2
import logging
import simplejson
import warnings

from django.conf import settings
from django.contrib.gis.gdal.datasource import OGRException
from django.contrib.gis.geos import Point

from molly.geolocation.providers import BaseGeolocationProvider

logger = logging.getLogger(__name__)


class CloudmadeGeolocationProvider(BaseGeolocationProvider):
    """
    CloudMade GeoLocation provider for geocoding and reverse geocoding,
    based on version 2 of the API
    """


    REVERSE_GEOCODE_URL = 'http://geocoding.cloudmade.com/%(api_key)s/geocoding/v2/find.js?object_type=%(type)s&around=%(lat)f,%(lon)f'
    GEOCODE_URL = 'http://geocoding.cloudmade.com/%(api_key)s/geocoding/v2/find.js?query=%(query)s&around=%(around)s&distance=%(distance)s&object_type=%(object_type)s'
    GEOCODE_URL_SIMPLE = 'http://geocoding.cloudmade.com/%(api_key)s/geocoding/v2/find.js?query=%(query)s&around=&object_type=%(object_type)s'

    def __init__(self, search_locality=None, search_around=None,
            search_distance=None, get_area=True):
        """
        CloudMade GeoLocation Provider
        DeprecationWarning: search_locality is not used anymore, due to changes in the API
        * search_around (optional): tuple (latitude, longitude) being the center of the area to make the search on
        * search_distance (optional): maximum distance in meters to make the search on
        * get_area (optional): get the name of the area around each result (e.g. "Walton Street, Jericho")
        """
        if search_locality:
            warnings.warn('search_locality is not used anymore, due to changes in the API, search_around and search_distance will provide better results.',
                    DeprecationWarning)
        self.search_around = search_around
        self.search_distance = search_distance
        self.get_area = get_area

    def reverse_geocode(self, lon, lat):

        params = {
            'api_key': settings.API_KEYS['cloudmade'],
            'lon': lon,
            'lat': lat,
            'type': 'road',
        }

        try:
            request_url = self.REVERSE_GEOCODE_URL % params
            response = urllib2.urlopen(request_url)
            logger.debug("Reverse geocode request: %s" % request_url)
            if response.code != 200:
                logger.error("Request to %s returned response code %d" % (request_url, response.code))
                return []
            json = simplejson.loads(response.read().replace('&apos;', "'"), 'utf8')
        except urllib2.HTTPError, e:
            logger.error("Cloudmade returned a non-OK response code %d", e.code)
            return []
        except urllib2.URLError, e:
            logger.error("Encountered an error reaching Cloudmade: %s", str(e))
            return []

        if not json:
            return []
        else:
            name = json['features'][0]['properties'].get('name')
            if self.get_area:
                try:
                    params['type'] = 'area'
                    data = simplejson.load(urllib2.urlopen(self.REVERSE_GEOCODE_URL % params))
                    logger.debug("Reverse geocode request: %s" % (self.REVERSE_GEOCODE_URL % params))
                    name = '%s, %s' % (name, data['features'][0]['properties']['name'])
                except Exception:
                    pass
            return [{
                'name': json['features'][0]['properties'].get('name'),
                'location': (lon, lat),
                'accuracy': 100,
            }]

    def geocode(self, query):
        """
        Geocode from a query (query being free-text), "around" and "distance"
        parameters can be specified to limit search results to an area.
        Uses version 2 of Cloudmade's Geocoding API.
        """

        if not query:
            return []

        query = query.strip()
        if query.split(' ')[0][0].isdigit():
            query = '+'.join(query.split(' ')[1:])

        params = {
            'api_key': settings.API_KEYS['cloudmade'],
            'query': urllib.quote_plus(query),
            'object_type': 'road',
        }

        if self.search_around and self.search_distance:
            params['around'] = '{0},{1}'.format(self.search_around[1],
                    self.search_around[0])
            params['distance'] = self.search_distance

        try:
            if self.search_around and self.search_distance:
                request_url = self.GEOCODE_URL % params
            else:
                request_url = self.GEOCODE_URL_SIMPLE % params
            response = urllib2.urlopen(request_url)
            logger.debug("Geocode request: %s" % request_url)
            if response.code != 200:
                logger.error("Request to %s returned response code %d"
                        % (request_url, response.code))
                return []
            json = simplejson.loads(response.read().replace('&apos;', "'"),
                    'utf8')
        except urllib2.HTTPError, e:
            logger.error("Cloudmade returned a non-OK response code %d", e.code)
            return []
        except urllib2.URLError, e:
            logger.error("Encountered an error reaching Cloudmade: %s", str(e))
            return []

        if not json:
            return []

        results = []

        features = sorted(json['features'], key=lambda f:
                len(f['properties'].get('name', 'x' * 1000)))

        for i, feature in enumerate(features):
            try:
                # Cloudmade returns a lat-long (and we use long-lats internally)
                bounds_a, bounds_b = [Point(p[1], p[0]) for p in feature['bounds']]
            except OGRException:
                # The point wasn't transformable into the co-ordinate
                # scheme desired - it's probably a long way away.
                continue

            centroid = tuple(feature['centroid']['coordinates'])
            centroid = centroid[1], centroid[0]
            accuracy = bounds_a.distance(bounds_b) / 1.414

            try:
                name = feature['properties']['name']

                if self.get_area:
                    try:
                        if i > 0:
                            raise ValueError
                        params.update({
                            'type': 'area',
                            'lat': centroid[1],
                            'lon': centroid[0],
                        })
                        # TODO this should use the "cache" instead of doing a call
                        data = simplejson.load(urllib2.urlopen(self.REVERSE_GEOCODE_URL % params))
                        logger.debug("Reverse geocode request: %s" % (self.REVERSE_GEOCODE_URL % params))
                        if name != data['features'][0]['properties']['name']:
                            name = '%s, %s' % (name, data['features'][0]['properties']['name'])
                    except Exception:
                        pass

                results.append({
                    'name': name,
                    'location': centroid,
                    'accuracy': accuracy,
                })

            except KeyError:
                results += self.reverse_geocode(*centroid)

        return results

########NEW FILE########
__FILENAME__ = places
import logging
from itertools import chain

import simplejson

from molly.geolocation.providers import BaseGeolocationProvider
from molly.apps.places.models import Entity, EntityName

logger = logging.getLogger(__name__)

class PlacesGeolocationProvider(BaseGeolocationProvider):
    def __init__(self, search_identifiers = None):
        self.search_identifiers = search_identifiers

    def geocode(self, query):
        entities = Entity.objects.all()
        if self.search_identifiers:
            entities = entities.filter(
                _identifiers__scheme__in = self.search_identifiers,
                _identifiers__value__iexact = query,
                location__isnull = False
            )
        else:
            entities = entities.filter(
                _identifiers__value__iexact = query,
                location__isnull = False
            )

        entities = chain(
            Entity.objects.filter(names__title__iexact = query,
                                  location__isnull = False),
            entities,
        )

        for entity in entities:
            yield {
                'name': entity.title,
                'location': tuple(entity.location),
                'accuracy': 100,
            }
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from views import IndexView, ClearHistoryView, FavouritesView

urlpatterns = patterns('',
    (r'^$',
        IndexView, {},
        'index'),

    (r'^clear/$',
        ClearHistoryView, {},
        'clear'),

    (r'^favourites/$',
        FavouritesView, {},
        'favourites'),

)
    
########NEW FILE########
__FILENAME__ = views
import urllib, random
from datetime import datetime, timedelta
from urlparse import urlparse

from django.core.urlresolvers import resolve, reverse
from django.http import HttpResponse, Http404, HttpResponseBadRequest
from django.contrib.gis.geos import Point
from django.conf import settings
from django.utils.translation import ugettext as _

from molly.utils.views import BaseView, renderer
from molly.utils.breadcrumbs import *
from molly.utils.http import update_url
from molly.utils.templatetags.molly_utils import humanise_distance
from molly.utils import haversine

from molly.geolocation.forms import LocationUpdateForm
from molly.geolocation import geocode, reverse_geocode

class GeolocationView(BaseView):
    """
    Deals with setting location using POST requests (either forms or AJAX)
    """
    
    def initial_context(self, request):
        data = dict(request.REQUEST.items())
        return {
            'form': LocationUpdateForm(data),
            'format': request.REQUEST.get('format'),
            'return_url': request.REQUEST.get('return_url', ''),
            'requiring_url': hasattr(request, 'requiring_url'),
        }

    def set_location(self, request, name, location, accuracy, method, with_history=False):
        request.session['geolocation:location'] = location
        request.session['geolocation:updated'] = datetime.utcnow()
        request.session['geolocation:name'] = name
        request.session['geolocation:method'] = method
        request.session['geolocation:accuracy'] = accuracy

        if not with_history:
            return

        if isinstance(location, list):
            location = tuple(location)
        last_updated = request.session.get('geolocation:updated', datetime(1970, 1, 1))
        try:
            last_location = Point(request.session['geolocation:location'])
            distance_moved = haversine(last_location, Point(location))
        except KeyError:
            distance_moved = float('inf')

        if method in ('other', 'manual', 'geocoded', 'html5request') or \
           not 'geolocation:location' in request.session or \
           (last_updated > datetime.utcnow() - timedelta(seconds=3600) and distance_moved > 250):
            self.add_to_history(request, name, location, accuracy, method)

    def add_to_history(self, request, name, location, accuracy, method):
        if not 'geolocation:history' in request.session:
            request.session['geolocation:history'] = []
        request.session['geolocation:history'].insert(0, {
            'location': location,
            'updated': datetime.utcnow(),
            'name': name,
            'method': method,
            'accuracy': accuracy,
        })

        request.session['geolocation:history'] = [e for i, e in enumerate(request.session['geolocation:history']) if e['name'] != name or i == 0]

        # Chop off the last element if the history is now larger than the
        # maximum allowed length.
        history_size = getattr(self.conf, 'history_size', 5)
        request.session['geolocation:history'][history_size:] = []

        request.session.modified = True

    def handle_set_location(self, request, context):
        form = context['form']

        if form.is_valid():
            self.set_location(request,
                             form.cleaned_data['name'],
                             form.cleaned_data['location'],
                             form.cleaned_data['accuracy'],
                             form.cleaned_data['method'],
                             True)

        if context.get('return_url').startswith('/'):
            redirect = context['return_url']
        elif context['format'] == 'json':
            redirect = None
        else:
            redirect = reverse('home:index')

    @renderer(format="embed", mimetypes=())
    def render_embed(self, request, context, template_name):
        response = self.render_html(request, context, template_name)
        response['X-Embed'] = 'True'
        return response

    def get_location_response(self, request, context, form=None):
        if context.get('return_url').startswith('/'):
            redirect = context['return_url']
        else:
            redirect = reverse('home:index')
        if context['format'] == 'json':
            return self.render(request, {
                'name': request.session['geolocation:name'],
                'redirect': redirect,
                'accuracy': humanise_distance(request.session['geolocation:accuracy']),
                'longitude': request.session['geolocation:location'][0],
                'latitude': request.session['geolocation:location'][1],
                'history': request.session.get('geolocation:history', ()),
                'alternatives': form.cleaned_data.get('alternatives') if form else None,
                'favourites': [dict(favourite.items() + [('id', id)]) for id, favourite in request.session.get('geolocation:favourites', {}).items()],
            }, None)
        elif context['format'] == 'embed':
            response = HttpResponse('')
            response['X-Embed-Redirect'] = redirect
            response['X-Embed-Location-Name'] = form.cleaned_data['name']
            return response
        else:
            alternatives = form.cleaned_data.get('alternatives') if form else None
            if alternatives != None and len(alternatives) > 0:
                # Not doing AJAX update, so show the form allowing users to
                # choose a location from alternatives before returning to their
                # original screen
                context.update({
                    'geolocation_alternatives': form.cleaned_data.get('alternatives')
                })
                return self.handle_GET(request, context)
            else:
                return self.redirect(redirect, request, 'seeother')

class IndexView(GeolocationView):
    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        if not request.REQUEST.get('return_url'):
            return Breadcrumb(
                self.conf.local_name,
                None,
                _('Update location'),
                lazy_reverse('geolocation:index'),
            )

        try:
            return_url = urlparse(request.REQUEST['return_url']).path
            parent_view, args, kwargs = resolve(return_url)
            parent_data = parent_view.breadcrumb.data(self, request, context, *args, **kwargs)
            parent_data = parent_data.parent(self, parent_view.conf.local_name, request, context)

            parent = lambda _1, _2, _3, _4: parent_data
            application = parent_data.application
        except Exception:
            application = 'home'
            parent = lambda _1,_2,_3, _4: type(
                'BC', (), {
                    'application': 'home',
                    'title': 'Back...',
                    'url':staticmethod(lambda _:request.REQUEST.get('return_url', reverse('home:index')))
                }
            )
        return Breadcrumb(
            application,
            parent,
            _('Update location'),
            lazy_reverse('index'),
        )

    def handle_GET(self, request, context):
        if context['format'] == 'embed':
            return self.render(request, context, 'geolocation/update_location_embed')
        else:
            if request.session.get('geolocation:location') \
              and context.get('return_url') \
              and not request.REQUEST.get('update', False) \
              and not 'geolocation_alternatives' in context:
                return self.redirect(context.get('return_url'),
                                     request, 'seeother')
            return self.render(request, context, 'geolocation/update_location')

    def handle_POST(self, request, context):
        form = context['form']

        if form.is_valid():
            context['return_url'] = update_url(context['return_url'], {'location_error': None}, None)
            self.handle_set_location(request, context)
            return self.get_location_response(request, context, form)
        else:
            if context['format'] == 'json':
                context = {
                    'error': form.errors.popitem()[1].pop(),
                }
                return self.render(request, context, None)
            else:
                return_url = update_url(
                    context['return_url'],
                    {'location_error': form.errors.popitem()[1].pop()},
                    'location-update',
                )
                return self.redirect(return_url, request, 'seeother')

class FavouritesView(GeolocationView):
    breadcrumb = NullBreadcrumb

    actions = frozenset(['add', 'remove', 'set'])

    def new_id(self, request):
        while True:
            id = ''.join(random.choice('0123456789abcdef') for i in range(8))
            if id in request.session['geolocation:favourites']:
                continue
            return id

    def handle_POST(self, request, context):
        if not 'geolocation:favourites' in request.session:
            request.session['geolocation:favourites'] = {}

        action = request.POST.get('action')

        if action not in self.actions:
            return HttpResponseBadRequest()

        handler = getattr(self, 'do_%s' % action)

        try:
            handler(request, context)
        except (ValueError, KeyError):
            return HttpResponseBadRequest()

        return self.get_location_response(request, context)

    def do_add(self, request, context):
        id = self.new_id(request)

        if any(f['name'] == request.POST['name'] for f in request.session['geolocation:favourites'].values()):
            return

        request.session['geolocation:favourites'][id] = {
            'name': request.POST['name'],
            'location': (float(request.POST['longitude']), float(request.POST['latitude'])),
            'accuracy': float(request.POST['accuracy']),
        }
        request.session.modified = True

    def do_remove(self, request, context):
        request.session['geolocation:favourites'].pop(request.POST['id'], None)
        request.session.modified = True

    def do_set(self, request, context):
        loc = request.session['geolocation:favourites'][request.POST['id']]
        if context['form'].is_valid():
            self.handle_set_location(request, context)
        else:
            raise ValueError

class ClearHistoryView(GeolocationView):
    breadcrumb = NullBreadcrumb

    def handle_POST(self, request, context):
        keys_to_delete = set()
        for key in request.session._session:
            if key.startswith('geolocation:history'):
                keys_to_delete.add(key)
        for key in keys_to_delete:
            del request.session[key]
        request.session.modified = True
        context['return_url'] = request.POST.get('return_url', reverse('home:index'))
        return self.get_location_response(request, context)

class LocationRequiredView(BaseView):
    def is_location_required(self, request, *args, **kwargs):
        return True

    def __call__(self, request, *args, **kwargs):
        if not self.is_location_required(request, *args, **kwargs) or hasattr(request, 'user_location'):
            return super(LocationRequiredView, self).__call__(request, *args, **kwargs)
        else:
            return self.redirect('%s?%s' % (
                reverse('geolocation:index'),
                urllib.urlencode({'return_url': request.get_full_path()}),
            ), request, 'seeother')


########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from models import OSMUpdate

admin.site.register(OSMUpdate)
########NEW FILE########
__FILENAME__ = generate_markers
import itertools
import subprocess
import os.path
import tempfile
import os
from optparse import make_option

from django.core.management.base import NoArgsCommand
from django.conf import settings

from molly.maps.osm import MARKER_COLORS, MARKER_RANGE
from molly.maps.osm.models import get_marker_dir

    
class Command(NoArgsCommand):
    
    option_list = NoArgsCommand.option_list + (
        make_option('--lazy',
            action='store_true',
            dest='lazy',
            default=False,
            help="Only generate makers if they don't already exist"),
        )
    
    def handle_noargs(self, **options):
        template = open(os.path.join(os.path.dirname(__file__), 'markers', 'base.svg')).read()
        marker_dir = get_marker_dir()
        
        if not os.path.exists(marker_dir):
            os.makedirs(marker_dir)
        

        for color, index in itertools.product(MARKER_COLORS, MARKER_RANGE):
            if os.path.exists(os.path.join(marker_dir, '%s_%d.png' % (color[0], index))):
                continue
            
            out = template % {
                'label': str(index),
                'fill': color[1],
                'stroke': color[2],
                'text_color': color[3],
            }
            
            f, infile = tempfile.mkstemp()
            os.write(f, out)
            os.close(f)
            
            filename = os.path.join(marker_dir, '%s_%d.png' % (color[0], index))
            subprocess.check_call('convert -background none "%s" "%s"' % (infile, filename), shell=True)
            os.unlink(infile)
        
        template = open(os.path.join(os.path.dirname(__file__), 'markers', 'star-base.svg')).read()
            
        for color in MARKER_COLORS:
            if os.path.exists(os.path.join(marker_dir, '%s_star.png' % color[0])):
                continue
            
            out = template % {'fill': color[1], 'stroke': color[2]}
            
            f, infile = tempfile.mkstemp()
            os.write(f, out)
            os.close(f)
            
            filename = os.path.join(marker_dir, '%s_star.png' % color[0])
            subprocess.check_call('convert -background none "%s" "%s"' % (infile, filename), shell=True)
            os.unlink(infile)

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.models import MigrationHistory
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # this is a custom migration because we changed the name of the app that
        # the models belong to 
        if MigrationHistory.objects.filter(app_name='osm').count() == 0:
            # Adding model 'GeneratedMap'
            db.create_table('osm_generatedmap', (
                ('hash', self.gf('django.db.models.fields.CharField')(unique=True, max_length=16, primary_key=True)),
                ('generated', self.gf('django.db.models.fields.DateTimeField')()),
                ('last_accessed', self.gf('django.db.models.fields.DateTimeField')()),
                ('_metadata', self.gf('django.db.models.fields.TextField')(blank=True)),
                ('faulty', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ))
            db.send_create_signal('maps', ['GeneratedMap'])
    
            # Adding model 'OSMTile'
            db.create_table('osm_osmtile', (
                ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
                ('xtile', self.gf('django.db.models.fields.IntegerField')()),
                ('ytile', self.gf('django.db.models.fields.IntegerField')()),
                ('zoom', self.gf('django.db.models.fields.IntegerField')()),
                ('last_fetched', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ))
            db.send_create_signal('maps', ['OSMTile'])
    
            # Adding unique constraint on 'OSMTile', fields ['xtile', 'ytile', 'zoom']
            db.create_unique('osm_osmtile', ['xtile', 'ytile', 'zoom'])
    
            # Adding model 'OSMUpdate'
            db.create_table('osm_osmupdate', (
                ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
                ('contributor_name', self.gf('django.db.models.fields.TextField')(blank=True)),
                ('contributor_email', self.gf('django.db.models.fields.TextField')(blank=True)),
                ('contributor_attribute', self.gf('django.db.models.fields.BooleanField')(default=False)),
                ('entity', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['places.Entity'])),
                ('submitted', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
                ('old', self.gf('django.db.models.fields.TextField')()),
                ('new', self.gf('django.db.models.fields.TextField')()),
                ('notes', self.gf('django.db.models.fields.TextField')(blank=True)),
                ('approved', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ))
            db.send_create_signal('maps', ['OSMUpdate'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'OSMTile', fields ['xtile', 'ytile', 'zoom']
        db.delete_unique('osm_osmtile', ['xtile', 'ytile', 'zoom'])

        # Deleting model 'GeneratedMap'
        db.delete_table('osm_generatedmap')

        # Deleting model 'OSMTile'
        db.delete_table('osm_osmtile')

        # Deleting model 'OSMUpdate'
        db.delete_table('osm_osmupdate')


    models = {
        'osm.generatedmap': {
            'Meta': {'object_name': 'GeneratedMap'},
            '_metadata': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'faulty': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'generated': ('django.db.models.fields.DateTimeField', [], {}),
            'hash': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '16', 'primary_key': 'True'}),
            'last_accessed': ('django.db.models.fields.DateTimeField', [], {})
        },
        'osm.osmtile': {
            'Meta': {'unique_together': "(('xtile', 'ytile', 'zoom'),)", 'object_name': 'OSMTile'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_fetched': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'xtile': ('django.db.models.fields.IntegerField', [], {}),
            'ytile': ('django.db.models.fields.IntegerField', [], {}),
            'zoom': ('django.db.models.fields.IntegerField', [], {})
        },
        'osm.osmupdate': {
            'Meta': {'object_name': 'OSMUpdate'},
            'approved': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'contributor_attribute': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'contributor_email': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'contributor_name': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'new': ('django.db.models.fields.TextField', [], {}),
            'notes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'old': ('django.db.models.fields.TextField', [], {}),
            'submitted': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'})
        },
        'places.entity': {
            'Meta': {'ordering': "('title',)", 'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_stack': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_sublocation': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"}),
            'title': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'places.entitytype': {
            'Meta': {'ordering': "('verbose_name',)", 'object_name': 'EntityType'},
            'article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'verbose_name': ('django.db.models.fields.TextField', [], {}),
            'verbose_name_plural': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        }
    }

    complete_apps = ['maps']

########NEW FILE########
__FILENAME__ = 0002_add_index_OSMTile_xtile_add_index_OSMTile_ytile_add_index_OSMTile_zoom
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding index on 'OSMTile', fields ['xtile']
        db.create_index('osm_osmtile', ['xtile'])

        # Adding index on 'OSMTile', fields ['ytile']
        db.create_index('osm_osmtile', ['ytile'])

        # Adding index on 'OSMTile', fields ['zoom']
        db.create_index('osm_osmtile', ['zoom'])


    def backwards(self, orm):
        
        # Removing index on 'OSMTile', fields ['zoom']
        db.delete_index('osm_osmtile', ['zoom'])

        # Removing index on 'OSMTile', fields ['ytile']
        db.delete_index('osm_osmtile', ['ytile'])

        # Removing index on 'OSMTile', fields ['xtile']
        db.delete_index('osm_osmtile', ['xtile'])


    models = {
        'maps.generatedmap': {
            'Meta': {'object_name': 'GeneratedMap', 'db_table': "'osm_generatedmap'"},
            '_metadata': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'faulty': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'generated': ('django.db.models.fields.DateTimeField', [], {}),
            'hash': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '16', 'primary_key': 'True'}),
            'last_accessed': ('django.db.models.fields.DateTimeField', [], {})
        },
        'maps.osmtile': {
            'Meta': {'unique_together': "(('xtile', 'ytile', 'zoom'),)", 'object_name': 'OSMTile', 'db_table': "'osm_osmtile'"},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_fetched': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'xtile': ('django.db.models.fields.IntegerField', [], {}),
            'ytile': ('django.db.models.fields.IntegerField', [], {}),
            'zoom': ('django.db.models.fields.IntegerField', [], {})
        },
        'maps.osmupdate': {
            'Meta': {'object_name': 'OSMUpdate', 'db_table': "'osm_osmupdate'"},
            'approved': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'contributor_attribute': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'contributor_email': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'contributor_name': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'entity': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'new': ('django.db.models.fields.TextField', [], {}),
            'notes': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'old': ('django.db.models.fields.TextField', [], {}),
            'submitted': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'})
        },
        'places.entity': {
            'Meta': {'object_name': 'Entity'},
            '_identifiers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.Identifier']", 'symmetrical': 'False'}),
            '_metadata': ('django.db.models.fields.TextField', [], {'default': "'{}'"}),
            'absolute_url': ('django.db.models.fields.TextField', [], {}),
            'all_types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'all_types_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'entities_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['places.EntityGroup']", 'symmetrical': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'identifier_scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'identifier_value': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'is_entrance': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Entity']", 'null': 'True'}),
            'primary_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityType']", 'null': 'True'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitygroup': {
            'Meta': {'object_name': 'EntityGroup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ref_code': ('django.db.models.fields.CharField', [], {'max_length': '256'}),
            'source': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.Source']"})
        },
        'places.entitytype': {
            'Meta': {'object_name': 'EntityType'},
            'category': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['places.EntityTypeCategory']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'note': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'show_in_category_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'show_in_nearby_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'subtype_of': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes'", 'blank': 'True', 'to': "orm['places.EntityType']"}),
            'subtype_of_completion': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'subtypes_completion'", 'blank': 'True', 'to': "orm['places.EntityType']"})
        },
        'places.entitytypecategory': {
            'Meta': {'object_name': 'EntityTypeCategory'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.TextField', [], {})
        },
        'places.identifier': {
            'Meta': {'object_name': 'Identifier'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'scheme': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'value': ('django.db.models.fields.CharField', [], {'max_length': '256'})
        },
        'places.source': {
            'Meta': {'object_name': 'Source'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'module_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        }
    }

    complete_apps = ['maps']

########NEW FILE########
__FILENAME__ = models
from molly.maps.osm.models import GeneratedMap, OSMTile, OSMUpdate
########NEW FILE########
__FILENAME__ = draw
from __future__ import division
import math
import random
import urllib
import os.path
import sys
import time
import logging

logger = logging.getLogger(__name__)

from PIL import Image, ImageDraw
from PIL.ImageFilter import EDGE_ENHANCE

from molly.maps.osm.models import OSMTile, get_marker_dir

def log2(x):
    """
    @return: log(x)/log(2)
    """
    return math.log(x)/math.log(2)

def get_tile_ref(lon_deg, lat_deg, zoom):
    """
    Gets OSM tile co-ordinates for the specified longitude, latitude and zoom
    level.
    
    @param lon_deg: The longitude, in degrees
    @type lon_deg: float
    
    @param lat_deg: The latitude, in degrees
    @type lat_deg: float
    
    @param zoom: The zoom level to get the tile references for
    @type zoom: int
    
    @return: A tuple of (x, y) co-ordinates for the OSM tile
    """
    lat_rad = lat_deg * math.pi / 180.0
    n = 2.0 ** zoom
    xtile = (lon_deg + 180.0) / 360.0 * n
    ytile = (1.0 - math.log(math.tan(lat_rad) + (1 / math.cos(lat_rad))) / math.pi) / 2.0 * n
    return (xtile, ytile)

def get_tile_geo(xtile, ytile, zoom):
    """
    Gets the latitude and longitude corresponding to a particular set of OSM
    tile co-ordinates.
    
    @param lon_deg: The longitude, in degrees
    @type lon_deg: int
    
    @param lat_deg: The latitude, in degrees
    @type lat_deg: int
    
    @param zoom: The zoom level this tile exists at
    @type zoom: int
    
    @return: A tuple of (long, lat) co-ordinates for the OSM tile
    """
    n = 2.0 ** zoom
    lon_deg = xtile / n * 360.0 - 180.0
    lat_rad = math.atan(math.sinh(math.pi * (1 - 2 * ytile / n)))
    lat_deg = lat_rad * 180.0 / math.pi
    return (lon_deg, lat_deg)

def minmax(i):
    """
    Gets the minimum and maximum values in some list
    
    @param i: The list for the maximum and minimum values to be obtained from
    @type i: list
    
    @return: A tuple (min, max)
    """
    min_, max_ = float('inf'), float('-inf')
    for e in i:
        min_ = min(min_, e)
        max_ = max(max_, e)
    return min_, max_

def get_map(points, width, height, filename, zoom=None, lon_center=None,
            lat_center=None, paths=[]):
    """
    Generates a map for the passed in arguments, saving that to filename
    
    @param points: The points where markers on the map should be added. This
                   should be a list of tuples corresponding to the points where
                   markers should be added. These tuples should be in the form
                   (latitude, longitude, colour, index), where acceptable values
                   of colour are specified in @C{utils.MARKER_COLOURS}, and
                   index is the number to appear on the marker, or None if
                   you want a star to appear
    @type points: list
    @param width: The width of the generated map image, in pixels
    @type width: int
    @param height: The height of the generated map image, in pixels
    @type height: int
    @param filename: The name of the file to write the generated map to
    @type filename: str
    @param zoom: The maximum zoom level which to generate this map at
    @type zoom: int
    @param lon_center: The actual center of the generated map
    @type lon_center: float
    @param lat_center: The actual center of the generated map
    @type lat_center: float
    """
    
    lon_min, lon_max = minmax(p[0] for p in points)
    lat_min, lat_max = minmax(p[1] for p in points)
    
    if not zoom:
        size = min(width, height)
        if lat_min != lat_max:
            zoom = int(log2(360/abs(lat_min - lat_max)) + log2(size/256)-1.0)
        else:
            zoom = 16
    
    points = [(get_tile_ref(p[0], p[1], zoom), p[2], p[3]) for p in points]

    lon_range, lat_range = lon_max - lon_min, lat_min - lat_max
    if not lat_center:
        lon_center, lat_center = (lon_min + lon_max)/2, (lat_min + lat_max)/2
    
    tx_min, tx_max = map(int, minmax(p[0][0] for p in points))
    ty_min, ty_max = map(int, minmax(p[0][1] for p in points))
    ty_max, tx_max = ty_max+1, tx_max+1
    
    cx, cy = get_tile_ref(lon_center, lat_center, zoom)
    oxc = int((cx - tx_min) * 256 - width/2)
    oyc = int((cy - ty_min) * 256 - height/2)
    ox, oy = oxc, oyc-10

    tx_min_ = int(tx_min + ox/256)
    tx_max_ = int(tx_max + (width+ox)/256)
    ty_min_ = int(ty_min + oy/256)
    ty_max_ = int(ty_max + (height+oy)/256)
    tiles = [{ 'ref':(tx, ty) }
        for tx in range(tx_min_, tx_max_) for ty in range(ty_min_, ty_max_)]
    
    # Create a new blank image for us to add the tiles on to
    image = Image.new('RGBA', (width, height))
    
    # Keep track of if the image if malformed or not
    malformed = False
    
    # Lots of different tiles contain the parts we're interested in, so take the
    # parts of those tiles, and copy them into our new image
    for tile in tiles:
        offx = (tile['ref'][0] - tx_min) * 256 - ox
        offy = (tile['ref'][1] - ty_min) * 256 - oy
        
        if not (-256 < offx and offx < width and -256 < offy and offy < height):
            continue
        
        try:
            tile_data = OSMTile.get_data(tile['ref'][0], tile['ref'][1], zoom)
            tile['surface'] = Image.open(tile_data)
        except Exception as e:
            logger.exception('Failed to fetch OSM tile')
            tile['surface'] = Image.open(os.path.join(os.path.dirname(__file__), 'fallback', 'fallback.png'))
            malformed = True
        
        image.paste(tile['surface'], ((tile['ref'][0] - tx_min) * 256 - ox, (tile['ref'][1] - ty_min) * 256 - oy))
    
    
    # Now add the paths to the image
    paths_canvas = Image.new('RGBA', (width, height))
    drawing = ImageDraw.Draw(paths_canvas)
    for path, colour in paths:
        drawing.line(map(lambda (x,y): (int((x - tx_min) * 256 - ox),
                                        int((y - ty_min) * 256 - oy)),
                         map(lambda x: get_tile_ref(*x, zoom=zoom), path.coords)),
                     fill=colour, width=4)
    paths_canvas = paths_canvas.filter(EDGE_ENHANCE) # Anti-alias
    
    # 50% transparency
    paths_canvas = Image.blend(paths_canvas, Image.new('RGBA', (width, height)), 0.5)
    
    image.paste(paths_canvas, None, paths_canvas)
    
    # Now add the markers to the image
    points.sort(key=lambda p:p[0][1])
    marker_dir = get_marker_dir()
    for (tx, ty), color, index in points:
        if index is None:
            off, fn = (10, 10), "%s_star.png" % color
        else:
            off, fn = (10, 25), "%s_%d.png" % (color, index)
        fn = os.path.join(marker_dir, fn)
        marker = Image.open(fn)
        off = (
            int((tx - tx_min) * 256 - off[0] - ox),
            int((ty - ty_min) * 256 - off[1] - oy),
        )
        image.paste(marker, (off[0], off[1]), marker)
    
    image.save(filename, 'png')
    
    if malformed:
        raise MapGenerationError((lon_center, lat_center))
    return lon_center, lat_center

class PointSet(set):
    
    def __init__(self, initial=None):
        """
        @param initial: An initial point set to use
        @type initial: ( (float, float) )
        """
        super(PointSet, self).__init__(initial)
        self._min = (float('inf'), float('inf'))
        self._max = (float('-inf'), float('-inf'))
        self.ordered = []
        for p in initial:
            self.update(p)
        
    def add(self, point):
        """
        Add a point to the set
        
        @param point: The point to be added
        @type point: (float, float)
        """
        super(PointSet, self).add(point)
        self.update(point)
    
    def remove(self, point):
        """
        Remove a point from the set
        
        @param point: The point to be removed
        @type point: (float, float)
        """
        self.ordered.remove(point)
        super(PointSet, self).remove(point)
        if any((point[i] in (self._min[i], self._max[i])) for i in range(2)):
            self._min = (float('inf'), float('inf'))
            self._max = (float('-inf'), float('-inf'))
            for point in self:
                self._min = (min(self._min[0], point[0]),
                             min(self._min[1], point[1]))
                self._max = (max(self._max[0], point[0]),
                             max(self._max[1], point[1]))
    
    def update(self, point):
        """
        Update the set
        
        @param point: The point to be added
        @type point: (float, float)
        """
        self.ordered.append(point)
        self._min = min(self._min[0], point[0]), min(self._min[1], point[1])
        self._max = max(self._max[0], point[0]), max(self._max[1], point[1])
        
    def extent(self, zoom):
        """
        Get the bounding box of this set of points
        
        @param zoom: The zoom level to use
        """
        top_left = get_tile_ref(self._min[0], self._min[1], zoom)
        bottom_right = get_tile_ref(self._max[0], self._max[1], zoom)
        
        a = (bottom_right[0]-top_left[0])*256, (top_left[1]-bottom_right[1])*256
        return a
        
    def contained_within(self, box, zoom):
        """
        Check if @C{box} is inside this pointset at the specified zoom level
        """
        extent = self.extent(zoom)
        return extent[0] <= box[0] and extent[1] <= box[1]
        

def get_fitted_map(centre_point, points, min_points, zoom, width, height,
                   extra_points, paths, filename):
    """
    Given a list of points and some minimum number of points, then a "fitted
    map" is generated, which is one which contains at least @C{min_points}, and
    is at least at the zoom level @C{zoom}, but also contains any other points
    in the list which is inside the bounding area of this minimal map.
    
    Valid colours in point definitions below are defined in @C{MARKER_COLOURS}
    
    @param centre_point: A tuple of longitude, latitude and colour corresponding
                         to the "centre" of the map. This is NOT the central
                         latitude/longitude of the generated image, which is
                         simply the middle of the set of points passed in, but
                         simply a special marker which is indicated with a star.
    @type centre_point: (float, float, str) or None
    @param points: An (ordered) list of points to be plotted on the map. These
                   are indicated on the map with numbered markers. This list
                   consists of tuples of longitude, latitude and a string
                   indicating the colours of the markers to be rendered.
    @type points: [(float, float, str)]
    @param min_points: The minimum number of points to be displayed on the
                       resulting map
    @type min_points: int
    @param zoom: A bound on the maximum zoom level to be rendered. If this zoom
                 level is too small to fit @C{min_points} points on it, then the
                 map will be zoomed out further to fit in. If this is None, then
                 this is equivalent to the smallest zoom level.
    @type zoom: int
    @param width: The width of the generated map image, in pixels
    @type width: int
    @param height: The height of the generated map image, in pixels
    @type height: int
    
    @raise MapGenerationError: If a map can not be generated (normally if the
                               OSM tile server is down)
    """

    # If we haven't been given a zoom, start as close as we can
    if not zoom:
        zoom = 18

    box = max(64, width - 20), max(64, height-35)
    
    new_points = []
    for i, point in enumerate(points):
        if i>1 and point == new_points[-1][0]:
            new_points[-1][1].append(i)
        else:
            new_points.append( (point, [i]) )
    
    points = [p[0] for p in new_points]
    
    # Include extra_points in bounding_box
    points = list(extra_points) + points
    min_points += len(extra_points)
    
    # Include the central point in the points to be considered
    if centre_point:
        points = [centre_point] + points
    
    # Get a set of the minimum points
    point_set, points = PointSet(points[:min_points+1]), points[min_points+1:]
    
    # Zoom out until the entire point set fits inside the generated map
    while not point_set.contained_within(box, zoom):
        zoom -= 1

    # If there are points outside the minimum points, see if they fit inside
    # the bounding box of the minimum points (or the specified zoom level)
    while point_set.contained_within(box, zoom):
        if not points:
            break
        new_point, points = points[0], points[1:]
        point_set.add(new_point)
    else:
        point_set.remove(new_point)
    
    points = [(p[0], p[1], p[2], None) for p in extra_points]
    
    if centre_point:
        used_points = point_set.ordered[len(extra_points)+1:]
        points.append((centre_point[0], centre_point[1], centre_point[2], None))
    else:
        used_points = point_set.ordered[len(extra_points):]
    
    for i, point in enumerate(used_points):
        points.append(
            (point[0], point[1], point[2], i+1)
        )
    
    if centre_point:
        new_points = new_points[:len(point_set)-1]
    else:
        new_points = new_points[:len(point_set)]
    
    try:
        lon_center, lat_center = get_map(points, width, height, filename, zoom,
                                         paths=paths)
    except MapGenerationError as e:
        e.metadata = (new_points, zoom, e.metadata[0], e.metadata[1])
        raise
    
    return new_points, zoom, lon_center, lat_center

class MapGenerationError(Exception):
    """
    Indicates that a map was unable to be successfully generated, but one was
    still attempted to be, in which case the metadata of the generated map can
    be attached to this.
    """
    
    def __init__(self, metadata=None):
        self.metadata = metadata

if __name__ == '__main__':
    RED, GREEN, BLUE = (1, 0, 0), (0, 0.5, 0), (0.25, 0.25, 1)
    get_map(
        [
            (51.760283, -1.259941, 'blue', None),
            (51.760565, -1.259021, 'red', 1),
            (51.760009, -1.260275, 'green', 2),
            (51.760294, -1.258813, 'red', 3),
            (51.759805, -1.261170, 'green', 4),
            (51.759810, -1.261359, 'red', 5),
            (51.759662, -1.261110, 'green', 6),
            (51.759520, -1.260638, 'red', 7),
            (51.759247, -1.259904, 'green', 8),
            (51.759173, -1.259880, 'red', 9),
        ], 300, 200, 'foo.png')


########NEW FILE########
__FILENAME__ = models
try:
    import cPickle as pickle
except:
    import pickle
import hashlib, os, urllib, simplejson, sys
from datetime import datetime, timedelta
from StringIO import StringIO

from django.db import models, IntegrityError
from django.conf import settings

from molly.apps.places.models import Entity

# This used to be its own app, but has now been subsumed into the 'Maps' app,
# but we use the old app_label on the models for backwards compatibility

def get_generated_map_dir():
    return getattr(settings,
                   'GENERATED_MAP_DIR',
                   os.path.join(settings.CACHE_DIR, 'generated_maps'))

def get_marker_dir():
    return getattr(settings,
                   'MARKER_DIR',
                   os.path.join(settings.CACHE_DIR, 'markers'))

def get_osm_tile_dir():
    return getattr(settings,
                   'OSM_TILE_DIR',
                   os.path.join(settings.CACHE_DIR, 'osm_tiles'))

class GeneratedMap(models.Model):
    """
    In database representation of a generated map on disk
    """
    
    hash = models.CharField(max_length=16, unique=True, primary_key=True)
    generated = models.DateTimeField()
    last_accessed = models.DateTimeField()
    _metadata = models.TextField(blank=True)
    faulty = models.BooleanField(default=False)
    
    class Meta:
        app_label = 'maps'
        db_table = 'osm_generatedmap'

    def _get_metadata(self):
        return simplejson.loads(self._metadata)
    def _set_metadata(self, value):
        self._metadata = simplejson.dumps(value)
    metadata = property(_get_metadata, _set_metadata)

    def get_filename(self):
        generated_map_dir = get_generated_map_dir()
        if not os.path.exists(generated_map_dir):
            os.mkdir(generated_map_dir)
        return os.path.join(generated_map_dir, self.hash)

    def delete(self, *args, **kwargs):
        """
        When deleting from the db, also delete on disk
        """
        try:
            os.unlink(self.get_filename())
        except:
            pass
        return super(GeneratedMap, self).delete(*args, **kwargs)

def get_tile_url(xtile, ytile, zoom):
    """
    Return a URL for a tile given some OSM tile co-ordinates
    """
    return "http://tile.openstreetmap.org/%d/%d/%d.png" % (zoom, xtile, ytile)

class OSMTile(models.Model):
    """
    In-database representation of a cached OSM tile on disk
    """
    
    xtile = models.IntegerField()
    ytile = models.IntegerField()
    zoom = models.IntegerField()
    last_fetched = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = (('xtile', 'ytile', 'zoom'),)
        app_label = 'maps'
        db_table = 'osm_osmtile'

    def get_filename(self):
        osm_tile_dir = get_osm_tile_dir()
        if not os.path.exists(osm_tile_dir):
            os.mkdir(osm_tile_dir)
        return os.path.join(osm_tile_dir, "%d-%d-%d.png" % (self.xtile, self.ytile, self.zoom))

    def refresh_data(self, retry=True):
            
        # Try to get the file from the OSM tile server
        try:
            response = urllib.urlopen(get_tile_url(self.xtile, self.ytile, self.zoom))
        except IOError:
            # If it fails... try again, but only once
            if retry:
                return self.refresh_data(retry=False)
            else:
                raise
        
        s = StringIO()
        s.write(response.read())
        f = open(self.get_filename(), 'w')
        f.write(s.getvalue())
        f.close()
        s.seek(0)
        return s

    @staticmethod
    def get_data(xtile, ytile, zoom):
        """
        Fetch an OSM tile from the OSM tile server, and cache it if necessary.
        """
        try:
            osm_tile = OSMTile.objects.get(xtile=xtile, ytile=ytile, zoom=zoom, last_fetched__gt = datetime.now() - timedelta(1))
            if osm_tile.last_fetched < datetime.now() - timedelta(weeks=1):
                try:
                    return osm_tile.refresh_data()
                except IOError:
                    # Ignore IOErrors, because we already have some data, so
                    # just use that
                    pass
            return open(osm_tile.get_filename())
        except (OSMTile.DoesNotExist, IOError):
            try:
                osm_tile, created = OSMTile.objects.get_or_create(xtile=xtile, ytile=ytile, zoom=zoom)
            except IntegrityError:
                return OSMTile.get_data(xtile, ytile, zoom)
            
            return osm_tile.refresh_data()
    
class OSMUpdate(models.Model):
    """
    A user-submitted update to OSM 
    """
    
    contributor_name = models.TextField(blank=True)
    contributor_email = models.TextField(blank=True)
    contributor_attribute = models.BooleanField()

    entity = models.ForeignKey(Entity)    
    
    submitted = models.DateTimeField(auto_now_add=True)
    
    old = models.TextField()
    new = models.TextField()
    
    notes = models.TextField(blank=True)
    
    approved = models.BooleanField(default=False)
    
    class Meta:
        app_label = 'maps'
        db_table = 'osm_osmupdate'
    

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from .views import GeneratedMapView, GPXView, AboutView

urlpatterns = patterns('',
    (r'^about/$', AboutView, {}, 'osm-about'),
    (r'^generated_map/(?P<hash>[a-f\d]{16})/$', GeneratedMapView, {}, 'osm-generated_map'),
    (r'^gpx/(?P<ptype>[a-z_]+)/$', GPXView, {}, 'osm-gpx'),

)


########NEW FILE########
__FILENAME__ = views
from email.utils import formatdate
from datetime import datetime, timedelta
from time import mktime
import simplejson, urllib2, base64
from xml.etree import ElementTree as ET
from xml.sax.saxutils import escape

from django.shortcuts import get_object_or_404
from django.http import HttpResponse, Http404
from django.utils.translation import ugettext as _

from molly.utils.views import BaseView
from molly.utils.breadcrumbs import *
from molly.utils.misc import AnyMethodRequest

from molly.apps.places.models import Entity

from .models import GeneratedMap

class GeneratedMapView(BaseView):
    breadcrumb = NullBreadcrumb

    def handle_GET(self, request, context, hash):
        gm = get_object_or_404(GeneratedMap, hash=hash)
        response = HttpResponse(open(gm.get_filename(), 'r').read(), mimetype='image/png')

        response['Expires'] = formatdate(mktime((datetime.now() + timedelta(days=7)).timetuple()))
        response['Last-Modified'] = formatdate(mktime(gm.generated.timetuple()))
        response['ETag'] = hash
        return response

class AboutView(BaseView):

    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name,
            None,
            _('About OpenStreetMap'),
            lazy_reverse('maps:osm-about'),
        )

    def handle_GET(self, request, context):
        return self.render(request, context, 'maps/osm/about')

class GPXView(BaseView):
    breadcrumb = NullBreadcrumb

    def handle_GET(self, request, context, ptype):
        out = []
        out.append('<?xml version="1.0"?>\n')
        out.append('<gpx version="1.0"')
        out.append(' creator="Molly Project &lt;http://mollyproject.org/&gt;"')
        out.append(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        out.append(' xmlns="http://www.topografix.com/GPX/1/0"')
        out.append(' xsi:schemaLocation="http://www.topografix.com/GPX/1/0 http://www.topografix.com/GPX/1/0/gpx.xsd">\n')

        for entity in Entity.objects.filter(primary_type__slug=ptype, source__module_name='molly.providers.apps.maps.osm'):
          out.append('  <wpt lat="%(lat)f" lon="%(lon)f">\n' % {'lat':entity.location[1], 'lon':entity.location[0]})
          out.append('    <name>%s</name>\n' % entity.title)
          out.append('  </wpt>\n')

        out.append('</gpx>')

        return HttpResponse(out, mimetype="application/gpx+xml")


########NEW FILE########
__FILENAME__ = molly_maps
from django import template
from django.template.loader import get_template

from molly.maps import map_from_point

register = template.Library()

class MapDisplayNode(template.Node):
    """
    Node to display a more complex map from a @C{molly.maps.Map} object
    """
    
    def __init__(self, map, force_static):
        """
        @param map: The Map to be rendered
        @type map: molly.maps.Map
        """
        self.map = map
        self.force_static = force_static
    
    def render(self, context):
        """
        Returns HTML for the map to be rendered
        
        @type context: dict
        """
        context.update({
                'map': template.Variable(self.map).resolve(context),
                'force_static': self.force_static
            })
        return get_template('maps/embed.html').render(context)


@register.tag
def render_map(parser, token):
    """    
    @raise template.TemplateSyntaxError: If incorrect arguments are passed
    @return: Ready for the map to be rendered
    @rtype: MapDisplayNode
    """
    contents = token.split_contents()
    if len(contents) == 2:
        tag_name, map = contents
        force_static = False
    elif len(contents) == 3:
        tag_name, map, force_static = contents
        force_static = force_static[1:-1] == 'printable'
    else:
        tag_name = token.contents.split()[0]
        raise template.TemplateSyntaxError, \
            "%r tag requires exactly 1 arguments: map" % tag_name
    return MapDisplayNode(map, force_static)


class LocationDisplayNode(template.Node):
    """
    Node to display a simple map with only one location
    """
    
    def __init__(self, place, force_static):
        """
        @param place: Point to render a map for
        """
        self.place = place
        self.force_static = force_static
    
    def render(self, context):
        """
        Returns HTML for the map to be rendered
        
        @type context: dict
        """
        context.update({
           'map': map_from_point(template.Variable(self.place).resolve(context),
                                 context['request'].map_width,
                                 context['request'].map_height,
                                 zoom=context.get('zoom', 16)),
           'force_static': self.force_static
           })
        return get_template('maps/embed.html').render(context)


@register.tag
def render_location_map(parser, token):
    """    
    @raise template.TemplateSyntaxError: If incorrect arguments are passed
    @return: Ready for the map to be rendered
    @rtype: PlaceDisplayNode
    """
    contents = token.split_contents()
    if len(contents) == 2:
        tag_name, place = contents
        force_static = False
    elif len(contents) == 3:
        tag_name, place, force_static = contents
        force_static = force_static[1:-1] == 'printable'
    else:
        tag_name = token.contents.split()[0]
        raise template.TemplateSyntaxError, \
            "%r tag requires exactly 1 arguments: location" % tag_name
    return LocationDisplayNode(place, force_static)


########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

import molly.maps.osm.urls

from views import IndexView

urlpatterns = patterns('',
        (r'^$', IndexView, {}, 'index'),
        (r'^osm/', include(molly.maps.osm.urls.urlpatterns)),
    )
########NEW FILE########
__FILENAME__ = views
from datetime import timedelta

from django.http import Http404
from django.utils.translation import ugettext as _

from molly.utils.views import BaseView
from molly.utils.breadcrumbs import *

class IndexView(BaseView):
    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name,
            None,
            _('Maps'),
            lazy_reverse('maps:osm-about'),
        )

    def handle_GET(self, request, context):
        raise Http404

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'CachedRoute'
        db.create_table('routing_cachedroute', (
            ('hash', self.gf('django.db.models.fields.CharField')(unique=True, max_length=56, primary_key=True)),
            ('expires', self.gf('django.db.models.fields.DateTimeField')()),
            ('_cache', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('routing', ['CachedRoute'])


    def backwards(self, orm):
        
        # Deleting model 'CachedRoute'
        db.delete_table('routing_cachedroute')


    models = {
        'routing.cachedroute': {
            'Meta': {'object_name': 'CachedRoute'},
            '_cache': ('django.db.models.fields.TextField', [], {}),
            'expires': ('django.db.models.fields.DateTimeField', [], {}),
            'hash': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '56', 'primary_key': 'True'})
        }
    }

    complete_apps = ['routing']

########NEW FILE########
__FILENAME__ = models
import base64
try:
    import cPickle as pickle
except ImportError:
    import pickle

from django.db import models

class CachedRoute(models.Model):
    
    hash = models.CharField(max_length=56, unique=True, primary_key=True)
    expires = models.DateTimeField()
    _cache = models.TextField()
    
    def _get_cache(self):
        return pickle.loads(base64.b64decode(self._cache))
    def _set_cache(self, value):
        self._cache = base64.b64encode(pickle.dumps(value))
    cache = property(_get_cache, _set_cache)

########NEW FILE########
__FILENAME__ = cloudmade
from urllib2 import urlopen
import simplejson

from django.conf import settings
from django.contrib.gis.geos import Point, LineString
from django.utils.translation import get_language, ugettext

from molly.utils.templatetags.molly_utils import humanise_seconds, humanise_distance

try:
    CLOUDMADE_URL = 'http://routes.cloudmade.com/%s/api/0.3/' % settings.API_KEYS['cloudmade']
except KeyError:
    raise ImportError()

def generate_route(points, type):
    """
    Given 2 Points, this will return a route between them. The route consists
    of a dictionary with the following keys:
    
    * error (optional, and if set means that the object contains no route),
      which is a string describing any errors that occurred in plotting the
      route
    * total_time: An int of the number of seconds this route is estimated to
      take
    * total_distance: An int of the number of metres this route is expected to
      take
    * waypoints: A list of dictionaries, where each dictionary has 2 keys:
      'instruction', which is a human-readable description of the steps to be
      taken here, and 'location', which is a Point describing the route to be
      taken
    
    @param points: An ordered list of points to be included in this route
    @type points: [Point]
    @param type: The type of route to generate (foot, car or bike)
    @type type: str
    @return: A dictionary containing the route and metadata associated with it
    @rtype: dict
    """
    
    def to_comma_string(p):
        return ','.join(reversed(map(str, p)))
    
    # Build cloudmade request:
    urlpoints = to_comma_string(points[0])
    
    if points[1:-1]:
        urlpoints += ',[' + ','.join(map(to_comma_string, points[1:-1])) + ']'
    
    urlpoints += ',' + to_comma_string(points[-1])
    
    url = CLOUDMADE_URL + '%s/%s.js?lang=%s' % (urlpoints, type, get_language()[:2])
    
    json = simplejson.load(urlopen(url))
    
    if json['status'] != 0:
        return {
            'error': json['status_message']
        }
    else:
        
        points = [Point(p[1], p[0], srid=4326) for p in json['route_geometry']]
        waypoints = []
        for i, waypoint in enumerate(json['route_instructions']):
            if i == 0:
                (instruction, length, position, time, length_caption,
                 earth_direction, azimuth) = waypoint
                turn_type = 'start'
            else:
                (instruction, length, position, time, length_caption,
                 earth_direction, azimuth, turn_type, turn_angle) = waypoint
                turn_type = {
                        'C': 'straight',
                        'TL': 'left',
                        'TSLL': 'slight-left',
                        'TSHL': 'sharp-left',
                        'TR': 'right',
                        'TSLR': 'slight-right',
                        'TSHR': 'sharp-right',
                        'TU': 'turn-around',
                    }.get(turn_type)
            waypoints.append({
                'instruction': instruction,
                'additional': ugettext('%(direction)s for %(distance)s (taking approximately %(time)s)') % {
                        'direction': earth_direction,
                        'distance': humanise_distance(length, False),
                        'time': humanise_seconds(time)
                    },
                'waypoint_type': turn_type,
                'location': points[position],
                'path': LineString(map(lambda ps: Point(*ps),
                            points[position:json['route_instructions'][i+1][2]+1] if i+1 < len(json['route_instructions']) else points[position:]
                        ))
            })
        
        return {
            'total_time': json['route_summary']['total_time'],
            'total_distance': json['route_summary']['total_distance'],
            'waypoints': waypoints,
            'path': LineString(map(lambda ps: Point(*ps), map(reversed, json['route_geometry'])))
        }


########NEW FILE########
__FILENAME__ = cyclestreets
from urllib import urlencode
from urllib2 import urlopen
import simplejson

from django.conf import settings
from django.contrib.gis.geos import Point, LineString
from django.utils.text import capfirst
from django.utils.translation import ugettext as _

from molly.apps.places.models import bearing_to_compass
from molly.utils.templatetags.molly_utils import humanise_distance, humanise_seconds

CYCLESTREETS_URL = 'http://www.cyclestreets.net/api/journey.json?%s'

if 'cyclestreets' not in settings.API_KEYS:
    # Cyclestreets not configured
    raise ImportError()

def generate_route(points, type):
    """
    Given 2 Points, this will return a route between them. The route consists
    of a dictionary with the following keys:
    
    * error (optional, and if set means that the object contains no route),
      which is a string describing any errors that occurred in plotting the
      route
    * total_time: An int of the number of seconds this route is estimated to
      take
    * total_distance: An int of the number of metres this route is expected to
      take
    * waypoints: A list of dictionaries, where each dictionary has 2 keys:
      'instruction', which is a human-readable description of the steps to be
      taken here, and 'location', which is a Point describing the route to be
      taken
    
    @param points: An ordered list of points to be included in this route
    @type points: [Point]
    @param type: The type of route to generate (foot, car or bike)
    @type type: str
    @return: A dictionary containing the route and metadata associated with it
    @rtype: dict
    """
    
    # Build Cyclestreets request:
    url = CYCLESTREETS_URL % urlencode({
        'key': settings.API_KEYS['cyclestreets'],
        'plan': 'balanced',
        'itinerarypoints': '|'.join('%f,%f' % (p[0], p[1]) for p in points)
    })
    
    json = simplejson.load(urlopen(url))
    
    if not json:
        return {
            'error': _('Unable to plot route')
        }
    else:
        
        summary = json['marker'][0]['@attributes']
        
        waypoints = []
        for i, waypoint in enumerate(json['marker'][1:]):
            segment = waypoint['@attributes']
            waypoints.append({
                'instruction': _('%(instruction)s at %(name)s') % {
                        'instruction': capfirst(segment['turn']),
                        'name': segment['name']
                    },
                'additional': _('%(direction)s for %(distance)s (taking approximately %(time)s)') % {
                        'direction': bearing_to_compass(int(segment['startBearing'])),
                        'distance': humanise_distance(segment['distance'], False),
                        'time': humanise_seconds(segment['time'])
                    },
                'waypoint_type': {
                        'straight on': 'straight',
                        'turn left': 'left',
                        'bear left': 'slight-left',
                        'sharp left': 'sharp-left',
                        'turn right': 'right',
                        'bear right': 'slight-right',
                        'sharp right': 'sharp-right',
                        'double-back': 'turn-around',
                    }.get(segment['turn']),
                'location': Point(*map(float, segment['points'].split(' ')[0].split(','))),
                'path': LineString(map(lambda ps: Point(*map(float, ps.split(','))),
                                       segment['points'].split(' ')))
            })
        
        return {
            'total_time': summary['time'],
            'total_distance': summary['length'],
            'waypoints': waypoints,
            'path': LineString(map(lambda ps: Point(*map(float, ps.split(','))), summary['coordinates'].split(' ')))
        }
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from django.conf import settings
from django.contrib import admin
from djcelery.models import PeriodicTask

from molly.conf.admin import RunnablePeriodicTaskAdmin
from molly.conf import applications, all_apps
from molly.utils.views import ReverseView
from molly.utils.i18n import SetLanguageView, javascript_catalog

# Admin
admin.autodiscover()
admin.site.unregister(PeriodicTask)
admin.site.register(PeriodicTask, RunnablePeriodicTaskAdmin)

urlpatterns = patterns('',
    (r'^adm/', include(admin.site.urls)), # Admin site
    (r'^comments/', include('django.contrib.comments.urls')), # Django comments
    (r'', applications.home.urls), # Home default
    (r'^reverse', ReverseView, {}, 'reverse'),
    (r'^set-language/$', SetLanguageView, {}, 'set-language'), # Change language view
    (r'^jsi18n/$', javascript_catalog,
     {'packages': settings.INSTALLED_APPS}, 'js-i18n')) # JS i18n catalogues

# Dynamically add apps
for app in (app for app in all_apps() if app.has_urlconf and app.local_name != 'home'):
    urlpatterns += patterns('',
        (r'^' + app.local_name + '/', include(app.urls)))

# Redirecting old URLs
urlpatterns += patterns('django.views.generic.simple',
    (r'^maps/busstop:(?P<atco>[A-Z\d]+)/(?P<remain>.*)$', 'redirect_to', {'url': '/places/atco:%(atco)s/%(remain)s'}),
    (r'^maps/[a-z]\-+:(?P<id>\d{8})/(?P<remain>.*)$', 'redirect_to', {'url': '/places/oxpoints:%(id)s/%(remain)s'}),
    (r'^maps/[a-z]\-+:(?P<id>[NW]\d{8})/(?P<remain>.*)$', 'redirect_to', {'url': '/places/osm:%(id)s/%(remain)s'}),
    (r'^maps/(?P<remain>.*)$', 'redirect_to', {'url': '/places/%(remain)s'}),
    (r'^osm/(?P<remain>.*)$', 'redirect_to', {'url': '/maps/osm/%(remain)s'}),
)

handler500 = 'molly.utils.views.handler500'

if settings.DEBUG:
    urlpatterns += patterns('',
        (r'^media/(?P<path>.*)$', 'django.views.static.serve',
            {'document_root': settings.STATIC_ROOT})
    )

########NEW FILE########
__FILENAME__ = middleware
import re

from django.http import HttpResponsePermanentRedirect

from .models import ShortenedURL

class URLShortenerMiddleware(object):
    url_re = re.compile(r"/[a-zA-Z\d]+")
    def process_response(self, request, response):
        if response.status_code == 404 and self.url_re.match(request.path):
            try:
                shortened_url = ShortenedURL.objects.get(slug=request.path[1:])
                return HttpResponsePermanentRedirect(shortened_url.path)
            except:
                pass
        return response

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'ShortenedURL'
        db.create_table('url_shortener_shortenedurl', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('path', self.gf('django.db.models.fields.TextField')()),
            ('slug', self.gf('django.db.models.fields.TextField')(max_length=7)),
        ))
        db.send_create_signal('url_shortener', ['ShortenedURL'])


    def backwards(self, orm):
        
        # Deleting model 'ShortenedURL'
        db.delete_table('url_shortener_shortenedurl')


    models = {
        'url_shortener.shortenedurl': {
            'Meta': {'object_name': 'ShortenedURL'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'path': ('django.db.models.fields.TextField', [], {}),
            'slug': ('django.db.models.fields.TextField', [], {'max_length': '7'})
        }
    }

    complete_apps = ['url_shortener']

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.core.urlresolvers import reverse

class ShortenedURL(models.Model):
    path = models.TextField()
    slug = models.TextField(max_length=7)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from views import IndexView

urlpatterns = patterns('',
    (r'^$',
        IndexView, {},
        'index'),
)

########NEW FILE########
__FILENAME__ = views
import random
import re
from datetime import timedelta

from django.http import Http404
from django.core.urlresolvers import resolve, reverse
from django.shortcuts import get_object_or_404
from django.utils.translation import ugettext as _

from molly.utils.views import BaseView

from molly.url_shortener import get_shortened_url

class IndexView(BaseView):

    def initial_context(self, request):
        try:
            path = request.GET['path']
            view, view_args, view_kwargs = resolve(path.split('?')[0])
            if getattr(view, 'simple_shorten_breadcrumb', False):
                view_context = None
            elif isinstance(view, IndexView):
                view_context = None
            else:
                try:
                    view_context = view.initial_context(request, *view_args, **view_kwargs)
                except Exception, e:
                    view_context = None

        except (KeyError, ):
            raise Http404

        return {
            'share_path': path,
            'view': view,
            'view_args': view_args,
            'view_kwargs': view_kwargs,
            'view_context': view_context,
            'complex_shorten': ('?' in path) or view_context is None or view_context.get('complex_shorten', False),
        }

    @staticmethod
    def breadcrumb(request, context):
        view, view_context = context['view'], context['view_context']
        view_args, view_kwargs = context['view_args'], context['view_kwargs']

        if not isinstance(context['view'], BaseView):
            return None

        if view_context:
            breadcrumb = view.breadcrumb(request, view_context, *view_args, **view_kwargs)
            context['page_title'] = breadcrumb[4]
            return (
                breadcrumb[0],
                breadcrumb[1],
                (breadcrumb[4], context['share_path']),
                breadcrumb[1] == (breadcrumb[4], context['share_path']),
                _('Shorten link'),
            )
        else:
            index = (view.conf.title, reverse('%s:index' % view.conf.local_name))
            return (
                view.conf.local_name,
                index,
                (u'Back\u2026', context['share_path']),
                context['share_path'] == index[1],
                _('Shorten link'),
            )

    def handle_GET(self, request, context):
        try:
            path = request.GET['path']
        except (KeyError):
            raise Http404()

        if IndexView in getattr(context['view'], '__mro__', ()):
            return self.redirect(path, request, 'perm')

        context['url'] = get_shortened_url(path, request, context['complex_shorten'])

        return self.render(request, context, 'url_shortener/index',
                           expires=timedelta(days=365))

########NEW FILE########
__FILENAME__ = breadcrumbs
from collections import namedtuple
import inspect

from django.core.urlresolvers import reverse, resolve

__all__ = [
    'Breadcrumb', 'BreadcrumbFactory', 'NullBreadcrumb', 'RenderedBreadcrumb',
    'RenderedBreadcrumbs', 'lazy_reverse', 'lazy_parent'
]

class Breadcrumb(object):
    def __init__(self, application, parent, title, url):
        self.application, self.title, self.url = application, title, url
        self.parent = parent

RenderedBreadcrumbs = namedtuple('RenderedBreadcrumbs',
                                ['application', 'index', 'parent',
                                 'parent_is_index', 'page_title', 'local_name'])

RenderedBreadcrumb = namedtuple('RenderedBreadcrumb',
                                ['title', 'url', 'page_name'])

def BreadcrumbFactory(breadcrumb_func):
    def data(self, request, context, *args, **kwargs):
        return breadcrumb_func(self, request, context, *args, **kwargs)
    
    def render(self, request, context, *args, **kwargs):
        breadcrumb = data(self, request, context, *args, **kwargs)
        
        if breadcrumb.parent:
            parent_data = breadcrumb.parent(self, breadcrumb.application, request, context)
            parent_url = parent_data.url(parent_data.application)
            resolved_parent = resolve(parent_url)
            parent = RenderedBreadcrumb(
                parent_data.title, parent_url,
                '%s:%s' % (':'.join(resolved_parent.namespaces), resolved_parent.url_name)
            )
        else:
            parent = None
        
        resolved_index = resolve(reverse('%s:index' % breadcrumb.application))
        index = resolved_index.func.breadcrumb.data(resolved_index.func, request, context)
        index = RenderedBreadcrumb(
            index.title, index.url(breadcrumb.application),
            '%s:%s' % (':'.join(resolved_index.namespaces), resolved_index.url_name)
        )
        
        parent_is_index = index == parent
        
        return RenderedBreadcrumbs(
            breadcrumb.application,
            index,
            parent,
            parent_is_index,
            breadcrumb.title,
            self.conf.local_name
        )
        
    render.data = data
    render.breadcrumb_func = breadcrumb_func

    return render

@staticmethod
def NullBreadcrumb(request, context, *args, **kwargs):
    return None

def lazy_reverse(view_name, *args, **kwargs):
    def f(application_name):
        view = view_name
        if ':' not in view:
            view = '%s:%s' % (application_name, view)
        return reverse(view, *args, **kwargs)
    return f
    
def static_reverse(path):
    def f():
        return path
    return f
    
def lazy_parent(view_name, *args, **kwargs):
    def f(self, application_name, request, context):
        view = view_name
        if ':' not in view:
            view = '%s:%s' % (application_name, view)
        view, view_args, view_kwargs = resolve(reverse(view, args=args, kwargs=kwargs))
        return view.breadcrumb.data(view, request, context, *view_args, **view_kwargs)
    return f

def static_parent(path, title, application=None):
    def f(self, app, request, context):
        return Breadcrumb(
            application, None, title, lambda app: path
        )
    return f
    

########NEW FILE########
__FILENAME__ = compress
""" Filter to remove whitespace from input CSS """

from __future__ import absolute_import

import re

from pipeline.compressors import CompressorBase

class MollyCSSFilter(CompressorBase):
    
    _COMMENT_RE = re.compile(r'/\*.*?\*/')
    _WHITESPACE_RE = re.compile(r'[ \t\n\r]+')
    
    def compress_css(self, css):
        css = self._COMMENT_RE.sub('', css)
        css = self._WHITESPACE_RE.sub(' ', css)
        return css.strip()

########NEW FILE########
__FILENAME__ = context_processors
from urlparse import urlparse, urlunparse, parse_qs
from urllib import urlencode

from django.conf import settings
from django.utils.translation import ugettext as _

from molly.utils.i18n import override
from molly.utils.views import tidy_query_string

def site_name(request):
    return {
        'site_name': settings.SITE_NAME if hasattr(settings, 'SITE_NAME') else 'Molly Project'
    }

def languages(request):
    languages = []
    for language_code, language_name in settings.LANGUAGES:
        with override(language_code):
            languages.append((language_code, _(language_name)))
    return {
        'LANGUAGES': languages,
    }

def full_path(request):
    return {
        'full_path': tidy_query_string(request.get_full_path()),
    }

def google_analytics(request):
    return {
        'google_analytics': settings.API_KEYS.get('google_analytics'),
    }

def ssl_media(request):
    """
    If the request is secure, then the media url should be HTTPS
    
    Source: http://djangosnippets.org/snippets/1754/
    """

    if request.is_secure():
        ssl_media_url = settings.STATIC_URL.replace('http://', 'https://')
    else:
        ssl_media_url = settings.STATIC_URL
  
    return {'STATIC_URL': ssl_media_url}

########NEW FILE########
__FILENAME__ = http
import urlparse
import urllib
import re

from django.http import HttpResponseRedirect

class HttpResponseSeeOther(HttpResponseRedirect):
    status_code = 303

def update_url(url, query_update, fragment = ''):
    """
    Replaces query parameters with those given in query_update, and updates the fragment.
    
    Use None to remove the relevant bits of the URL.
    """
    
    url = urlparse.urlparse(url)
    query = urlparse.parse_qs(url.query)
    for key, value in query_update.items():
        if value is None:
            query.pop(key, None)
        else:
            query[key] = value
    fragment = url[5] if fragment == '' else fragment
    return urlparse.urlunparse(url[:4] + (urllib.urlencode(query), fragment))
                
class MediaType(object):
    """
    Represents a parsed internet media type.
    """

    _MEDIA_TYPE_RE = re.compile(r'(\*/\*)|(?P<type>[^/]+)/(\*|((?P<subsubtype>[^+]+)\+)?(?P<subtype>.+))')    
    def __init__(self, value, priority=0):
        value = unicode(value).strip()
        media_type = value.split(';')
        media_type, params = media_type[0].strip(), dict((i.strip() for i in p.split('=', 1)) for p in media_type[1:] if '=' in p)

        mt = self._MEDIA_TYPE_RE.match(media_type)
        if not mt:
            raise ValueError("Not a correctly formatted internet media type (%r)" % media_type)
        mt = mt.groupdict()

        try:
            self.quality = float(params.pop('q', 1))
        except ValueError:
            self.quality = 1

        self.type = mt.get('type'), mt.get('subtype'), mt.get('subsubtype')
        self.specifity = len([t for t in self.type if t])
        self.params = params
        self.value = value
        self.priority = priority

    def __unicode__(self):
        return self.value

    def __gt__(self, other):
        if self.quality != other.quality:
            return self.quality > other.quality
        
        if self.specifity != other.specifity:
            return self.specifity > other.specifity
        
        for key in other.params:
            if self.params.get(key) != other.params[key]:
                return False
        
        return len(self.params) > len(other.params)
    
    def __lt__(self, other):
        return other > self

    def __eq__(self, other):
        return self.quality == other.quality and self.type == other.type and self.params == other.params
    def __ne__(self, other):
        return not self.__eq__(other)
    def equivalent(self, other):
        """
        Returns whether two MediaTypes have the same overall specifity.
        """
        return not (self > other or self < other)

    def __cmp__(self, other):
        if self > other:
            return 1
        elif self < other:
            return -1
        else:
            return 0

    def __repr__(self):
        return "%s(%r)" % (type(self).__name__, self.value)

    def provides(self, imt):
        """
        Returns True iff the self is at least as specific as other.

        Examples:
        application/xhtml+xml provides application/xml, application/*, */*
        text/html provides text/*, but not application/xhtml+xml or application/html
        """
        return self.type[:imt.specifity] == imt.type[:imt.specifity]
        
    @classmethod
    def resolve(self, accept, provide):
        """
        Resolves a list of accepted MediaTypes and available renderers to the preferred renderer.

        Call as MediaType.resolve([MediaType], [(MediaType, renderer)]).
        """
        if len(accept) == 0:
            return []
        accept.sort()
        eq_classes, accept = [[accept[-1]]], accept[:-1]

        # Group the accepted types into equivalence classes
        while accept:
            imt = accept.pop()
            if imt.equivalent(eq_classes[0][-1]):
                eq_classes[-1].append(imt)
            else:
                eq_classes.append([imt])

        renderers, seen_renderers = [], set()

        # For each equivalence class, find the first renderer MediaType that
        # can handle one of its members, and return the renderer.
        for imts in eq_classes:
            for provide_type, renderer in provide:
                for imt in imts:
                    if renderer not in seen_renderers and provide_type.provides(imt):
                        renderers.append(renderer)
                        seen_renderers.add(renderer)

        return renderers

########NEW FILE########
__FILENAME__ = i18n
from copy import copy

from django.utils.translation import get_language
from django.db.models import Model
from django.conf import settings
from django.core.exceptions import ObjectDoesNotExist
from django.views.i18n import set_language
from django.utils.translation import ugettext as _
from django.core.urlresolvers import reverse

from molly.utils.views import BaseView

def languages_to_try():
    languages = [get_language()]
    if '-' in languages[0]:
        languages.append(languages[0].split('-')[0])
    languages.append(settings.LANGUAGE_CODE)
    if '-' in settings.LANGUAGE_CODE:
        languages.append(settings.LANGUAGE_CODE.split('-')[0])
    return languages
    

def name_in_language(obj, field, default=None):
    """
    Assuming the object follows the Molly pattern for i18n data (related manager
    called names, and the related object has a language_code field), then get
    the i18n'd version of 'field' in the user's current language.
    """
    
    for language_code in languages_to_try():
        try:
            return getattr(obj.names.get(language_code=language_code), field)
        except ObjectDoesNotExist:
            continue
    return None


def set_name_in_language(obj, lang, **fields):
    """
    Assuming the object follows the Molly pattern for i18n data (related manager
    called names, and the related object has a language_code field), then set
    name/language pair to 'field'.
    """
    
    names = obj.names.filter(language_code=lang)
    if names.count() == 0:
        obj.names.create(language_code=lang, **fields)
    else:
        name = names[0]
        for k, v in fields.items():
            setattr(name, k, v)
        name.save()


class SetLanguageView(BaseView):

    def handle_GET(self, request, context):
        return self.render(request, context, 'i18n/index')
    
    def handle_POST(self, request, context):
        if hasattr(request, 'session'):
            # MOLLY-177: Force using cookies to set language
            session = request.session
            del request.session
            ret = set_language(request)
            request.session = session
            return ret
        
        else:
            
            # Do Django's built in language setter
            return set_language(request)


# TODO: When Molly moves to Django 1.4, this can be removed

"""
Below here contains backports from newer versions of Django, licensed under the
BSD license below:

Copyright (c) Django Software Foundation and individual contributors.
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

    1. Redistributions of source code must retain the above copyright notice, 
       this list of conditions and the following disclaimer.
    
    2. Redistributions in binary form must reproduce the above copyright 
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

    3. Neither the name of Django nor the names of its contributors may be used
       to endorse or promote products derived from this software without
       specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

try:
    from django.utils.translation import override
except ImportError:
    from django.utils.translation import activate, deactivate
    
    # Backported from Django
    class override(object):
        def __init__(self, language, deactivate=False):
            self.language = language
            self.deactivate = deactivate
            self.old_language = get_language()
        
        def __enter__(self):
            activate(self.language)
        
        def __exit__(self, exc_type, exc_value, traceback):
            if self.deactivate:
                deactivate()
            else:
                activate(self.old_language)

from django.views.i18n import (LibHead, LibFoot, LibFormatHead, LibFormatFoot,
                               SimplePlural, InterPolate, PluralIdx)
import os
import gettext as gettext_module
from django import http
from django.utils import importlib
from django.utils.translation import check_for_language, activate, to_locale, get_language
from django.utils.encoding import smart_unicode
from django.utils.text import javascript_quote
from django.utils.formats import get_format_modules, get_format
from django.views.i18n import get_formats

def javascript_catalog(request, domain='djangojs', packages=None):
    """
    Returns the selected language catalog as a javascript library.

    Receives the list of packages to check for translations in the
    packages parameter either from an infodict or as a +-delimited
    string from the request. Default is 'django.conf'.

    Additionally you can override the gettext domain for this view,
    but usually you don't want to do that, as JavaScript messages
    go to the djangojs domain. But this might be needed if you
    deliver your JavaScript source from Django templates.
    """
    if request.GET:
        if 'language' in request.GET:
            #if check_for_language(request.GET['language']):
            activate(request.GET['language'])
    if packages is None:
        packages = ['django.conf']
    if isinstance(packages, basestring):
        packages = packages.split('+')
    packages = [p for p in packages if p == 'django.conf' or p in settings.INSTALLED_APPS]
    default_locale = to_locale(settings.LANGUAGE_CODE)
    locale = to_locale(get_language())
    t = {}
    paths = []
    en_selected = locale.startswith('en')
    en_catalog_missing = True
    # paths of requested packages
    for package in packages:
        p = importlib.import_module(package)
        path = os.path.join(os.path.dirname(p.__file__), 'locale')
        paths.append(path)
    # add the filesystem paths listed in the LOCALE_PATHS setting
    paths.extend(list(reversed(settings.LOCALE_PATHS)))
    # first load all english languages files for defaults
    for path in paths:
        try:
            catalog = gettext_module.translation(domain, path, ['en'])
            t.update(catalog._catalog)
        except IOError:
            pass
        else:
            # 'en' is the selected language and at least one of the packages
            # listed in `packages` has an 'en' catalog
            if en_selected:
                en_catalog_missing = False
    # next load the settings.LANGUAGE_CODE translations if it isn't english
    if default_locale != 'en':
        for path in paths:
            try:
                catalog = gettext_module.translation(domain, path, [default_locale])
            except IOError:
                catalog = None
            if catalog is not None:
                t.update(catalog._catalog)
    # last load the currently selected language, if it isn't identical to the default.
    if locale != default_locale:
        # If the currently selected language is English but it doesn't have a
        # translation catalog (presumably due to being the language translated
        # from) then a wrong language catalog might have been loaded in the
        # previous step. It needs to be discarded.
        if en_selected and en_catalog_missing:
            t = {}
        else:
            locale_t = {}
            for path in paths:
                try:
                    catalog = gettext_module.translation(domain, path, [locale])
                except IOError:
                    catalog = None
                if catalog is not None:
                    locale_t.update(catalog._catalog)
            if locale_t:
                t = locale_t
    src = [LibHead]
    plural = None
    if '' in t:
        for l in t[''].split('\n'):
            if l.startswith('Plural-Forms:'):
                plural = l.split(':',1)[1].strip()
    if plural is not None:
        # this should actually be a compiled function of a typical plural-form:
        # Plural-Forms: nplurals=3; plural=n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;
        plural = [el.strip() for el in plural.split(';') if el.strip().startswith('plural=')][0].split('=',1)[1]
        src.append(PluralIdx % plural)
    else:
        src.append(SimplePlural)
    csrc = []
    pdict = {}
    for k, v in t.items():
        if k == '':
            continue
        if isinstance(k, basestring):
            csrc.append("catalog['%s'] = '%s';\n" % (javascript_quote(k), javascript_quote(v)))
        elif isinstance(k, tuple):
            if k[0] not in pdict:
                pdict[k[0]] = k[1]
            else:
                pdict[k[0]] = max(k[1], pdict[k[0]])
            csrc.append("catalog['%s'][%d] = '%s';\n" % (javascript_quote(k[0]), k[1], javascript_quote(v)))
        else:
            raise TypeError(k)
    csrc.sort()
    for k, v in pdict.items():
        src.append("catalog['%s'] = [%s];\n" % (javascript_quote(k), ','.join(["''"]*(v+1))))
    src.extend(csrc)
    src.append("""var language_code = '%s'""" % locale)
    src.append(LibFoot)
    src.append(InterPolate)
    src.append(LibFormatHead)
    src.append(get_formats())
    src.append(LibFormatFoot)
    src = ''.join(src)
    return http.HttpResponse(src, 'text/javascript')

########NEW FILE########
__FILENAME__ = installer
#################################
# BEGIN borrowed from Django    #
# licensed under the BSD        #
# http://www.djangoproject.com/ #
#################################

import os

def fullsplit(path, result=None):
    """
    Split a pathname into components (the opposite of os.path.join) in a
    platform-neutral way.
    """
    if result is None:
        result = []
    head, tail = os.path.split(path)
    if head == '':
        return [tail] + result
    if head == path:
        return result
    return fullsplit(head, [tail] + result)

def get_packages_and_data(root_dir):
    # Compile the list of packages available, because distutils doesn't have
    # an easy way to do this.
    packages, data_files = [], []
    if root_dir != '':
        os.chdir(root_dir)
    molly_dir = 'molly'
    
    for dirpath, dirnames, filenames in os.walk(molly_dir):
        # Ignore dirnames that start with '.'
        for i, dirname in enumerate(dirnames):
            if dirname.startswith('.'): del dirnames[i]
        if '__init__.py' in filenames:
            packages.append('.'.join(fullsplit(dirpath)))
        elif filenames:
            data_files.append([dirpath, [os.path.join(dirpath, f) for f in filenames]])
    
    return packages, data_files

#################################
# END borrowed from Django      #
#################################

########NEW FILE########
__FILENAME__ = deploy
import os
from optparse import make_option

from django.core.management import call_command
from django.core.management.base import NoArgsCommand

class Command(NoArgsCommand):
    
    option_list = NoArgsCommand.option_list + (
        make_option('--develop',
            action='store_true',
            dest='develop',
            default=False,
            help='Create symlinks, rather than copy, existing media, then start the dev server'),
        )

    def handle_noargs(self, develop, **options):
        call_command('sync_and_migrate')
        try:
            from molly.wurfl import wurfl_data
        except ImportError:
            no_wurfl = True
        else:
            no_wurfl = False
        if no_wurfl or not develop:
            call_command('update_wurfl')
        call_command('generate_markers', lazy=True)
        call_command('collectstatic', interactive=False, link=(develop and os.name != 'nt'))
        # Forcing compression because it seems to not compress *sometimes* even if files
        # have been changed...
        call_command('synccompress')
        call_command('synccompress', force=True)
        if develop:
            call_command('runserver')

########NEW FILE########
__FILENAME__ = generate_cache_manifest
import os
import os.path

from django.core.management.base import NoArgsCommand
from django.conf import settings

class Command(NoArgsCommand):
    
    can_import_settings = True

    def handle_noargs(self, **options):
        cache_manifest_path = os.path.join(settings.STATIC_ROOT,
                                           'cache.manifest')
        static_prefix_length = len(settings.STATIC_ROOT.split(os.sep))
        with open(cache_manifest_path, 'w') as cache_manifest:
            print >>cache_manifest, "CACHE MANIFEST"
            print >>cache_manifest, "CACHE:"
            for root, dirs, files in os.walk(settings.STATIC_ROOT):
                if root == settings.STATIC_ROOT:
                    # Don't cache admin media, desktop or markers
                    if 'admin' in dirs: dirs.remove('admin')
                    if 'desktop' in dirs: dirs.remove('desktop')
                    if 'markers' in dirs: dirs.remove('markers')
                
                if root == os.path.join(settings.STATIC_ROOT, 'touchmaplite', 'images'):
                    # Don't cache touchmaplite markers, we don't use them
                    if 'markers' in dirs: dirs.remove('markers')
                    if 'iui' in dirs: dirs.remove('iui')
                url = '/'.join(root.split(os.sep)[static_prefix_length:])
                for file in files:
                    # Don't cache uncompressed JS/CSS
                    _, ext = os.path.splitext(file)
                    if ext in ('.js','.css') and 'c' != url.split('/')[0]:
                        continue
                    
                    # Don't cache ourselves!
                    if file == 'cache.manifest':
                        continue
                    
                    print >>cache_manifest, "%s%s/%s" % (settings.STATIC_URL, url, file)
########NEW FILE########
__FILENAME__ = sync_and_migrate
import os
import os.path
import sys

from django.db import transaction
from django.db.utils import DatabaseError
from django.core.management import call_command
from django.core.management.base import NoArgsCommand
from django.conf import settings

from south.models import MigrationHistory

class Command(NoArgsCommand):
    
    can_import_settings = True

    def handle_noargs(self, **options):
        try:
            # This triggers a database lookup, if it fails (table doesn't exist)
            # then it means South hasn't been installed, so we need to do a
            # first sync to work around South's confusion between molly.auth
            # and django.contrib.auth
            savepoint = transaction.savepoint()
            MigrationHistory.objects.all()[0]
        except (DatabaseError, IndexError):
            transaction.savepoint_rollback(savepoint)
            print "Doing first sync..."
            call_command('syncdb', migrate_all=True)
            call_command('migrate', fake=True)
        else:
            print "Doing db sync..."
            call_command('syncdb')
            # patch to solve a bug in data migration (app feeds/003)
            # migrate places first because other apps depend on it
            call_command('migrate', 'places')
            call_command('migrate')


########NEW FILE########
__FILENAME__ = media
"""
Handles generating the settings variables for django-compress
"""

import os, os.path

def get_compress_groups(STATIC_ROOT):
    COMPRESS_CSS, COMPRESS_JS = {}, {}
    
    if not os.path.exists(STATIC_ROOT):
        os.makedirs(STATIC_ROOT)
    
    for directory in os.listdir(STATIC_ROOT):
        # We don't want to compress admin media or already-compressed media.
        # Due to the structure of the leaflet directory (as its distributed like
        # that) and the fact that it's already minified), we don't compress it
        # blueprint is only used for desktop site, no need to compress it
        if directory in ('admin', 'c', 'leaflet', 'blueprint',):
            continue
        directory = os.path.join(STATIC_ROOT, directory)
        for root, dirs, files in os.walk(directory):
            for filename in files:
                filename = os.path.relpath(os.path.join(root, filename), STATIC_ROOT)
                if filename.endswith('.css'):
                    compress = COMPRESS_CSS
                elif filename.endswith('.js'):
                    compress = COMPRESS_JS
                else:
                    continue
                
                path = filename.split(os.sep)[1:-1]
                output_filename = filename.split(os.sep)[-1].rsplit('.', 1)
                group = '-'.join(path + [output_filename[0],])
                if group.startswith('css-') or group.startswith('js-'):
                    group = group.split('-', 1)[1]
                if not group in compress:
                    output_filename = '.'.join((output_filename[0], 'v?', output_filename[1]))
                    output_filename = os.path.join(os.path.join('c', *path), output_filename)

                    # Create the target directory if it doesn't already exist.
                    if not os.path.exists(os.path.join(STATIC_ROOT, os.path.dirname(output_filename))):
                        os.makedirs(os.path.join(STATIC_ROOT, os.path.dirname(output_filename)))

                    compress[group] = {
                        'source_filenames': (),
                        'output_filename': output_filename,
                        'extra_context': {},
                    }
                compress[group]['source_filenames'] += (filename,)
    
    return COMPRESS_CSS, COMPRESS_JS

########NEW FILE########
__FILENAME__ = middleware
import sys
import logging

from collections import namedtuple
from django.http import Http404
from django.conf import settings
from django.contrib.gis.geos import Point
from django.core.exceptions import ImproperlyConfigured, PermissionDenied
from django.middleware.locale import LocaleMiddleware
from django.utils import translation
from django.core.signals import got_request_exception

from molly.utils.views import handler500

logger = logging.getLogger(__name__)

Location = namedtuple('Location', ['point', 'accuracy'])

class LocationMiddleware(object):
    """
    Adds a user_location attribute to requests where the user's location
    can be determined by any of a number of means (query string parameters,
    HTTP header, previously set session variable, etc)
    
    user_location is a namedtuple of (point, accuracy). user_location.point
    is a django.contrib.gis.geos.Point object using SRID 4326
    """
    def process_request(self, request):
        latitude = None
        longitude = None
        accuracy = None

        # If the request has latitude and longitude query params, use those
        if 'latitude' in request.GET and 'longitude' in request.GET:
            latitude = request.GET['latitude']
            longitude = request.GET['longitude']
            accuracy = request.GET.get('accuracy')

        # Else look for an X-Current-Location header with the format
        # X-Current-Location: latitude=0.0,longitude=0.0,accuracy=1
        elif 'HTTP_X_CURRENT_LOCATION' in request.META:
            location_string = request.META['HTTP_X_CURRENT_LOCATION']
            try:
                temp_dict = dict([token.split('=') for token in location_string.split(',')])
                if 'latitude' in temp_dict and 'longitude' in temp_dict:
                    latitude = temp_dict['latitude']
                    longitude = temp_dict['longitude']
                    accuracy = temp_dict.get('accuracy')
            except ValueError:
                # Malformed X-Current-Location header (e.g. latitude=0.0&foo)
                pass
                
        # Else use a geolocation:location session variable
        elif 'geolocation:location' in request.session:
            longitude, latitude = request.session['geolocation:location']
            accuracy = request.session.get('geolocation:accuracy')

        if latitude and longitude:
            point = Point(float(longitude), float(latitude), srid=4326)
            if accuracy:
                accuracy = float(accuracy)
            else:
                accuracy = None
            request.user_location = Location(point, accuracy)

class ErrorHandlingMiddleware(object):
    def process_exception(self, request, exception):
        if isinstance(exception, Http404):
            return
        elif isinstance(exception, PermissionDenied):
            return
        elif isinstance(exception, ImproperlyConfigured):
            logger.critical("Site improperly configured", exc_info=True)
        else:
            logger.exception("[500] %s at %s" % (type(exception).__name__, request.path))
            got_request_exception.send(sender=self, request=request)
            return handler500(request, exc_info=sys.exc_info())

class CookieLocaleMiddleware(LocaleMiddleware):
    
    def process_request(self, request):
        
        language_code = request.REQUEST.get('language_code')
        
        if language_code and language_code in dict(settings.LANGUAGES):
            translation.activate(language_code)
        
        else:
            
            if hasattr(request, 'session'):
                # MOLLY-177: Force using cookies to set language
                session = request.session
                del request.session
                super(CookieLocaleMiddleware, self).process_request(request)
                request.session = session
                
            else:
                
                super(CookieLocaleMiddleware, self).process_request(request)
    
    def process_response(self, request, response):
        
        language_code = request.REQUEST.get('language_code')
        if language_code and language_code in dict(settings.LANGUAGES):
            response.set_cookie(settings.LANGUAGE_COOKIE_NAME, language_code)
        
        return super(CookieLocaleMiddleware, self).process_response(request,
                                                                    response)


########NEW FILE########
__FILENAME__ = misc
import urllib2
import sys
import os.path
import imp

class AnyMethodRequest(urllib2.Request):
    def __init__(self, url, data=None, headers={}, origin_req_host=None, unverifiable=None, method=None):
        self.method = method and method.upper() or None
        urllib2.Request.__init__(self, url, data, headers, origin_req_host, unverifiable)

    def get_method(self):
        if not self.method is None:
            return self.method
        elif self.has_data():
            return "POST"
        else:
            return "GET"


def get_norm_sys_path():
    """
    Returns a normalised path that can be used for PYTHONPATH to recreate the
    path used for this invocation. 
    """

    sys_path = sys.path[:]

    # Find the path to the first package containing the settings module.
    # Once we have it, normalise it and add it to our sys_path if it isn't
    # already there.
    try:
        project_path = imp.find_module(os.environ['DJANGO_SETTINGS_MODULE'].split('.')[0])[1]
    except ImportError:
        project_path = os.path.dirname(imp.find_module('settings')[1])
    sys_path.insert(0, os.path.join(project_path, '..'))

    sys_path = [os.path.normpath(p) for p in sys_path if p != '']

    # Remove duplicates. This is O(n^2), but efficiency isn't too much of an
    # issue when n is small.
    sys_path = [p for i,p in enumerate(sys_path) if p not in sys_path[:i]]

    return sys_path
########NEW FILE########
__FILENAME__ = simplify
import itertools
import datetime
from logging import getLogger

from lxml import etree

from django.contrib.gis.geos import Point
from django.contrib.gis.measure import Distance
from django.core.paginator import Page
from django.db import models
from django.utils.functional import Promise as lazy_translation

logger = getLogger(__name__)


class DateUnicode(unicode):
    pass


class DateTimeUnicode(unicode):
    pass


_XML_DATATYPES = (
    (DateUnicode, 'date'),
    (DateTimeUnicode, 'datetime'),
    (str, 'string'),
    (unicode, 'string'),
    (int, 'integer'),
    (float, 'float'),
)

FIELDS_NOT_EXPOSED = ('password', 'user_email',)


def simplify_value(value):
    if hasattr(value, 'simplify_for_render'):
        return value.simplify_for_render(simplify_value, simplify_model)
    elif isinstance(value, dict):
        out = {}
        for key in value:
            new_key = key if isinstance(key, (basestring, int)) else str(key)
            try:
                out[new_key] = simplify_value(value[key])
            except NotImplementedError:
                logger.info('Could not simplify field %s of type %s',
                            key, type(value[key]), exc_info=True)
                pass
        return out
    elif isinstance(value, tuple) and hasattr(value, '_asdict'):
        # Handle named tuples as dicts
        return simplify_value(value._asdict())
    elif isinstance(value, (list, tuple, set, frozenset)):
        out = []
        for subvalue in value:
            try:
                out.append(simplify_value(subvalue))
            except NotImplementedError:
                logger.info('Could not simplify a value of type %s',
                            type(subvalue), exc_info=True)
        if isinstance(value, tuple):
            return tuple(out)
        else:
            return out
    elif isinstance(value, (basestring, int, float)):
        return value
    elif isinstance(value, lazy_translation):
        return unicode(value)
    elif isinstance(value, datetime.datetime):
        return DateTimeUnicode(value.isoformat(' '))
    elif isinstance(value, datetime.date):
        return DateUnicode(value.isoformat())
    elif hasattr(type(value), '__mro__') and models.Model in type(value).__mro__:
        return simplify_model(value)
    elif isinstance(value, Page):
        return {
            'has_next': value.has_next(),
            'has_previous': value.has_next(),
            'next_page_number': value.has_next(),
            'previous_page_number': value.has_next(),
            'number': value.number,
            'objects': simplify_value(value.object_list),
            'num_pages': value.paginator.num_pages,
            'num_objects': value.paginator.count,
        }
    elif value is None:
        return None
    elif isinstance(value, Point):
        return simplify_value(list(value))
    elif isinstance(value, Distance):
        # This is here to avoid a circular import
        from molly.utils.templatetags.molly_utils import humanise_distance
        return simplify_value(humanise_distance(value.m))
    elif hasattr(value, '__iter__'):
        # Iterators may be unbounded; silently ignore elements once we've already had 1000.
        return [simplify_value(item) for item in itertools.islice(value, 1000)]
    else:
        raise NotImplementedError


def simplify_model(obj, terse=False):
    if obj is None:
        return None
    # It's a Model instance
    # "expose_fields" is never used
    if hasattr(obj._meta, 'expose_fields'):
        expose_fields = obj._meta.expose_fields
    else:
        expose_fields = [f.name for f in obj._meta.fields]
    out = {
        '_type': '%s.%s' % (obj.__module__[:-7], obj._meta.object_name),
        '_pk': obj.pk,
    }
    if hasattr(obj, 'get_absolute_url'):
        out['_url'] = obj.get_absolute_url()
    if terse:
        out['_terse'] = True
    else:
        for field_name in expose_fields:
            if field_name in FIELDS_NOT_EXPOSED:
                continue
            try:
                value = getattr(obj, field_name)
                if isinstance(value, models.Model):
                    value = simplify_model(value, terse=True)
                out[field_name] = simplify_value(value)
            except NotImplementedError:
                pass

        # Add any non-field attributes
        for field in list(dir(obj)):
            try:
                if field[0] != '_' and field != 'objects' \
                        and not isinstance(getattr(obj, field), models.Field) \
                        and not field in FIELDS_NOT_EXPOSED:
                    try:
                        out[field] = simplify_value(getattr(obj, field))
                    except NotImplementedError:
                        pass
            except AttributeError:
                pass
    return out


def serialize_to_xml(value):
    if value is None:
        node = etree.Element('null')
    elif isinstance(value, bool):
        node = etree.Element('literal')
        node.text = 'true' if value else 'false'
        node.attrib['type'] = 'boolean'
    elif isinstance(value, (basestring, int, float)):
        node = etree.Element('literal')
        try:
            node.text = unicode(value)
        except UnicodeDecodeError:
            # Encode as UTF-8 if ASCII string can not be encoded
            node.text = unicode(value, 'utf-8')
        node.attrib['type'] = [d[1] for d in _XML_DATATYPES if isinstance(value, d[0])][0]
    elif isinstance(value, dict):
        if '_type' in value:
            node = etree.Element('object', {'type': value['_type'], 'pk': unicode(value.get('_pk', ''))})
            del value['_type']
            del value['_pk']
            if '_url' in value:
                node.attrib['url'] = value['_url']
                del value['_url']
            if value.get('_terse'):
                node.attrib['terse'] = 'true'
                del value['_terse']
        else:
            node = etree.Element('collection', {'type': 'mapping'})
        for key in value:
            v = serialize_to_xml(value[key])
            subnode = etree.Element('item', {'key': key})
            subnode.append(v)
            node.append(subnode)
    elif isinstance(value, (list, tuple, set, frozenset)):
        for x, y in ((list, 'list'), (tuple, 'tuple')):
            if isinstance(value, x):
                node = etree.Element('collection', {'type': y})
                break
        else:
            node = etree.Element('collection', {'type': 'set'})
        for item in value:
            v = serialize_to_xml(item)
            subnode = etree.Element('item')
            subnode.append(v)
            node.append(subnode)
    else:
        node = etree.Element('unknown')

    return node

########NEW FILE########
__FILENAME__ = molly_utils
# -*- coding: utf-8 -*-
try:
    import cStringIO as StringIO
except ImportError:
    import StringIO

from lxml import etree
import math
from datetime import datetime
from dateutil.tz import tzutc, tzlocal

from django import template
from django.conf import settings
from django.template.defaultfilters import stringfilter
from django.utils.safestring import SafeUnicode, mark_safe
from django.utils.translation import ugettext as _
from django.utils.translation import ungettext

from molly.utils.xslt import transform
from molly.wurfl import device_parents
from molly.apps.places import get_entity
from molly.apps.places.models import Entity
from molly.conf.applications import has_app_by_local_name

register = template.Library()

@register.filter
@stringfilter
def app_is_loaded(app):
    return has_app_by_local_name(app)

@register.filter
def sanitize_html(value, args=''):
    document = etree.fromstring(u'<body>%s</body>' % value, parser = etree.HTMLParser())

    args = args.split(',') + [None, None]
    id_prefix, class_prefix = args[0] or 'sani', args[1] or 'sani'

    document = transform(document, 'utils/sanitize_html.xslt', {
        'id_prefix': id_prefix,
        'class_prefix': class_prefix,
    })
    return SafeUnicode(etree.tostring(document)[6:-7])

@register.filter(name="gte")
def gte(value, arg):
    return value >= float(arg)

@register.filter(name="lte")
def lte(value, arg):
    return value <= arg

@register.filter(name="contains")
def contains(value, arg):
    return arg in value

@register.filter
def this_year(value, arg=None):
    if not arg:
        arg = datetime.now()
    return value.year == arg.year

@register.filter
def humanise_distance(value, round10=True):
    """
    Takes a distance in metres and returns it in sensible units
    """
    if round10:
        m = int(math.ceil(float(value)/10)*10)
    else:
        m = int(value)
    units = getattr(settings, 'DISTANCE_UNITS', 'british')
    
    if units == 'metric':
    
        if m >= 1000:
            # Translators: Distance in kilometres
            return _('%.1fkm') % round(float(m) / 1000, 2)
        else:
            # Translators: Distance in metres
            return _('%dm') % m
    
    elif units == 'imperial':
        
        yds = int(math.ceil((int(value) * 1.0936133)/10)*10)
        if yds >= 1200:
            # Translators: Distance in miles
            return _('%.1f miles') % round(float(yds) / 5280, 2)
        else:
            # Translators: Distance in yards
            return _('%d yards') % yds
        
    elif units == 'british':
        
        if m >= 1000:
            # Translators: Distance in miles
            return _('%.1f miles') % round(float(m) / 1609.344, 2)
        else:
            # Translators: Distance in metres
            return _('%dm') % m

@register.filter
def humanise_seconds(seconds):
    
    seconds = int(seconds)
    # <30 secs = less than 30 seconds
    
    if seconds < 30:
        return _('less than 30 seconds')
    
    hours, seconds = seconds // 3600, seconds % 3600
    minutes, seconds = seconds // 60, seconds % 60
    
    # 30secs to 2 minutes = exact
    if (hours, minutes) < (0, 2):
        # Translators: Seconds
        second_t = ungettext('%d sec', '%d secs', seconds) % seconds
        # Translators: Minutes
        minute_t = ungettext('%d min', '%d mins', minutes) % minutes
        
        if minutes == 0:
            return second_t
        else:
            if seconds:
                return '%s %s' % (minute_t, second_t)
            else:
                return minute_t
    
    # 2 minutes to 5 mins: mins and secs, rounded up to 10
    elif (hours, minutes) < (0, 5):
        # Translators: Minutes and seconds
        seconds = int(math.ceil(float(seconds)/10)*10)
        if seconds == 60:
            minutes += 1
            seconds = 0
        
        # Translators: Seconds
        second_t = ungettext('%d sec', '%d secs', seconds) % seconds
        # Translators: Minutes
        minute_t = ungettext('%d min', '%d mins', minutes) % minutes
        
        if seconds:
            return '%s %s' % (minute_t, second_t)
        else:
            return minute_t
    
    # 5 mins to 10 mins: mins and secs rounded to quarter mins
    elif (hours, minutes) < (0, 10):
        
        seconds = int(math.ceil(float(seconds)/15))
        if seconds == 4:
            minutes += 1
        
        if seconds in (0,4):
            second_t = ''
        else:
            second_t = {
                # Translators: A quarter minute
                1: _(u'¼'),
                # Translators: A half minute
                2: _(u'½'),
                # Translators: Three-quarters of a minute
                3: _(u'¾'),
            }.get(seconds)
        
        # Translators: Minutes with fractions
        return _('%(minutes)d%(seconds)s mins') % {
            'minutes': minutes,
            'seconds': second_t
        }
    
    # 10mins-30mins: mins and secs rounded to half mins
    elif (hours, minutes) < (0, 30):
        
        seconds = int(math.ceil(float(seconds)/30))
        if seconds == 2:
            minutes += 1
        
        if seconds in (0,2):
            second_t = ''
        else:
            # Translators: A half minute
            second_t = _(u'½')
        
        # Translators: Minutes with fractions
        return _('%(minutes)d%(seconds)s mins') % {
            'minutes': minutes,
            # Translators: A half minute
            'seconds': _(u'½')
        }
        
    # 30mins+ mins (and hours)
    else:
        # Translators: Hours
        hour_t = ungettext('%d hour', '%d hours', hours) % hours
        
        # Translators: Minutes
        minute_t = ungettext('%d min', '%d mins', minutes) % minutes
        
        return '%s %s' % (hour_t, minute_t)

UNUSUAL_NUMBERS = {
    '+448454647': '0845 46 47', # NHS Direct
    '+448457909090': '08457 90 90 90' # Samaritans
}

@register.filter(name="telephone")
def telephone(value, arg=None):
    """
    Formats UK telephone numbers to E.123 format (national notation)
    
    University number ranges are also formatted according to internal guidelines
    """
    
    # Normalise a number
    value = value.replace(" ", "").replace("-", "")
    if value.startswith("0"):
        value = "+44" + value[1:]
    normalised = value
    
    # Check if it's a number which is formatted in a special way
    if normalised in UNUSUAL_NUMBERS:
        value = UNUSUAL_NUMBERS[normalised]
    else:
        # Figure out how to format that number
        
        # Convert UK numbers into national format
        if value.startswith("+44"):
            value = "0" + value[3:]
        
        # Now apply rules on how to split up area codes
        if value[:8] in ('01332050', '01382006'):
            # Direct dial only
            value = value[:5] + " " + value[5:]
        elif value[:7] in ('0141005', '0117101') or value[:6] in ('011800',):
            # Direct dial only
            value = value[:4] + " " + value[4:7] + " " + value[7:]
        elif value[:7] in ('0200003',):
            # Direct dial only
            value = value[:3] + " " + value[3:7] + " " + value[7:]
        elif value.startswith('01'):
            if value[2] == '1' or value[3] == '1':
                # 4 digit area codes
                area_code = value[:4]
                local_part =  value[4:7] + " " + value[7:]
            elif value[:6] in (
                        '013873', # Langholm
                        '015242', # Hornby
                        '015394', # Hawkshead
                        '015395', # Grange-over-Sands
                        '015396', # Sedbergh
                        '016973', # Wigton
                        '016974', # Raughton Head
                        '016977', # Brampton
                        '017683', # Appleby
                        '017684', # Pooley Bridge
                        '017687', # Keswick
                        '019467', # Gosforth
                    ):
                # 6 digit area codes
                area_code = value[:4] + " " + value[4:6]
                local_part = value[6:]
            else:
                # 5 digit
                area_code = value[:5]
                local_part = value[5:]
            
            value = "(%s) %s" % (area_code, local_part)
        
        elif value.startswith('02'):
            # 3 digit area codes
            value = "(%s) %s %s" % (value[:3], value[3:7], value[7:])
        
        elif value.startswith('0500') or value.startswith('0800'):
            # direct dial - 4 digit prefix, short following
            value = "%s %s" % (value[:4], value[4:])
        
        elif value.startswith('03') or value.startswith('08') or value.startswith('09'):
            # direct dial - 4 digit prefix
            value = "%s %s %s" % (value[:4], value[4:7], value[7:])
        
        elif value.startswith('05') or value.startswith('070'):
            # direct dial - 3 digit prefix
            value = "%s %s %s" % (value[:3], value[3:7], value[7:])
        
        elif value.startswith('07'):
            # direct dial - 5 digit prefix, short following
            value = "%s %s" % (value[:5], value[5:])

    # Now apply University rules:
    if value[:10] in ('(01865) 27', '(01865) 28', '(01865) 43', '(01865) 61'):
            # Oxford - list of internal number prefixes here:
            # http://www.oucs.ox.ac.uk/telecom/directories/intdiraccess.xml
            value = "(01865 " + value[8] + ")" + value[9:]

    if arg == 'nolink':
        return value
    else:
        return mark_safe('<a href="tel:%s">%s</a>' % (normalised, value))

@register.filter
def telephone_uri(value):
    value = value.replace(" ", "").replace('-','')
    if value.startswith("0"):
        value = "+44" + value[1:]
    value = "tel:" + value

    return value

@register.filter(name="device_has_parent")
def device_has_parent(value, arg):
    if not value:
        return False
    return arg in device_parents[value.devid]

@register.filter
def header_width(value):
    try:
        value = int(value)
        if value < 160:
            return 128
        elif value < 240:
            return 160
    except ValueError, e:
        pass
    return 128

@register.filter('get_entity')
def get_entity_filter(value):
    return get_entity(*value)

@register.filter
def localize_utc(value):
    """
    Localise a UTC datetime
    """
    if isinstance(value, datetime):
        return value.replace(tzinfo=tzutc()).astimezone(tzlocal())
    else:
        return value

@register.tag
def svg_or_png(parser, token):
    return SvgOrPngNode()

class SvgOrPngNode(template.Node):

    def render(self, context):
        if device_has_parent(context['device'], 'apple_generic') or context['browser'].svgt_1_1:
            return 'svg'
        else:
            return 'png'


########NEW FILE########
__FILENAME__ = template_loaders
import os.path

from django.conf import settings
from django.template import TemplateDoesNotExist
from django.template.loader import BaseLoader
import django.template.loaders.app_directories
import django.template.loaders.filesystem

class MollyDefaultLoader(BaseLoader):
    """
    Always shows the built-in templates as molly_default/...
    """
    
    is_usable = True
    def load_template_source(self, template_name, template_dirs=None):
        template_parts = template_name.split('/')
        if template_parts[0] == 'molly_default':
            template_rest = '/'.join(template_parts[1:])
            try:
                loader = django.template.loaders.app_directories.Loader()
                return loader.load_template_source(template_rest, template_dirs)
            except TemplateDoesNotExist:
                loader = django.template.loaders.filesystem.Loader()
                return loader.load_template_source(
                  template_rest,
                  (os.path.join(os.path.dirname(__file__), '..', 'templates'),))
        else:
            # This isn't a template we care about
            raise TemplateDoesNotExist()
########NEW FILE########
__FILENAME__ = views
from email.utils import formatdate
from time import mktime
from inspect import isfunction
import logging
import itertools
from datetime import datetime, timedelta
from slimmer.slimmer import xhtml_slimmer
from urlparse import urlparse, urlunparse, parse_qs
from urllib import urlencode

import simplejson
from lxml import etree

from django.http import (HttpRequest, HttpResponse, HttpResponseBadRequest,
                         HttpResponseNotAllowed, Http404,
                         HttpResponseRedirect, HttpResponsePermanentRedirect)
from django.template import loader, Context, RequestContext
from django.template.loader_tags import BlockNode, ExtendsNode
from django.shortcuts import render_to_response
from django.core.urlresolvers import reverse, resolve, NoReverseMatch
from django.conf import settings
from django.utils.translation import ugettext as _
from django.views.debug import technical_500_response
from django.middleware.csrf import get_token

logger = logging.getLogger(__name__)

from molly.utils.http import MediaType, HttpResponseSeeOther
from molly.utils.simplify import (simplify_value, serialize_to_xml)
from molly.utils.breadcrumbs import NullBreadcrumb

def renderer(format, mimetypes=(), priority=0):
    """
    Decorates a view method to say that it renders a particular format and
    mimetypes.

    Use as:
        @renderer(format="foo")
        def render_foo(self, request, context, template_name): ...
    or
        @renderer(format="foo", mimetypes=("application/x-foo",))
        def render_foo(self, request, context, template_name): ...
    
    The former case will inherit mimetypes from the previous renderer for that
    format in the MRO. Where there isn't one, it will default to the empty
    tuple.

    Takes an optional priority argument to resolve ties between renderers.
    """

    def g(f):
        f.is_renderer = True
        f.format = format
        f.mimetypes = set(MediaType(mimetype, priority)
                          for mimetype in mimetypes)
        return f
    return g

def tidy_query_string(url):
    scheme, netloc, path, params, query, fragment = urlparse(url)
    args = []
    for k, vs in parse_qs(query, keep_blank_values=True).items():
        if k in ['format', 'language_code']:
            continue
        else:
            for v in vs:
                args.append((k.encode('utf-8'), v.encode('utf-8')))
    query = urlencode(args)
    return urlunparse((scheme, netloc, path, params, query, fragment))

class ViewMetaclass(type):
    def __new__(mcs, name, bases, attrs):

        # Pull the renderers from the bases into a couple of new dicts for
        # this view's renderers
        formats_by_mimetype = {}
        formats = {}
        for base in reversed(bases):
            if hasattr(base, 'FORMATS'):
                formats.update(base.FORMATS)
                formats_by_mimetype.update(base.FORMATS_BY_MIMETYPE)

        for key, value in attrs.items():
            # If the method is a renderer we add it to our dicts. We can't add
            # the functions right now because we want them bound to the view
            # instance that hasn't yet been created. Instead, add the keys
            # (strs) and we'll replace them with the bound instancemethods in
            # BaseView.__init__.
            if isfunction(value) and getattr(value, 'is_renderer', False):
                if value.mimetypes is not None:
                    mimetypes = value.mimetypes
                elif value.format in formats:
                    mimetypes = formats[value.format].mimetypes
                else:
                    mimetypes = ()
                for mimetype in mimetypes:
                    formats_by_mimetype[mimetype] = key
                formats[value.format] = key

        attrs.update({
            'FORMATS': formats,
            'FORMATS_BY_MIMETYPE': formats_by_mimetype,
        })

        # Create our view.
        view = type.__new__(mcs, name, bases, attrs)

        return view


class BaseView(object):
    __metaclass__ = ViewMetaclass

    ALLOWABLE_METHODS = ('GET', 'POST', 'DELETE', 'HEAD', 'OPTIONS', 'PUT')

    breadcrumb = NullBreadcrumb

    def method_not_allowed(self, request):
        return HttpResponseNotAllowed([m for m in self.ALLOWABLE_METHODS
                                       if hasattr(self, 'handle_%s' % m)])

    def not_acceptable(self, request):
        response = HttpResponse(
            _("The desired media type is not supported for this resource."),
            mimetype="text/plain")
        response.status_code = 406
        return response

    def bad_request(self, request):
        response = HttpResponse(
            _('Your request was malformed.'),
            status=400)
        return response

    def initial_context(self, request, *args, **kwargs):
        return {}
    
    def __new__(self, conf, *args, **kwargs):
        if isinstance(conf, HttpRequest):
            return self(None)(conf, *args, **kwargs)
        else:
            return object.__new__(self, conf, *args, **kwargs)

    def __init__(self, conf=None):
        self.conf = conf
        
        # Resolve renderer names to bound instancemethods. Also turn the
        # FORMATS_BY_MIMETYPE dict into a list of pairs ordered by descending
        # priority.
        self.FORMATS = dict((key, getattr(self, value))
                            for key, value in self.FORMATS.items())
        formats_sorted = sorted(self.FORMATS_BY_MIMETYPE.items(),
                                key=lambda x: x[0].priority,
                                reverse=True)
        self.FORMATS_BY_MIMETYPE = tuple((key, getattr(self, value))
                                         for (key, value) in formats_sorted)
    
    def __unicode__(self):
        self = type(self)
        return ".".join((self.__module__, self.__name__))

    def __call__(self, request, *args, **kwargs):
        method_name = 'handle_%s' % request.method
        if hasattr(self, method_name):
            context = self.initial_context(request, *args, **kwargs)
            context['breadcrumbs'] = self.breadcrumb(request, context,
                                                     *args, **kwargs)
            response = getattr(self, method_name)(request, context,
                                                  *args, **kwargs)
            return response
        else:
            return self.method_not_allowed(request)

    def handle_HEAD(self, request, context, *args, **kwargs):
        """
        Provides a default HEAD handler that strips the content from the
        response returned by the GET handler.
        """
        if hasattr(self, 'handle_GET'):
            response = self.handle_GET(request, context, *args, **kwargs)
        else:
            response = self.method_not_acceptable(request)
        response.content = ''
        return response

    def get_zoom(self, request, default=16):
        try:
            zoom = int(request.GET['zoom'])
        except (ValueError, KeyError):
            zoom = default
        else:
            zoom = min(max(10, zoom), 18)
        return zoom

    def redirect(self, uri, request, type='found'):
        """
        When called, returns a response which redirects users to the correct
        locations. It also correctly handles redirects within the AJAX page
        transition framework. The first argument is the URI to be redirected to,
        the second the request object and the third is optional, and specifies
        the type of redirect to be done:
        
        * found (the default) is a standard 302 Found redirect
        * perm is a standard 301 Moved Permanently redirect
        * seeother is a standard 303 See Other redirect
        * secure is a 301 Moved Permanently redirect, that has a special meaning
          when used within the AJAX framework, which causes pages to manually
          redirect to the new URL, rather than just AJAX transition. This causes
          transitions to/from secure pages to work as expected.
        """
        if 'format' in request.REQUEST:
            uri = urlparse(uri)
            args = []
            for k, vs in parse_qs(uri.query, keep_blank_values=True).items():
                if k == 'format':
                    continue
                else:
                    for v in vs:
                        args.append((k, v))
            if (uri.netloc != request.META.get('HTTP_HOST') and \
                uri.netloc != '') or type == 'secure':
                # This makes sure we never cross http/https boundaries with AJAX
                # requests or try to make an off-site AJAX request
                uri = urlunparse((uri.scheme, uri.netloc, uri.path, uri.params,
                                  urlencode(args), uri.fragment))
                return self.render(request, {'redirect': uri}, None)
            args.append(('format', request.REQUEST['format']))
            uri = urlunparse((uri.scheme, uri.netloc, uri.path, uri.params,
                              urlencode(args), uri.fragment))
        
        redirect = {
            'found': HttpResponseRedirect,
            'perm': HttpResponsePermanentRedirect,   
            'secure': HttpResponsePermanentRedirect,
            'seeother': HttpResponseSeeOther,
        }.get(type)
        return redirect(uri)

    def render(self, request, context, template_name, expires=None):
        """
        Given a request, a context dictionary and a template name, this renders
        the template with the given context according to the capabilities and
        requested format of the client. An optional final argument is that of
        a timedelta object, which sets additional caching headers for the
        content.
        """
        context.pop('exposes_user_data', None)

        if 'format' in request.REQUEST:
            formats = request.REQUEST['format'].split(',')
            renderers, seen_formats = [], set()
            for format in formats:
                if format in self.FORMATS and format not in seen_formats:
                    renderers.append(self.FORMATS[format])
        elif request.META.get('HTTP_ACCEPT'):
            accepts = self.parse_accept_header(request.META['HTTP_ACCEPT'])
            renderers = MediaType.resolve(accepts, self.FORMATS_BY_MIMETYPE)
        else:
            renderers = [self.FORMATS['html']]

        # Stop external sites from grabbing JSON representations of pages
        # which contain sensitive user information.
        try:
            offsite_referrer = 'HTTP_REFERER' in request.META and \
                request.META['HTTP_REFERER'].split('/')[2] != \
                                                request.META.get('HTTP_HOST')
        except IndexError:
            # Malformed referrers (i.e., those not containing a full URL) throw
            # this
            offsite_referrer = True

        for renderer in renderers:
            if renderer.format != 'html' and context.get('exposes_user_data') \
              and offsite_referrer:
                continue
            try:
                response = renderer(request, context, template_name)
            except NotImplementedError:
                continue
            else:
                if expires is not None and not settings.DEBUG and \
                  not getattr(settings, 'NO_CACHE', False):
                    response['Expires'] = formatdate(
                        mktime((datetime.now() + expires).timetuple()))
                    
                    # if expires is negative, then consider this to be no-cache
                    if expires < timedelta(seconds=0):
                        response['Cache-Control'] = 'no-cache'
                    else:
                        response['Cache-Control'] = 'max-age=%d' % \
                                (expires.seconds + expires.days * 24 * 3600)
                    
                return response
        else:
            if 'format' not in request.REQUEST:
                tried_mimetypes = list(itertools.chain(*[r.mimetypes
                                                         for r in renderers]))
                response = HttpResponse(
                  _("Your Accept header didn't contain any supported media ranges.") + \
                  "\n\n" + _("Supported ranges are:") + \
                  "\n\n * %s\n" % '\n * '.join(
                      sorted('%s (%s)' % (f[0].value, f[1].format) for f in
                      self.FORMATS_BY_MIMETYPE if not f[0] in tried_mimetypes)),
                mimetype="text/plain")
            else:
                response = HttpResponse(
                  _("Unable to render this document in this format.") + "\n\n" +
                  _("Supported formats are") + ":\n\n * %s\n" \
                                % '\n * '.join(self.FORMATS.keys()),
                  mimetype="text/plain")
            response.status_code = 406 # Not Acceptable
            return response

    def parse_accept_header(self, accept):
        media_types = []
        for media_type in accept.split(','):
            try:
                media_types.append(MediaType(media_type))
            except ValueError:
                pass
        return media_types

    def render_to_format(self, request, context, template_name, format):
        render_method = self.FORMATS[format]
        return render_method(request, context, template_name)

    @renderer(format="json", mimetypes=('application/json',))
    def render_json(self, request, context, template_name):
        context = simplify_value(context)
        resolved = resolve(request.path)
        context['view_name'] = '%s:%s' % (
            self.conf.application_name.split('.')[-1], resolved.url_name)
        
        # Include CSRF token, as templates don't get rendered csrf_token is
        # never called which breaks CSRF for apps written against the JSON API
        get_token(request)
        
        return HttpResponse(simplejson.dumps(context),
                            mimetype="application/json")

    @renderer(format="js", mimetypes=('text/javascript',
                                      'application/javascript',))
    def render_js(self, request, context, template_name):
        callback = request.GET.get('callback',
                                   request.GET.get('jsonp', 'callback'))
        content = simplejson.dumps(simplify_value(context))
        content = "%s(%s);" % (callback, content)
        return HttpResponse(content, mimetype="application/javascript")

    @renderer(format="html", mimetypes=('text/html', 'application/xhtml+xml'),
              priority=1)
    def render_html(self, request, context, template_name):
        if template_name is None:
            raise NotImplementedError
        return render_to_response(
            template_name+'.html',
            context,
            context_instance=RequestContext(request, current_app=self.conf.local_name),
            mimetype='text/html;charset=UTF-8')

    @renderer(format="xml", mimetypes=('application/xml', 'text/xml'))
    def render_xml(self, request, context, template_name):
        context = simplify_value(context)
        return HttpResponse(
            etree.tostring(serialize_to_xml(context), encoding='UTF-8'),
            mimetype="application/xml")

    # We don't want to depend on YAML. If it's there offer it as a renderer,
    # otherwise ignore it.
    try:
        # Try importing, but don't stick the result in locals.
        __import__('yaml')
        @renderer(format="yaml", mimetypes=('application/x-yaml',), priority=-1)
        def render_yaml(self, request, context, template_name):
            import yaml
            context = simplify_value(context)
            return HttpResponse(yaml.safe_dump(context),
                                mimetype="application/x-yaml")
    except ImportError, e:
        pass

    @renderer(format="fragment")
    def render_fragment(self, request, context, template_name):
        """
        Uses block rendering functions, see end of file.
        """
        if template_name is None:
            if 'redirect' in context:
                return HttpResponse(
                    simplejson.dumps({
                        'redirect': request.build_absolute_uri(
                            context['redirect'])
                    }),
                    mimetype="application/json")
            raise NotImplementedError
        body = render_blocks_to_string(template_name + '.html', context,
                                       RequestContext(request))
        
        uri = tidy_query_string(request.get_full_path())
        
        try:
            title = xhtml_slimmer(body['whole_title'])
        except:
            logger.warn('Slimmer failed to slim title', exc_info=True)
            title = body['whole_title']
        
        try:
            pagebody = xhtml_slimmer(body['body'])
        except:
            logger.warn('Slimmer failed to slim body', exc_info=True)
            pagebody = body['body']
        
        return HttpResponse(
            simplejson.dumps({
                'uri': uri,
                'body': pagebody,
                'title': title,
            }),
            mimetype="application/json")

class ZoomableView(BaseView):
    default_zoom = None

    def initial_context(self, request, *args, **kwargs):
        context = super(ZoomableView, self).initial_context(request,
                                                            *args, **kwargs)
        try:
            zoom = int(request.GET['zoom'])
        except (KeyError, ValueError):
            zoom = self.default_zoom
        else:
            zoom = min(max(10, zoom), 18)
        context['zoom'] = zoom
        context.update({
            'zoom_controls': True,
        })
        return context

def render_template_blocks(template, context, extensions={}):
    """
    Renders all the blocks from a template and returns a dictionary of block
    names and results.
    
    This template should have previously been rendered.
    """
    return render_template_nodelist(template.nodelist, context)

def render_template_nodelist(nodelist, context, extensions={}):
    blocks = {}
    for node in nodelist:
        if isinstance(node, ExtendsNode):
            blocks.update(render_template_blocks(node.get_parent(context),
                                                 context))
        if isinstance(node, BlockNode):
            # Render this node and add it to dictionary
            blocks[node.name] = node.render(context)
        for key in ('nodelist', 'nodelist_true', 'nodelist_false'):
            # Descend any recursive nodes
            if hasattr(node, key):
                blocks.update(render_template_nodelist(getattr(node, key),
                                                       context))
    return blocks

def render_blocks_to_string(template_name, dictionary=None,
                            context_instance=None):
    """
    Loads the given template_name and renders all blocks with the given
    dictionary as context. Returns a dictionary of blocks to string.
    """
    dictionary = dictionary or {}
    t = loader.get_template(template_name)
    if context_instance:
        context_instance.update(dictionary)
    else:
        context_instance = Context(dictionary)
    t._render(context_instance)
    return render_template_blocks(t, context_instance)

def ReverseView(request):
    from molly.auth.views import SecureView

    try:
        name = request.GET['name']
        args = request.GET.getlist('arg')
        
        path = reverse(name, args=args)
        view, view_args, view_kwargs = resolve(path)
        is_secure = isinstance(view, SecureView) and not settings.DEBUG_SECURE
        return HttpResponse("http%s://%s%s" % (
            's' if is_secure else '',
            request.META['HTTP_HOST'],
            path,
        ), mimetype='text/plain')
    except NoReverseMatch:
        raise Http404
    except KeyError:
        return HttpResponseBadRequest()

def handler500(request, exc_info=None):
    
    context = {
        'request': request,
    }

    if exc_info and (request.user.is_superuser or settings.DEBUG):
        # Now try and return this as a redirect if we're using fragment rendering
        if request.GET.get('format') == 'fragment':
            try:
                return HttpResponse(simplejson.dumps({
                        'redirect': tidy_query_string(request.build_absolute_uri())
                    }), mimetype="application/json")
            except:
                pass
        
        return technical_500_response(request, *exc_info)

    # This will make things prettier if we can manage it.
    # No worries if we can't.
    try:
        from molly.wurfl.context_processors import device_specific_media
        context.update(device_specific_media(request))
    except:
        pass
    
    # This will make stop mixed content warnings if we can manage it
    try:
        from molly.utils.context_processors import ssl_media
        context.update(ssl_media(request))
    except:
        context.update({'STATIC_URL': settings.STATIC_URL})

    response = render_to_response('500.html', context)
    response.status_code = 500
    return response

class CSRFFailureView(BaseView):
    
    def handle_GET(self, request, context, reason=''):
        logger.info('CSRF validation failure: %s', reason)
        return self.render(request, context, 'csrf_failure')
    
    def handle_POST(self, request, context, reason=''):
        return self.handle_GET(request, context, reason)

########NEW FILE########
__FILENAME__ = xslt
from lxml import etree

from django.core.urlresolvers import reverse
from django.template import loader, Context

def safe_href(context, url):
    url = url[0]
    return url.startswith('http://') or url.startswith('https://') or url.startswith('ftp://')

def url_func(context, node, name, *args):
    args = [arg.split('#')[0] for arg in args if arg]
    return reverse(name, args=args)

def transform(document, template_name, template_context=None):

    ns = etree.FunctionNamespace('http://mollyproject.org/xpath#')
    ns.prefix = 'molly'
    ns['url'] = url_func
    ns['safe-href'] = safe_href

    # Load a template and turn it into an XSL template
    template = loader.get_template(template_name)
    template = template.render(Context(template_context or {}))
    template = etree.XSLT(etree.XML(template))

    return template(document)

def add_children_to_context(document, context):
    for node in document.findall('*'):
        context[node.tag] = etree.tostring(node, method="html")[len(node.tag)+2:-len(node.tag)-3]

########NEW FILE########
__FILENAME__ = context_processors
from molly.wurfl import device_parents

def parse_version(s):
    try:
        return tuple(map(int, s.split('.')))
    except ValueError:
        return (0,)

def device_specific_media(request):
    """
    Uses DEVICE_SPECIFIC_MEDIA as a basis to pass extra context when the
    wurfl-detected device is a child of a given device id.
    """

    device, browser = request.device, request.browser
    use_javascript = True
    use_slippy_maps = device.pointing_method == "touchscreen"

    # Skyfire
    if browser.devid == 'generic_skyfire':
        style_group = "dumb"

    # Apple products
    elif device.brand_name == 'Apple' :
        style_group = "smart"

    # Symbian S60 v3 and above (iresspective of browser)
    elif device.device_os in ('Symbian', 'Symbian OS') and parse_version(device.device_os_version) >= (9, 2) :
        style_group = "smart"
        use_slippy_maps = False
        if parse_version(device.device_os_version) < (9, 4):
            # Only S60 5th edition properly supports JQuery
            use_javascript = False

    # Nokia Maemo
    elif device.brand_name == 'Nokia' and device.device_os == 'Linux Smartphone OS' :
        style_group = "smart"

    # Blackberries
    elif device.brand_name == 'RIM' :
        style_group = 'smart'
        use_javascript = False

    # Android
    elif device.device_os == 'Android' :
        style_group = 'smart'

    # Palm Web OS
    elif device.device_os == 'Web OS' :
        style_group = 'smart'

    # Opera Mini/Mobile Browsers
    elif browser.brand_name == 'Opera' or browser.mobile_browser == 'Opera':
        style_group = 'smart'
        # Opera Mini 4 doesn't properly support JS
        if browser.mobile_browser == 'Opera Mini' and parse_version(browser.mobile_browser_version) <= (5,):
            use_javascript = False

    # Windows Mobile 7
    elif (device.device_os, parse_version(device.device_os_version)) == (u'Windows Mobile OS', (7,)):
        style_group = 'smart'
    
    # Kindle - but only the Mobile Safari based ones... unfortunately Wurfl seems
    # to think that version 3 still uses Netfront, so can't be clever here
    elif device.devid == 'amazon_kindle3_ver1' or 'amazon_kindle3_ver1' in device_parents[device.devid]:
        style_group = 'smart'
    
    # Desktop browsers
    elif 'generic_web_browser' in device_parents[browser.devid]:
        style_group = 'smart'
        use_slippy_maps = True

    # All Others
    else:
        style_group = "dumb"
        use_javascript = False
    
    return {
        'style_group': '%s' % style_group,
        'use_javascript': use_javascript,
        'use_slippy_maps': use_javascript and use_slippy_maps,
    }

def wurfl_device(request):
    return {
        'browser': request.browser,
        'device': request.device,
        'map_width': request.map_width,
        'map_height': request.map_height,
    }
########NEW FILE########
__FILENAME__ = update_wurfl
import gzip
import itertools
import optparse
import os
import os.path
import pdb
import pkg_resources
import tempfile
import shutil
import subprocess
import sys
import urllib

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

from django.core.management.base import CommandError, NoArgsCommand
from pywurfl import wurflprocessor
from xml.etree import ElementTree as ET

class Command(NoArgsCommand):
    option_list = NoArgsCommand.option_list
    help = "Updates wurfl data"

    requires_model_validation = False

    WURFL_URL = 'http://mollyproject.org/wurfl/wurfl-2.1.1.xml.gz'
    WEB_PATCH_URL = 'http://mollyproject.org/wurfl/web_browsers_patch.xml'

    def handle_noargs(self, **options):
        tempdir = tempfile.mkdtemp()

        final_filename = os.path.normpath(os.path.join(
            os.path.dirname(__file__), '..', '..', 'wurfl_data.py'))
        local_filename = os.path.normpath(os.path.join(
            os.path.dirname(__file__), '..', '..', 'data', 'local_patch.xml'))

        try:
            wurfl_gz = urllib.urlopen(Command.WURFL_URL)
            wurfl_f = gzip.GzipFile(fileobj=StringIO(wurfl_gz.read()))
            web_patch_f = urllib.urlopen(Command.WEB_PATCH_URL)
            local_patch_f = open(local_filename, 'r')

            wurfl = ET.parse(wurfl_f)
            web_patch = ET.parse(web_patch_f)
            local_patch = ET.parse(local_patch_f)

            devices = {}
            devices_et = itertools.chain(
                wurfl.findall('devices/device'),
                web_patch.findall('devices/device'),
                local_patch.findall('devices/device'),
            )

            root = ET.Element('wurfl')
            root.append(wurfl.find('version'))
            devices_out = ET.SubElement(root, 'devices')

            for device_et in devices_et:
                devices_out.append(device_et)

            out_filename = os.path.join(tempdir, 'wurfl.xml')
            gen_filename = os.path.join(tempdir, 'wurfl.py')
            ET.ElementTree(root).write(out_filename)

            if os.name == 'nt':

                # Find the wurfl2python.py script
                for file in (os.path.join(os.path.expandvars(p), 'wurfl2python.py')
                             for p in os.getenv('PATH').split(';')):
                    if os.path.exists(file):
                        wurfl2python_path = file
                        break
                else:
                    raise CommandError("Could not find wurfl2python.py on PATH")

                # Windows can't handle shebangs
                subprocess.call([sys.executable, wurfl2python_path,
                    out_filename, '-o', gen_filename])

            else:
                subprocess.call(['wurfl2python.py', out_filename, '-o', gen_filename])

            shutil.move(gen_filename, final_filename)

        finally:
            shutil.rmtree(tempdir)

########NEW FILE########
__FILENAME__ = middleware
from django.conf import settings

from molly.wurfl.wurfl_data import devices
from pywurfl.algorithms import DeviceNotFound
from molly.wurfl.vsm import vsa

class WurflMiddleware(object):
    def process_request(self, request):
        ua = request.META.get('HTTP_USER_AGENT', '').decode('ascii', 'ignore')

        try:
            request.browser = devices.select_ua(
                ua,
                search=vsa
            )
        except (KeyError, DeviceNotFound):
            request.browser = devices.select_id('generic_xhtml')

        if 'HTTP_X_OPERAMINI_PHONE' in request.META:
            opera_device = request.META['HTTP_X_OPERAMINI_PHONE'].decode('ascii', 'ignore')
            request.device = devices.select_ua(
                opera_device,
                search=vsa
            )
        if 'HTTP_X_SKYFIRE_PHONE' in request.META:
            request.browser = devices.select_id('generic_skyfire')
            skyfire_device = request.META['HTTP_X_SKYFIRE_PHONE'].decode('ascii', 'ignore')
            request.device = devices.select_ua(
                skyfire_device,
                search=vsa
            )
            try:
                request.device.resolution_width, request.device.resolution_height = \
                    map(int, request.META['HTTP_X_SKYFIRE_SCREEN'].split(','))[2:4]
            except (KeyError, ValueError):
                pass
        else:
            request.device = request.browser

        request.map_width = min(320, request.device.resolution_width-10)
        request.map_height = min(320, request.device.resolution_height-10)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

from .views import IndexView

urlpatterns = patterns('',
    (r'^$', IndexView, {}, 'index'),
)


########NEW FILE########
__FILENAME__ = views
from pywurfl.algorithms import DeviceNotFound

from django.http import Http404
from django.utils.translation import ugettext as _

from molly.utils.views import BaseView
from molly.utils.breadcrumbs import *
from molly.utils.http import MediaType

from molly.wurfl.vsm import vsa
from molly.wurfl import device_parents
from molly.wurfl.wurfl_data import devices

class IndexView(BaseView):
    @BreadcrumbFactory
    def breadcrumb(self, request, context):
        return Breadcrumb(
            self.conf.local_name,
            None,
            _('Device detection'),
            lazy_reverse('index'),
        )
    
    def handle_GET(self, request, context):
        if not getattr(self.conf, 'expose_view', False):
            raise Http404
        ua = request.GET.get('ua', request.META.get('HTTP_USER_AGENT', ''))
        ua = ua.decode('ascii', 'ignore')

        try:
            device = devices.select_ua(
                ua,
                search=vsa
            )
        except (KeyError, DeviceNotFound):
            device = devices.select_id('generic_xhtml')

        accepts = self.parse_accept_header(request.META.get('HTTP_ACCEPT', ''))
        renderers = MediaType.resolve(accepts, self.FORMATS_BY_MIMETYPE)
        formats = [renderer.format for renderer in renderers]

        context.update({
            'id': device.devid,
            'is_mobile': not 'generic_web_browser' in device_parents[device.devid],
            'brand_name': device.brand_name,
            'model_name': device.model_name,
            'ua': ua,
            'matched_ua': device.devua,
            'accept': request.META.get('HTTP_ACCEPT', ''),
            'formats': formats
        })

        if request.GET.get('capabilities') == 'true':
            context['capabilities'] = dict((k, getattr(device, k)) for k in dir(device) if (not k.startswith('_') and not k.startswith('dev') and not k in ('groups','children')))

        return self.render(request, context, 'wurfl/index')

########NEW FILE########
__FILENAME__ = vsm
from math import sqrt
import time

from pywurfl.algorithms import Algorithm
from molly.wurfl.wurfl_data import devices

class Vector(object):
    terms = {}
    def __init__(self, value):
        if isinstance(value, tuple):
            self.value = value
        elif isinstance(value, dict):
            self.value = []
            for term, magnitude in value.items():
                if not term in Vector.terms:
                    Vector.terms[term] = len(Vector.terms)
                self.value.append((Vector.terms[term], magnitude))
            self.value = tuple(sorted(self.value))
        else:
            raise TypeError("Initialise with tuple or dict, not %s" % type(value))
    
    def __add__(self, other):
        out, i, j, u, v = [], 0, 0, self.value, other.value
        try:
            while True:
                if u[i][0] < v[j][0]:
                    i += 1
                    out.append( ( i, u[i][1] ) )
                elif u[i][0] > v[j][0]:
                    j += 1
                    out.append( ( i, v[j][1] ) )
                else:
                    i, j = i+1, j+1
                    out.append( ( i, u[i][1]+v[j][1] ) )
        except IndexError:
            return Vector(tuple(out))
   
    def __sub__(self, other):
        out, i, j, u, v = [], 0, 0, self.value, other.value
        try:
            while True:
                if u[i][0] < v[j][0]:
                    i += 1
                    out.append( ( i, u[i][1] ) )
                elif u[i][0] > v[j][0]:
                    j += 1
                    out.append( ( i, -v[j][1] ) )
                else:
                    i, j = i+1, j+1
                    out.append( ( i, u[i][1]-v[j][1] ) )
        except IndexError:
            return Vector(tuple(out))
   
    def __div__(self, other):
        return Vector(tuple((k,v/other) for (k,v) in self.value))
       
    def __mul__(self, other):
        if isinstance(other, Vector):
            out, i, j, u, v = 0, 0, 0, self.value, other.value
            try:
                while True:
                    if u[i][0] < v[j][0]:
                        i += 1
                    elif u[i][0] > v[j][0]:
                        j += 1
                    else:
                        i, j = i+1, j+1
                        out += u[i][1]*v[j][1]
            except IndexError:
                return out
        else:
            return Vector(tuple((k,v*other) for (k,v) in self.value))
        
    def __abs__(self):
        return sqrt(sum(v**2 for k,v in self.value))

def tokenise(ua):
    for c in ';()':
        ua = ua.replace(c, ' ')
    
    out = []
    for token in ua.split(' '):
        if not token:
            continue
            
        for c in '/.':
            token = token.replace(c, ' ')
        token = token.split()

        for i in range(1, len(token)+1):
            out.append(' '.join(token[:i]))
            out.append(token[i-1])
            
    return out

class VectorSpaceAlgorithm(Algorithm):
    
    use_normalized_ua = True
    
    def __init__(self, devices=None):
        
        if devices:
            self.precompute(devices)
        else:
            self.devices = None
            
    def precompute(self, devices):
        vectors = {}
        for ua, device in devices.devuas.items():
            tokenised = tokenise("%s %s %s" % (ua, device.brand_name, device.model_name))
            vectors[device] = Vector(dict((token, 1) for token in tokenised))
            vectors[device] /= abs(vectors[device])
            
        self.cache = {}
        self.vectors = vectors
        self.devices = devices
        
        
    def __call__(self, ua, devices=None):
        if not devices is None and devices != self.devices:
            self.precompute(devices)
            
        if ua in self.cache:
            return self.cache[ua]
            
        v1 = Vector(dict((token, 1) for token in tokenise(ua)))
        v1 /= abs(v1)
        
        current_device, value = None, float('-inf')
        
        for device, v2 in self.vectors.items():
            c = v1 * v2
            if c > value:
                current_device = device
                value = c
                v = v2
                
        self.cache[ua] = current_device
        return current_device

vsa = VectorSpaceAlgorithm(devices)

########NEW FILE########
__FILENAME__ = runtests
#This file mainly exists to allow python setup.py test to work.
import os
import sys
os.environ['DJANGO_SETTINGS_MODULE'] = 'molly.conf.test_settings'

from django.test.utils import get_runner
from django.conf import settings


def runtests():
    from south.management.commands import patch_for_test_db_setup
    patch_for_test_db_setup()
    test_runner = get_runner(settings)
    test_runner = test_runner(interactive=True, verbosity=1, failfast=False)
    failures = test_runner.run_tests([])
    sys.exit(bool(failures))

if __name__ == '__main__':
    runtests()

########NEW FILE########
