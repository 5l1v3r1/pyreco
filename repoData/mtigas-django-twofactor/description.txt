# django-twofactor

&copy; 2011-2013 [Mike Tigas][miketigas] ([@mtigas](https://twitter.com/mtigas))  
[MIT License][license]

[miketigas]: https://mike.tig.as/
[license]: https://github.com/mtigas/django-twofactor/blob/master/LICENSE

A django app that allows supplementing the default `django.contrib.auth` login
system with two-factor authentication using the Time-Based One-Time Password
(TOTP) Algorithm spec ([RFC 6238][rfc6238]).

[Google Authenticator][goog_auth] is currently the primary support target for
tokens, but any TOTP (soft?) token that allows using a server-generated seed
should work.

[rfc6238]: http://tools.ietf.org/html/rfc6238
[goog_auth]: http://www.google.com/support/accounts/bin/answer.py?answer=1066447

Some notes:

* [RFC 6238][rfc6238] - TOTP: Time-Based One-Time Password Algorithm
* ...An extension of [RFC 4226][rfc4226] - HOTP: An HMAC-Based One-Time
  Password Algorithm
* [A proof of concept regarding how to use **python-oath** with Google Authenticator][poc_link]

[rfc4226]: http://tools.ietf.org/html/rfc4226
[poc_link]: https://gist.github.com/445567d2206a82a4e684

---

## Possible alternatives

This project hasn't been touched in a while, but the proof of concept still works.
Other similar projects may have more fleshed-out APIs and integration:

* [django-otp](https://bitbucket.org/psagers/django-otp) ([PyPI](https://pypi.python.org/pypi/django-otp))
* [django-twostepauth](https://bitbucket.org/cogni/django-twostepauth) ([PyPI](https://pypi.python.org/pypi/django-twostepauth))
* [django-two-factor-auth](https://github.com/Bouke/django-two-factor-auth)

---

## Current status

This app is a work in progress. It is not much farther than "proof of concept,"
however. Clone the source and look at [twofactor_demo/README.mdown](demo_readme)
for a quick demo (including steps on how to set it up).

The basics work:

* If the special `adminsite` subclass is used, all login forms are replaced
  with one that has an optional "Auth Code" field. (Users with two-factor auth
  enabled will be required to enter this.)
* In the admin, a "Two-factor Authentication" link shows up next to the "Change
  password" link. From here, a user may enable two-factor auth (if it is not
  enabled), reset their auth token (to allow migration to a new device), or
  disable two-factor auth (if it is enabled).

What does not work:

* (Optional) backup codes or some ability to reset your auth token (or even
  simply log in) if you have lost your token. Optional because in some usecases
  this is a feature for high security that require manual intervention (support
  call to have a human verify and reset). FWIW, Google does provide this in the
  form of temporary, one-time-use codes that are received when two-factor
  authentication is turned on.

[demo_readme]: https://github.com/mtigas/django-twofactor/tree/master/twofactor_demo

---

## Dependencies

* [python-oath][py_oath] -- not to be confused with "OAuth"
* [django][django]

Optionally, for performance:

* [PyCrypto](https://www.dlitz.net/software/pycrypto/) -- See *PyCrypto*
  section below, under *Security Considerations*.

[py_oath]: https://github.com/bdauvergne/python-oath
[django]: https://www.djangoproject.com/


## Security Considerations

[Section 5.1 of RFC 6238](http://tools.ietf.org/html/rfc6238#section-5.1)
"recommends" that the shared secret key (i.e. the "seed" for the time-based
generator) be stored securely in the validation system (i.e., the server) and
specifies encrypting the values until their use is necessary.

The key cannot be hashed (as with a password) because the raw value of the key
is required to seed the generator. A single round of AES against
`settings.SECRET_KEY` is used (with a randomly-generated seed appended to
`SECRET_KEY`) as the encryption passphrase so that the value can be decrypted
at validation time.

This works sort of like this:

    stored_seed = salt + "$" + hexlify(AES(
        key = sha256(SECRET_KEY + salt),
        value = raw_seed
    ))
    # i.e. 'CYM5yCSZ9Ybyu1dq$6cc094ca2e1eb46122d84ae877fff885'

This isn't perfect, but it obscures the values in the database in the event
the database is compromised but `settings.SECRET_KEY` has not been.


### PyCrypto

A copy of [**pyaes**](https://bitbucket.org/intgr/pyaes/wiki/Home) is bundled
with this app. If **PyCrypto** is installed, that library's C-compiled
extensions will be used instead of the (extremely slow) native Python AES
implementation.

# Easy setup

```python
virtualenv --no-site-packages django-twofactor
cd django-twofactor
echo "export PYTHONPATH=\"\$VIRTUAL_ENV/repo\"" >> bin/activate
echo "export PIP_RESPECT_VIRTUALENV=true" >> bin/activate
echo "export DJANGO_SETTINGS_MODULE=\"twofactor_demo.settings\"" >> bin/activate

source bin/activate
git clone git://github.com/mtigas/django-twofactor.git repo
pip install -r repo/requirements.txt
pip install pycrypto

cd repo/twofactor_demo
django-admin.py syncdb --noinput
django-admin.py runserver
```

Open http://127.0.0.1:8000/

The admin site at http://127.0.0.1:8000/admin/ works, too (and allows you to
update your two-factor auth options).

## Test accounts

The following account does not have two-factor authentication enabled.

    Username: test_notwofactor
    Password: test

The following account has two-factor authentication enabled. If you are using
[Google Authenticator][goog_auth], you can enter in the Token Seed manually
(as the "Time Based" key) or by scanning the QR code below.

    Username:   test_twofactor
    Password:   test
    Token Seed: 34YKAEGB2GLGVZDKJLJMLDQJ4N6VTHDYWCL4HPKDP6CX477Q

[goog_auth]: http://www.google.com/support/accounts/bin/answer.py?answer=1066447

<img src="https://chart.googleapis.com/chart?chl=otpauth%3A%2F%2Ftotp%2Ftest_twofactor%40twofactor_demo%3Fsecret%3D34YKAEGB2GLGVZDKJLJMLDQJ4N6VTHDYWCL4HPKDP6CX477Q&chs=200x200&cht=qr&chld=M%7C0"/>

## Settings

The settings file as-is will allow you to `syncdb` and pre-load the above
users. It also provides the following "new" settings:

```python
AUTHENTICATION_BACKENDS = (
    'django_twofactor.auth_backends.TwoFactorAuthBackend',
)

TWOFACTOR_OPTIONS = {
    #'period': 30, # default
    'forward_drift': 4, # allow a code from four "steps" (up to 2:00) in the future, in case of bad clock sync.
    'backward_drift': 2, # allow a code from two "steps" (up to 1:00) in the past, in case of bad clock sync.
}

TWOFACTOR_ENCRYPTION_KEY = ''
```

`AUTHENTICATION_BACKENDS` is simply how the two-factor authentication
currently hooks into Django's built-in auth module. (As per [Django's
contrib.auth documentation][auth_backends].)

[auth_backends]: https://docs.djangoproject.com/en/1.4/topics/auth/#specifying-authentication-backends

`TWOFACTOR_TOTP_OPTIONS` currently accepts a few options that affect how time-sensitive
the time-based authentication codes are: `period`, `forward_drift`, and `backward_drift`.

* Time-based authentication codes are generated based on the system clock and
  last for a certain `period`. Currently, since we rely on Google Authenticator,
  this defaults to 30 seconds and should not be changed.
* `forward_drift` and `backward_drift` allow a code from *periods* in the future
  or past. These default to 1 -- meaning if you enter in a code that has just disappeared
  or have entered in a code and your phone clock is fast, the code will still be
  accepted. (They are set to 4 and 2 in the demo settings because cellular networks
  are not always in sync with NTP; first-hand experience using Google Authenticator
  for Google services seems to show that Google's allowable drift is *at least* 4.)

If you are interested in deeper analysis of these settings, you should
read [RFC6238][rfc6238]: `period` is referred to as "X" or the "time step",
and clock drift is referred to in section 6 ("Resynchronization"). The [underlying
method in python-oath][accept_totp] is useful to look at, too.

[rfc6238]: https://tools.ietf.org/html/rfc6238
[accept_totp]: https://github.com/bdauvergne/python-oath/blob/v1.0/oath/totp.py#L61

`TWOFACTOR_ENCRYPTION_KEY` should be a unique value that you never, ever change.
(The demo currently uses an empty one. That's TODO.)

```shell
python -c "from django.utils.crypto import get_random_string;print get_random_string(50)"
```

