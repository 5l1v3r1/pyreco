__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-simple-friends documentation build configuration file, created by
# sphinx-quickstart on Sat Nov 26 10:47:33 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os


# Import app module for autodoc
try:
    import friends
except ImportError:
    sys.path.append(
        os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')),
    )
    import friends


# Setup Django environment
sys.path.append(os.path.abspath(
    os.path.join(os.path.dirname(__file__), '../../example')),
)
import settings
from django.core.management import setup_environ
setup_environ(settings)
# Run syncdb to create tables, this avoids tag fields complaining
# about django_content_type table
from django.core.management.commands.syncdb import Command as SyncdbCommand
from django.db import DEFAULT_DB_ALIAS
SyncdbCommand().execute(verbosity=0, database=DEFAULT_DB_ALIAS)


# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.intersphinx',
    'sphinx.ext.viewcode',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-simple-friends'
copyright = friends.__copyright__

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = friends.__version__
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-simple-friendsdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-simple-friends.tex', u'django-simple-friends Documentation',
   u'Atamert Ölçgen', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-simple-friends', u'django-simple-friends Documentation',
     [u'Atamert Ölçgen'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'django-simple-friends', u'django-simple-friends Documentation',
   u'Atamert Ölçgen', 'django-simple-friends', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


intersphinx_mapping = {
  'django': ('http://docs.djangoproject.com/en/dev/', 'http://docs.djangoproject.com/en/dev/_objects/'),
  'python': ('http://docs.python.org/', None),
}

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
import imp
try:
    imp.find_module('settings') # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n" % __file__)
    sys.exit(1)

import settings

# Add parent directory to path if the app is not importable.
try:
    import friends
except ImportError:
    import sys, os
    sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
import os

_PATH = os.path.abspath(os.path.dirname(__file__))
_MODULE = os.path.basename(_PATH)

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS =[]
MANAGERS = ADMINS

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": os.path.join(_PATH, "example.sqlite"),
    },
}

MEDIA_ROOT = os.path.join(_PATH, '..', 'files', 'media')
MEDIA_URL = '/media/'
STATIC_ROOT = os.path.join(_PATH, '..', 'files', 'static')
STATIC_URL = '/static/'
ADMIN_MEDIA_PREFIX = '/static/admin/'
STATICFILES_DIRS = (
    os.path.join(_PATH, 'static'),
)
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
)

SECRET_KEY = 'fow!2s3r6+9=(4wav3i)(%rqr!h61@vbk122h_i37qh@+z*%7-'

TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
)
TEMPLATE_DIRS = (
    os.path.join(_PATH, 'templates'),
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = '%s.urls' % _MODULE

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'friends',
    'django_coverage',
)

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}

SITE_ID = 1

COVERAGE_USE_CACHE = True
COVERAGE_PATH_EXCLUDES = ["fixtures", "locale"]

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import patterns, include, url

# Uncomment the next two lines to enable the admin:
# from django.contrib import admin
# admin.autodiscover()

urlpatterns = patterns('',
    # Examples:
    # url(r'^$', 'example.views.home', name='home'),
    # url(r'^example/', include('example.foo.urls')),

    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    # url(r'^admin/', include(admin.site.urls)),
)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.utils.translation import ugettext_lazy as _
from models import FriendshipRequest, Friendship, UserBlocks


class FriendshipRequestAdmin(admin.ModelAdmin):
    date_hierarchy = 'created'
    list_display = ('from_user', 'to_user', 'accepted', 'created')
    list_filter = ('accepted',)
    actions = ('accept_friendship', 'decline_friendship', 'cancel_friendship')

    def accept_friendship(self, request, queryset):
        for friendship_request in queryset:
            friendship_request.accept()
    accept_friendship.short_description = \
        _(u'Accept selected friendship requests')

    def decline_friendship(self, request, queryset):
        for friendship_request in queryset:
            friendship_request.decline()
    decline_friendship.short_description = \
        _(u'Decline selected friendship requests')

    def cancel_friendship(self, request, queryset):
        for friendship_request in queryset:
            friendship_request.cancel()
    cancel_friendship.short_description = \
        _(u'Cancel selected friendship requests')
admin.site.register(FriendshipRequest, FriendshipRequestAdmin)


class FriendshipAdmin(admin.ModelAdmin):
    list_display = ('user', 'friend_count', 'friend_summary')
admin.site.register(Friendship, FriendshipAdmin)


class UserBlocksAdmin(admin.ModelAdmin):
    list_display = ('user', 'block_count', 'block_summary')
admin.site.register(UserBlocks, UserBlocksAdmin)

########NEW FILE########
__FILENAME__ = app_settings
from django.conf import settings


REDIRECT_FALLBACK_TO_PROFILE = getattr(settings,
                                       'FRIENDS_REDIRECT_FALLBACK_TO_PROFILE',
                                       False)

# During syncdb, this app ensures a Friendship and UserBlock record exists for
# each user. This setting controls the batch size on the bulk creation of those
# records when that process runs.
FRIENDS_SYNCDB_BATCH_SIZE = getattr(settings, 'FRIENDS_SYNCDB_BATCH_SIZE', 999)

########NEW FILE########
__FILENAME__ = management
from django.db.models.signals import post_syncdb
from django.contrib.auth.models import User
from django.core.exceptions import ImproperlyConfigured
import models
from app_settings import FRIENDS_SYNCDB_BATCH_SIZE


def post_syncdb_handler(sender, app, created_models, verbosity, **kwargs):
    if FRIENDS_SYNCDB_BATCH_SIZE < 1:
        raise ImproperlyConfigured("FRIENDS_SYNCDB_BATCH_SIZE must be > 0")
    for model in (models.Friendship, models.UserBlocks):
        name = model.__name__
        if verbosity >= 1:
            print "Creating {0} models for existing users...".format(name)
        # We only want user IDs that don't have existing Friendship or
        # UserBlock records. For example, a superuser account created
        # interactively during syncdb will have such a record due to this
        # app's post_save signal handler
        kwargs = {
            'Friendship': { 'friendship__isnull': True },
            'UserBlocks': { 'user_blocks__isnull': True }
        }[name]
        user_ids = User.objects.filter(**kwargs).values_list('pk', flat=True)\
            .order_by('pk')
        # Note: In Django 1.5, a batch_size parameter can be passed directly to
        # bulk_create(). Better to use that parameter instead of the below
        # code once version 1.4 is no longer supported by this app.
        total = 0
        batch_size = FRIENDS_SYNCDB_BATCH_SIZE
        while True:
            batch = [model(user_id=id) for id in user_ids[:batch_size]]
            if batch:
                model.objects.bulk_create(batch)
                total += len(batch)
            else:
                break
        if verbosity >= 2 and total:
            print "Created {0} new {1} record(s).".format(total, name)


post_syncdb.connect(
    post_syncdb_handler,
    sender=models,
    dispatch_uid='friends.signals.post_syncdb',
)

########NEW FILE########
__FILENAME__ = models
"""
Models
======

.. autoclass:: FriendshipRequest
    :members:

.. autoclass:: FriendshipManager
    :members:

.. autoclass:: Friendship
    :members:

.. autoclass:: UserBlocks
    :members:
"""


import datetime
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.contrib.auth.models import User
import signals


class FriendshipRequest(models.Model):
    """
    An intent to create a friendship between two users.

    .. seealso::

        There should never be complementary :class:`FriendshipRequest`\ 's,
        as in ``user1`` requests to be friends with ``user2`` when ``user2``
        has been requested to be friends with ``user1``. See how
        :class:`~friends.views.FriendshipRequestView` checks the existence of
        a :class:`FriendshipRequest` from ``to_user`` to ``from_user``.
    """

    from_user = models.ForeignKey(User, related_name="friendshiprequests_from")
    """
    :class:`~django.db.models.ForeignKey` to |User| who initiated the request.
    """

    to_user = models.ForeignKey(User, related_name="friendshiprequests_to")
    """
    :class:`~django.db.models.ForeignKey` to |User| the request has been sent.
    """

    message = models.CharField(max_length=200, blank=True)
    """
    :class:`~django.db.models.CharField` containing the optional message.

    .. note::

        ``__unicode__()`` method of this class **does not** print out this
        field. You must explicitly access this field to output the message.

    Although :mod:`django-simple-friends <friends>` doesn't provide any
    functionality to use markup engines to render this message it doesn't
    prevent you to store and render it in any format you desire.
    """

    created = models.DateTimeField(default=datetime.datetime.now,
                                   editable=False)
    """
    :class:`~django.db.models.DateTimeField` set when the object is created.
    """

    accepted = models.BooleanField(default=False)
    """
    :class:`~django.db.models.BooleanField` indicates whether the request is
    accepted or still pending.
    """

    class Meta:
        verbose_name = _(u'friendship request')
        verbose_name_plural = _(u'friendship requests')
        unique_together = (('to_user', 'from_user'),)

    def __unicode__(self):
        return _(u'%(from_user)s wants to be friends with %(to_user)s') % {
            'from_user': unicode(self.from_user),
            'to_user': unicode(self.to_user),
        }

    def accept(self):
        """
        Create the :class:`Friendship` between
        :attr:`~FriendshipRequest.from_user` and
        :attr:`~FriendshipRequest.to_user` and mark this instance
        as accepted.

        :obj:`~friends.signals.friendship_accepted` is signalled on success.

        .. seealso::

            :class:`~friends.views.FriendshipAcceptView`
        """
        Friendship.objects.befriend(self.from_user, self.to_user)
        self.accepted = True
        self.save()
        signals.friendship_accepted.send(sender=self)

    def decline(self):
        """
        Deletes this :class:`FriendshipRequest`

        :obj:`~friends.signals.friendship_declined` is signalled on success.

        .. seealso::

            :class:`~friends.views.FriendshipDeclineView`
        """
        signals.friendship_declined.send(sender=self)
        self.delete()

    def cancel(self):
        """
        Deletes this :class:`FriendshipRequest`

        :obj:`~friends.signals.friendship_cancelled` is signalled on success.

        .. seealso::

            :class:`~friends.views.FriendshipCancelView`
        """
        signals.friendship_cancelled.send(sender=self)
        self.delete()


class FriendshipManager(models.Manager):
    def friends_of(self, user, shuffle=False):
        """
        List friends of ``user``.

        :param user: User to query friends.
        :type user: |User|
        :param shuffle: Optional. Default ``False``.
        :type shuffle: |bool|
        :returns: :class:`~django.db.models.query.QuerySet` containing friends
                  of ``user``.
        """
        qs = User.objects.filter(friendship__friends__user=user)
        if shuffle:
            qs = qs.order_by('?')
        return qs

    def are_friends(self, user1, user2):
        """
        Indicate if ``user1`` and ``user2`` are friends.

        :param user1: User to compare with ``user2``.
        :type user1: |User|
        :param user2: User to compare with ``user1``.
        :type user2: |User|
        :rtype: |bool|
        """
        friendship = Friendship.objects.get(user=user1)
        return bool(friendship.friends.filter(user=user2).exists())

    def befriend(self, user1, user2):
        """
        Establish friendship between ``user1`` and ``user2``.

        .. important::

            Instead of calling this method directly,
            :func:`FriendshipRequest.accept()
            <friends.models.FriendshipRequest.accept>`, which calls
            this method, should be used.

        :param user1: User to make friends with ``user2``.
        :type user1: |User|
        :param user2: User to make friends with ``user1``.
        :type user2: |User|
        """
        friendship = Friendship.objects.get(user=user1)
        friendship.friends.add(Friendship.objects.get(user=user2))
        # Now that user1 accepted user2's friend request we should delete any
        # request by user1 to user2 so that we don't have ambiguous data
        FriendshipRequest.objects.filter(from_user=user1,
                                         to_user=user2).delete()

    def unfriend(self, user1, user2):
        """
        Break friendship between ``user1`` and ``user2``.

        :param user1: User to unfriend with ``user2``.
        :type user1: |User|
        :param user2: User to unfriend with ``user1``.
        :type user2: |User|
        """
        # Break friendship link between users
        friendship = Friendship.objects.get(user=user1)
        friendship.friends.remove(Friendship.objects.get(user=user2))
        # Delete FriendshipRequest's as well
        FriendshipRequest.objects.filter(from_user=user1,
                                         to_user=user2).delete()
        FriendshipRequest.objects.filter(from_user=user2,
                                         to_user=user1).delete()


class Friendship(models.Model):
    """
    Represents the network of friendships.
    """

    user = models.OneToOneField(User, related_name='friendship')
    """
    |OneToOneField| to |User| whose friends are stored.
    """

    friends = models.ManyToManyField('self', symmetrical=True)
    """
    Symmetrical |ManyToManyField| to :class:`Friendship`.

    .. seealso::

        To obtain friends as a list of |User|'s use
        :meth:`FriendshipManager.friends_of()
        <friends.models.FriendshipManager.friends_of>`.
    """

    objects = FriendshipManager()

    class Meta:
        verbose_name = _(u'friendship')
        verbose_name_plural = _(u'friendships')

    def __unicode__(self):
        return _(u'%(user)s\'s friends') % {'user': unicode(self.user)}

    def friend_count(self):
        """
        Return the count of :attr:`~Friendship.friends`.
        This method is used in :class:`~friends.admin.FriendshipAdmin`.

        :rtype: |int|
        """
        return self.friends.count()
    friend_count.short_description = _(u'Friends count')

    def friend_summary(self, count=7):
        """
        Return a string representation of
        :attr:`~Friendship.friends`.
        This method is used in :class:`~friends.admin.FriendshipAdmin`.

        :param |int| count: Maximum number of friends to include in the output.
        :rtype: |unicode|
        """
        friend_list = self.friends.all().select_related(depth=1)[:count]
        return u'[%s%s]' % (u', '.join(unicode(f.user) for f in friend_list),
                            u', ...' if self.friend_count() > count else u'')
    friend_summary.short_description = _(u'Summary of friends')


class UserBlocks(models.Model):
    """
    |User|'s blocked by :attr:`~UserBlocks.user`.
    """

    user = models.OneToOneField(User, related_name='user_blocks')
    """
    |OneToOneField| to |User| whose blocks are stored.
    """

    blocks = models.ManyToManyField(User, related_name='blocked_by_set')
    """
    |ManyToManyField| to containing blocked |User|'s.
    """

    class Meta:
        verbose_name = verbose_name_plural = _(u'user blocks')

    def __unicode__(self):
        return _(u'Users blocked by %(user)s') % {'user': unicode(self.user)}

    def block_count(self):
        """
        Return the count of :attr:`~UserBlocks.blocks`.
        This method is used in :class:`~friends.admin.UserBlocksAdmin`.

        :rtype: |int|
        """
        return self.blocks.count()
    block_count.short_description = _(u'Blocks count')

    def block_summary(self, count=7):
        """
        Return a string representation of
        :attr:`~UserBlocks.blocks`.
        This method is used in :class:`~friends.admin.UserBlocksAdmin`.

        :param |int| count: Maximum number of blocked users to include in
                            the output.
        :rtype: |unicode|
        """
        block_list = self.blocks.all()[:count]
        return u'[%s%s]' % (u', '.join(unicode(user) for user in block_list),
                            u', ...' if self.block_count() > count else u'')
    block_summary.short_description = _(u'Summary of blocks')


# Signal connections
models.signals.post_save.connect(
    signals.create_friendship_instance,
    sender=User,
    dispatch_uid='friends.signals.create_friendship_instance',
)
models.signals.post_save.connect(
    signals.create_userblocks_instance,
    sender=User,
    dispatch_uid='friends.signals.create_userblocks_instance',
)

########NEW FILE########
__FILENAME__ = signals
"""
Signals
=======

friendship_accepted
-------------------

.. data:: friends.signals.friendship_accepted

    Sent when a |FriendshipRequest| is accepted.

    Arguments sent with this signal:

    ``sender``
        |FriendshipRequest| instance that is accepted.


friendship_declined
-------------------

.. data:: friends.signals.friendship_declined

    Sent when a |FriendshipRequest| is declined by
    :attr:`~friends.models.FriendshipRequest.to_user`.

    Arguments sent with this signal:

    ``sender``
        |FriendshipRequest| instance that is declined.


friendship_cancelled
--------------------

.. data:: friends.signals.friendship_cancelled

    Sent when a |FriendshipRequest| is cancelled by
    :attr:`~friends.models.FriendshipRequest.from_user`.

    Arguments sent with this signal:

    ``sender``
        |FriendshipRequest| instance that is cancelled.


Signal Handlers
===============

.. automethod:: friends.signals.create_friendship_instance

.. automethod:: friends.signals.create_userblocks_instance
"""


from django.dispatch import Signal


friendship_accepted = Signal()


friendship_declined = Signal()


friendship_cancelled = Signal()


def create_friendship_instance(sender, instance, created, raw, **kwargs):
    """
    Create a |FriendshipRequest| for newly created |User|.

    .. seealso::
        :data:`~django.db.models.signals.post_save` built-in signal.
    """
    from friends.models import Friendship
    if created and not raw:
        Friendship.objects.create(user=instance)


def create_userblocks_instance(sender, instance, created, raw, **kwargs):
    """
    Create a |UserBlocks| for newly created |User|.

    .. seealso::
        :data:`~django.db.models.signals.post_save` built-in signal.
    """
    from friends.models import UserBlocks
    if created and not raw:
        UserBlocks.objects.create(user=instance)

########NEW FILE########
__FILENAME__ = friends_tags
from django import template
from django.contrib.auth.models import User
from friends.models import FriendshipRequest, Friendship, UserBlocks


register = template.Library()


class AddToFriendsNode(template.Node):
    def __init__(self, target_user, current_user='user',
                       template_name='friends/_add_to.html'):
        self.target_user = template.Variable(target_user)
        self.current_user = template.Variable(current_user)
        self.template_name = template_name

    def render(self, context):
        target_user = self.target_user.resolve(context)
        current_user = self.current_user.resolve(context)
        if current_user.is_authenticated():
            ctx = {'target_user': target_user,
                   'current_user': current_user}
            if not target_user is current_user:
                ctx['are_friends'] = Friendship.objects.are_friends(
                                                    target_user, current_user)
                ctx['is_invited'] = bool(FriendshipRequest.objects.filter(
                                                    from_user=current_user,
                                                    to_user=target_user,
                                                    accepted=False).count())
            return template.loader.render_to_string(self.template_name,
                                                    ctx,
                                                    context)
        else:
            return u''


class BlockUserLinkNode(template.Node):
    def __init__(self, target_user, current_user='user',
                       template_name='friends/_block.html'):
        self.target_user = template.Variable(target_user)
        self.current_user = template.Variable(current_user)
        self.template_name = template_name

    def render(self, context):
        target_user = self.target_user.resolve(context)
        current_user = self.current_user.resolve(context)
        if current_user.is_authenticated():
            ctx = {'target_user': target_user,
                   'current_user': current_user}
            if not target_user is current_user:
                ctx['is_blocked'] = bool(UserBlocks.objects.filter(
                         user=current_user, blocks__pk=target_user.pk).count())
            return template.loader.render_to_string(self.template_name,
                                                    ctx,
                                                    context)
        else:
            return u''


def add_to_friends(parser, token):
    bits = token.split_contents()
    tag_name, bits = bits[0], bits[1:]
    if not bits:
        raise template.TemplateSyntaxError(
                           '%s tag requires at least one argument' % tag_name)
    elif len(bits) > 3:
        raise template.TemplateSyntaxError(
                            '%s tag takes at most three arguments' % tag_name)
    if len(bits) == 3:
        if bits[2].startswith('"') and bits[2].endswith('"'):
            bits[2] = bits[2][1:-1]
        else:
            raise template.TemplateSyntaxError(
                      'Third argument for %s tag must be a string' % tag_name)
    return AddToFriendsNode(*bits)


def blocks(value):
    user = _get_user_from_value('friends', value)
    return {
        'applied': User.objects.filter(blocked_by_set__user=user),
        'received': User.objects.filter(user_blocks__blocks=user),
    }


def block_user(parser, token):
    bits = token.split_contents()
    tag_name, bits = bits[0], bits[1:]
    if not bits:
        raise template.TemplateSyntaxError(
                           '%s tag requires at least one argument' % tag_name)
    elif len(bits) > 3:
        raise template.TemplateSyntaxError(
                            '%s tag takes at most three arguments' % tag_name)
    if len(bits) == 3:
        if bits[2].startswith('"') and bits[2].endswith('"'):
            bits[2] = bits[2][1:-1]
        else:
            raise template.TemplateSyntaxError(
                      'Third argument for %s tag must be a string' % tag_name)
    return BlockUserLinkNode(*bits)


def friends_(value):
    user = _get_user_from_value('friends', value)
    return Friendship.objects.friends_of(user)


def friendship_requests(value):
    user = _get_user_from_value('friends', value)
    return {
        'sent': User.objects.filter(friendshiprequests_to__from_user=user),
        'received': User.objects.filter(friendshiprequests_from__to_user=user),
    }


def is_blocked_by(value, arg):
    user = _get_user_from_value('isblockedby', value)
    target = _get_user_from_argument('isblockedby', arg)
    return UserBlocks.objects.filter(user=target, blocks=user).exists()


def is_friends_with(value, arg):
    user = _get_user_from_value('isfriendswith', value)
    target = _get_user_from_argument('isfriendswith', arg)
    return Friendship.objects.are_friends(user, target)


def _get_user(value):
    if isinstance(value, User):
        return value
    elif hasattr(value, 'user') and isinstance(value.user, User):
        return value.user
    else:
        raise ValueError


def _get_user_from_argument(filter_name, arg):
    try:
        return _get_user(arg)
    except ValueError:
        message = '%s filter\'s argument must be a User or ' \
                  'an object with a `user` attribute.' % filter_name
        raise template.TemplateSyntaxError(message)


def _get_user_from_value(filter_name, value):
    try:
        return _get_user(value)
    except ValueError:
        message = '%s filter can only be applied to User\'s or ' \
                  'objects with a `user` attribute.' % filter_name
        raise template.TemplateSyntaxError(message)


register.filter('blocks', blocks)
register.filter('friends', friends_)
register.filter('friendshiprequests', friendship_requests)
register.filter('isblockedby', is_blocked_by)
register.filter('isfriendswith', is_friends_with)
register.tag('addtofriends', add_to_friends)
register.tag('blockuser', block_user)

########NEW FILE########
__FILENAME__ = tests
from django.test import TestCase
from django.core.urlresolvers import reverse
from django.contrib.auth.models import User
from friends.models import FriendshipRequest, Friendship, UserBlocks
from friends.templatetags import friends_tags


class BaseTestCase(TestCase):
    fixtures = ['test_data.json']

    def setUp(self):
        for i in range(1, 5):
            setattr(self, 'user%d' % i,
                                  User.objects.get(username='testuser%d' % i))


class BlocksFilterTestCase(BaseTestCase):
    def test_blocks_filter(self):
        result = friends_tags.blocks(self.user4)
        self.assertTrue(isinstance(result, dict))
        self.assertTrue('applied' in result)
        self.assertEqual(len(result['applied']), 2)
        self.assertTrue(self.user1 in result['applied'])
        self.assertTrue(self.user3 in result['applied'])
        self.assertTrue('received' in result)
        self.assertEqual(len(result['received']), 2)
        self.assertTrue(self.user1 in result['received'])
        self.assertTrue(self.user2 in result['received'])


class FriendsFilterTestCase(BaseTestCase):
    def test_friends_filter(self):
        result = friends_tags.friends_(self.user1)
        self.assertEqual(len(result), 1)
        self.assertTrue(self.user2 in result)


class FriendshipModelsTestCase(BaseTestCase):
    def test_friendship_request(self):
        are_friends = Friendship.objects.are_friends
        for method, result in [('decline', False),
                               ('cancel', False),
                               ('accept', True)]:
            friendship_request = FriendshipRequest.objects.create(
                                     from_user=self.user3, to_user=self.user4)
            self.assertEqual(are_friends(self.user3, self.user4), False)
            getattr(friendship_request, method)()
            self.assertEqual(are_friends(self.user3, self.user4), result)

    def test_friendship_manager_query_methods(self):
        self.assertEqual(Friendship.objects.are_friends(self.user1,
                                                        self.user2), True)
        self.assertEqual(Friendship.objects.are_friends(self.user1,
                                                        self.user3), False)
        self.assertEqual(Friendship.objects.are_friends(self.user2,
                                                        self.user3), False)
        friends_of_user1 = Friendship.objects.friends_of(self.user1)
        friends_of_user2 = Friendship.objects.friends_of(self.user2)
        friends_of_user3 = Friendship.objects.friends_of(self.user3)
        self.assertEqual(list(friends_of_user1), [self.user2])
        self.assertEqual(list(friends_of_user2), [self.user1])
        self.assertEqual(list(friends_of_user3), [])

    def test_friendship_manager_befriend(self):
        Friendship.objects.befriend(self.user1, self.user4)
        self.assertEqual(Friendship.objects.are_friends(self.user1,
                                                        self.user4), True)

    def test_friendship_manager_unfriend(self):
        Friendship.objects.unfriend(self.user1, self.user2)
        self.assertEqual(Friendship.objects.are_friends(self.user1,
                                                        self.user2), False)


class FriendshipRequestsFilterTestCase(BaseTestCase):
    def test_friendship_requests_filter(self):
        FriendshipRequest.objects.create(from_user=self.user1,
                                         to_user=self.user3)
        FriendshipRequest.objects.create(from_user=self.user4,
                                         to_user=self.user1)
        result = friends_tags.friendship_requests(self.user1)
        # result['sent'] shouldn't contain user2 because they
        # are already friends.
        result = {
            'sent': [self.user3],
            'received': [self.user4],
        }


class FriendshipViewsTestCase(BaseTestCase):
    urls = 'friends.urls'

    def test_friendship_request(self):
        self.client.login(username='testuser1', password='testuser1')
        self.client.get(reverse('friendship_request', args=('testuser3',)))
        self.assertEqual(Friendship.objects.are_friends(self.user1,
                                                        self.user3), False)
        self.assertEqual(FriendshipRequest.objects.filter(from_user=self.user1,
                               to_user=self.user3, accepted=False).count(), 1)

    def test_friendship_accept(self):
        FriendshipRequest.objects.create(from_user=self.user1,
                                         to_user=self.user3)
        self.client.login(username='testuser3', password='testuser3')
        self.client.get(reverse('friendship_accept', args=('testuser1',)))
        self.assertEqual(FriendshipRequest.objects.filter(
                                                   accepted=True).count(), 2)
        self.assertEqual(Friendship.objects.are_friends(self.user1,
                                                        self.user3), True)

    def test_friendship_cancel(self):
        FriendshipRequest.objects.create(from_user=self.user1,
                                         to_user=self.user3)
        self.client.login(username='testuser1', password='testuser1')
        self.client.get(reverse('friendship_cancel', args=('testuser3',)))
        self.assertEqual(FriendshipRequest.objects.filter(
                                                   accepted=False).count(), 0)
        self.assertEqual(Friendship.objects.are_friends(self.user1,
                                                        self.user3), False)

    def test_friendship_decline(self):
        FriendshipRequest.objects.create(from_user=self.user1,
                                         to_user=self.user3)
        self.client.login(username='testuser3', password='testuser3')
        self.client.get(reverse('friendship_decline', args=('testuser1',)))
        self.assertEqual(FriendshipRequest.objects.filter(
                                                   accepted=False).count(), 0)
        self.assertEqual(Friendship.objects.are_friends(self.user1,
                                                        self.user3), False)

    def test_friendship_delete(self):
        self.client.login(username='testuser1', password='testuser1')
        self.client.get(reverse('friendship_delete', args=('testuser2',)))
        self.assertEqual(Friendship.objects.are_friends(self.user1,
                                                        self.user2), False)

    def test_friendship_mutual_request(self):
        self.client.login(username='testuser1', password='testuser1')
        self.client.get(reverse('friendship_request', args=('testuser3',)))
        self.assertEqual(Friendship.objects.are_friends(self.user1,
                                                        self.user3), False)
        self.client.login(username='testuser3', password='testuser3')
        self.client.get(reverse('friendship_request', args=('testuser1',)))
        self.assertEqual(FriendshipRequest.objects.filter(from_user=self.user1,
                                to_user=self.user3, accepted=True).count(), 1)
        self.assertEqual(Friendship.objects.are_friends(self.user1,
                                                        self.user3), True)


class UserBlockTestCase(BaseTestCase):
    def test_blocking_info_methods(self):
        self.user1.user_blocks.blocks.add(self.user3, self.user4)
        self.assertEqual(self.user1.user_blocks.block_count(), 2)
        summary = UserBlocks.objects.get(user=self.user1).block_summary()
        self.assertEqual(self.user3.username in summary, True)
        self.assertEqual(self.user4.username in summary, True)


class UserBlocksViewsTestCase(BaseTestCase):
    urls = 'friends.urls'

    def test_block(self):
        self.client.login(username='testuser1', password='testuser1')
        self.client.get(reverse('user_block', args=('testuser2',)))
        self.assertEqual(self.user2 in self.user1.user_blocks.blocks.all(),
                                                                         True)

    def test_unblock(self):
        self.user1.user_blocks.blocks.add(self.user2)
        self.client.login(username='testuser1', password='testuser1')
        self.client.get(reverse('user_unblock', args=('testuser2',)))
        self.assertEqual(self.user2 in self.user1.user_blocks.blocks.all(),
                                                                        False)

########NEW FILE########
__FILENAME__ = urls
try:
    from django.conf.urls import patterns, url
except ImportError:
    from django.conf.urls.defaults import patterns, url


urlpatterns = patterns(
    'friends.views',
    url(r'^add/(?P<username>[\+\w\.@-_]+)/$',
        'friendship_request',
        name='friendship_request'),
    url(r'^accept/(?P<username>[\+\w\.@-_]+)/$',
        'friendship_accept',
        name='friendship_accept'),
    url(r'^decline/(?P<username>[\+\w\.@-_]+)/$',
        'friendship_decline',
        name='friendship_decline'),
    url(r'^cancel/(?P<username>[\+\w\.@-_]+)/$',
        'friendship_cancel',
        name='friendship_cancel'),
    url(r'^delete/(?P<username>[\+\w\.@-_]+)/$',
        'friendship_delete',
        name='friendship_delete'),
    url(r'^block/(?P<username>[\+\w\.@-_]+)/$',
        'user_block',
        name='user_block'),
    url(r'^unblock/(?P<username>[\+\w\.@-_]+)/$',
        'user_unblock',
        name='user_unblock'),
)

########NEW FILE########
__FILENAME__ = views
"""
Views
=====

.. _class-based-views:

Class Based Views
-----------------

All the views are implemented as
`classes <https://docs.djangoproject.com/en/dev/topics/class-based-views/>`_
but :ref:`view functions <view-functions>` are also provided.

.. autoclass:: BaseActionView
    :members:

.. autoclass:: FriendshipAcceptView

.. autoclass:: UserBlockView

.. autoclass:: FriendshipCancelView

.. autoclass:: FriendshipDeclineView

.. autoclass:: FriendshipDeleteView

.. autoclass:: FriendshipRequestView

.. autoclass:: UserUnblockView


.. _view-functions:

View Functions
--------------

.. tip::

    If you want to customize the views provided, check out
    :ref:`class-based-views` first.

.. autofunction:: friendship_request

.. autofunction:: friendship_accept

.. autofunction:: friendship_decline

.. autofunction:: friendship_cancel

.. autofunction:: friendship_delete

.. autofunction:: user_block

.. autofunction:: user_unblock
"""

from django.http import HttpResponseBadRequest, Http404
from django.db import transaction
from django.views.generic.base import RedirectView
from django.shortcuts import get_object_or_404
from django.utils.translation import ugettext
from django.contrib.auth.models import User
from django.contrib.auth.decorators import login_required
from models import FriendshipRequest, Friendship
from app_settings import REDIRECT_FALLBACK_TO_PROFILE


class BaseActionView(RedirectView):
    """
    Base class for action views.
    """

    http_method_names = ['get', 'post']
    permanent = False

    def action(request, user, *args, **kwargs):
        raise NotImplementedError("Subclasses must implement action()")

    def get(self, request, username, *args, **kwargs):
        if request.user.username == username:
            return HttpResponseBadRequest(
                ugettext(u'You can\'t befriend yourself.'),
            )
        user = get_object_or_404(User, username=username)
        self.action(request, user, *args, **kwargs)
        self.set_url(request, **kwargs)
        return super(BaseActionView, self).get(request, **kwargs)

    def set_url(self, request, **kwargs):
        """
        Set the ``url`` attribute so that it can be used when
        :py:meth:`~django.views.generic.base.RedirectView.get_redirect_url` is
        called.

        ``url`` is determined using the following methods, in order:

        - It can be set in the urlconf using ``redirect_to`` keyword argument.
        - If ``redirect_to_param`` keyword argument is set in urlconf, the
          request parameter with that name will be used. In this case the
          request parameter **must** be provided in runtime.
        - If the request has ``redirect_to`` to parameter is present, its
          value will be used.
        - If ``REDIRECT_FALLBACK_TO_PROFILE`` setting is ``True``, current
          user's profile URL will be used.
        - ``HTTP_REFERER`` header's value will be used if exists.
        - If all else fail, ``'/'`` will be used.
        """
        if 'redirect_to' in kwargs:
            self.url = kwargs['redirect_to']
        elif 'redirect_to_param' in kwargs and \
             kwargs['redirect_to_param'] in request.REQUEST:
            self.url = request.REQUEST[kwargs['redirect_to_param']]
        elif 'redirect_to' in request.REQUEST:
            self.url = request.REQUEST['next']
        elif REDIRECT_FALLBACK_TO_PROFILE:
            self.url = request.user.get_profile().get_absolute_url()
        else:
            self.url = request.META.get('HTTP_REFERER', '/')


class FriendshipAcceptView(BaseActionView):
    @transaction.commit_on_success
    def accept_friendship(self, from_user, to_user):
        get_object_or_404(
            FriendshipRequest,
            from_user=from_user,
            to_user=to_user,
        ).accept()

    def action(self, request, user, **kwargs):
        self.accept_friendship(user, request.user)


class FriendshipRequestView(FriendshipAcceptView):
    @transaction.commit_on_success
    def action(self, request, user, **kwargs):
        if Friendship.objects.are_friends(request.user, user):
            raise RuntimeError(
                '%r amd %r are already friends' % (request.user, user),
            )
        try:
            # If there's a friendship request from the other user accept it.
            self.accept_friendship(user, request.user)
        except Http404:
            request_message = request.REQUEST.get('message', u'')
            # If we already have an active friendship request IntegrityError
            # will be raised and the transaction will be rolled back.
            FriendshipRequest.objects.create(
                from_user=request.user,
                to_user=user,
                message=request_message,
            )


class FriendshipDeclineView(BaseActionView):
    def action(self, request, user, **kwargs):
        get_object_or_404(FriendshipRequest,
                          from_user=user,
                          to_user=request.user).decline()


class FriendshipCancelView(BaseActionView):
    def action(self, request, user, **kwargs):
        get_object_or_404(FriendshipRequest,
                          from_user=request.user,
                          to_user=user).cancel()


class FriendshipDeleteView(BaseActionView):
    def action(self, request, user, **kwargs):
        Friendship.objects.unfriend(request.user, user)


class UserBlockView(BaseActionView):
    def action(self, request, user, **kwargs):
        request.user.user_blocks.blocks.add(user)


class UserUnblockView(BaseActionView):
    def action(self, request, user, **kwargs):
        request.user.user_blocks.blocks.remove(user)


friendship_request = login_required(FriendshipRequestView.as_view())
friendship_accept = login_required(FriendshipAcceptView.as_view())
friendship_decline = login_required(FriendshipDeclineView.as_view())
friendship_cancel = login_required(FriendshipCancelView.as_view())
friendship_delete = login_required(FriendshipDeleteView.as_view())
user_block = login_required(UserBlockView.as_view())
user_unblock = login_required(UserUnblockView.as_view())

########NEW FILE########
