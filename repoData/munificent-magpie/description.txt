This directory contains the Magpie "standard library" for the C++ Magpie VM.
Once the VM is more mature, this will be merged with lib/.
A place-holder for this Xcode build output directory, so that the
test script can verify that .xcodeproj files are not created in
their normal location by making the src/ read-only, and then
selectively making this build directory writable.

A place-holder for this Xcode build output directory, so that the
test script can verify that .xcodeproj files are not created in
their normal location by making the src/ read-only, and then
selectively making this build directory writable.

A place-holder for this Xcode build output directory, so that the
test script can verify that .xcodeproj files are not created in
their normal location by making the src/ read-only, and then
selectively making this build directory writable.

A place-holder for this Xcode build output directory, so that the
test script can verify that .xcodeproj files are not created in
their normal location by making the src/ read-only, and then
selectively making this build directory writable.

A place-holder for this Xcode build output directory, so that the
test script can verify that .xcodeproj files are not created in
their normal location by making the src/ read-only, and then
selectively making this build directory writable.

Supporting modules for GYP testing.

    TestCmd.py
    TestCommon.py

        Modules for generic testing of command-line utilities,
        specifically including the ability to copy a test configuration
        to temporary directories (with default cleanup on exit) as part
        of running test scripts that invoke commands, compare actual
        against expected output, etc.

        Our copies of these come from the SCons project,
        http://www.scons.org/.

    TestGyp.py

        Modules for GYP-specific tests, of course.

Make things live in a subdirectory, to make sure that DEPTH works correctly.

How to install gyp-mode for emacs:

Add the following to your ~/.emacs (replace ... with the path to your gyp
checkout).

(setq load-path (cons ".../tools/emacs" load-path))
(require 'gyp)

Restart emacs (or eval-region the added lines) and you should be all set.

Please note that ert is required for running the tests, which is included in
Emacs 24, or available separately from https://github.com/ohler/ert

pretty_vcproj:
  Usage: pretty_vcproj.py "c:\path\to\vcproj.vcproj" [key1=value1] [key2=value2]

  They key/value pair are used to resolve vsprops name.

  For example, if I want to diff the base.vcproj project:

  pretty_vcproj.py z:\dev\src-chrome\src\base\build\base.vcproj "$(SolutionDir)=z:\dev\src-chrome\src\chrome\\" "$(CHROMIUM_BUILD)=" "$(CHROME_BUILD_TYPE)=" > orignal.txt
  pretty_vcproj.py z:\dev\src-chrome\src\base\base_gyp.vcproj "$(SolutionDir)=z:\dev\src-chrome\src\chrome\\" "$(CHROMIUM_BUILD)=" "$(CHROME_BUILD_TYPE)=" > gyp.txt

  And you can use your favorite diff tool to see the changes.

  Note: In the case of base.vcproj, the original vcproj is one level up the generated one.
        I suggest you do a search and replace for '"..\' and replace it with '"' in original.txt
        before you perform the diff.
Specifications contains syntax formatters for Xcode 3. These do not appear to be supported yet on Xcode 4. To use these with Xcode 3 please install both the gyp.pbfilespec and gyp.xclangspec files in

~/Library/Application Support/Developer/Shared/Xcode/Specifications/

and restart Xcode.
# libuv [![Build Status](https://secure.travis-ci.org/joyent/libuv.png)](http://travis-ci.org/joyent/libuv)

libuv is a new platform layer for Node. Its purpose is to abstract IOCP on
Windows and epoll/kqueue/event ports/etc. on Unix systems. We intend to
eventually contain all platform differences in this library.

http://nodejs.org/

## Features

 * Non-blocking TCP sockets

 * Non-blocking named pipes

 * UDP

 * Timers

 * Child process spawning

 * Asynchronous DNS via `uv_getaddrinfo`.

 * Asynchronous file system APIs `uv_fs_*`

 * High resolution time `uv_hrtime`

 * Current executable path look up `uv_exepath`

 * Thread pool scheduling `uv_queue_work`

 * ANSI escape code controlled TTY `uv_tty_t`

 * File system events Currently supports inotify, `ReadDirectoryChangesW`
   and kqueue. Event ports in the near future.
   `uv_fs_event_t`

 * IPC and socket sharing between processes `uv_write2`

## Community

 * [Mailing list](http://groups.google.com/group/libuv)

## Documentation

 * [include/uv.h](https://github.com/joyent/libuv/blob/master/include/uv.h)
   &mdash; API documentation in the form of detailed header comments.
 * [An Introduction to libuv](http://nikhilm.github.com/uvbook/) &mdash; An
   overview of libuv with tutorials.
 * [LXJS 2012 talk](http://www.youtube.com/watch?v=nGn60vDSxQ4) - High-level
   introductory talk about libuv.
 * [Tests and benchmarks](https://github.com/joyent/libuv/tree/master/test) -
   API specification and usage examples.

## Build Instructions

For GCC (including MinGW) there are two methods building: via normal
makefiles or via GYP. GYP is a meta-build system which can generate MSVS,
Makefile, and XCode backends. It is best used for integration into other
projects.  The old (more stable) system is using Makefiles.

To build via Makefile simply execute:

    make

To build with Visual Studio run the vcbuilds.bat file which will
checkout the GYP code into build/gyp and generate the uv.sln and
related files.

Windows users can also build from cmd-line using msbuild.  This is
done by running vcbuild.bat from Visual Studio command prompt.

To have GYP generate build script for another system you will need to
checkout GYP into the project tree manually:

    svn co http://gyp.googlecode.com/svn/trunk build/gyp

Unix users run

    ./gyp_uv -f make
    make

Macintosh users run

    ./gyp_uv -f xcode
    xcodebuild -project uv.xcodeproj -configuration Release -target All

Note for Linux users: compile your project with `-D_GNU_SOURCE` when you
include `uv.h`. GYP builds take care of that automatically. If you use
autotools, add a `AC_GNU_SOURCE` declaration to your `configure.ac`.

## Supported Platforms

Microsoft Windows operating systems since Windows XP SP2. It can be built
with either Visual Studio or MinGW.

Linux 2.6 using the GCC toolchain.

MacOS using the GCC or XCode toolchain.

Solaris 121 and later using GCC toolchain.

Any expression can appear in any order at the top level. Top-level expressions, including `def`, `var`, and `defclass` are executed top-to-bottom. Unlike in nested scopes, any name defined at the top level can be referred to anywhere in the program, even before that definition appears. However, an expression containing a name must not be *executed* before that name is defined.

Expressions appearing is variable initializers are executed immediately at the point of the definition, as are superclass specifiers. Method bodies, method patterns, field initializers, and field patterns are *not* executed immediately.

These are errors:

    var first = second
    var second = "value"

    defclass First is Second
    end
    defclass Second
    end

This is OK:

    def method() later
    var later = "ok"
    print(method())

But note that this is not:

    def method() later
    print(method()) // later has not been defined yet
    var later = "ok"

To avoid errors, all referred-to names but have defined values (i.e. the expression that defines it must have been executed) before expressions containing them are executed.

 *  A method body is executed when that multimethod is called and that specific
    method is selected and executed.
 *  A method pattern is executed once when that multimethod is called after
    that method's `def` expression has been executed. Field patterns are
    essentially method patterns too.
 *  A field initializer is executed when an instance of the containing class is
    constructed. (And when a value for that field is not provided?)

The general model here is that instead of trying to statically detect undefined variable access errors, we will defer much of that to runtime. This doesn't catch as many errors as we'd like, but it makes top-level forms simpler to reason about.
^title Blocks

In any imperative language, you often want to perform a series of actions in sequence. You usually do this by creating a *block*. A block contains a series of expressions. When the block is evaluated, each expression is evaluated in turn. The result of the last expression is the value of the block. The values returned by previous expressions are discarded.

## Syntax

Magpie has a peculiarly lightweight syntax for defining blocks. Consider a simple [if](flow-control.html) expression. If we just want to evaluate a single expression when the condition is met, we can do so like this:

    :::magpie
    if isHappy then print("I'm happy!")

If we want to evaluate a series of expressions when the condition is met, we need to create a block:

    :::magpie
    if isHappy then
        print("I'm happy!")
        print("Really happy!")
    end

A block begins with a newline where an expression is expected. The parser knows that an expression must follow a `then`. If it sees a newline there instead, it knows that a block is being provided. It will then parse a series of expressions separated by newlines until it reaches the terminator for the block.

Normally, the terminator is the `end` keyword, but it may be another keyword based on the context in which the block occurs. For example, you can terminate the `then` block in an `if` expression with `else`:

    :::magpie
    if isHappy then
        print("I'm happy!")
        print("Really happy!")
    else // Terminates the then block.
        print("I'm not happy")
    end

This all sounds a bit fishy, but in practice it works well with a minimum of punctuation. There is one important bit to keep in mind with this: you cannot have an expression on the first line if you want to create a block:

    :::magpie
    if isHappy then print("I'm happy!") // ERROR
        print("Really happy!")
    end

If you do so, it will assume that the first expression is all that is expected, and subsequent lines will not be part of the block.

## Do Blocks

If you want to create a block in the middle of another block, you can create a `do` block:

    :::magpie
    print("one")
    do
        print("two")
        print("three")
    end
    print("four")

This can be useful if you want to limit the scope of a [variable](variables.html) or [catch](error-handling.html#catching-errors) a thrown error.

^title Calls

Most of the [expressions](expressions.html) you'll write in Magpie will be *calls*. A call invokes a [multimethod](multimethods.html) by name, passing in the provided argument. Method calls may have one of three different "fixities" in Magpie, which means the name of the method may appear before, after, or in the middle of the argument.

It's important to note that the fixity distinction is purely syntactic. Semantically, all method calls are just calls that take arguments. Magpie is flexible here is so to let you define APIs that read naturally when called.

## Prefix Calls

A *prefix* method call is a method name followed by an argument. The argument must be in parentheses.

    :::magpie
    print("Hello!")

Prefix calls are most useful for operations where no argument is "special" and where the operation doesn't feel like an intrinsic property of the argument. The above *could* be `"Hello!" print` but that would feel a bit strange since printing doesn't seem like an intrinsic capability of strings.

## Infix Calls

An *infix* method call is a left-hand expression followed by the method name, followed by a right-hand argument. Like prefix calls, the right-hand argument must be in parentheses (but the left does not).

    :::magpie
    list add("item")

This is a single call that invokes the `add` method. The arguments are `list` and `"item"`.

If you're wondering where the `.` went, the answer is that Magpie doesn't use one between the left-hand argument and the method. In general, Magpie eschews punctuation when possible and this is an example of that. Instead, `.` is just another character that can be used in identifiers.

## Postfix Calls

An expression followed by a name defines a *postfix* method call.

    :::magpie
    "a string" count

This invokes the `count` method with `"a string"` as the lone argument.

**TODO: Infix and prefix operator calls.**

## Subscript Operators

The named call syntax we've seen covers most code you'll read and write in Magpie, but it also offers a little special sugar for accessing collection-like objects. A *subscript operator* is a method call that uses square brackets.

    :::magpie
    collection[3]

Here, we're calling a subscript operator method. The left-hand argument is `collection` and the right-hand is `3`. While they look different, subscript operators are just another notation for method calls. You can define your own subscripts and they can be overloaded just like other multimethods. If `collection` here was an instance of an `List` class, the indexer method called above could be defined like this:

    :::magpie
    def (this is List)[index is Int]
        // Get item at index...
    end

Subscript operators aren't limited to numeric arguments inside the square brackets. Any [pattern](patterns.html), including record ones is valid.

    :::magpie
    def (this is Grid)[x is Int, y is Int]
        // Get item at position...
    end

Here we've defined a subscript for a `Grid` class that accesses a point on a two-dimensional space. It can be called like this:

    :::magpie
    grid[2, 3]

## Chaining Calls

Call expressions are left-associative, which follows how method calls work in other object-oriented languages. This way, a series of method calls can be read from left to right.

    :::magpie
    addressBook names find("Waldo") sendEmail

This expression will be parsed like:

    :::magpie
    ((addressBook names) find("Waldo")) sendEmail

**TODO: `with` block arguments**

^title Classes

Magpie is a class-based language. That means everything you can stick in a
[variable](variables.html) will be an [*object*](objects.html) and every object is an instance of some *class*. Even [primitive types](primitives.html) like numbers and booleans are full-featured objects, as are [functions](functions.html).

Objects exist to *store data*, package it together, and let you pass it around. Objects also know their class, which can be used to select one method in a [multimethod](multimethods.html).

Unlike most object-oriented languages, classes in Magpie do not own methods. State and behavior are not encapsulated together. Instead, classes own state, and multimethods own behavior.

## Defining Classes

A class has a *name* and a set of *fields*, which describe the state the class holds. Unlike other dynamic languages, Magpie requires all of a class's fields to be explicitly declared. They aren't just loose bags of data. You can define a new class using the `defclass` keyword.

    :::magpie
    defclass Point
        var x
        var y
    end

This declares a simple class `Point`, with two fields `x` and `y`.

## Constructing Instances

Once you've defined a class, you instantiate new instances of it by calling the constructor method `new`. The left-hand argument to `new` is the class being instantiated, and the right-hand argument is a [record](records.html). The record has a named field for each field that the class defines. Given our above `Point` class, we can create a new instance like this:

    :::magpie
    val point = Point new(x: 2, y: 3)

### Overloading Initialization

Construction actually proceeds in two stages. When you invoke `new()`, it creates a fresh object of your class in some hidden location. Then it invokes the `init()` multimethod, passing in the same arguments. `init()` is responsible for initializing the fields of this hidden instance, but it doesn't return anything. After `init()` is done, `new()` returns the freshly-created and now fully-initialized object.

When you define a class, Magpie automatically creates a new specialization for `init()` that takes your class on the left, and a record of all of its fields on the right. This is called the *canonical initializer*. You can also provide your own specializations of `init()`. Doing so lets you overload constructors.

    :::magpie
    def (this == Point) init(x is Int, y is Int)
        this init(x: x, y: y)
    end

Here we've defined a new `init()` method that takes a `x` and `y` coordinates using a simple unnamed record. We can call it like this:

    :::magpie
    val point = Point new(2, 3)

When you call `new()` it looks for an `init()` method that matches *whatever* you pass to it. In this case, `2, 3` matches our overloaded `init()` method. That method in turn calls the canonical or "real" initializer to ensure that all of the class's fields are initialized.

This way, you are free to overload `init()` to make it easy to create instances of your classes. The only key requirement is that an `init()` method needs to eventually "bottom out" and call the canonical initializer before it returns. If you fail to do that, Magpie will [throw](error-handling.html) an `InitializationError` when you try to construct the object.

### Overloading Construction

In the above example, we provide an alternate path for *initializing* a new object, but we're still *creating* a new object normally. Sometimes you may need to be more flexible than that. Perhaps you want to cache objects so that calling `new()` with certain arguments always returns the *same* object.

    :::magpie
    def (this == Point) new(x is Int, y is Int)
        match x, y
            case 0, 0 then zeroPoint // Use cached one.
            else this new(x: x, y: y)
        end
    end

As you can see, you can also overload `new()` itself. If you do that, you can sidestep the process of creating a fresh instance entirely and return another existing object.

This also gives you the flexibility of creating an instance of a different class than what was passed in. You may want to hide the concrete class behind an abstract superclass, or switch out the concrete class based on some specific data passed in. Overloading `new()` gives you this flexibility without having to go through the trouble of implementing your own [factory](http://en.wikipedia.org/wiki/Factory_pattern).

## Fields

Once you have an instance of a class, you access a field by invoking a [getter](calls.html) on the object whose name is the name of the field.

    :::magpie
    val point = Point new(x: 2, y: 3)
    print(point x) // 2

Here, `point x` is a call to a method `x` with argument `point`. As you would expect, it returns the field's value.

### Assigning to Fields

Setting a field on an existing object looks like you'd expect:

    :::magpie
    val point = Point new(x: 2, y: 3)
    point x = 4
    print(point x)

**TODO: Explain that this is just a setter and point to assignment page.**

### Field Patterns

When defining a field, you may optionally give it a [pattern](patterns.html) after the field's name. If provided, then you will only be able to initialize or assign to the field using values that match that pattern.

    :::magpie
    defclass Point
        var x is Int
        var y is Int
    end

Here `x` and `y` are now constrained to number values by using `is Int` patterns. If you try to construct a `Point` using another type, or set a field using something other than an `Int`, you'll get an [error](error-handling.html).

### Immutable Fields

So far, we've seen fields defined using `var`, but you can also define them with `val`. Doing so creates an *immutable* field. Immutable fields can be initialized at construction time, but don't have a setter, so they can't be modified.

    :::magpie
    defclass ImmutablePoint
        val x is Int
        val y is Int
    end

    var point = ImmutablePoint new(x: 1, y: 2)
    point x = 2 // ERROR: There is no setter for "x".

### Field Initializers

Finally, when defining a field in a class, you can give it an initializer by having an `=` followed by an expression. If you do that, you won't need to pass in a value for the field when instantiating the class. Instead, it will automatically evaluate that initializer expression and set the field to the result.

    :::magpie
    defclass Point
        var x = 0
        var y = 0
    end

Here `Point`s will default to be `0, 0`. You can create a new one simply by doing:

    :::magpie
    val point = Point new()

## Inheritance

Like most class-based languages, Magpie supports *inheritance*. You can specify that one class is a *child* or *subclass* of another, like so:

    :::magpie
    defclass Widget
        val label is String
    end

    defclass Button is Widget
        var pressed? is Bool
    end

The part after `is` in the declaration of `Button` specifies its parent class. A child class inherits all of the state of its parent class. So here, `Button` will have fields for both `pressed?` and `label`.

When constructing a new instance of a class, its parent classes also need their constructors to be called so that inherited fields can be correctly initialized. To do this, the canonical initializer is extended to include a field for the parent class.

    :::magpie
    Button new(Widget: (label: "Play"), pressed?: false)

When the initializer for `Button` is called, it takes the value of the `Widget:` field and uses that as the argument to `Widget init(...)`. This way, child classes can invoke overridden parent class initializers, like so:

    :::magpie
    // Since there's just one field, don't require a record:
    def (this == Widget) init(label is String)
        this init(label: label)
    end

    // We can then call it through Button:
    Button new(Widget: "Play", pressed?: false)

If a parent class doesn't have any fields, or has initializers for all of them, you can omit it when constructing the child class. If the parent class has its own parent class, you may need to initialize it too:

    :::magpie
    defclass CheckBox is Button
        var checked? is Bool
    end

    CheckBox new(Button: (Widget: "45 RPM", pressed?: false),
            checked?: true)

That's a bit tedious, so you're encouraged to override the initializers for your class to "flatten" that out and hide the parent class initialization.

    :::magpie
    def (this == Button) init(label is String, pressed? is Bool)
        this init(Widget: label, pressed? pressed)
    end

    def (this == CheckBox) init(label is String, pressed? is Bool,
            checked? is Bool)
        // Use the init() for Button we just defined.
        this init(Button: (label, pressed?), checked?: checked?)
    end

    // Use the init() for CheckBox.
    CheckBox new("45 RPM", false, true)

You can consider canonical initializers to be "raw" initializers that you'll likely hide behind a simpler overridden one.

### Inherited Methods

If you call a [multimethod](multimethods.html) and pass in an instance of a child class, it will look through all of its methods to find a [pattern](patterns.html) that matches. A type pattern will match against an object of the given class, but it will also match objects of *child classes* of that class. In that way, methods defined using `is` patterns are automatically inherited by child classes.

    :::magpie
    def (this is Widget) display()
        print(this label)
    end

    val checkBox = CheckBox new("45 RPM", false, true)
    checkBox display() // Prints "45 RPM".

When multiple patterns match an object, type patterns on child classes take precedence over parent classes. This lets you *override* a method defined on a parent class.

    :::magpie
    def (this is CheckBox) display()
        val check = if this checked? then "[X] " else "[ ] "
        print(check + this label)
    end

    val checkBox = CheckBox new("45 RPM", false, true)
    checkBox display() // Prints "[X] 45 RPM".

Note that method inheritance like this only works for *type* patterns. Value patterns (i.e. `==` ones) do *not* match subclasses.

    :::magpie
    // Given a string like "Play|true", creates a new Button.
    def (this == Button) fromString(descriptor is String)
        val parts = descriptor split("|")
        this new Button(parts[0], parts[1] true?)
    end

    Button fromString("45 RPM|false")   // OK.
    CheckBox fromString("45 RPM|false") // ERROR: No method found.

This more or less follows other languages where "static" or "class" methods are not inherited, just "instance" ones.

### Multiple Inheritance

Unlike many newer languages, Magpie embraces multiple inheritance. A class is free to have as many parent classes as it wishes:

    :::magpie
    defclass Container
        val widgets is List
    end

    defclass GroupBox is Widget, Container
        var selected is Int
    end

Here, `GroupBox` inherits from both `Widget` and `Container`. This means it gets all of the fields of both of those parents (and their parents). In addition, methods specialized to either of those are valid for `GroupBox` objects too. When constructing an object, all of its parent classes must be initialized.

    :::magpie
    GroupBox new(
            Widget: "Group",
            Container: (widgets: []),
            selected: 0)

Here, we're passing fields for both `Widget:` and `Container:`.

Multiple inheritance can add considerable complexity to a language, which is why many shy away from it. Most of that complexity can be traced back to a single corner case: *inheriting from the same class twice*. For example:

    :::magpie
    defclass RadioButton is Button, Widget
    end

    val group = RadioButton new(
            Button: ("From Button", false),
            Widget: "From Widget")
    print(group label) // ???

Here, `RadioButton` inherits `Widget` along two paths: once from `Button`, and once from `Widget` directly. Both paths try to initialize the label, one using `"From Button"` and one using `"From Widget"`. How do we decide which one "wins"? Overriding methods have similar ambiguity problems.

To avoid these problems, Magpie has a simple rule: *a class may only inherit from some other class once, either directly or indirectly.* In other words, there may only be one path from a given child class to a given parent class. If you try to define a class like `RadioGroup` above, Magpie will [throw](error-handling.html) `ParentCollisionError` at you.

A side-effect of this rule is that Magpie doesn't have a "root" class like `Object` or `Any` in other languages. It doesn't need one. Root classes usually don't have state, and you can define methods that work on objects of any class (think `toString()` or `getHashCode()`) simply by defining methods that aren't specialized to any type.

^title Concurrency

**TODO**
^title Core Concepts

As much as possible, this guide is organized so that you can read it top to bottom (not that you *have* to read it like that, unless you've got an afternoon free). It tries to avoid referencing concepts or terms that haven't been fully introduced yet. 

That's a challenge, though, in something as self-referencing as a programming language. Magpie has a couple of key ideas that can't be understood in isolation: *[patterns](patterns.html)*, *[classes](classes.html)*, and *[multimethods](multimethods.html)*. Classes use patterns for fields and multimethods for behavior. Patterns match on classes and define method specializers. Multimethods are defined using patterns and specialized to classes.

These concepts are core to understanding the language, even though it's hard to separate them from each other. At some point you just have to jump on the carousel and follow it around. When you read these sections and get to a term that hasn't been explained yet, just be patient. By the time you get through all three it should be clear.

^title Are All Types First-Class?

In other words, can you have an object in Magpie that represents the type `Int |
Bool`?

Answer: **Yes.**

Things like generics will need to internally store their type parameters. For
example:

    :::magpie
    class List[E]
        items E[]
    end

That type parameter should be useful at the type level, for things like:

    :::magpie
    def List[E] add(item E)
        // ...
    end

But should also be directly available in the same way that you can do `typeof(T)`
in C#:

    :::magpie
    def List[E] displayItemType()
        print(E string)
    end
    
This is fine if you only instantiate generics with class type arguments. But
it's perfectly valid to also do:

    :::magpie
    var optionalInts = List[Int | Nothing] new
    
Which implies that `Int | Nothing` must itself resolve to a first-class object
in Magpie.

This is good because (as of 8/19) that's the current path the implementation is
taking. It just makes some stuff harder because type checking has to bounce
between Java and Magpie more than we'd like.

This is also good in that it follows the goal of making everything the interpreter
knows also available to Magpie.
^title Are Types in Java or Magpie?

For a while, I've been working on making Magpie's type system Turing complete
such that type annotations are themselves regular Magpie expressions. This makes
Magpie very flexible: users can define classes that represent "type-like" things
and methods that create and manipulate types. For example, you could create a
type where only objects whose class starts with "B" are in the type.

This simplifies things in that there is only a single language for expressions
and type annotations and also meshes nicely with first-class classes: a type
annotation like `Int` really just looks up the global variable `Int` which
contains the object representing the class of integers.

The downside is that it makes the line between what's in Java and what's in
Magpie very blurry. Type-checking becomes a complicated dance that bounces
between the two languages. Lots of really weird edge cases are possible, such as
type expressions that aren't pure!

I beat my head on this for a while. I eventually got it mostly working, but it
still felt dirty. After a while I realized there were three main paths I could
take:

## Option 1: Follow the [COLA](http://en.wikipedia.org/wiki/COLA_%28software_architecture%29) concept of making a tiny core and having the language implemented in terms of itself.

So Java just has a core for defining objects and sending messages. Decisions
like prototypes versus classes are made entirely in Magpie. The entire type
system lives in Magpie.

### Pros:

* Little switching between Magpie and Java.
* Very flexible: can do prototypes classes, etc. *simultaneously*.
* Academically interesting: not a lot of other languages like this.
* Small simple core.

### Cons:

* Lot of work.
* Lot of stuff to write in Magpie, which could be a pain.
* Feels mushy.
* Unlikely to end up a usable language, more an experiment or novelty.

## Option 2. Keep going down the current path of a Turing-complete type system but with classes baked into Java.

### Pros:

* Flexible extensible type system: can define new types in Magpie.
* May be able to use for dependent types or other out there concepts.
* Plays well with first-class classes.
* Turing-complete type system is interesting selling point.
* Have a single language for expressions and types, which is neat.
* Provides a natural path for generics: they are just expressions with type
  arguments that return new types.

### Cons:

* Messy: lots of switching between Java/Magpie.
* Hard to tell at what level something should be implemented.
* Locks some type system choices (classes, inheritance) into code.
* Hard to merge semantics between what a magpie-level type object declares about
  an object and what the actual java backend lets you do with it (for example,
  you could define a "type" that says all object with methods that are
  palindromes are in the type, but there's no way to make an object actually
  have those methods). Classes are still special.

## Option 3. Pull back from flexibility and move the type system fully into Java.

It will still have first-class classes, but things like or types `Int | Bool` and interfaces would be implemented in Java. No more type expressions. Instead, there'd be a distinct syntax for type annotations.

### Pros:

* Simple, conventional and practical.
* Don't have to switch back and forth between Magpie/Java when type-checking.
* Makes some type declaration syntax (function types) easier to parse.
* Most well-worn path to a usable language.

### Cons:

* Not as novel or flexible.
* Type system is baked into Java: users can't define their own type-like things.
* Need to figure out how generics work with this since they need to essentially
  create new types at check time.

Answer: **Option 2.**

Option 3 is ruled out because all types do in practices need to be first-class
anyway (see [this doc](are-all-types-first-class.html) for why). That means the
types will need to exist in Magpie, so also implementing them in Java would just
be redundant and confusing.

So that leaves options 1 and 2. I'm open to option 1, but I fear that's going
too far down the flexibility rabbit hole. It may make it hard/slow/cumbersome to
statically determine which objects meet which types since there's no core
built-in types to build on. I may investigate it further, but for now, I'll
stick with the middle ground. My suspicion is that, over time, it will gradually drift towards option 1.
^title Can All Generic Arguments Be Inferred?

Generics without inference is a real pain for many cases. Consider:

    :::magpie
    def max[T](a T, b T -> T)
        if a > b then a else b
    end

It's a real chore to have to call that like:

    :::magpie
    max[Int](2, 4)

The only reason we even need to make `max` generic is so that the return type
matches the arguments.

This is especially egregious in an optionally-typed language. At runtime, we're
doing work there to instantiate the function when there's no benefit since the
types are ignored at that point anyway.

One way around this is to infer type arguments from value arguments. So the
above becomes:

    :::magpie
    def max(a 'T, b 'T -> 'T)

With that, you just do:

    :::magpie
    max(2, 3)

At runtime, the types are all ignored and it just becomes a regular dynamic
function. At check time, we infer the return type from the types of the 
arguments. Everyone is happy.

## Explicit Type Arguments

But there's a problem. In static languages, there are plenty of places where you
call a generic method (or constructor) with no value arguments, *just* type
arguments. For example, consider a service locator that caches objects by their
type:

    :::csharp
    class Locator {
        T Locate<T>() {
            // look up instance of T in dictionary...
        }
    }

That would translate to something like this in Magpie:

    :::magpie
    class Locator
        def locate[T](-> T)
            // ...
        end
    end

There is no runtime argument to `locate`, so we can't infer the type. We could
hope to pass in the located type as a value parameter, like so:

    :::magpie
    class Locator
        def locate(type Type -> ???)
            // ...
        end
    end

But then the return type of the function won't be known at type-check time. Bad.
From this reasoning, I went ahead with Magpie's current generics system where
generic functions are special functions evaluated at check time, and there's no
inference. It works, but it's lame.

## A Curious Solution

But, if we could infer type arguments like in the `max` example, there may even
be a solution for our service locator one. What if it looked like this:

    :::magpie
    class Locator
        def locate(type Type['T] -> 'T)
            // ...
        end
    end

Let's say we call it like this:

    :::magpie
    var service = myLocator locate(MyService)

At runtime, of course, this works fine. What does the type-checker see?

It will see a call to `locate`, and know the type of its argument. In this case,
it will be `MyServiceClass`, the metaclass of the `MyService` class, and the 
type of the class object.

If we make each metaclass an instance of a generic class, whose type argument is 
the class that the metaclass is... meta-ing?... then the type-checker can
reconstruct back *down* to that class given the metaclass.

So the type-checker will see `MyServiceClass` where it expects `Type['T]`. It
asks that metaclass, "are you an instance of `Type['T']`, and if so, what is 
`T`?" and the metaclass should be able to give that back.

To make that work, we'll have to implement something like the `inferTypesFrom`
stuff I described in the [first generics design question](how-are-generic-functions-checked.html). But, now, given that, we
should be able to get rid of the old `[]`-style generic stuff completely. 
Inference for everything!


## The Problem

When you define DSL-like APIs, you often want to have some implicit context
that the various methods can operate on. In other OOP languages that don't
require an explicit `this.`, this state is often stuffed into the containing
class, like TestSuite in jUnit. That lets your DSL have "bare" method calls
that read nicely.

Magpie doesn't have any way to pass along implicit state like this. Even the
"receiver" isn't implicit. This makes it harder to make DSLs that aren't
verbose. For example, the old test suite code looks like:

    :::magpie
    specify("An 'and' expression") with
        it should("return the first non-true argument") with
            (0 and false) shouldEqual(0)
            (1 and 0) shouldEqual(0)
            (1 and 2 and 0) shouldEqual(0)
        end
    end

That `it` parameter exists just to pass along the current test context.

## The Solution: Dynamic Scope

What would be nice is a way to push some context on the callstack where later
functions can then access. The traditional answer here is dynamic scope. That
doesn't play nicely with threads or callback-style async, but fortunately,
Magpie uses neither of those! Given fibers which make it easy to spin up and
suspend callstacks, the callstack is the perfect place to stuff this.

## Strawman

Here's a rough proposal. If you declare a variable whose name starts with `$`,
this creates a *dynamically scoped* variable. When you *access* a variable
with a name that starts with `$`, the VM will walk up the *callstack* to find
its value, and not the enclosing lexical scopes.

(If it fails to find the variable, it throws an `UndefinedVarError`. This is
a necessary corner case since it is no longer possible to statically determine
if this error can occur.)

For example:

    :::magpie
    def foo()
        val $i = "foo"
        baz()
    end

    def bar()
        val $i = "bar"
        baz()
    end

    def baz()
        print($i)
    end

    foo()
    bar()
    baz()

This program will print "foo", then "bar", and then thrown an
`UndefinedVarError`. Using this, we could make a test DSL like:

    :::magpie
    specify("An 'and' expression") do
        should("return the first non-true argument") do
            (0 and false) shouldEqual(0)
            (1 and 0) shouldEqual(0)
            (1 and 2 and 0) shouldEqual(0)
        end
    end

(Note no more `it` argument.)

It could be implemented like:

    :::magpie
    def specify(desc, body)
        var $spec = desc
        body call
    end

    def should(desc, body)
        var $desc = desc
        body call
    end

    def (actual) shouldEqual(expected)
        if actual != expected then
            print($spec + $desc + "expected " + expected + " but got " + actual)
        end
    end

## Caution!

Dynamic scoping is rightfully scary and frowned upon. Any time a `$` variable
is accessed, it can fail at runtime. Also, it's no longer possible to tell what
state a method can modify since it could be internally using dynamically-scoped
variables (though closures have similar issues along the lexical axis).

Like any powerful tool, it should be used in careful moderation.

One intent behind having a sigil character for dynamically-scoped names is that
it makes them stand out in code.

^title How Are Bare Names Interpreted?

A bare name in code like `i` can be interpreted as either a variable in some surrounding scope, or as a getter on `this`. It could correctly be both of those at the same time, so it's important to know which takes priority and when.

I believe the expected behavior is:

    :::magpie
    var i = "global"
    print(i) // global
    defclass C
        var i = "getter"
    end

    do
        var i = "outer"
        def (this C) method() ->
            print(i) // getter
            var i = "local"
            print(i) // local
            do
                var i = "shadow"
                print(i) // shadow
            end
            print(i) // local
        end
    end

So local variables within the method take priority over getters, which take priority over variables declared in the method's closure. Lookup then is:

1.  Look in the current local scope.
2.  Walk up local scopes until we hit the top scope of the function body.
3.  Look on `this`.
4.  Look in the scope chain where the method is declared (its closure).
5.  If not found, throw an `UnknownNameError`.

That's fine for things with only a single level of nesting. Now consider:

    :::magpie
    var i = "global"
    defclass C
        var i = "getter"
    end

    def (this C) method1()
        var i1 = "1"
        def (this C) method2()
            var i2 = "2"
            def (this C) method3()
                var i3 = "3"
                print(i1) // "1"
                print(i2) // "2"
                print(i3) // "3"
                print(notfound)
            end
        end
    end

When we look up `notfound` here, it needs to:

1.  Look in the locals of `method3`.
2.  Look for a getter on `this` in `method3`.
3.  Look in the locals of `method2`.
4.  Look for a getter on `this` in `method2`.
5.  Look in the locals of `method1`.
6.  Look for a getter on `this` in `method1`.
7.  Look in the global scope.

So we need either a way to arbitrarily interleave lookup of variables and getters in the scope chain, or we need to restrict the scope in which methods can be defined (which is kind of lame).

This gets more confusing because getters themselves are defined in the scope chain. It's just that we may need to "find" them earlier when walking the scope chain. For example:

    :::magpie
    // 1
    defclass C
        var i = "getter"
    end
    // getter is defined here in scope chain

    do // 2
        var i = "inner"

        def (this C) method() // 3
            print(i)
        end
    end

Here we have three nested scopes (labelled `// 1`, `// 2`, `// 3`). The getter for `i` is defined in `1`, the outermost scope. There is a variable `i` declared in `2`. Inside `3`, we print `i`. The tricky bit is that it needs to find the getter first, so we need to give priority to the `i` in `1` over the nearer one in `2`. Confusing.

## Not Interleaved

Actually, the above isn't correct. When looking up a name, we never have to look at `this` in an outer method definition. At any point in code, there is only one `this`, and that's the one we need to consider. They don't cascade. So with:

    :::magpie
    def (this A) method1()
        def (this B) method2()
            def (this C) method3()
                print(foo)
            end
        end
    end

When we're looking up `foo`, all we need to consider are:

1.  The locals in `method3`.
2.  Methods specialized to `this` in `method3`.
3.  Variables in the closure of `method3`.

The `this` definitions in `method2` and `method1` never come into play.
^title How are Classes Declared?

Magpie's core system for defining classes is imperative and just uses regular message sends. But on top of that is a declarative sugar to make things cleaner.

Coming up with a good syntax for that is surprisingly hard. There are a number of different kinds of members users need to be able to define, and some corner cases where it's hard to distinguish them. Balancing that against terseness and minimizing keywords is tricky.

A complete sample that shows everything is:

    :::magpie
    class Example
        // define ctor
        this(x Int)
            doSomething()
        end
    
        // define instance field
        var foo Int = 123
        
        // define instance method
        def foo(arg Int -> Bool) = body
    
        // define instance getter
        get foo Int = 123
    
        // define instance setter
        set foo Int = print(it)
    
        // declare instance field
        var foo Int
    
        // declare instance method
        def foo(arg Int -> Bool)
    
        // declare instance getter
        get foo Int
    
        // declare instance setter
        set foo Int
        
        // define shared field
        shared var foo Int = 123
    
        // define shared method
        shared def foo(arg Int -> Bool) = body
    
        // define shared getter
        shared get foo Int = 123
    
        // define shared setter
        shared set foo Int = print(it)
    end
    
    interface Example
        // declare instance method
        def foo(arg Int -> Bool)
    
        // declare instance getter
        get foo Int
    
        // declare instance setter
        set foo Int
    end

## Why have separate keywords for fields and methods?

We need to be able to distinguish a method from a field of tuple or function type. Consider:

    :::magpie
    foo(a, b)

Is that a field "foo" whose type is a tuple of types "a" and "b", or a method that takes two dynamic arguments? Or:

    :::magpie
    foo(a -> b)

Is that a method that takes a dynamic argument and returns a value of type "b", or a field whose type is a function from "a" to "b"? To clarify this, we need some explicit keyword or keywords to distinguish methods from fields.

## Why have a keyword for methods?

If there are keywords for the other types of members, we could infer no keyword at all to mean method (since methods are likely the most common member). That would make things more terse. The downside is that it looks less consistent. Consider:

    :::magpie
    interface Type
        canAssignFrom(other Type -> Bool)
        getMemberType(name String -> Type | Nothing)
        getSetterType(name String -> Type | Nothing)
        get string String
        get type Type
        ==(other -> Bool)
        !=(other -> Bool)
    end

The getters look really out of place there. So, for now, we'll try keywords for everything and see how it goes. As a nice bonus, this means that we can support calling arbitrary methods inside a class body, since they are not ambiguous with method declaration. So we can make things like this work:

    :::magpie
    class Foo
        mixin(Bar) // call a method on Foo
    end

## Why "get" and "set"?

We need some keyword to distinguish getters and setters from regular methods or fields. Otherwise it becomes hard to parse without backtracking. "get" and "set" aren't great keywords: they're simple verbs that would ideally be usable by end users. But they're conveniently three letters which lines up nicely with "var" and "def", and I don't have any better ideas.

## Why "=" after the type in a method definition?

We need to be able to distinguish a method declaration (no body), from a method definition whose body is a block. Without some special syntax, in both cases there would be a newline immediately after the type declaration, so there would be no way to tell the two apart. Using `=` makes it clear that the definition follows.

Another option would be a specific `abstract` keyword or something for method declarations. That would be more terse for the common case (defined methods), but it would make interface definitions kind of cumbersome. Using `=` instead is consistent with how fields are declared/defined.





^title How are Generic Functions Checked?

Give a program like:

    :::magpie
    var foo[A](arg A)
        arg bar
    end

    foo(Baz new)

How and when do we verify that:

1. `bar` is a valid message on `arg`.
2. `Baz` is a valid argument type.
3. That the generic parameter `A` can be inferred from `arg`?

## First Question

For the first question, there are basically two solutions:

1. C++-style. A generic method cannot be checked on its own. Instead, it gets
   instantiated at each callsite with specific concrete types, and its only then
   that it gets checked.
   
2. C# with constraints style. A generic method's type parameters are annotated
   with "where" clauses that limit the type of type arguments. A method can be
   checked against its constrained types.

C++ is a mess, so let's try to go with C# style. A type parameter like the above
one with no constraint would default to `Object` (or `Dynamic`?), meaning the
above code won't check because `Object` doesn't have a method `bar`. To fix it,
you'd have to do:

    :::magpie
    var foo[A Baz](arg A)
        arg bar
    end

Where `Baz` is assumed to be some type that has a method `bar`. Type-checking a function now means:

1. Evaluate the type annotations of the static parameters.
2. In the function's type scope, bind those types to the static parameter names.
3. Evaluate the type annotations of the dynamic parameters in that scope.

That should conveniently alias `A` to `Baz`, so when we look up `A` later, we'll get the constrained type. Now we can type-check a method independent of its use. Win.

## Second Question

Now, the second question. How do we know that `Baz` is a valid (dynamic) argument type? Let's skip over inference now and just consider:

    foo[Baz](Baz new)

To check this, we just need to:
1. Evaluate the constraint on the static parameter (`Baz`).
2. Evaluate the static argument.
3. Test for compatibility.
4. In the function's type scope, bind the static argument value (not the
   constraint type) to the static parameter name (`A`).
5. Evaluate the type annotations of the dynamic parameters in that scope.

## Third Question

The last question, inferring static type arguments. That's going to get tricky. Consider a function like:

    :::magpie
    var foo[A, B, C](a List[A], b B | C, c (A, (B, C)))

We need to answer two questions:
1. Are all static type parameters present in the dynamic parameter's type signature? (In this case, they are.)
2. If so, given an evaluated type for the dynamic argument and the expression tree for its parameter type, what are the values of the static type parameters?

The first one we can do statically independent of the actual type semantics by just walking the parameter type tree. The second one is hard because it's another core capability every type-like object will need to support. So the question is, given:

    :::magpie
    var foo[A, B](a Dict[B, A])
    foo(Dict[String, Int] new)

Is there a way we can ask `Dict` to help us figure out what `A` and `B` are given `Dict[String, Int]`?

Here's one idea. We'll create a special tag type that just represents a placeholder for a type parameter, so that we can treat "A" and "B" as fake types. Given those, we can evaluate:

    :::magpie
    Dict[B, A] // which desugars to Dict call[B, A]

And get a type object back (an instantiated `Dict`) with our special type tags embedded in it. Then we evaluate `Dict[String, Int]`, the actual argument type. Now we've got two objects we can line up, so we do:

    :::magpie
    Dict[B, A] inferTypesFrom(typeMap, Dict[String, Int])

That will take some sort of map that maps parameter names like "A" to their inferred type. Every type will be expected to implement this. An implementation would look something like:

    :::magpie
    def Dict[K, V] inferTypesFrom(typeMap, other IType)
        let dict = other as(Dict) then
            let keyType = K as(TypeParam) then
                typeMap map(keyType name, dict keyType)
            else
                K inferTypesFrom(typeMap, dict keyType)
            end
            let valueType = V as(TypeParam) then
                typeMap map(valueType name, dict valueType)
            else
                V inferTypesFrom(typeMap, dict keyType)
            end
        end
    end

Note the recursive calls to `inferTypesFrom`. Those handle nested types like
`Dict[(Int, String), List[String]]`. The `typeMap` will have to handle collisions where a type parameter appears more than once and is bound to conflicting types like:

    :::magpie
    var foo[A](a A, b A)
    foo(1, true)

I think this would work. Handling or types and some other stuff may be a bit tricky. Figuring out how to reuse this code across all generic types will be a bit of work too.
^title How Are Methods Defined?

Should methods always be declared inside some `class` or `extend` block, or just
be declared individually using `def`? There are two basic syntaxes for adding a
method to a class. The conventional OOP style is:

    :::magpie
    class SomeClass
        def someMethod(arg Int ->)
            // ...
        end
    end

To add a method to an existing class, just replace `class` with `extend`. The
other option is Go style, where methods are just declared freestanding, like:

    :::magpie
    def SomeClass someMethod(arg Int ->)
        // ...
    end

## Advantages for class style:

* Minimizes duplication when defining a lot of methods. Avoids repeating the
  class name for each method. With generic methods where the class name is an
  expression like `Dictionary[Key, Value]`, this can be a bigger deal.
* Familiar to most users.
* If we allow interface declarations to define methods in the main declaration,
  allowing classes to do the same would be more consistent.
  
## Advantages for Go style:
* Avoids an unneeded level of indentation.
* Emphasizes the openness of classes. Encourages people to add methods to
  arbitrary classes by making it lightweight to do so.
* Highlights the separation between state (the core class definition) and
  methods.

Answer: **There are advantages both ways.** If you're adding a lot of methods to one class, then being able to do that in one block saves a lot of redundant typing, especially with long class names or generic classes:

    :::magpie
    def AbstractDictionary[Key, Value] blah...
    def AbstractDictionary[Key, Value] blah...
    def AbstractDictionary[Key, Value] blah...
    def AbstractDictionary[Key, Value] blah...

On the other hand, if you're adding a bunch of methods to different classes (i.e. avoiding the visitor pattern), the blocks are tedious:

    :::magpie
    extend AddExpr
        evaluate(-> Int) left + right
    end
    extend IntExpr
        evaluate(-> Int) value
    end
    ...

The best solution may be to just support both.

How Are Multimethods Compiled?

Given a set of method definitions with the same signature, how and when do we compile that to bytecode? Goals:

 1. We want to compile the method selection logic to regular bytecode. To tell
    if a given method matches, we don't want to have to walk the pattern tree
    in C++ like an interpreter.

 2. We want to select a method and bind its arguments at the same time. Testing
    a method and binding its arguments both involve destructuring, and we don't
    want to do that work twice.

 3. We want to detect pattern collisions at compile time.

 4. To make it possible to statically compile Magpie, it would be really nice if
    methods could be ordered without needing to first execute any Magpie code.

At a high level, the basic process for compiling a multimethod is.

 1. Get the set of methods. Since imports are static, this is pretty easy to do
    all at once during compile time (as long as we can ignore dynamic loading).

 2. Topologically sort them. The conditional logic for selecting a method needs
    to ensure that more specific methods are preferred over less specific ones.
    Specificity is a property of the multimethod itself (in that the actual
    runtime arguments passed to a method don't affect specificity).

 3. Compile them all to a single method whose body is (more or less) a match
    expression. Once we've ordered the methods, we can basically just compile
    it to a single method whose body is a pattern match with each methods as a
    case.

    This isn't *exactly* true because the jumping logic on match failure is a
    little different, and there's some special sauce needed to handle ambiguous
    methods, but it's roughly true. Given a set of methods and known
    specificity relationships between them, it should be doable to compile the
    whole thing to a chunk of pure bytecode.

The core nasty challenge is that step 2 here involves *executing* Magpie code.
Consider:

    def method(is Foo) ...
    def method(is Bar) ...

To order these methods, we need to know what `Foo` and `Bar` refer to: their
actual values. Those are expressions then that we need to evaluate. In this
case, we *could* say, that `is` patterns can only have class names on the right
and then we just treat class definitions specially so we can resolve them at
compile time.

But then consider:

    defclass Foo ...
    var Bar = if true then Foo
    def method(is Bar) ...

Ideally, this could work too, but that means allowing actual expressions for
type patterns. We could lose this flexibility and just say this use case isn't
supported, but then consider:

    defclass Color ...
    val red = Color new(...)
    val green = Color new(...)
    val blue = Color new(...)

    def method(== red) ...
    def method(== green) ...
    def method(== blue) ...

Here, we really do need to be able to support arbitrary expressions in value
patterns. We can't lose that without making value patterns basically useless.

Fortunately, we have an out here: value patterns don't have any relative
ordering, so we don't need to resolve their expressions to order methods that
use them. Win.

Except...

    val blue = Color new(...)
    val alsoBlue = blue

    def method(== blue) ...
    def method(== alsoBlue) ...

We really would still like to catch pattern collisions like this at compile
time.

^title How Are Syntax Extensions Imported?

There's a weird little problem with extending Magpie's syntax. Consider this
example:

    :::magpie
    // a.mag
    definfix $$ 80 (left, right) ...

    // b.mag
    import("a.mag")
    print(1 $$ 2)

The intent here is that `b` imports `a` in order to define a syntax extension
(here a custom operator) and then uses it later in the file.

The problem is that in the current implementation, this won't work at all. `b.mag` will be completely parsed before that `import("a.mag")` is *evaluated*. So by the time we've defined `$$`, it's too late. Suck.

(The base library dodges this by being implicitly imported and evaluated completely before any user script is run.)

Some possible solutions:

## Declarative Imports

One option is to make imports not regular imperative Magpie code. Instead, they would be more like a C preprocessor directive. These directives would be scraped, parsed and processed (i.e. by importing referenced files) in a separate pass. After that completes and the imports are evaluated, the file is parsed again for the regular expression contents.

### Pros

*   Makes the dependency graph completely declarative and easier for tools to
    parse and scrape. Might make things like build tools easier to make.
*   Conceptually simple and familiar.

### Cons

*   Creates a separate little language. That goes directly against Magpie's
    "one language for everything" philosophy.
*   Not as flexible as using regular Magpie code to import. This would rule out
    things like conditionally importing a file or other programmable control
    over the import process.

## Script Header

This is similar to the above but more open-ended. We could allow the user to
define a section of the file as the "header". Everything in the header is parsed and evaluated. Then, after that, the rest of the file is parsed and evaluated.

This fixes the limitations of a special import language. The downside is that it
feels a bit arbitrary. Why allow just one header? What if you want three sections?

## Incremental Parsing

That takes us to the next solution: parsing and evaluating the file incrementally. The top level of a file is a series of expressions (and, importantly is *not* parsed as a single expression). Given that, it should be
fairly straightforward to parse and evaluate it at a piece at a time. Each time
a top-level expression is fully parsed, it is returned and evaluated before
continuing the parse.

This restricts incremental parsing to just the top-level which I think makes simpler to understand and less likely to be a limitation when it comes to implementing a bytecode compiler or otherwise optimizing. It avoids the need to add any special language features or syntax. In theory, at least, it should just do the Right Thing from the user's perspective.


^title How Do We Handle Abstract Methods?

## Use Cases

1.  Extension methods in C#. We should be able to define a mixin for iterable
collections. So, if a class implements `iterate()`, you can mixin another class
that will give it `first`, `each()`, etc. That mixin class needs to implement
those in terms of `iterate()`, which it does *not* define. In the context of the
mixin, `iterate()` is an abstract member.

2.  "Base class"-style delegate fields. For example, Amaranth has a class like this:

        :::csharp
        abstract class ContentBase
        {
            public abstract string Name { get; }

            private Content content

            ContentBase(Content content)
            {
                this.content = content;
            }
        }

    In Magpie, this would be a delegate field since it has state, but we need
    to be able to support that abstract "Name" property.

## Requirements

1.  A user should be able to declare (as opposed to define) a member in a class.
    A declared member has a type but no implementation. When type-checking a
    class, it will be as if that member is there. This way, we can type-check a
    mixin or delegate class in the context of having the functionality it needs
    its host to provide.

2.  We should be able to statically ensure that all declared members are given
    an implementation before they can be accessed. A user shouldn't have to
    worry about getting an error at runtime that they tried to call a method
    that wasn't given a concrete implementation. If there's a member they need
    to implement, it should tell them this at check time.

3.  You should be able to "forward" abstract members. For example, class A may
    define an abstract member `foo`. Class B mixes in A but is also intended to
    be used as a mixin. It should be able to declare an abstract member `foo`
    that passes the buck onto the class that mixins *it* in.

5.  As always, we should accomplish this with a minimum of ceremony and
    complexity.

## Abstract Mixins

Mixins are the easy one. Since they are already stateless (non-constructible), all we really need to do is:

1.  Allow the user to declare members on a class.
2.  When we're checking a mixin, make sure that the parent class defines members
    that are compatible with all of the declared members on the mixin.
3.  If a class has abstract members, don't let it be constructed.

And that should be good. Rule 2 lets us implement abstract members. Rule 3 and the fact that mixins side-step construction completely make sure that you will only be able to refer to an abstract member from a context where a concrete implementation has been provided.

## Abstract Delegates

Now we come to the challenge. Lets say we wanted to implement the ContentBase use case in Magpie. The abstract delegate class would be:

    :::magpie
    class ContentBase
        def shared new(content Content -> ContentBase)
            construct(content: content)
        end

        get name String

        var content Content
    end

A class using it would be something like:

    :::magpie
    class WidgetContent
        def shared new(content ContentBase)
            construct(content: content)
        end

        delegate var content ContentBase
    end

So we'd construct one like:

    :::magpie
    var content = ContentBase new(Content new(...))
    var widget = WidgetContent new(content)

Magpie's construction style is from the leaves in: we create all of the fields
for a class and then instantiate the class using them. The problem here is the
first line. At that point, we're creating an instance of an *abstract* class. That violates our second requirement. There's nothing here preventing you from
doing:

    :::magpie
    var content = ContentBase new(Content new(...))
    content name // bad! calling abstract member!

Even if we don't forget to give it a parent object, there's an equivalent problem:

    :::magpie
    var content = ContentBase new(Content new(...))
    var widget = WidgetContent new(content)
    // fine so far...
    widget name // delegates to content through widget, still ok...
    widget content name // bad! not going through widget, so we won't be able
                        // to look up the name member on it

Ideas to resolve this:

### Don't allow abstract delegates

The simplest and harshest solution. Just don't allow abstract methods in delegates. In practice, I don't think this will work well. I've got lots of examples in Amaranth and other code of classes with both state and abstract members.

### Define two types for an abstract class

Given an abstract class like `ContentBase`, there will be *two* types: `ContentBase` and `AbstractContentBase`. The first is the "normal" type and can be used like you'd expect. The only objects that will have this type are places where the abstract members have been correctly implemented by a delegating parent object. So, in the above example, `WidgetContent` is a subtype of `ContentBase` because it has a delegate field of that class.

The `AbstractContentBase` type is then for variables of the abstract class that are not correctly accessed through a delegating parent that implements its abstract members. When you construct an instance of `ContentBase` the variable you get back is of type `AbstractContentBase`. If you access a delegate field on some object (like doing `widget content`) that's the type of variable you'll get back since you're stripping off the delegating parent.

The `Abstract__` type has no members on it. This ensures that you'll get a check error if you try to use an instance of an abstract type outside of its delegating content. It's basically a black hole. You can pass it around, but you can't do anything with it.

When a class has a delegate field (with abstract members), its `construct` method will take the *abstract* type for that field, not the normal one. So, in the above example, the type signature for `WidgetContent construct` is `content: AbstractContentBase`.

In other words, an instance of an abstract class has a special not-very-useful `AbstractFoo` type. But a class that has a delegate field of that class is correctly a subtype of the full-featured `Foo` type.

### Make the type useless

This is a refinement of the previous idea. Instead of defining two types, just
have one. But that type will be the equivalent of the `Abstract__` up there: it
will have no members. It's assignable to itself, but aside from that, there
isn't anything useful you can do with it. That just gives you enough to get it
into a delegate field for class that's using it, which is all you need.

This implies that abstract classes do not define any usable type. They provide
stateful behavior that can be mixed into another class, but don't define a type
that describes all classes that do that. For example:

    :::magpie
    class Named
        def sayName(->) print("Hi, I'm " + name + (if excited? then "!" else "."))
        get excited? Bool // abstract
        var name String
    end

    class Dave
        get excited? Bool = true
        delegate var name Named
    end

Given these, you can create a new `Dave` like this:

    :::magpie
    var dave = Dave new(name: Named new(name: "Dave"))

What you can't do is define functions that act on the `Named` interface alone:

    :::magpie
    def sayTwice(named Named ->)
        named sayName()
        named sayName()
    end

The problem is that the `Named` type has no members, not even `sayName`. That
ensures that you don't try to use a standalone instance of an abstract class,
but also prevents the above.

This seems like enough of a limitation that it probably isn't worth pursuing.

### Implicitly construct delegate fields

Consider the above example:

    :::magpie
    var dave = Dave new(name: Named new(name: "Dave"))

The key bit here, and the cause of our problems, is that we're passing in an
instance of `Named` to that constructor. But we can't safely create one of those
outside of the context of a parent class. So maybe the solution is to not do
that. Instead, the containing class's `construct` function will have the magic
required to promote a *record* for the delegate field to the real deal. The
above would become:

    :::magpie
    var dave = Dave new(name: (name: "Dave"))

And then, internally, it will take that `name: "Dave"` record and promote it to
the delegate field's type.

This neatly solves the problem of dangling delegates. Abstract classes simply
won't have constructors and cannot be created on their own. They can still be
used as types. We'll just have to modify the class subtyping rules to allow a
class A to be assignable to class B if A has a delegate field of type B.

### Don't worry about it

Remember, Magpie is optionally typed. It isn't perfectly sound. Maybe the
simplest solution is to not worry about it. You can instantiate an abstract
class just fine. If you try to use it, it'll do weird (but defined!) things when
it tries to call abstract members. Don't sweat it.


^title How Do Callable Fields Work?

In other words, how do we distinguish between a method that takes an argument,
and a method that doesn't take an argument but returns a callable object?

The scenario is this:

    :::magpie
    class Foo
        this() this items = Array of(123)
        bar() items(123)
    end

The body of `bar` method could be interpreted to mean two different things:

1. Invoke the `items` method, passing in `123`.
2. Look up the field `items` (which is done using a getter method that takes no
   argument) and then call `call` on it.

The second is the intended interpretation in this case. Unfortunately, a
strictly Io-style syntax cannot support that. (Io doesn't have callables. You
always invoke a named method. Getting an item from a list is `list at(123)`.)

The way Python and C# handle this is with properties. A property is *not* a
method, and the distinction is known at runtime. This means we can disambiguate
the two scenarios above like this:

    look up the member "items"
    if it's a property
        invoke the property (with no argument, of course)
        send a "call" message to the result, passing in the argument (123 here)
    else
        invoke the method
    end

Before, we tried to treat all zero-argument methods implicitly as properties.
Unfortunately, we'll have to make an interpreter-visible distinction so that it
can behave differently depending on whether or not a member is a property.

While having explicit support for properties feels a bit gross, it does make
some things more consistent. Before this, implicitly calling a callable did work
if it was in a local variable or a dynamic (not declared and hence wrapped in a
getter) field. That's because the interpreter knew it was looking at a local
variable or field and therefore it couldn't be a method invocation, so it would
implicitly add the call. Now it can apply the same logic to declared fields and
other getters.

On the user side, there are two questions:

1. How do I declare a property?
2. Which things should be zero-argument methods, and which should be properties?

Scala's answer to 2 is that functions with side-effects should have an explicit
`()` and others should not. Io assumes that all zero-argument functions should
omit the `()`. I lean towards that simply because it's shorter. Magpie is
different enough that user's shouldn't expect a `()`-less method to always be
"field-like".

So the answer to 2 is "all zero-argument methods should be properties". Which
lets us neatly answer 1 by automatically creating a property if the function has
no named parameters.

This lets us come full-circle and actually eliminate properties as something tangible the user needs to think about. Instead, we get back to our original scenario. The way we disambiguate it is:

    look up the method "items"
    if it has no named parameters
        invoke it with no argument
        send a "call" message to the result, passing in the argument (123 here)
    else
        invoke the method with the argument
    end

^title How Do Callable Fields Work with Multimethods?

Consider:

    :::magpie
    class Foo
        var bar = fn(i) print("field")
        def bar(i) print("method")
    end

    var foo = Foo new()
    foo bar(123)

The last line can be interpreted two ways:

1.  Look up `bar`, then invoke the result.
2.  Call the `bar()` method, passing in `123`.

Both are valid use cases, how can they be distinguished? In the current system, it would always be given the second interpretation. If the class is like:

    :::magpie
    class Foo
        var bar = fn(i) print("field")
    end

When you try to do:

    :::magpie
    Foo new() bar(123)

It will simply fail to find a method, since it's looking for one specialized to `(this Foo, i Int)` and all that exists is the field getter: `(this Foo)`. What to do?

## Option 1: No Callables

The Smalltalk/Io/Ruby solution is to not have functions. An expression like `foo bar(123)` always means "call the method `bar` passing in `123`" because there are no directly invocable objects. If `bar` was a field holding a callable, you'd have to do:

    :::magpie
    foo bar call(123)

This solves the problem, but it's kind of ugly. Multimethods are a step *towards* being more functional, so it seems weird for the syntax to step *back*.

## Option 2: Fallback Dispatch

Maybe we could just try both interpretations in order. So if you do:

    :::magpie
    foo bar(123)

First it will try to find a method specialized to `(this Foo, arg Int)`. If it finds that, good. If not, it then tries to find `(this Foo)`. If that succeeds, it then tries to immediately invoke the result passing in `123`.

That would work, I think, but it feels ugly.
^title How Do Fields Work?

An object is a bundle of state and a set of methods. Classes generally handle the "set of methods" part. How does state work? There are two common paths that I'll call "struct" and "scope". Javascript is the struct approach: an object's state is just public fields accessed from this:

    :::javascript
    // define some state:
    this.foo = bar;
    
    // access it:
    this.foo;

Smalltalk, Ruby and Finch take the "scope" approach: inside a method, variables with a certain name will be looked up in the object's dictionary:

    :::finch
    Obj :: method {
        // define some state
        _foo = bar
        
        // access it
        _foo
    }

Each has its pros and cons:

## The Struct Path

This encourages users to think of an object as a dictionary of named properties. Its state is implicitly public and open to easy external modification. Objects feel open and flat. It has this going for it:

*   Public-by-default fields make it easy to build ad-hoc objects and property 
    bags.
*   Easy to add or modify state outside of an object's methods.
*   Don't have to write getter/setter wrappers.
*   Lines up with the current implementation (as of 10/05/2010).
*   Conceptually unifies state and methods: state is always accessed through 
    methods.

## The Scope Path

This encourages users to think of state as fundamentally separate from methods and fully encapsulated within an object. Object's feel sealed and self-contained. It's good for:

*   Private-by-default fields make it easy to build safely encapsulated objects.
*   Conceptually unifies state and local variables: state is just a special kind 
    of variable.
*   Encourages a simple syntax for defining fields:
    
        :::magpie
        var _field = 123

## The Answer

Right now, I'm leaning towards the scope approach. One of the tedious parts of
Finch is that fields require explicit getters and setters. We could solve that
in a couple of ways. One way would be to get the existing field
declaration/definition support and have that create a field and matching getter
and setter too. It would be nice to allow readonly or writeonly variations too.

The other question this brings up is how is state type-checked? Beyond the basic limitation that variables cannot change type, I'm consider not doing any type-checking for fields. The type-checker at that point would essentially operate at the unit test level: it would check methods but you couldn't explicitly declare field types.

It might be interesting to try that and see how it feels.

^title How Do Multimethods Interact with Modules?

Consider:

    :::magpie
    module a
        def double(i Int) i * 2
    end

    module b
        def double(s String) s ~ s
    end

    module c
        import a
        import b

        double(1)
        double("s")
    end

Assuming that `import` means, "get all of the top-level identifiers in the given module and copy them into this one", then that code has a problem. Modules `a` and `b` each define multimethods bound to top-level variables `double`. When we hit `import b`, it will either have a name collision when it imports `double` again, or it will overwrite. In neither case will the code do the right thing.

This is a bummer since namespaced methods was the motivating factor for multimethods (i.e. not tied to class generic functions) to begin with. What's the solution?

## Option 1: Module-level Multimethods

One option would be to not make multimethods first-class. Right now, they're just objects bound to a variable. Named dispatch looks up the variable, finds a multimethod in it, and goes from there. This means that they're pretty opaque when it comes to things like `import`.

On the other hand, it means you can pass them around as objects. Except you actually can't because there's no syntax to just get one. If you have a multimethod stored in `foo`, then just doing `foo` won't get it. Instead, it will try to invoke it as a getter on the current (implicit) receiver: i.e. it calls `this foo`.

So, since they aren't very first-class like anyway, one option would be to make them explicitly not first class and more built into the language as a module-level construct. When you declare a method, it adds it to the current module. When you import it, it just merges it with any methods of the same name in the current module.

### What About Functions?

This makes them very different from functions, which are normal, lexically scoped first-class objects. It's clear that functions are still needed for things like `with` and higher-order functions like `map` and `filter`. Is it redundant or confusing to have both?

There's already some difference between a method and a function even in single-dispatch Magpie since `this` has different semantics between the two. This pushes them farther apart, but that may not be a bad thing.

### What About Local Multimethods?

One consequence of this is that there's no way to make a "local" multimethod. Regardless of where the `def` appears, they live at the module level. That covers 95% of the use cases, but is a limitation. At the very least, it will make the spec a little trickier since it wants to scope things as locally as possible.

This also feels like it goes against the grain of the language since pretty much everything else is lexically scoped: functions, classes, variables.

## Option 2: Merge on Import

Perhaps a more straightforward solution is to simply merge multimethods on import. If you import a named multimethod and there is already a multimethod with that name in the current module, just merge them.


^title How Do Multimethods Work?

There are a number of tricky challenges to getting multimethods working. They are:

## How Are Return Types Determined?

Different specialized methods should be able to return different types. That way, for example, a `+` method on numbers can return a number, while a `+` specialized to strings can return strings. Dynamically, that's easy. But the static checker needs to be able to determine this too.

This is actually fairly straightforward to solve. During type-checking, we'll statically determine the set of methods that *could* match, based on the known static types of the arguments. The return type of the method from the type-checker's perspective is then the union of those types. For example:

    :::magpie
    def double(n Int -> Int) n * 2
    def double(s String -> String) s ~ s

    var foo = double(123)

Here, the type-checker can determine that `foo` is an Int because the only method whose type is a subtype of the type of `123` is the Int one. A slightly more complex example:

### Omitting Covered Methods

To be as accurate as possible, it would be ideal if it was smart enough to not include the return type of methods that can be statically determined to be completely covered by another one:

    :::magpie
    def add(left Int, right Int -> Int) left + right
    def add(left Object, right Object -> String) left ~ right

    def foo = add(1, 2)

Here, it should know that `foo` is an Int because even though both methods could match, the first one covers the second.

## How Are the Methods Ordered?

Since methods can be defined pretty much anywhere in Magpie it's hard to figure out which order the specialized methods should be tested. CLOS handles this by prefering the most specialized methods first, but "most specialized" probably isn't well-defined in Magpie with interfaces.

One radical option is to just ditch interfaces and go with a more CLOS-like multiple inheritance of classes approach. I'm not crazy about the whole mixins/delegates system anyway, so that might be an improvement.

## How Do We Ensure At Least One Pattern Will Match?

One of the basic and most useful features of the static checker is catching errors like:

    def foo(i Int) ...
    foo("not int")

In the presence of multimethods testing that gets a little funkier. I think this case will actually be easy. All we do is the same logic to statically determine which cases *could* match. If the set is empty, then we report an error. That should cover cases like the above.

## How Do Abstract Methods Work?

One really nice feature of OOP languages is the ability to define abstract methods in base classes. The type-checker can then ensure that all derived classes implement that method.

Magpie accomplishes something similar with interfaces. If you try to pass a concrete type where an interface is expected, it will statically verify that the type satisfies the interface. We definitely do *not* want to lose the ability to say "Any type used in this context requires this capability."

There's two components to this. First, we need to be able to define abstract methods in base classes. Then the type checker must ensure that for all derived classes, there are specialized methods that completely cover that one. Determining total cover in multimethods may be a bit tricky, but I hope it's resolvable. (That feature is also needed to ignore the return type of completely covered methods.)

With that, we can generate static errors when a derived class doesn't implement all of the abstract methods it inherits.

The second piece is ensuring that classes that have abstract methods can't be constructed and passed around. Ensuring that Derived implements Base's abstract methods isn't very helpful if you could actually end up with an instance of just Base that you're trying to dispatch on.

Not sure how to handle that yet. The solution may just be, "don't do that" and generate an error at runtime on a failed match.

## How Do Interfaces Work?

A very common use case in Magpie and other OOP languages is to define a function
that takes an argument of any type that implements a certain interface. In other words, any object that has certain capabilities. Basing this on interfaces instead of base classes dodges the brittle base class problem. Magpie's current interface system makes it even more flexible since existing classes can retroactively implement new interfaces.

How does this translate to multimethods? For example:

    :::magpie
    def ~(left Stringable, right Stringable)
        String concat(left string, right string)
    end

The goal here is that this method can be called on any arguments that have a `string` getter, and that it should be a static error to try calling with an argument that doesn't.

Without interfaces, what is the type signature of that function?

One option would be the C++ solution. An "interface" becomes just a class with no state and some abstract methods. Classes that implement that interface would have to explicitly inherit from it. Then, the existing support for making sure abstract methods are covered would cover this too.

It would look something like:

    :::magpie
    class Stringable
    end

    def abstract string(arg Stringable -> String)

    Int extends(Stringable)

    def string(arg Int -> String) ...

## How Do Constructors Work?

CLOS doesn't really place much emphasis on constructors. When you define a class, you instantiate it by calling:

    :::lisp
    (make-instance 'my-class :slot1 "blah" :slot2 "boof")

So basically you specify the class and all of the slot values, much like `construct()` in Magpie. We can take that and make it nicer by having a class
define a `new` method that specializes the `new` generic function with the class being constructed, and a record of its fields. That would get us to what CLOS supports. If you want to define your own ctor, just create a different `new` method that specializes on the class and a different set of arguments, like so:

    :::magpie
    class Point
        var x Int
        var y Int
    end

    // The above gives us:
    Point new(x: 1, y: 2) // i.e. new(Point, (x: 1, y: 2))

    // If we want a different ctor, just do:
    def class method Point new() new(0, 0)

    Point new() // i.e. new(Point, ())

## How Do Chained Constructors Work?

The above handles classes with no inheritance (or at least no base classes that in turn require construction). What about ones that do?

The CLOS answer is to just union the fields together. If `Base` has field `a` and `Derived` has `b`, to instantiate a derived, you'd do this:

    :::magpie
    Derived new(a: "a", b: "b")

This is because CLOS doesn't emphasize encapsulating state, but I'm really not crazy about that, especially when it comes to private fields. A class should own its internal state and should be able to use its constructor as the interface for that.

One option would be to chain constructors like this:

    :::magpie
    class Base1
        var a
    end

    class Base2
        var d
    end

    class Derived : Base1, Base2
        var f
    end

    // By default, this defines:
    Derived new(Base1: (a: 123), Base2: (d: 234), f: 345 -> Derived)

    // If we want to use different ctors for base:
    def class method Base1 new(b Int, c Int -> Base1) new(b + c)
    def class method Base2 new(e String -> Base2) new(Int parse(e))

    // Now we can do:
    Derived new(Base1: (100, 23), Base2: "234", f: 345)

This is a little fishy though because constructors *create* objects instead of *initializing* them. So when we call the constructors for `Base1` and `Base2`, we'll create two objects and then, I guess, have to copy those fields over to the "real" one. That feels kind of gross. Ignoring that for now, though, the semantics for built-in `new` would be:

    obj = new empty object
    obj.class = the class
    for each property in arg record
        if property name is a base class name
            invoke new with the base class and the property's value
            get the resulting object and copy its fields to obj
        else if property name is a field on the class
            initialize the field with the property value
        end
    end

### Initialize Instead of Construct

Now that I think about it, we may be able to resolve the fishiness by making `new` just initialize `this` instead of returning a new one. In the above examples, all of the `new` methods return their class type, and the ultimate built-in `new` does too. Instead of that, we could replace `new` with `init`. That doesn't return anything. Instead, the expectation is that any `init` method will eventually bottom out on the built-in one.

The built-in `init`, like `new`, takes a record of field values and base class values. Now there is a single built-in `new` method. Its semantics are:

    create an empty object, _newObj
    call init(), passing in the argument passed to new()
    return _newObj

The built-in `init()` does:

    for each property in arg record
        if property name is a base class name
            invoke init() with the base class and the property's value
        else if property name is a field on the class
            initialize the field on _newObj with the property value
        end
    end

Problem solved, I think. This also cleans things up a bit. It always felt tedious to have explicitly declare the return type of `new()` to be the created class.

### What About Factories?

What intended nice feature of the existing `new()` semantics is that a constructor doesn't have to always create and return a new object. It can return a cached one or a subclass or pretty much anything. That's a nice feature to maintain.

I *think* we can support this with the above idea too. All you would need to do is specialize `new()` with a different argument type and you'll hit that method instead. If you want to swap out the "real" `new()` with one that takes the *same* argument type, well... we'll have to see if it's possible to replace a method.



^title How Do Operators Work?

In the current implementation, a binary operator is just a method call on the
left-hand argument. That's nice and simple, but doesn't actually work well in
practice:

*   You can do `"a" + 2` but not `2 + "a"`.
*   You can add a `|` operator to classes and other concrete type classes in
    order to create union types, but you can't add it to an interface, so 
    there's no way to do `Iterator | Nothing`. Ditto for `=>` and other type
    operators.
*   Every class that defines `==` has to manually mixin an implementation of
    `!=` based on it.

The more I think about it, the more lame it is. I think the core problem is that
we're baking in too many semantics. The language right now *defines* that 
operators are looked up in the method set of the left-hand argument and are
dispatched based on it. That's 1) too rigid and 2) honestly not the right
semantic for *any* operator.

There's a simple solution: just make operators functions instead of methods. So
an operator becomes a regular unbound function that take two arguments: the
left and right-hand side. For any given operator, the implementor of that
function can decide if any dispatch based on the arguments is appropriate. For
example, if we wanted to keep the current behavior for a certain operator, it
would be as easy as:

    :::magpie
    def ?!(left, right)
        left op?!(right)
    end

But if they *don't* want that behavior (which they actually don't), it can do
whatever it wants. For example:

    :::magpie
    def !=(left, right)
        (left == right) not
    end

Now we never have to mixin a `!=` operator. And:

    :::magpie
    def ++(left, right)
        concatenate(left string, right string)
    end

Now we have a symmetric string concatenation operator that works on all types.

The only downside is that operators sit in the global namespace (well not really
once actual namespaces are in). This means it gets trickier to define "local"
operators specific to a class. But my hunch is that those cases are rare and
when they do happen, it's easy to define a global one that just gives you that,
like the `?!` example above.

Because Magpie is mutable (at load time at least), you can always redefine an
operator function if the existing definition doesn't do what you want.

## Addendum

After implementing this, I've stumbled onto one other limitation of this 
approach: the type signature of the operator can now no longer vary based on the
argument type. With the previous approach, we could define `+` on Ints to return
and Int, and `+` on String to return a String. Now there's a single `+` function
with a single return type.

Generics may help here, but it will likely be an inevitable limitation of the
approach. In the specific example above, I fixed it by just making `+` no longer
used for string concatenation. Instead, `~` is used.





^title How Does Inheritance Work?

Inheritance can be a nice feature, but it adds a *lot* of complexity to the language. In particular, all of these have to be addressed:

### How are base classes initialized?

If a base class has fields that require values to be passed in to initialize them, the derived class needs some way to provide it. In Java, that's through `super()`, but it gets trickier in multiple inheritance where you need to identify *which* base class you're calling.

### What happens if there are multiple paths to the same base class?

In other words, the [Deadly Diamond](http://en.wikipedia.org/wiki/Deadly_Diamond_of_Death). Say there are classes like:

      A
     / \
    B   C
     \ /
      D

A has a `foo` method which both B and C override. If you have an instance of D and call `foo`, which one gets called?

### What happens if fields collide?

If A and B both have fields `foo` with different types, what happens when C tries to inherit from them both?

### Can you inherit without subtyping?

C++ has private inheritance, which is essentially composition with less explicit forwarding. It basically copies all of the methods from the base class to the derived one, but does *not* set up a subtype relation where the derived class can be used where the base is expected. Should that be supported?

### How are methods overridden?

Are all methods virtual? What happens if the types don't match?

## One Solution: No Inheritance

The simplest solution: no inheritance at all! If you want to share methods across classes, add the same method to multiple classes.

You can do "mixins" where you copy all of the methods from one class to another, but there's no implied long-term relationship between the two classes. (Actually, that's probably a terrible idea. It would be weird because if you add a method to a mixin class, classes that already had that mixin applied wouldn't get it. That means ordering of code would be important and fragile. Lame.)

To share code and state between classes, you use composition. Instead of inheriting from a base class, you have a field contain an instance of it. Then you forward method calls to it.

The downside, of course, is that inheritance is really handy. It makes it easy to share code between lots of classes. For some things, a subtype relation between concrete classes works well.

## Slightly Better: Explicit Delegation

A slightly looser approach is explicit delegation. We take the same approach that base classes are named fields on the derived class. This clears up a bunch of ambiguity and makes some problems trivial. For example, "calling the base class constructors" is really just initializing fields as usual.

Then on top of that, we add some simple support for automatic delegation. You can mark a field as a "delegate". Doing so means that if a member lookup fails on the object, it will cascade to trying to look it up on that delegate. If that fails, it proceeds to the next, etc. There needs to be a way to specify how delegates are ordered in case there are collisions where multiple delegates have a given member.

That gives you the simplicity of no inheritance with the convenience of not needing to manually forward. Code sharing is pretty easy to accomplish.

There are a couple of issues:

### Is there subtyping?

If an object delegates to one of its fields, does that imply a subtype relation? If so, we'll have to do some checking to make sure that overridden methods (i.e. a member a delegate has that the primary object also has) have compatible types.

It might be interesting to actually answer "no" to this: no subtyping between concrete classes, even when delegating. That removes issues with override compatibility, I think. This is sort of Go's model: if you want subtype polymorphism, you use interfaces.

### What is "this" in a delegated method?

This is the trickier question. If we pass a method on to a delegate, what is `this` within the body of that method? The implication is that it's just a straight forward, so `this` would be the object delegated to. For example:

    :::magpie
    class Foo
        def method() print(name)
        var name = "Foo"
    end

    class Bar
        delegate var foo = Foo new()
        var name = "Bar"
    end

    var bar = Bar new()
    bar method()

That would print "Foo" because when we invoke the delegated `method` method, it gets invoked on the object delegated to: `Foo`. This is good because it removes all of the confusion about overridden methods and other weird stuff. (For example, if `method()` was invoked with `this` set to the instance of `Bar`, we'd have to ensure that Bar's `name` getter was compatible with the one in Foo that `method()` was checked against. Each class is its own island.

The downside is that it means you can't mixin methods that act on the state of the original object. There's no way to define a method in Foo that can productively use state from Bar.

In theory that isn't much of a limitation: you should bundle the state with the methods that act on it. So Foo shouldn't need to act on Bar's state: that state should be pulled out of Bar and put into Foo. In practice, it's probably a pain.

## Bound Delegates

One way we could possible address that issue is by having the delegating object pass in itself to the delegate method as an additional parameter. Let's say in our original example, we really did want `method()` to print "Bar". That could be solved like this:

    :::magpie
    class Foo
        def method(receiver Bar) print(receiver name)
        var name = "Foo"
    end

    class Bar
        var foo = Foo new()
        var name = "Bar"

        def method()
            // Explicitly forward.
            foo method(this)
        end
    end

    var bar = Bar new()
    bar method()

The question now is how can we automate this using delegates? Can we make this
work:

    :::magpie
    class Foo
        def method(receiver Bar) print(receiver name)
        var name = "Foo"
    end

    class Bar
        delegate var foo = Foo new()
        var name = "Bar"
    end

    var bar = Bar new()
    bar method() // calls bar foo method(bar)

One tricky part is that member lookup is distinct from invokation. That means
we need to bind the receiver argument passed to the delegated method *before*
that method gets invoked. For example, given the above, this:

    :::magpie
    var bar = Bar new()
    var m = bar method

For this to work as expected, `m` here needs to be a reference to Foo's `method` where the argument has already been bound to `bar`. So it looks like we'll need something like currying and partial application. Consider:

    :::magpie
    class Foo
        def greet(receiver Bar) fn (name String)
            print(receiver name + " greets " + name)
        end
    end

    class Bar
        var name = "Bar"
        delegate var foo = Foo new()
    end

    var bar = Bar new()
    bar greet("Bob") // prints "Bar greets Bob"

In this way, resolving a delegated method is:

1. Look for a method with the right name on the delegated object.
2. If found, *immediately invoke it, passing in the delegating object*.
3. Return the result of that.

This is a little fishy because it means *all* delegated methods need to be curried like this, which is cumbersome. Any class will have to be designed to be used as a delegate or not, and can't easily do double-duty.

What this gives us is that inside the delegated method, we have access to all of the state we want: `this` will be the delegate object so you can get to its state, and we'll define a variable in the surrounding closure whose value is the original receiver.

That does raise the question of what happens with indirect delegation. If Foo delegates to Bar which delegates to Bang, we'll have a reference to Bang (`this`) and either Foo or Bar (the closure), but not both. Is that OK? Which should it be? If it's Foo, we won't know how to type-check the delegate method.





^title How Static is the Top Level of a Module?

Languages basically fall into one of two buckets:

1.  Languages where the top level of a file is pure definitions: types and
    functions. This includes, C, C++, Java, C#, and Dart. With these, the
    program's definitions are "timeless": the order that they appear in the
    text doesn't matter or affect anything. This makes cyclic dependencies and
    mututal recursion simple because you can handle all definitions "all at
    once".

2.  Languages where the top level of a file is a series of imperative
    statements or expressions. This includes most scripting languages like
    Scheme, Ruby, Python, JavaScript, etc. With these, "definitions" are just
    regular imperative code that is executed top-to-bottom like other stuff.

    These languages have to do extra work to enable mutual recursion: Scheme
    treats top-level definitions like a letrec, JavaScript has hoisting, and I
    think Ruby and Python just late bind everything at the top level.

I'll call these buckets "static" and "dynamic" because in the first bucket, you
can figure out everything a program defines statically without executing any
code. I need to decide which bucket Magpie is in. The interpreter is currently
in the dynamic bucket, but I don't know if that's ideal.

## Static pros:

*  It makes static whole program compilation much simpler: the compiler doesn't
   need to be able to evaluate code.

*  Mutual recursion works "naturally".

*  Cyclic dependencies between modules are simpler to handle.

*  It makes it easier to compile a multimethod (and all of its methods) to
   bytecode all at once.

*  It's more tool-friendly: it's simpler to build an IDE that statically
   understands a program's types.

*  It isn't overly flexible. It usually only allows a subset of what a dynamic
   language would allow. This means you aren't painting yourself into a corner:
   if you start with a subset, you can always expand that later, but you can't
   take stuff away.

## Dynamic pros:

*  It lets you have imperative code at the top level, which is nice for simple
   scripts: no special `main()` entrypoint.

*  It lets patterns contain expressions without much trouble. Expression-like
   things appear in a bunch of places in definitions: superclasses, method
   patterns, and field patterns.

*  It's simpler to implement (I think). Since expression-like things often
   appear in definitions, most static languages end up with a sublanguage that
   can be executed at "compile time": const expressions in Dart, etc. Having to
   define and implement that sublanguage is more work. If you just do
   everything dynamically, you only do one language.

*  It's more flexible. You can do things like have arbitrary expressions in
   method patterns without too much trouble.

## What should Magpie do?

I'm leaning towards the dynamic side, for a bunch of reasons:

*   Magpie is dynamically typed, so it feels like a more natural fit. Magpie is
    spiritually closer to Ruby, Io, and Scheme than Java or C#.

*   Top-level variables look like local variables, so I think users will expect
    them to evaluated top-down in a program.

*   We want to support imperative code at the top-level of a program. It feels
    a bit strange to have that but have other definitions not be imperative.

*   At some point, we may want to support nested class and methods inside local
    scopes (much like how Scheme allows `define` inside a `begin` block). Since
    that will be in the middle of imperative code, it seems more consistent for
    the top level to feel dynamic too.

*   The tooling pros for something more static are likely moot for Magpie since
    there is no Magpie IDE. I think it's easier to get people excited about a
    hobby language that can do fun dynamic stuff now, than one that may be able
    to be tooled better later.

## Given that, what are the semantics of top-level code?

Here's some constraints:

1.  Definitions should be executed in the order in which they appear in a
    module. Things like `var` initializers can have visible side-effects, so
    the order matters.

2.  Mutual recursion should work. Of course.

3.  Cyclic module dependencies should be allowed, at least in some cases. Given
    type patterns, it's entirely likely for two modules to refer to each other.

4.  Method pattern collisions should be detected as early as possible. We can
    relax this, but the earlier the better here.

Some motivating examples:

### The order of `var` expressions matters:

    var a = 0
    var b = a = a + 1
    var c = a = a + 1

### The order of `var` expressions matters, not because of assignment:

    var a = writeSomeFile()
    var b = readThatFile()

### The order between `defclass` and `var` matters:

    var foo = "not base"
    defclass Base
    end
    var bar = foo = Base
    defclass Derived is foo
    end

### The order between `def` and `var` matters:

    var foo = "one"
    def bar(== foo) "1"
    var bar = foo = "two"
    def bar(== foo) "2"

### The order between `def` and `var` matters (2):

    def bar(any) "any"
    var foo = bar(1) // "any"
    def bar(1) "one"
    var baz = bar(1) // "one"

### A safe cyclic dependency:

    // a.mag
    import b

    defclass A
    end

    def (a is A) collideWith(b is B) ...

    // b.mag
    import a

    defclass B
    end

    def (b is B) collideWith(a is A) ...

### An unsafe cyclic dependency:

    // a.mag
    import b
    var a = b

    // b.mag
    import a
    var b = a

### Something nasty

    // a.mag
    import b

    defclass A
    end

    def foo(== B) A
    def (a == foo(B)) collideWith(b is B) ...

    // b.mag
    import a

    defclass B
    end

    def (b is B) collideWith(a is A) ...

## Temporal dependencies

The key idea is separating out regular dependencies and *temporal ones*. A regular dependency is just one module importing another. It means that, by the time a method in that module is called, the other one needs to have its top-level definitions available.

A temporal dependency is a stricter requirement: if module A has a temporal dependency on B then module B's top level code must be executed before A's.

You can have circular dependencies, but you cannot have circular *temporal* dependencies.

If we can make enough things *not* induce a temporal dependency, then cyclic imports will work fine. These should induce a temporal dependency from A to B:

*   If a `var` initializer in A refers to a variable or class in B.
*   If a superclass expression in A refers to a variable or class in B.

These should *not*:

*   If a method pattern in A refers to a variable or class in B.
*   If a field pattern in A refers to a variable or class in B.

The trick is squaring the last two with the fact that method patterns may contain expressions with visible side effects.

**TODO: Figure out how we can make this work.**

Ideas:

* Does only allowing name expressions whose variables are single-assignment help?

## A strawman for how the top level code is compiled

Traverse all imports to build up the full set of needed modules. Cyclic dependencies are allowed: this is just walking the graph.

For each module, forward declare all of its methods. In other words, add a multimethod to the global pool with the method's name, but don't actually add any concrete methods. This is just to detect calls to completely unknown methods at compile time.

For each module, get all of the variables it defines: all of the `var` and `defclass` top-level expressions. With this, for any given name in a given module, we can tell where it came from: either in this module or in one of its imports.

This should give us enough information to determine temporal dependencies between modules. Do that and then topologically sort that so that a module is always sorted after its temporal dependencies. If there is a cycle, report an error and stop.

Otherwise, execute the modules in the resulting order.

^title Interfaces or Abstract Classes?

Instead of having interfaces, C++ just has classes but you can define a class where all of its methods are abstract. With multiple inheritance, a C++ class can effectively implement multiple interfaces. Should Magpie have abstract methods? Does it need interfaces at all?

## Advantages for interfaces:

* Popular and familiar.
* Multiple inheritance is complex. Have to figure out how methods are looked up,
  how collisions are dealt with, how constructors are invoked, etc.
* Explicit. Interfaces cannot have implementation.

## Advantages for abstract classes:

* Much more flexible. An abstract class can have some concrete methods.
* Just one kind of construct: the class. Of course, multiple inheritance adds
  complexity to offset that simplicity.
* Multiple inheritance is powerful and useful in its own right.
* Magpie's dynamic object-is-a-dictionary underlying system should simplify some
  of the problems with multiple inheritance that C++ has.

Answer: **It Should Have Interfaces.**

Unlike classes, interfaces in Magpie allow implicit compatibility: a concrete type that has matching methods is compatible with the interface automatically. That allows a measure of duck typing, but it's *not* something I think all classes should allow. I don't think arbitrary concrete classes should be implicitly compatible based just on method compatibility.

This doesn't necessarily rule out abstract classes or methods too: they serve a different purpose.
^title What Conversions Are Needed?

In other words, what kinds of type-casts and conversions does Magpie need?

First, we'll need to clarify some terms. A "cast" is a procedure that changes the type of an object as seen by the type-checker. No runtime transformation is involved. A "conversion" is a procedure that actually produces a new object. 

Magpie doesn't have anything like the conversions of a static language. Things that do conversion are just regular methods with distinct names like "parse" (convert a string to some other form).

So, casts. What kinds of casts does Magpie need to support, and what do they look like? Before we get into use cases, there's one important point to keep in mind:

## Static evaluation

We need to be able to cast to any type, not just simple named ones like classes
and interfaces. That means casting operations need to accept full type
expressions that are evaluated at type-check time. That, unfortunately, means we
*can't* make casts just be methods on types, because the type-checker would have
a very hard time being smart enough to understand that. Consider:

    :::magpie
    var a = Foo cast(bar)

The intent here is that a will hold a value `bar`, statically typed to be `Foo`. We can do this by simply defining the return type of `Foo cast()` to be `Foo`. That's easy. Now what about this:

    :::magpie
    var a = (Foo | Bar) cast(bar)

The type-checker will look at `Foo`, and find its `|` method. From there it will get the return type of that and look up the `cast` method on that type. For this to work correctly then, the static type of `Foo |()` would need to evaluate the argument *value* passed to it. No dice.

This implies that casting operations, at least ones general enough to apply to arbitrary type expressions (which include or types, arrays, generics, etc.), will need to use static arguments (see [Where Do Type Expressions Appear?](where-do-type-expressions-appear.html]).

## Use cases

Back to the actual use cases for casting. There are a few use cases I can think of:

### 1. An upcast

This widens the inferred type of an expression. By nature it will always
succeed. The main use case for this is since we don't allow variables to change
type (which is necessary to address another issue), it may be important to have
a variable's type be a supertype of what's directly inferred from its
initializer. For example:

    :::magpie
    var a = 123
    a = "hi" // error

But if we could widen `a`'s type at the point of initialization to allow
`String`s, that would be fine:

    :::magpie
    var a = 123 upcast[Int | String]
    a = "hi" // ok now, no type change

If widening variable types is the only use case for upcasts, we could consider rolling this into variable declaration syntax:

    :::magpie
    var a Int | String = 123

There is at least one other use case, though: field initializers. For now, let's leave off any special syntax since this should hopefully not be needed frequently anyway.

### 2. An unsafe cast

In the implementation of certain low-level type-related methods, or in other weird places, you may just need to straight up lie to the type-checker. For example, if you've deserialized an object and are sure that it does match a certain type, it's valid to just do an unsafe cast to tell the type-checker what you already know.

The syntax for this should highlight its unsafety. Something like:

    :::magpie
    var a = foo unsafeCast![Bar]

### 3. An asserted downcast

This is the common case where you're downcasting an object and you're quite certain the cast will succeed. Although I hope to minimize places where you need this, there's still cases where you get an `Object` but you know it's *really* a `Foo`.

The desired behavior is "check the type and if it isn't what I expect, blow up". More specifically, it will likely throw an exception. This is what doing a cast in a C# or Java does. In Magpie:

    :::magpie
    var a = someObj cast[Foo | Bar]

### 4. A potential downcast

Finally, the most common case: a downcast where you're not sure if it will
succeed or not. The desired behavior is "if it's this type, do this". More
specifically, it will return a value whose type is the desired type or
`Nothing`. At runtime, it will do the type test and return the original value on
success and nothing on failure. This plays nicely with `let`:

    :::magpie
    let b = a as[Foo] then
        ...
    end

### 5. A Duck-typed cast

There's one other use case I've thought of. In situations like mocking or testing, it's sometimes nice to be able to pass in an object as some type when the actual object is an unrelated type. `as` and `cast` will use nominal rules for compatibility (i.e. the object must be in the class hierarchy to succeed). 

For mocking, it would be nice to have looser structural compatibility. This basically lets you duck type any type and takes advantage of Magpie's dynamic core. We'll call this "masquerading". An object of one concrete type can masquerade as another unrelated type as long as its methods are compatible. It looks like:

    :::magpie
    var a = someObj masqueradeAs[Foo] // returns Foo | Nothing
    var b = someObj masqueradeCast[Foo] // returns Foo

^title What is a Multimethod's Identity?

The key question with multimethods is one of identity. A multimethod is a collection of methods, but when should two piles of identically-named methods be a single method and when should they be separate?

Other ways to phrase the question:

1. When do two `def`s with the same name collide and when do they merge?
2. When do two `import`s of methods with the same name collide, and when do they merge?
3. When a method is defined in one module, which other modules see that change?

## Current Implementation

The current implementation works like this:

Imagine the `import` graph of a set of modules. If module `a` imports `b` then there's a *directed* edge from `a` to `b`. Two methods are part of the same multimethod if there is a path from one to the other, or if they each have a path to a third shared method.

For example:

           .----------.
           | // a.mag |
           | def m1() |
           '----------'
            /        \
    .----------. .----------.
    | // b.mag | | // c.mag |
    | import a | | import a |
    | def m1() | | def m1() |
    | def m2() | | def m2() |
    '----------' '----------'

Here, there is only a single `m1` method across all three modules, but `b` and `c` each have their own `m2`. Note that if an `m2` were later added to `a`, then all three would collapse into a single multimethod.

## Use Cases and Problems

There are a number of relevant use cases:

### Overloading

This should not be an error:

    :::magpie
    def method(n Int) ...
    def method(s String) ...

But this should:

    :::magpie
    def method(n Int) ...
    def method(s Int) ...

### Unrelated Methods

Given this:

    :::magpie
    // a.mag
    def method(n Int) ...

    // b.mag
    def method(n Int) ...

As long as those two modules are never both imported unqualified by another module, the above should be fine and produce no error. Those methods should be oblivious to each other.

### Overriding

    :::magpie
    // a.mag
    def method(any) ...

    def callIt(arg) method(any)

    // b.mag
    import a

    def method(n Int) "int"
    callIt(123) // should return "int"

Here module `a` defines a multimethod `method`. Module `b` refines it. The important part is `callIt()`. It exists only in module `a` and isn't aware of module `b` at all. But when it's called, it *should* still successfully find the more specific method defined in `b`.

The specific case where this arose is:

    :::magpie
    // core.mag
    def (left Comparable) < (right Comparable)
        left compareTo(right) == -1
    end

    // spec.mag
    defclass TestComparable
        // ...
    end

    def (left TestComparable) compareTo(right TestComparable) ...

    var test = TestComparable new()
    test < test

The last line calls `<` which in turn calls `compareTo` from `core.mag`. But since `core.mag` didn't know about `TestComparable` at all, it never saw that specialization in `spec.mag`.

The fix was to import entire multimethods on `import`. So when `spec.mag` imported `core.mag` it got a reference to the `compareTo` multimethod&mdash; the actual same object that the `core.mag` module was referencing. When we defined `compareTo` on `TestComparable`, that method went into that same multimethod object, so `core.mag` was later able to see it.

### Colliding Getters

Every field on a class has a corresponding getter, which is just a multimethod. Given that, consider:

    :::magpie
    defclass Person
        var name String
    end

    defclass Pet
        var name String
    end

In the current implementation, this code in a single module will implicitly create a single `name` multimethod with specializations for `Person` and `Pet`, so it works as expected. Now consider:

    :::magpie
    // a.mag
    defclass Person
        var name String
    end

    // b.mag
    defclass Pet
        var name String
    end

    // c.mag
    import a
    import b

Those imports will collide when they both try to import distinct and unrelated `name` multimethods. One possible solution is to have those imports merge and create a single `name` multimethod. As long as none of the specializations collide (which they don't here), that would be fine.

But now consider the previous overriding use case. Consider:

    :::magpie
    // a.mag
    defclass Person
        var name String
    end

    // b.mag
    defclass Pet
        var name String
    end

    // c.mag
    import a
    import b

    def (_ Int) name ...

Which multimethod do we define that last `name` in? The one from `a` or `b`, or both?

Another example of the problem:

    :::magpie
    // a.mag
    def method(s String) "string"
    def callFromA(arg) method(arg)

    // b.mag
    def method(b Bool) "bool"
    def callFromB(arg) method(arg)

    // c.mag
    import a
    import b

    def method(n Int) "int"

    method(true) // should be "bool"
    callFromA(123) // "int"?
    callFromB("str") // "string"?

Maybe the way to phrase the question is: are methods lexically scoped or dynamically scoped? This last example implies a certain amount of dynamic scoping: `callFromA()` should have access to the `method` methods defined where `callFromA()` is being *called*. But that kind of seems like crazy talk.

### Chained Imports

Imports are not and should not be transitive. If I import `a` which imports `b`, I don't get everything in `b` imported into my module, just the stuff from `a`. If we were to try to dynamically scope methods, though, that would break it. Consider:

    :::magpie
    // a.mag
    def aMethod() "a"

    // b.mag
    import a

    def bMethod() aMethod()

    // c.mag
    import b

    bMethod() // should return "a"

When we call `bMethod()`, we can look it up in module `c` because it's been imported. But when that in turn looks up `aMethod()`, we can't look that up in `c`, because `aMethod()` hasn't been imported into it.

## Solutions

### No Spanning Across Modules

The simplest solution is that multimethods are never shared across modules. Instead, each module has its own multimethod for a given name. When you import, the methods are imported individually and piled into that collection. That addresses overloading, colliding getters, and unrelated methods. It's also concurrency friendly (since defining a method in one module doesn't affect others.

It breaks overriding. As far as I can tell, that's the only real problem with this, though that's certainly a valid one.

    :::magpie
    // core.mag
    def (left Comparable) < (right Comparable)
        left compareTo(right) == -1
    end

    // spec.mag
    defclass TestComparable
        // ...
    end

    def (left TestComparable) compareTo(right TestComparable) ...

    var test = TestComparable new()
    test < test


### Global Multimethods

The interpreter keeps a global pool of multimethods. Any method defined with a given name in any package becomes part of the same multimethod.

If you haven't defined a method with a given name, or imported it, you won't see that name at all, but if you have, you see the same one as every other module.

This solution is pretty simple, and addresses every use case lists above except for unrelated methods. It also doesn't allow lexically-scoped multimethods, but it could be that this "global pool" rule only applies to top-level multimethods or something.

But, of course, unrelated methods were one of the main motivations for multimethods in the first place.

### Current Solution

The current solution works pretty well. When you import a multimethod, you
import the exact same object, so when you add new methods, the original module can see them too. That addresses overriding while still allowing unrelated methods.

The only real problem with it is colliding getters. The CLOS solution is to just rename:

    :::magpie
    // a.mag
    defclass Person
        var name String
    end

    // b.mag
    defclass Pet
        var name String
    end

    // c.mag
    import a = a
    import b = b

    Person new("Bob") a.name
    Pet new("Ginny") b.name

That's perfectly valid for most methods. It just feels a bit weird to have to do it for getters. One angle to look at it is, "if two classes have the same field, should you be able to treat them generically?" Consider:

    :::magpie
    defclass Person
        var name String
    end

    defclass Pet
        var name String
    end

    def sayName(who) print(who name)

Should we expect `sayName()` to work with both people and pets? If the answer is yes, then renaming is wrong. If it's no, then it's reasonable. If you *should* be able to act on those classes generically, then one solution is:

    :::magpie
    defclass Named
        var name String
    end

    defclass Person : Named
    end

    defclass Pet : Named
    end

    def sayName(who Named) print(who name)

That's probably the Right Thing, and not that this also fixes the colliding getter problem. Even if `Person` and `Pet` are defined in different modules, they will both be importing the one that defines `Named` so they'll use the same multimethod for `name`.

So maybe the current system is the best we can do.
^title What Is the Type of a Generic?

Consider this function:

    var a[T](arg T ->)
   
Normally, the type of a function is an instance of `FunctionType`. It has fields for the declared parameter and return types. Both fields are expected to contain types. `FunctionType` is itself a type: it implements `canAssignFrom()` and `getMethodType()`.

The problem is that a function type that has a static parameter isn't the same as a regular function type. `FunctionType` implements `getMethodType()` to handle the param and return type for `call`, which is how you invoke a function. A generic function can't do that since it doesn't know the concrete types `call` expects.

Instead, a `GenericFunctionType` stores thunks for the parameter and return types. Those thunks need to be evaluated *after* a static argument is applied before you can get the type of the object's `call` method. So maybe there is a two-stage process: A generic function supports a single operation: "instantiate" that takes the static arguments. That returns a concrete function object with concrete parameter and return types.

That should also simplify evaluation. We're essentially currying the static argument, so we don't have to pass it around everywhere in addition to the dynamic argument. Instead, the static argument is applied which returns a function where the static argument is bound in its closure.

For example:

    :::magpie
    var printAny[T](arg T ->) print(arg)
    var t1 = printAny type
    // t1 will be GenericFunctionType("T", (fn() T), (fn() Nothing))

    // this:
    var printInt = printAny[Int]
    // the [Int] part is a special instantiate expression which is its own
    // ast node since it's more special than a regular message

    var t2 = printInt type
    // t2 will be FunctionType(Int, Nothing)

What we need are static function literals. They are just like regular function literals, except that they are *evaluated* at check-time instead of being checked. Its runtime semantics are identical to a regular function:

    :::magpie
    var a = staticfn(T) (fn(t T) print(t))
    var b = a[Int] // b = fn(t Int) print(t)
    b(123) // prints 123

The only difference is how the checker handles them. When a static function is checked, the checker does not evaluate the type of its body. (It can't: the body's type may have annotations which refer to the static parameters.) Instead, it stores the entire body as an expression, and the type of the static function literal becomes a special "StaticFunction" type that contains the static parameter names and the body.

    :::magpie
    var a = staticfn(T) (fn(t T) print(t))
    // a's type is StaticFn("T", (fn() fn(t T) print(t) ))

The type-checker then handles instantiating a static function "specially". Given:

    :::magpie
    var b = a[Int] // b = fn(t Int) print(t)
    
The type-checker will:

1. *Evaluate* the argument to instantiate (not evaluate it's type). So it 
   evaluates `Int` and gets the Int type object.
2. Create a static scope and bind the static type parameter name (`T`) to the
   evaluated argument `Int`.
3. Type-check the body in that scope so that type annotations within it can
   refer to the instantiated static arguments.
4. Return the type of the body.

^title Where Do Type Expressions Appear?

Answer:

1. After a param name in a function decl.
2. After `->` in a function decl.
3. In a field type decl.
4. In a cast expression.

These are different from just an expression evaluated at runtime on objects that happen to be types. These are cases where the type expression needs to be evaluated at type-check time because they affect the type-checking process.

## Q: Are there other cases where we want to define expressions that will be evaluated at type-check time?

A: *Yes:* type arguments to generic methods. They need to be evaluated at type-check time so that they can statically affect the parameter and return types of the method. Passing the type as a regular value parameter would work at runtime, but doesn't work at type-check time:

    :::magpie
    var makeList(elementType IType -> List(???))

So, at a minimum, we'll need some syntax for passing type arguments to a method that is distinct from passing value arguments. One option:

    :::magpie
    foo bar[typeArg](valueArg)

The type-checker will process that like:

    1. Evaluate `typeArg`.
    2. Check `valueArg`.
    3. Look up `bar` on `foo`'s type.
    4. Look up its type param name(s) and bind `typeArg` to it.
    5. Evaluate its param and return types in that context.
    6. Check that `valueArg`'s type matches the param type.
    7. Return the method's return type.

The interpreter will process that like:

    1. Evaluate `typeArg`.
    2. Evaluate `valueArg`.
    3. Look up `bar` on `foo`.
    4. Look up its type param name(s) and bind `typeArg` to it.
    5. Bind the argument to the param name(s).
    6. Evaluate the method body.
    7. Return the result.

Generic methods should cover constructing generic types:

    var people = List[Person] new
    var hash = Dictionary[String, Int] new

## Q: Are type arguments to generics erased?

A: *No.* Because we want to be able to access the type argument at runtime like
you can in C#, the type argument will have a runtime effect. For example:
   
    :::magpie
    var makeList[E](-> List[E])
        print("making a list of " + E)
        /// ...
    end
   
## Q: Can you have "value template arguments"? I.e. things inside [] that don't evaluate to types?

A: *Sure*, there's no reason not to. The only real difference between stuff in
`[]` and stuff in `()` is that the former is evaluated at check time and the
latter is only checked. It would be clearer to call the former "static
arguments" and the latter "dynamic arguments".

## Q: We took brackets. What about arrays?

A: *Make them functors:*

    :::magpie
    [1, 2, 3]    // becomes: Array of(1, 2, 3)
    array[1]     // becomes: array(1)
    array[1] = 2 // becomes: array(1) = 2
^title Design Questions

This section is really more useful for me than for Magpie users, but it may offer some insight into why the language is designed the way it is. When I first started working on Magpie, I'd run into basic design questions that needed answering. Each time, I would sit down and work my way through it until I reached a solution that seemed to make sense. I'd code up the result and move on.

Later, I'd forget all of the reasoning and then second guess the result. "Why did I do it this way when this other way makes so much more sense?" After going in circles a few times, I realized I should really write down not just the answer, but the reasoning that led to it.

Each page in this section is a specific language design question, the answer (if I have one), and the reasoning that led to it. They're somewhere between a Socratic dialogue and a personal journal. They may be kind of hard for anyone but me to understand, but maybe you'll get something from them.

Please keep in mind that I write these as I go, which means a lot of this content may be outdated as later design decisions affected or overrode it.

1. [Are All Types First Class?](design-questions/are-all-types-first-class.html)
1. [How Do Callable Fields Work?](design-questions/how-do-callable-fields-work.html)
1. [What Is the Type of a Generic?](design-questions/what-is-the-type-of-a-generic.html)
1. [Are Types in Java or Magpie?](design-questions/are-types-in-java-or-magpie.html)
1. [Can All Generic Arguments Be Inferred?](design-questions/can-all-generic-arguments-be-inferred.html)
1. [How Are Classes Declared?](design-questions/how-are-classes-declared.html)
1. [How Are Generic Functions Checked?](design-questions/how-are-generic-functions-checked.html)
1. [How Are Methods Defined?](design-questions/how-are-methods-defined.html)
1. [How Do Abstract Members Work?](design-questions/how-do-abstract-members-work.html)
1. [How Do Fields Work?](design-questions/how-do-fields-work.html)
1. [How Do Operators Work?](design-questions/how-do-operators-work.html)
1. [How Does Inheritance Work?](design-questions/how-does-inheritance-work.html)
1. [Interfaces or Abstract Classes?](design-questions/interfaces-or-abstract-classes.html)
1. [What Conversions Are Needed?](design-questions/what-conversions-are-needed.html)
1. [Where Do Type Expressions Appear?](design-questions/where-do-type-expressions-appear.html)
1. [How Are Syntax Extensions Imported?](design-questions/how-are-syntax-extensions-imported.html)
1. [How Do Multimethods Work?](design-questions/how-do-multimethods-work.html)
1. [How Are Bare Names Interpreted?](design-questions/how-are-bare-names-interpreted.html)
1. [How Do Callables Work With Multimethods?](design-questions/how-do-callables-work-with-multimethods.html)
1. [What is a Multimethod's Identity?](design-questions/what-is-a-multimethods-identity.html)
1. [How Do Multimethods Interact with Modules?](design-questions/how-do-multimethods-interact-with-modules.html)

^title Errors

Even the best-intentioned programs and users occasionally go awry and a language must give you tools to handle them. Magpie has a few tricks up its sleeve for working with errors and exceptional conditions.

## Returning Errors

For errors that are common or important enough that you want to ensure programmers handle them, you can simply return an error object. Magpie defines an `Error` class that is the base class for objects representing errors. Let's say we're writing a method that converts a "yes" or "no" string to a boolean. We can implement that like this:

    :::magpie
    def parseYesNo(value is String)
        match value
            case "yes" then true
            case "no"  then false
        end
    end

What happens if the passed in value is neither "yes" or "no"? A simple solution is to return an error.

    :::magpie
    def parseYesNo(value is String)
        match value
            case "yes" then true
            case "no"  then false
            else ParseError new("String must be 'yes' or 'no'.")
        end
    end

This pushes the problem onto the caller. They can no longer assume `parseYesNo` will always return a `Bool`, since it may now also return a `ParseError`. Pattern-matching gives them a straightforward way to distinguish those cases.

    :::magpie
    var response = getTextFromUser()
    match parseYesNo(response)
        case b is Bool       then "Got good answer"
        case e is ParseError then "Bad input"
    end

## Throwing Errors

Some errors occur very rarely, such as a stack overflow or out of memory. Other errors indicate bugs in the code that should be fixed instead of handling the error at runtime. For those cases, it's a chore to make the user check and manually handle an error return that they never expect to see.

For those cases, Magpie also supports *throwing* errors. A `throw` expression will cause the currently executing code to immediately stop and begin unwinding the callstack. When you throw, you include an error object that describes the problem. By convention, these are subclasses of `Error`.

Here is a "safe" division function that does not allow dividing by zero. Since attempting to divide by zero indicates a programmer error, it throws instead of returning the error.

    :::magpie
    def safeDivide(numerator is Int, denominator is Int)
        if denominator == 0 then throw DivideByZeroError new()
        numerator / denominator
    end

## Catching Errors

Unlike a returned error, a thrown error will not be given back to the calling code. Instead, Magpie will continue to unwind the callstack, causing each successive method to immediately return until the error is *caught*.

Errors are caught using a *catch clause*, which is `catch` followed by a [pattern](patterns.html), followed by `then`, and finally the expression or block to execute when an error is caught.

    :::magpie
    def canDivide(numerator is Int, denominator is Int)
        safeDivide(numerator, denominator)
        true // If we got here, no error was thrown.
    catch err is DivideByZeroError then
        false // If we got here, an error occurred.
    end

You can see here that unlike the exception-handling syntax in most languages, Magpie does not have an explicit `try` syntax. Instead, *any* [block](blocks.html) is implicitly a "try" block and may have catch clauses. In `canDivide`, the block is the method body itself, but other blocks may have catch clauses. For example:

    :::magpie
    if someCondition then
        doSomethingUnsafe()
    catch err is Error then
        // Failed.
    else
        doSomethingElse()
    catch err is Error then
        // Also failed.
    end

(There is one exception to this rule. A block that defines a `catch` clause's body may not have its own `catch` clauses.)

A single block may have more than one catch clause. When an error is thrown from the block, each catch clause's pattern is matched against the error in the order that they appear. The first catch clause whose pattern matches catches the error. The body of the catch clause is evaluated and that becomes the value returned by the block.

If no catch clause matches the error, the error continues to propagate.

## Errors and "Exceptions"

Magpie's error objects very similar to exceptions in most languages. It uses the term "error" for them because its valid to use errors outside of `throw` and `catch`: you can return error objects and pass them around. That's considered poor form in languages that call them "exceptions".

This is handy because the caller and callee may disagree on whether or not an error is important enough to be returned or should be thrown. A caller may catch a thrown error and then return it, or it may throw one that was returned to it. Using the same `Error`-derived classes for both affords that flexibility.

    :::magpie
    def returnError()
        doSomethingThatThrows()
    catch err is Error then
        err // Return it.
    end

    def throwError()
        match doSomethingThatReturnsError()
            case err is Error then throw err
            case success then success
        end
    end

In other words, an `Error` object tells you *what* the error is, but not *how it gets passed* from the code that generates the error to the code that handles it.

^title Expressions

Expressions are the building blocks for programs. In Magpie, a program is simply a series of them. Unlike most imperative languages, but like most functional languages, Magpie does not have *statements*, only expressions. Flow control, blocks, and variable declarations are all expressions which return values. This is valid in Magpie:

    :::magpie
    print(if result then "yes" else "no")

^title Flow Control

Magpie doesn't shy away from imperative programming, so it supports the usual flow control structures you know and love, although it does try to spice them up a bit. Before we cover them, there's one minor point to cover first:

## Truthiness

Flow control is about evaluating an expression and then choosing an action based on whether or not the result is "true". That's easy if the value happens to be a boolean, but what if it's some other class?

Most languages handle this by having a set of rules for what values of any given type are "true" or not. Magpie calls this "truthiness". By default, the rules are:

* For booleans: `true` is truthy, and `false` is not, of course.
* Non-zero numbers are truthy.
* Non-empty strings are truthy.
* `nothing` is not truthy.
* All other objects are truthy.

However, this behavior isn't fixed. Truthiness is determined by sending a `true?` message to the object. The value returned by that is used to determine if a condition is met or not. So, if you define your own class, you can control how it behaves when used in a conditional expression by simply defining `true?` to do what you want. (To avoid the [turtles-all-the-way-down](http://en.wikipedia.org/wiki/Turtles_all_the_way_down) problem, the result from `true?` *does* have a fixed interpretation: a boolean `true` is the only truthy value.)

When reading the rest of this section, understand that any time a condition is evaluated, there is an implicit call to `true?` inserted. So this:

    :::magpie
    if something(other) then ...

Is really:

    :::magpie
    if something(other) true? then ...

## if/then/else

The simplest flow control structure, `if` lets you conditionally skip a chunk of code. It looks like this:

    :::magpie
    if ready then go!

That will evaluate the expression after `if`. If it's true, then the expression after `then` is evaluated. Otherwise it is skipped. The `then` expression can be a block:

    :::magpie
    if ready then
        getSet
        go!
    end

You may also provide an `else` expression. It will be evaluated if the condition is false:

    :::magpie
    if ready then go! else notReady

And, of course, it can take a block too. Note that if you have an `else` clause, and the `then` takes a block, you do *not* need an explicit `end` for the first block. The `else` will imply that:

    :::magpie
    if ready then
        getSet
        go!
    else
        notReady
    end

Since Magpie does not have statements, even flow control structures are expressions and return values. An `if` expression returns the value of the `then` expression if the condition was true, or the `else` expression if false. If there is no `else` block and the condition was false, it returns `nothing`.

    :::magpie
    print(if true then "yes" else "no") // Prints "yes".

(This also means that Magpie has no need for a C-style ternary operator. `if` *is* the ternary operator.)

## Conjunctions

What other languages call "logical operators", Magpie calls "conjunctions". They are considered flow control expressions and not operators because they conditionally execute some code&mdash; they short-circuit. There are two conjunctions in Magpie: `and` and `or`. Both of them are infix operators, like so:

    :::magpie
    happy and knowIt
    ready or not

An `and` conjunction evaluates the left-hand argument. If it's not true, it returns that value. Otherwise it evaluates and returns the right-hand argument. An `or` conjunction is reversed. If the left-hand argument *is* true, it's returned, otherwise the right-hand argument is evaluated and returned:

    :::magpie
    print(0 and 1) // prints 0
    print(1 and 2) // prints 2
    print(0 or 1)  // prints 1
    print(1 or 2)  // prints 1

Note that logical negation is *not* a built-in flow control expression. Instead, `not` is simply a method on booleans:

    :::magpie
    if happy not then print("sad")

<p class="future">
"xor" doesn't really need to be a conjunction since it doesn't short circuit, but it (and maybe "not") likely will be at some point just to be consistent.
</p>
^title Functions

When you want to bundle up a reusable chunk of code in Magpie, you'll usually use a [method](multimethods.html). But sometimes you want a chunk of code that you can pass around like a value. For that, you'll use a *function*. Functions are first-class objects that encapsulate an executable expression.

## Creating Functions

Functions are defined using the `fn` keyword followed by the expression that forms the body of the function.

    :::magpie
    fn print("I'm a fn!")

This creates an anonymous function that prints `"I'm a fn!"` when called. The body of a function can be a single expression like above or can be a [block](blocks.html).

    :::magpie
    fn
        print("First!")
        print("Second!")
    end

## Parameters

To make a function that takes an argument, put a [pattern](patterns.html) for it in parentheses after the `fn` keyword.

    :::magpie
    fn(name, age) print("Hi, " + name + ". You are " + age + " years old.")

Like with methods, any kind of pattern can be used here. Go crazy.

### Implicit Parameters

When programming in a functional style, you often have lots of little functions that just call a method or do some trivial expression. Here's a line of code to pull the even numbers from a collection:

    :::magpie
    val evens = [1, 2, 3, 4, 5] where(fn(n) n % 2 == 0)

To make this a little more terse, Magpie supports *implicit parameters*. The above code can also be written:

    :::magpie
    val evens = [1, 2, 3, 4, 5] where(fn _ % 2 == 0)

Note that the parameter pattern is gone, and `n` in the body has been replaced with `_`.

The rule for implicit parameters is pretty simple. If a function has no parameter pattern, then a pattern will be created for it. Every `_` that appears in the body of the function will be replaced with a unique variable for each occurrence. Then a pattern will be created that defines those variables in the order that they appear.

The "unique variable" and "order that they appear" parts are important here, since you can have multiple implicit parameters. When you do, each `_` becomes its *own* parameter for the function.

    :::magpie
    fn (_ + _) / _

This creates a function with *three* separate implicit parameters. It's equivalent to:

    :::magpie
    fn(a, b, c) (a + b) / c

Implicit parameters can help code be more readable when the function body is small and the parameters are obvious from the surrounding context. But they can also render your code virtually unreadable (like the above example here) otherwise. Like all pointy instruments, wield it with care.

## Calling Functions

Once you have a function, you call it by invoking the `call` method on it. The left-hand argument is the function, and the right-hand argument is the argument passed to the function.

    :::magpie
    var greeter = fn(who) print("Hi, " + who)
    greeter call("Fred") // Hi, Fred

If a function doesn't take an argument, then there won't be a right-hand argument to `call`.

    :::magpie
    var sayHi = fn print("Hi!")
    sayHi call

Like methods, the argument pattern for a function may include tests. If the argument passed to `call` doesn't match the function's pattern, it throws a `NoMethodError`.

    :::magpie
    var expectInt = fn(n is Int) n * 2
    expectInt call(123) // OK
    expectInt call("not int") // Throws NoMethodError.

If you pass too many arguments to a function, the extra ones will be ignored.

    :::magpie
    var takeOne = fn(n) print(n)
    takeOne call("first", "second") // Prints "first".

However, if you pass too *few*, it will throw a `NoMethodError`.

    :::magpie
    var takeTwo = fn(a, b) print(a + b)
    takeOne call("first") // Throws NoMethodError.

## Returning Values

A function automatically returns the value that its body evaluates to. An explicit `return` is not required:

    :::magpie
    var name = fn "Fred"
    print(name call) // Fred

If the body is a block, the result is the last expression in the block:

    :::magpie
    var sayHi = fn
        print("hi")
        "result"
    end
    sayHi call // Prints "hi" then returns "result".

If you want to return before reaching the end of the function body, you can use an explicit `return` expression.

    :::magpie
    var earlyReturn = fn(arg)
        if arg == "no!" then return "bailed"
        print("got here")
        "ok"
    end

This will return `"bailed"` and print nothing if the argument is `"no!"`. With any other argument, it will print `"got here"` and then return `"ok"`.

A `return` expression with no expression following the keyword (in other words, a `return` on its own line) implicitly returns `nothing`.

## Closures

As you would expect, functions are
[closures](http://en.wikipedia.org/wiki/Closure_%28computer_science%29): they
can access variables defined outside of their scope. They will hold onto closed-over variables even after leaving the scope where the function is defined:

    :::magpie
    def makeCounter()
        var i = 0
        fn i = i + 1
    end

Here, the `makeCounter` method returns the function created on its second line. That function references a variable `i` declared outside of the function. Even after the function is returned from `makeCounter`, it is still able to access `i`.

    :::magpie
    var counter = makeCounter()
    print(counter call // Prints "1".
    print(counter call) // Prints "2".
    print(counter call) // Prints "3".

## Callables

The `call` method used to invoke functions is a regular multimethod with a built-in specialization for functions. This means you can define your own "callable" types, and specialize `call` to act on those. With that, you can use your own callable type where a function is expected and it will work seamlessly.

^title Hacking On Magpie

If you'd like to contribute to Magpie, or just poke around at its internals, this guide is for you. A word of warning before we start: Magpie is under heavy development. As soon as I save this doc, I'll probably edit some code and invalidate something here. I'll try to keep this up-to-date, but understand that there will likely be some lag.

## The Code

The Magpie interpreter is written in straight Java. It has no external dependencies and doesn't really do any magical stuff in the language. Since it changes so frequently, the code isn't as well-documented as I'd like, but it's getting there. You should be able to figure out what's going on without too much trouble.

### Cloning the Repo

Magpie lives on [github](http://github.com). To work on the source, just clone [the repository](http://github.com/munificent/magpie). That will give you a source tree with:

* `/base`: Contains the base library: the Magpie code automatically run at startup.
* `/doc`: Documentation, of course. Lots of notes to myself and stuff that may be outdated, but may be useful.
* `/doc/site`: The markdown text and python script used to build this site.
* `/old`: The old pre-Java, C# statically-typed version of Magpie.
* `/script`: Example Magpie scripts.
* `/spec`: The Magpie spec, the executable specification that defines and verifies the language.
* `/src/com/stuffwithstuff/magpie`: The Java source code of the interpreter.

## The Namespaces

The code for the interpreter is split out into six namespaces:

* `com.stuffwithstuff.magpie`: Classes that define the visible programmatic interface to the language. If you host Magpie within your own app, you'll talk to Magpie through here.
* `com.stuffwithstuff.magpie.app`: Stuff for the standalone application: `main()`, the REPL, file-loading, etc.
* `com.stuffwithstuff.magpie.ast`: Classes for the parsed syntax tree. The code here defines the data structures that hold Magpie code.
* `com.stuffwithstuff.magpie.interpreter`: The interpreter. The heart of Magpie is here.
* `com.stuffwithstuff.magpie.intrinsics`: Built-in methods in Magpie that are implemented in Java live here.
* `com.stuffwithstuff.parser`: The lexer and parser. This takes in a string of code and spits out AST.
* `com.stuffwithstuff.util`: Other random utility stuff.

## A Tour Through the Code

The simplest way to understand Magpie's code is to walk through it in the order that it gets evaluated.

1.  We start in `Magpie:main()`, of course. All it does is parse the
    command-line args and then either start a REPL, run the test suite, or
    execute a script. Let's assume we're running a script for now.

2.  Once we've loaded a .mag file into a `String`, it gets passed to the lexer:
    `Lexer`. That class takes in a `String` and chunks it into a series of
    `Token`s. A Token is the smallest meaningful chunk of code: a complete
    number, keyword, name, operator, etc.

3.  The `Token` stream is fed into the parser: `MagpieParser`. This is a simple
    recursive-descent parser with a fixed amount of lookahead. This class
    contains the core Magpie grammar. Generic parsing functionality is in its
    base class: `Parser`. Most of Magpie's high-level grammar is split out by
    keyword. When `MagpieParser` encounters a keyword like `var`, `def`, or
    `class`, it passes off functionality to an `ExprParser` that is registered
    to that keyword. Eventually, these will likely be implemented in Magpie so
    that its syntax can be extended by users.

    The end result of this is single expression or list of expressions.
    The source code is now in a form that Magpie can understand. Each expression will be a subclass of the base `Expr` class. There are subclasses for all of the core expression types (i.e. the things that don't get desugared away): literals (`IntExpr`, `StringExpr`, etc.), calls (`CallExpr`), flow control (`MatchExpr`, `ReturnExpr`, etc.), etc.

    The actual set of `Expr` subclasses is in flux. It isn't well-defined what
    becomes a real AST node, and what gets desugared by the parser into
    something simpler. Having fewer AST classes makes the interpreter simpler to implement. Having more makes it easier to create good error messages. What will likely happen over time is that this will be split into two levels: a rich AST set that is very close to the text syntax. That will get translated to a much simpler core syntax (basically just messages and literals) which will be what the interpreter or compiler sees.

4.  Next, we create an `Interpreter` to actually interpret the `Expr`s. It
    creates a global `Scope`, and defines the built-in types in it: `Int`,
    `Nothing`, etc.

5.  The `Interpreter` then registers the built-in methods on those types. For
    each built-in Magpie class (`Int`), there is a corresponding static Java
    class that has the built-in methods for it (`IntBuiltIns`). Each method in
    that class has a `Signature` annotation that describes how the method looks
    to Magpie. `BuiltIn` uses reflection to find all of those methods and make
    them available to be called from Magpie.

6.  Now we've got a live Magpie environment we can start running code in, but
    it's still pretty empty. Things like interfaces aren't defined in Java, they're in the base library. So before we can do useful stuff, we need to load the base lib. This is done automatically by `Script` before it runs the user-provided code.

7.  Finally we can throw our code at the interpreter. We pass it our parsed
    expressions. It creates an `EvalContext` which defines the context in which code is executed: the local variable scope (and its parent scopes), as well as what `this` refers to. Code is always evaluated with an `EvalContext`.

8.  It then creates an `ExprEvaluator`. `Expr` uses the Visitor Pattern to
    allow operations on the different expression types without having to put that code directly in the `Expr`-derived classes. `ExprEvaluator` is one of the two visitors in Magpie. It, as you'd expect, evaluates `Expr`s. This is where the actual Magpie code gets interpreted.

    Right now, Magpie is a tree-walk interpreter: it interprets code by
    recursively traversing an expression tree and evaluating the nodes. At some
    point, it will likely compile to bytecode instead. When that happens,
    `ExprEvaluator` will become `ExprCompiler`, which will walk the AST and
    generate bytecode.

9.  We pass our expressions to evaluate to the evaluator which evaluates them.
    Ta-da! We've run Magpie code.

^title Welcome

Thanks for coming!

Magpie is a small dynamically-typed programming language built around [*patterns*](patterns.html), [*classes*](classes.html), and [*multimethods*](multimethods.html). It tries to blend the syntactic charm of Ruby, the open-ended extensibility of CLOS, and the lightweight concurrency of Go.

It looks a bit like this:

    :::magpie
    // Generates the sequence of turns needed to draw a dragon curve.
    // See: http://en.wikipedia.org/wiki/Dragon_curve
    def dragon(0, _)
        ""
    end

    def dragon(n is Int, turn)
        dragon(n - 1, "R") + turn + dragon(n - 1, "L")
    end

    print(dragon(5, ""))

## Where We're At

Here's the deal. Magpie is very young. The egg has been laid, but still hasn't
quite cracked open yet. Everything described here is implemented and working
now, but lots of stuff is missing, buggy, or likely to change. I wouldn't
entrust it with my lunch money if I were you.

If you just want a language to *use*, this is bad news. But if you want a
language to *contribute to*, this is great news! Lots of interesting important
decisions have yet to be made, and there's lots of fun stuff that needs coding.
I'd love to have you involved.

## Getting Started

Magpie has two implementations right now. There is a prototype interpreter
written in Java. This supports more of the language, but is (of course) tied to
the JVM and is *much* slower. It's main job was to let me iterate on the
language semantics quickly.

Now that the language has (mostly) settled down, I've started writing a
bytecode VM in C++. This is the "real" Magpie implementation, but it's still a
work in progress. All current development is going on here. The Java interpreter
is mainly a reference.

### Building the Bytecode VM

1.  **Pull down the code.** It lives here: https://github.com/munificent/magpie

2.  **Generate a project.** From the root directory of the magpie repo:

        $ cd <path to magpie repo>
        $ ./run_gyp

3.  **Set the output directory (XCode 4 only).** Recent versions of XCode build
    into some shared directory not related to where the project is. This borks
    Magpie since it's a command-line executable that loads the core library
    from a path relative to that executable.

    Unfortunately, this setting isn't in the project itself, so gyp can't help.
    After you generate the project, open it in XCode, then:

    1. Choose "File > Project Settings...".
    2. On the "Build" tab, click "Advanced...".
    3. Set "Build Location" to "Custom > Relative to Workspace".
    4. Set "Products" to `build`.
    5. Set "Intermediates" to `build/Intermediates`.
    6. Click "Done".

    This should ensure that Magpie gets built into `build/<config>/magpie`.

4.  **Build the project.** Do what you usually do on your OS to build the thing.
    On Mac, that means open the XCode project and build from there. In Windows,
    there is a Visual Studio solution you can build. On Linux, you can just run
    `make`.

[gyp]: http://code.google.com/p/gyp/

### Building the Java Interpreter

1.  **Pull down the code.** It lives here: https://github.com/munificent/magpie

2.  **Build it.** The repo includes an Eclipse project if that's your thing. If
    you rock the command-line, you can just do:

        $ cd magpie
        $ ant jar

### Running Magpie

Magpie is a command line app. After building it, you can run it by doing:

        $ ./magpie

This will run the Java interpreter or the bytecode VM, whichever is more recent.

If you run it with no arguments, it drops you into a simple REPL. Enter a
Magpie expression and it will immediately evaluate it. Since everything is an
expression, even things like class definitions, you can build entire programs
incrementally this way. Here's one to get you started:

    :::magpie
    for i in 1..20 do print("<your name> is awesome!")

If you pass an argument to the app, it will assume it's a path to a script
file and it will load and execute it:

    $ ./magpie example/hello.mag

## Where to Go From Here

Since you've made it this far, you must be interested. You can learn more about
the language from the [Magpie posts](http://journal.stuffwithstuff.com/category/magpie/) on my blog. (Note that the language has changed dramatically over time, so the older a post is, the less likely it is to still be relevant.)

If you have questions or comments, the mailing list
[here](http://groups.google.com/group/magpie-lang) is a good place to start. You can [file bugs or issues on github](https://github.com/munificent/magpie/issues). If you want some live interaction, there's an IRC channel on freenode: [#magpie-lang](irc://irc.freenode.net/magpie-lang).

Cheers, and have fun playing with it!

^title Internals

<p class="future">To do...</p>
^title Lists

Almost every language has arrays or lists and Magpie is no different. If you have a bunch of items that you want to lump together and identify programmatically, it's hard to beat them. A list is a compound object that holds a collection of *elements* identified by *index*. You can create a list by placing a sequence of comma-separated [expressions](expressions.html) inside square brackets:

    :::magpie
    [1, "banana", true]

Here, we've created a list of three elements. Notice that the elements don't have to be the same type.

## Accessing Elements

You can access an element from a list by calling the [subscript operator](multimethods.html#indexers) on it with the index of the element you want. Like most languages, indexes start at zero:

    :::magpie
    val hirsute = ["sideburns", "porkchops", "'stache"]
    hirsute[0] // "sideburns"
    hirsute[1] // "porkchops"

If you pass in an index that's greater than the number of items in the list, it [throws](error-handling.html) an `OutOfBoundsError`. If you pass in a *negative* index, it counts backwards from the end:

    :::magpie
    hirsute[-1] // "'stache"
    hirsute[-2] // "porkchops"

Of course, if you go *too* negative and shoot past the first item, that throws an error too. If you don't know how far that is, you can always find out by getting the number of items in the list using `count`:

    :::magpie
    hirsute count // 3

^title Looping

**TODO: This needs to be rewritten now that `while` and `for` are distinct.**

Many languages have three distinct loop structures: `for`, `while`, and `foreach` or something similar for generators. Magpie only has a single loop construct, but it subsumes all three of those. A simple loop looks like this:

    :::magpie
    while something do
        body
    end

The `while something` part is the *clause*, and the expression after `do` (here a [block](blocks.html)) is the *body*. The clause is evaluated at the beginning of each loop iteration (including before the first). If it fails, the loop body is skipped and the loop ends. There are two kinds of clauses:

## `while` Clauses

The simplest is `while`. It evaluates a condition expression. If it evaluates to `false`, the loop ends, otherwise it continues. For example:

    :::magpie
    while 1 < 2 do print("forever...")

## `for` Clauses

The other loop clause is `for`. It looks like:

    :::magpie
    for item in collection do print(item)

The expression after `in` is evaluated *once* before the loop starts and is expected to return an *iterable* object, which it then passes to the `iterate` method. That should return an *iterator*.

An iterator generates a series of values. There are two methods it gets passed to. The `next()` method is called before each loop iteration (including the first) and advances the iterator to its next position. If the iterator is out of values, it returns `false` and the clause fails, otherwise it returns `true`. The `current` getter returns the current value that the iterator is sitting on.

Each iteration of the loop, Magpie will advance the iterator and bind the current value to a variable. The variable is scoped within the body of the loop. What this means is that a loop like:

    :::magpie
    for item in collection do print(item)

Is really just syntactic sugar for something like:

    :::magpie
    val __iter = collection iterate()
    while __iter next do
        val item = __iter current
        print(item)
    end

All of this means that Magpie *only* has a `foreach`-like for loop. It doesn't have a primitive C-style `for` loop. To get the classic "iterate through a range of numbers" behavior, the standard library provides methods on numbers that return iterators:

    :::magpie
    for i = 1 to(5) do print(i)
    // Prints "1", "2", "3", "4", "5".

    for i = 1 until(5) do print(1)
    // Prints "1", "2", "3", "4".

Here, `to` and `until` are just regular methods and not built-in keywords. They each return ranges that iterate through a series of numbers.

## Combining Clauses

The reason Magpie has only a single loop expression is because clauses can be combined. A single loop can have as many clauses as you want, of either kind, in any order. At the beginning of each iteration of a loop (including before the first one), *all* of the clauses are evaluated in the order they appear. If *any* clause fails, the loop body is skipped and the loop ends. For example:

    :::magpie
    while happy
    while knowIt do
        clap(hands)
    end

Once one of those `while` clauses returns false, the loop ends. Note that the clauses are iterated *in parallel*, unlike nested loops:

    :::magpie
    for i = 1 to(3)
    for j = 6 to(10) do
        print(i + ":" + j)
    end
    // Prints "1:6", "2:7", "3:8".

    for i = 1 to(4) do
        for j = 6 to(10) do
            print(i + ":" + j)
        end
    end
    // Prints "1:6", "1:7", "1:8", "1:9", "1:10", "2:7" ... "4:10".

The key difference is `do`. That's the keyword that indicates the end of the
clauses and the beginning of the body. No matter how many clauses you have, a
single `do` means a single loop.

Allowing multiple `for` clauses like this enables some handy idioms:

    :::magpie
    // Iterate through a collection with indexes
    for i = 0 countingUp
    for item = collection do
        // Here 'item' is the item and 'i' is its index.
    end

    // Iterate through the first 10 items in a collection.
    for i = 1 to(10)
    for item = collection do print(item)

    // Iterate through a collection until an item is found.
    var found = nothing
    while found == nothing
    for item = collection do
        if test(item) then found = item
    end

## Exiting Early

Inside the body of a loop, you can exit early using a `break` expression:

    :::magpie
    while true do
        something
        if badNews then break
        somethingElse
    end

## Return Value

Because loops are [expressions](expressions.html), they return a value.

<p class="future">
Right now, a loop will always return `nothing`, but that will likely change. It will be possible to define an `else` clause for a loop and then the expression will return the last result of evaluating the body, the expression passed to `break` or the expression after `else` if the body was never entered.
</p>

^title Modules

Once you start writing programs that are more than little toys, you quickly run into two problems:

1. You want to break them down into multiple smaller files to make it easier to
   find your way around them.
2. You want to reuse pieces of them across different programs.

To address those, Magpie has a simple *module* system. A file containing Magpie code saved with a `.mag` extension defines a module. A module can use the code defined in another module by *importing* it. You can break big programs into smaller modules that import each other, and you can reuse code by having multiple programs share the use of a single module.

## Importing a Module

One module can import another using an `import` expression. Like any expression, these can appear anywhere, but the convention is to place them at the top of the file before any other code.

    :::magpie
    import io.path

Here, we're importing the `io.path` module. Importing a module does two things: it runs the module's code, then it binds name in the importing scope.

## Qualified Imports

By default, when you import a module you get everything it exports just as it appears in that module. That works most of the time, but sometimes you may want finer-grained control. Maybe you only want to import a few things, or you need to rename something to deal with a name collision.

To handle those, Magpie has a few additional qualifiers you can provide when you import. The first is a prefix:

    :::magpie
    import io.path as path

When you add `as` followed by a name after the module being imported, it prefixes every imported name with that name followed by a dot (`.`). So if `io.path` defines a `baseName` method, we will import it as `path.baseName`. This is useful if you want to bring in every name, but make it very clear where they are coming from.

If you want more precise control over specific names, you can add a `with` block to the import:

    :::magpie
    import io.path with
        ...
    end

Each line inside that block lets you do a few things with a name. First is renaming:

    :::magpie
    import io.path with
        baseName as base
    end

Using `as` lets you provide a new name for a name that you're importing. With the above example, this module would be able able to invoke the `baseName` method defined in `io.path` by calling `base`.

If a line starts with `export` it lets you re-export an imported name.

    :::magpie
    import io.path with
        export baseName
    end

By default, imported names are not in turn exported for a module. The idea is that you import things to use yourself, but you only export the behavior you define in your module.

If you do actually want to make something you import part of the exported set of names in your module you can add `export` as shown. Here, anyone importing your module will be able to call the `baseName` method that's defined in `io.path` as if it were defined in your module.

<p class="future">It isn't implemented yet, but at some point you'll also be able to exclude imported names and indicate that you only want to import a select set of names.</p>

## Module Loading

When a module is imported for the first time, Magpie needs to find the file that corresponds to that module's name. This is called the *lookup* process. It works like so:

1. Dots in the name are turned into directory separators. So if we're loading `io.path`, we'll turn that into `io/path`.
2. A `.mag` file extension is added, so now we have `io/path.mag`.
3. We look for a file at that path relative to the current working directory. If found there, we're done.
4. Otherwise, we look for it inside the standard Magpie `lib/` directory which lives where the main executable is.

If Magpie couldn't find a module at either of those paths, an [error](error-handling.html) is thrown.

If it succeeds, Magpie creates a new empty module scope and runs the loaded code. Magpie has no single global scope where names are defined. Instead, each module has its own top level scope. When you define a variable or method in a module, that name is only visible to the module where it's defined.

When that's done, the module is successfully loaded. Note that Magpie only does this the *first* time a given module is imported. If a module is imported by three other modules, its code will only be run once, and it will only have a single top-level scope in memory.

Once a module has been loaded in response to an `import`, it proceeds to the next step, importing names.

## Importing Names

When one module imports another, it usually does so because it wants to use some of the methods or variables defined in that module. But, since there is no single global scope, it doesn't have a way to get at them.

To solve that, an `import` expression will also define names in the importing module that reference [methods](multimethods.html) and [variables](variables.html) defined in the imported module. By default, when you import a module, any methods and variables that that module declares at its top level (i.e. not inside some nested [block](blocks.html) scope or in a method) will be imported into yours. For example:

    :::magpie
    // dessert.mag
    var pie = "apple"
    def eatPie()
        print("You eat a delicious " + pie + " pie")
    end

    // hungry.mag
    import dessert

    print("I imported " + pie)
    eatPie()

When `hungry.mag` imports `dessert.mag` it gets a variable named `pie` defined in *its* scope that references the same value that it has in `dessert.mag`. Likewise, it gets a top-level `eatPie()` defined in its scope that it can then call.

It's important to realize that when you import a variable, you get your *own* variable declared in your module that points to the same value that the exported variable had *when you imported it*. If either module assigns a different value to it, the other won't see that change. Consider:

    :::magpie
    // dessert.mag
    var pie = "apple"
    def eatPie()
        print("You eat a delicious " + pie + " pie")
    end

    def changePie()
        pie = "chocolate"
    end

    // hungry.mag
    import dessert

    changePie()
    print(pie) // Still prints "apple"
    eatPie() // Prints "chocolate"

Here, `dessert.mag` is changing the value of `pie` after `hungry.mag` imports it. We won't see that change reflected in the `pie` variable defined in `hungry.mag`, but we will see it when it calls `eatPie()` since that method looks it up in `dessert.mag` where its defined.

## Public and Private Names

By default, any variable or method defined at the top level of a module is considered "public" and can be exported into other modules. Sometimes, though, you want to define code that the module can use itself but that isn't visible to the outside world.

To address that, Magpie supports *private names*. Any name that starts with an underscore will not be exported from a module.

    :::magpie
    // secret.mag
    val _hidden = "you can't see me!"

    // main.mag
    import secret

    print(_hidden) // ERROR! _hidden is not defined

This applies to methods, variables, as well as [classes](classes.html) and their fields. With a class, you can even make some fields private and others public.

    :::magpie
    // secret.mag
    var _nextKey = 12345

    defclass Lock
        val _key = _nextKey = _nextKey + 1
    end

    // main.mag
    import secret

    val lock = Lock new()
    lock _key // ERROR: _key getter isn't defined here

**TODO: circular dependencies, _init.mag, relative imports.**

^title Multimethods

Methods are the workhorses of Magpie. Most of the code you write will reside inside a method, and most of that code will in turn be calls to other methods. A *method* is an executable chunk of code (an [expression](expressions.html) to be precise) that is bound to a *name* and has a [*pattern*](patterns.html) that describes the *argument* it expects.

## Defining Methods

Methods are defined using the `def` keyword.

    :::magpie
    def greet()
        print("Hi!")
    end

Here we've defined a method named `greet` whose body is a [block](blocks.html) containing a single `print` call. You can [call](calls.html) this method like so:

    :::magpie
    greet()

We can define a method that takes an argument by using a pattern in its definition.

    :::magpie
    def greet(who)
        print("Hi, " + who)
    end

    greet("Fred") // Hi, Fred

In this case, the pattern `who` is a simple variable pattern, but more complex patterns can be used:

    :::magpie
    def greet(who is String, whoElse is String)
        print("Hi, " + who + " and " + whoElse)
    end

    greet("Fred", "George")

Here we have a record pattern with two fields that must both be strings. We call it by passing it a record of two strings: `"Fred", "George"`. This may seem a bit strange, but it's important to note that we are *not* passing two arguments. In Magpie, methods (and [functions](functions.html)) always take a *single* argument. It's just that the argument may be a record which the method destructures.

The end result is that it works pretty much like other languages, but there's some conceptual unification going on under the hood. The destructuring initialization that you can do when declaring [variables](variables.html) is the exact same process used when splitting out arguments to a method, or selecting a `catch` clause when an [error](error-handling.html) is thrown.

## Left and Right Arguments

Method calls are *infix* expressions, which means that an argument may appear to the left of the name, to the right, or both. (More pedantically, *the record that forms the single argument* may have fields which appear to the left and right of the name.)

The `greet` methods we've defined so far only have a right argument. Methods which only have a *left* argument are informally called *getters*.

    :::magpie
    def (this is String) isEmpty
        this count == 0
    end

This defines a getter `isEmpty` whose left argument must be a string. It takes no right argument. It can be called like this:

    :::magpie
    "not empty" isEmpty // false

And, finally, methods can have arguments on both sides:

    :::magpie
    def (this is String) greet(other is String)
        print("Hi, " + other + ", I'm " + this)
    end

    "Fred" greet("George")

When you define a method, the argument patterns always need to be in parentheses. When you *call* a method, only the right one must. If you chain several method calls, they associate to the left (like most languages). For example, this:

    :::magpie
    people find("Smith") firstName greet("George")

is the same as:

    :::magpie
    ((people find("Fred")) firstName) greet("George")

## Setters

In addition to getters, you can also define *setter* methods. Like getters, setters are just regular methods, but they have special syntax to make them look like assignment. You define a setter like so:

    :::magpie
    def (this is Person) name = (name is String)
        print("Set name to " + name + "...")
    end

The `=` followed by a pattern tells Magpie that you're defining a setter. We can call the above setter:

    :::magpie
    person name = "Fred"

A setter may also have a right argument:

    :::magpie
    def (this is Contact) phoneNumber(type is String) = (number is String)
        print("Set " + type + " number to " + number)
    end

    jenny phoneNumber("Home") = "867-5309"

Magpie tries to roll as much behavior under method calls as possible and getters and setters are a good example of that. It's worth noting that *everything* that looks like a getter or setter is just a method call. When you're accessing fields in a [class](classes.html), you're just calling getter and setter methods that have automatically created implementations.

## Indexers

In addition to setters, Magpie has one more little bit of extra syntax for method calls. To make working with collection-like objects easier, it provides *indexer methods*. These are essentially methods whose name is `[]`. The left argument appears before the brackets, and the right argument is inside them.

    :::magpie
    list[2]

Here, we're accessing an element from some `list` variable by calling an indexer method. The left argument is `list` and the right argument is `2`. Aside from their syntax, there is nothing special about indexers. They're just methods like any other and you're free to define your own indexers, like so:

    :::magpie
    def (this is String)[index is Int]
        this substring(index, 1)
    end

Here, we've defined an indexer on strings that takes a number and returns the character at that index (as a string). As you'd expect, the right argument can also be a [record](records.html):

    :::magpie
    defclass Grid
        val width is Int
        val height is Int
        val cells is List
    end

    def (this is Grid)[x is Int, y is Int]
        cells[y * width + x]
    end

Here we've defined a `Grid` class that represents a 2D array of cells. It includes an indexer for getting the cell at a given coordinate. You can call it like this:

    :::magpie
    val cell = grid[2, 3]

You can also define *indexer setters* which combines the syntax of those:

    :::magpie
    def (this is Grid)[x is Int, y is Int] = (value)
        cells[y * with + x] = value
    end

    grid[2, 3] = "some value"

## Method Scope

Magpie's method call syntax looks similar to other OOP languages where a "receiver" argument precedes the method. We've seen some examples where we define methods whose left argument is a built-in type like `String`. In other languages, this is called [monkey-patching](http://en.wikipedia.org/wiki/Monkey_patch) and doing it is fraught with peril. The reason is that when you invoke a method in those languages, it looks up the method *on the class of the receiver*. If two unrelated parts of the program define a method with the same name on the same class, those two methods will collide. When we call it later we may find the wrong one.

In Magpie (as in [CLOS](http://en.wikipedia.org/wiki/CLOS)) methods are not *owned* by classes. Instead, methods reside in lexical scope, just like variables. When you call a method, the method is found by looking for it in the scope *where the call appears*, and not on the class of any of the arguments. When a method goes out of scope, it disappears just like a variable.

    :::magpie
    do
        def (this is String) method()
            print(this + " first")
        end

        "a" method() // a first
    end

    a method() // ERROR!

    do
        def (this is String) method()
            print(this + " second")
        end

        "a" method() // a second
    end

It is impossible to have a method collision in Magpie. If you try to define two methods with the same name and pattern in the same scope, it will [throw an error](error-handling.html). This way, you can define methods that have a nice readable calling syntax without having to worry about breaking code in some other part of the codebase.

<p class="future">Checking for pattern collisions hasn't been implemented yet.</p>

## Multimethods

In Magpie, all methods are *multimethods*. This is one of the places where the language really steps it up compared to other dynamic languages. In the previous section, we noted that it's an error to define two methods with the same name *and pattern* in the same scope. That qualifier is important. It's perfectly fine to define two methods with the same name but *different patterns*.

    :::magpie
    def double(n is Int)
        n * 2
    end

    def double(s is String)
        s + s
    end

Here we've defined two `double` methods, one on strings and one and numbers. Even though they are defined in the same scope, these don't collide with each other. Instead, these are combined to form a single `double` multimethod containing two *specializations*.

When you [call](calls.html) a multimethod, it looks through the methods it contains and their patterns. It then *selects* the most appropriate pattern, and calls the method associated with it.

    :::magpie
    double(3) // 6
    double("ma") // mama

In simple terms, this means Magpie lets you overload methods, which is pretty unusual in dynamic languages. It's also more powerful than most static languages because it's selecting the most appropriate method *at runtime* where overloading in a language like Java is done at compile time.

Since all methods actually take a single argument, we're free to specialize a multimethod on the left argument, right argument, or both. You can also specialize on different record patterns.

    :::magpie
    def (this is String) double
        this + this
    end

    def (this is Int) double
        this * 2
    end

    def double(s is String, s is Int)
        s + s, n * 2
    end

    "left" double   // leftleft
    3 double        // 6
    double(3, "do") // 6, dodo

As long as you don't provide two specializations with the exact same pattern, you are free to define as many as you want. If you call a multimethod with an argument that doesn't match *any* of the specializations, it will [throw](error-handling.html) an error.

    :::magpie
    do
        double(true)
    catch is NoMethodError
        print("We didn't specialize double on bools")
    end

We didn't define a `double` method that accepts a boolean, so when we call it, it will throw a `NoMethodError` which gets caught here to print a warning.

## Linearization

**TODO(bob): Methods are partial order now, not a strict linearization. Need to update this.**

The previous section says that the "most appropriate" method is selected based on the argument. In the examples we've seen so far, only one method is a possible match, so most appropriate is pretty easy. If multiple methods match the argument, we need to determine the *best* one. Magpie (and other languages) call this *linearization*.

    :::magpie
    def odd?(0)
        false
    end

    def odd?(n is Int)
        not(odd?(n - 1))
    end

Here we have an `odd?` multimethod with two specializations. If we call it and pass in `0`, then both specializations match. Which is best? To answer this, Magpie has a few relatively simple rules that it uses to order the patterns.

Before we get to those rules, it's important to understand one thing that does *not* affect ordering: *the order that methods are defined in a program has no effect on linearization.*

### Pattern Kind

First, different kinds of patterns are ordered. From best to worst:

1.  Value patterns
2.  Record patterns
3.  Type patterns
4.  Wildcard patterns

For variable patterns, we look at its inner pattern. (If it doesn't have one, it is implicitly `_`, the wildcard pattern.) The above list addresses our `odd?` example: the first method will win since a value pattern (`0`) takes precedence over a type pattern (`is Int`).

To linearize two patterns of the *same* kind, we need more precise rules.

### Class Ordering

To order two type patterns, we look at the [classes](classes.html) being compared and see how they are related to each other. Subclasses take precedence over superclasses.

    :::magpie
    defclass Parent
    end

    defclass Child is Parent
    end

    def sayClass(is Parent)
        print("Parent")
    end

    def sayClass(is Child)
        print("Child")
    end

    sayClass(Child new())

Here, both methods match because an instance of `Child` is also an instance of `Parent`. In this case, the second method specialized to `is Child` wins because `Child` is a subclass of `Parent`.

### Record Ordering

It's possible for two record patterns to match the same argument.

    :::magpie
    def printPoint(x: x, y: y)
        print(x + ", " + y)
    end

    def printPoint(x: x, y: y, z: z)
        print(x + ", " + y + ", " + z)
    end

    printPoint(x: 1, y: 2, z: 3)

A record pattern matches as long as the argument has the fields the record requires. *Extra* fields are allowed and ignored, so here both methods match. It's also possible for records with the same fields but different field patterns to match:

    :::magpie
    def sameGeneration?(a: is Parent, b: is Parent)
        true
    end

    def sameGeneration?(a: is Child, b: is Child)
        true
    end

    def sameGeneration?(a: _, b: _)
        false
    end

Ordering these can be complex, so the linearization rules for records a bit subtle. The first requirement is that the records must specify the same fields, or one must be a subset of the other. If not, they cannot be ordered and an `AmbiguousMethodError` is [thrown](error-handling.html).

    :::magpie
    def say(x: x)
        print("x " + x)
    end

    def say(y: y)
        print("y " + y)
    end

    say(x: 1, y: 2)

It's unclear what the programmer was even trying to accomplish here, and Magpie can't read your mind. So in cases like this, it just raises an error to signal its confusion. Our first example doesn't have this problem, though. The first definition of `printPoint` is a subset of the former, so there's no ambiguity. In that case, it proceeds to the next step.

There are several signals we can rely on to tell us which record should come first. We'll call those *lean*. To order records in a predictable way, those signals need to agree with each other. The first signal is if one record has fields the other doesn't. In our first `printPoint` example, the second method has an extra `z:` field. That means we *lean* towards preferring that method since it "uses more" of the argument that gets passed in.

Next, we go through the fields that the two records have in common and linearize *their* patterns. Whichever pattern wins is a lean towards that record. (If the patterns compare the same, like the `x` and `y` fields in the two `printPoint` methods, then there's no lean one way or the other.)

If all of the leans are towards one record, it wins. If the leans are inconsistent then it's ambiguous. This is all a bit fishy, so some examples should clarify:

    :::magpie
    x: x, y: y
    x: x, y: y, z: z
    // Second wins: more fields

    x: x, y: y
    y: y, z: z
    // Ambiguous: neither is a subset of the other

    a: is Parent, b: is Parent
    a: is Child, b: is Parent
    // Second wins: Child is more specific

    a: is Parent, b: is Child
    a: is Child, b: is Parent
    // Ambiguous: fields disagree

The general theme here is that it tries to pick records that are "obviously" the more specific one where "more specific" means more fields or more precise fields. If it isn't crystal clear which one the programmer intended to win, Magpie just throws its hands up and pleads confusion.

^title Objects

*Objects* are the data that Magpie programs operate on. They are the nouns of
the language. An address or a phone number is an object, as is a spaceship in a
game, or an HTTP request in a web app. Magpie is a "pure" object-oriented language in that *all* values are represented by objects. Numbers, strings, and boolean values are objects, as are functions, classes, chunks of code, the special value `nothing`, and even types. The whole kit and caboodle.

Every object in Magpie is an instance of some [class](classes.html). Magpie has
several built-in classes that deserve special attention and that you'll use to
as the building blocks for your own classes. They are:

1. [Primitives](primitives.html)
1. [Records](records.html)
1. [Lists](lists.html)
1. [Functions](functions.html)

^title Pattern Matching

Control flow&mdash;deciding which code to execute&mdash;is a big part of imperative languages. Magpie has your basic [looping](looping.html) and [branching](flow-control.html) expressions that you know from most imperative languages. But instead of a boring C-style `switch`, it's got something turbo-charged: *pattern matching*.

A `match` expression evaluates a *value* expression. Then it looks at each of a series of *cases*. For each case, it tries to match the case's [*pattern*](patterns.html) against the value. If the pattern matches, then it evaluates the *body* of the case.

    :::magpie
    val fruit = "lemon"
    match fruit
        case "apple" then print("apple pie")
        case "lemon" then print("lemon tart")
        case "peach" then print("peach cobbler")
    end

The expression after `match` (here just `fruit`) is the value being matched. Each line starting with `case` until the final `end` is reached defines a potential branch the control flow can take. When a match expression is evaluated, it tries each case from top to bottom. The first case here doesn't match because `"apple"` isn't `"lemon"`, so its body is skipped. The second case *does* match. That means we execute its body, print `"lemon tart"` and we're done. Once a case has matched, the remaining cases are skipped.

Like everything in Magpie, `match` expressions are *expressions*, not statements, so they return a value: the result of evaluating the body of the matched case. That means we can reformulate the above example like so:

    :::magpie
    val fruit = "lemon"
    val dessert = match fruit
        case "apple" then "apple pie"
        case "lemon" then "lemon tart"
        case "peach" then "peach cobbler"
    end
    print(dessert)

Or even:

    :::magpie
    val fruit = "lemon"
    print(match fruit
        case "apple" then "apple pie"
        case "lemon" then "lemon tart"
        case "peach" then "peach cobbler"
    end)

A case body may also be a block, as you'd expect. If it's the last case in the match, the block must end with `end`, otherwise, the following `case` is enough to terminate it:

    :::magpie
    match dessert
        case "apple pie" then
            print("apple")
            print("pie crust")
            print("ice cream")
        case "lemon tart" then // "case" here ends "apple pie" block
            print("lemon")
            print("pastry shell")
        end // last case block must end with "end"
    end // ends entire "match" expression

## Case Patterns

With simple literal patterns, this doesn't look like much more than `switch` statements in other languages, but Magpie allows you to use any pattern as a case. With that, you can bind variables, destructure objects, or branch based on type:

    :::magpie
    def describe(obj)
        match obj
            case b is Bool          then "Bool : " + b
            case n is Int           then "Int : " + n
            case s is String        then "String : " + s
            case x is Int, y is Int then "Point " + x + ", " + y
        end
    end

    describe(true) // "Bool : true"
    describe(123)  // "Int : 123"
    describe(3, 4) // "Point : 3, 4"

If the pattern for a case binds a variable (like `b` in the first case here) that variable's scope is limited to the body of that case. That way, you can ensure that you'll only get a variable bound if it matches what you want. For example, here we know for certain that `b` will only exist if `obj` is a boolean and `b` will be its value.

## Match Failure

It's possible for no case in a match expression to match the value. If that happens, it will [throw](error-handling.html) a `NoMatchError`. This is the right thing to do if you only expect certain values and a failure to match is a programmatic error. If you *do* want to handle any possible value, though, you can add an `else` case to the match expression:

    :::magpie
    val dessert = match fruit
        case "apple" then "apple pie"
        case "lemon" then "lemon tart"
        case "peach" then "peach cobbler"
        else "unknown fruit"
    end

If no other pattern matches, the `else` case will.

^title Patterns

If you've seen a few lines of Magpie code, you've likely seen patterns already. They are used everywhere in the language: [`match` expressions](pattern-matching.html) obviously use them, but so do [variable declarations](variables.html), [method parameters](multimethods.html), and `catch` clauses for [handling exceptions](error-handling.html).

Patterns are the foundation that control flow and naming are built on in Magpie. Given an [object](objects.html), a pattern does two things: First, it *tests* if the object *matches* that pattern. Then, if and only if it does, it may *bind new variables* to parts of the object. By performing those operations together, patterns can pull data out of an object but only when the object correctly has the data you're asking for.

A quick example in the context of a `match` expression should clarify:

    :::magpie
    match "s", 234, true
        case "s", n is Int, _ then print(n + 2)
    end

Here, the value being matched is the [record](records.html) `"s", 234, true`. The pattern is `"s", n is Int, _`, a record pattern containing a value pattern, type pattern, and wildcard pattern, respectively. This pattern *does* match that value, which means it will bind `n` and then evaluate the body in that scope. In this case, the body is just `print(n + 2)`.

## Kinds of Patterns

Syntactically, patterns are a bit like the twin of expressions. Like expressions, there are different atomic pattern syntaxes which can be composed to form larger patterns. There are six kinds of patterns:

### Literal Patterns

A [literal value](primitives.html) like `123` or `true` where a pattern is expected defines a *literal* pattern. As you would expect, a literal pattern only matches an identical value. The pattern `"hi"` matches the string value `"hi"` and nothing else.

### Equality Patterns

To check if a value is equal to the result of some [expression](expressions.html), you can use an *equality pattern*. It starts with `==`, followed by the value to be compared with.

    :::magpie
    == pi

The above pattern will match the value &pi; and fail to match otherwise.

### Type Patterns

Now we start to get to the interesting patterns. Often, you'll want to check to see if a value is of a certain [class](classes.html) (or a subclass) in order to tell if an operation is valid. To do that, you can use a *type pattern*. A type pattern starts with the keyword `is` followed by an expression:

    :::magpie
    is String

A type pattern matches if the value is of the given class or one of its subclasses.

### Variable Patterns

To bind values to names, you use *variable patterns*. A variable pattern always successfully matches, and when it does, it creates a new named variable whose value is the matched object. As you'd expect, a variable pattern is just an identifier.

    :::magpie
    name

This pattern matches any value and creates a new variable named `name` when it does. A variable pattern may also have another pattern following it. If it does, the variable pattern will only match if that pattern matches too. For example:

    :::magpie
    name is String

This is a variable pattern containing a type pattern. The entire pattern matches only if the value is a string. If it is, then it will bind the variable `name` to the value.

### Wildcard Patterns

If the name in a variable pattern is `_`, then it's a *wildcard* pattern. It works exactly like a variable pattern except that no variable will actually be created. This can be useful if you want to say "a value goes here" but you don't care what the value is. Like other variable patterns, it may also have an inner pattern.

### Record Patterns

*Record patterns* are the dual to [record *expressions*](records.html). A record pattern contains a series of fields. Each field may have a name, and must have a pattern. When it is tested, it looks for fields in the given value to match all of the pattern's fields. The entire record pattern matches if all of its field patterns match.

    :::magpie
    x: _, y: _

This will match any record with fields `x` and `y`. This is using simple wildcard patterns for the fields, but more complex patterns can be used:

    :::magpie
    x: 1, y: is String

This will match a record whose `x` field is `1` and whose `y` field contains a string. By using variable patterns for the fields, a record can be *destructured* into its component parts.

    :::magpie
    name: n, address: a

This will match a record with `name` and `address` fields. If it matches, it will create new variables `n` and `a` and bind them to the values of those fields.

Like record expressions, record patterns can omit the field names, in which case they'll be inferred by position:

    :::magpie
    x is Int, y is Int

This matches a record with two positional fields whose values are integers and binds the fields. In other words, matching that pattern against `3, 4` will bind `x` to `3` and `y` to `4`.

^title Pragmatics

**TODO**
^title Primitives

Primitives are the built-in object types that all other objects are composed from. They can be created through *literals*, atomic expressions that evaluate to a value.

All primitive values in Magpie are *immutable*. That means that once created, they cannot be changed. `3` is always `3` and `"hi"` is always `"hi"`.

## Booleans

A boolean value represents truth or falsehood. There are two boolean literals, `true` and `false`. Its class is `Bool`.

## Numbers

Magpie has two numeric types, integers and floating-point. Number literals look like you expect:

    :::magpie
    // Ints
    0
    1234
    -5678

    // Floats
    3.14159
    1.0
    -12.34

Integers and floating-point numbers are instances of different classes (`Int` and `Float` respectively) and there are no implicit conversions in Magpie. This means that if you have a [method](multimethods.html) that expects a `Float`, then passing `1` won't work. You'll need to pass `1.0`.

In practice, this is rarely an issue. Most arithmetic operations have specializations for both kinds of numbers and will work fine regardless of what you pass. In cases where mixed argument types are passed, then the result will be a float.

If you want to write code that works generically with either kind of number, then you want the `Num` class. Both `Int` and `Float` inherit from that, so a method specialized to `Num` will accept either type.

## Strings

String literals are surrounded in double quotes:

    :::magpie
    "hi there"

A couple of escape characters are supported:

    :::magpie
    "\n" // Newline.
    "\"" // A double quote character.
    "\\" // A backslash.

Their class is `String`.

## Characters

Characters are instance of the `Char` class and represent the individual Unicode code points that make up strings. When you index into a string or iterate over it, character objects will be returned. They also have a literal form, which is the character surrounded by single quotes:

    :::magpie
    'A'
    '!'

<p class="future">
There will also be escape sequences for characters, but they haven't been implemented yet.
</p>

## Nothing

Magpie has a special primitive value `nothing`, which is the only value of the
class `Nothing`. (Note the difference in case.) It functions a bit like `void`
in some languages: it indicates the absence of a value. An `if` expression with
no `else` block whose condition is `false` evaluates to `nothing`. Likewise, a
method like `print()` that doesn't return anything actually returns `nothing`.

It's also similar to `null` in some ways, but it doesn't have [the
problems](http://journal.stuffwithstuff.com/2010/08/23/void-null-maybe-and-
nothing/) that `null` has in most other languages. It's rare that you'll
actually need to write `nothing` in code since it can usually be inferred from
context but it's there if you need it.

Since `nothing` is in its own class, that means that a method that is [specialized](multimethods.html) to another class won't receive `nothing` instead. In Magpie, you never need to do this:

    :::magpie
    def length(string is String)
        // Make sure we got a string.
        if string == nothing then return 0

        string count
    end

If your method expects a string, you'll get a string, not a string-or-maybe-nothing.

^title Program Structure

Magpie programs are stored in plain text files with a <tt>.mag</tt> file extension. Magpie does not compile ahead of time: programs are interpreted directly from source, from top to bottom like a typical scripting language.

## Comments

Comments are as in C, C++, Java, etc.:

    :::magpie
    some code // This is a line comment.
    // A line comment ends at the end of the line.

    some more /* This is a block comment. */ code code

    /* Block comments
       can span multiple lines. */

Unlike those languages, block comments nest in Magpie. That's handy for commenting out chunks of code which may themselves contain block comments.

    :::magpie
    code /* A /* nested */ block comment */ code code

## Doc Comments

In addition to regular line and block comments, Magpie has a third kind of comment called *documentation comments* or simply *doc comments*. They start with three slashes and proceed to the end of the line.

    :::magpie
    def square(n is Int)
        /// Returns `n` squared.
        n * n
    end

Doc comments are used to document entire constructs: [modules](modules.html), [classes](classes.html), [methods](multimethods.html), etc. Unlike other comments, doc comments are *not* ignored by the language. This means they are only allowed where they are expected: at the beginning of a file, method body, or class definition:

    :::magpie
    defclass Address
        /// A postal address.
        val street
        val city
        val state
    end

Doc comments are formatted using [Markdown](http://daringfireball.net/projects/markdown/) and are intended to be parsed to generate documentation files.

## Reserved Words

Some people like to see all of the reserved words in a programming language in one lump. If you're one of those folks, here you go:

    :::magpie
    and async break case catch def defclass do end else
    false fn for if import in is match not nothing or
    return then throw true val var while xor

Also, the following are *punctuators* in Magpie which means they are both
reserved words and they can be used to separate tokens:

    :::magpie
    ( ) [ ] { } , . .. ...

The only built-in operator is `=`. All other operators are just methods, as explained below.

## Names

Identifiers are similar to other programming languages. They start with a letter or underscore and may contain letters, digits, and underscores. Case is sensitive.

    :::magpie
    hi
    camelCase
    PascalCase
    _under_score
    abc123
    ALL_CAPS

## Operators

Magpie does not have many built-in operators. Instead, most are just [methods](multimethods.html) like any other method. However, the grammar of the language does treat them a bit specially.

Lexically, an operator is any sequence of punctuation characters from the following set:

    :::magpie
    ~ ! $ % ^ & * - = + | / ? < >

Also, the special tokens `..` and `...` are valid operator names. But a `=` by itself is not&mdash;that's reserved for [assignment](variables.html#assignment).

<p class="future">
The exact set of operator characters is still a bit in flux.
</p>

These are all valid operators:

    :::magpie
    +
    -
    *
    ?!
    <=>&^?!

When expressions are parsed, infix operators have the same precedence that you expect from other languages. From lowest to highest:

    :::magpie
    = !
    < >
    .. ...
    + -
    * / %

Every operator on the same line above has the same precedence. If an operator has multiple characters, the first determines the precedence. So this (unreadable) expression:

    :::magpie
    a +* b *- c <!! d !> e %< f

Will be parsed like:

    :::magpie
    (((a +* (b *- c)) <!! d) !> (e %< f))

The goal here is to have code that works more or less like you expect coming from other languages while still being a little more open-ended than those languages.

## Newlines

Like many scripting languages, newlines are significant in Magpie and are used to separate expressions. You can keep your semicolons safely tucked away.

    :::magpie
    // Two expressions:
    print("hi")
    print("bye")

To make things easier, Magpie will ignore a newline in any place where it
doesn't make sense. Specifically, that means newlines following a comma (`,`), equals (`=`), backtick (<code>\`</code>), or infix operator (`+`, `-`, etc.) will be discarded:

    :::magpie
    val a = 1,
            2 // a will be the record (1, 2).

    val b = 1 +
            2 // b will be 3.

    val c = true and
            false // c will be false.

If you specifically want to ignore a newline where it otherwise *would* separate two expressions, you can end the line with a backslash (`\`):

    :::magpie
    val a = foo
    bar()
    // Sets a to foo then calls bar()

    val a = foo \
    bar()
    // Equivalent to:
    // var a = foo bar()

^title Records

Sometimes you need a little bundle of values where only a single one is expected. Maybe you want a division method that returns both the dividend *and* the remainder. To support this and much much more, as we'll see, Magpie has *records*. Records are anonymous, immutable composite objects.

Two little bits of syntax are used for them: fields and commas.

    :::magpie
    x: 1, y: 2

Here, we've created a record with two fields, `x` and `y`. A piece of text followed by a colon like `x:` defines a field. Any sequence of fields followed by expressions separated by commas defines a record. Note that the colon is part of the actual field token. This means you can use reserved names in fields, like `if:`, but also means you *can't* have a space before the `:` like `x :`.

## Accessing Fields

Once you have a record, you will likely need to pull it back apart. To do that, you'll use [pattern-matching](pattern-matching.html):

    :::magpie
    val point = x: 1, y: 2
    val x: a, y: b = point
    print(a + b) // 3

Record expressions and record [patterns](patterns.html) are duals of each other. Record expressions combine several values into a single object, and record patterns split those values back out.

## Positional Fields and Tuples

You can omit the field name, in which case the name will be inferred from its position. These lines are all equivalent:

    :::magpie
    0: "peanut butter", 1: "jelly
    "peanut butter", 1: "jelly
    "peanut butter", "jelly"

In other words, records in Magpie subsume both named records and [tuples](http://en.wikipedia.org/wiki/Tuple) in other languages. Records are first class values like any other [object](objects.html) which means they can be put into variables or passed to [methods](multimethods.html):

    :::magpie
    val point = x: 2, y: 3
    drawPoint(x: 2, y: 3)

In fact, *any* time you call a method that takes "multiple" arguments, you're actually just passing a record. Records are used pervasively through the language. Every time you see a comma in code, you're seeing a record or a record [pattern](patterns.html). (There's one exception, [lists](lists.html) use commas to separate elements too.)

^title The Heart of Magpie

Every creative work betrays the author's beliefs about his fellow humans, and his desires about how the world should be. Some call these the "principles" by which a system is designed, but principles are uncomfortably close to dogma for my taste.

Instead, I'll call the guidelines below the "Heart of Magpie". If you talk to
programmers, you'll note that many have an emotional, personal relationship with
the languages they use. Learning a new language is a bit like finding out if a
partner is compatible with you, so consider this Magpie's answer to the language
dating game:

## A programming language should be a medium of intent.

Imagine you're writing a function. You document what you intend the code to do
at a high level in some sort of pseudo-code and then you write the actual code.
The difference between those two blocks of text is a measure of the failure of
expressiveness in a language.

As much as possible, you should be able to define your own abstractions such that the code you write looks exactly like you would write on a whiteboard to explain to a colleague. The code should read like you think about your problem. Magpie should speak your language and not vice versa.

## Don't force users to predict the future.

In Java, it's standard practice to wrap all of your fields in getters and setters. That way, if in the future it turns out you need to do some calculation or validation, you won't have to touch every place that field is accessed.

Magpie tries to prevent you from needing to do speculative work like that. You
should be able to write code simple today that solves today's problems. Later,
when the problems change, the decisions you made then shouldn't come back to
haunt you.

This means following [uniform
access](http://en.wikipedia.org/wiki/Uniform_access_principle) so that built-in
default behavior today (such as accessing a field or assigning to a collection)
can be upgraded to a user-defined abstraction later without affecting every
callsite.

It also means allowing existing constructs to be extended and modified. You should be able add new methods that work naturally with existing classes and feel as built-in as ones that were created when that class was.

## Give users power and trust them to use it well.

If smart users can't come up with things in Magpie that I didn't anticipate,
I've failed to design a sufficiently powerful language. To be long-lasting, a
language must be able to solve more than just the problems we know of today.
That means we have to be open to the language surprising us (but hopefully
mostly in pleasant ways).

"It's too powerful" should not be sufficient reason to deny users a feature. It's the scared, incompetent and cynical that are drawn to harmless things, and are those the people we want to surround ourselves with? We shouldn't minimize danger by removing powerful tools altogether, instead we should design them well such that they're easy and safe to use.

## Prefer defining things in the library over in the language.

One test of a language's power and expressiveness is seeing how many useful abstractions can be implemented just at the library level and don't require specific language support. The more you can do at the library level, the more power you've put in the hands of all users instead of just giving magical abilities to the language designers. Pushing things out to the library also gives a few very practical benefits:

* This simplifies the core language, which makes it easier to specify and
  implement.
* Libraries can evolve faster than a language can. This can increase the
  shelf-life of the language and give users a greater ability to explore
  different ways of expressing things.
* It makes it easier to port the language to other platforms. The more features
  that are written in the language itself, the less there is that needs to be
  written in the host language.

^title Top-Level Definitions

**TODO: Explain mutual recursion, and accessing undefined top-level variables.**
^title Tutorial

If this is your first time looking at Magpie (and let's be honest, it probably is), this little tutorial will walk you gently through its garden of features. Before we get started, make sure you've got Magpie [installed and running](index.html).

**TODO**
^title Variables

Variables are named slots for storing values. You can define a new variable in Magpie using the `var` keyword, like so:

    :::magpie
    var a = 1 + 2

This creates a new variable `a` in the current scope and initializes it with the result of the expression following the `=`. Like everything, a variable definition is an expression in Magpie. It evaluates to the initialized value.

    :::magpie
    print(var a = "hi") // prints "hi"

Once a variable has been defined, it can be accessed by name as you would expect.

    :::magpie
    var name = "Abraham Lincoln"
    print(name) // prints "Abraham Lincoln"

## Patterns

In our previous examples, the part between `var` and the `=` has always been a simple name, but what you're seeing there is actually a [pattern](patterns.html). That means any pattern is allowed in a declaration. A simple case is what other languages call "multiple assignment".

    :::magpie
    var x, y = 1, 2
    print(x + ", " + y) // 1, 2

Here, the record pattern `x, y` is used to destructure the record `1, 2`, pulling out the fields into separate variables. More complex nested records also work.

    :::magpie
    var coloredPoint = (position: (2, 3), color: "red")
    var position: (x, y), color: c = coloredPoint
    print(x + ", " + y + " " + c) // 2, 3 red

Here we're destructuring a nested record in the same way. Patterns that test values are supported as well.

    :::magpie
    var good is String = "a string"
    var bad is String = 123

The first line of this will execute without a problem, but the second line will throw a `NoMatchError` because `123` is not a string.

(One way to think of variable definitions is as [match](pattern-matching.html) expressions with one case whose body is the rest of the current scope.)

## Scope

A variable in Magpie has true block scope: it exists from the point where it is defined until the end of the [block](blocks.html) where that definition appears.

    :::magpie
    do
        print(a) // ERROR! a doesn't exist yet
        var a = 123
        print(a) // "123"
    end
    print(a) // ERROR! a doesn't exist anymore

All variables are lexically scoped. There is no single global scope in Magpie. Instead, each [module](modules.html) has its own top-level scope that isn't shared with other modules.

Declaring a variable in an inner scope with the same name as an outer one is called *shadowing* and is not an error (although it's not something you likely intend to do much).

    :::magpie
    var a = "outer"
    if true then
        var a = "inner"
        print(a) // Prints "inner".
    end
    print(a) // Prints "outer".

Declaring a variable with the same name in the *same* scope *is* an error.

    :::magpie
    var a = "hi"
    var a = "again" // ERROR!

## Assignment

After a variable has been declared, you can assign to it using `=`.

    :::magpie
    var a = 123
    a = 234

An assignment will walk up the scope stack to find where the named variable is declared. It's an error to assign to a variable that isn't defined. Magpie doesn't roll with implicit variable definition.

Like variable definition, an assignment expression returns the assigned value.

    :::magpie
    var a = "before"
    print(a = "after") // Prints "after".

You can use can also use record pattern syntax to destructure when assigning to existing variables.

    :::magpie
    var a, b = 1, 2
    a, b = 3, 4
    print(a + ", " + b) // Prints "3, 4".

## Single-Assignment Variables

The variables we've seen so far all allow assignment. You can prevent that by defining them using `val` instead of `var`.

    :::magpie
    val a = "before"
    a = "after" // ERROR!

Single-assignment variables can make code easier to understand since you don't have to hunt around and see if they ever gets reassigned. Arguments to [methods](multimethods.html), variables bound in [pattern match expressions](pattern-matching.html), and [loop iterators](looping.html) are always defined as single-assignment.

The website for Magpie is generated from a tree of markdown files by a little Python script. It uses Pygments with a custom lexer for Magpie. To get the lexer visible to markdown, it needs to be installed. The easiest way is to do:

  <from repo root dir>
  $ cd docs/site/magpie
  $ python setup.py develop

Then the site can be generated by doing:

  $ cd ..
  $ python generate-docs.py
  
That will create an "html" directory in the current directory with the entire site.

This stuff is still under development! To do:
* Create a correct breadcrumb trail on the top of each page.
* Set the page title correctly.
* Add lots more docs.
This directory contains the Magpie "standard library". When a module is
imported, it will look for it starting in the current working directory (i.e
the directory of the initial Magpie script that is being executed). If not
found there, it will look here.



                              _/Oo>
                             /(MM)
                            A___/       m a g p i e
                    _______AV_h_h___________________________
                          AV
                         AV
                        AV


Magpie is a small dynamically-typed programming language built around patterns,
classes, and multimethods. It has a prototype interpreter that runs on the JVM
and an in-progress bytecode VM written in C++.

It looks a bit like this:

    // Generates the sequence of turns needed to draw a dragon curve.
    // See: http://en.wikipedia.org/wiki/Dragon_curve
    def dragon(0, _)
        ""
    end

    def dragon(n is Num, turn)
        dragon(n - 1, "R") + turn + dragon(n - 1, "L")
    end

    print(dragon(5, ""))

Its goal is to let you write code that's beautiful and easy to read, and to
allow you to seamlessly extend the language and libraries as you see fit.

You can learn more about the language at http://magpie-lang.org/.

## Getting Started

Magpie has two implementations right now. There is a prototype interpreter
written in Java. This supports more of the language, but is (of course) tied to
the JVM and is *much* slower. It's main job was to let me iterate on the
language semantics quickly.

Now that the language has (mostly) settled down, I've started writing a
bytecode VM in C++. This is the "real" Magpie implementation, but it's still a
work in progress. All current development is going on here. The Java interpreter
is mainly a reference.

### Building the Bytecode VM

1.  **Pull down the code.** It lives here: https://github.com/munificent/magpie

2.  **Generate a project.** From the root directory of the magpie repo:

        $ cd <path to magpie repo>
        $ ./run_gyp

3.  **Set the output directory (XCode 4 only).** Recent versions of XCode build
    into some shared directory not related to where the project is. This borks
    Magpie since it's a command-line executable that loads the core library
    from a path relative to that executable.

    Unfortunately, this setting isn't in the project itself, so gyp can't help.
    After you generate the project, open it in XCode, then:

    1. Choose "File > Project Settings...".
    2. On the "Build" tab, click "Advanced...".
    3. Set "Build Location" to "Custom > Relative to Workspace".
    4. Set "Products" to `build`.
    5. Set "Intermediates" to `build/Intermediates`.
    6. Click "Done".

    This should ensure that Magpie gets built into `build/<config>/magpie`.

4.  **Build the project.** Do what you usually do on your OS to build the thing.
    On Mac, that means open the XCode project and build from there. In Windows,
    there is a Visual Studio solution you can build. On Linux, you can just run
    `make`.

[gyp]: http://code.google.com/p/gyp/

### Building the Java Interpreter

1.  **Pull down the code.** It lives here: https://github.com/munificent/magpie

2.  **Build it.** The repo includes an Eclipse project if that's your thing. If
    you rock the command-line, you can just do:

        $ cd magpie
        $ ant jar

### Running Magpie

Magpie is a command line app. After building it, you can run it by doing:

        $ ./magpie

This will run the Java interpreter or the bytecode VM, whichever is more recent.

If you run it with no arguments, it drops you into a simple REPL. Enter a
Magpie expression and it will immediately evaluate it. Since everything is an
expression, even things like class definitions, you can build entire programs
incrementally this way. Here's one to get you started:

    for i in 1..20 do print("<your name> is awesome!")

If you pass an argument to the app, it will assume it's a path to a script
file and it will load and execute it:

    $ ./magpie example/hello.mag

This directory contains Magpie's executable specification. The spec is a Magpie
program that should be easily human readable, but also machine verifiable. If a
Magpie interpreter can run the spec without errors, it is a conforming
implementation.

At least, that's the plan. The spec still needs a lot of filling in, but it's
getting there.

--- Executing the Spec ---------------------------------------------------------

You can run the spec to see how the interpreter measures up by running init.mag.
It will write the results to stdout.

