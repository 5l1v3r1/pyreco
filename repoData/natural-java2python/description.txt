## Customization

The java2python compiler defers a significant amount of its processing to
handlers defined within configuration files.  These configuration files,
directories, and modules are supplied to the `j2py` script on the command
line. See the [usage][] page for instructions on specifying additional configs.

The default configuration module is `java2python.config.default`.  Refer to
[the source of that module][1] for details and additional descriptions.


### Usage

To change the behavior of some or all of these config items, create a Python
file, define in it the items you want, and specify that file when invoking
`j2py`.

For example, if you would like to change the comment prefix to `##`, you might
do this:

    $ echo "indentPrefix = '##'" >> ./myconfig.py

Then run the script:

    $ j2py SomeJavaSource.java -c ./myconfig.py 

The config files are Python modules, so you can use the full power of Python
when writing them.


### Defaults

Many of the defaults are built using values imported from the
`java2python.mod.basic` module.  Refer to the [source of that module][2] for
details.  The `java2python.mod` subpackage contains other modules with
additional config handlers.


### A Note About Some of the Names:  Prologue, Base, Head, and Epilogue

When a config point has `Prologue` in its name, it means that the item will be
responsible for generating code before the output.  For example, method
prologue handlers generate decorators, while module prologue handlers generate
the shebang line.

When a config point has `Base` in the name, it means that the item will be
responsible for generating the base classes of a class, enum, or interface.

A config point with `Head` in the name means that the item will be responsible
for generating code for the section between the declaration and the body of the
item.  For example:

    class X(object):
        """ this is a comment generated by classHeadHandlers """

Finally, when a config point contains `Epilogue`, it means that the item will
be responsible for generating code after the body of the item.  The only
recognized epilogue config point is `moduleEpilogueHandlers`, which (by
default) generates a main script stanza if necessary.


### Override vs. Replace

Many of the config handlers in the default config module are lists or
dictionaries.  It may be desirable for your project to supplement or modify
these instead of changing them completely.  For example, you could add a module
prologue handler to the existing values.  To do so, you would do something like this
in your config:

    from java2python.config.default import modulePrologueHandlers

    def myPrologue(module):
        ...
        
    modulePrologueHandlers.append(myPrologue)
    
Values can be removed in a similar way:

    from java2python.config.default import modulePrologueHandlers
    from java2python.mod import basic

    modulePrologueHandlers.remove(basic.shebangLine)

In other cases, you can simply redefine the config value altogether:

    classHeadHandlers = [myCustomDocStringGenerator]


### Customization Points

The remainder of this page lists the recognized config points, their meaning,
and their default values.


#### <a name="indentPrefix"></a>indentPrefix

Leading indent character or characters.  Four spaces are the default because
that is the recommendation of [PEP 8][].

Default:  `    ` (four spaces)


#### <a name="commentPrefix"></a>commentPrefix

Prefix character or characters for comments.  The hash+space is recommended by
[PEP 8][].

Default:  `# ` (hash + space)


#### <a name="expressionVariableNamingHandler"></a>expressionVariableNamingHandler

When the compiler needs to make up a variable name (for example, to emulate
assignment expressions), it calls this handler to produce a new one.

Default:  `basic.globalNameCounter`


#### <a name="modulePrologueHandlers"></a>modulePrologueHandlers

These values are strings or generators that yield strings for a module
prologue.

Default:
```
[basic.shebangLine,
 basic.simpleDocString,
 basic.maybeBsr,
 basic.maybeSyncHelpers
]
```


#### <a name="moduleEpilogueHandlers"></a>moduleEpilogueHandlers

These generators yield lines for a module epilogue.

Default: `[basic.scriptMainStanza]`


#### <a name="moduleOutputHandlers"></a>moduleOutputHandlers

These generators yield (possibly modified) source strings for a module.  The
default handler uses values defined elsewhere in the config, e.g.,
`moduleOutputSubs`.

Default: `[basic.outputSubs]`


#### <a name="modulePackageDeclarationHandler"></a>modulePackageDeclarationHandler

This config item is called to handle package declarations.  The default handler simply
turns those declarations into comments.

Default: `basic.commentedPackages`


#### <a name="moduleImportDeclarationHandler"></a>moduleImportDeclarationHandler

This config item is called to handle import statements.  The default handler
transforms the import statements into Python imports.

Default:  `basic.simpleImports`


#### <a name="moduleOutputSubs"></a>moduleOutputSubs

Mapping of input/output regular expressions used during the final pass of
source generation.

Default: refer to the [java2python.config.default][1] module.


#### <a name="classHeadHandlers"></a>classHeadHandlers

These generators yield doc values for the head of classes.

Default: `[basic.simpleDocString]`


#### <a name="classBaseHandlers"></a>classBaseHandlers

These generators yield the base types (as strings) for classes.

Default: `[basic.defaultBases]`


#### <a name="classPostWalkHandlers"></a>classPostWalkHandlers

These handlers are called with each class object after it has been completely
constructed.

Default: `[]`


#### <a name="interfaceBaseHandlers"></a>interfaceBaseHandlers

These generators yield the base types (as strings) for interfaces.

Default: `[basic.defaultBases]`


#### <a name="interfaceHeadHandlers"></a>interfaceHeadHandlers

These generators yield doc values for the head of interfaces.

Default:  `[basic.simpleDocString, '__metaclass__ = ABCMeta']`


#### <a name="enumHeadHandlers"></a>enumHeadHandlers

These generators yield doc values for the head of enums.

Default: `[basic.simpleDocString]`


#### <a name="enumValueHandler"></a>enumValueHandler

This handler is responsible for creating enum values on classes after they've
been defined.

Default:  `basic.enumConstStrings`


#### <a name="methodParamHandlers"></a>methodParamHandlers

This handler is responsible for constructing method parameters.

Default: `[basic.defaultParams]`


#### <a name="methodLockFunctionName"></a>methodLockFunctionName

This is the name of the callable used to construct locks for an object with the
synchronized keyword.

Default: `'lock_for_object'`


#### <a name="methodHeadHandlers"></a>methodHeadHandlers

These generators yield values for the head of classes.

Default: `[basic.simpleDocString]`


#### <a name="methodPrologueHandlers"></a>methodPrologueHandlers

These generators yield values for the module prologue.

Default:

```
[basic.maybeAbstractMethod,
 basic.maybeClassMethod,
 basic.maybeSynchronizedMethod,
 basic.overloadedClassMethods,
]
```

#### <a name="astTransforms"></a>astTransforms

The AST transformer uses these declarations to modify an AST before compiling
it to Python source.

Default: refer to the [java2python.config.default][1] module.

#### <a name="typeSubs"></a>typeSubs

Many Java identifiers have a 1:1 relationship with Python identifiers, and this
mapping is used to convert them when found.  Note that this mapping is now
unnecessary and will be folded into the `astTransforms` sequence in future
releases.

[1]: https://github.com/natural/java2python/blob/master/java2python/config/default.py
[2]: https://github.com/natural/java2python/blob/master/java2python/mod/basic.py
[PEP 8]: http://www.python.org/dev/peps/pep-0008/
[usage]: https://github.com/natural/java2python/tree/master/doc/usage.md

## Installation

### New School

Kids these days have it easy:

    # pip install java2python

### Old School

#### Install ANTLR Runtime

We need the ANTLR Python runtime before we can install java2python:

    # wget http://www.antlr.org/download/antlr-3.1.3.tar.gz
    # tar xfz antlr-3.1.3.tar.gz
    # cd antlr-3.1.3/runtime/Python/
    # python setup.py install

#### Install java2python

Now the goodness:

    # wget https://github.com/downloads/natural/java2python/java2python-0.5.1.tar.gz
    # tar xfz java2python-0.5.1.tar.gz
    # cd java2python
    # python setup.py install

### Development Version

The latest source can be installed directly from github:

    # pip install --upgrade https://github.com/natural/java2python/zipball/master

You'll want to clone or fork the repo to work on the project, however.


### Dependencies

The runtime dependency for java2python is the [Python runtime][] for [ANTLR][].
The exact version number is very important: java2python requires
[version 3.1.3 of the Python runtime][].

The development dependencies (what you need if you're coding java2python) are
[ANTLR][], also version 3.1.3, GNU make, and a JVM.


[version 3.1.3 of the Python runtime]: http://www.antlr.org/download/antlr-3.1.3.tar.gz
[Python runtime]: http://www.antlr.org/wiki/display/ANTLR3/Python+runtime
[ANTLR]: http://www.antlr.org

## Introduction

This is an introduction.  Just like the title told you it would be.

### What it Does

java2python reads the Java source files you give it and produces somewhat
roughly equivalent Python source code.  It tries to make the same decisions you
would if you were porting the code manually.  It can perform the translation
faster and more accurately than you could (usually).

### Where It's Useful

java2python can help in two situations.  First, if you're doing a one-time port
of a Java project to Python, it can save you a lot of time and effort by
getting you really far really fast.

Second, if you've got a Java project and you'd like to generate a Python port
and keep the port up to date, you'll find that java2python can help
tremendously.  The per-project and per-file configuration system helps out a
lot in this area.

### Where It's Not

Where java2python is not useful is also important.  It won't be useful to you
if you expect your newly translated Python code to run correctly the first
time.  The platforms are too different and this tool is too limited for that to
happen.  Also, you won't find java2python very useful if you expect to convert
Java sources at runtime.  I suppose you could try, but I wouldn't.

### How it Works

java2python first converts the source code you give it into an abstract syntax
tree.  (That's a lie, really.  java2python doesn't do this step, [ANTLR][] does
this step, and [ANTLR][] is a whole lot bigger and cooler than java2python
could ever be.  Obviously, really smart people worked on [ANTLR][] and only one
fairly dim one worked on java2python).

After the syntax tree is constructed, it's walked and its nodes are converted
to their Python equivalents.  When the walking is complete, java2python takes a
few more swipes at it and prints it out.  It's all very boring, like geology or
watching someone learn to play the xylophone.

This is all well and good for most cases where there exists a very similar
Python construct for the given Java construct.  Classes, for example, are
pretty much the same in both languages.  The trouble spots are places where a
construct exists in Java that is not readily available in Python.

Note: yes, of course, we're dealing with Turing Machines and they're
equivalent.  If it works in Java, it can work in Python, and I'm not saying
that it can't.  But what I am saying is that there are chunks of Java source
code that you can't make into nice and neat and obvious Python equivalents.

To get around these trouble spots, java2python takes the approach of trying
make the problem go away.  For example, in Java the `if` statement can contain
an assignment expression:

```java
if (++x == 0) { ... }
```

There isn't a single statement equivalent in Python because assignments are
statements there, not expressions.  So java2python does what it can, presumably
what you would do:

```python
x += 1
if x == 0:
    ...
```

Careful readers will have spotted just how close we came to driving over a
cliff with that `++x` expression.  If the increment had been done on the other
side of the variable, the meaning of the statement would have changed and the
Python code would have been wrong.  Fortunately, I've driven by lots of cliffs
and have been scared by all of them so I thought of this ahead of time and
decided to do something about it:

```java
if (x++ ==0) { ... }
```

will translate to:

```python
mangled_name_for_x = x
x += 1
if mangled_name_for_x == 0:
    ...
```

See what java2python did there?  It tried to do what you would do.  For further
explanation and enumeration see the [translation details][] page.


### Why Bother?

I bothered to write this because [I needed a Java package][1] to run on the CPython
interpreter.  I got tired of porting by hand so I wrote this instead.  And
it's an interesting problem (kind of).


[ANTLR]: http://www.antlr.org
[translation details]: https://github.com/natural/java2python/tree/master/doc/translation.md
[1]:  http://roundrockriver.wordpress.com/2007/02/15/automated-translation-of-java-to-python/

## Documentation

#### Introduction

The [Introduction][] provides a brief overview of the package. You should read
this first.

#### Installation

The [Installation][] doc describes how to install the package.

#### Translation Details

The [Translation Details][] page documents how the package translates Java
syntax to Python.

#### Usage

The [Usage][] page explains how to run the `j2py` script.


#### Customization

The [Customization][] doc describes how to customize translation behavior.


#### Tests

The [Tests][] page documents the test suite.


[Customization]: https://github.com/natural/java2python/tree/master/doc/customization.md
[Installation]: https://github.com/natural/java2python/tree/master/doc/install.md
[Introduction]: https://github.com/natural/java2python/tree/master/doc/intro.md
[Translation Details]: https://github.com/natural/java2python/tree/master/doc/translation.md
[Usage]: https://github.com/natural/java2python/tree/master/doc/usage.md
[Tests]: https://github.com/natural/java2python/tree/master/doc/tests.md

## Tests

The java2python package includes a [test suite][] for exercising the compiler and
its various translation features.  This doc explains how the tests work, how to
run these suite, and how to add new tests to it.

### How the Test Suite Works

The test suite is a [makefile][] that finds `.java` files in the same directory,
converts each to Python, runs both programs, and then compares their output.  If
the output matches, the test is considered successful.  If not, it's considered
a failure.

### How to Run the Test Suite

The simplest way to run the suite is to run all of it:

```bash
$ cd some_path_to/java2python/test
$ make
```

This will print lines like this:

```
...
[PASS] Class00
[PASS] Class01
[PASS] Class02
...
```

You can also run an individual test like this:

```bash
$ make Class02
[PASS] Class02
```

Notice that there isn't a suffix to the file name; you don't run `make
Class02.java`, just `make Class02`.  If you supply an extension, nothing will
happen and the test won't run.

The `test` directory contains two helper scripts that you can use during
development.  The first is [runjava][], which runs the Java compiler and the
Java VM with the indicated file.  Use it like this:

```bash
$ ./runjava Class01.java
Hello, world.
```

The second script is [runj2py][], which is a handy shortcut for running the
`j2py` script with preset command line arguments for the test configuration.
You run it like this:

```bash
$ ./runj2py Class01.java
#!/usr/bin/env python
""" generated source for module Class01 """
class Class01(object):
...
```

### Adding New Tests

When a new compiler feature is added, or when the translation semantics change,
it's a good idea to add one or more tests to the test suite.  Follow this
general outline:

1.  Create a Java source file that exhibits the language feature in question.

2.  Name the Java source file `FeatureNN` where `NN` is the next number in
sequence for `Feature`, e.g., `Class14.java`.

3.  In your Java source, write one or more values to stdout with
`System.out.println`.

4.  Check the comparison via `make FeatureNN`.  If the test passes, it might
indicate the new feature is working correctly.

[test suite]: https://github.com/natural/java2python/tree/master/test/
[makefile]: https://github.com/natural/java2python/blob/master/test/Makefile
[runjava]: https://github.com/natural/java2python/blob/master/test/runjava
[runj2py]: https://github.com/natural/java2python/blob/master/test/runj2py

## Translation Features


### General Approach

The approach taken by java2python is to favor readability over correctness.

### Identifiers and Qualified Identifiers

java2python copies identifiers from source to target, modifying the value only
when:

  * the identifier conflicts with a Python keyword or builtin, or
  * the identifier has an explicit lexical transformation


### Literals: Integer, Floating Point, Character, String, Boolean and Null

Literals are copied from source to target with the following modifications:

  * `null` is changed to `None`
  * `false` is changed to `False`
  * `true` is changed to `True`
  * if necessary, floating point literals are changed to valid Python values
  * string and character literals are changed to Python strings

Transformation of literal values happens at the AST level; see the
[`astTransforms`][1] configuration value for details.

### Expressions

#### Constant Expressions

Constant expressions are translated to their Python equivalents.

#### Ternary Expressions

Ternary expressions are translated to their Python form (`val if condition else
other`)


#### Prefix Operators

All of the Java prefix operators are supported:

        ++    --    !    ~    +    -

In the case of `++` and `--`, java2python translates to `+= 1` and `-= 1`.  If
necessary, those expressions are moved outside of statements.

#### Assignment Operators

All of the following assignment operators are translated into their Python
equivalents:

    =    +=    -=    *=    /=    &=    |=    ^=    %=    <<=    >>=

The bit shift right (`>>>`)and bit shift assign right (`>>>=`) operators are
mapped to a function; if java2python detects code that uses either of these, it
replaces the operator with that function and includes the function within the
output.  This behavior is controlled by the [`modulePrologueHandlers`][6] config
handler.

#### Infix Operators

The following operators are translated to their Python equivalents:

    ||    &&    |    ^    &    ==    !=    <    >
    <=    >=    <<   >>   >>>  +     -     *    /    %

Refer to the note above regarding bit shift right.

### Basic Types

The basic Java types are mapped to Python types as follows:

*    `byte`, `short`, `int`, and `long` become `int`
*    `char` becomes  `str`
*    `float` and `double` become `float`
*    `boolean` becomes `bool`

#### Arrays

Java arrays and array access expressions are translated to their Python
equivalents.


### Types, Interfaces, Enums

Java classes, interfaces, and enums are translated into Python classes.

In the case of interfaces, the strategy is configurable.  By default,
interfaces are translated to classes utilizing the `ABCMeta` class.  The
package includes config handlers that can translate to simple classes
(inheriting from `object`), or from Zope Interfaces.  Interface base types are
controlled via the [`interfaceBaseHandlers`][2] config item.  The
[`interfaceHeadHandlers`][3] config item controls the metaclass.

Enums are also translated via a configurable strategy.  By default, enumerated
values are created as class attributes with string values.  The package
includes a config handler to create class attributes with integer values.  The
config handler that controls enumeration value construction is
[`enumValueHandler`][4].


### Statements

#### assert

Java `assert` statements are translated to equivalent Python `assert`
statements.

#### if

Java `if` statements are translated to equivalent Python `if` statements.

#### import

The processing import statements is delegated to the [`moduleImportDeclarationHandler`][9].

#### for

Java `for` statements are translated to equivalent Python `for` statements.

#### while and do

Java `while` and `do` statements are translated to equivalent Python `while`
statements.

#### try and catch

Java `try` and `catch` statements are translated to equivalent Python `try` and
`except` statements.

#### switch and case

Java `switch` and `case` statements are translated to equivalent Python `if`
statements.

#### synchronized

In the case of a `synchronized` method or static method, the compiler will
include a decorator, `@synchronized` in the method or static method preamble.
In the case of a `synchronized` block, the compiler will translate to this
form:

    with lock_for_object(expr):
        ...

The `lock_for_object` callable is the default and can be controlled via the
[`methodLockFunctionName`][5] config item.  Also of note, the default
[`modulePrologueHandlers`][6] uses a generator named `maybeSyncHelpers` to include
Python helper code for synchronization.

#### return

Java `return` statements are translated to equivalent Python `return`
statements.


#### throw

Java `throw` statements are translated to equivalent Python `raise` statements.

#### break

Java `break` statements are translated to equivalent Python `break` statements.
However, a Java `break` statement with an identifier (e.g., `break FOO`) is not
supported.  If the compiler detects such a statement, a warning will be printed
and the translated source will not contain the original label.

#### continue

Java `continue` statements are translated to equivalent Python `continue`
statements.  However, a Java `continue` statement with an identifier (e.g.,
`continue FOO`) is not supported.  If the compiler detects such a statement, a
warning will be printed and the translated source will not contain the original
label.


### Other Keywords

#### this

The `this` Java keyword is translated to the Python pseudo keyword `self`.

#### instanceof

The `instanceof` Java keyword is translated to the `isinstance(…)` Python
function call.

#### super

The Java keyword `super` is translated to the `super(…)` Python function call.

#### .class

The compiler translates Java `.class` expressions to `.__class__` attribute
references.

#### void

The Java keyword `void` is typically discarded by the compiler.  In the case of
the `void.class` form, the compiler translates the expression to
`None.__class__`.


### Annotations

Annotations are typically dropped by the compiler.  The following Java
annotations have little or no meaning in Python and are discarded:

    public    protected    private    abstract    final    native    transient
    volatile  strictfp

#### static

The `static` annotation is translated to a `@classmethod` decorator for the
corresponding method.

#### synchronized

When used as a method or static method annotation, the `synchronized` keyword
is translated to a `@synchronized` method decorator.  This behavior is
controllable via the [`methodPrologueHandlers`][7] config item.

See the note above regarding the use of `synchronized` within blocks.

### Comments

Both Java end-of-line comments and multi-line comments are translated to Python
comments.  The comment prefix is `# ` (hash plus space) by default, and is
controllable via the [`commentPrefix`][8] config item.

#### JavaDoc

JavaDoc comments are preserved as Python comments.


### References

Java language specification:  http://java.sun.com/docs/books/jls/third_edition/html/syntax.html


[1]: https://github.com/natural/java2python/tree/master/doc/customization.md#astTransforms
[2]: https://github.com/natural/java2python/tree/master/doc/customization.md#interfaceBaseHandlers
[3]: https://github.com/natural/java2python/tree/master/doc/customization.md#interfaceHeadHandlers
[4]: https://github.com/natural/java2python/tree/master/doc/customization.md#enumValueHandler
[5]: https://github.com/natural/java2python/tree/master/doc/customization.md#methodLockFunctionName
[6]: https://github.com/natural/java2python/tree/master/doc/customization.md#modulePrologueHandlers
[7]: https://github.com/natural/java2python/tree/master/doc/customization.md#methodPrologueHandlers
[8]: https://github.com/natural/java2python/tree/master/doc/customization.md#commentPrefix
[9]: https://github.com/natural/java2python/tree/master/doc/customization.md#moduleImportDeclarationHandler

## Usage

This page describes how to invoke the java2python script, `j2py`.


### Basic Use

The simplest way to use java2python is with the `j2py` command
and the name of an input file and output file:

```bash
$ j2py [INPUT] [OUTPUT]
```

Both are optional, but you'll usually supply an input file:

```bash
$ j2py SourceFile.java
```


### Options and Arguments

The `j2py` command accepts options that alter its behavior.
The behavior of the code generator is not part of the command itself;
to change code generation behavior, refer to the [customization][]
page.


#### Code Generation

  * `[INPUT]`

    Read from the given file.  Specify `-` for `stdin`.  If not
    given the command will read from `stdin`.
    
    If `[INPUT]` is a directory, the script will walk the directory looking for
    files named `.java`, and transform each one.  If `[OUTPUT]` is also a
    directory, the directory structure of `[INPUT]` will be recreated below it.
    
    If `[INPUT]` is a directory, `[OUTPUT]` must also be a directory, or it may
    be `-` or unspecified.

  * `[OUTPUT]`

    Write to the given file.  Specify `-` for `stdout`.  If not
    given the command will write to `stdout`.

  * `-l LEVEL`, `--log-level LEVEL`

    Set the logging package to the specified log level.  The log level
    may given as an integer (e.g., `50` for critical) or by name
    (e.g., `CRITICAL`, `Critical`, or `critical`).

  * `-c NAME`, `--config NAME`

    Use the specified configuration module or file.  This option may
    be repeated.

    Configuration modules/files are referenced in reverse order, i.e.,
    from the final value given to the first given, with the default
    configuration referenced last.

    See the [customization][] page for details of the
    configuration system and available configuration points.

  * `-d DIR`, `--config-dir DIR`

    Use the given directory name to match input file names to
    configuration file names.  This option may be repeated.
    
    For example, to translate
    `FooBar.java` and use the configuration stored in
    `./cfg/FooBar.py`, specify `-d ./cfg`.

  * `-k`, `--skip-compile`

    Do not byte compile the output to test for valid Python syntax.

  * `-n`, `--no-defaults`

    Ignore the default configuration module.

  * `-r`, `--no-color`

    Disable colorized output.

    Colorized output is not available on Windows and this option is ignored
    there.


#### Development

  * `-p`, `--python-tree`

    Print a representation of the internal Python code tree.
    Representation is written to `stderr`.

  * `-j`, `--java-ast`

    Print a representation of the Java abstract syntax tree.
    Representation is written to `stderr`.

  * `-f`, `--profile`

    Profile execution and print the results to `stderr`.

  * `-s`, `--skip-source`

    Do not write generated source.  This most useful in development of
    java2python itself and when combined with `-p` and/or
    `-j`.


#### Meta

  * `-h`, `--help`

    Show a help message and exit

  * `-v`, `--version`

    Show the program version number and exit.



[customization]: https://github.com/natural/java2python/tree/master/doc/customization.md

## java2python

Simple but effective tool to translate Java source code into Python.


The java2python package can translate any syntactically valid Java source code
file.  The generated Python code is not guaranteed to run, nor is guaranteed to
be syntactically valid Python.  However, java2python works well many cases, and
in some of those, it creates perfectly usable and workable Python code.

For more information, read the [introduction][].  To install, refer to the
[installation][] page.

There are [lots of docs][], [plenty of tests][], and [many options][] for
controlling code generation.

If you're looking for old releases, check the [downloads][] link above.

Here's a very simple example:

```bash
$ cat HelloWorld.java
```
```java
// This is the HelloWorld class with a single method.
class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, world.");
    }
}
```

Next we run our program:


```bash
$ j2py HelloWorld.java
```
```python
#!/usr/bin/env python
""" generated source for module HelloWorld """

#  This is the HelloWorld class with a single method.
class HelloWorld(object):
    """ generated source for class HelloWorld """

    @classmethod
    def main(cls, args):
        """ generated source for method main """
        print "Hello, world."

if __name__ == '__main__':
    import sys
    HelloWorld.main(sys.argv)
```


[downloads]: https://github.com/natural/java2python/downloads
[installation]: https://github.com/natural/java2python/tree/master/doc/install.md
[introduction]: https://github.com/natural/java2python/tree/master/doc/intro.md
[lots of docs]: https://github.com/natural/java2python/tree/master/doc/
[many options]: https://github.com/natural/java2python/tree/master/doc/customization.md
[plenty of tests]: https://github.com/natural/java2python/tree/master/doc/tests.md

