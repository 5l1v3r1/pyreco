__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# honcho documentation build configuration file, created by
# sphinx-quickstart on Sun Mar 24 13:09:42 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'honcho'
copyright = u'2014, Nick Stenning'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
from ..honcho import __version__
version = __version__
# The full version, including alpha/beta/rc tags.
release = __version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'honchodoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'honcho.tex', u'honcho Documentation',
   u'Nick Stenning', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'honcho', u'honcho Documentation',
     [u'Nick Stenning'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'honcho', u'honcho Documentation',
   u'Nick Stenning', 'honcho', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'honcho'
epub_author = u'Nick Stenning'
epub_publisher = u'Nick Stenning'
epub_copyright = u'2014, Nick Stenning'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
#epub_cover = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True

########NEW FILE########
__FILENAME__ = colour
ANSI_COLOURS = [
    'grey',
    'red',
    'green',
    'yellow',
    'blue',
    'magenta',
    'cyan',
    'white'
]

for i, name in enumerate(ANSI_COLOURS):
    globals()[name] = str(30 + i)
    globals()['intense_' + name] = str(30 + i) + ';1'


def get_colours():
    cs = ['cyan', 'yellow', 'green', 'magenta', 'red', 'blue',
          'intense_cyan', 'intense_yellow', 'intense_green',
          'intense_magenta', 'intense_red', 'intense_blue']
    cs = [globals()[c] for c in cs]

    i = 0
    while True:
        yield cs[i % len(cs)]
        i += 1

########NEW FILE########
__FILENAME__ = command
import argparse
import logging
import os
import re
import sys
from collections import defaultdict
try:
    from shlex import quote as shellquote  # Python 3
except ImportError:
    from pipes import quote as shellquote

from honcho import __version__
from honcho.procfile import Procfile
from honcho.process import Process, ProcessManager
from honcho import compat

logging.basicConfig(format='%(levelname)s: %(message)s', level=logging.INFO)
log = logging.getLogger(__name__)

PATH = os.path.dirname(__file__)
BASENAME = os.path.basename(os.getcwd())

EXPORT_CHOICES = ['supervisord', 'upstart']

process_manager = ProcessManager()


# option decorator
def option(*args, **kwargs):
    def _decorator(func):
        _option = (args, kwargs)
        if hasattr(func, 'options'):
            func.options.append(_option)
        else:
            func.options = [_option]
        return func
    return _decorator

# arg decorator
arg = option


class Commander(type):
    def __new__(cls, name, bases, attrs):  # noqa
        subcommands = {}
        commands = attrs.get('commands', [])
        for command in commands:
            func = attrs.get(command, None)
            if func is not None:
                subcommand = {
                    'name': command,
                    'func': func,
                    'options': []
                }
                if hasattr(func, 'options'):
                    subcommand['options'] = func.options
                subcommands[command] = subcommand
        attrs['_subcommands'] = subcommands
        return type.__new__(cls, name, bases, attrs)


class CommandError(Exception):
    pass


class Honcho(compat.with_metaclass(Commander, object)):
    "Manage Procfile-based applications"

    name = 'honcho'
    version = __version__
    epilog = ''
    formatter_class = argparse.ArgumentDefaultsHelpFormatter

    subparser_title = 'tasks'
    subparser_help = ''
    subparser_formatter_class = formatter_class

    default = ['--help']
    commands = ['start', 'check', 'help', 'run', 'export']
    common = [
        option('-e', '--env', help='Environment file[,file]', default='.env'),
        option('-d', '--app-root', help='Procfile directory', default='.'),
        option('-f', '--procfile', help='Procfile path', default='Procfile'),
    ]

    def add_common(self, parser):
        "add all common options and arguments to the main parser"
        common_group = parser.add_argument_group('common arguments')
        for option in self.common:
            options = option(lambda: None).options
            if options:
                args, kwargs = options[0]
                common_group.add_argument(*args, **kwargs)

    def parse(self, argv=None):
        # the main parser
        parser = argparse.ArgumentParser(
            prog=self.name,
            formatter_class=self.formatter_class,
            description=self.__doc__,
            epilog=self.epilog,
        )
        parser.add_argument('-v', '--version', action='version',
                            version='%(prog)s ' + self.version)
        self.add_common(parser)

        # then add the subparsers
        subparsers = parser.add_subparsers(
            title=self.subparser_title,
            help=self.subparser_help)

        for name, subcommand in sorted(self._subcommands.items()):
            subparser = subparsers.add_parser(subcommand['name'],
                                              help=subcommand['func'].__doc__,
                                              formatter_class=self.subparser_formatter_class)
            self.add_common(subparser)
            for args, kwargs in subcommand['options']:
                subparser.add_argument(*args, **kwargs)
            subparser.set_defaults(func=subcommand['func'])

        if not argv:
            argv = sys.argv[1:]
        if not argv:
            argv = self.default

        options = parser.parse_args(argv)

        try:
            options.func(self, options)
        except CommandError as e:
            log.error(str(e))
            sys.exit(1)

    @arg('task', help='Task to show help for', nargs='?')
    def help(self, options):
        "Describe available tasks or one specific task"
        argv = ['--help']
        if options.task:
            argv.append(options.task)
        return self.parse(argv[::-1])

    def check(self, options):
        "Validate your application's Procfile"
        procfile = self.make_procfile(options.procfile)

        log.info('Valid procfile detected ({0})'.format(', '.join(procfile.commands)))

    @arg('command', nargs=argparse.REMAINDER, help='Command to run')
    def run(self, options):
        "Run a command using your application's environment"
        self.set_env(self.read_env(options))

        if compat.ON_WINDOWS:
            # do not quote on Windows, subprocess will handle it for us
            # using the MSFT quoting rules
            cmd = options.command
        else:
            cmd = ' '.join(shellquote(arg) for arg in options.command)

        p = Process(cmd, stdout=sys.stdout, stderr=sys.stderr)
        p.wait()
        sys.exit(p.returncode)

    @option('-p', '--port', type=int, default=5000, metavar='N')
    @option('-c', '--concurrency', help='The number of each process type to run.',
            type=str, metavar='process=num,process=num')
    @option('-q', '--quiet', help='Any processes that you want to quiet ouput of.',
            type=str, metavar='process1,process2,process3')
    @arg('processes', nargs='*', help='Process(es) to start. All processes will be run if omitted.')
    def start(self, options):
        "Start the application (or a specific PROCESS)"
        self.set_env(self.read_env(options))
        procfile = self.make_procfile(options.procfile)

        port = int(os.environ.get('PORT', options.port))
        concurrency = self.parse_concurrency(options.concurrency)
        quiet = self.parse_quiet(options.quiet)

        processes = options.processes

        if len(processes) > 0:
            commands = {}
            for process in processes:
                try:
                    commands[process] = procfile.commands[process]
                except KeyError:
                    raise CommandError("Process type '{0}' does not exist in Procfile".format(process))
        else:
            commands = procfile.commands

        for name, cmd in compat.iteritems(commands):
            for i in compat.xrange(concurrency[name]):
                n = '{name}.{num}'.format(name=name, num=i + 1)
                os.environ['PORT'] = str(port + i)
                process_manager.add_process(n, cmd, quiet=(name in quiet))
            port += 100

        sys.exit(process_manager.loop())

    @option('-a', '--app',
            help="Alternative app name", default=BASENAME, type=str, metavar='APP')
    @option('-l', '--log',
            help="Specify the directory to place process logs in",
            default="/var/log/APP", type=str, metavar='DIR')
    @option('-p', '--port', default=5000, type=int, metavar='N')
    @option('-c', '--concurrency',
            help='The number of each process type to run.',
            type=str, metavar='process=num,process=num')
    @option('-u', '--user',
            help="Specify the user the application should run as",
            type=str)
    @option('-s', '--shell',
            help="Specify the shell that should run the application",
            default='/bin/sh', type=str)
    @arg('location',
         help="Folder to export to",
         default=EXPORT_CHOICES[0], type=str, metavar="LOCATION")
    @arg('format',
         help="What format to export to",
         default=EXPORT_CHOICES[0], choices=EXPORT_CHOICES, type=str, metavar="FORMAT")
    def export(self, options):
        "Export the application to another process management format"
        if options.log == "/var/log/APP":
            options.log = options.log.replace('APP', options.app)

        if options.user is None:
            if compat.ON_WINDOWS:
                options.user = os.environ.get('USERNAME')
            else:
                options.user = os.environ.get('USER')

        if options.user is None:
            raise CommandError('Could not automatically deduce user: please '
                               'supply the -u/--user option.')

        options.app_root = os.path.abspath(options.app_root)

        procfile = self.make_procfile(options.procfile)
        env = self.read_env(options)
        concurrency = self.parse_concurrency(options.concurrency)

        mod = __import__('.'.join(['honcho', 'export', options.format]),
                         fromlist=['Export'])

        export = mod.Export(procfile, options, env, concurrency)
        export.export()

    def make_procfile(self, filename):
        try:
            with open(filename) as f:
                content = f.read()
        except IOError:
            raise CommandError('Procfile does not exist or is not a file')

        procfile = Procfile(content)

        if not procfile.commands:
            raise CommandError('No processes defined in Procfile')

        return procfile

    def read_env(self, args):
        app_root = args.app_root or os.path.dirname(args.procfile)
        files = [env.strip() for env in args.env.split(',')]
        content = []
        for envfile in files:
            try:
                with open(os.path.join(app_root, envfile)) as f:
                    content.append(f.read())
            except IOError:
                pass

        return self.parse_env('\n'.join(content))

    def parse_env(self, content):
        values = {}
        for line in content.splitlines():
            m1 = re.match(r'\A([A-Za-z_0-9]+)=(.*)\Z', line)
            if m1:
                key, val = m1.group(1), m1.group(2)

                m2 = re.match(r"\A'(.*)'\Z", val)
                if m2:
                    val = m2.group(1)

                m3 = re.match(r'\A"(.*)"\Z', val)
                if m3:
                    val = re.sub(r'\\(.)', r'\1', m3.group(1))

                values[key] = val
        return values

    def set_env(self, values):
        os.environ.update(values)

    def parse_concurrency(self, desc):
        result = defaultdict(lambda: 1)
        if desc is None:
            return result
        for item in desc.split(','):
            key, concurrency = item.split('=', 1)
            result[key] = int(concurrency)
        return result

    def parse_quiet(self, desc):
        result = []
        if desc is None:
            return result
        result = desc.split(',')
        return result


def main():
    app = Honcho()
    app.parse()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = compat
"""
Compatibility layer and utilities, mostly for proper Windows and Python 3
support.
"""
import sys

# This works for both 32 and 64 bit Windows
ON_WINDOWS = 'win32' in str(sys.platform).lower()

# Python 3 hasn't iteritems, we should use items instead
try:
    {}.iteritems
except AttributeError:
    iteritems = lambda data: data.items()
else:
    iteritems = lambda data: data.iteritems()

# Python 3 hasn't xrange, we should use range instead
try:
    xrange = xrange
except NameError:
    xrange = range


# Python 3 doesn't understand __metaclass__ magic
def with_metaclass(meta, *bases):
    """Create a base class with metaclass."""
    return meta('NewBase', bases, {})

# Python 3 does not have StringIO, we should use the io module instead
try:
    from StringIO import StringIO  # noqa
except ImportError:
    from io import StringIO  # noqa

# Python 3 renamed ConfigParser to configparser
try:
    from ConfigParser import ConfigParser  # noqa
except ImportError:
    from configparser import ConfigParser  # noqa

########NEW FILE########
__FILENAME__ = base
from __future__ import print_function
import os
import pwd
import sys
from honcho.command import CommandError, PATH

try:
    from jinja2 import Template
except ImportError:
    print("honcho's 'export' command requires the jinja2 package,\n"
          "which you don't appear to have installed.\n"
          "\n"
          "To fix this, install honcho with the 'export' extra selected:\n"
          "\n"
          "    pip install honcho[export]\n",
          file=sys.stderr)
    sys.exit(1)


class BaseExport(object):
    def __init__(self, procfile, options, environment, concurrency):
        self.procfile = procfile
        self.options = options
        self.environment = environment
        self.concurrency = concurrency

        try:
            user_entry = pwd.getpwnam(options.user)
        except KeyError:
            raise CommandError("No such user available: {0}"
                               .format(options.user))

        self.uid = user_entry.pw_uid
        self.gid = user_entry.pw_gid

    def _mkdir(self, directory):
        if os.path.exists(directory):
            return
        try:
            os.makedirs(directory)
        except OSError as e:
            print(e)
            raise CommandError("Can not create {0}"
                               .format(directory))

    def _chown(self, filename):
        try:
            os.chown(filename, self.uid, self.gid)
        except OSError:
            raise CommandError("Can not chown {0} to {1}"
                               .format(self.options.log,
                                       self.options.user))

    def _write(self, filename, content):
        path = os.path.join(self.options.location, filename)

        try:
            open(path, 'w').write(content)
        except IOError:
            raise CommandError("Can not write to file {0}"
                               .format(path))

    def get_template(self, name):
        path = os.path.join(PATH, 'data/export/', self.options.format, name)

        try:
            return Template(open(path).read())
        except IOError:
            raise CommandError("Can not find template with name {0}"
                               .format(name))

    def export(self):
        self._mkdir(self.options.location)
        self._mkdir(self.options.log)
        self._chown(self.options.log)

        files = self.render(self.procfile,
                            self.options,
                            self.environment,
                            self.concurrency)

        for name, content in files:
            self._write(name, content)

        return files

    def render(self, procfile, options, environment, concurrency):
        raise NotImplementedError("You must write a render method.")

########NEW FILE########
__FILENAME__ = supervisord
import pipes
from honcho import compat
from honcho.export.base import BaseExport


class Export(BaseExport):
    def render(self, procfile, options, environment, concurrency):
        commands = []
        port = options.port
        for name, cmd in procfile.commands.items():
            for num in compat.xrange(0, concurrency[name]):
                full_name_parts = [options.app, name]
                env = environment.copy()
                if concurrency[name] > 1:
                    env['PORT'] = str(port + num)
                    full_name_parts.append(str(num))
                else:
                    env['PORT'] = str(port)
                commands.append((
                    name,
                    cmd,
                    '-'.join(full_name_parts),
                    num,
                    [(key, '"%s"' % pipes.quote(value)) for key, value in env.items()]  # quote env values
                ))
            port += 100

        context = {
            'app':         options.app,
            'app_root':    options.app_root,
            'log':         options.log,
            'port':        options.port,
            'user':        options.user,
            'shell':       options.shell,
            'commands':    commands,
            'concurrency': concurrency
        }
        filename = "{0}.conf".format(options.app)
        content = self.get_template("supervisord.conf").render(context)
        return [(filename, content)]

########NEW FILE########
__FILENAME__ = upstart
from honcho import compat
from honcho.export.base import BaseExport


class Export(BaseExport):
    def render(self, procfile, options, environment, concurrency):
        files = []

        context = {
            'app':         options.app,
            'app_root':    options.app_root,
            'environment': environment,
            'log':         options.log,
            'port':        options.port,
            'user':        options.user,
            'shell':       options.shell
        }

        for name, cmd in procfile.commands.iteritems():
            ctx = context.copy()
            ctx.update({'command': cmd,
                        'name':    name})

            master = "{0}-{1}.conf".format(options.app, name)
            master_content = self.get_template("process_master.conf").render(ctx)
            files.append((master, master_content))

            for num in compat.xrange(1, concurrency[name] + 1):
                ctx.update({'num': num})
                process = "{0}-{1}-{2}.conf".format(options.app, name, num)
                process_content = self.get_template("process.conf").render(ctx)
                files.append((process, process_content))

        app = "{0}.conf".format(options.app)
        app_content = self.get_template("master.conf").render(context)

        files.append((app, app_content))

        return files

########NEW FILE########
__FILENAME__ = printer
from datetime import datetime
import sys


class Printer(object):
    def __init__(self, output=sys.stdout, name='unknown', colour=None, width=0):
        self.output = output
        self.name = name
        self.colour = colour
        self.width = width

        self._write_prefix = True

    def write(self, *args, **kwargs):
        new_args = []

        for arg in args:
            lines = arg.split('\n')
            lines = [self._prefix() + l if l else l for l in lines]
            new_args.append('\n'.join(lines))

        self.output.write(*new_args, **kwargs)

    def _prefix(self):
        time = datetime.now().strftime('%H:%M:%S')
        name = self.name.ljust(self.width)
        prefix = '{time} {name} | '.format(time=time, name=name)
        if self.colour:
            return _colour_string(self.colour, prefix)
        else:
            return prefix


def _ansi(code):
    return '\033[{0}m'.format(code)


def _colour_string(colour, s):
    return '{0}{1}{2}'.format(_ansi(colour), s, _ansi(0))

########NEW FILE########
__FILENAME__ = process
from __future__ import print_function

import signal
import subprocess
import sys
from threading import Thread

try:
    from Queue import Queue, Empty
except ImportError:
    from queue import Queue, Empty  # Python 3.x

from .colour import get_colours
from .printer import Printer
from .compat import ON_WINDOWS


class Process(subprocess.Popen):
    """

    A simple utility wrapper around subprocess.Popen that stores
    a number of attributes needed by Honcho.

    """
    def __init__(self, cmd, name=None, quiet=False, *args, **kwargs):
        self.name = name
        self.quiet = quiet
        self.reader = None
        self.printer = None
        self.dead = False

        if self.quiet:
            self.name = "{0} (quiet)".format(self.name)

        defaults = {
            'stdout': subprocess.PIPE,
            'stderr': subprocess.STDOUT,
            'shell': True,
            'bufsize': 1,
            'close_fds': not ON_WINDOWS
        }
        defaults.update(kwargs)

        super(Process, self).__init__(cmd, *args, **defaults)


class ProcessManager(object):
    """

    Here's where the business happens. The ProcessManager multiplexes and
    pretty-prints the output from a number of Process objects, typically added
    using the add_process() method.

    Example:

        pm = ProcessManager()
        pm.add_process('name', 'ruby server.rb')
        pm.add_process('name', 'python worker.py')

        pm.loop()

    """
    def __init__(self):
        self.processes = []
        self.colours = get_colours()
        self.queue = Queue()
        self.system_printer = Printer(sys.stdout, name='system')
        self.returncode = None

        self._terminating = False

    def add_process(self, name, cmd, quiet=False):
        """

        Add a process to this manager instance:

        Arguments:

        name        - a human-readable identifier for the process
                      (e.g. 'worker'/'server')
        cmd         - the command-line used to run the process
                      (e.g. 'python run.py')

        """
        self.processes.append(Process(cmd, name=name, quiet=quiet))

    def loop(self):
        """

        Enter the main loop of the program. This will print the multiplexed
        output of all the processes in this ProcessManager to sys.stdout, and
        will block until all the processes have completed.

        If one process terminates, all the others will be terminated by
        Honcho, and loop() will return.

        Returns: the returncode of the first process to exit, or 130 if
        interrupted with Ctrl-C (SIGINT)

        """

        self._init_readers()
        self._init_printers()

        for proc in self.processes:
            print("started with pid {0}".format(proc.pid), file=proc.printer)

        while True:
            try:
                proc, line = self.queue.get(timeout=0.1)
            except Empty:
                pass
            except KeyboardInterrupt:
                print("SIGINT received", file=sys.stderr)
                self.returncode = 130
                self.terminate()
            else:
                self._print_line(proc, line)

            for proc in self.processes:
                if not proc.dead and proc.poll() is not None:
                    print('process terminated', file=proc.printer)
                    proc.dead = True

                    # Set the returncode of the ProcessManager instance if not
                    # already set.
                    if self.returncode is None:
                        self.returncode = proc.returncode

                    self.terminate()

            if not self._process_count() > 0:
                break

        while True:
            try:
                proc, line = self.queue.get(timeout=0.1)
            except Empty:
                break
            else:
                self._print_line(proc, line)

        return self.returncode

    def terminate(self):
        """

        Terminate all the child processes of this ProcessManager, bringing the
        loop() to an end.

        """
        if self._terminating:
            return False

        self._terminating = True

        print("sending SIGTERM to all processes", file=self.system_printer)
        for proc in self.processes:
            if proc.poll() is None:
                print("sending SIGTERM to pid {0:d}".format(proc.pid), file=self.system_printer)
                proc.terminate()

        def kill(signum, frame):
            # If anything is still alive, SIGKILL it
            for proc in self.processes:
                if proc.poll() is None:
                    print("sending SIGKILL to pid {0:d}".format(proc.pid), file=self.system_printer)
                    proc.kill()

        if ON_WINDOWS:
            # SIGALRM is not supported on Windows: just kill instead
            kill(None, None)
        else:
            # the default is POSIX
            signal.signal(signal.SIGALRM, kill)  # @UndefinedVariable
            signal.alarm(5)  # @UndefinedVariable

    def _process_count(self):
        return [p.poll() for p in self.processes].count(None)

    def _init_readers(self):
        for proc in self.processes:
            t = Thread(target=_enqueue_output, args=(proc, self.queue))
            t.daemon = True  # thread dies with the program
            t.start()

    def _init_printers(self):
        width = max(len(p.name) for p in filter(lambda x: not x.quiet, self.processes))
        width = max(width, len(self.system_printer.name))

        self.system_printer.width = width

        for proc in self.processes:
            proc.printer = Printer(sys.stdout,
                                   name=proc.name,
                                   colour=next(self.colours),
                                   width=width)

    def _print_line(self, proc, line):
        if isinstance(line, UnicodeDecodeError):
            print("UnicodeDecodeError while decoding line from process {0:s}".format(proc.name),
                  file=self.system_printer)
        else:
            print(line, end='', file=proc.printer)


def _enqueue_output(proc, queue):
    if not proc.quiet:
        for line in iter(proc.stdout.readline, b''):
            try:
                line = line.decode('utf-8')
            except UnicodeDecodeError as e:
                queue.put((proc, e))
                continue
            if not line.endswith('\n'):
                line += '\n'
            queue.put((proc, line))
        proc.stdout.close()

########NEW FILE########
__FILENAME__ = procfile
try:
    from collections import OrderedDict
except ImportError:
    from ordereddict import OrderedDict

import re

LINE = re.compile(r'^([A-Za-z0-9_]+):\s*(.+)$')


class Procfile(object):
    def __init__(self, contents):
        self.commands = OrderedDict()

        for line in contents.splitlines():
            m = LINE.match(line)
            if m:
                self.commands[m.group(1)] = m.group(2)

########NEW FILE########
__FILENAME__ = awkward
from __future__ import print_function
import sys

if __name__ == '__main__':
    for i in range(10):
        print("Hello with no line break", end='')
        sys.stdout.flush()

########NEW FILE########
__FILENAME__ = fast
from __future__ import print_function
import random
import sys

words = [word.strip() for word in open('/usr/share/dict/words')]

if __name__ == '__main__':
    while True:
        print(' '.join(random.choice(words) for _ in range(3)))
        sys.stdout.flush()
        # time.sleep(0.1)

########NEW FILE########
__FILENAME__ = ignoreterm
from __future__ import print_function
import signal
import sys
import time


def handler(signum, frame):
    print("Ignoring you")
    sys.stdout.flush()

signal.signal(signal.SIGQUIT, handler)
signal.signal(signal.SIGINT, handler)
signal.signal(signal.SIGTERM, handler)

if __name__ == '__main__':
    while True:
        print("Still here")
        sys.stdout.flush()
        time.sleep(1)

########NEW FILE########
__FILENAME__ = output
import sys


if __name__ == '__main__':
    sys.stdout.write('some normal output\n')
    sys.stdout.flush()
    sys.stderr.write('and then write to stderr\n')
    sys.stderr.flush()

########NEW FILE########
__FILENAME__ = simple
from __future__ import print_function
import sys
import time


if __name__ == '__main__':
    sys.stdout.write('normal output\n')
    sys.stdout.flush()
    sys.stderr.write('error output\n')
    sys.stderr.flush()
    time.sleep(0.1)

########NEW FILE########
__FILENAME__ = unicode_decode
import sys

if __name__ == '__main__':
    sys.stdout.write("\x8e\n")
    sys.stdout.flush()
    sys.stdout.write("normal output\n")

########NEW FILE########
__FILENAME__ = helpers
import os
import re
from honcho.procfile import Procfile
from subprocess import Popen, PIPE
from nose.tools import assert_equal, assert_true  # noqa
from mock import patch, MagicMock, call  # noqa

FIXTURE_ROOT = os.path.join(os.path.dirname(__file__), 'fixtures')

try:
    from nose.tools import assert_regexp_matches
except ImportError:

    def assert_regexp_matches(text, expected_regexp, msg=None):
        """Fail the test unless the text matches the regular expression."""
        if isinstance(expected_regexp, str):
            expected_regexp = re.compile(expected_regexp)
        if not expected_regexp.search(text):
            msg = msg or "Regexp didn't match"
            msg = '%s: %r not found in %r' % (msg, expected_regexp.pattern, text)
            raise AssertionError(msg)


def assert_regexp_fails(text, failed_regexp, msg=None):
    """Fail the test if the text matches the regular expression."""
    if isinstance(failed_regexp, str):
        failed_regexp = re.compile(failed_regexp)
    if failed_regexp.search(text):
        msg = msg or "Regexp matched"
        msg = '%s: %r found in %r' % (msg, failed_regexp.pattern, text)
        raise AssertionError(msg)


def get_honcho_output(args):
    os.chdir(FIXTURE_ROOT)
    cmd = ['honcho']
    cmd.extend(args)

    # The below is mostly copy-pasted from subprocess.py's check_output (to
    # support python 2.6)

    process = Popen(cmd, stdout=PIPE, stderr=PIPE, universal_newlines=True)
    output, error = process.communicate()
    retcode = process.returncode

    return retcode, output, error


def get_procfile(name):
    with open(os.path.join(FIXTURE_ROOT, name)) as f:
        return Procfile(f.read())

########NEW FILE########
__FILENAME__ = test_awkward
from ..helpers import get_honcho_output, assert_regexp_matches, assert_equal


def test_awkward():
    ret, out, err = get_honcho_output(['-f', 'Procfile.awkward', 'start'])

    assert_equal(ret, 0)

    assert_regexp_matches(out, r'awkward\.1 \| (....)?started with pid \d+\n')
    assert_regexp_matches(out, r'awkward\.1 \| (....)?(Hello with no line break){10}\n')
    assert_regexp_matches(out, r'awkward\.1 \| (....)?process terminated\n')

########NEW FILE########
__FILENAME__ = test_env
from ..helpers import assert_regexp_matches, assert_equal, get_honcho_output
from honcho import compat


def test_env_start():
    procfile = 'Procfile.envwin' if compat.ON_WINDOWS else 'Procfile.env'
    ret, out, err = get_honcho_output(['-f', procfile, 'start'])

    assert_equal(ret, 0)

    assert_regexp_matches(out, r'animals\.1 \| (....)?I like giraffes')


def test_env_run():
    if compat.ON_WINDOWS:
        command = ['run', 'cmd', '/c', 'echo', '%TEST_ANIMAL%']
    else:
        command = ['run', 'sh', '-c', 'echo $TEST_ANIMAL']
    ret, out, err = get_honcho_output(command)

    assert_equal(ret, 0)
    assert_equal(out, 'giraffe\n')

########NEW FILE########
__FILENAME__ = test_invalid
from ..helpers import get_honcho_output, assert_equal, assert_regexp_matches


def test_invalid():
    ret, out, err = get_honcho_output(['-f', 'Procfile.invalid', 'start'])

    assert_equal(ret, 1)

    assert_regexp_matches(err, 'No processes defined in Procfile')

########NEW FILE########
__FILENAME__ = test_multi
from ..helpers import get_honcho_output, assert_equal, assert_regexp_matches


def test_multi_check():
    ret, out, err = get_honcho_output(['-f', 'Procfile.multi', 'check'])

    assert_equal(ret, 0)

    assert_regexp_matches(err, 'Valid procfile detected')
    assert_regexp_matches(err, r'\bfoo\b')
    assert_regexp_matches(err, r'\bbar\b')
    assert_regexp_matches(err, r'\bbaz\b')

########NEW FILE########
__FILENAME__ = test_ports
from ..helpers import get_honcho_output, assert_regexp_matches, assert_equal
import os
from honcho import compat


def test_proctype_increment():
    procfile = 'Procfile.portswin' if compat.ON_WINDOWS else 'Procfile.ports'
    ret, out, err = get_honcho_output(['-f', procfile, 'start'])

    assert_equal(ret, 0)

    assert_regexp_matches(out, r'web\.1    \| (....)?PORT=5000')
    assert_regexp_matches(out, r'worker\.1 \| (....)?PORT=5100')
    assert_regexp_matches(out, r'redis\.1  \| (....)?PORT=5200')
    assert_regexp_matches(out, r'es\.1     \| (....)?PORT=5300')


def test_concurrency_increment():
    procfile = 'Procfile.portswin' if compat.ON_WINDOWS else 'Procfile.ports'
    ret, out, err = get_honcho_output(['-f', procfile, 'start', '-c', 'web=2,worker=3'])

    assert_equal(ret, 0)

    assert_regexp_matches(out, r'web\.1    \| (....)?PORT=5000')
    assert_regexp_matches(out, r'web\.2    \| (....)?PORT=5001')
    assert_regexp_matches(out, r'worker\.1 \| (....)?PORT=5100')
    assert_regexp_matches(out, r'worker\.2 \| (....)?PORT=5101')
    assert_regexp_matches(out, r'worker\.3 \| (....)?PORT=5102')
    assert_regexp_matches(out, r'redis\.1  \| (....)?PORT=5200')
    assert_regexp_matches(out, r'es\.1     \| (....)?PORT=5300')


def test_get_port_from_dot_env():
    procfile = 'Procfile.portswin' if compat.ON_WINDOWS else 'Procfile.ports'
    ret, out, err = get_honcho_output(['-f', procfile, '-e', '.env_port', 'start'])

    assert_equal(ret, 0)

    assert_regexp_matches(out, r'web\.1    \| (....)?PORT=8000')


def test_get_port_from_env():
    os.environ['PORT'] = '3000'
    procfile = 'Procfile.portswin' if compat.ON_WINDOWS else 'Procfile.ports'
    ret, out, err = get_honcho_output(['-f', procfile, 'start'])

    assert_equal(ret, 0)

    assert_regexp_matches(out, r'web\.1    \| (....)?PORT=3000')

########NEW FILE########
__FILENAME__ = test_run
import sys
from ..helpers import get_honcho_output, assert_equal, assert_true

from honcho import compat


def test_run_quoting():
    # 'python' is not always in the path on all test os
    # in particular on Windows, this is not the case
    python = sys.executable
    ret, out, err = get_honcho_output(['run', python, '-c',
                                       'print("hello world")'])

    assert_equal(ret, 0)
    assert_equal(out, 'hello world\n')


def test_run_captures_all_arguments():
    if compat.ON_WINDOWS:
        return
    command = ['run', 'env', '-i', 'A=B']
    ret, out, err = get_honcho_output(command)
    assert_equal(ret, 0)
    assert_equal(out.strip(), "A=B")


def test_run_captures_all_arguments_windows():
    # note: this is not the same exact test as on Posix
    # but this captures the gist of the intention
    if not compat.ON_WINDOWS:
        return
    command = ['run', 'cmd', '/a', '/e:on', '/c', 'cd', '&', 'set']
    ret, out, err = get_honcho_output(command)
    assert_equal(ret, 0)
    assert_true("honcho" in out)
    assert_true("HOMEDRIVE" in out)


def test_run_keeps_stderr_and_stdout_separate():
    ret, out, err = get_honcho_output(['run', 'python', 'simple.py'])

    assert_equal(ret, 0)
    assert_equal(out, 'normal output\n')
    assert_equal(err, 'error output\n')

########NEW FILE########
__FILENAME__ = test_start
import re
from ..helpers import (get_honcho_output, assert_equal, assert_regexp_matches,
                       assert_true, assert_regexp_fails)

from honcho import compat


def test_start_simple():
    ret, out, err = get_honcho_output(['-f', 'Procfile.simple', 'start'])

    assert_equal(ret, 0)

    assert_regexp_matches(out, r'foo\.1  \| (....)?started with pid \d+\n')
    assert_regexp_matches(out, r'foo\.1  \| (....)?process terminated\n')
    assert_regexp_matches(out, r'system \| (....)?sending SIGTERM to all processes\n')

    count = len(re.findall(r'foo\.1  \| (....)?(normal|error) output\n', out))
    assert_equal(count, 2)


def test_start_with_arg():
    ret, out, err = get_honcho_output(['-f', 'Procfile.default', 'start', 'foo'])

    assert_equal(ret, 0)

    assert_regexp_matches(out, r'foo\.1  \| (....)?started with pid \d+\n')
    assert_regexp_matches(out, r'foo\.1  \| (....)?process terminated\n')
    assert_regexp_matches(out, r'system \| (....)?sending SIGTERM to all processes\n')

    count = len(re.findall(r'foo\.1  \| (....)?(normal|error) output\n', out))
    assert_equal(count, 2)


def test_start_with_multiple_args():
    ret, out, err = get_honcho_output(['-f', 'Procfile.default', 'start', 'foo', 'bar'])

    assert_equal(ret, 0)

    assert_regexp_matches(out, r'foo\.1  \| (....)?started with pid \d+\n')
    assert_regexp_matches(out, r'foo\.1  \| (....)?process terminated\n')
    assert_regexp_matches(out, r'bar\.1  \| (....)?started with pid \d+\n')
    assert_regexp_matches(out, r'foo\.1  \| (....)?process terminated\n')
    assert_regexp_matches(out, r'system \| (....)?sending SIGTERM to all processes\n')

    count = len(re.findall(r'foo\.1  \| (....)?(normal|error) output\n', out))
    assert_equal(count, 2)
    count = len(re.findall(r'bar\.1  \| (....)?(normal|error) output\n', out))
    assert_equal(count, 2)
    count = len(re.findall(r'baz\.1  \| (....)?(normal|error) output\n', out))
    assert_equal(count, 0)


def test_start_returncode():
    procfile = 'Procfile.returncodewin' if compat.ON_WINDOWS else 'Procfile.returncode'
    ret, out, err = get_honcho_output(['-f', procfile, 'start'])

    assert_true(ret in [123, 42])


def test_start_with_arg_returncode():
    procfile = 'Procfile.returncodewin' if compat.ON_WINDOWS else 'Procfile.returncode'
    ret, out, err = get_honcho_output(['-f', procfile, 'start', 'bar'])

    assert_equal(ret, 42)


def test_start_joins_stderr_into_stdout():
    ret, out, err = get_honcho_output(['-f', 'Procfile.default', 'start'])

    assert_equal(ret, 0)

    assert_regexp_matches(out, r'normal output')
    assert_regexp_matches(out, r'error output')
    assert_equal(err, '')


def test_start_quiet_simple():
    ret, out, err = get_honcho_output(['-f', 'Procfile.default', 'start', '-qbaz'])

    assert_equal(ret, 0)

    assert_regexp_matches(out, r'foo\.1 *\| (....)?normal output')
    assert_regexp_matches(out, r'foo\.1 *\| (....)?error output')
    assert_regexp_matches(out, r'bar\.1 *\| (....)?normal output')
    assert_regexp_matches(out, r'bar\.1 *\| (....)?error output')
    assert_regexp_fails(out, r'baz\.1 \(quiet\) *\| (....)?normal output')
    assert_regexp_fails(out, r'baz\.1 \(quiet\) *\| (....)?error output')

    assert_regexp_matches(out, r'baz\.1 \(quiet\) *\| (....)?started with pid \d+\n')
    assert_regexp_matches(out, r'baz\.1 \(quiet\) *\| (....)?process terminated\n')

    assert_equal(err, '')


def test_start_quiet_multi():
    ret, out, err = get_honcho_output(['-f', 'Procfile.default', 'start', '-qbaz,bar'])

    assert_equal(ret, 0)

    assert_regexp_matches(out, r'foo\.1 *\| (....)?normal output')
    assert_regexp_matches(out, r'foo\.1 *\| (....)?error output')
    assert_regexp_fails(out, r'bar\.1 \(quiet\) *\| (....)?normal output')
    assert_regexp_fails(out, r'bar\.1 \(quiet\) *\| (....)?error output')
    assert_regexp_fails(out, r'baz\.1 \(quiet\) *\| (....)?normal output')
    assert_regexp_fails(out, r'baz\.1  \(quiet\)*\| (....)?error output')

    assert_regexp_matches(out, r'bar\.1 \(quiet\) *\| (....)?started with pid \d+\n')
    assert_regexp_matches(out, r'bar\.1 \(quiet\) *\| (....)?process terminated\n')
    assert_regexp_matches(out, r'baz\.1 \(quiet\) *\| (....)?started with pid \d+\n')
    assert_regexp_matches(out, r'baz\.1 \(quiet\) *\| (....)?process terminated\n')

    assert_equal(err, '')

########NEW FILE########
__FILENAME__ = test_unicode_decode
from ..helpers import get_honcho_output, assert_equal, assert_regexp_matches


def test_unicode_decode_error():
    ret, out, err = get_honcho_output(['-f',
                                       'Procfile.unicode_decode', 'start'])
    assert_equal(ret, 0)
    assert_regexp_matches(out, "normal output")

########NEW FILE########
__FILENAME__ = test_colour
from honcho import colour, compat

from ..helpers import assert_equal


def test_colours():
    assert_equal(colour.red, '31')
    assert_equal(colour.intense_red, '31;1')
    assert_equal(colour.cyan, '36')
    assert_equal(colour.intense_cyan, '36;1')


def test_get_colours():
    gen = colour.get_colours()

    expect = ['cyan', 'yellow', 'green', 'magenta', 'red', 'blue']
    expect = [getattr(colour, x) for x in expect]
    actual = [next(gen) for _ in compat.xrange(6)]

    assert_equal(expect, actual)

########NEW FILE########
__FILENAME__ = test_export_supervisord
import os
from collections import defaultdict, namedtuple

from honcho import compat
from honcho.export.supervisord import Export

from ..helpers import get_procfile, assert_equal

from nose.tools import assert_true


Options = namedtuple("Options", ("app", "app_root", "format", "log", "port", "user", "shell", "location"))

DEFAULT_OPTIONS = Options(app="app", app_root="/path/to/app", format="supervisord", log="/path/to/log",
                          port=5000, user=os.getlogin(), shell="/usr/local/shell", location="/path/to/export")

DEFAULT_ENV = {}

DEFAULT_CONCURRENCY = defaultdict(lambda: 1)


def get_render(procfile, options, environment, concurrency):
    export = Export(procfile, options, environment, concurrency)
    return export.render(export.procfile, export.options, export.environment, export.concurrency)


def test_supervisord_export():
    procfile = get_procfile("Procfile.simple")
    render = get_render(procfile, DEFAULT_OPTIONS, DEFAULT_ENV, DEFAULT_CONCURRENCY)

    assert_equal(1, len(render))
    (fname, contents), = render

    parser = compat.ConfigParser()
    parser.readfp(compat.StringIO(contents))

    section = "program:app-foo"

    assert_true(parser.has_section(section))
    assert_equal(DEFAULT_OPTIONS.user, parser.get(section, "user"))
    assert_equal("{0} -c 'python simple.py'".format(DEFAULT_OPTIONS.shell), parser.get(section, "command"))


def test_supervisord_concurrency():
    procfile = get_procfile("Procfile.simple")
    render = get_render(procfile, DEFAULT_OPTIONS, DEFAULT_ENV, {"foo": 4})

    assert_equal(1, len(render))
    (fname, contents), = render

    parser = compat.ConfigParser()
    parser.readfp(compat.StringIO(contents))

    for job_index in compat.xrange(4):
        section = "program:app-foo-{0}".format(job_index)
        assert_true(parser.has_section(section))
        assert_equal('PORT="{0}"'.format(DEFAULT_OPTIONS.port + job_index),
                     parser.get(section, "environment"))

    assert_equal(parser.get("group:app", "programs"),
                 ",".join("app-foo-{0}".format(i) for i in compat.xrange(4)))

########NEW FILE########
__FILENAME__ = test_printer
import datetime

from honcho.printer import Printer
from ..helpers import MagicMock, patch


class TestPrinter(object):
    def setup(self):
        self.out = MagicMock()

        self._dt_patch = patch('honcho.printer.datetime')
        self._dt = self._dt_patch.start()
        self._dt.now.return_value = datetime.datetime(2012, 8, 11, 12, 42)

    def teardown(self):
        self._dt_patch.stop()

    def test_defaults_simple(self):
        self.p = Printer(output=self.out)
        self.p.write("monkeys")
        self.out.write.assert_called_once_with("12:42:00 unknown | monkeys")

    def test_defaults_multiline(self):
        self.p = Printer(output=self.out)
        self.p.write("one\ntwo\nthree")

        expect = "12:42:00 unknown | one\n12:42:00 unknown | two\n12:42:00 unknown | three"
        self.out.write.assert_called_once_with(expect)

    def test_name_simple(self):
        self.p = Printer(output=self.out, name="Robert Louis Stevenson")
        self.p.write("quiescent")
        self.out.write.assert_called_once_with("12:42:00 Robert Louis Stevenson | quiescent")

    def test_length_simple(self):
        self.p = Printer(output=self.out, name="oop", width=6)
        self.p.write("narcissist")
        self.out.write.assert_called_once_with("12:42:00 oop    | narcissist")

    def test_colour_simple(self):
        self.p = Printer(output=self.out, name="red", colour="31")
        self.p.write("conflate")
        self.out.write.assert_called_once_with("\033[31m12:42:00 red | \033[0mconflate")

########NEW FILE########
__FILENAME__ = test_process
from honcho.process import ProcessManager
from ..helpers import call, patch, assert_equal


class TestProcessManager(object):

    @patch('honcho.process.Process')
    def test_add_processes(self, process_mock):
        pm = ProcessManager()
        pm.add_process('foo', 'ruby server.rb')
        pm.add_process('bar', 'python worker.py')

        expected = [call('ruby server.rb', name='foo', quiet=False),
                    call('python worker.py', name='bar', quiet=False)]

        assert_equal(process_mock.mock_calls, expected)

########NEW FILE########
__FILENAME__ = test_procfile
import textwrap

from honcho.procfile import Procfile
from ..helpers import assert_equal

FIXTURES = [
    [
        # Simple
        """
        web: command
        """,
        {'web': 'command'}
    ],
    [
        # Simple 2
        """
        foo: python foo.py
        bar: python bar.py
        """,
        {'foo': 'python foo.py', 'bar': 'python bar.py'}
    ],
    [
        # No newline at EOF
        """
        web: command""",
        {'web': 'command'}
    ],
    [
        # Comments
        """
        #commented: command
        """,
        {}
    ],
    [
        # Invalid characters
        """
        -foo: command
        """,
        {}
    ],
    [
        # Shell metacharacters
        """
        web: sh -c "echo $FOOBAR" >/dev/null 2>&1
        """,
        {'web': 'sh -c "echo $FOOBAR" >/dev/null 2>&1'}
    ],
]


def test_procfiles():
    for content, commands in FIXTURES:
        content = textwrap.dedent(content)
        procfile = Procfile(content)
        assert_equal(procfile.commands, commands)


def test_procfile_ordered():
    content = textwrap.dedent("""
    one: onecommand
    two: twocommand
    three: twocommand
    four: fourcommand
    """)

    procfile = Procfile(content)

    order = [k for k in procfile.commands]
    assert_equal(['one', 'two', 'three', 'four'], order)

########NEW FILE########
