__FILENAME__ = bootstrap
##############################################################################
#
# Copyright (c) 2006 Zope Corporation and Contributors.
# All Rights Reserved.
#
# This software is subject to the provisions of the Zope Public License,
# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
# FOR A PARTICULAR PURPOSE.
#
##############################################################################
"""Bootstrap a buildout-based project

Simply run this script in a directory containing a buildout.cfg.
The script accepts buildout command-line options, so you can
use the -c option to specify an alternate configuration file.

$Id: bootstrap.py 102545 2009-08-06 14:49:47Z chrisw $
"""

import os, shutil, sys, tempfile, urllib2
from optparse import OptionParser

tmpeggs = tempfile.mkdtemp()

is_jython = sys.platform.startswith('java')

# parsing arguments
parser = OptionParser()
parser.add_option("-v", "--version", dest="version",
                          help="use a specific zc.buildout version")
parser.add_option("-d", "--distribute",
                   action="store_true", dest="distribute", default=True,
                   help="Use Disribute rather than Setuptools.")

options, args = parser.parse_args()

if options.version is not None:
    VERSION = '==%s' % options.version
else:
    VERSION = ''

USE_DISTRIBUTE = options.distribute
args = args + ['bootstrap']

to_reload = False
try:
    import pkg_resources
    if not hasattr(pkg_resources, '_distribute'):
        to_reload = True
        raise ImportError
except ImportError:
    ez = {}
    if USE_DISTRIBUTE:
        exec urllib2.urlopen('http://python-distribute.org/distribute_setup.py'
                         ).read() in ez
        ez['use_setuptools'](to_dir=tmpeggs, download_delay=0, no_fake=True)
    else:
        exec urllib2.urlopen('http://peak.telecommunity.com/dist/ez_setup.py'
                             ).read() in ez
        ez['use_setuptools'](to_dir=tmpeggs, download_delay=0)

    if to_reload:
        reload(pkg_resources)
    else:
        import pkg_resources

if sys.platform == 'win32':
    def quote(c):
        if ' ' in c:
            return '"%s"' % c # work around spawn lamosity on windows
        else:
            return c
else:
    def quote (c):
        return c

cmd = 'from setuptools.command.easy_install import main; main()'
ws  = pkg_resources.working_set

if USE_DISTRIBUTE:
    requirement = 'distribute'
else:
    requirement = 'setuptools'

if is_jython:
    import subprocess

    assert subprocess.Popen([sys.executable] + ['-c', quote(cmd), '-mqNxd',
           quote(tmpeggs), 'zc.buildout' + VERSION],
           env=dict(os.environ,
               PYTHONPATH=
               ws.find(pkg_resources.Requirement.parse(requirement)).location
               ),
           ).wait() == 0

else:
    assert os.spawnle(
        os.P_WAIT, sys.executable, quote (sys.executable),
        '-c', quote (cmd), '-mqNxd', quote (tmpeggs), 'zc.buildout' + VERSION,
        dict(os.environ,
            PYTHONPATH=
            ws.find(pkg_resources.Requirement.parse(requirement)).location
            ),
        ) == 0

ws.add_entry(tmpeggs)
ws.require('zc.buildout' + VERSION)
import zc.buildout.buildout
zc.buildout.buildout.main(args)
shutil.rmtree(tmpeggs)

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# box-linux-sync documentation build configuration file, created by
# sphinx-quickstart on Sat Feb  9 22:09:07 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.todo', 'sphinx.ext.coverage', 'sphinx.ext.ifconfig', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'box-linux-sync'
copyright = u'2012-2013, Vítor Brandão'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
show_authors = True

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'nature'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
html_logo = '_static/images/box-logo.png'

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
html_favicon = 'favicon.ico'

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'box-linux-sync-doc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'box-linux-sync.tex', u'box-linux-sync Documentation',
   u'Vítor Brandão', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'box-linux-sync', u'box-linux-sync Documentation',
     [u'Vítor Brandão'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'box-linux-sync', u'box-linux-sync Documentation',
   u'Vítor Brandão', 'box-linux-sync', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'box-linux-sync'
epub_author = u'Vítor Brandão'
epub_publisher = u'Vítor Brandão'
epub_copyright = u'2012-2013, Vítor Brandão'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
#epub_cover = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True

########NEW FILE########
__FILENAME__ = ansistrm
#
# Copyright (C) 2010-2013 Vinay Sajip. All rights reserved. Licensed under the new BSD license.
#
import ctypes
import logging
import os

class ColorizingStreamHandler(logging.StreamHandler):
    # color names to indices
    color_map = {
        'black': 0,
        'red': 1,
        'green': 2,
        'yellow': 3,
        'blue': 4,
        'magenta': 5,
        'cyan': 6,
        'white': 7,
    }

    #levels to (background, foreground, bold/intense)
    if os.name == 'nt':
        level_map = {
            logging.DEBUG: (None, 'blue', True),
            logging.INFO: (None, 'green', False),
            logging.WARNING: (None, 'yellow', True),
            logging.ERROR: (None, 'red', True),
            logging.CRITICAL: ('red', 'white', True),
        }
    else:
        level_map = {
            logging.DEBUG: (None, 'white', False),
            logging.INFO: (None, 'green', False),
            logging.WARNING: (None, 'yellow', False),
            logging.ERROR: (None, 'red', False),
            logging.CRITICAL: ('red', 'white', True),
        }
    csi = '\x1b['
    reset = '\x1b[0m'

    @property
    def is_tty(self):
        isatty = getattr(self.stream, 'isatty', None)
        return isatty and isatty()

    def emit(self, record):
        try:
            message = self.format(record)
            stream = self.stream
            if not self.is_tty:
                stream.write(message)
            else:
                self.output_colorized(message)
            stream.write(getattr(self, 'terminator', '\n'))
            self.flush()
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            self.handleError(record)

    if os.name != 'nt':
        def output_colorized(self, message):
            self.stream.write(message)
    else:
        import re
        ansi_esc = re.compile(r'\x1b\[((?:\d+)(?:;(?:\d+))*)m')

        nt_color_map = {
            0: 0x00,    # black
            1: 0x04,    # red
            2: 0x02,    # green
            3: 0x06,    # yellow
            4: 0x01,    # blue
            5: 0x05,    # magenta
            6: 0x03,    # cyan
            7: 0x07,    # white
        }

        def output_colorized(self, message):
            parts = self.ansi_esc.split(message)
            write = self.stream.write
            h = None
            fd = getattr(self.stream, 'fileno', None)
            if fd is not None:
                fd = fd()
                if fd in (1, 2): # stdout or stderr
                    h = ctypes.windll.kernel32.GetStdHandle(-10 - fd)
            while parts:
                text = parts.pop(0)
                if text:
                    write(text)
                if parts:
                    params = parts.pop(0)
                    if h is not None:
                        params = [int(p) for p in params.split(';')]
                        color = 0
                        for p in params:
                            if 40 <= p <= 47:
                                color |= self.nt_color_map[p - 40] << 4
                            elif 30 <= p <= 37:
                                color |= self.nt_color_map[p - 30]
                            elif p == 1:
                                color |= 0x08 # foreground intensity on
                            elif p == 0: # reset to default color
                                color = 0x07
                            else:
                                pass # error condition ignored
                        ctypes.windll.kernel32.SetConsoleTextAttribute(h, color)

    def colorize(self, message, record):
        if record.levelno in self.level_map:
            bg, fg, bold = self.level_map[record.levelno]
            params = []
            if bg in self.color_map:
                params.append(str(self.color_map[bg] + 40))
            if fg in self.color_map:
                params.append(str(self.color_map[fg] + 30))
            if bold:
                params.append('1')
            if params:
                message = ''.join((self.csi, ';'.join(params),
                                   'm', message, self.reset))
        return message

    def format(self, record):
        message = logging.StreamHandler.format(self, record)
        if self.is_tty:
            # Don't colorize any traceback
            parts = message.split('\n', 1)
            parts[0] = self.colorize(parts[0], record)
            message = '\n'.join(parts)
        return message

########NEW FILE########
__FILENAME__ = config
#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# This file is part of box-linux-sync.
#
# Copyright (C) 2013 Vítor Brandão <noisebleed@noiselabs.org>
#
# box-linux-sync is free software; you can redistribute it  and/or modify it
# under the terms of the GNU Lesser General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# box-linux-sync is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with box-linux-sync; if not, see
# <http://www.gnu.org/licenses/>.

import datetime
import os
import ConfigParser

from noiselabs.box import __prog__, __version__
from noiselabs.box.utils import create_file

BASEDIR = os.path.expanduser('~/.noiselabs/box')

class BoxConfig(object):
    """
    Handles noiselabs/box-linux-sync configuration file.
    """
    filepath = os.path.join(BASEDIR, 'box-sync.cfg')
    options = {'main': ['box_dir', 'use_davfs']}

    def __init__(self, box_console):
        self.out = box_console
        self.cfgparser = ConfigParser.SafeConfigParser()

    def check_file(self):
        """
        Check for config file existance and create if it doesn't
        """
        if create_file(self.filepath):
            self.out.info("Created configuration file '%s'" % self.filepath)
            self.write_default_config(self.filepath)

        sample_filepath = self.filepath+'.sample'
        if create_file(sample_filepath):
            self.out.info("Created example configuration file '%s'" % sample_filepath)
            self.write_default_config(sample_filepath)

        # Add all configured sections
        self.cfgparser = ConfigParser.SafeConfigParser()
        for section, options in self.options.items():
            self.cfgparser.add_section(section)
        self.cfgparser.read(self.filepath)        

    def check_config(self):
        """
        Check for sections and options available in the configuration file.
        """

        self.cfgparser.read(self.filepath)
        for section, options in self.options.items():
            loaded_options = self.cfgparser.options(section)
            for option in options:
                if option not in loaded_options:
                    return False
        return True        

    def write_default_config(self, filepath):
        data = "; " + os.path.basename(filepath) + "\n" + \
        "[main]\n\n" + \
        "; Path to your Box sync dir. Use a relative path to place this dir\n" + \
        "; inside $HOME or an absolute path. Default: Box\n" + \
        "box_dir = Box\n\n" + \
        "; Wether to use a WebDAV filesystem to synchronize your local and\n" + \
        "; remote files. Default: true\n" + \
        "use_davfs = true\n"
        try:
            f = open(filepath, 'w')
            try:
                f.write(data)
            finally:
                f.close()
        except IOError:
            self.out.error("Failed to write default configuration to '%s'" % filepath)
        
    def save(self):
        """
        Writes sections and options to the configuration file.
        """
        with open(self.filepath, 'wb') as configfile:
            self.cfgparser.write(configfile)
        
########NEW FILE########
__FILENAME__ = configparser
#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# This file is part of box-linux-sync.
#
# Copyright (C) 2013 Vítor Brandão <noisebleed@noiselabs.org>
#
# box-linux-sync is free software; you can redistribute it  and/or modify it
# under the terms of the GNU Lesser General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# box-linux-sync is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with box-linux-sync; if not, see
# <http://www.gnu.org/licenses/>.

import csv

class WhitespaceDelimitedConfigParser(object):
    """A really simple, stupid, class to parse whitespace delimited files
    like /etc/fstab or /etc/davfs2/davfs.conf"""

    def read(self, filepath):
        self.f = open(filepath, 'rb')
        self.reader = csv.reader(self.f, delimiter=' ', skipinitialspace=True)
    
    def get_option(self, option, index=0):
        for row in self.reader:
            if row and option == row[0]:
                return row
        return False
            
    def close(self):
        self.f.close()
########NEW FILE########
__FILENAME__ = main
#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# This file is part of box-linux-sync.
#
# Copyright (C) 2013 Vítor Brandão <noisebleed@noiselabs.org>
#
# box-linux-sync is free software; you can redistribute it  and/or modify it
# under the terms of the GNU Lesser General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# box-linux-sync is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with box-linux-sync; if not, see
# <http://www.gnu.org/licenses/>.

from __future__ import print_function

import subprocess
import sys

from optparse import OptionParser
from noiselabs.box import __prog__, __version__
from noiselabs.box.output import BoxConsole
from noiselabs.box.setup import BoxSetup

class NoiselabsOptionParser(OptionParser):
    """
    A quick'n'dirty version of optparse OptionParser that redefines
    format_epilog to allow newlines at will,
    """
    def format_epilog(self, formatter):
        return self.epilog

def box_main(args=None):
    """
    @param args: command arguments (default: sys.argv[1:])
    @type args: list
    """

    if args is None:
        args = sys.argv[1:]
    
    prog = __prog__
    version = __version__
    description = "Box.com command-line interface"
    usage = "Usage: %prog [options] <command>"

    force_help = "forces the execution of every procedure even if the component " +\
    "is already installed and/or configured"
    log_help = "log output to ~/.noiselabs/box/box-sync.log"

    parser = NoiselabsOptionParser(
        usage=usage,
        prog=prog,
        version=version,
        description=description,
        epilog=
"""
Commands:
  check       check box-sync setup and dependencies
  setup       launch a setup wizard
  start       start sync service
  stop        stop sync service
  help        show this help message and exit
  uninstall   removes all configuration and cache files installed by box-sync

Workflow:
  $ box-sync check && box-sync setup
  $ box-sync start
"""
    )

    parser.add_option("-f", "--force", help=force_help, action="store_true",
        dest="force")
    parser.add_option("-l", "--log", help=log_help, action="store_true",
        dest="log")
    parser.add_option("-v", "--verbose", help="be verbose", action="store_true",
        dest="verbose")

    opts, pargs = parser.parse_args(args=args)

    commands = ['check', 'help', 'start', 'stop', 'setup', 'uninstall']

    nargs = len(pargs)
    # Parse commands
    if nargs == 0:
        parser.error("no command given")
    elif pargs[0] not in commands:
        parser.error("unknown command '%s'" % pargs[0])
    else:
        command = pargs[0]
        if command == 'help':
            parser.print_help()
            sys.exit(0)

    bc = BoxConsole(opts, __prog__)
    setup = BoxSetup(bc)

    if command == 'check':
        setup.check()
    elif command == 'setup':
        setup.wizard()
    elif command == 'start':
        box_dir = setup.get_box_dir()
        bc.debug("Mounting '%s'..." % box_dir)
        cmd = "mount %s" % box_dir
        if subprocess.call(cmd, shell=True) != 0:
            bc.error("Failed to mount sync dir.")
            sys.exit(-1)
    elif command == 'stop':
        box_dir = setup.get_box_dir()
        bc.debug("Unmounting '%s'..." % box_dir)
        cmd = "umount %s" % box_dir
        if subprocess.call(cmd, shell=True) != 0:
            bc.error("Failed to unmount sync dir.")
            sys.exit(-1)
    elif command == 'uninstall':
        setup = BoxSetup(bc)
        setup.uninstall()

########NEW FILE########
__FILENAME__ = output
#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# This file is part of box-linux-sync.
#
# Copyright (C) 2013 Vítor Brandão <noisebleed@noiselabs.org>
#
# box-linux-sync is free software; you can redistribute it  and/or modify it
# under the terms of the GNU Lesser General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# box-linux-sync is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with box-linux-sync; if not, see
# <http://www.gnu.org/licenses/>.

from __future__ import print_function

import curses
import logging
import os
import time
import sys
import types

from noiselabs.box.config import BASEDIR
from noiselabs.box.utils import create_file
from noiselabs.box.ansistrm import ColorizingStreamHandler

################################################################################
##
## Color codes (taken from Portage)
##
################################################################################

_styles = {}
"""Maps style class to tuple of attribute names."""

codes = {}
"""Maps attribute name to ansi code."""

esc_seq = "\x1b["

codes["normal"]         = esc_seq + "0m"
codes['reset']          = esc_seq + "39;49;00m"

codes["bold"]         =  esc_seq + "01m"
codes["faint"]        =  esc_seq + "02m"
codes["standout"]     =  esc_seq + "03m"
codes["underline"]    =  esc_seq + "04m"
codes["blink"]        =  esc_seq + "05m"
codes["overline"]     =  esc_seq + "06m"
codes["reverse"]      =  esc_seq + "07m"
codes["invisible"]    =  esc_seq + "08m"

codes["no-attr"]      = esc_seq + "22m"
codes["no-standout"]  = esc_seq + "23m"
codes["no-underline"] = esc_seq + "24m"
codes["no-blink"]     = esc_seq + "25m"
codes["no-overline"]  = esc_seq + "26m"
codes["no-reverse"]   = esc_seq + "27m"

codes["bg_black"]      = esc_seq + "40m"
codes["bg_darkred"]    = esc_seq + "41m"
codes["bg_darkgreen"]  = esc_seq + "42m"
codes["bg_brown"]      = esc_seq + "43m"
codes["bg_darkblue"]   = esc_seq + "44m"
codes["bg_purple"]     = esc_seq + "45m"
codes["bg_teal"]       = esc_seq + "46m"
codes["bg_lightgray"]  = esc_seq + "47m"
codes["bg_default"]    = esc_seq + "49m"
codes["bg_darkyellow"] = codes["bg_brown"]

def color(fg, bg="default", attr=["normal"]):
    mystr = codes[fg]
    for x in [bg]+attr:
        mystr += codes[x]
    return mystr

ansi_codes = []
for x in range(30, 38):
    ansi_codes.append("%im" % x)
    ansi_codes.append("%i;01m" % x)

rgb_ansi_colors = ['0x000000', '0x555555', '0xAA0000', '0xFF5555', '0x00AA00',
    '0x55FF55', '0xAA5500', '0xFFFF55', '0x0000AA', '0x5555FF', '0xAA00AA',
    '0xFF55FF', '0x00AAAA', '0x55FFFF', '0xAAAAAA', '0xFFFFFF']

for x in range(len(rgb_ansi_colors)):
    codes[rgb_ansi_colors[x]] = esc_seq + ansi_codes[x]
del x

codes["black"]     = codes["0x000000"]
codes["darkgray"]  = codes["0x555555"]

codes["red"]       = codes["0xFF5555"]
codes["darkred"]   = codes["0xAA0000"]

codes["green"]     = codes["0x55FF55"]
codes["darkgreen"] = codes["0x00AA00"]

codes["yellow"]    = codes["0xFFFF55"]
codes["brown"]     = codes["0xAA5500"]

codes["blue"]      = codes["0x5555FF"]
codes["darkblue"]  = codes["0x0000AA"]

codes["fuchsia"]   = codes["0xFF55FF"]
codes["purple"]    = codes["0xAA00AA"]

codes["turquoise"] = codes["0x55FFFF"]
codes["teal"]      = codes["0x00AAAA"]

codes["white"]     = codes["0xFFFFFF"]
codes["lightgray"] = codes["0xAAAAAA"]

codes["darkteal"]   = codes["turquoise"]
# Some terminals have darkyellow instead of brown.
codes["0xAAAA00"]   = codes["brown"]
codes["darkyellow"] = codes["0xAAAA00"]

# Colors from /etc/init.d/functions.sh
_styles["NORMAL"]     = ( "normal", )
_styles["GOOD"]       = ( "green", )
_styles["WARN"]       = ( "yellow", )
_styles["BAD"]        = ( "red", )
_styles["HILITE"]     = ( "teal", )
_styles["BRACKET"]    = ( "blue", )

def style_to_ansi_code(style):
    """
    @param style: A style name
    @type style: String
    @rtype: String
    @return: A string containing one or more ansi escape codes that are
        used to render the given style.
    """
    ret = ""
    for attr_name in _styles[style]:
        # allow stuff that has found it's way through ansi_code_pattern
        ret += codes.get(attr_name, attr_name)
    return ret

def colorize(color_key, text):
    if color_key in codes:
        return codes[color_key] + text + codes["reset"]
    elif color_key in _styles:
        return style_to_ansi_code(color_key) + text + codes["reset"]
    else:
        return text

class BoxConsole():
    """
    A class that performs fancy terminal formatting for status and informational
    messages built upon the logging module.
    """
    def __init__(self, opts, name):
        self.name = name
        self.opts = opts
        self.logger = logging.getLogger(name)

        self.level = logging.DEBUG if self.opts.verbose else logging.INFO
        self.logger.setLevel(self.level)

        # create console handler
        ch = ColorizingStreamHandler()
        ch.setLevel(self.level)
        # create formatter and add it to the handlers
        #ch.setFormatter(logging.Formatter('%(message)s'))
        self.logger.addHandler(ch)

        # create file handler
        if self.opts.log:
            logfile = os.path.join(BASEDIR, 'box-sync.log')
            create_file(logfile)
            fh = logging.FileHandler(logfile)
            fh.setLevel(logging.DEBUG)
            fh.setFormatter(logging.Formatter('[%(asctime)s] [%(name)s] [%(levelname)s] %(message)s'))
            self.logger.addHandler(fh)

    def debug(self, msg):
        self.logger.debug(msg)

    def info(self, msg):
        self.logger.info(msg)

    def warning(self, msg):
        self.logger.warning(msg)

    def error(self, msg):
        self.logger.error(msg)

    def critical(self, msg):
        self.logger.critical(msg)

    def log(self, lvl, msg):
        self.logger.log(lvl, msg)

    def countdown(self, secs=5, doing="Starting"):
        """ This method is based on Portage's _emerge.countdown
        Copyright 1999-2009 Gentoo Foundation"""
        if secs:
            print("Waiting",secs,"seconds before starting (Control-C to abort)...")
            print(doing+" in: ", end=' ')
            ticks=list(range(secs))
            ticks.reverse()
            for sec in ticks:
                sys.stdout.write(colorize("red", str(sec+1)+" "))
                sys.stdout.flush()
                time.sleep(1)
            print()

########NEW FILE########
__FILENAME__ = apt
#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# This file is part of box-linux-sync.
#
# Copyright (C) 2013 Vítor Brandão <noisebleed@noiselabs.org>
#
# box-linux-sync is free software; you can redistribute it  and/or modify it
# under the terms of the GNU Lesser General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# box-linux-sync is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with box-linux-sync; if not, see
# <http://www.gnu.org/licenses/>.

from noiselabs.box.pms.pms import BasePMS

class APT(BasePMS):
    """The Advanced Packaging Tool used in the Debian family of Linux operating
    systems (Ubuntu included)."""

    def __str__(self):
        return 'APT'

    def search(self, pkg):
        return "apt-cache search %s" % pkg

    def install(self, pkg):
        return "apt-get install %s" % pkg

    def remove(self, pkg):
        return "apt-get remove %s" % pkg

########NEW FILE########
__FILENAME__ = aptitude
#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# This file is part of box-linux-sync.
#
# Copyright (C) 2013 Vítor Brandão <noisebleed@noiselabs.org>
#
# box-linux-sync is free software; you can redistribute it  and/or modify it
# under the terms of the GNU Lesser General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# box-linux-sync is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with box-linux-sync; if not, see
# <http://www.gnu.org/licenses/>.

from noiselabs.box.pms.pms import BasePMS

class Atitude(BasePMS):
    """The Aptitude PMS used in the Debian family of Linux operating systems
    (Ubuntu included)."""

    def __str__(self):
        return 'Aptitude'

    def search(self, pkg):
        return "aptitude search %s" % pkg

    def install(self, pkg):
        return "aptitude install %s" % pkg

    def remove(self, pkg):
        return "aptitude remove %s" % pkg

########NEW FILE########
__FILENAME__ = pacman
#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# This file is part of box-linux-sync.
#
# Copyright (C) 2013 Vítor Brandão <noisebleed@noiselabs.org>
#
# box-linux-sync is free software; you can redistribute it  and/or modify it
# under the terms of the GNU Lesser General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# box-linux-sync is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with box-linux-sync; if not, see
# <http://www.gnu.org/licenses/>.

from noiselabs.box.pms.pms import BasePMS

class Pacman(BasePMS):
    """Pacman is a software package manager, developed as part of the Arch Linux
    distribution."""

    def __str__(self):
        return 'pacman'

    def search(self, pkg):
        return "pacman -Ss %s" % pkg

    def install(self, pkg):
        return "pacman -S %s" % pkg

    def remove(self, pkg):
        return "pacman -R %s" % pkg

########NEW FILE########
__FILENAME__ = pms
#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# This file is part of box-linux-sync.
#
# Copyright (C) 2013 Vítor Brandão <noisebleed@noiselabs.org>
#
# box-linux-sync is free software; you can redistribute it  and/or modify it
# under the terms of the GNU Lesser General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# box-linux-sync is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with box-linux-sync; if not, see
# <http://www.gnu.org/licenses/>.

import abc
import platform
import subprocess

def get_pms():
    """In here we try to determine the Linux distro we are currently running and
    then return the Package Management System commonly associated with that
    distro."""
    if platform.system() != 'Linux': return False

    (distname,version,id) = platform.linux_distribution(full_distribution_name=False)
    if distname == 'gentoo':
        from noiselabs.box.pms.portage import Portage
        return Portage()
    elif distname in ['debian', 'ubuntu']:
        from noiselabs.box.pms.apt import APT
        return APT()
    elif distname in ['SuSE', 'fedora', 'redhat', 'centos', 'yellowdog', 'UnitedLinux', 'turbolinux']:
        from noiselabs.box.pms.yum import YUM
        return YUM()
    elif distname == 'slackware':
        from noiselabs.box.pms.slackpkg import Slackpkg
        return Slackpkg()
    elif distname == 'archlinux':
        from noiselabs.box.pms.pacman import Pacman
        return Pacman()
    else:
        return False

class BasePMS(object):
    """An abstract base class to be inherited by every PMS implementation."""
    __metaclass__ = abc.ABCMeta

    @abc.abstractmethod
    def search(self, pkg):
        """Retrieve as a string the command used to search for a given package"""
        return        
        
    @abc.abstractmethod
    def install(self, pkg):
        """Retrieve as a string the command required to install the package"""
        return
        
    @abc.abstractmethod
    def remove(self, pkg):
        """Retrieve as a string the command required to remove the package"""
        return
        
    def run(self, cmd):
        """Executes the command"""
        return subprocess.call(cmd, shell=True)
########NEW FILE########
__FILENAME__ = portage
#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# This file is part of box-linux-sync.
#
# Copyright (C) 2013 Vítor Brandão <noisebleed@noiselabs.org>
#
# box-linux-sync is free software; you can redistribute it  and/or modify it
# under the terms of the GNU Lesser General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# box-linux-sync is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with box-linux-sync; if not, see
# <http://www.gnu.org/licenses/>.

from noiselabs.box.pms.pms import BasePMS

class Portage(BasePMS):
    """Portage is a package management system used by Gentoo Linux."""

    def __str__(self):
        return 'Portage'

    def search(self, pkg):
        return "emerge  --searchdesc %s" % pkg

    def install(self, pkg):
        return "emerge %s" % pkg

    def remove(self, pkg):
        return "emerge --unmerge %s" % pkg

########NEW FILE########
__FILENAME__ = slackpkg
#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# This file is part of box-linux-sync.
#
# Copyright (C) 2013 Vítor Brandão <noisebleed@noiselabs.org>
#
# box-linux-sync is free software; you can redistribute it  and/or modify it
# under the terms of the GNU Lesser General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# box-linux-sync is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with box-linux-sync; if not, see
# <http://www.gnu.org/licenses/>.

from noiselabs.box.pms.pms import BasePMS

class Slackpkg(BasePMS):
    """slackpkg is a software tool for installing or upgrading packages
    automatically through a network or over the Internet for Slackware."""

    def __str__(self):
        return 'slackpkg'

    def search(self, pkg):
        return "slackpkg search %s" % pkg

    def install(self, pkg):
        return "slackpkg install %s" % pkg

    def remove(self, pkg):
        return "slackpkg remove %s" % pkg

########NEW FILE########
__FILENAME__ = yum
#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# This file is part of box-linux-sync.
#
# Copyright (C) 2013 Vítor Brandão <noisebleed@noiselabs.org>
#
# box-linux-sync is free software; you can redistribute it  and/or modify it
# under the terms of the GNU Lesser General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# box-linux-sync is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with box-linux-sync; if not, see
# <http://www.gnu.org/licenses/>.

from noiselabs.box.pms.pms import BasePMS

class YUM(BasePMS):
    """The Yellowdog Updater, Modified (YUM) is an open-source command-line
    package-management utility for RPM-compatible Linux operating systems"""

    def __str__(self):
        return 'Yum'

    def search(self, pkg):
        return "yum search %s" % pkg

    def install(self, pkg):
        return "yum install %s" % pkg

    def remove(self, pkg):
        return "yum remove %s" % pkg

########NEW FILE########
__FILENAME__ = utils
#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# This file is part of box-linux-sync.
#
# Copyright (C) 2013 Vítor Brandão <noisebleed@noiselabs.org>
#
# box-linux-sync is free software; you can redistribute it  and/or modify it
# under the terms of the GNU Lesser General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your option)
# any later version.
#
# box-linux-sync is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with box-linux-sync; if not, see
# <http://www.gnu.org/licenses/>.

import pwd
import os

def get_username():
    return pwd.getpwuid(os.getuid()).pw_name

def create_file(filepath, dirmode=0700, filemode=0600):
    """
    Creates a new file
    """
    if not os.path.isfile(filepath):
        # if the base dir doesn't exist we need to create it first
        basedir = os.path.dirname(filepath) 
        if not os.path.isdir(basedir):
            os.makedirs(os.path.dirname(filepath), dirmode)
        # create the file
        f = open(filepath, 'w+')
        f.write('')
        f.close()
        os.chmod(filepath, filemode)
        return True
    else:
        return False
    

########NEW FILE########
