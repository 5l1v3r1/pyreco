__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# nose2 documentation build configuration file, created by
# sphinx-quickstart on Thu Oct  7 15:16:09 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))
sys.path.append(os.path.abspath('_themes'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.intersphinx', 'sphinx.ext.todo', 'sphinx.ext.coverage', 'sphinx.ext.ifconfig', 'sphinx.ext.viewcode', 'nose2.sphinxext']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'nose2'
copyright = u'2010, Jason Pellerin'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.4'
# The full version, including alpha/beta/rc tags.
release = '0.4.7'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
#html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'nose2doc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'nose2.tex', u'nose2 Documentation',
   u'Jason Pellerin', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'nose2', u'nose2 Documentation',
     [u'Jason Pellerin'], 1)
]


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'python': ('http://docs.python.org/', None)}

########NEW FILE########
__FILENAME__ = attrib_example
import unittest


class Test(unittest.TestCase):

    def test_fast(self):
        pass
    test_fast.fast = 1
    test_fast.layer = 2
    test_fast.flags = ['blue', 'green']

    def test_faster(self):
        pass
    test_faster.fast = 1
    test_faster.layer = 1
    test_faster.flags = ['red', 'green']

    def test_slow(self):
        pass
    test_slow.fast = 0
    test_slow.slow = 1
    test_slow.layer = 2

    def test_slower(self):
        pass
    test_slower.slow = 1
    test_slower.layer = 3
    test_slower.flags = ['blue', 'red']

########NEW FILE########
__FILENAME__ = ordereddict
# {{{ http://code.activestate.com/recipes/576693/ (r9)
# Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.
# Passes Python2.7's test suite and incorporates all the latest updates.

try:
    from thread import get_ident as _get_ident
except ImportError:
    from dummy_thread import get_ident as _get_ident

try:
    from _abcoll import KeysView, ValuesView, ItemsView
except ImportError:
    pass


class OrderedDict(dict):

    'Dictionary that remembers insertion order'
    # An inherited dict maps keys to values.
    # The inherited dict provides __getitem__, __len__, __contains__, and get.
    # The remaining methods are order-aware.
    # Big-O running times for all methods are the same as for regular
    # dictionaries.

    # The internal self.__map dictionary maps keys to links in a doubly linked list.
    # The circular doubly linked list starts and ends with a sentinel element.
    # The sentinel element never gets deleted (this simplifies the algorithm).
    # Each link is stored as a list of length three:  [PREV, NEXT, KEY].

    def __init__(self, *args, **kwds):
        '''Initialize an ordered dictionary.  Signature is the same as for
        regular dictionaries, but keyword arguments are not recommended
        because their insertion order is arbitrary.

        '''
        if len(args) > 1:
            raise TypeError('expected at most 1 arguments, got %d' % len(args))
        try:
            self.__root
        except AttributeError:
            self.__root = root = []                     # sentinel node
            root[:] = [root, root, None]
            self.__map = {}
        self.__update(*args, **kwds)

    def __setitem__(self, key, value, dict_setitem=dict.__setitem__):
        'od.__setitem__(i, y) <==> od[i]=y'
        # Setting a new item creates a new link which goes at the end of the linked
        # list, and the inherited dictionary is updated with the new key/value
        # pair.
        if key not in self:
            root = self.__root
            last = root[0]
            last[1] = root[0] = self.__map[key] = [last, root, key]
        dict_setitem(self, key, value)

    def __delitem__(self, key, dict_delitem=dict.__delitem__):
        'od.__delitem__(y) <==> del od[y]'
        # Deleting an existing item uses self.__map to find the link which is
        # then removed by updating the links in the predecessor and successor
        # nodes.
        dict_delitem(self, key)
        link_prev, link_next, key = self.__map.pop(key)
        link_prev[1] = link_next
        link_next[0] = link_prev

    def __iter__(self):
        'od.__iter__() <==> iter(od)'
        root = self.__root
        curr = root[1]
        while curr is not root:
            yield curr[2]
            curr = curr[1]

    def __reversed__(self):
        'od.__reversed__() <==> reversed(od)'
        root = self.__root
        curr = root[0]
        while curr is not root:
            yield curr[2]
            curr = curr[0]

    def clear(self):
        'od.clear() -> None.  Remove all items from od.'
        try:
            for node in self.__map.itervalues():
                del node[:]
            root = self.__root
            root[:] = [root, root, None]
            self.__map.clear()
        except AttributeError:
            pass
        dict.clear(self)

    def popitem(self, last=True):
        '''od.popitem() -> (k, v), return and remove a (key, value) pair.
        Pairs are returned in LIFO order if last is true or FIFO order if false.

        '''
        if not self:
            raise KeyError('dictionary is empty')
        root = self.__root
        if last:
            link = root[0]
            link_prev = link[0]
            link_prev[1] = root
            root[0] = link_prev
        else:
            link = root[1]
            link_next = link[1]
            root[1] = link_next
            link_next[0] = root
        key = link[2]
        del self.__map[key]
        value = dict.pop(self, key)
        return key, value

    # -- the following methods do not depend on the internal structure --

    def keys(self):
        'od.keys() -> list of keys in od'
        return list(self)

    def values(self):
        'od.values() -> list of values in od'
        return [self[key] for key in self]

    def items(self):
        'od.items() -> list of (key, value) pairs in od'
        return [(key, self[key]) for key in self]

    def iterkeys(self):
        'od.iterkeys() -> an iterator over the keys in od'
        return iter(self)

    def itervalues(self):
        'od.itervalues -> an iterator over the values in od'
        for k in self:
            yield self[k]

    def iteritems(self):
        'od.iteritems -> an iterator over the (key, value) items in od'
        for k in self:
            yield (k, self[k])

    def update(*args, **kwds):
        '''od.update(E, **F) -> None.  Update od from dict/iterable E and F.

        If E is a dict instance, does:           for k in E: od[k] = E[k]
        If E has a .keys() method, does:         for k in E.keys(): od[k] = E[k]
        Or if E is an iterable of items, does:   for k, v in E: od[k] = v
        In either case, this is followed by:     for k, v in F.items(): od[k] = v

        '''
        if len(args) > 2:
            raise TypeError('update() takes at most 2 positional '
                            'arguments (%d given)' % (len(args),))
        elif not args:
            raise TypeError('update() takes at least 1 argument (0 given)')
        self = args[0]
        # Make progressively weaker assumptions about "other"
        other = ()
        if len(args) == 2:
            other = args[1]
        if isinstance(other, dict):
            for key in other:
                self[key] = other[key]
        elif hasattr(other, 'keys'):
            for key in other.keys():
                self[key] = other[key]
        else:
            for key, value in other:
                self[key] = value
        for key, value in kwds.items():
            self[key] = value

    __update = update  # let subclasses override update without breaking __init__

    __marker = object()

    def pop(self, key, default=__marker):
        '''od.pop(k[,d]) -> v, remove specified key and return the corresponding value.
        If key is not found, d is returned if given, otherwise KeyError is raised.

        '''
        if key in self:
            result = self[key]
            del self[key]
            return result
        if default is self.__marker:
            raise KeyError(key)
        return default

    def setdefault(self, key, default=None):
        'od.setdefault(k[,d]) -> od.get(k,d), also set od[k]=d if k not in od'
        if key in self:
            return self[key]
        self[key] = default
        return default

    def __repr__(self, _repr_running={}):
        'od.__repr__() <==> repr(od)'
        call_key = id(self), _get_ident()
        if call_key in _repr_running:
            return '...'
        _repr_running[call_key] = 1
        try:
            if not self:
                return '%s()' % (self.__class__.__name__,)
            return '%s(%r)' % (self.__class__.__name__, self.items())
        finally:
            del _repr_running[call_key]

    def __reduce__(self):
        'Return state information for pickling'
        items = [[k, self[k]] for k in self]
        inst_dict = vars(self).copy()
        for k in vars(OrderedDict()):
            inst_dict.pop(k, None)
        if inst_dict:
            return (self.__class__, (items,), inst_dict)
        return self.__class__, (items,)

    def copy(self):
        'od.copy() -> a shallow copy of od'
        return self.__class__(self)

    @classmethod
    def fromkeys(cls, iterable, value=None):
        '''OD.fromkeys(S[, v]) -> New ordered dictionary with keys from S
        and values equal to v (which defaults to None).

        '''
        d = cls()
        for key in iterable:
            d[key] = value
        return d

    def __eq__(self, other):
        '''od.__eq__(y) <==> od==y.  Comparison to another OD is order-sensitive
        while comparison to a regular mapping is order-insensitive.

        '''
        if isinstance(other, OrderedDict):
            return len(self) == len(other) and self.items() == other.items()
        return dict.__eq__(self, other)

    def __ne__(self, other):
        return not self == other

    # -- the following methods are only used in Python 2.7 --

    def viewkeys(self):
        "od.viewkeys() -> a set-like object providing a view on od's keys"
        return KeysView(self)

    def viewvalues(self):
        "od.viewvalues() -> an object providing a view on od's values"
        return ValuesView(self)

    def viewitems(self):
        "od.viewitems() -> a set-like object providing a view on od's items"
        return ItemsView(self)
# end of http://code.activestate.com/recipes/576693/ }}}

########NEW FILE########
__FILENAME__ = collector
import sys
import unittest

from nose2 import loader, runner, session
from nose2.main import PluggableTestProgram
__unittest = True


def collector():
    class Test(unittest.TestCase):

        def run(self, result_):
            ok = self._collector(result_)
            sys.exit(not ok)

        def _collector(self, result_):
            ssn = session.Session()
            ldr = loader.PluggableTestLoader(ssn)
            rnr = runner.PluggableTestRunner(ssn)

            ssn.loadConfigFiles('unittest.cfg', 'nose2.cfg', 'setup.cfg')
            ssn.setStartDir()
            ssn.prepareSysPath()
            ssn.loadPlugins(PluggableTestProgram.defaultPlugins)

            test = ldr.loadTestsFromNames([], None)
            rslt = rnr.run(test)
            return rslt.wasSuccessful()

    return Test('_collector')

########NEW FILE########
__FILENAME__ = compat
"""unittest/unittest2 compatibilty wrapper.

Anything internal to nose2 *must* import unittest from here, to be
sure that it is using unittest2 when on older pythons.

Yes::

  from nose2.compat import unittest

**NO**::

  import unittest

**NO**::

  import unittest2

"""
try:
    import unittest2 as unittest
except ImportError:
    import unittest


try:
    unittest.installHandler
except AttributeError:
    raise ImportError(
        "Built-in unittest version too old, unittest2 is required")

__unittest = True


try:
    from collections import OrderedDict
except ImportError:
    from .backports.ordereddict import OrderedDict

########NEW FILE########
__FILENAME__ = config
TRUE_VALS = set(['1', 't', 'true', 'on', 'yes', 'y'])
__unittest = True


class Config(object):

    """Configuration for a plugin or other entities.

    Encapsulates configuration for a single plugin or other element.
    Corresponds to a :class:`ConfigParser.Section` but provides an
    extended interface for extracting items as a certain type.

    """

    def __init__(self, items):
        self._items = items
        self._mvd = {}
        for k, v in items:
            self._mvd.setdefault(k, []).append(v)

    def __getitem__(self, key):
        return self._mvd[key]

    def as_bool(self, key, default=None):
        """Get key value as boolean

        1, t, true, on, yes and y (case insensitive) are accepted as True
        values. All other values are False.

        """
        try:
            val = self._mvd[key][0].strip()
        except KeyError:
            return default
        except IndexError:
            # setting = -> False
            return False
        return val.lower() in TRUE_VALS

    def as_int(self, key, default=None):
        """Get key value as integer"""
        return self._cast(key, int, default)

    def as_float(self, key, default=None):
        """Get key value as float"""
        return self._cast(key, float, default)

    def as_str(self, key, default=None):
        """Get key value as str"""
        return self._cast(key, str, default)

    def as_list(self, key, default=None):
        """Get key value as list.

        The value is split into lines and returned as a list. Lines
        are stripped of whitespace, and lines beginning with # are
        skipped.

        """
        lines = []
        try:
            vlist = self[key]
        except KeyError:
            return default
        for val in vlist:
            lines.extend(
                line.strip() for line in val.splitlines()
                if line.strip() and not line.strip().startswith('#'))
        return lines

    def get(self, key, default=None):
        """Get key value"""
        return self.as_str(key, default)

    def _cast(self, key, type_, default):
        try:
            return type_(self._mvd[key][0].strip())
        except (KeyError, IndexError):
            return default

########NEW FILE########
__FILENAME__ = events
# Adapted from unittest2/events.py from the unittest2 plugins branch.
# This module contains some code copied from unittest2/events.py and other
# code developed in reference to that module and others within unittest2.
# unittest2 is Copyright (c) 2001-2010 Python Software Foundation; All
# Rights Reserved. See: http://docs.python.org/license.html

import logging

import argparse
import six

from nose2 import config, util

log = logging.getLogger(__name__)
__unittest = True

# FIXME decide on a real rule for camelCase vs under_score and stick with it.

# XXX I'd rather move this stuff to Plugin.__init__ and
# have __init__ call self.configure() or something after the
# initial setup, but that would further break compatibilty
# with the unittest2 plugins branch Plugin class.


class PluginMeta(type):

    def __call__(cls, *args, **kwargs):
        session = kwargs.pop('session', None)
        instance = object.__new__(cls, *args, **kwargs)
        instance.session = session
        instance.config = config.Config([])

        config_section = getattr(instance, 'configSection', None)
        switch = getattr(instance, 'commandLineSwitch', None)

        if session is not None and config_section is not None:
            instance.config = session.get(config_section)

        always_on = instance.config.as_bool(
            'always-on', default=instance.alwaysOn)

        instance.__init__(*args, **kwargs)
        if always_on:
            instance.register()
        else:
            if switch is not None:
                short_opt, long_opt, help = switch
                instance.addOption(
                    instance._register_cb, short_opt, long_opt, help)
        return instance


class Plugin(six.with_metaclass(PluginMeta)):

    """Base class for nose2 plugins

    All nose2 plugins must subclass this class.

    .. attribute :: session

       The :class:`nose2.session.Session` under which the plugin
       has been loaded.

    .. attribute :: config

       The :class:`nose2.config.Config` representing the plugin's
       config section as loaded from the session's config files.

    .. attribute :: commandLineSwitch

       A tuple of (short opt, long opt, help text) that defines a command
       line flag that activates this plugin. The short opt may be None. If
       defined, it must be a single upper-case character. Both short and
       long opt must *not* start with dashes.

       Example::

         commandLineSwitch = ('B', 'buffer-output', 'Buffer output during tests')

    .. attribute :: configSection

       The name config file section to load into this plugin's config.

    .. attribute :: alwaysOn

       If this plugin should automatically register itself, set alwaysOn to
       True. Default is False.

    .. note ::

       Plugins that use config values from config files and want to
       use the nose2 sphinx extension to automatically generate
       documentation *must* extract all config values from
       ``self.config`` in ``__init__``. Otherwise the extension will
       not be able to detect the config keys that the plugin uses.

    """
    alwaysOn = False
    registered = False

    def register(self):
        """Register with appropriate hooks.

        This activates the plugin and enables it to receive events.

        """
        if self.session is None:
            log.warning("Unable to register %s, no session", self)
            return
        self.session.registerPlugin(self)
        self.registered = True

    def addMethods(self, *methods):
        """Add new plugin methods to hooks registry

        Any plugins that are already registered and implement
        a method added here will be registered for that
        method as well.

        """
        for method in methods:
            self.session.hooks.addMethod(method)
        for plugin in self.session.plugins:
            for method in methods:
                if plugin.registered and hasattr(plugin, method):
                    self.session.hooks.register(method, plugin)

    def _register_cb(self, *_):
        self.register()

    def addFlag(self, callback, short_opt, long_opt, help_text=None):
        """Add command-line flag that takes no arguments

        :param callback: Callback function to run when flag is seen.
                         The callback will receive one empty argument.
        :param short_opt: Short option. Must be uppercase, no dashes.
        :param long_opt: Long option. Must not start with dashes
        :param help_text: Help text for users so they know what this
                          flag does.

        """
        self.addOption(callback, short_opt, long_opt, help_text, nargs=0)

    def addArgument(self, callback, short_opt, long_opt, help_text=None):
        """Add command-line option that takes one argument.

        :param callback: Callback function to run when flag is seen.
                         The callback will receive one argument.
        :param short_opt: Short option. Must be uppercase, no dashes.
        :param long_opt: Long option. Must not start with dashes
        :param help_text: Help text for users so they know what this
                          flag does.

        """
        self.addOption(callback, short_opt, long_opt, help_text, nargs=1)

    def addOption(self, callback, short_opt, long_opt, help_text=None, nargs=0):
        """Add command-line option.

        :param callback: Callback function to run when flag is seen.
                         The callback will receive one argument.
                         The "callback" may also be a list, in which
                         case values submitted on the command line
                         will be appended to the list.
        :param short_opt: Short option. Must be uppercase, no dashes.
        :param long_opt: Long option. Must not start with dashes
        :param help_text: Help text for users so they know what this
                          flag does.
        :param nargs: Number of arguments to consume from command line.

        """
        if self.session is None:
            log.warning("Unable to add option %s/%s for %s, no session",
                        short_opt, long_opt, self)
            return

        class CB(argparse.Action):

            def __call__(self, parser, namespace, values, option_string=None):
                if six.callable(callback):
                    callback(values)
                elif isinstance(callback, list):
                    callback.extend(values)
                else:
                    raise ValueError(
                        "Invalid callback %s for plugin option %s",
                        callback, option_string)
        opts = []
        if short_opt:
            if short_opt.lower() == short_opt:
                raise ValueError(
                    'Lowercase short options are reserved: %s' % short_opt)
            opts.append('-' + short_opt)
        if long_opt:
            opts.append('--' + long_opt)
        self.session.pluginargs.add_argument(
            *opts, action=CB, help=help_text, const=True, nargs=nargs)


class Hook(object):

    """A plugin hook

    Each plugin method in the :class:`nose2.events.PluginInterface` is
    represented at runtime by a Hook instance that lists the plugins
    that should be called by that hook.

    .. attribute :: method

       The name of the method that this Hook represents.

    .. attribute :: plugins

       The list of plugin instances bound to this hook.

    """

    def __init__(self, method):
        self.method = method
        self.plugins = []

    def __call__(self, event):
        for plugin in self.plugins[:]:
            result = getattr(plugin, self.method)(event)
            if event.handled:
                return result

    def append(self, plugin):
        if plugin not in self.plugins:
            self.plugins.append(plugin)


class PluginInterface(object):

    """Definition of plugin interface.

    Instances of this class contain the methods that may be called,
    and a dictionary of :class:`nose2.events.Hook` instances bound
    to each method.

    In a plugin, PluginInterface instance is typically available as
    self.session.hooks, and plugin hooks may be called on it
    directly::

      event = events.LoadFromModuleEvent(module=the_module)
      self.session.hooks.loadTestsFromModule(event)

    .. attribute :: preRegistrationMethods

       Tuple of methods that are called before registration.

    .. attribute :: methods

       Tuple of available plugin hook methods.

    .. attribute :: hookClass

       Class to instantiate for each hook. Default: :class:`nose2.events.Hook`.

    """
    preRegistrationMethods = ('pluginsLoaded', 'handleArgs')
    methods = (
        'loadTestsFromModule', 'loadTestsFromNames',
        'handleFile', 'startTestRun', 'startTest', 'stopTest',
        'loadTestsFromName', 'loadTestsFromTestCase',
        'stopTestRun', 'matchPath', 'matchDirPath', 'getTestCaseNames',
        'runnerCreated', 'resultCreated', 'testOutcome', 'wasSuccessful',
        'resultStop', 'setTestOutcome', 'describeTest',
        'reportStartTest', 'reportError', 'reportFailure', 'reportSkip',
        'reportSuccess', 'reportExpectedFailure', 'reportUnexpectedSuccess',
        'reportOtherOutcome', 'outcomeDetail', 'beforeErrorList',
        'beforeSummaryReport', 'afterSummaryReport', 'beforeInteraction',
        'afterInteraction', 'createTests', 'afterTestRun',
        'moduleLoadedSuite', 'handleDir',
        # ... etc?
    )
    hookClass = Hook

    def __init__(self):
        self.hooks = {}

    def addMethod(self, method):
        """Add a method to the available method.

        This allows plugins to register for this method.

        :param method: A method name

        """
        self.methods = self.methods + (method,)

    def register(self, method, plugin):
        """Register a plugin for a method.

        :param method: A method name
        :param plugin: A plugin instance

        """
        self.hooks.setdefault(method, self.hookClass(method)).append(plugin)

    def __getattr__(self, attr):
        return self.hooks.setdefault(attr, self.hookClass(attr))


class Event(object):

    """Base class for all events.

    .. attribute :: metadata

       Storage for arbitrary information attached to an event.

    .. attribute :: handled

       Set to True to indicate that a plugin has handled the event,
       and no other plugins or core systems should process it further.

    .. attribute :: version

       Version of the event API. This will be incremented with each
       release of nose2 that changes the API.

    """
    _attrs = ('handled',)
    version = '0.4'

    def __init__(self, **metadata):
        self.handled = False
        self.metadata = {}
        self.metadata.update(metadata)

    def __str__(self):
        return '%s(%s)' % (self.__class__.__name__, self._format())

    def __repr__(self):
        return str(self)

    def _format(self):
        return ', '.join(['%s=%r' % (k, getattr(self, k, None))
                          for k in self._attrs])

    def __getstate__(self):
        state = self.__dict__
        # FIXME fails for loadTestsFailure
        if 'test' in state:
            state['test'] = util.test_name(state['test'])
        if 'executeTests' in state:
            state['executeTests'] = None
        if 'exc_info' in state and state['exc_info'] is not None:
            ec, ev, tb = state['exc_info']
            state['exc_info'] = (
                ec, ev, util.format_traceback(None, (ec, ev, tb)))
        clear = ('loader', 'result', 'runner')
        for attr in clear:
            if attr in state:
                state[attr] = None
        return state


class PluginsLoadedEvent(Event):

    """Event fired after all plugin classes are loaded.

    .. attribute :: pluginsLoaded

       List of all loaded plugin classes

    """
    _attrs = Event._attrs + ('pluginsLoaded',)

    def __init__(self, pluginsLoaded, **kw):
        self.pluginsLoaded = pluginsLoaded
        super(PluginsLoadedEvent, self).__init__(**kw)


class RunnerCreatedEvent(Event):

    """Event fired when test runner is created.

    .. attribute :: runner

       Test runner instance. Plugins may replace the test runner by
       setting this attribute to a new test runner instance.

    """
    _attrs = Event._attrs + ('runner',)

    def __init__(self, runner, **kw):
        self.runner = runner
        super(RunnerCreatedEvent, self).__init__(**kw)


class ResultCreatedEvent(Event):

    """Event fired when test result handler is created.

    .. attribute :: result

       Test result handler instance. Plugins may replace the test
       result by setting this attribute to a new test result instance.

    """
    _attrs = Event._attrs + ('result',)

    def __init__(self, result, **kw):
        self.result = result
        super(ResultCreatedEvent, self).__init__(**kw)


class StartTestRunEvent(Event):

    """Event fired when test run is about to start.

    Test collection is complete before this event fires, but
    no tests have yet been executed.

    .. attribute :: runner

       Test runner

    .. attribute :: suite

       Top-level test suite to execute. Plugins can filter this suite,
       or set event.suite to change which tests execute (or how they
       execute).

    .. attribute :: result

       Test result

    .. attribute :: startTime

       Timestamp of test run start

    .. attribute :: executeTests

       Callable that will be used to execute tests.  Plugins may set
       this attribute to wrap or otherwise change test execution. The
       callable must match the signature::

         def execute(suite, result):
             ...

    To prevent normal test execution, plugins may set ``handled`` on
    this event to True. When ``handled`` is true, the test executor
    does not run at all.

    """
    _attrs = Event._attrs + ('runner', 'suite', 'result', 'startTime',
                             'executeTests')

    def __init__(self, runner, suite, result, startTime, executeTests, **kw):
        self.suite = suite
        self.runner = runner
        self.result = result
        self.startTime = startTime
        self.executeTests = executeTests
        super(StartTestRunEvent, self).__init__(**kw)


class StopTestRunEvent(Event):

    """Event fired when test run has stopped.

    .. attribute :: runner

       Test runner

    .. attribute :: result

       Test result

    .. attribute :: stopTime

       Timestamp of test run stop

    .. attribute :: timeTaken

       Number of seconds test run took to execute

    """
    _attrs = Event._attrs + ('runner', 'result', 'stopTime', 'timeTaken')

    def __init__(self, runner, result, stopTime, timeTaken, **kw):
        self.runner = runner
        self.result = result
        self.stopTime = stopTime
        self.timeTaken = timeTaken
        super(StopTestRunEvent, self).__init__(**kw)


class StartTestEvent(Event):

    """Event fired before a test is executed.

    .. attribute :: test

       The test case

    .. attribute :: result

       Test result

    .. attribute :: startTime

       Timestamp of test start

    """
    _attrs = Event._attrs + ('test', 'result', 'startTime')

    def __init__(self, test, result, startTime, **kw):
        self.test = test
        self.result = result
        self.startTime = startTime
        super(StartTestEvent, self).__init__(**kw)


class StopTestEvent(Event):

    """Event fired after a test is executed.

    .. attribute :: test

       The test case

    .. attribute :: result

       Test result

    .. attribute :: stopTime

       Timestamp of test stop

    """
    _attrs = Event._attrs + ('test', 'result', 'stopTime')

    def __init__(self, test, result, stopTime, **kw):
        self.test = test
        self.result = result
        self.stopTime = stopTime
        super(StopTestEvent, self).__init__(**kw)


class TestOutcomeEvent(Event):

    """Event fired when a test completes.

    .. attribute :: test

       The test case

    .. attribute :: result

       Test result

    .. attribute :: outcome

       Description of test outcome. Typically will be one of 'error',
       'failed', 'skipped', or 'passed'.

    .. attribute :: exc_info

       If the test resulted in an exception, the tuple of (exception
       class, exception value, traceback) as returned by
       sys.exc_info(). If the test did not result in an exception,
       None.

    .. attribute :: reason

       For test outcomes that include a reason (Skips, for example),
       the reason.

    .. attribute :: expected

       Boolean indicating whether the test outcome was expected. In
       general, all tests are expected to pass, and any other outcome
       will have expected as False. The exceptions to that rule are
       unexpected successes and expected failures.

    .. attribute :: shortLabel

       A short label describing the test outcome. (For example, 'E'
       for errors).

    .. attribute :: longLabel

       A long label describing the test outcome (for example, 'ERROR'
       for errors).

    Plugins may influence how the rest of the system sees the test
    outcome by setting ``outcome`` or ``exc_info`` or ``expected``. They
    may influence how the test outcome is reported to the user by
    setting ``shortLabel`` or ``longLabel``.

    """
    _attrs = Event._attrs + ('test', 'result', 'outcome', 'exc_info', 'reason',
                             'expected', 'shortLabel', 'longLabel')

    def __init__(self, test, result, outcome, exc_info=None, reason=None,
                 expected=False, shortLabel=None, longLabel=None, **kw):
        self.test = test
        self.result = result
        self.outcome = outcome
        self.exc_info = exc_info
        self.reason = reason
        self.expected = expected
        self.shortLabel = shortLabel
        self.longLabel = longLabel
        super(TestOutcomeEvent, self).__init__(**kw)


class LoadFromModuleEvent(Event):

    """Event fired when a test module is loaded.

    .. attribute :: loader

       Test loader instance

    .. attribute :: module

       The module whose tests are to be loaded

    .. attribute :: extraTests

       A list of extra tests loaded from the module. To load tests
       from a module without interfering with other plugins' loading
       activities, append tests to extraTests.

    Plugins may set ``handled`` on this event and return a test suite
    to prevent other plugins from loading tests from the module. If
    any plugin sets ``handled`` to True, ``extraTests`` will be
    ignored.

    """
    _attrs = Event._attrs + ('loader', 'module', 'extraTests')

    def __init__(self, loader, module, **kw):
        self.loader = loader
        self.module = module
        self.extraTests = []
        super(LoadFromModuleEvent, self).__init__(**kw)


class ModuleSuiteEvent(Event):
    _attrs = Event._attrs + ('loader', 'module', 'suite')

    def __init__(self, loader, module, suite, **kw):
        self.loader = loader
        self.module = module
        self.suite = suite
        super(ModuleSuiteEvent, self).__init__(**kw)


class LoadFromTestCaseEvent(Event):

    """Event fired when tests are loaded from a test case.

    .. attribute :: loader

       Test loader instance

    .. attribute :: testCase

       The :class:`unittest.TestCase` instance being loaded.

    .. attribute :: extraTests

        A list of extra tests loaded from the module. To load tests
        from a test case without interfering with other plugins'
        loading activities, append tests to extraTests.

    Plugins may set ``handled`` on this event and return a test suite
    to prevent other plugins from loading tests from the test case. If
    any plugin sets ``handled`` to True, ``extraTests`` will be
    ignored.

    """
    _attrs = Event._attrs + ('loader', 'testCase', 'extraTests')

    def __init__(self, loader, testCase, **kw):
        self.loader = loader
        self.testCase = testCase
        self.extraTests = []
        super(LoadFromTestCaseEvent, self).__init__(**kw)


class LoadFromNamesEvent(Event):

    """Event fired to load tests from test names.

    .. attribute :: loader

       Test loader instance

    .. attribute :: names

       List of test names. May be empty or None.

    .. attribute :: module

       Module to load from. May be None. If not None, names should be
       considered relative to this module.

    .. attribute :: extraTests

        A list of extra tests loaded from the tests named. To load
        tests from test names without interfering with other plugins'
        loading activities, append tests to extraTests.

    Plugins may set ``handled`` on this event and return a test suite
    to prevent other plugins from loading tests from the test names. If
    any plugin sets ``handled`` to True, ``extraTests`` will be
    ignored.

    """
    _attrs = Event._attrs + ('loader', 'names', 'module', 'extraTests')

    def __init__(self, loader, names, module, **kw):
        self.loader = loader
        self.names = names
        self.module = module
        self.extraTests = []
        super(LoadFromNamesEvent, self).__init__(**kw)

    def __str__(self):
        return "LoadFromNames(names=%r, module=%r)" % (self.names, self.module)


class LoadFromNameEvent(Event):

    """Event fired to load tests from test names.

    .. attribute :: loader

       Test loader instance

    .. attribute :: name

       Test name to load

    .. attribute :: module

       Module to load from. May be None. If not None, names should be
       considered relative to this module.

    .. attribute :: extraTests

        A list of extra tests loaded from the name. To load tests
        from a test name without interfering with other plugins'
        loading activities, append tests to extraTests.

    Plugins may set ``handled`` on this event and return a test suite
    to prevent other plugins from loading tests from the test name. If
    any plugin sets ``handled`` to True, ``extraTests`` will be
    ignored.

    """
    _attrs = Event._attrs + ('loader', 'name', 'module', 'extraTests')

    def __init__(self, loader, name, module, **kw):
        self.loader = loader
        self.name = name
        self.module = module
        self.extraTests = []
        super(LoadFromNameEvent, self).__init__(**kw)


class HandleFileEvent(Event):

    """Event fired when a non-test file is examined.

    .. note ::

       This event is *not* fired for python modules that
       match the test file pattern.

    .. attribute :: loader

       Test loader instance

    .. attribute :: name

       File basename

    .. attribute :: path

       Full path to file

    .. attribute :: pattern

       Current test file match pattern

    .. attribute :: topLevelDirectory

       Top-level directory of the test run

    .. attribute :: extraTests

        A list of extra tests loaded from the file. To load tests
        from a file without interfering with other plugins'
        loading activities, append tests to extraTests.

    Plugins may set ``handled`` on this event and return a test suite
    to prevent other plugins from loading tests from the file. If
    any plugin sets ``handled`` to True, ``extraTests`` will be
    ignored.

    """
    _attrs = Event._attrs + ('loader', 'name', 'path', 'pattern',
                             'topLevelDirectory')

    def __init__(self, loader, name, path, pattern, topLevelDirectory, **kw):
        self.extraTests = []
        self.path = path
        self.loader = loader
        self.name = name
        # note: pattern may be None if not called during test discovery
        self.pattern = pattern
        self.topLevelDirectory = topLevelDirectory
        super(HandleFileEvent, self).__init__(**kw)


class MatchPathEvent(Event):

    """Event fired during file matching.

    Plugins may return False and set ``handled`` on this event to prevent
    a file from being matched as a test file, regardless of other system
    settings.

    .. attribute :: path

       Full path to the file

    .. attribute :: name

       File basename

    .. attribute :: pattern

       Current test file match pattern

    """
    _attrs = Event._attrs + ('name', 'path', 'pattern')

    def __init__(self, name, path, pattern, **kw):
        self.path = path
        self.name = name
        self.pattern = pattern
        super(MatchPathEvent, self).__init__(**kw)


class GetTestCaseNamesEvent(Event):

    """Event fired to find test case names in a test case.

    Plugins may return a list of names and set ``handled`` on this
    event to force test case name selection.


    .. attribute :: loader

       Test loader instance

    .. attribute :: testCase

       The :class:`unittest.TestCase` instance being loaded.

    .. attribute :: testMethodPrefix

       Set this to change the test method prefix. Unless set by a plugin,
       it is None.

    .. attribute :: extraNames

       A list of extra test names to load from the test case. To cause
       extra tests to be loaded from the test case, append the names
       to this list. Note that the names here must be attributes of
       the test case.

    .. attribute :: excludedNames

       A list of names to exclude from test loading. Add names to this
       list to prevent other plugins from loading the named tests.

    .. attribute :: isTestMethod

       Callable that plugins can use to examine test case attributes to
       determine whether nose2 thinks they are test methods.

    """
    _attrs = Event._attrs + ('loader', 'testCase', 'testMethodPrefix',
                             'extraNames', 'excludedNames', 'isTestMethod')

    def __init__(self, loader, testCase, isTestMethod, **kw):
        self.loader = loader
        self.testCase = testCase
        self.testMethodPrefix = None
        self.extraNames = []
        self.excludedNames = []
        self.isTestMethod = isTestMethod
        super(GetTestCaseNamesEvent, self).__init__(**kw)


class ResultSuccessEvent(Event):

    """Event fired at end of test run to determine success.

    This event fires at the end of the test run and allows
    plugins to determine whether the test run was successful.

    .. attribute :: result

       Test result

    .. attribute :: success

       Set this to True to indicate that the test run was
       successful. If no plugin sets the ``success`` to
       True, the test run fails.

    """
    _attrs = Event._attrs + ('result', 'success')

    def __init__(self, result, success, **kw):
        self.result = result
        self.success = success
        super(ResultSuccessEvent, self).__init__(**kw)


class ResultStopEvent(Event):

    """Event fired when a test run is told to stop.

    Plugins can use this event to prevent other plugins from stopping
    a test run.

    .. attribute :: result

       Test result

    .. attribute :: shouldStop

       Set to True to indicate that the test run should stop.

    """
    _attrs = Event._attrs + ('result', 'shouldStop')

    def __init__(self, result, shouldStop, **kw):
        self.result = result
        self.shouldStop = shouldStop
        super(ResultStopEvent, self).__init__(**kw)


class DescribeTestEvent(Event):

    """Event fired to get test description.


    .. attribute :: test

       The test case

    .. attribute :: description

       Description of the test case. Plugins can set this to change
       how tests are described in output to users.

    .. attribute :: errorList

       Is the event fired as part of error list output?

    """
    _attrs = Event._attrs + ('test', 'description')

    def __init__(self, test, description=None, errorList=False, **kw):
        self.test = test
        self.description = description
        self.errorList = errorList
        super(DescribeTestEvent, self).__init__(**kw)


class OutcomeDetailEvent(Event):

    """Event fired to acquire additional details about test outcome.

    .. attribute :: outcomeEvent

       A :class:`nose2.events.TestOutcomeEvent` instance holding
       the test outcome to be described.

    .. attribute :: extraDetail

       Extra detail lines to be appended to test outcome
       output. Plugins can append lines (of strings) to this list to
       include their extra information in the error list report.

    """
    _attrs = Event._attrs + ('outcomeEvent', 'extraDetail')

    def __init__(self, outcomeEvent, **kw):
        self.outcomeEvent = outcomeEvent
        self.extraDetail = []
        super(OutcomeDetailEvent, self).__init__(**kw)


class ReportSummaryEvent(Event):

    """Event fired before and after summary report.

    .. attribute :: stopTestEvent

       A :class:`nose2.events.StopTestEvent` instance.

    .. attribute :: stream

       The output stream. Plugins can set this to change or capture
       output.

    .. attribute :: reportCategories

       Dictionary of report category and test events captured in that
       category. Default categories include 'errors', 'failures',
       'skipped', 'expectedFails', and 'unexpectedSuccesses'. Plugins
       may add their own categories.

    """
    _attrs = Event._attrs + ('stopTestEvent', 'stream', 'reportCategories')

    def __init__(self, stopTestEvent, stream, reportCategories, **kw):
        self.stopTestEvent = stopTestEvent
        self.stream = stream
        self.reportCategories = reportCategories
        super(ReportSummaryEvent, self).__init__(**kw)


class ReportTestEvent(Event):

    """Event fired to report a test event.

    Plugins can respond to this event by producing output for the user.

    .. attribute :: testEvent

       A test event. In most cases, a
       :class:`nose2.events.TestOutcomeEvent` instance. For startTest,
       a :class:`nose2.events.StartTestEvent` instance.

    .. attribute :: stream

       The output stream. Plugins can set this to change or capture
       output.

    """
    _attrs = Event._attrs + ('testEvent', 'stream')

    def __init__(self, testEvent, stream, **kw):
        self.testEvent = testEvent
        self.stream = stream
        super(ReportTestEvent, self).__init__(**kw)


class UserInteractionEvent(Event):

    """Event fired before and after user interaction.

    Plugins that capture stdout or otherwise prevent user interaction
    should respond to this event.

    To prevent the user interaction from occurring, return False and
    set ``handled``. Otherwise, turn off whatever you are doing that
    prevents users from typing/clicking/touching/psionics/whatever.

    """

    def __init__(self, **kw):
        super(UserInteractionEvent, self).__init__(**kw)


class CommandLineArgsEvent(Event):

    """Event fired after parsing of command line arguments.

    Plugins can respond to this event by configuring themselves or other plugins
    or modifying the parsed arguments.

    .. note ::

       Many plugins register options with callbacks. By the time this event
       fires, those callbacks have already fired. So you can't use this
       event to reliably influence all plugins.

    .. attribute :: args

       Args object returned by argparse.

    """
    _attrs = Event._attrs + ('args',)

    def __init__(self, args, **kw):
        self.args = args
        super(CommandLineArgsEvent, self).__init__(**kw)


class CreateTestsEvent(Event):

    """Event fired before test loading.

    Plugins can take over test loading by returning a test suite and setting
    ``handled`` on this event.

    .. attribute :: loader

       Test loader instance

    .. attribute :: names

       List of test names. May be empty or None.

    .. attribute :: module

       Module to load from. May be None. If not None, names should be
       considered relative to this module.

    """
    _attrs = Event._attrs + ('loader', 'testNames', 'module')

    def __init__(self, loader, testNames, module, **kw):
        self.loader = loader
        self.testNames = testNames
        self.module = module
        super(CreateTestsEvent, self).__init__(**kw)

########NEW FILE########
__FILENAME__ = exceptions
# This module contains some code copied from unittest2/ and other code
# developed in reference to unittest2.
# unittest2 is Copyright (c) 2001-2010 Python Software Foundation; All
# Rights Reserved. See: http://docs.python.org/license.html
__unittest = True


class TestNotFoundError(Exception):

    """Exception raised when a named test cannot be found"""

########NEW FILE########
__FILENAME__ = loader
# Adapted from unittest2/loader.py from the unittest2 plugins branch.
# This module contains some code copied from unittest2/loader.py and other
# code developed in reference to that module and others within unittest2.
# unittest2 is Copyright (c) 2001-2010 Python Software Foundation; All
# Rights Reserved. See: http://docs.python.org/license.html

import logging
import traceback

from nose2 import events
from nose2.compat import unittest


log = logging.getLogger(__name__)
__unittest = True


class PluggableTestLoader(object):

    """Test loader that defers all loading to plugins

    :param session: Test run session.

    .. attribute :: suiteClass

       Suite class to use. Default: :class:`unittest.TestSuite`.

    """
    suiteClass = unittest.TestSuite

    def __init__(self, session):
        self.session = session

    def loadTestsFromModule(self, module):
        """Load tests from module.

        Fires :func:`loadTestsFromModule` hook.

        """
        evt = events.LoadFromModuleEvent(self, module)
        result = self.session.hooks.loadTestsFromModule(evt)
        if evt.handled:
            suite = result or self.suiteClass()
        else:
            suite = self.suiteClass(evt.extraTests)
        filterevt = events.ModuleSuiteEvent(self, module, suite)
        result = self.session.hooks.moduleLoadedSuite(filterevt)
        if result:
            return result or self.suiteClass()
        return filterevt.suite

    def loadTestsFromNames(self, testNames, module=None):
        """Load tests from test names.

        Fires :func:`loadTestsFromNames` hook.

        """
        event = events.LoadFromNamesEvent(
            self, testNames, module)
        result = self.session.hooks.loadTestsFromNames(event)
        log.debug('loadTestsFromNames event %s result %s', event, result)
        if event.handled:
            suites = result or []
        else:
            if event.names:
                suites = [self.loadTestsFromName(name, module)
                          for name in event.names]
            elif module:
                suites = self.loadTestsFromModule(module)
        if event.extraTests:
            suites.extend(event.extraTests)
        return self.suiteClass(suites)

    def loadTestsFromName(self, name, module=None):
        """Load tests from test name.

        Fires :func:`loadTestsFromName` hook.

        """
        log.debug('loadTestsFromName %s/%s', name, module)
        event = events.LoadFromNameEvent(self, name, module)
        result = self.session.hooks.loadTestsFromName(event)
        if event.handled:
            suite = result or self.suiteClass()
            return suite
        return self.suiteClass(event.extraTests)

    def failedImport(self, name):
        """Make test case representing a failed import."""
        message = 'Failed to import test module: %s' % name
        if hasattr(traceback, 'format_exc'):
            # Python 2.3 compatibility
            # format_exc returns two frames of discover.py as well XXX ?
            message += '\n%s' % traceback.format_exc()
        return self._makeFailedTest(
            'ModuleImportFailure', name, ImportError(message))

    def failedLoadTests(self, name, exception):
        """Make test case representing a failed test load."""
        return self._makeFailedTest('LoadTestsFailure', name, exception)

    def sortTestMethodsUsing(self, name):
        """Sort key for test case test methods."""
        return name.lower()

    def discover(self, start_dir=None, pattern=None):
        """Compatibility shim for load_tests protocol."""
        try:
            oldsd = self.session.startDir
            self.session.startDir = start_dir
            return self.loadTestsFromNames([])
        finally:
            self.session.startDir = oldsd

    def _makeFailedTest(self, classname, methodname, exception):
        def testFailure(self):
            raise exception
        attrs = {methodname: testFailure}
        TestClass = type(classname, (unittest.TestCase,), attrs)
        return self.suiteClass((TestClass(methodname),))

    def __repr__(self):
        return '<%s>' % self.__class__.__name__

########NEW FILE########
__FILENAME__ = main
import logging
import os
import sys

from nose2.compat import unittest
from nose2 import events, loader, runner, session, util


log = logging.getLogger(__name__)
__unittest = True


class PluggableTestProgram(unittest.TestProgram):

    """TestProgram that enables plugins.

    Accepts the same parameters as :class:`unittest.TestProgram`,
    but most of them are ignored as their functions are
    handled by plugins.

    :param module: Module in which to run tests. Default: __main__
    :param defaultTest: Default test name. Default: None
    :param argv: Command line args. Default: sys.argv
    :param testRunner: *IGNORED*
    :param testLoader: *IGNORED*
    :param exit: Exit after running tests?
    :param verbosity: Base verbosity
    :param failfast: *IGNORED*
    :param catchbreak: *IGNORED*
    :param buffer: *IGNORED*
    :param plugins: List of additional plugin modules to load
    :param excludePlugins: List of plugin modules to exclude
    :param extraHooks: List of hook names and plugin *instances* to
                       register with the session's hooks system. Each
                       item in the list must be a 2-tuple of
                       (hook name, plugin instance)

    .. attribute :: sessionClass

       The class to instantiate to create a test run configuration
       session. Default: :class:`nose2.session.Session`

    .. attribute :: loaderClass

       The class to instantiate to create a test loader. Default:
       :class:`nose2.loader.PluggableTestLoader`.

       .. warning ::

          Overriding this attribute is the only way to customize
          the test loader class. Passing a test loader to
          ``__init__`` does not work.

    .. attribute :: runnerClass

       The class to instantiate to create a test runner.  Default:
       :class:`nose2.runner.PluggableTestRunner`.

       .. warning ::

          Overriding this attribute is the only way to customize
          the test runner class. Passing a test runner to
          ``__init__`` does not work.

    .. attribute :: defaultPlugins

       List of default plugin modules to load.

    """
    sessionClass = session.Session
    loaderClass = loader.PluggableTestLoader
    runnerClass = runner.PluggableTestRunner
    defaultPlugins = ('nose2.plugins.loader.discovery',
                      'nose2.plugins.loader.testcases',
                      'nose2.plugins.loader.functions',
                      'nose2.plugins.loader.testclasses',
                      'nose2.plugins.loader.generators',
                      'nose2.plugins.loader.parameters',
                      'nose2.plugins.loader.loadtests',
                      'nose2.plugins.dundertest',
                      'nose2.plugins.coverage',
                      'nose2.plugins.result',
                      'nose2.plugins.logcapture',
                      'nose2.plugins.buffer',
                      'nose2.plugins.failfast',
                      'nose2.plugins.debugger',
                      )
    excludePlugins = ()

    # XXX override __init__ to warn that testLoader and testRunner are ignored?
    def __init__(self, **kw):
        plugins = kw.pop('plugins', [])
        exclude = kw.pop('excludePlugins', [])
        hooks = kw.pop('extraHooks', [])
        self.defaultPlugins = list(self.defaultPlugins)
        self.excludePlugins = list(self.excludePlugins)
        self.extraHooks = hooks
        self.defaultPlugins.extend(plugins)
        self.excludePlugins.extend(exclude)
        super(PluggableTestProgram, self).__init__(**kw)

    def parseArgs(self, argv):
        """Parse command line args

        Parses arguments and creates a configuration session,
        then calls createTests.

        """
        self.session = self.sessionClass()
        self.argparse = self.session.argparse  # for convenience

        # XXX force these? or can it be avoided?
        self.testLoader = self.loaderClass(self.session)
        self.session.testLoader = self.testLoader

        # Parse initial arguments like config file paths, verbosity
        self.setInitialArguments()
        # FIXME -h here makes processing stop.
        cfg_args, argv = self.argparse.parse_known_args(argv[1:])
        self.handleCfgArgs(cfg_args)

        # Parse arguments for plugins (if any) and test names
        self.argparse.add_argument('testNames', nargs='*')
        # add help arg now so -h will also print plugin opts
        self.argparse.add_argument('-h', '--help', action='help',
                                   help=('Show this help message and exit'))
        args, argv = self.argparse.parse_known_args(argv)
        if argv:
            self.argparse.error("Unrecognized arguments: %s" % ' '.join(argv))
        self.handleArgs(args)
        self.createTests()

    def setInitialArguments(self):
        """Set pre-plugin command-line arguments.

        This set of arguments is parsed out of the command line
        before plugins are loaded.

        """
        self.argparse.add_argument(
            '-s', '--start-dir', default=None,
            help="Directory to start discovery ('.' default)")
        self.argparse.add_argument(
            '-t', '--top-level-directory', '--project-directory',
            help='Top level directory of project (defaults to start dir)')
        self.argparse.add_argument(
            '--config', '-c', nargs='?', action='append',
            default=['unittest.cfg', 'nose2.cfg'],
            help="Config files to load, if they exist. ('unittest.cfg' "
            "and 'nose2.cfg' in start directory default)")
        self.argparse.add_argument(
            '--no-user-config', action='store_const',
            dest='user_config', const=False, default=True,
            help="Do not load user config files")
        self.argparse.add_argument(
            '--no-plugins', action='store_const',
            dest='load_plugins', const=False, default=True,
            help="Do not load any plugins. Warning: nose2 does not "
            "do anything if no plugins are loaded")
        self.argparse.add_argument(
            '--plugin', action='append',
            dest='plugins', default=[],
            help="Load this plugin module.")
        self.argparse.add_argument(
            '--exclude-plugin', action='append',
            dest='exclude_plugins', default=[],
            help="Do not load this plugin module")
        self.argparse.add_argument(
            '--verbose', '-v', action='count', default=0, help="print test case names and statuses")
        self.argparse.add_argument('--quiet', action='store_const',
                                   dest='verbose', const=0)
        self.argparse.add_argument(
            '--log-level', default=logging.WARN,
            help='Set logging level for message logged to console.')

    def handleCfgArgs(self, cfg_args):
        """Handle initial arguments.

        Handle the initial, pre-plugin arguments parsed out of the
        command line.

        """
        self.session.logLevel = util.parse_log_level(cfg_args.log_level)
        logging.basicConfig(level=self.session.logLevel)
        log.debug('logging initialized %s', cfg_args.log_level)
        if cfg_args.verbose:
            self.session.verbosity += cfg_args.verbose
        self.session.startDir = cfg_args.start_dir
        if cfg_args.top_level_directory:
            self.session.topLevelDir = cfg_args.top_level_directory
        self.session.loadConfigFiles(*self.findConfigFiles(cfg_args))
        self.session.setStartDir()
        self.session.prepareSysPath()
        if cfg_args.load_plugins:
            self.defaultPlugins.extend(cfg_args.plugins)
            self.excludePlugins.extend(cfg_args.exclude_plugins)
            self.loadPlugins()
        elif cfg_args.plugins or cfg_args.exclude_plugins:
            log.warn("Both '--no-plugins' and '--plugin' or '--exclude-plugin' "
                     "specified. No plugins were loaded.")

    def findConfigFiles(self, cfg_args):
        """Find available config files"""
        filenames = cfg_args.config[:]
        proj_opts = ('unittest.cfg', 'nose2.cfg')
        for fn in proj_opts:
            if cfg_args.top_level_directory:
                fn = os.path.abspath(
                    os.path.join(cfg_args.top_level_directory, fn))
            filenames.append(fn)
        if cfg_args.user_config:
            user_opts = ('~/.unittest.cfg', '~/.nose2.cfg')
            for fn in user_opts:
                filenames.append(os.path.expanduser(fn))
        return filenames

    def handleArgs(self, args):
        """Handle further arguments.

        Handle arguments parsed out of command line after plugins have
        been loaded (and injected their argument configuration).

        """
        self.testNames = args.testNames
        self.session.hooks.handleArgs(events.CommandLineArgsEvent(args=args))

    def loadPlugins(self):
        """Load available plugins


        ``self.defaultPlugins`` and ``self.excludePlugins`` are passed
        to the session to alter the list of plugins that will be
        loaded.

        This method also registers any (hook, plugin) pairs set in
        ``self.hooks``. This is a good way to inject plugins that fall
        outside of the normal loading procedure, for example, plugins
        that need some runtime information that can't easily be
        passed to them through the configuration system.

        """
        self.session.loadPlugins(self.defaultPlugins, self.excludePlugins)
        for method_name, plugin in self.extraHooks:
            self.session.hooks.register(method_name, plugin)

    def createTests(self):
        """Create top-level test suite"""
        event = events.CreateTestsEvent(
            self.testLoader, self.testNames, self.module)
        result = self.session.hooks.createTests(event)
        if event.handled:
            self.test = result
        else:
            log.debug("Create tests from %s/%s", self.testNames, self.module)
            self.test = self.testLoader.loadTestsFromNames(
                self.testNames, self.module)

    def runTests(self):
        """Run tests"""
        # fire plugin hook
        runner = self._makeRunner()
        self.result = runner.run(self.test)
        if self.exit:
            sys.exit(not self.result.wasSuccessful())

    def _makeRunner(self):
        runner = self.runnerClass(self.session)
        event = events.RunnerCreatedEvent(runner)
        self.session.hooks.runnerCreated(event)
        self.session.testRunner = event.runner
        return event.runner


main = PluggableTestProgram


def discover(*args, **kwargs):
    """Main entry point for test discovery.

    Running discover calls :class:`nose2.main.PluggableTestProgram`,
    passing through all arguments and keyword arguments **except module**:
    ``module`` is discarded, to force test discovery.

    """
    kwargs['module'] = None
    return main(*args, **kwargs)

########NEW FILE########
__FILENAME__ = attrib
import logging
from unittest import TestSuite

from nose2.events import Plugin

log = logging.getLogger(__name__)
undefined = object()


class AttributeSelector(Plugin):

    """Filter tests by attribute"""

    def __init__(self):
        self.attribs = []
        self.eval_attribs = []
        self.addArgument(
            self.attribs, "A", "attribute",
            "Select tests with matching attribute")
        self.addArgument(
            self.eval_attribs, "E", "eval-attribute",
            "Select tests for whose attributes the "
            "given Python expression evalures to True")

    def handleArgs(self, args):
        """Register if any attribs defined"""
        if self.attribs or self.eval_attribs:
            self.register()

    def moduleLoadedSuite(self, event):
        """Filter event.suite by specified attributes"""
        log.debug('Attribute selector attribs %s/%s',
                  self.attribs, self.eval_attribs)
        attribs = []
        for attr in self.eval_attribs:
            def eval_in_context(expr, obj):
                try:
                    return eval(expr, None, ContextHelper(obj))
                except Exception as e:
                    log.warning(
                        "%s raised exception %s with test %s", expr, e, obj)
                    return False
            attribs.append([(attr, eval_in_context)])
        for attr in self.attribs:
            # all attributes within an attribute group must match
            attr_group = []
            for attrib in attr.strip().split(","):
                # don't die on trailing comma
                if not attrib:
                    continue
                items = attrib.split("=", 1)
                if len(items) > 1:
                    # "name=value"
                    # -> 'str(obj.name) == value' must be True
                    key, value = items
                else:
                    key = items[0]
                    if key[0] == "!":
                        # "!name"
                        # 'bool(obj.name)' must be False
                        key = key[1:]
                        value = False
                    else:
                        # "name"
                        # -> 'bool(obj.name)' must be True
                        value = True
                attr_group.append((key, value))
            attribs.append(attr_group)
        if not attribs:
            return

        event.suite = self.filterSuite(event.suite, attribs)

    def filterSuite(self, suite, attribs):
        # FIXME probably need to copy or something to allow suites w/custom attrs to work or iter and remove instead of
        # recreating
        new_suite = suite.__class__()

        for test in suite:
            if isinstance(test, TestSuite):
                new_suite.addTest(self.filterSuite(test, attribs))
            elif self.validateAttrib(test, attribs):
                new_suite.addTest(test)
        return new_suite

    def validateAttrib(self, test, attribs):
        any_ = False
        for group in attribs:
            match = True
            for key, value in group:
                neg = False
                if key.startswith('!'):
                    neg, key = True, key[1:]
                obj_value = _get_attr(test, key)
                if callable(value):
                    if not value(key, test):
                        match = False
                        break
                elif value is True:
                    # value must exist and be True
                    if not bool(obj_value):
                        match = False
                        break
                elif value is False:
                    # value must not exist or be False
                    if bool(obj_value):
                        match = False
                        break
                elif type(obj_value) in (list, tuple):
                    # value must be found in the list attribute
                    found = str(value).lower() in [str(x).lower()
                                                   for x in obj_value]
                    if found and neg:
                        match = False
                        break
                    elif not found and not neg:
                        match = False
                        break
                else:
                    # value must match, convert to string and compare
                    if (value != obj_value
                        and str(value).lower() != str(obj_value).lower()):
                        match = False
                        break
            any_ = any_ or match
        return any_


# helpers

def _get_attr(test, key):
    # FIXME for vals that are lists (or just mutable?), combine all levels
    val = getattr(test, key, undefined)
    if val is not undefined:
        return val
    if hasattr(test, '_testFunc'):
        val = getattr(test._testFunc, key, undefined)
        if val is not undefined:
            return val
    elif hasattr(test, '_testMethodName'):
        meth = getattr(test, test._testMethodName, undefined)
        if meth is not undefined:
            val = getattr(meth, key, undefined)
            if val is not undefined:
                return val


class ContextHelper:

    def __init__(self, obj):
        self.obj = obj

    def __getitem__(self, name):
        return _get_attr(self.obj, name)

########NEW FILE########
__FILENAME__ = buffer
"""
Buffer stdout and/or stderr during test execution, appending any
output to the error reports of failed tests.

This allows you to use print for debugging in tests without making
your test runs noisy.

This plugin implements :func:`startTest`, :func:`stopTest`,
:func:`setTestOutcome`, :func:`outcomeDetail`, :func:`beforeInteraction`
and :func:`afterInteraction` to manage capturing sys.stdout and/or
sys.stderr into buffers, attaching the buffered output to test error
report detail, and getting out of the way when other plugins want to
talk to the user.

"""

import sys

from six import StringIO

from nose2 import events
from nose2.util import ln


__unittest = True


class _Buffer(object):

    def __init__(self, stream):
        self._stream = stream
        self._buffer = StringIO()

    def fileno(self):
        return self._stream.fileno()

    def __getattr__(self, attr):
        # this happens on unpickling
        if attr == '_buffer':
            raise AttributeError("No _buffer yet")
        return getattr(self._buffer, attr)

    def __le__(self, obj):
        return self._buffer.getvalue() == obj

    def __eq__(self, obj):
        return self._buffer.getvalue() == obj

    def __str__(self):
        return self._buffer.getvalue()

    def __repr__(self):
        return repr(self._buffer.getvalue())


class OutputBufferPlugin(events.Plugin):

    """Buffer output during test execution"""
    commandLineSwitch = ('B', 'output-buffer', 'Enable output buffer')
    configSection = 'output-buffer'

    def __init__(self):
        self.captureStdout = self.config.as_bool('stdout', default=True)
        self.captureStderr = self.config.as_bool('stderr', default=False)
        self.bufStdout = self.bufStderr = None
        self.realStdout = sys.__stdout__
        self.realStderr = sys.__stderr__
        self._disable = False

    def registerInSubprocess(self, event):
        event.pluginClasses.append(self.__class__)
        # turn off in this process: the subproc will run the tests
        self._disable = True

    def startSubprocess(self, event):
        self.realStdout = sys.__stdout__
        self.realStderr = sys.__stderr__

    def startTest(self, event):
        """Start buffering selected stream(s)"""
        self._buffer()

    def stopTest(self, event):
        """Stop buffering"""
        self._restore()

    def setTestOutcome(self, event):
        """Attach buffer(s) to event.metadata"""
        if self._disable:
            return
        if self.captureStdout and 'stdout' not in event.metadata:
            event.metadata['stdout'] = self.bufStdout
        if self.captureStderr and 'stderr' not in event.metadata:
            event.metadata['stderr'] = self.bufStderr

    def outcomeDetail(self, event):
        """Add buffered output to event.extraDetail"""
        for stream in ('stdout', 'stderr'):
            if stream in event.outcomeEvent.metadata:
                buf = event.outcomeEvent.metadata[stream].getvalue()
                if not buf:
                    continue
                event.extraDetail.append(
                    ln('>> begin captured %s <<' % stream))
                event.extraDetail.append(buf)
                event.extraDetail.append(ln('>> end captured %s <<' % stream))

    def beforeInteraction(self, event):
        """Stop buffering so users can see stdout"""
        self._restore()

    def afterInteraction(self, event):
        """Start buffering again (does not clear buffers)"""
        self._buffer(fresh=False)

    def stopSubprocess(self, event):
        self._restore()

    def _restore(self):
        if self._disable:
            return
        if self.captureStdout:
            sys.stdout = self.realStdout
        if self.captureStderr:
            sys.stderr = self.realStderr

    def _buffer(self, fresh=True):
        if self._disable:
            return
        if self.captureStdout:
            if fresh or self.bufStdout is None:
                self.bufStdout = _Buffer(sys.stdout)
            sys.stdout = self.bufStdout
        if self.captureStderr:
            if fresh or self.bufStderr is None:
                self.bufStderr = _Buffer(sys.stderr)
            sys.stderr = self.bufStderr

########NEW FILE########
__FILENAME__ = collect
"""
This plugin implements :func:`startTestRun`, setting a test executor
(``event.executeTests``) that just collects tests without executing
them. To do so it calls result.startTest, result.addSuccess and
result.stopTest for ech test, without calling the test itself.
"""
from nose2.events import Plugin
from nose2.compat import unittest


__unittest = True


class CollectOnly(Plugin):

    """Collect but don't run tests"""

    configSection = 'collect-only'
    commandLineSwitch = (None, 'collect-only',
                         'Collect and output test names, do not run any tests')
    _mpmode = False

    def registerInSubprocess(self, event):
        event.pluginClasses.append(self.__class__)
        self._mpmode = True

    def startTestRun(self, event):
        """Replace event.executeTests"""
        if self._mpmode:
            return
        event.executeTests = self.collectTests

    def startSubprocess(self, event):
        event.executeTests = self.collectTests

    def collectTests(self, suite, result):
        """Collect tests but don't run them"""
        for test in suite:
            if isinstance(test, unittest.TestSuite):
                self.collectTests(test, result)
                continue
            result.startTest(test)
            result.addSuccess(test)
            result.stopTest(test)

########NEW FILE########
__FILENAME__ = coverage
"""
Use this plugin to activate coverage report.

To install this plugin, you need to activate ``coverage-plugin``
with extra requirements :

::

    $ pip install nose2[coverage-plugin]


Next, you can enable coverage reporting with :

::

    $ nose2 --with-coverage

Or with this lines in ``unittest.cfg`` :

::

    [coverage]
    always-on = True


"""
from nose2.events import Plugin


class Coverage(Plugin):
    configSection = 'coverage'
    commandLineSwitch = ('C', 'with-coverage', 'Turn on coverage reporting')

    def __init__(self):
        """Get our config and add our command line arguments."""
        self.conSource = self.config.as_list('coverage', [])
        self.conReport = self.config.as_list('coverage-report', [])
        self.conConfig = self.config.as_str('coverage-config', '').strip()

        group = self.session.pluginargs
        group.add_argument(
            '--coverage', action='append', default=[], metavar='PATH',
            dest='coverage_source',
            help='Measure coverage for filesystem path (multi-allowed)'
        )
        group.add_argument(
            '--coverage-report', action='append', default=[], metavar='TYPE',
            choices=['term', 'term-missing', 'annotate', 'html', 'xml'],
            dest='coverage_report',
            help='Generate selected reports, available types:'
                 ' term, term-missing, annotate, html, xml (multi-allowed)'
        )
        group.add_argument(
            '--coverage-config', action='store', default='', metavar='FILE',
            dest='coverage_config',
            help='Config file for coverage, default: .coveragerc'
        )

    def handleArgs(self, event):
        """Get our options in order command line, config file, hard coded."""

        self.covSource = (event.args.coverage_source or
                          self.conSource or ['.'])
        self.covReport = (event.args.coverage_report or
                          self.conReport or ['term'])
        self.covConfig = (event.args.coverage_config or
                          self.conConfig or '.coveragerc')

    def startTestRun(self, event):
        """Only called if active so start coverage."""
        self.covController = None
        try:
            import cov_core
        except:
            print('Warning: you need to install [coverage-plugin] '
                  'extra requirements to use this plugin')
            return

        self.covController = cov_core.Central(self.covSource,
                                              self.covReport,
                                              self.covConfig)
        self.covController.start()

    def afterSummaryReport(self, event):
        """Only called if active so stop coverage and produce reports."""

        if self.covController:
            self.covController.finish()
            self.covController.summary(event.stream)

########NEW FILE########
__FILENAME__ = debugger
"""
Start a :func:`pdb.post_mortem` on errors and failures.

This plugin implements :func:`testOutcome` and will drop into pdb
whenever it sees a test outcome that includes exc_info.

It fires :func:`beforeInteraction` before launching pdb and
:func:`afterInteraction` after. Other plugins may implement
:func:`beforeInteraction` to return False and set event.handled to
prevent this plugin from launching pdb.

"""
import logging
import pdb

from nose2 import events


__unittest = True
log = logging.getLogger(__name__)


class Debugger(events.Plugin):

    """Enter pdb on test error or failure

    .. attribute :: pdb

       For ease of mocking and using different pdb implementations, pdb
       is aliased as a class attribute.

    """
    configSection = 'debugger'
    commandLineSwitch = ('D', 'debugger', 'Enter pdb on test fail or error')
    # allow easy mocking and replacment of pdb
    pdb = pdb

    def __init__(self):
        self.errorsOnly = self.config.as_bool('errors-only', default=False)

    def testOutcome(self, event):
        """Drop into pdb on unexpected errors or failures"""
        if not event.exc_info or event.expected:
            # skipped tests, unexpected successes, expected failures
            return

        value, tb = event.exc_info[1:]
        test = event.test
        if self.errorsOnly and isinstance(value, test.failureException):
            return
        evt = events.UserInteractionEvent()
        result = self.session.hooks.beforeInteraction(evt)
        try:
            if not result and evt.handled:
                log.warning(
                    "Skipping pdb for %s, user interaction not allowed", event)
                return
            self.pdb.post_mortem(tb)
        finally:
            self.session.hooks.afterInteraction(evt)

########NEW FILE########
__FILENAME__ = doctests
"""
Load tests from doctests.

This plugin implements :func:`handleFile` to load doctests from text files
and python modules.

To disable loading doctests from text files, configure an empty extensions list:

.. code-block :: ini

  [doctest]
  extensions =

"""
import doctest
import os

from nose2.events import Plugin
from nose2 import util


__unittest = True


class DocTestLoader(Plugin):
    configSection = 'doctest'
    commandLineSwitch = (None, 'with-doctest',
                         'Load doctests from text files and modules')

    def __init__(self):
        self.extensions = self.config.as_list('extensions', ['.txt', '.rst'])

    def handleFile(self, event):
        """Load doctests from text files and modules"""
        path = event.path
        _root, ext = os.path.splitext(path)
        if ext in self.extensions:
            suite = doctest.DocFileTest(path, module_relative=False)
            event.extraTests.append(suite)
            return
        elif not util.valid_module_name(os.path.basename(path)):
            return

        name = util.name_from_path(path)
        try:
            module = util.module_from_name(name)
        except Exception:
            # XXX log warning here?
            return
        if hasattr(module, '__test__') and not module.__test__:
            return
        try:
            suite = doctest.DocTestSuite(module)
        except ValueError:
            # doctest, very annoyingly, raises ValueError when
            # a module has no tests.
            return
        event.extraTests.append(suite)

########NEW FILE########
__FILENAME__ = dundertest
"""
This plugin implements :func:`startTestRun`, which excludes all test objects
that define a ``__test__`` attribute with a truth value of False.
"""
from unittest import TestSuite
from nose2 import events

__unittest = True


class DunderTestFilter(events.Plugin):
    """
    Exclude all tests defining a ``__test__`` attribute with a truth value of
    False.
    """
    alwaysOn = True

    def startTestRun(self, event):
        """
        Recurse :attr:`event.suite` and remove all test suites and test cases
        that define a ``__test__`` attribute with a truth value of False.
        """
        self.removeNonTests(event.suite)

    def removeNonTests(self, suite):
        for test in list(suite):
            if not getattr(test, '__test__', True):
                suite._tests.remove(test)
            elif isinstance(test, TestSuite):
                self.removeNonTests(test)

########NEW FILE########
__FILENAME__ = failfast
"""
Stop the test run after the first error or failure.

This plugin implements :func:`testOutcome` and sets
``event.result.shouldStop`` if it sees an outcome with exc_info that
is not expected.

"""

from nose2 import events


__unittest = True


class FailFast(events.Plugin):

    """Stop the test run after error or failure"""
    commandLineSwitch = (
        'F', 'fail-fast', 'Stop the test run after the first error or failure')

    def testOutcome(self, event):
        """Stop on unexpected error or failure"""
        if event.exc_info and not event.expected:
            event.result.shouldStop = True

########NEW FILE########
__FILENAME__ = junitxml
"""
Output test reports in junit-xml format.

This plugin implements :func:`startTest`, :func:`testOutcome` and
:func:`stopTestRun` to compile and then output a test report in
junit-xml format. By default, the report is written to a file called
``nose2-junit.xml`` in the current working directory. You can
configure the output filename by setting ``path`` in a ``[junit-xml]``
section in a config file.  Unicode characters which are invalid in XML 1.0
are replaced with the U+FFFD replacement character.  In the case that your
software throws an error with an invalid byte string.  By default, the
ranges of discouraged characters are replaced as well.  This can be
changed by setting the keep_restricted configuration variable to True.

"""
# Based on unittest2/plugins/junitxml.py,
# which is itself based on the junitxml plugin from py.test
import os.path
import time
import re
import sys
from xml.etree import ElementTree as ET

import six

from nose2 import events, result, util

__unittest = True


class JUnitXmlReporter(events.Plugin):

    """Output junit-xml test report to file"""
    configSection = 'junit-xml'
    commandLineSwitch = ('X', 'junit-xml', 'Generate junit-xml output report')

    def __init__(self):
        self.path = os.path.realpath(
            self.config.as_str('path', default='nose2-junit.xml'))
        self.keep_restricted = self.config.as_bool('keep_restricted',
                                                   default=False)
        self.errors = 0
        self.failed = 0
        self.skipped = 0
        self.numtests = 0
        self.tree = ET.Element('testsuite')
        self._start = None

    def startTest(self, event):
        """Count test, record start time"""
        self.numtests += 1
        self._start = event.startTime

    def testOutcome(self, event):
        """Add test outcome to xml tree"""
        test = event.test
        testid = test.id().split('\n')[0]
        # split into module, class, method parts... somehow
        parts = testid.split('.')
        classname = '.'.join(parts[:-1])
        method = parts[-1]

        testcase = ET.SubElement(self.tree, 'testcase')
        testcase.set('time', "%.6f" % self._time())
        testcase.set('classname', classname)
        testcase.set('name', method)

        msg = ''
        if event.exc_info:
            msg = util.exc_info_to_string(event.exc_info, test)
        elif event.reason:
            msg = event.reason

        msg = string_cleanup(msg, self.keep_restricted)

        if event.outcome == result.ERROR:
            self.errors += 1
            error = ET.SubElement(testcase, 'error')
            error.set('message', 'test failure')
            error.text = msg
        elif event.outcome == result.FAIL and not event.expected:
            self.failed += 1
            failure = ET.SubElement(testcase, 'failure')
            failure.set('message', 'test failure')
            failure.text = msg
        elif event.outcome == result.PASS and not event.expected:
            self.skipped += 1
            skipped = ET.SubElement(testcase, 'skipped')
            skipped.set('message', 'test passes unexpectedly')
        elif event.outcome == result.SKIP:
            self.skipped += 1
            skipped = ET.SubElement(testcase, 'skipped')
        elif event.outcome == result.FAIL and event.expected:
            self.skipped += 1
            skipped = ET.SubElement(testcase, 'skipped')
            skipped.set('message', 'expected test failure')
            skipped.text = msg

    def stopTestRun(self, event):
        """Output xml tree to file"""
        self.tree.set('name', 'nose2-junit')
        self.tree.set('errors', str(self.errors))
        self.tree.set('failures', str(self.failed))
        self.tree.set('skipped', str(self.skipped))
        self.tree.set('tests', str(self.numtests))
        self.tree.set('time', "%.3f" % event.timeTaken)

        self._indent_tree(self.tree)
        output = ET.ElementTree(self.tree)
        output.write(self.path, encoding="utf-8")

    def _indent_tree(self, elem, level=0):
        """In-place pretty formatting of the ElementTree structure."""
        i = "\n" + level * "  "
        if len(elem):
            if not elem.text or not elem.text.strip():
                elem.text = i + "  "
            if not elem.tail or not elem.tail.strip():
                elem.tail = i
            for elem in elem:
                self._indent_tree(elem, level + 1)
            if not elem.tail or not elem.tail.strip():
                elem.tail = i
        else:
            if level and (not elem.tail or not elem.tail.strip()):
                elem.tail = i

    def _time(self):
        try:
            return time.time() - self._start
        except Exception:
            pass
        finally:
            self._start = None
        return 0

#
# xml utility functions
#

# six doesn't include a unichr function


def _unichr(string):
    if six.PY3:
        return chr(string)
    else:
        return unichr(string)

# etree outputs XML 1.0 so the 1.1 Restricted characters are invalid.
# and there are no characters that can be given as entities aside
# form & < > ' " which ever have to be escaped (etree handles these fine)
ILLEGAL_RANGES = [(0x00, 0x08), (0x0B, 0x0C), (0x0E, 0x1F),
                  (0xD800, 0xDFFF), (0xFFFE, 0xFFFF)]
# 0xD800 thru 0xDFFF are technically invalid in UTF-8 but PY2 will encode
# bytes into these but PY3 will do a replacement

# Other non-characters which are not strictly forbidden but
# discouraged.
RESTRICTED_RANGES = [(0x7F, 0x84), (0x86, 0x9F), (0xFDD0, 0xFDDF)]
# check for a wide build
if sys.maxunicode > 0xFFFF:
    RESTRICTED_RANGES += [(0x1FFFE, 0x1FFFF), (0x2FFFE, 0x2FFFF),
                          (0x3FFFE, 0x3FFFF), (0x4FFFE, 0x4FFFF),
                          (0x5FFFE, 0x5FFFF), (0x6FFFE, 0x6FFFF),
                          (0x7FFFE, 0x7FFFF), (0x8FFFE, 0x8FFFF),
                          (0x9FFFE, 0x9FFFF), (0xAFFFE, 0xAFFFF),
                          (0xBFFFE, 0xBFFFF), (0xCFFFE, 0xCFFFF),
                          (0xDFFFE, 0xDFFFF), (0xEFFFE, 0xEFFFF),
                          (0xFFFFE, 0xFFFFF), (0x10FFFE, 0x10FFFF)]

ILLEGAL_REGEX_STR = \
    six.u('[') + \
    six.u('').join(["%s-%s" % (_unichr(l), _unichr(h))
                   for (l, h) in ILLEGAL_RANGES]) + \
    six.u(']')
RESTRICTED_REGEX_STR = \
    six.u('[') + \
    six.u('').join(["%s-%s" % (_unichr(l), _unichr(h))
                   for (l, h) in RESTRICTED_RANGES]) + \
    six.u(']')

_ILLEGAL_REGEX = re.compile(ILLEGAL_REGEX_STR, re.U)
_RESTRICTED_REGEX = re.compile(RESTRICTED_REGEX_STR, re.U)


def string_cleanup(string, keep_restricted=False):

    if not issubclass(type(string), six.text_type):
        string = six.text_type(string, encoding='utf-8', errors='replace')

    string = _ILLEGAL_REGEX.sub(six.u('\uFFFD'), string)
    if not keep_restricted:
        string = _RESTRICTED_REGEX.sub(six.u('\uFFFD'), string)

    return string

########NEW FILE########
__FILENAME__ = layers
import logging
import re

import six

from nose2 import events, util
from nose2.suite import LayerSuite
from nose2.compat import unittest, OrderedDict

BRIGHT = r'\033[1m'
RESET = r'\033[0m'

__unittest = True

log = logging.getLogger(__name__)


class Layers(events.Plugin):
    alwaysOn = True

    def startTestRun(self, event):
        event.suite = self._makeLayerSuite(event)

    def _makeLayerSuite(self, event):
        return self._sortByLayers(
            event.suite, self.session.testLoader.suiteClass)

    def _sortByLayers(self, suite, suiteClass):
        top = suiteClass()
        # first find all of the layers mentioned
        layers = OrderedDict()
        for test in self._flatten(suite):
            # split tests up into buckets by layer
            layer = getattr(test, 'layer', None)
            if layer:
                layers.setdefault(layer, LayerSuite(layer=layer)).addTest(test)
            else:
                top.addTest(test)

        # then organize layers into a tree
        remaining = list(layers.keys())
        seen = set()
        tree = {}
        while remaining:
            ly = remaining.pop()
            if ly in seen:
                continue
            seen.add(ly)
            # superclasses of this layer
            if ly is None:
                deps = []
            else:
                deps = [cls for cls in util.bases_and_mixins(ly)
                        if cls is not object]
                deps.reverse()
            if not deps:
                # layer is top-level
                self._addToTree(tree, ly, None)
            else:
                outer = ly
                while deps:
                    inner, outer = outer, deps.pop()
                    self._addToTree(tree, inner, outer)
                    if outer not in layers:
                        remaining.append(outer)
                        layers[outer] = LayerSuite(layer=outer)

        # finally build the top-level suite
        self._treeToSuite(tree, None, top, layers)
        # printtree(top)
        return top

    def _addToTree(self, tree, inner, outer):
        found = False
        for k, v in tree.items():
            if inner in v:
                found = True
                if outer is not None:
                    v.remove(inner)
                break
        if outer is not None or not found:
            tree.setdefault(outer, []).append(inner)

    def _treeToSuite(self, tree, key, suite, layers):
        mysuite = layers.get(key, None)
        if mysuite:
            suite.addTest(mysuite)
            suite = mysuite
        sublayers = tree.get(key, [])
        # ensure that layers with a set order are in order
        sublayers.sort(key=self._sortKey)
        log.debug('sorted sublayers of %s (%s): %s', mysuite,
                  getattr(mysuite, 'layer', 'no layer'), sublayers)
        for layer in sublayers:
            self._treeToSuite(tree, layer, suite, layers)

    def _flatten(self, suite):
        out = []
        for test in suite:
            try:
                out.extend(self._flatten(test))
            except TypeError:
                out.append(test)
        return out

    def _sortKey(self, layer):
        pos = getattr(layer, 'position', None)
        # ... lame
        if pos is not None:
            key = six.u("%04d") % pos
        else:
            key = layer.__name__
        return key


class LayerReporter(events.Plugin):
    commandLineSwitch = (
        None, 'layer-reporter', 'Add layer information to test reports')
    configSection = 'layer-reporter'

    def __init__(self):
        self.indent = self.config.as_str('indent', '  ')
        self.colors = self.config.as_bool('colors', False)
        self.highlight_words = self.config.as_list('highlight-words',
                                                   ['A', 'having', 'should'])
        self.highlight_re = re.compile(
            r'\b(%s)\b' % '|'.join(self.highlight_words))
        self.layersReported = set()

    def reportStartTest(self, event):
        if self.session.verbosity < 2:
            return
        test = event.testEvent.test
        layer = getattr(test, 'layer', None)
        if not layer:
            return
        for ix, lys in enumerate(util.ancestry(layer)):
            for layer in lys:
                if layer not in self.layersReported:
                    desc = self.describeLayer(layer)
                    event.stream.writeln('%s%s' % (self.indent * ix, desc))
                    self.layersReported.add(layer)
        event.stream.write(self.indent * (ix + 1))

    def describeLayer(self, layer):
        return self.format(getattr(layer, 'description', layer.__name__))

    def format(self, st):
        if self.colors:
            return self.highlight_re.sub(r'%s\1%s' % (BRIGHT, RESET), st)
        return st

    def describeTest(self, event):
        if hasattr(event.test, 'methodDescription'):
            event.description = self.format(event.test.methodDescription())
        if event.errorList and hasattr(event.test, 'layer'):
            # walk back layers to build full description
            self.describeLayers(event)

    def describeLayers(self, event):
        desc = [event.description]
        base = event.test.layer
        for layer in (base.__mro__ + getattr(base, 'mixins', ())):
            if layer is object:
                continue
            desc.append(self.describeLayer(layer))
        desc.reverse()
        event.description = ' '.join(desc)


# for debugging
def printtree(suite, indent=''):
    six.print_('%s%s ->' % (indent, getattr(suite, 'layer', 'no layer')))
    for test in suite:
        if isinstance(test, unittest.BaseTestSuite):
            printtree(test, indent + '  ')
        else:
            six.print_('%s %s' % (indent, test))
    six.print_('%s<- %s' % (indent, getattr(suite, 'layer', 'no layer')))

########NEW FILE########
__FILENAME__ = discovery
"""
Discovery-based test loader.

This plugin implements nose2's automatic test module discovery. It
looks for test modules in packages and directories whose names start
with 'test', then fires the :func:`loadTestsFromModule` hook for each
one to allow other plugins to load the actual tests.

It also fires :func:`handleFile` for every file that it sees, and
:func:`matchPath` for every python module, to allow other plugins to
load tests from other kinds of files and to influence which modules
are examined for tests.

"""


# Adapted from unittest2/loader.py from the unittest2 plugins branch.
# This module contains some code copied from unittest2/loader.py and other
# code developed in reference to that module and others within unittest2.
# unittest2 is Copyright (c) 2001-2010 Python Software Foundation; All
# Rights Reserved. See: http://docs.python.org/license.html

from fnmatch import fnmatch
import logging
import os
import sys

from nose2 import events, util

__unittest = True
log = logging.getLogger(__name__)


class DirectoryHandler(object):
    def __init__(self, session):
        self.session = session
        self.event_handled = False

    def handle_dir(self, event, full_path, top_level):
        dirname = os.path.basename(full_path)
        pattern = self.session.testFilePattern

        evt = events.HandleFileEvent(
            event.loader, dirname, full_path, pattern, top_level)
        result = self.session.hooks.handleDir(evt)
        if evt.extraTests:
            for test in evt.extraTests:
                yield test
        if evt.handled:
            if result:
                yield result
            self.event_handled = True
            return
        
        evt = events.MatchPathEvent(dirname, full_path, pattern)
        result = self.session.hooks.matchDirPath(evt)
        if evt.handled and not result:
            self.event_handled = True


class Discoverer(object):
    
    def loadTestsFromName(self, event):
        """Load tests from module named by event.name"""
        # turn name into path or module name
        # fire appropriate hooks (handle file or load from module)
        if event.module:
            return
        name = event.name
        module = None
        _, top_level_dir = self._getStartDirs()
        try:
            # try name as a dotted module name first
            __import__(name)
            module = sys.modules[name]
        except ImportError:
            # if that fails, try it as a file or directory
            event.extraTests.extend(
                self._find_tests(event, name, top_level_dir))
        else:
            event.extraTests.extend(
                self._find_tests_in_module(event, module, top_level_dir))

    def loadTestsFromNames(self, event):
        """Discover tests if no test names specified"""
        log.debug("Received event %s", event)
        if event.names or event.module:
            return
        event.handled = True  # I will handle discovery
        return self._discover(event)

    def _checkIfPathIsOK(self, start_dir):
        if not os.path.isdir(os.path.abspath(start_dir)):
            raise OSError("%s is not a directory" % os.path.abspath(start_dir))

    def _getStartDirs(self):
        start_dir = self.session.startDir
        top_level_dir = self.session.topLevelDir
        if start_dir is None:
            start_dir = '.'
        if top_level_dir is None:
            top_level_dir = start_dir

        self._checkIfPathIsOK(start_dir)

        is_not_importable = False
        start_dir = os.path.abspath(start_dir)
        top_level_dir = os.path.abspath(top_level_dir)
        if start_dir != top_level_dir:
            is_not_importable = not os.path.isfile(
                os.path.join(start_dir, '__init__.py'))
        if is_not_importable:
            raise ImportError(
                'Start directory is not importable: %r' % start_dir)
        # this is redundant in some cases, but that's ok
        self.session.prepareSysPath()
        return start_dir, top_level_dir

    def _discover(self, event):
        loader = event.loader
        try:
            start_dir, top_level_dir = self._getStartDirs()
        except (OSError, ImportError):
            _, ev, _ = sys.exc_info()
            return loader.suiteClass(
                loader.failedLoadTests(self.session.startDir, ev))
        log.debug("_discover in %s (%s)", start_dir, top_level_dir)
        tests = list(self._find_tests(event, start_dir, top_level_dir))
        return loader.suiteClass(tests)

    def _find_tests(self, event, start, top_level):
        """Used by discovery. Yields test suites it loads."""
        log.debug('_find_tests(%r, %r)', start, top_level)
        if start == top_level:
            full_path = start
        else:
            full_path = os.path.join(top_level, start)
        if os.path.isdir(start):
            for test in self._find_tests_in_dir(
                event, full_path, top_level):
                yield test
        elif os.path.isfile(start):
            for test in self._find_tests_in_file(
                event, start, full_path, top_level):
                yield test
        
    def _find_tests_in_dir(self, event, full_path, top_level):
        if not os.path.isdir(full_path):
            return
        log.debug("find in dir %s (%s)", full_path, top_level)
        dir_handler = DirectoryHandler(self.session)
        for test in dir_handler.handle_dir(event, full_path, top_level):
            yield test
        if dir_handler.event_handled:
            return
        for path in os.listdir(full_path):
            entry_path = os.path.join(full_path, path)
            if os.path.isfile(entry_path):
                for test in self._find_tests_in_file(
                    event, path, entry_path, top_level):
                    yield test
            elif os.path.isdir(entry_path):
                if ('test' in path.lower()
                    or util.ispackage(entry_path)
                    or path in self.session.libDirs):
                    for test in self._find_tests(event, entry_path, top_level):
                        yield test

    def _find_tests_in_file(self, event, filename, full_path, top_level, module_name=None):
        log.debug("find in file %s (%s)", full_path, top_level)
        pattern = self.session.testFilePattern
        loader = event.loader
        evt = events.HandleFileEvent(
            loader, filename, full_path, pattern, top_level)
        result = self.session.hooks.handleFile(evt)
        if evt.extraTests:
            yield loader.suiteClass(evt.extraTests)

        if evt.handled:
            if result:
                yield result
            return

        if not util.valid_module_name(filename):
            # valid Python identifiers only
            return

        evt = events.MatchPathEvent(filename, full_path, pattern)
        result = self.session.hooks.matchPath(evt)
        if evt.handled:
            if not result:
                return
        elif not self._match_path(filename, full_path, pattern):
            return

        if module_name is None:
            module_name = util.name_from_path(full_path)
        
        try:
            module = util.module_from_name(module_name)
        except:
            yield loader.failedImport(module_name)
        else:
            mod_file = os.path.abspath(
                getattr(module, '__file__', full_path))
            realpath = os.path.splitext(mod_file)[0]
            fullpath_noext = os.path.splitext(full_path)[0]
            if realpath.lower() != fullpath_noext.lower():
                module_dir = os.path.dirname(realpath)
                mod_name = os.path.splitext(os.path.basename(full_path))[0]
                expected_dir = os.path.dirname(full_path)
                msg = ("%r module incorrectly imported from %r. "
                       "Expected %r. Is this module globally installed?"
                       )
                raise ImportError(
                    msg % (mod_name, module_dir, expected_dir))
            yield loader.loadTestsFromModule(module)

    def _find_tests_in_module(self, event, module, top_level_dir):
        # only called from loadTestsFromName
        yield event.loader.loadTestsFromModule(module)
        # may be a package; recurse into __path__ if so
        pkgpath = getattr(module, '__path__', None)
        if pkgpath:
            for entry in pkgpath:
                full_path = os.path.abspath(os.path.join(top_level_dir, entry))
                for test in self._find_tests_in_dir(
                    event, full_path, top_level_dir):
                    yield test

    def _match_path(self, path, full_path, pattern):
        # override this method to use alternative matching strategy
        return fnmatch(path, pattern)


class DiscoveryLoader(events.Plugin, Discoverer):
    """Loader plugin that can discover tests"""
    alwaysOn = True
    configSection = 'discovery'

    def registerInSubprocess(self, event):
        event.pluginClasses.append(self.__class__)

    def loadTestsFromName(self, event):
        """Load tests from module named by event.name"""
        return Discoverer.loadTestsFromName(self, event)

    def loadTestsFromNames(self, event):
        """Discover tests if no test names specified"""
        return Discoverer.loadTestsFromNames(self, event)

########NEW FILE########
__FILENAME__ = eggdiscovery
"""
Egg-based discovery test loader.

This plugin implements nose2's automatic test module discovery inside Egg Files.
It looks for test modules in packages whose names start
with 'test', then fires the :func:`loadTestsFromModule` hook for each
one to allow other plugins to load the actual tests.

It also fires :func:`handleFile` for every file that it sees, and
:func:`matchPath` for every python module, to allow other plugins to
load tests from other kinds of files and to influence which modules
are examined for tests.

"""
import logging
import os

from nose2 import events

from nose2.plugins.loader import discovery

__unittest = True
log = logging.getLogger(__name__)

try:
    import pkg_resources
except ImportError:
    pkg_resources = None


class EggDiscoveryLoader(events.Plugin, discovery.Discoverer):

    """Loader plugin that can discover tests"""
    alwaysOn = True
    configSection = 'discovery'

    def registerInSubprocess(self, event):
        event.pluginClasses.append(self.__class__)

    def loadTestsFromName(self, event):
        """Load tests from module named by event.name"""
        return discovery.Discoverer.loadTestsFromName(self, event)

    def loadTestsFromNames(self, event):
        """Discover tests if no test names specified"""
        return discovery.Discoverer.loadTestsFromNames(self, event)

    def _checkIfPathIsOK(self, start_dir):
        if not os.path.exists(os.path.abspath(start_dir)):
            raise OSError("%s does not exist" % os.path.abspath(start_dir))

    def _find_tests_in_egg_dir(self, event, rel_path, dist):
        log.debug("find in egg dir %s %s (%s)", dist.location, rel_path, dist.project_name)
        full_path = os.path.join(dist.location, rel_path)
        dir_handler = discovery.DirectoryHandler(self.session)
        for test in dir_handler.handle_dir(event, full_path, dist.location):
            yield test
        if dir_handler.event_handled:
            return
        for path in dist.resource_listdir(rel_path):
            entry_path = os.path.join(rel_path, path)
            if dist.resource_isdir(entry_path):
                for test in self._find_tests_in_egg_dir(event, entry_path, dist):
                    yield test
            else:
                modname = os.path.splitext(entry_path)[0].replace(os.sep, '.')
                for test in self._find_tests_in_file(
                    event, path, os.path.join(dist.location, entry_path), dist.location, modname):
                    yield test

    def _find_tests_in_dir(self, event, full_path, top_level):
        if os.path.exists(full_path):
            for test in discovery.Discoverer._find_tests_in_dir(self,
                event, full_path, top_level):
                yield test
        elif pkg_resources and full_path.find('.egg') != -1:
            egg_path = full_path.split('.egg')[0] + '.egg'
            for dist in pkg_resources.find_distributions(egg_path):
                for modname in dist._get_metadata('top_level.txt'):
                    for test in self._find_tests_in_egg_dir(
                        event, modname, dist):
                        yield test

########NEW FILE########
__FILENAME__ = functions
"""
Load tests from test functions in modules.

This plugin responds to :func:`loadTestsFromModule` by adding test
cases for all test functions in the module to ``event.extraTests``. It
uses ``session.testMethodPrefix`` to find test functions.

Functions that are generators, have param lists, or take arguments
are not collected.

This plugin also implements :func:`loadTestsFromName` to enable loading
tests from dotted function names passed on the command line.

Fixtures
--------

Test functions can specify setup and teardown fixtures as attributes on the
function, for example:

.. code :: python

   x = 0

   def test():
       assert x

   def setup():
       global x
       x = 1

   def teardown():
       global x
       x = 1

   test.setup = setup
   test.teardown = teardown

The setup attribute may be named ``setup``, ``setUp`` or ``setUpFunc``. The
teardown attribute may be named ``teardown``, 'tearDown`` or ``tearDownFunc``.

Other attributes
----------------

The other significant attribute that may be set on a test function is
``paramList``. When ``paramList`` is set, the function will be collected
by the :doc:`parameterized test loader <parameters>`. The easiest way
to set ``paramList`` is with the :func:`nose2.tools.params` decorator.

"""
# This module contains some code copied from unittest2/ and other code
# developed in reference to unittest2.
# unittest2 is Copyright (c) 2001-2010 Python Software Foundation; All
# Rights Reserved. See: http://docs.python.org/license.html


import inspect
import types

from nose2 import util
from nose2.events import Plugin
from nose2.compat import unittest


__unittest = True


class Functions(Plugin):

    """Loader plugin that loads test functions"""
    alwaysOn = True
    configSection = 'functions'

    def registerInSubprocess(self, event):
        event.pluginClasses.append(self.__class__)

    def loadTestsFromName(self, event):
        """Load test if event.name is the name of a test function"""
        name = event.name
        module = event.module
        try:
            result = util.test_from_name(name, module)
        except (AttributeError, ImportError) as e:
            event.handled = True
            return event.loader.failedLoadTests(name, e)
        if result is None:
            return

        parent, obj, name, index = result
        if (isinstance(obj, types.FunctionType) and not
            util.isgenerator(obj) and not
            hasattr(obj, 'paramList') and not
            inspect.getargspec(obj).args):
            suite = event.loader.suiteClass()
            suite.addTests(self._createTests(obj))
            event.handled = True
            return suite

    def loadTestsFromModule(self, event):
        """Load test functions from event.module"""
        module = event.module

        def is_test(obj):
            if not obj.__name__.startswith(self.session.testMethodPrefix):
                return False
            if inspect.getargspec(obj).args:
                return False
            return True

        tests = []
        for name in dir(module):
            obj = getattr(module, name)
            if isinstance(obj, types.FunctionType) and is_test(obj):
                tests.extend(self._createTests(obj))
        event.extraTests.extend(tests)

    def _createTests(self, obj):
        if not hasattr(obj, 'setUp'):
            if hasattr(obj, 'setup'):
                obj.setUp = obj.setup
            elif hasattr(obj, 'setUpFunc'):
                obj.setUp = obj.setUpFunc
        if not hasattr(obj, 'tearDown'):
            if hasattr(obj, 'teardown'):
                obj.tearDown = obj.teardown
            elif hasattr(obj, 'tearDownFunc'):
                obj.tearDown = obj.tearDownFunc

        tests = []
        args = {}
        setUp = getattr(obj, 'setUp', None)
        tearDown = getattr(obj, 'tearDown', None)
        if setUp is not None:
            args['setUp'] = setUp
        if tearDown is not None:
            args['tearDown'] = tearDown

        paramList = getattr(obj, 'paramList', None)
        isGenerator = util.isgenerator(obj)
        if paramList is not None or isGenerator:
            return tests
        else:
            case = util.transplant_class(
                unittest.FunctionTestCase, obj.__module__)(obj, **args)
            tests.append(case)
        return tests

########NEW FILE########
__FILENAME__ = generators
"""
Load tests from generators.

This plugin implements :func:`loadTestFromTestCase`,
:func:`loadTestsFromName` and :func:`loadTestFromModule` to enable
loading tests from generators.

Generators may be functions or methods in test cases. In either case,
they must yield a callable and arguments for that callable once for
each test they generate. The callable and arguments may all be in one
tuple, or the arguments may be grouped into a separate tuple::

  def test_gen():
      yield check, 1, 2
      yield check, (1, 2)

To address a particular generated test via a command-line test name,
append a colon (':') followed by the index, *starting from 1*, of the
generated case you want to execute.

"""
# This module contains some code copied from unittest2 and other code
# developed in reference to unittest2.
# unittest2 is Copyright (c) 2001-2010 Python Software Foundation; All
# Rights Reserved. See: http://docs.python.org/license.html

import functools
import logging
import sys
import types
import unittest

from nose2 import exceptions, util
from nose2.events import Plugin
from nose2.compat import unittest as ut2


log = logging.getLogger(__name__)
__unittest = True


class Generators(Plugin):

    """Loader plugin that loads generator tests"""
    alwaysOn = True
    configSection = 'generators'

    def registerInSubprocess(self, event):
        event.pluginClasses.append(self.__class__)

    def unpack(self, generator):
        for index, func_args in enumerate(generator):
            try:
                func, args = func_args
                if not isinstance(args, tuple):
                    args = (args,)
                yield index, (func, args)
            except ValueError:
                func, args = func_args[0], func_args[1:]
                yield index, (func, args)

    def loadTestsFromTestCase(self, event):
        """Load generator tests from test case"""
        log.debug('loadTestsFromTestCase %s', event.testCase)
        testCaseClass = event.testCase
        for name in dir(testCaseClass):
            method = getattr(testCaseClass, name)
            if (name.startswith(self.session.testMethodPrefix) and
                hasattr(getattr(testCaseClass, name), '__call__') and
                util.isgenerator(method)):
                instance = testCaseClass(name)
                event.extraTests.extend(
                    self._testsFromGenerator(
                        event, name, method(instance), testCaseClass)
                )

    def loadTestsFromTestClass(self, event):
        testCaseClass = event.testCase
        for name in dir(testCaseClass):
            method = getattr(testCaseClass, name)
            if (name.startswith(self.session.testMethodPrefix) and
                hasattr(getattr(testCaseClass, name), '__call__') and
                util.isgenerator(method)):
                instance = testCaseClass()
                event.extraTests.extend(
                    self._testsFromGeneratorMethod(
                        event, name, method, instance)
                )

    def getTestCaseNames(self, event):
        """Get generator test case names from test case class"""
        log.debug('getTestCaseNames %s', event.testCase)
        names = filter(event.isTestMethod, dir(event.testCase))
        klass = event.testCase
        for name in names:
            method = getattr(klass, name)
            if util.isgenerator(method):
                event.excludedNames.append(name)

    def getTestMethodNames(self, event):
        return self.getTestCaseNames(event)

    def loadTestsFromName(self, event):
        """Load tests from generator named on command line"""
        original_name = name = event.name
        module = event.module
        try:
            result = util.test_from_name(name, module)
        except (AttributeError, ImportError) as e:
            event.handled = True
            return event.loader.failedLoadTests(name, e)
        if result is None:
            # we can't find it - let the default case handle it
            return

        parent, obj, name, index = result
        if not util.isgenerator(obj):
            return

        if (index is None and not
            isinstance(parent, type) and not
            isinstance(obj, types.FunctionType)):
            log.debug("Don't know how to load generator tests from %s", obj)
            return

        if (parent and
            isinstance(parent, type) and
            issubclass(parent, unittest.TestCase)):
            # generator method in test case
            instance = parent(obj.__name__)
            tests = list(
                self._testsFromGenerator(
                    event, obj.__name__, obj(instance), parent)
            )
        elif (parent and
              isinstance(parent, type)):
              # generator method in test class
            method = obj
            instance = parent()
            tests = list(
                self._testsFromGeneratorMethod(event, name, method, instance)
            )
        else:
            # generator func
            tests = list(self._testsFromGeneratorFunc(event, obj))

        if index is not None:
            try:
                tests = [tests[index - 1]]
            except IndexError:
                raise exceptions.TestNotFoundError(original_name)

        suite = event.loader.suiteClass()
        suite.addTests(tests)
        event.handled = True
        return suite

    def loadTestsFromModule(self, event):
        """Load tests from generator functions in a module"""
        module = event.module

        def is_test(obj):
            return (obj.__name__.startswith(self.session.testMethodPrefix)
                    and util.isgenerator(obj))
        tests = []
        for name in dir(module):
            obj = getattr(module, name)
            if isinstance(obj, types.FunctionType) and is_test(obj):
                tests.extend(self._testsFromGeneratorFunc(event, obj))
        event.extraTests.extend(tests)

    def _testsFromGenerator(self, event, name, generator, testCaseClass):
        try:
            for index, (func, args) in self.unpack(generator):
                method_name = util.name_from_args(name, index, args)
                setattr(testCaseClass, method_name, None)
                instance = testCaseClass(method_name)
                delattr(testCaseClass, method_name)

                def method(func=func, args=args):
                    return func(*args)
                method = functools.update_wrapper(method, func)
                setattr(instance, method_name, method)
                yield instance
        except:
            exc_info = sys.exc_info()
            test_name = '%s.%s.%s' % (testCaseClass.__module__,
                                      testCaseClass.__name__,
                                      name)
            yield event.loader.failedLoadTests(test_name, exc_info)

    def _testsFromGeneratorFunc(self, event, obj):
        extras = list(obj())
        name = '%s.%s' % (obj.__module__, obj.__name__)
        args = {}
        setUp = getattr(obj, 'setUp', None)
        tearDown = getattr(obj, 'tearDown', None)
        if setUp is not None:
            args['setUp'] = setUp
        if tearDown is not None:
            args['tearDown'] = tearDown

        def createTest(name):
            return util.transplant_class(
                GeneratorFunctionCase, obj.__module__)(name, **args)
        for test in self._testsFromGenerator(event, name, extras, createTest):
            yield test

    def _testsFromGeneratorMethod(self, event, name, method, instance):
        extras = list(method(instance))
        name = "%s.%s.%s" % (instance.__class__.__module__,
                             instance.__class__.__name__,
                             method.__name__)
        args = {}
        setUp = getattr(instance, 'setUp', None)
        tearDown = getattr(instance, 'tearDown', None)
        if setUp is not None:
            args['setUp'] = setUp
        if tearDown is not None:
            args['tearDown'] = tearDown

        def createTest(name):
            return util.transplant_class(
                GeneratorMethodCase(instance.__class__),
                instance.__class__.__module__)(name, **args)
        for test in self._testsFromGenerator(event, name, extras, createTest):
            yield test


class GeneratorFunctionCase(ut2.FunctionTestCase):

    def __init__(self, name, **args):
        self._funcName = name
        ut2.FunctionTestCase.__init__(self, None, **args)

    _testFunc = property(lambda self: getattr(self, self._funcName),
                         lambda self, func: None)

    def __repr__(self):
        return self._funcName

    id = __str__ = __repr__


def GeneratorMethodCase(cls):
    class _GeneratorMethodCase(GeneratorFunctionCase):

        @classmethod
        def setUpClass(klass):
            if hasattr(cls, 'setUpClass'):
                cls.setUpClass()

        @classmethod
        def tearDownClass(klass):
            if hasattr(cls, 'tearDownClass'):
                cls.tearDownClass()
    return _GeneratorMethodCase

########NEW FILE########
__FILENAME__ = loadtests
"""
Loader that implements the load_tests protocol.

This plugin implements the load_tests protocol as detailed in the
documentation for unittest2.

See the `load_tests protocol`_ documentation for more information.

.. warning ::

   Test suites using the load_tests protocol do not work correctly
   with the multiprocess plugin as of nose2 04. This will be
   fixed in a future release.

.. _load_tests protocol: http://docs.python.org/library/unittest.html#load-tests-protocol
"""
from fnmatch import fnmatch
import logging

from nose2 import events, util


log = logging.getLogger(__name__)


class LoadTestsLoader(events.Plugin):

    """Loader plugin that implements load_tests."""
    alwaysOn = True
    configSection = 'load_tests'
    _loading = False

    def registerInSubprocess(self, event):
        event.pluginClasses.append(self.__class__)

    def moduleLoadedSuite(self, event):
        """Run load_tests in a module.

        May add to or filter tests loaded in module.

        """
        module = event.module
        load_tests = getattr(module, 'load_tests', None)
        if not load_tests:
            return
        try:
            event.suite = load_tests(
                event.loader, event.suite, self.session.testFilePattern)
        except Exception as exc:
            log.exception(
                "Failed to load tests from %s via load_tests", module)
            suite = event.loader.suiteClass()
            suite.addTest(event.loader.failedLoadTests(module.__name__, exc))
            event.handled = True
            return suite

    def handleDir(self, event):
        """Run load_tests in packages.

        If a package itself matches the test file pattern, run
        load_tests in its __init__.py, and stop default test
        discovery for that package.

        """
        if self._loading:
            return

        if (self._match(event.name, event.pattern) and
            util.ispackage(event.path)):
            name = util.name_from_path(event.path)
            module = util.module_from_name(name)

            load_tests = getattr(module, 'load_tests', None)
            if not load_tests:
                return
            self._loading = True
            try:
                suite = event.loader.suiteClass()
                try:
                    suite = load_tests(event.loader, suite, event.pattern)
                except Exception as exc:
                    log.exception(
                        "Failed to load tests from %s via load_tests", module)
                    suite.addTest(
                        event.loader.failedLoadTests(module.__name__, exc))

                event.handled = True
                return suite
            finally:
                self._loading = False

    def _match(self, filename, pattern):
        return fnmatch(filename, pattern)

########NEW FILE########
__FILENAME__ = parameters
"""
Load tests from parameterized functions and methods.

This plugin implements :func:`getTestCaseNames`,
:func:`loadTestsFromModule`, and :func:`loadTestsFromName` to support
loading tests from parameterized test functions and methods.

To parameterize a function or test case method, use :func:`nose2.tools.params`.

To address a particular parameterized test via a command-line test name,
append a colon (':') followed by the index, *starting from 1*, of the
case you want to execute.

"""
# This module contains some code copied from unittest2 and other code
# developed in reference to unittest2.
# unittest2 is Copyright (c) 2001-2010 Python Software Foundation; All
# Rights Reserved. See: http://docs.python.org/license.html

import functools
import logging
import types
import unittest

from nose2 import exceptions, util
from nose2.events import Plugin
from nose2.compat import unittest as ut2
from nose2.plugins.loader.testclasses import MethodTestCase


log = logging.getLogger(__name__)
__unittest = True


class ParamsFunctionCase(ut2.FunctionTestCase):

    def __init__(self, name, func, **args):
        self._funcName = name
        ut2.FunctionTestCase.__init__(self, func, **args)

    def __repr__(self):
        return self._funcName

    id = __str__ = __repr__


class Parameters(Plugin):

    """Loader plugin that loads parameterized tests"""
    alwaysOn = True
    configSection = 'parameters'

    def registerInSubprocess(self, event):
        event.pluginClasses.append(self.__class__)

    def getTestCaseNames(self, event):
        """Generate test case names for all parameterized methods"""
        log.debug('getTestCaseNames %s', event)
        names = filter(event.isTestMethod, dir(event.testCase))
        testCaseClass = event.testCase
        for name in names:
            method = getattr(testCaseClass, name)
            paramList = getattr(method, 'paramList', None)
            if paramList is None:
                continue
            # exclude this method from normal collection
            event.excludedNames.append(name)
            # generate the methods to be loaded by the testcase loader
            self._generate(event, name, method, testCaseClass)

    def getTestMethodNames(self, event):
        return self.getTestCaseNames(event)

    def loadTestsFromModule(self, event):
        """Load tests from parameterized test functions in the module"""
        module = event.module

        def is_test(obj):
            return (obj.__name__.startswith(self.session.testMethodPrefix) and
                    hasattr(obj, 'paramList'))
        tests = []
        for name in dir(module):
            obj = getattr(module, name)
            if isinstance(obj, types.FunctionType) and is_test(obj):
                tests.extend(
                    self._generateFuncTests(obj)
                )
        event.extraTests.extend(tests)

    def loadTestsFromName(self, event):
        """Load parameterized test named on command line"""
        original_name = name = event.name
        module = event.module
        try:
            result = util.test_from_name(name, module)
        except (AttributeError, ImportError) as e:
            event.handled = True
            return event.loader.failedLoadTests(name, e)
        if result is None:
            # we can't find it - let the default case handle it
            return

        parent, obj, fqname, index = result
        if not hasattr(obj, 'paramList'):
            return

        if (index is None and not
            isinstance(parent, type) and not
            isinstance(obj, types.FunctionType)):
            log.debug(
                "Don't know how to load parameterized tests from %s", obj)
            return

        if (parent and
            isinstance(parent, type) and
            issubclass(parent, unittest.TestCase)):
            # generator method
            names = self._generate(event, obj.__name__, obj, parent)
            tests = [parent(n) for n in names]
        elif (parent and
              isinstance(parent, type)):
            names = self._generate(event, name, obj, parent)
            tests = [MethodTestCase(parent)(name) for name in names]
        else:
            # generator func
            tests = list(self._generateFuncTests(obj))

        if index is not None:
            try:
                tests = [tests[index - 1]]
            except IndexError:
                raise exceptions.TestNotFoundError(original_name)

        suite = event.loader.suiteClass()
        suite.addTests(tests)
        event.handled = True
        return suite

    def _generate(self, event, name, method, testCaseClass):
        names = []
        for index, argSet in enumerate_params(method.paramList):
            method_name = util.name_from_args(name, index, argSet)
            if not hasattr(testCaseClass, method_name):
                # not already generated
                def _method(self, method=method, argSet=argSet):
                    return method(self, *argSet)
                _method = functools.update_wrapper(_method, method)
                delattr(_method, 'paramList')
                setattr(testCaseClass, method_name, _method)
            names.append(method_name)
        return names

    def _generateFuncTests(self, obj):
        args = {}
        setUp = getattr(obj, 'setUp', None)
        tearDown = getattr(obj, 'tearDown', None)
        if setUp is not None:
            args['setUp'] = setUp
        if tearDown is not None:
            args['tearDown'] = tearDown
        for index, argSet in enumerate_params(obj.paramList):
            def func(argSet=argSet, obj=obj):
                return obj(*argSet)
            func = functools.update_wrapper(func, obj)
            delattr(func, 'paramList')
            name = '%s.%s' % (obj.__module__, obj.__name__)
            func_name = util.name_from_args(name, index, argSet)
            yield util.transplant_class(
                ParamsFunctionCase, obj.__module__)(func_name, func, **args)


def enumerate_params(paramList):
    for index, argSet in enumerate(paramList):
        if not isinstance(argSet, tuple):
            argSet = (argSet,)
        yield index, argSet

########NEW FILE########
__FILENAME__ = testcases
"""
Load tests from :class:`unittest.TestCase` subclasses.

This plugin implements :func:`loadTestsFromName` and
:func:`loadTestsFromModule` to load tests from
:class:`unittest.TestCase` subclasses found in modules or named on the
command line.


"""
# Adapted from unittest2/loader.py from the unittest2 plugins branch.
# This module contains some code copied from unittest2/loader.py and other
# code developed in reference to that module and others within unittest2.
# unittest2 is Copyright (c) 2001-2010 Python Software Foundation; All
# Rights Reserved. See: http://docs.python.org/license.html
import logging
import unittest

from nose2 import events, util


__unittest = True


log = logging.getLogger(__name__)


class TestCaseLoader(events.Plugin):

    """Loader plugin that loads from test cases"""
    alwaysOn = True
    configSection = 'testcases'

    def registerInSubprocess(self, event):
        event.pluginClasses.append(self.__class__)

    def loadTestsFromModule(self, event):
        """Load tests in :class:`unittest.TestCase` subclasses"""
        seen = set()
        module = event.module
        for name in dir(module):
            obj = getattr(module, name)
            if id(obj) in seen:
                continue
            seen.add(id(obj))
            if isinstance(obj, type) and issubclass(obj, unittest.TestCase):
                event.extraTests.append(
                    self._loadTestsFromTestCase(event, obj))

    def loadTestsFromName(self, event):
        """Load tests from event.name if it names a test case/method"""
        name = event.name
        module = event.module
        log.debug("load %s from %s", name, module)
        try:
            result = util.test_from_name(name, module)
        except (AttributeError, ImportError) as e:
            event.handled = True
            return event.loader.failedLoadTests(name, e)
        if result is None:
            return
        parent, obj, name, index = result
        if isinstance(obj, type) and issubclass(obj, unittest.TestCase):
            # name is a test case class
            event.extraTests.append(self._loadTestsFromTestCase(event, obj))
        elif (isinstance(parent, type) and
              issubclass(parent, unittest.TestCase) and
              not util.isgenerator(obj) and
              not hasattr(obj, 'paramList')):
            # name is a single test method
            event.extraTests.append(parent(obj.__name__))

    def _loadTestsFromTestCase(self, event, testCaseClass):
        evt = events.LoadFromTestCaseEvent(event.loader, testCaseClass)
        result = self.session.hooks.loadTestsFromTestCase(evt)
        if evt.handled:
            loaded_suite = result or event.loader.suiteClass()
        else:
            names = self._getTestCaseNames(event, testCaseClass)
            if not names and hasattr(testCaseClass, 'runTest'):
                names = ['runTest']
            # FIXME return failure test case if name not in testcase class
            loaded_suite = event.loader.suiteClass(map(testCaseClass, names))
        if evt.extraTests:
            loaded_suite.addTests(evt.extraTests)
        return loaded_suite

    def _getTestCaseNames(self, event, testCaseClass):
        excluded = set()

        def isTestMethod(attrname, testCaseClass=testCaseClass,
                         excluded=excluded):
            prefix = evt.testMethodPrefix or self.session.testMethodPrefix
            return (
                attrname.startswith(prefix) and
                hasattr(getattr(testCaseClass, attrname), '__call__') and
                attrname not in excluded
            )
        evt = events.GetTestCaseNamesEvent(
            event.loader, testCaseClass, isTestMethod)
        result = self.session.hooks.getTestCaseNames(evt)
        if evt.handled:
            test_names = result or []
        else:
            excluded.update(evt.excludedNames)
            test_names = [entry for entry in dir(testCaseClass)
                          if isTestMethod(entry)]
        if evt.extraNames:
            test_names.extend(evt.extraNames)
        sortkey = getattr(
            testCaseClass, 'sortTestMethodsUsing',
            event.loader.sortTestMethodsUsing)
        if sortkey:
            test_names.sort(
                key=sortkey)
        return test_names

########NEW FILE########
__FILENAME__ = testclasses
"""
Load tests from classes that are *not* :class:`unittest.TestCase` subclasses.

This plugin responds to :func:`loadTestsFromModule` by adding test
cases for test methods found in classes in the module that are *not*
sublcasses of :class:`unittest.TestCase`, but whose names (lowercased)
match the configured test method prefix.

Test class methods that are generators or have param lists are not
loaded here, but by the :class:`nose2.plugins.loader.generators.Generators` and
:class:`nose2.plugins.loader.parameters.Parameters` plugins.

This plugin also implements :func:`loadTestsFromName` to enable
loading tests from dotted class and method names passed on the command
line.

This plugin makes two additional plugin hooks available for other
test loaders to use:

.. function :: loadTestsFromTestClass(self, event)

   :param event: A :class:`LoadFromTestClassEvent` instance

   Plugins can use this hook to load tests from a class that is not a
   :class:`unittest.TestCase` subclass. To prevent other plugins from
   loading tests from the test class, set ``event.handled`` to True and
   return a test suite. Plugins can also append tests to
   ``event.extraTests`` -- ususally that's what you want to do, since
   that will allow other plugins to load their tests from the test
   case as well.

.. function :: getTestMethodNames(self, event)

   :param event: A :class:`GetTestMethodNamesEvent` instance

   Plugins can use this hook to limit or extend the list of test case
   names that will be loaded from a class that is not a
   :class:`unittest.TestCase` subclass by the standard nose2 test
   loader plugins (and other plugins that respect the results of the
   hook). To force a specific list of names, set ``event.handled`` to
   True and return a list: this exact list will be the only test case
   names loaded from the test case. Plugins can also extend the list
   of names by appending test names to ``event.extraNames``, and
   exclude names by appending test names to ``event.excludedNames``.

About Test Classes
------------------

Test classes are classes that look test-like but are not subclasses of
:class:`unittest.TestCase`. Test classes support all of the same test
types and fixtures as test cases.

To "look test-like" a class must have a name that, lowercased, matches
the configured test method prefix -- "test" by default. Test classes
must also be able to be instantiated without arguments.

What are they useful for? Mostly the case where a test class can't for
some reason subclass :class:`unittest.TestCase`. Otherwise, test class
tests and test cases are functionally equivalent in nose2, and test
cases have broader support and all of those helpful *assert\** methods
-- so when in doubt, you should use a :class:`unittest.TestCase`.

Here's an example of a test class::

  class TestSomething(object):

      def test(self):
          assert self.something(), "Something failed!"

"""

import unittest
import sys

from nose2 import events, util
from nose2.compat import unittest as ut2

__unittest = True


class TestClassLoader(events.Plugin):

    """Loader plugin that loads test functions"""
    alwaysOn = True
    configSection = 'test-classes'

    def registerInSubprocess(self, event):
        event.pluginClasses.append(self.__class__)

    def register(self):
        """Install extra hooks

        Adds the new plugin hooks:

        - loadTestsFromTestClass
        - getTestMethodNames

        """
        super(TestClassLoader, self).register()
        self.addMethods('loadTestsFromTestClass', 'getTestMethodNames')

    def loadTestsFromModule(self, event):
        """Load test classes from event.module"""
        module = event.module
        for name in dir(module):
            obj = getattr(module, name)
            if (isinstance(obj, type) and
                not issubclass(obj, unittest.TestCase) and
                not issubclass(obj, unittest.TestSuite) and
                name.lower().startswith(self.session.testMethodPrefix)):
                event.extraTests.append(
                    self._loadTestsFromTestClass(event, obj))

    def loadTestsFromName(self, event):
        """Load tests from event.name if it names a test class/method"""
        name = event.name
        module = event.module
        try:
            result = util.test_from_name(name, module)
        except (AttributeError, ImportError) as e:
            event.handled = True
            return event.loader.failedLoadTests(name, e)
        if result is None:
            return
        parent, obj, name, index = result
        if isinstance(obj, type) and not issubclass(obj, unittest.TestCase):
            # name is a test case class
            event.extraTests.append(self._loadTestsFromTestClass(event, obj))
        elif (isinstance(parent, type) and
              not issubclass(parent, unittest.TestCase) and
              not util.isgenerator(obj) and
              not hasattr(obj, 'paramList')):
            # name is a single test method
            event.extraTests.append(
                util.transplant_class(
                    MethodTestCase(parent), parent.__module__)(obj.__name__))

    def _loadTestsFromTestClass(self, event, cls):
        # ... fire event for others to load from
        evt = LoadFromTestClassEvent(event.loader, cls)
        result = self.session.hooks.loadTestsFromTestClass(evt)
        if evt.handled:
            loaded_suite = result or event.loader.suiteClass()
        else:
            names = self._getTestMethodNames(event, cls)
            try:
                loaded_suite = event.loader.suiteClass(
                    [util.transplant_class(
                     MethodTestCase(cls), cls.__module__)(name)
                        for name in names])
            except:
                _, ev, _ = sys.exc_info()
                return event.loader.suiteClass(
                    event.loader.failedLoadTests(cls.__name__, ev))
        if evt.extraTests:
            loaded_suite.addTests(evt.extraTests)
        # ... add extra tests
        return loaded_suite

    def _getTestMethodNames(self, event, cls):
        # ... give others a chance to modify list
        excluded = set()

        def isTestMethod(attrname, cls=cls, excluded=excluded):
            # FIXME allow plugs to change prefix
            prefix = self.session.testMethodPrefix
            return (
                attrname.startswith(prefix) and
                hasattr(getattr(cls, attrname), '__call__') and
                attrname not in excluded
            )
        evt = GetTestMethodNamesEvent(event.loader, cls, isTestMethod)
        result = self.session.hooks.getTestMethodNames(evt)
        if evt.handled:
            test_names = result or []
        else:
            excluded.update(evt.excludedNames)

            test_names = [entry for entry in dir(cls)
                          if isTestMethod(entry)]

        if event.loader.sortTestMethodsUsing:
            test_names.sort(key=event.loader.sortTestMethodsUsing)
        return test_names


# to prevent unit2 discover from running this as a test, need to
# hide it inside of a factory func. ugly!
def MethodTestCase(cls):
    class _MethodTestCase(ut2.TestCase):

        def __init__(self, method):
            self.method = method
            self._name = "%s.%s.%s" % (cls.__module__, cls.__name__, method)
            self.obj = cls()
            ut2.TestCase.__init__(self, 'runTest')

        @classmethod
        def setUpClass(klass):
            if hasattr(cls, 'setUpClass'):
                cls.setUpClass()

        @classmethod
        def tearDownClass(klass):
            if hasattr(cls, 'tearDownClass'):
                cls.tearDownClass()

        def setUp(self):
            if hasattr(self.obj, 'setUp'):
                self.obj.setUp()

        def tearDown(self):
            if hasattr(self.obj, 'tearDown'):
                self.obj.tearDown()

        def __repr__(self):
            return self._name
        id = __str__ = __repr__

        def runTest(self):
            getattr(self.obj, self.method)()

    return _MethodTestCase

#
# Event classes
#


class LoadFromTestClassEvent(events.LoadFromTestCaseEvent):

    """Bare subclass of :class:`nose2.events.LoadFromTestCaseEvent`"""


class GetTestMethodNamesEvent(events.GetTestCaseNamesEvent):

    """Bare subclass of :class:`nose2.events.GetTestCaseNamesEvent`"""

########NEW FILE########
__FILENAME__ = logcapture
"""
Capture log messages during test execution, appending them to the
error reports of failed tests.

This plugin implements :func:`startTestRun`, :func:`startTest`,
:func:`stopTest`, :func:`setTestOutcome`, and :func:`outcomeDetail` to
set up a logging configuration that captures log messages during test
execution, and appends them to error reports for tests that fail or
raise exceptions.

"""
import logging
from logging.handlers import BufferingHandler
import threading

from nose2.events import Plugin
from nose2.util import ln, parse_log_level


log = logging.getLogger(__name__)
__unittest = True


class LogCapture(Plugin):

    """Capture log messages during test execution"""

    configSection = 'log-capture'
    commandLineSwitch = (None, 'log-capture', 'Enable log capture')
    logformat = '%(name)s: %(levelname)s: %(message)s'
    logdatefmt = None
    clear = False
    filters = ['-nose']

    def __init__(self):
        self.logformat = self.config.as_str('format', self.logformat)
        self.logdatefmt = self.config.as_str('date-format', self.logdatefmt)
        self.filters = self.config.as_list('filter', self.filters)
        self.clear = self.config.as_bool('clear-handlers', self.clear)
        self.loglevel = parse_log_level(
            self.config.as_str('log-level', 'NOTSET'))
        self.handler = MyMemoryHandler(1000, self.logformat, self.logdatefmt,
                                       self.filters)

    def registerInSubprocess(self, event):
        event.pluginClasses.append(self.__class__)

    def startSubprocess(self, event):
        self._setupLoghandler()

    def startTestRun(self, event):
        """Set up logging handler"""
        self._setupLoghandler()

    def startTest(self, event):
        """Set up handler for new test"""
        self._setupLoghandler()

    def setTestOutcome(self, event):
        """Store captured log messages in ``event.metadata``"""
        self._addCapturedLogs(event)

    def stopTest(self, event):
        """Clear captured messages, ready for next test"""
        self.handler.truncate()

    def outcomeDetail(self, event):
        """Append captured log messages to ``event.extraDetail``"""
        logs = event.outcomeEvent.metadata.get('logs', None)
        if logs:
            event.extraDetail.append(ln('>> begin captured logging <<'))
            event.extraDetail.extend(logs)
            event.extraDetail.append(ln('>> end captured logging <<'))

    def _setupLoghandler(self):
        # setup our handler with root logger
        root_logger = logging.getLogger()
        if self.clear:
            if hasattr(root_logger, "handlers"):
                for handler in root_logger.handlers:
                    root_logger.removeHandler(handler)
            for logger in logging.Logger.manager.loggerDict.values():
                if hasattr(logger, "handlers"):
                    for handler in logger.handlers:
                        logger.removeHandler(handler)
        # make sure there isn't one already
        # you can't simply use "if self.handler not in root_logger.handlers"
        # since at least in unit tests this doesn't work --
        # LogCapture() is instantiated for each test case while root_logger
        # is module global
        # so we always add new MyMemoryHandler instance
        for handler in root_logger.handlers[:]:
            if isinstance(handler, MyMemoryHandler):
                root_logger.handlers.remove(handler)
        root_logger.addHandler(self.handler)
        root_logger.setLevel(self.loglevel)

    def _addCapturedLogs(self, event):
        format = self.handler.format
        records = [format(r) for r in self.handler.buffer]
        if 'logs' in event.metadata:
            event.metadata['logs'].extend(records)
        else:
            event.metadata['logs'] = records


class FilterSet(object):

    def __init__(self, filter_components):
        self.inclusive, self.exclusive = self._partition(filter_components)

    @staticmethod
    def _partition(components):
        inclusive, exclusive = [], []
        for component in components:
            if component.startswith('-'):
                exclusive.append(component[1:])
            else:
                inclusive.append(component)
        return inclusive, exclusive

    def allow(self, record):
        """returns whether this record should be printed"""
        if not self:
            # nothing to filter
            return True
        return self._allow(record) and not self._deny(record)

    @staticmethod
    def _any_match(matchers, record):
        """return the bool of whether `record` starts with
        any item in `matchers`"""
        def record_matches_key(key):
            return record == key or record.startswith(key + '.')
        return any(map(record_matches_key, matchers))

    def _allow(self, record):
        if not self.inclusive:
            return True
        return self._any_match(self.inclusive, record)

    def _deny(self, record):
        if not self.exclusive:
            return False
        return self._any_match(self.exclusive, record)


class MyMemoryHandler(BufferingHandler):

    def __init__(self, capacity, logformat, logdatefmt, filters):
        BufferingHandler.__init__(self, capacity)
        fmt = logging.Formatter(logformat, logdatefmt)
        self.setFormatter(fmt)
        self.filterset = FilterSet(filters)

    def flush(self):
        pass  # do nothing

    def truncate(self):
        self.buffer = []

    def filter(self, record):
        return self.filterset.allow(record.name)

    def __getstate__(self):
        state = self.__dict__.copy()
        del state['lock']
        return state

    def __setstate__(self, state):
        self.__dict__.update(state)
        self.lock = threading.RLock()

########NEW FILE########
__FILENAME__ = mp

import logging
import multiprocessing
import select
import unittest
import collections

import os
import sys
import six

import multiprocessing.connection as connection
from nose2 import events, loader, result, runner, session, util

log = logging.getLogger(__name__)


class MultiProcess(events.Plugin):
    configSection = 'multiprocess'

    def __init__(self):
        self.addArgument(self.setProcs, 'N', 'processes', '# o procs')
        self.testRunTimeout = self.config.as_float('test-run-timeout', 60.0)
        self.procs = self.config.as_int(
            'processes', multiprocessing.cpu_count())
        self.setAddress(self.config.as_str('bind_address', None))

        self.cases = {}

    def setProcs(self, num):
        self.procs = int(num[0])  # FIXME merge n fix
        self.register()

    def setAddress(self, address):
        if address is None or address.strip() == '':
            address = []
        else:
            address = [x.strip() for x in address.split(':')[:2]]

        #Background:  On Windows, select.select only works on sockets.  So the
        #ability to select a bindable address and optionally port for the mp
        #plugin was added.  Pipes should support a form of select, but this
        #would require using pywin32.  There are altnernatives but all have
        #some kind of downside.  An alternative might be creating a connection
        #like object using a shared queue for incomings events. 
        self.bind_host = None
        self.bind_port = 0

        if sys.platform == "win32" or address:
            self.bind_host = '127.116.157.163'
            if address and address[0]:
                self.bind_host = address[0]
            
            self.bind_port = 0
            if len(address) >= 2:
                self.bind_port = int(address[1])

    def pluginsLoaded(self, event):
        self.addMethods('registerInSubprocess', 'startSubprocess',
                        'stopSubprocess')

    def startTestRun(self, event):
        event.executeTests = self._runmp

    def beforeInteraction(self, event):
        # prevent interactive plugins from running
        event.handled = True
        return False

    def _runmp(self, test, result):
        flat = list(self._flatten(test))
        procs = self._startProcs()

        # send one initial task to each process
        for proc, conn in procs:
            if not flat:
                break
            caseid = flat.pop(0)
            conn.send(caseid)

        rdrs = [conn for proc, conn in procs if proc.is_alive()]
        while flat or rdrs:
            ready, _, _ = select.select(rdrs, [], [], self.testRunTimeout)
            for conn in ready:
                # XXX proc could be dead
                try:
                    remote_events = conn.recv()
                except EOFError:
                    # probably dead/12
                    log.warning("Subprocess connection closed unexpectedly")
                    continue  # XXX or die?

                if remote_events is None:
                    # XXX proc is done, how to mark it dead?
                    rdrs.remove(conn)
                    continue

                # replay events
                testid, events = remote_events
                log.debug("Received results for %s", testid)
                for (hook, event) in events:
                    log.debug("Received %s(%s)", hook, event)
                    self._localize(event)
                    getattr(self.session.hooks, hook)(event)

                # send a new test to the worker if there is one left
                if not flat:
                    # if there isn't send None - it's the 'done' flag
                    conn.send(None)
                    continue
                caseid = flat.pop(0)
                conn.send(caseid)

        for _, conn in procs:
            conn.close()
        # ensure we wait until all processes are done before
        # exiting, to allow plugins running there to finalize
        for proc, _ in procs:
            proc.join()

    def _prepConns(self):
        """
        If the bind_host is not none, return:
            (multiprocessing.connection.Listener, (address, port, authkey))
        else:
            (parent_connection, child_connection)

        For the former case: accept must be called on the listener. In order
        to get a Connection object for the socket.
        """
        if self.bind_host is not None:
            #prevent "accidental" wire crossing
            authkey = os.urandom(20)
            address = (self.bind_host, self.bind_port)
            listener = connection.Listener(address, authkey=authkey)
            return (listener, listener.address + (authkey,))
        else:
            return multiprocessing.Pipe()

    def _acceptConns(self, parent_conn):
        """
        When listener is is a connection.Listener instance: accept the next
        incoming connection.  However, a timeout mechanism is needed.  Since,
        this functionality was added to support mp over inet sockets, will
        assume a Socket based listen and will accept the private _socket
        member to get a low_level socket to do a select on.
        """
        if isinstance(parent_conn, connection.Listener):
            #ick private interface
            rdrs = [parent_conn._listener._socket]
            readable, _, _ = select.select(rdrs, [], [],
                                           self.testRunTimeout)
            if readable:
                return parent_conn.accept()
            else:
                raise RuntimeError('MP: Socket Connection Failed')
        else:
            return parent_conn

    def _startProcs(self):
        # XXX create session export
        session_export = self._exportSession()
        procs = []
        for i in range(0, self.procs):
            parent_conn, child_conn = self._prepConns()
            proc = multiprocessing.Process(
                target=procserver, args=(session_export, child_conn))
            proc.daemon = True
            proc.start()
            parent_conn = self._acceptConns(parent_conn)
            procs.append((proc, parent_conn))
        return procs

    def _flatten(self, suite):
        # XXX
        # examine suite tests to find out if they have class
        # or module fixtures and group them that way into names
        # of test classes or modules
        # ALSO record all test cases in self.cases
        mods = {}
        classes = {}
        stack = [suite]
        while stack:
            suite = stack.pop()
            for test in suite:
                if isinstance(test, unittest.TestSuite):
                    stack.append(test)
                else:
                    testid = util.test_name(test)
                    self.cases[testid] = test
                    if util.has_module_fixtures(test):
                        mods.setdefault(test.__class__.__module__, []).append(
                            testid)
                    elif util.has_class_fixtures(test):
                        classes.setdefault(
                            "%s.%s" % (test.__class__.__module__,
                                       test.__class__.__name__),
                            []).append(testid)
                    else:
                        yield testid

        for cls in sorted(classes.keys()):
            yield cls
        for mod in sorted(mods.keys()):
            yield mod

    def _localize(self, event):
        # XXX set loader, case, result etc to local ones, if present in event
        # (event case will be just the id)
        # (traceback in exc_info if any won't be real!)
        if hasattr(event, 'result'):
            event.result = self.session.testResult
        if hasattr(event, 'loader'):
            event.loader = self.session.testLoader
        if hasattr(event, 'runner'):
            event.runner = self.session.testRunner
        if hasattr(event, 'test') and isinstance(event.test, six.string_types):
            # remote event.case is the test id
            try:
                event.test = self.cases[event.test]
            except KeyError:
                event.test = self.session.testLoader.failedLoadTests(
                    'test_not_found',
                    RuntimeError("Unable to locate test case for %s in "
                                 "main process" % event.test))._tests[0]

    def _exportSession(self):
        # argparse isn't pickleable
        # no plugin instances
        # no hooks
        export = {'config': self.session.config,
                  'verbosity': self.session.verbosity,
                  'startDir': self.session.startDir,
                  'topLevelDir': self.session.topLevelDir,
                  'logLevel': self.session.logLevel,
                  # XXX classes or modules?
                  'pluginClasses': []}
        # XXX fire registerInSubprocess -- add those plugin classes
        # (classes must be pickleable!)
        event = RegisterInSubprocessEvent()  # FIXME should be own event type
        self.session.hooks.registerInSubprocess(event)
        export['pluginClasses'].extend(event.pluginClasses)
        return export


def procserver(session_export, conn):
    # init logging system
    rlog = multiprocessing.log_to_stderr()
    rlog.setLevel(session_export['logLevel'])

    # make a real session from the "session" we got
    ssn = session.Session()
    ssn.config = session_export['config']
    ssn.hooks = RecordingPluginInterface()
    ssn.verbosity = session_export['verbosity']
    ssn.startDir = session_export['startDir']
    ssn.topLevelDir = session_export['topLevelDir']
    ssn.prepareSysPath()
    loader_ = loader.PluggableTestLoader(ssn)
    ssn.testLoader = loader_
    result_ = result.PluggableTestResult(ssn)
    ssn.testResult = result_
    runner_ = runner.PluggableTestRunner(ssn)  # needed??
    ssn.testRunner = runner_
    # load and register plugins
    ssn.plugins = [
        plugin(session=ssn) for plugin in session_export['pluginClasses']]
    rlog.debug("Plugins loaded: %s", ssn.plugins)
    for plugin in ssn.plugins:
        plugin.register()
        rlog.debug("Registered %s in subprocess", plugin)

    if isinstance(conn, collections.Sequence):
        conn = connection.Client(conn[:2], authkey=conn[2])

    event = SubprocessEvent(loader_, result_, runner_, ssn.plugins, conn)
    res = ssn.hooks.startSubprocess(event)
    if event.handled and not res:
        conn.send(None)
        conn.close()
        ssn.hooks.stopSubprocess(event)
        return
    # receive and run tests
    executor = event.executeTests
    for testid in gentests(conn):
        if testid is None:
            break
        # XXX to handle weird cases like layers, need to
        # deal with the case that testid is something other
        # than a simple string.
        test = event.loader.loadTestsFromName(testid)
        # xxx try/except?
        rlog.debug("Execute test %s (%s)", testid, test)
        executor(test, event.result)
        events = [e for e in ssn.hooks.flush()]
        conn.send((testid, events))
        rlog.debug("Log for %s returned", testid)
    conn.send(None)
    conn.close()
    ssn.hooks.stopSubprocess(event)


# test generator
def gentests(conn):
    while True:
        try:
            testid = conn.recv()
            if testid is None:
                return
            yield testid
        except EOFError:
            return


# custom event classes
class SubprocessEvent(events.Event):

    """Event fired at start and end of subprocess execution.

    .. attribute :: loader

       Test loader instance

    .. attribute :: result

       Test result

    .. attribute :: plugins

       List of plugins loaded in the subprocess.

    .. attribute :: connection

       The :class:`multiprocessing.Connection` instance that the
       subprocess uses for communication with the main process.

    .. attribute :: executeTests

       Callable that will be used to execute tests.  Plugins may set
       this attribute to wrap or otherwise change test execution. The
       callable must match the signature::

         def execute(suite, result):
             ...

    """

    def __init__(self, loader, result, runner, plugins, connection, **metadata):
        self.loader = loader
        self.result = result
        self.runner = runner
        self.plugins = plugins
        self.connection = connection
        self.executeTests = lambda test, result: test(result)
        super(SubprocessEvent, self).__init__(**metadata)


class RegisterInSubprocessEvent(events.Event):

    """Event fired to notify plugins that multiprocess testing will occur

    .. attribute :: pluginClasses

       Add a plugin class to this list to cause the plugin to be
       instantiated in each test-running subprocess. The most common
       thing to do, for plugins that need to run in subprocesses, is::

         def registerInSubprocess(self, event):
             event.pluginClasses.append(self.__class__)

    """

    def __init__(self, **metadata):
        self.pluginClasses = []
        super(RegisterInSubprocessEvent, self).__init__(**metadata)


# custom hook system that records calls and events
class RecordingHook(events.Hook):

    def __init__(self, method, interface):
        super(RecordingHook, self).__init__(method)
        self.interface = interface

    def __call__(self, event):
        res = super(RecordingHook, self).__call__(event)
        self.interface.log(self.method, event)
        return res


class RecordingPluginInterface(events.PluginInterface):
    hookClass = RecordingHook
    noLogMethods = set(
        ['getTestCaseNames', 'startSubprocess', 'stopSubprocess',
         'registerInSubprocess', 'moduleLoadedSuite'])

    def __init__(self):
        super(RecordingPluginInterface, self).__init__()
        self.events = []

    def log(self, method, event):
        self.events.append((method, event))

    def flush(self):
        events = self.events[:]
        self.events = []
        return events

    def register(self, method, plugin):
        """Register a plugin for a method.

        :param method: A method name
        :param plugin: A plugin instance

        """
        self._hookForMethod(method).append(plugin)

    def __getattr__(self, attr):
        if attr.startswith('__'):
            raise AttributeError('No %s in %s' % (attr, self))
        return self._hookForMethod(attr)

    def _hookForMethod(self, method):
        # return recording hook for most hooks, normal hook for those
        # (like test loading and subprocess events) that we don't want
        # to send back to the main process.
        try:
            return self.hooks[method]
        except KeyError:
            if method in self.noLogMethods or method.startswith('loadTest'):
                hook = events.Hook(method)
            else:
                hook = self.hookClass(method, self)
        self.hooks[method] = hook
        return hook

########NEW FILE########
__FILENAME__ = outcomes
"""
Map exceptions to test outcomes.

This plugin implements :func:`setTestOutcome` to enable simple mapping
of exception classes to existing test outcomes.

By setting a list of exception classes in a nose2 config file, you can
configure exceptions that would otherwise be treated as test errors,
to be treated as failures or skips instead:

.. code-block :: ini

  [outcomes]
  always-on = True
  treat-as-fail = NotImplementedError
  treat-as-skip = TodoError
                  IOError

"""

from nose2.events import Plugin


__unittest = True


class Outcomes(Plugin):

    """Map exceptions to other test outcomes"""

    configSection = 'outcomes'
    commandLineSwitch = (None, 'set-outcomes',
                         'Treat some configured exceptions as failure or skips')

    def __init__(self):
        self.treatAsFail = set(self.config.as_list('treat-as-fail', []))
        self.treatAsSkip = set(self.config.as_list('treat-as-skip', []))

    def setTestOutcome(self, event):
        """Update outcome, exc_info and reason based on configured mappings"""
        if event.exc_info:
            ec, ev, tb = event.exc_info
            classname = ec.__name__
            if classname in self.treatAsFail:
                short, long_ = self.labels(classname)
                self._setOutcome(event, 'failed', short, long_)
            elif classname in self.treatAsSkip:
                short, long_ = self.labels(classname, upper=False)
                self._setOutcome(
                    event, 'skipped', short, "%s: '%s'" % (long_, ev), str(ev))

    def labels(self, label, upper=True):
        if upper:
            label = label.upper()
        else:
            label = label.lower()
        short = label[0]
        return short, label

    def _setOutcome(self, event, outcome, shortLabel, longLabel, reason=None):
        event.outcome = outcome
        event.shortLabel = shortLabel
        event.longLabel = longLabel
        if reason:
            event.exc_info = None
            event.reason = reason

########NEW FILE########
__FILENAME__ = printhooks
"""
This plugin is primarily useful for plugin authors who want to debug
their plugins.

It prints each hook that is called to stderr, along with details of
the event that was passed to the hook.

To do that, this plugin overrides :meth:`nose2.events.Plugin.register`
and, after registration, replaces all existing
:class:`nose2.events.Hook` instances in ``session.hooks`` with
instances of a Hook subclass that prints information about each call.
"""
import sys

from nose2 import events


INDENT = []
__unittest = True


class PrintHooks(events.Plugin):

    """Print hooks as they are called"""

    configSection = 'print-hooks'
    commandLineSwitch = ('P', 'print-hooks',
                         'Print names of hooks in order of execution')

    def register(self):
        """Override to inject noisy hook instances.

        Replaces Hook instances in ``self.session.hooks.hooks`` with
        noisier objects.

        """
        super(PrintHooks, self).register()
        # now we can be sure that all other plugins have loaded
        # and this plugin is active, patch in our hook class
        self.session.hooks.hookClass = NoisyHook
        for attr, hook in self.session.hooks.hooks.items():
            newhook = NoisyHook(attr)
            newhook.plugins = hook.plugins
            self.session.hooks.hooks[attr] = newhook


class NoisyHook(events.Hook):

    def __call__(self, event):
        _report(self.method, event)
        _indent()
        try:
            return super(NoisyHook, self).__call__(event)
        finally:
            _dedent()


def _report(method, event):
    sys.stderr.write("\n%s%s: %s" % (''.join(INDENT), method, event))


def _indent():
    INDENT.append('  ')


def _dedent():
    if INDENT:
        INDENT.pop()

########NEW FILE########
__FILENAME__ = prof
"""
Profile test execution using hotshot.

This plugin implements :func:`startTestRun` and replaces
``event.executeTests`` with :meth:`hotshot.Profile.runcall`. It
implements :func:`beforeSummaryReport` to output profiling information
before the final test summary time. Config file options ``filename``,
``sort`` and ``restrict`` can be used to change where profiling
information is saved and how it is presented.

"""
try:
    import hotshot
    from hotshot import stats
except ImportError:
    hotshot, stats = None, None
import logging
import os
import tempfile

from nose2 import events, util

log = logging.getLogger(__name__)
__unittest = True


class Profiler(events.Plugin):

    """Profile the test run"""

    configSection = 'profiler'
    commandLineSwitch = ('P', 'profile', 'Run tests under profiler')

    def __init__(self):
        self.pfile = self.config.as_str('filename', '')
        self.sort = self.config.as_str('sort', 'cumulative')
        self.restrict = self.config.as_list('restrict', [])
        self.clean = False
        self.fileno = None

    def register(self):
        """Don't register if hotshot is not found"""
        if hotshot is None:
            log.error("Unable to profile: hotshot module not available")
            return
        super(Profiler, self).register()

    def startTestRun(self, event):
        """Set up the profiler"""
        self.createPfile()
        self.prof = hotshot.Profile(self.pfile)
        event.executeTests = self.prof.runcall

    def beforeSummaryReport(self, event):
        """Output profiling results"""
        # write prof output to stream
        class Stream:

            def write(self, *msg):
                for m in msg:
                    event.stream.write(m)
                    event.stream.write(' ')
                event.stream.flush()
        stream = Stream()
        self.prof.close()
        prof_stats = stats.load(self.pfile)
        prof_stats.sort_stats(self.sort)
        event.stream.writeln(util.ln("Profiling results"))
        tmp = prof_stats.stream
        prof_stats.stream = stream
        try:
            if self.restrict:
                prof_stats.print_stats(*self.restrict)
            else:
                prof_stats.print_stats()
        finally:
            prof_stats.stream = tmp
        self.prof.close()
        event.stream.writeln('')

        if self.clean:
            if self.fileno:
                try:
                    os.close(self.fileno)
                except OSError:
                    pass
            try:
                os.unlink(self.pfile)
            except OSError:
                pass

    def createPfile(self):
        if not self.pfile:
            self.fileno, self.pfile = tempfile.mkstemp()
            self.clean = True

########NEW FILE########
__FILENAME__ = result
"""
Collect and report test results.

This plugin implements the primary user interface for nose2. It
collects test outcomes and reports on them to the console, as well as
firing several hooks for other plugins to do their own reporting.

To see this report, nose2 MUST be run with the "verbose" flag::

  nose2 --verbose

This plugin extends standard unittest console reporting slightly by
allowing custom report categories. To put events into a custom
reporting category, change the event.outcome to whatever you
want. Note, however, that customer categories are *not* treated as
errors or failures for the purposes of determining whether a test run
has succeeded.

Don't disable this plugin unless you a) have another one doing the
same job or b) really don't want any test results (and want all test
runs to exit(1))
"""
# This module contains some code copied from unittest2/runner.py and other
# code developed in reference to that module and others within unittest2.
# unittest2 is Copyright (c) 2001-2010 Python Software Foundation; All
# Rights Reserved. See: http://docs.python.org/license.html

import sys

from nose2 import events, result, util

__unittest = True


class ResultReporter(events.Plugin):

    """Result plugin that implements standard unittest console reporting"""
    alwaysOn = True
    configSection = 'test-result'
    separator1 = '=' * 70
    separator2 = '-' * 70

    def __init__(self):
        self.testsRun = 0
        self.reportCategories = {'failures': [],
                                 'errors': [],
                                 'skipped': [],
                                 'expectedFailures': [],
                                 'unexpectedSuccesses': []}
        self.dontReport = set(['errors', 'failures', 'skipped', 'passed',
                               'expectedFailures', 'unexpectedSuccesses'])

        self.stream = util._WritelnDecorator(sys.stderr)
        self.descriptions = self.config.as_bool('descriptions', True)

    def startTest(self, event):
        """Handle startTest hook

        - prints test description if verbosity > 1
        """
        self.testsRun += 1
        self._reportStartTest(event)

    def testOutcome(self, event):
        """Handle testOutcome hook

        - records test outcome in reportCategories
        - prints test outcome label
        - fires reporting hooks (:func:`reportSuccess`, :func:`reportFailure`,
          etc)

        """
        if event.outcome == result.ERROR:
            self.reportCategories['errors'].append(event)
            self._reportError(event)
        elif event.outcome == result.FAIL:
            if not event.expected:
                self.reportCategories['failures'].append(event)
                self._reportFailure(event)
            else:
                self.reportCategories['expectedFailures'].append(event)
                self._reportExpectedFailure(event)
        elif event.outcome == result.SKIP:
            self.reportCategories['skipped'].append(event)
            self._reportSkip(event)
        elif event.outcome == result.PASS:
            if event.expected:
                self._reportSuccess(event)
            else:
                self.reportCategories['unexpectedSuccesses'].append(event)
                self._reportUnexpectedSuccess(event)
        else:
            # generic outcome handling
            self.reportCategories.setdefault(event.outcome, []).append(event)
            self._reportOtherOutcome(event)

    def afterTestRun(self, event):
        """Handle afterTestRun hook

        - prints error lists
        - prints summary
        - fires summary reporting hooks (:func:`beforeErrorList`,
          :func:`beforeSummaryReport`, etc)

        """
        self._reportSummary(event)

    def wasSuccessful(self, event):
        event.success = True
        for name, events in self.reportCategories.items():
            for e in events:
                if (e.outcome == result.ERROR or
                    (e.outcome == result.FAIL and not e.expected)):
                    event.success = False
                    break

    def _reportStartTest(self, event):
        evt = events.ReportTestEvent(event, self.stream)
        self.session.hooks.reportStartTest(evt)
        if evt.handled:
            return
        if self.session.verbosity > 1:
            # allow other plugins to override/spy on stream
            evt.stream.write(self._getDescription(event.test, errorList=False))
            evt.stream.write(' ... ')
            evt.stream.flush()

    def _reportError(self, event):
        self._report(event, 'reportError', 'E', 'ERROR')

    def _reportFailure(self, event):
        self._report(event, 'reportFailure', 'F', 'FAIL')

    def _reportSkip(self, event):
        self._report(event, 'reportSkip', 's', 'skipped %s' % event.reason)

    def _reportExpectedFailure(self, event):
        self._report(event, 'reportExpectedFailure', 'x', 'expected failure')

    def _reportUnexpectedSuccess(self, event):
        self._report(
            event, 'reportUnexpectedSuccess', 'u', 'unexpected success')

    def _reportOtherOutcome(self, event):
        self._report(event, 'reportOtherOutcome', '?', 'unknown outcome')

    def _reportSuccess(self, event):
        self._report(event, 'reportSuccess', '.', 'ok')

    def _reportSummary(self, event):
        self.stream.writeln('')
        # let others print something
        evt = events.ReportSummaryEvent(
            event, self.stream, self.reportCategories)
        self.session.hooks.beforeErrorList(evt)
        # allows other plugins to mess with report categories
        cats = evt.reportCategories
        errors = cats.get('errors', [])
        failures = cats.get('failures', [])
        # use evt.stream so plugins can replace/wrap/spy it
        self._printErrorList('ERROR', errors, evt.stream)
        self._printErrorList('FAIL', failures, evt.stream)

        for flavour, events_ in cats.items():
            if flavour in self.dontReport:
                continue
            self._printErrorList(flavour.upper(), events_, evt.stream)
        self._printSummary(evt)

    def _printErrorList(self, flavour, events_, stream):
        for event in events_:
            desc = self._getDescription(event.test, errorList=True)
            err = self._getOutcomeDetail(event)
            stream.writeln(self.separator1)
            stream.writeln("%s: %s" % (flavour, desc))
            self.stream.writeln(self.separator2)
            stream.writeln("%s" % err)

    def _printSummary(self, reportEvent):
        self.stream.writeln(self.separator2)
        self.session.hooks.beforeSummaryReport(reportEvent)

        stream = reportEvent.stream
        run = self.testsRun
        msg = (
            "Ran %d test%s in %.3fs\n" %
            (run, run != 1 and "s" or "", reportEvent.stopTestEvent.timeTaken))
        stream.writeln(msg)

        infos = []
        extraInfos = []
        if reportEvent.stopTestEvent.result.wasSuccessful():
            stream.write("OK")
        else:
            stream.write("FAILED")

        failed = len(reportEvent.reportCategories.get('failures', []))
        errored = len(reportEvent.reportCategories.get('errors', []))
        skipped = len(reportEvent.reportCategories.get('skipped', []))
        expectedFails = len(
            reportEvent.reportCategories.get('expectedFails', []))
        unexpectedSuccesses = len(
            reportEvent.reportCategories.get('unexpectedSuccesses', []))

        for flavour, results in reportEvent.reportCategories.items():
            if flavour in self.dontReport:
                continue
            count = len(results)
            if count:
                extraInfos.append("%s=%d" % (flavour, count))

        if failed:
            infos.append("failures=%d" % failed)
        if errored:
            infos.append("errors=%d" % errored)
        if skipped:
            infos.append("skipped=%d" % skipped)
        if expectedFails:
            infos.append("expected failures=%d" % expectedFails)
        if unexpectedSuccesses:
            infos.append("unexpected successes=%d" % unexpectedSuccesses)
        infos.extend(extraInfos)
        if infos:
            reportEvent.stream.writeln(" (%s)" % (", ".join(infos),))
        else:
            reportEvent.stream.writeln('')

        self.session.hooks.afterSummaryReport(reportEvent)

    def _getDescription(self, test, errorList):
        doc_first_line = test.shortDescription()
        if self.descriptions and doc_first_line:
            desc = '\n'.join((str(test), doc_first_line))
        else:
            desc = str(test)
        event = events.DescribeTestEvent(
            test, description=desc, errorList=errorList)
        self.session.hooks.describeTest(event)
        return event.description

    def _getOutcomeDetail(self, event):
        evt = events.OutcomeDetailEvent(event)
        result = self.session.hooks.outcomeDetail(evt)
        if evt.handled:
            return result
        exc_info = getattr(event, 'exc_info', None)
        test = getattr(event, 'test', None)
        if exc_info:
            detail = [util.exc_info_to_string(exc_info, test)]
        else:
            detail = []
        if evt.extraDetail:
            detail.extend(evt.extraDetail)
        try:
            return "\n".join(detail)
        except UnicodeDecodeError:
            return "\n".join(util.safe_decode(d) for d in detail)

    def _report(self, event, hook, shortLabel, longLabel):
        evt = events.ReportTestEvent(event, self.stream)
        getattr(self.session.hooks, hook)(evt)
        if evt.handled:
            return
        if self.session.verbosity > 1:
            # event I fired has stream, event I received has labels
            evt.stream.writeln(getattr(event, 'longLabel', None) or longLabel)
        elif self.session.verbosity:
            evt.stream.write(getattr(event, 'shortLabel', None) or shortLabel)
            evt.stream.flush()

########NEW FILE########
__FILENAME__ = testid
"""
Allow easy test selection with test ids.

Assigns (and, in verbose mode, prints) a sequential test id for each
test executed. Ids can be fed back in as test names, and this plugin
will translate them back to full test names. Saves typing!

This plugin implements :func:`reportStartTest`,
:func:`loadTestsFromName`, :func:`loadTestsFromNames` and
:func:`stopTest`.

"""
import os
import pickle
import re

from nose2.events import Plugin
from nose2 import util


__unittest = True


class TestId(Plugin):

    """Allow easy test select with ids"""

    configSection = 'testid'
    commandLineSwitch = ('I', 'with-id', 'Add test ids to output')
    idpat = re.compile(r'(\d+)')

    def __init__(self):
        self.idfile = self.config.as_str('id-file', '.noseids')
        self.ids = {}
        self.tests = {}
        if not os.path.isabs(self.idfile):
            # FIXME expand-user?
            self.idfile = os.path.join(os.getcwd(), self.idfile)
        self.id = 0
        self._loaded = False

    def nextId(self):
        """Increment ID and return it."""
        self.id += 1
        return self.id

    def reportStartTest(self, event):
        """Record and possibly output test id"""
        testid = util.test_name(event.testEvent.test)
        if testid not in self.tests:
            id_ = self.nextId()
            self.ids[id_] = testid
            self.tests[testid] = id_
        else:
            id_ = self.tests[testid]
        event.metadata['testid'] = id_
        if self.session.verbosity > 1:
            event.stream.write('#%s ' % id_)

    def loadTestsFromName(self, event):
        """Load tests from a name that is an id

        If the name is a number, it might be an ID assigned by us. If we can
        find a test to which we have assigned that ID, event.name is changed to
        the test's real ID. In this way, tests can be referred to via sequential
        numbers.
        """
        testid = self._testNameFromId(event.name)
        if testid is not None:
            event.name = testid

    def loadTestsFromNames(self, event):
        """Translate test ids into test names"""
        for i, name in enumerate(event.names[:]):
            testid = self._testNameFromId(name)
            if testid is not None:
                event.names[i] = testid

    def stopTestRun(self, event):
        """Write testids file"""
        with open(self.idfile, 'wb') as fh:
            pickle.dump({'ids': self.ids, 'tests': self.tests}, fh)

    def loadIds(self):
        """Load previously pickled 'ids' and 'tests' attributes."""
        if self._loaded:
            return

        try:
            with open(self.idfile, 'rb') as fh:
                data = pickle.load(fh)
        except EnvironmentError:
            self._loaded = True
            return

        if 'ids' in data:
            self.ids = data['ids']
        if 'tests' in data:
            self.tests = data['tests']
        self.id = max(self.ids.keys())
        self._loaded = True

    def _testNameFromId(self, name):
        """Try to translate one of our IDs to real test ID."""
        m = self.idpat.match(name)
        if m is None:
            return None

        id_ = int(m.groups()[0])

        self.loadIds()
        # Translate to test's real ID
        try:
            return self.ids[id_]
        except KeyError:
            return None

########NEW FILE########
__FILENAME__ = result
import time

from nose2 import events


ERROR = 'error'
FAIL = 'failed'
SKIP = 'skipped'
PASS = 'passed'
__unittest = True


class PluggableTestResult(object):

    """Test result that defers to plugins.

    All test outcome recording and reporting is deferred to plugins,
    which are expected to implement startTest, stopTest, testOutcome,
    and wasSuccessful.

    :param session: Test run session.

    .. attribute :: shouldStop

       When True, test run should stop before running another test.

    """

    def __init__(self, session):
        self.session = session
        self.shouldStop = False

    def startTest(self, test):
        """Start a test case.

        Fires :func:`startTest` hook.

        """
        event = events.StartTestEvent(test, self, time.time())
        self.session.hooks.startTest(event)

    def stopTest(self, test):
        """Stop a test case.

        Fires :func:`stopTest` hook.

        """
        event = events.StopTestEvent(test, self, time.time())
        self.session.hooks.stopTest(event)

    def addError(self, test, err):
        """Test case resulted in error.

        Fires :func:`setTestOutcome` and :func:`testOutcome` hooks.

        """
        event = events.TestOutcomeEvent(test, self, ERROR, err)
        self.session.hooks.setTestOutcome(event)
        self.session.hooks.testOutcome(event)

    def addFailure(self, test, err):
        """Test case resulted in failure.

        Fires :func:`setTestOutcome` and :func:`testOutcome` hooks.

        """
        event = events.TestOutcomeEvent(test, self, FAIL, err)
        self.session.hooks.setTestOutcome(event)
        self.session.hooks.testOutcome(event)

    def addSuccess(self, test):
        """Test case resulted in success.

        Fires :func:`setTestOutcome` and :func:`testOutcome` hooks.

        """
        event = events.TestOutcomeEvent(test, self, PASS, expected=True)
        self.session.hooks.setTestOutcome(event)
        self.session.hooks.testOutcome(event)

    def addSkip(self, test, reason):
        """Test case was skipped.

        Fires :func:`setTestOutcome` and :func:`testOutcome` hooks.

        """
        event = events.TestOutcomeEvent(test, self, SKIP, reason=reason)
        self.session.hooks.setTestOutcome(event)
        self.session.hooks.testOutcome(event)

    def addExpectedFailure(self, test, err):
        """Test case resulted in expected failure.

        Fires :func:`setTestOutcome` and :func:`testOutcome` hooks.

        """
        event = events.TestOutcomeEvent(test, self, FAIL, err, expected=True)
        self.session.hooks.setTestOutcome(event)
        self.session.hooks.testOutcome(event)

    def addUnexpectedSuccess(self, test):
        """Test case resulted in unexpected success.

        Fires :func:`setTestOutcome` and :func:`testOutcome` hooks.

        """
        event = events.TestOutcomeEvent(test, self, PASS)
        self.session.hooks.setTestOutcome(event)
        self.session.hooks.testOutcome(event)

    def wasSuccessful(self):
        """Was test run successful?

        Fires :func:`wasSuccessful` hook, returns ``event.success``.

        """
        # assume failure, plugins must affirmatively declare success
        try:
            return self._success
        except AttributeError:
            event = events.ResultSuccessEvent(self, False)
            self.session.hooks.wasSuccessful(event)
            self._success = event.success
            return self._success

    def stop(self):
        """Stop test run.

        Fires :func:`resultStop` hook, sets ``self.shouldStop`` to
        ``event.shouldStop``.

        """
        event = events.ResultStopEvent(self, True)
        self.session.hooks.resultStop(event)
        self.shouldStop = event.shouldStop

    def __repr__(self):
        return '<%s>' % self.__class__.__name__

########NEW FILE########
__FILENAME__ = runner
# This module contains some code copied from unittest2/runner.py and other
# code developed in reference to that module and others within unittest2.
# unittest2 is Copyright (c) 2001-2010 Python Software Foundation; All
# Rights Reserved. See: http://docs.python.org/license.html

import time

from nose2 import events, result


__unittest = True


class PluggableTestRunner(object):

    """Test runner that defers most work to plugins.

    :param session: Test run session

    .. attribute :: resultClass

       Class to instantiate to create test result. Default:
       :class:`nose2.result.PluggableTestResult`.

    """
    resultClass = result.PluggableTestResult

    def __init__(self, session):
        self.session = session

    def run(self, test):
        """Run tests.

        :param test: A unittest TestSuite or TestClass.
        :returns: Test result

        Fires :func:`startTestRun` and :func:`stopTestRun` hooks.

        """
        result = self._makeResult()
        executor = lambda suite, result: suite(result)
        startTime = time.time()
        event = events.StartTestRunEvent(
            self, test, result, startTime, executor)
        self.session.hooks.startTestRun(event)

        # allows startTestRun to modify test suite
        test = event.suite
        # ... and test execution
        executor = event.executeTests
        try:
            if not event.handled:
                executor(test, result)
        finally:
            stopTime = time.time()
            timeTaken = stopTime - startTime
            event = events.StopTestRunEvent(self, result, stopTime, timeTaken)
            self.session.hooks.stopTestRun(event)
            self.session.hooks.afterTestRun(event)
        return result

    def _makeResult(self):
        result = self.resultClass(self.session)
        event = events.ResultCreatedEvent(result)
        self.session.hooks.resultCreated(event)
        self.session.testResult = event.result
        return event.result

    def __repr__(self):
        return '<%s>' % self.__class__.__name__

########NEW FILE########
__FILENAME__ = session
import logging
import os

import argparse
from six.moves import configparser

from nose2 import config, events, util


log = logging.getLogger(__name__)
__unittest = True


class Session(object):

    """Configuration session.

    Encapsulates all configuration for a given test run.

    .. attribute :: argparse

       An instance of :class:`argparse.ArgumentParser`. Plugins can
       use this directly to add arguments and argument groups, but
       *must* do so in their ``__init__`` methods.

    .. attribute :: pluginargs

       The argparse argument group in which plugins (by default) place
       their command-line arguments. Plugins can use this directly to
       add arguments, but *must* do so in their ``__init__`` methods.

    .. attribute :: hooks

       The :class:`nose2.events.PluginInterface` instance contains
       all available plugin methods and hooks.

    .. attribute :: plugins

       The list of loaded -- but not necessarily *active* -- plugins.

    .. attribute :: verbosity

       Current verbosity level. Default: 1.

    .. attribute :: startDir

       Start directory of test run. Test discovery starts
       here. Default: current working directory.

    .. attribute :: topLevelDir

       Top-level directory of test run. This directory is added to
       sys.path. Default: starting directory.

    .. attribute :: libDirs

       Names of code directories, relative to starting
       directory. Default: ['lib', 'src']. These directories are added
       to sys.path and discovery if the exist.

    .. attribute :: testFilePattern

       Pattern used to discover test module files. Default: test*.py

    .. attribute :: testMethodPrefix

       Prefix used to discover test methods and functions: Default: 'test'.

    .. attribute :: unittest

       The config section for nose2 itself.

    """
    configClass = config.Config

    def __init__(self):
        self.argparse = argparse.ArgumentParser(prog='nose2', add_help=False)
        self.pluginargs = self.argparse.add_argument_group(
            'plugin arguments',
            'Command-line arguments added by plugins:')
        self.config = configparser.ConfigParser()
        self.hooks = events.PluginInterface()
        self.plugins = []
        self.verbosity = 1
        self.startDir = None
        self.topLevelDir = None
        self.testResult = None
        self.testLoader = None
        self.logLevel = logging.WARN

    def get(self, section):
        """Get a config section.

        :param section: The section name to retreive.
        :returns: instance of self.configClass.

        """
        # FIXME cache these
        items = []
        if self.config.has_section(section):
            items = self.config.items(section)
        return self.configClass(items)

    def loadConfigFiles(self, *filenames):
        """Load config files.

        :param filenames: Names of config files to load.

        Loads all names files that exist into ``self.config``.

        """
        self.config.read(filenames)

    def loadPlugins(self, modules=None, exclude=None):
        """Load plugins.

        :param modules: List of module names from which to load plugins.

        """
        # plugins set directly
        if modules is None:
            modules = []
        if exclude is None:
            exclude = []
        # plugins mentioned in config file(s)
        cfg = self.unittest
        more_plugins = cfg.as_list('plugins', [])
        cfg_exclude = cfg.as_list('exclude-plugins', [])
        exclude.extend(cfg_exclude)
        exclude = set(exclude)
        all_ = (set(modules) | set(more_plugins)) - exclude
        log.debug("Loading plugin modules: %s", all_)
        for module in all_:
            self.loadPluginsFromModule(util.module_from_name(module))
        self.hooks.pluginsLoaded(events.PluginsLoadedEvent(self.plugins))

    def loadPluginsFromModule(self, module):
        """Load plugins from a module.

        :param module: A python module containing zero or more plugin
                       classes.

        """
        avail = []
        for entry in dir(module):
            try:
                item = getattr(module, entry)
            except AttributeError:
                pass
            try:
                if issubclass(item, events.Plugin):
                    avail.append(item)
            except TypeError:
                pass
        for cls in avail:
            log.debug("Plugin is available: %s", cls)
            plugin = cls(session=self)
            self.plugins.append(plugin)
            for method in self.hooks.preRegistrationMethods:
                if hasattr(plugin, method):
                    self.hooks.register(method, plugin)

    def registerPlugin(self, plugin):
        """Register a plugin.

        :param plugin: A `nose2.events.Plugin` instance.

        Register the plugin with all methods it implements.

        """
        log.debug("Register active plugin %s", plugin)
        if plugin not in self.plugins:
            self.plugins.append(plugin)
        for method in self.hooks.methods:
            if hasattr(plugin, method):
                log.debug("Register method %s for plugin %s", method, plugin)
                self.hooks.register(method, plugin)

    def setStartDir(self):
        if self.startDir is None:
            self.startDir = self.unittest.as_str('start-dir', '.')

    def prepareSysPath(self):
        """Add code directories to sys.path"""
        tld = self.topLevelDir
        sd = self.startDir
        if tld is None:
            tld = sd
        tld = os.path.abspath(tld)
        util.ensure_importable(tld)
        for libdir in self.libDirs:
            libdir = os.path.abspath(os.path.join(tld, libdir))
            if os.path.exists(libdir):
                util.ensure_importable(libdir)

    # convenience properties
    @property
    def libDirs(self):
        return self.unittest.as_list('code-directories', ['lib', 'src'])

    @property
    def testFilePattern(self):
        return self.unittest.as_str('test-file-pattern', 'test*.py')

    @property
    def testMethodPrefix(self):
        return self.unittest.as_str('test-method-prefix', 'test')

    @property
    def unittest(self):
        return self.get('unittest')

########NEW FILE########
__FILENAME__ = sphinxext
import types

from docutils import nodes
from docutils.statemachine import ViewList
from docutils.parsers.rst import Directive, directives

from nose2 import events, session, util


AD = u'<autodoc>'
__unittest = True


class AutoPlugin(Directive):
    required_arguments = 1
    optional_arguments = 1
    final_argument_whitespace = False
    has_content = False
    option_spec = {'module': directives.unchanged}

    def run(self):
        plugin_name = self.arguments[0]
        parent, plugin = util.object_from_name(plugin_name)
        if isinstance(plugin, types.ModuleType):
            # document all plugins in module
            module = plugin
            mod_name = module.__name__
            plugins = self.plugins(module)

        else:
            if 'module' in self.options:
                mod_name = self.options['module']
            else:
                mod_name = plugin_name[
                    0:plugin_name.index(plugin.__name__) - 1]
            plugins = [plugin]

        rst = ViewList()
        if mod_name:
            rst.append(u'.. automodule :: %s\n' % mod_name, AD)
            rst.append(u'', AD)

        for plug in plugins:
            self.document(rst, plug)

        # parse rst and generate new nodelist
        state = self.state
        node = nodes.section()
        node.document = state.document
        surrounding_title_styles = state.memo.title_styles
        surrounding_section_level = state.memo.section_level
        state.memo.title_styles = []
        state.memo.section_level = 0
        state.nested_parse(rst, 0, node, match_titles=1)
        state.memo.title_styles = surrounding_title_styles
        state.memo.section_level = surrounding_section_level

        return node.children

    def document(self, rst, plugin):
        ssn = session.Session()
        ssn.configClass = ssn.config = config = ConfigBucket()
        ssn.pluginargs = opts = OptBucket()
        plugin_name = plugin.__name__
        config = ssn.config
        obj = plugin(session=ssn)
        try:
            obj.pluginsLoaded(events.PluginsLoadedEvent([obj]))
        except AttributeError:
            pass

        # config options
        if config.vars:
            self.add_config(rst, config)

        # command-line options
        if opts.opts:
            self.headline(rst, u'Command-line options')
            for opt in opts:
                for line in opt.options():
                    rst.append(line, AD)
                rst.append('', AD)

        # class __doc__
        self.headline(rst, u'Plugin class reference: %s' % plugin_name)
        rst.append(u'.. autoclass :: %s' % plugin_name, AD)
        rst.append(u'   :members:', AD)
        rst.append(u'', AD)

    def add_config(self, rst, config):
        headline = u'Configuration [%s]' % config.section
        self.headline(rst, headline)

        for var in sorted(config.vars.keys()):
            info = config.vars[var]
            rst.append(u'.. rst:configvar :: %s' % var, AD)
            rst.append(u'  ', AD)
            rst.append(u'  :Default: %(default)s' % info, AD)
            rst.append(u'  :Type: %(type)s' % info, AD)
            rst.append(u'', AD)

        self.headline(rst, u"Sample configuration", '-')
        rst.append(u'The default configuration is equivalent to including '
                   u'the following in a unittest.cfg file.', AD)
        rst.append(u'', AD)
        rst.append(u'.. code-block:: ini', AD)
        rst.append(u'  ', AD)
        rst.append(u'  [%s]' % config.section, AD)
        for var in sorted(config.vars.keys()):
            info = config.vars[var]
            entry = '  %s = ' % (var)
            if info['type'] != 'list':
                entry = u'%s%s' % (entry, info['default'])
                rst.append(entry, AD)
            elif info['default']:
                pad = ' ' * len(entry)
                entry = u'%s%s' % (entry, info['default'][0])
                rst.append(entry, AD)
                for val in info['default'][1:]:
                    rst.append(u'%s%s' % (pad, val), AD)
            else:
                rst.append(entry, AD)
        rst.append(u'', AD)

    def headline(self, rst, headline, level=u'='):
        rst.append(headline, AD)
        rst.append(level * len(headline), AD)
        rst.append(u'', AD)

    def plugins(self, module):
        for entry in dir(module):
            try:
                item = getattr(module, entry)
            except AttributeError:
                pass
            try:
                if issubclass(item, events.Plugin):
                    yield item
            except TypeError:
                pass


def setup(app):
    app.add_directive('autoplugin', AutoPlugin)
    app.add_object_type('configvar', 'config', u'pair: %s; configvar')


DEFAULT = object()


class ConfigBucket(object):

    def __init__(self):
        self.section = None
        self.vars = {}

    def __call__(self, items):
        self.vars = dict(items)
        return self

    def has_section(self, section):
        self.section = section
        return False

    def items(self):
        return self.vars.items()

    def as_bool(self, item, default=DEFAULT):
        self.vars[item] = {'type': 'boolean',
                           'default': default}
        return default
    as_tri = as_bool

    def as_int(self, item, default=DEFAULT):
        self.vars[item] = {'type': 'integer',
                           'default': default}
        return default

    def as_float(self, item, default=DEFAULT):
        self.vars[item] = {'type': 'float',
                           'default': default}
        return default

    def as_str(self, item, default=DEFAULT):
        self.vars[item] = {'type': 'str',
                           'default': default}
        return default

    def as_list(self, item, default=DEFAULT):
        self.vars[item] = {'type': 'list',
                           'default': default}
        return default

    def __getitem__(self, item):
        self.vars[item] = {'type': None,
                           'default': DEFAULT}

    def get(self, item, default=DEFAULT):
        self.vars[item] = {'type': None,
                           'default': default}
        return default


class OptBucket(object):

    def __init__(self, doc=None, prog='nosetests'):
        self.seen = set()
        self.opts = []
        self.doc = doc
        self.prog = prog

    def __iter__(self):
        return iter(self.opts)

    def format_help(self):
        return self.doc.replace('%prog', self.prog).replace(':\n', '::\n')

    def add_argument(self, *arg, **kw):
        if not arg in self.seen:
            self.opts.append(Opt(*arg, **kw))
            self.seen.add(arg)

    def __call__(self, callback, opt=None, longOpt=None, help=None):
        opts = []
        if opt is not None:
            opts.append('-' + opt)
        if longOpt is not None:
            opts.append('--' + longOpt)
        self.add_option(*opts, help=help)


class Opt(object):

    def __init__(self, *arg, **kw):
        self.opts = arg
        self.action = kw.pop('action', None)
        self.default = kw.pop('default', None)
        self.metavar = kw.pop('metavar', None)
        self.help = kw.pop('help', None)

    def options(self):
        buf = []
        for optstring in self.opts:
            desc = optstring
            if self.action not in ('store_true', 'store_false', None):
                desc += ' %s' % self.meta(optstring)
            buf.append(desc)
            res = ['.. cmdoption :: ' + ', '.join(buf)]
            if self.help:
                res.append('')
                res.append('   %s' % self.help)
            res.append('')
        return res

    def meta(self, optstring):
        # FIXME optparser default metavar?
        return self.metavar or 'DEFAULT'

########NEW FILE########
__FILENAME__ = suite
import inspect
import logging

from nose2 import util
from nose2.compat import unittest

log = logging.getLogger(__name__)

__unittest = True

#
# Layer suite class
#


class LayerSuite(unittest.BaseTestSuite):

    def __init__(self, tests=(), layer=None):
        super(LayerSuite, self).__init__(tests)
        self.layer = layer
        self.wasSetup = False

    def run(self, result):
        self.setUp()
        try:
            for test in self:
                if result.shouldStop:
                    break
                self.setUpTest(test)
                try:
                    test(result)
                finally:
                    self.tearDownTest(test)
        finally:
            if self.wasSetup:
                self.tearDown()

    def setUp(self):
        # FIXME hook call
        log.debug('in setUp layer %s', self.layer)
        if self.layer is None:
            return

        setup = self._getBoundClassmethod(self.layer, 'setUp')
        if setup:
            setup()
            log.debug('setUp layer %s called', self.layer)
        self.wasSetup = True

    def setUpTest(self, test):
        # FIXME hook call
        if self.layer is None:
            return
        # skip suites, to ensure test setup only runs once around each test
        # even for sub-layer suites inside this suite.
        try:
            iter(test)
        except TypeError:
            # ok, not a suite
            pass
        else:
            # suite-like enough for skipping
            return
        if getattr(test, '_layer_wasSetUp', False):
            return
        self._allLayers(test, 'testSetUp')
        test._layer_wasSetUp = True

    def tearDownTest(self, test):
        # FIXME hook call
        if self.layer is None:
            return
        if not getattr(test, '_layer_wasSetUp', None):
            return
        self._allLayers(test, 'testTearDown', reverse=True)
        delattr(test, '_layer_wasSetUp')

    def tearDown(self):
        # FIXME hook call
        if self.layer is None:
            return

        teardown = self._getBoundClassmethod(self.layer, 'tearDown')
        if teardown:
            teardown()
            log.debug('tearDown layer %s called', self.layer)

    def _allLayers(self, test, method, reverse=False):
        done = set()
        all_lys = util.ancestry(self.layer)
        if reverse:
            all_lys = [reversed(lys) for lys in reversed(all_lys)]
        for lys in all_lys:
            for layer in lys:
                if layer in done:
                    continue
                self._inLayer(layer, test, method)
                done.add(layer)

    def _inLayer(self, layer, test, method):
        meth = self._getBoundClassmethod(layer, method)
        if meth:
            args, _, _, _ = inspect.getargspec(meth)
            if len(args) > 1:
                meth(test)
            else:
                meth()

    def _getBoundClassmethod(self, cls, method):
        """
        Use instead of getattr to get only classmethods explicitly defined
        on cls (not methods inherited from ancestors)
        """
        descriptor = cls.__dict__.get(method, None)
        if descriptor:
            if not isinstance(descriptor, classmethod):
                raise TypeError(
                    'The %s method on a layer must be a classmethod.' % method)
            bound_method = descriptor.__get__(None, cls)
            return bound_method
        else:
            return None

########NEW FILE########
__FILENAME__ = plugin_a
from nose2 import events


class PluginA(events.Plugin):
    configSection = 'a'

    def __init__(self):
        self.a = self.config.as_int('a', 0)

########NEW FILE########
__FILENAME__ = test_cf_testcase
import unittest


class Test(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.x = 1

    def test_1(self):
        assert self.x

    def test_2(self):
        assert self.x


class Test2(unittest.TestCase):

    def setUp(self):
        self.x = 1

    def test_1(self):
        assert self.x

    def test_2(self):
        assert self.x


class Test3(Test):
    # this has class setup by virtue of inheritting from Test

    def test_3(self):
        assert self.x

########NEW FILE########
__FILENAME__ = test

########NEW FILE########
__FILENAME__ = test

########NEW FILE########
__FILENAME__ = test
import unittest


class TestDunderTest(unittest.TestCase):
    __test__ = False

    def test_a(self):
        pass

########NEW FILE########
__FILENAME__ = test_junitxml_chdir
import os.path
import shutil
import tempfile

from nose2.compat import unittest


class Test(unittest.TestCase):

    def setUp(self):
        super(Test, self).setUp()

        self.temp_dir = tempfile.mkdtemp()

    def tearDown(self):
        super(Test, self).tearDown()

        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_chdir(self):
        os.chdir(self.temp_dir)

########NEW FILE########
__FILENAME__ = test_junitxml_happyday
import unittest


class Test(unittest.TestCase):

    def test(self):
        pass

########NEW FILE########
__FILENAME__ = test_layers
from nose2.compat import unittest

STATE = {}


class Base(object):

    @classmethod
    def setUp(cls):
        STATE['base'] = 'setup'

    @classmethod
    def tearDown(cls):
        del STATE['base']


class LayerA(Base):
    position = 1

    @classmethod
    def setUp(cls):
        STATE['layerA'] = 'setup'

    @classmethod
    def tearDown(cls):
        del STATE['layerA']

    @classmethod
    def testSetUp(cls, test):
        STATE['layerA.test'] = 'setup'
        # print "->", STATE, test

    @classmethod
    def testTearDown(cls, test):
        # print "<-", STATE, test
        del STATE['layerA.test']


class LayerA_1(LayerA):
    position = 0

    @classmethod
    def setUp(cls):
        STATE['layerA_1'] = 'setup'

    @classmethod
    def tearDown(cls):
        del STATE['layerA_1']


class LayerB(LayerA):
    position = 2

    @classmethod
    def setUp(cls):
        STATE['layerB'] = 'setup'

    @classmethod
    def tearDown(cls):
        del STATE['layerB']


class LayerB_1(LayerB):
    position = 0

    @classmethod
    def setUp(cls):
        STATE['layerB_1'] = 'setup'

    @classmethod
    def tearDown(cls):
        del STATE['layerB_1']


class LayerC(LayerB, LayerA):
    position = 1

    @classmethod
    def setUp(cls):
        STATE['layerC'] = 'setup'

    @classmethod
    def tearDown(cls):
        del STATE['layerC']


class LayerD(Base):
    position = 0

    @classmethod
    def setUp(cls):
        STATE['layerD'] = 'setup'

    @classmethod
    def tearDown(cls):
        del STATE['layerD']


class Outer(unittest.TestCase):
    layer = Base

    def test(self):
        self.assertEqual(STATE.get('base'), 'setup')


class InnerA(unittest.TestCase):
    layer = LayerA

    def setUp(self):
        STATE['innerA.test'] = 'setup'

    def tearDown(self):
        del STATE['innerA.test']

    def test(self):
        expect = {'base': 'setup',
                  'layerA': 'setup',
                  'innerA.test': 'setup',
                  'layerA.test': 'setup'}
        for k, v in expect.items():
            self.assertEqual(STATE.get(k), v)


class InnerA_1(unittest.TestCase):
    layer = LayerA_1

    def test(self):
        expect = {'base': 'setup',
                  'layerA': 'setup',
                  'layerA_1': 'setup',
                  'layerA.test': 'setup'}
        for k, v in expect.items():
            self.assertEqual(STATE.get(k), v)


class InnerB(unittest.TestCase):
    layer = LayerB

    def setUp(self):
        STATE['innerB.test'] = 'setup'

    def tearDown(self):
        STATE['innerB.test'] = 'tearDown'


class InnerB_1(unittest.TestCase):
    layer = LayerB_1

    def test(self):
        expect = {'base': 'setup',
                  'layerB': 'setup',
                  'layerB_1': 'setup'}
        for k, v in expect.items():
            self.assertEqual(STATE.get(k), v)


class InnerC(unittest.TestCase):
    layer = LayerC

    def test(self):
        expect = {'base': 'setup',
                  'layerB': 'setup',
                  'layerC': 'setup',
                  'layerA': 'setup',
                  'layerA.test': 'setup'}
        for k, v in expect.items():
            self.assertEqual(STATE.get(k), v)

    def test2(self):
        expect = {'base': 'setup',
                  'layerB': 'setup',
                  'layerC': 'setup',
                  'layerA': 'setup',
                  'layerA.test': 'setup'}
        for k, v in expect.items():
            self.assertEqual(STATE.get(k), v)


class InnerD(unittest.TestCase):
    layer = LayerD

    def test(self):
        self.assertEqual(
            {'base': 'setup',
             'layerD': 'setup'},
            STATE)


class NoLayer(unittest.TestCase):

    def test(self):
        self.assertEqual(STATE, {})

########NEW FILE########
__FILENAME__ = test_layers_and_attributes
from nose2.compat import unittest

STATE = {}


class L1(object):

    @classmethod
    def setUp(cls):
        STATE['L1'] = 'setup'

    @classmethod
    def tearDown(cls):
        del STATE['L1']


class L2(object):

    @classmethod
    def setUp(cls):
        STATE['L2'] = 'setup'

    @classmethod
    def tearDown(cls):
        del STATE['L2']


class LayerAndAttributesA(unittest.TestCase):
    layer = L1
    a = 1

    def test(self):
        self.assertEqual(STATE.get('L1'), 'setup')


class LayerAndAttributesB(unittest.TestCase):
    layer = L2
    b = 1

    def test(self):
        self.assertEqual(STATE.get('L2'), 'setup')

########NEW FILE########
__FILENAME__ = test_layers_with_errors
from nose2.compat import unittest


class Layer(object):
    description = 'fixture with a value'

    @classmethod
    def setUp(cls):
        cls.value = 1


class Test(unittest.TestCase):
    layer = Layer

    def test_ok(self):
        self.assertEqual(self.layer.value, 1)

    def test_fail(self):
        self.assertEqual(self.layer.value, 2)

    def test_err(self):
        self.assertEqual(self.layer.mulch, 'pine')

########NEW FILE########
__FILENAME__ = test_such_with_errors
from nose2.tools import such

with such.A('test scenario with errors') as it:

    @it.has_setup
    def set_value():
        it.value = 1

    @it.should('check that value == 1')
    def test_passes(case):
        case.assertEqual(it.value, 1)

    @it.should('check that value == 2 and fail')
    def test_fails(case):
        case.assertEqual(it.value, 2)

    @it.should('check for an attribute that does not exist and raise an error')
    def test_err(case):
        case.assertEqual(it.mulch, 'pine')


it.createTests(globals())

########NEW FILE########
__FILENAME__ = test_layers_with_inheritance
from nose2.compat import unittest


class L1(object):

    @classmethod
    def setUp(cls):
        print('L1 setUp')

    @classmethod
    def testSetUp(cls):
        print('L1 testSetUp')

    @classmethod
    def tearDown(cls):
        print('L1 tearDown')

    @classmethod
    def testTearDown(cls):
        print('L1 testTearDown')


class L2(L1):

    @classmethod
    def setUp(cls):
        print('L2 setUp')

    @classmethod
    def testSetUp(cls):
        print('L2 testSetUp')

    @classmethod
    def testTearDown(cls):
        print('L2 testTearDown')


# L1 tearDown should only run once
class T1(unittest.TestCase):
    layer = L2

    def test1(self):
        print('Run test1')

    def test2(self):
        print('Run test2')

########NEW FILE########
__FILENAME__ = test_filter
import unittest


class TestCase(unittest.TestCase):

    def test_a(self):
        pass

    def test_b(self):
        pass

    def test_c(self):
        pass


def load_tests(loader, tests, pattern):
    del tests._tests[0]._tests[1]
    return tests

########NEW FILE########
__FILENAME__ = test_simple
import unittest


class TestCase(unittest.TestCase):

    def test_a(self):
        pass

    def test_b(self):
        pass

    def test_c(self):
        pass


def load_tests(loader, tests, pattern):
    class InnerTest(unittest.TestCase):

        def test_d(self):
            pass
    tests.addTest(InnerTest('test_d'))
    return tests

########NEW FILE########
__FILENAME__ = test_find_these
import unittest


class Test(unittest.TestCase):

    def test(self):
        pass

########NEW FILE########
__FILENAME__ = test_skip_these
import unittest


class Test(unittest.TestCase):

    def test(self):
        raise Exception("this should not execute")

########NEW FILE########
__FILENAME__ = test_gen_many_func
def check(_):
    pass


def test():
    for i in range(0, 600):
        yield check, i


########NEW FILE########
__FILENAME__ = test_gen_many_socket_func
def check(_):
    pass


def test():
    for i in range(0, 600):
        yield check, i


########NEW FILE########
__FILENAME__ = test_mf_func
THINGS = []


def setUpModule():
    THINGS.append(1)


def tearDownModule():
    while THINGS:
        THINGS.pop()


def test():
    assert THINGS, "setup didn't run I think"

########NEW FILE########
__FILENAME__ = test_mf_gen_func
THINGS = []


def setUpModule():
    THINGS.append(1)


def tearDownModule():
    while THINGS:
        THINGS.pop()


def check(_):
    assert THINGS, "setup didn't run I think"


def test():
    yield check, 1

########NEW FILE########
__FILENAME__ = test_mf_param_func
THINGS = []


def setUpModule():
    THINGS.append(1)


def tearDownModule():
    while THINGS:
        THINGS.pop()


def test(p):
    assert THINGS, "setup didn't run I think"
test.paramList = (1,)

########NEW FILE########
__FILENAME__ = test_mf_testcase
import unittest

THINGS = []


def setUpModule():
    THINGS.append(1)


def tearDownModule():
    while THINGS:
        THINGS.pop()


class Test(unittest.TestCase):

    def test_1(self):
        assert THINGS, "setup didn't run"

    def test_2(self):
        assert THINGS, "setup didn't run"

########NEW FILE########
__FILENAME__ = test_import_err
import unittest
raise ImportError("booms")


def test():
    pass


class Test(unittest.TestCase):

    def test(self):
        pass

########NEW FILE########
__FILENAME__ = a
"""An empty module."""

########NEW FILE########
__FILENAME__ = tests
import nose2
import unittest


class Test(unittest.TestCase):

    def test(self):
        pass

if __name__ == '__main__':
    nose2.main()
########NEW FILE########
__FILENAME__ = tests
import logging
import unittest

from pkg2 import get_one


log = logging.getLogger(__name__)
log.debug("module imported")


def test():
    log.debug("test run")
    assert get_one() == 1


def test_fail():
    log.debug("test_fail run")
    assert get_one() == 2


class Tests(unittest.TestCase):

    def test_fail2(self):
        log.debug("test_fail2 run")
        self.assertEqual(get_one(), 4)

########NEW FILE########
__FILENAME__ = test_slow
import time
import unittest

import logging

log = logging.getLogger(__name__)


class TestSlow(unittest.TestCase):

    def test_ok(self):
        print("hide this")
        time.sleep(2)

    def test_fail(self):
        print("show this")
        log.debug("hola")
        time.sleep(2)
        self.assertEqual(1, 2)

    def test_err(self):
        print("show this too")
        log.debug("ciao")
        time.sleep(2)
        {}['x']

########NEW FILE########
__FILENAME__ = mod1

def some_other_func():
    """This is a function with an inline doctest.

    >>> a = 1
    >>> b = 2
    >>> a == b
    False
    """
    pass

########NEW FILE########
__FILENAME__ = test_things
try:
    import unittest2 as unittest
except ImportError:
    import unittest


class SomeTests(unittest.TestCase):
    tags = ['case']

    def test_ok(self):
        pass
    test_ok.tags = ['method', 'pass']
    test_ok.a = 0
    test_ok.b = 1

    def test_typeerr(self):
        raise TypeError("oops")
    test_typeerr.tags = ['method']

    def test_failed(self):
        print("Hello stdout")
        assert False, "I failed"
    test_failed.tags = ['method']

    def test_skippy(self):
        raise unittest.SkipTest("I wanted to skip")
    test_skippy.a = 1
    test_skippy.b = 1

    def test_gen_method(self):
        def check(x):
            assert x == 1
        check.b = 2
        yield check, 1
        yield check, 2
    test_gen_method.a = 1
    test_gen_method.b = 1

    def test_params_method(self, a):
        self.assertEqual(a, 1)
    test_params_method.paramList = (1, 2)
    test_params_method.a = 1


def test_func():
    assert 1 == 1
test_func.a = 1
test_func.b = 0
test_func.tags = ['func', 'pass']


def test_gen():
    def check(a, b):
        assert a == b
    check.tags = ['func']
    for i in range(0, 5):
        yield check, (i, i,)
test_gen.testGenerator = True
test_gen.tags = ['func']


def test_gen_nose_style():
    def check(a, b):
        assert a == b
    for i in range(0, 5):
        yield check, i, i


did_setup = False


def setup():
    global did_setup
    did_setup = True


def test_fixt():
    assert did_setup
test_fixt.setup = setup


def test_params_func(a):
    assert a == 1
test_params_func.paramList = (1, 2)
test_params_func.tags = ['func']


def test_params_func_multi_arg(a, b):
    assert a == b
test_params_func_multi_arg.paramList = ((1, 1), (1, 2), (2, 2))

########NEW FILE########
__FILENAME__ = test_classes
class Test(object):

    def test(self):
        pass

    def test_gen(self):
        def check(a):
            pass
        for i in range(0, 5):
            yield check, i

    def test_params(self, a):
        pass
    test_params.paramList = (1, 2)

########NEW FILE########
__FILENAME__ = test_fixtures
class Test(object):

    @classmethod
    def setUpClass(cls):
        cls.setup = 1

    @classmethod
    def tearDownClass(cls):
        del cls.setup

    def setUp(self):
        self.test_setup = 1

    def tearDown(self):
        del self.test_setup

    def test(self):
        assert self.test_setup
        assert self.setup

    def test_gen(self):
        def check(a):
            assert self.test_setup
            assert self.setup
        for i in range(0, 2):
            yield check, i

    def test_params(self, a):
        assert self.test_setup
        assert self.setup
    test_params.paramList = (1, 2)

########NEW FILE########
__FILENAME__ = test_class_fail

class Test(object):
    def __init__(self):
        raise RuntimeError('Something bad happened but other tests should still be run!')
    
    def test(self):
        raise RuntimeError('Something bad happened but other tests should still be run! RUNNING')


########NEW FILE########
__FILENAME__ = mod1
def covered_func():
    a = 1
    a = a + 8
    return a


def uncovered_func():
    b = 1
    b = b + 8
    return b

########NEW FILE########
__FILENAME__ = test_coverage
import unittest

from lib import mod1


class TestLib(unittest.TestCase):
    def test1(self):
        self.assertEqual(mod1.covered_func(), 9)

########NEW FILE########
__FILENAME__ = test_regression_same_havings
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from nose2.tools import such

with such.A('system') as it:

    with it.having('something'):
        @it.should("do stuff")
        def test_should_do_stuff(case):
            pass

    it.createTests(globals())

with such.A('another system') as it:

    with it.having('something'):
        @it.should("do stuff")
        def test_should_do_stuff(case):
            pass

    it.createTests(globals())
########NEW FILE########
__FILENAME__ = test_such
import unittest

from nose2.tools import such


class SomeLayer(object):

    @classmethod
    def setUp(cls):
        it.somelayer = True

    @classmethod
    def tearDown(cls):
        del it.somelayer

#
# Such tests start with a declaration about the system under test
# and will typically bind the test declaration to a variable with
# a name that makes nice sentences, like 'this' or 'it'.
#
with such.A('system with complex setup') as it:

    #
    # Each layer of tests can define setup and teardown methods.
    # setup and teardown methods defined here run around the entire
    # group of tests, not each individual test.
    #
    @it.has_setup
    def setup():
        it.things = [1]

    @it.has_teardown
    def teardown():
        it.things = []

    #
    # The 'should' decorator is used to mark tests.
    #
    @it.should('do something')
    def test():
        assert it.things
        #
        # Tests can use all of the normal unittest TestCase assert
        # methods by calling them on the test declaration.
        #
        it.assertEqual(len(it.things), 1)

    #
    # The 'having' context manager is used to introduce a new layer,
    # one that depends on the layer(s) above it. Tests in this
    # new layer inherit all of the fixtures of the layer above.
    #
    with it.having('an expensive fixture'):
        @it.has_setup
        def setup():
            it.things.append(2)

        #
        # Tests that take an argument will be passed the
        # unittest.TestCase instance that is generated to wrap
        # them. Tests can call any and all TestCase methods on this
        # instance.
        #
        @it.should('do more things')
        def test(case):
            case.assertEqual(it.things[-1], 2)

        #
        # Layers can be nested to any depth.
        #
        with it.having('another precondtion'):
            @it.has_setup
            def setup():
                it.things.append(3)

            @it.has_teardown
            def teardown():
                it.things.pop()

            @it.should('do that not this')
            def test(case):
                it.things.append(4)
                #
                # Tests can add their own cleanup functions.
                #
                case.addCleanup(it.things.pop)
                case.assertEqual(it.things[-1], 4, it.things)

            @it.should('do this not that')
            def test(case):
                case.assertEqual(it.things[-1], 3, it.things[:])

        #
        # A layer may have any number of sub-layers.
        #
        with it.having('a different precondition'):

            #
            # A layer defined with ``having`` can make use of
            # layers defined elsewhere. An external layer
            # pulled in with ``it.uses`` becomes a parent
            # of the current layer (though it doesn't actually
            # get injected into the layer's MRO).
            #
            it.uses(SomeLayer)

            @it.has_setup
            def setup():
                it.things.append(99)

            @it.has_teardown
            def teardown():
                it.things.pop()

            #
            # Layers can define setup and teardown methods that wrap
            # each test case, as well, corresponding to TestCase.setUp
            # and TestCase.tearDown.
            #
            @it.has_test_setup
            def test_setup(case):
                it.is_funny = True
                case.is_funny = True

            @it.has_test_teardown
            def test_teardown(case):
                delattr(it, 'is_funny')
                delattr(case, 'is_funny')

            @it.should('do something else')
            def test(case):
                assert it.things[-1] == 99
                assert it.is_funny
                assert case.is_funny

            @it.should('have another test')
            def test(case):
                assert it.is_funny
                assert case.is_funny

            @it.should('have access to an external fixture')
            def test(case):
                assert it.somelayer

            with it.having('a case inside the external fixture'):
                @it.should('still have access to that fixture')
                def test(case):
                    assert it.somelayer

#
# To convert the layer definitions into test cases, you have to call
# `createTests` and pass in the module globals, so that the test cases
# and layer objects can be inserted into the module.
#
it.createTests(globals())


#
# Such tests and normal tests can coexist in the same modules.
#
class NormalTest(unittest.TestCase):

    def test(self):
        pass

########NEW FILE########
__FILENAME__ = test_attrib_plugin
from nose2.tests._common import FunctionalTestCase


class TestAttribPlugin(FunctionalTestCase):

    def test_simple_true(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            '--plugin=nose2.plugins.attrib',
            '-A',
            'a')
        self.assertTestRunOutputMatches(proc, stderr='Ran 4 tests')
        self.assertTestRunOutputMatches(proc, stderr='test_params_method')
        self.assertTestRunOutputMatches(proc, stderr='test_func')

    def test_simple_false(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            '--plugin=nose2.plugins.attrib',
            '-A',
            '!a')
        self.assertTestRunOutputMatches(proc, stderr='Ran 21 tests')

    def test_simple_value(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            '--plugin=nose2.plugins.attrib',
            '-A',
            'b=2')
        self.assertTestRunOutputMatches(proc, stderr='Ran 2 tests')

    def test_list_value(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            '--plugin=nose2.plugins.attrib',
            '-A',
            'tags=func')
        self.assertTestRunOutputMatches(proc, stderr='Ran 8 tests')
        self.assertTestRunOutputMatches(proc, stderr='test_params_func')
        self.assertTestRunOutputMatches(proc, stderr='test_func')
        self.assertTestRunOutputMatches(proc, stderr='test_gen')

    def test_list_value_negation(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            '--plugin=nose2.plugins.attrib',
            '-A',
            '!tags=func')
        self.assertTestRunOutputMatches(proc, stderr='Ran 8 tests')
        self.assertTestRunOutputMatches(proc, stderr='test_gen_method')
        self.assertTestRunOutputMatches(proc, stderr='test_params_method')
        self.assertTestRunOutputMatches(proc, stderr='test_ok')
        self.assertTestRunOutputMatches(proc, stderr='test_failed')
        self.assertTestRunOutputMatches(proc, stderr='test_skippy')
        self.assertTestRunOutputMatches(proc, stderr='test_typeerr')

    def test_eval_expr(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            '--plugin=nose2.plugins.attrib',
            '-E',
            'a == b and a')
        self.assertTestRunOutputMatches(proc, stderr='Ran 1 test')
        self.assertTestRunOutputMatches(proc, stderr='skippy')

########NEW FILE########
__FILENAME__ = test_collect_plugin
import re

from nose2.tests._common import FunctionalTestCase


class CollectOnlyFunctionalTest(FunctionalTestCase):

    def test_collect_tests_in_package(self):
        self.assertTestRunOutputMatches(
            self.runIn('scenario/tests_in_package', '-v', '--collect-only',
                       '--plugin=nose2.plugins.collect'),
            stderr=EXPECT_LAYOUT1)


# expectations
EXPECT_LAYOUT1 = re.compile("""\
Ran 25 tests in \d.\d+s

OK""")

########NEW FILE########
__FILENAME__ = test_coverage
import os.path

from nose2.tests._common import FunctionalTestCase


class TestCoverage(FunctionalTestCase):
    def test_run(self):
        proc = self.runIn(
            'scenario/test_with_module',
            '-v',
            '--with-coverage',
            '--coverage=lib/'
        )
        STATS = '           8      5    38%'

        stdout, stderr = proc.communicate()
        self.assertTestRunOutputMatches(
            proc,
            stderr=os.path.join('lib', 'mod1').replace('\\', r'\\') + STATS)
        self.assertTestRunOutputMatches(
            proc,
            stderr='TOTAL   ' + STATS)

########NEW FILE########
__FILENAME__ = test_discovery_loader
from nose2.tests._common import FunctionalTestCase, TestCase, support_file
from nose2 import events, loader, session
from nose2.plugins.loader.discovery import DiscoveryLoader


class Watcher(events.Plugin):

    def __init__(self):
        self.called = []

    def loadTestsFromModule(self, event):
        self.called.append(event)


class DiscoveryFunctionalTest(FunctionalTestCase):

    def setUp(self):
        self.session = session.Session()
        self.plug = DiscoveryLoader(session=self.session)
        self.loader = loader.PluggableTestLoader(self.session)
        self.watcher = Watcher(session=self.session)
        self.watcher.register()

    def test_can_discover_test_modules_in_packages(self):
        self.session.startDir = support_file('scenario/tests_in_package')
        event = events.LoadFromNamesEvent(self.loader, [], None)
        result = self.session.hooks.loadTestsFromNames(event)
        assert isinstance(result, self.loader.suiteClass)
        self.assertEqual(len(result._tests), 1)
        self.assertEqual(len(self.watcher.called), 1)
        self.assertEqual(self.watcher.called[0].module.__name__,
                         'pkg1.test.test_things')

    def test_discovery_supports_code_in_lib_dir(self):
        self.session.startDir = support_file('scenario/package_in_lib')
        event = events.LoadFromNamesEvent(self.loader, [], None)
        result = self.session.hooks.loadTestsFromNames(event)
        assert isinstance(result, self.loader.suiteClass)
        self.assertEqual(len(result._tests), 1)
        self.assertEqual(len(self.watcher.called), 1)
        self.assertEqual(self.watcher.called[0].module.__name__, 'tests')

    def test_match_path_event_can_prevent_discovery(self):
        class NoTestsForYou(events.Plugin):

            def matchPath(self, event):
                event.handled = True
                return False
        mp = NoTestsForYou(session=self.session)
        mp.register()
        self.session.startDir = support_file('scenario/tests_in_package')
        event = events.LoadFromNamesEvent(self.loader, [], None)
        result = self.session.hooks.loadTestsFromNames(event)
        assert isinstance(result, self.loader.suiteClass)
        self.assertEqual(len(result._tests), 0)
        self.assertEqual(len(self.watcher.called), 0)

    def test_handle_file_event_can_add_tests(self):
        class TextTest(TestCase):

            def test(self):
                pass

        class TestsInText(events.Plugin):

            def handleFile(self, event):
                if event.path.endswith('.txt'):
                    event.extraTests.append(TextTest('test'))
        mp = TestsInText(session=self.session)
        mp.register()
        self.session.startDir = support_file('scenario/tests_in_package')
        event = events.LoadFromNamesEvent(self.loader, [], None)
        result = self.session.hooks.loadTestsFromNames(event)
        assert isinstance(result, self.loader.suiteClass)
        self.assertEqual(len(result._tests), 2)
        self.assertEqual(len(self.watcher.called), 1)

########NEW FILE########
__FILENAME__ = test_dundertest_plugin
from nose2.tests._common import FunctionalTestCase


class TestDunderTestPlugin(FunctionalTestCase):
    def test_dunder(self):
        proc = self.runIn(
            'scenario/dundertest_attribute',
            '-v')
        self.assertTestRunOutputMatches(proc, stderr='Ran 0 tests')

########NEW FILE########
__FILENAME__ = test_eggdiscovery_loader
import sys
from nose2.tests._common import FunctionalTestCase, support_file
import nose2.plugins.loader.eggdiscovery #@UnusedImport This is not very elegant, but it allows eggdiscovery to be found in Travis (or when run with PYTHONPATH=.)

try:
    import pkg_resources

except ImportError:
    pkg_resources = None

else:
    class EggDiscoveryFunctionalTest(FunctionalTestCase):
        def setUp(self):
            for m in [m for m in sys.modules if m.startswith('pkgegg')]:
                del sys.modules[m]
            self.egg_path = support_file('scenario/tests_in_zipped_eggs/pkgegg-0.0.0-py2.7.egg')
            sys.path.append(self.egg_path)
    
        def tearDown(self):
            if self.egg_path in sys.path:
                sys.path.remove(self.egg_path)
            for m in [m for m in sys.modules if m.startswith('pkgegg')]:
                del sys.modules[m]
        
        def test_non_egg_discoverer_does_not_fail_when_looking_in_egg(self):
            proc = self.runIn(
                'scenario/tests_in_zipped_eggs',
                '-v',
                'pkgegg')
            self.assertTestRunOutputMatches(proc, stderr='Ran 0 tests in')
        
        def test_can_discover_test_modules_in_zipped_eggs(self):
            proc = self.runIn(
                'scenario/tests_in_zipped_eggs', 
                '-v',
                '--plugin=nose2.plugins.loader.eggdiscovery',
                'pkgegg')
            self.assertTestRunOutputMatches(proc, stderr='FAILED \(failures=5, errors=1, skipped=1\)')
    
        def test_eggdiscovery_failure_does_not_exist(self):
            proc = self.runIn(
                'scenario', 
                '-v',
                '--plugin=nose2.plugins.loader.eggdiscovery',
                '--exclude-plugin=nose2.plugins.loader.discovery',
                '-s',
                'tests_in_zipped_eggs_BAD')
            self.assertTestRunOutputMatches(proc, stderr='tests_in_zipped_eggs_BAD does not exist')
    

########NEW FILE########
__FILENAME__ = test_junitxml_plugin
import os

from nose2.tests._common import FunctionalTestCase
from nose2.tests._common import TestCase
from nose2.tests._common import support_file


class JunitXmlPluginFunctionalTest(FunctionalTestCase, TestCase):
    _RUN_IN_TEMP = True

    def run_with_junitxml_loaded(self, scenario, *args):
        work_dir = os.getcwd()
        test_dir = support_file(*scenario)
        junit_report = os.path.join(work_dir, 'nose2-junit.xml')

        proc = self.runIn(work_dir,
                          '-s%s' % test_dir,
                          '--plugin=nose2.plugins.junitxml',
                          '-v',
                          *args)
        return junit_report, proc

    def test_invocation_by_double_dash_option(self):
        junit_report, proc = self.run_with_junitxml_loaded(
            ('scenario', 'junitxml', 'happyday'),
            '--junit-xml')

        self.assertTestRunOutputMatches(
            proc, stderr='test \(test_junitxml_happyday.Test\) ... ok')
        self.assertTestRunOutputMatches(
            proc, stderr='Ran 1 test')
        self.assertEqual(proc.poll(), 0)

        self.assertTrue(os.path.isfile(junit_report),
                        "junitxml report wasn't found in working directory. "
                        "Searched for " + junit_report)

    def test_invocation_by_single_dash_option(self):
        junit_report, proc = self.run_with_junitxml_loaded(
            ('scenario', 'junitxml', 'happyday'),
            '-X')

        self.assertTestRunOutputMatches(
            proc, stderr='test \(test_junitxml_happyday.Test\) ... ok')
        self.assertTestRunOutputMatches(
            proc, stderr='Ran 1 test')
        self.assertEqual(proc.poll(), 0)

        self.assertTrue(os.path.isfile(junit_report),
                        "junitxml report wasn't found in working directory. "
                        "Searched for " + junit_report)

    def test_no_report_written_if_loaded_but_not_invoked(self):
        junit_report, proc = self.run_with_junitxml_loaded(
            ('scenario', 'junitxml', 'happyday'))

        self.assertTestRunOutputMatches(
            proc, stderr='test \(test_junitxml_happyday.Test\) ... ok')
        self.assertTestRunOutputMatches(
            proc, stderr='Ran 1 test')
        self.assertEqual(proc.poll(), 0)

        self.assertFalse(os.path.isfile(junit_report),
                         "junitxml report was found in working directory. "
                         "Report file: " + junit_report)

    def test_report_location_should_be_resilent_to_chdir_in_tests(self):
        junit_report, proc = self.run_with_junitxml_loaded(
            ('scenario', 'junitxml', 'chdir'), '--junit-xml')

        self.assertTestRunOutputMatches(
            proc,
            stderr='test_chdir \(test_junitxml_chdir.Test\) \.* ok')
        self.assertTestRunOutputMatches(
            proc, stderr='Ran 1 test')
        self.assertEqual(proc.poll(), 0)

        self.assertTrue(os.path.isfile(junit_report),
                        "junitxml report wasn't found in working directory. "
                        "Searched for " + junit_report)

########NEW FILE########
__FILENAME__ = test_layers_plugin
from nose2.tests._common import FunctionalTestCase


class TestLayers(FunctionalTestCase):

    def test_runs_layer_fixtures(self):
        proc = self.runIn(
            'scenario/layers',
            '-v',
            '--plugin=nose2.plugins.layers')
        self.assertTestRunOutputMatches(proc, stderr='Ran 8 tests')
        self.assertEqual(proc.poll(), 0)

    def test_scenario_fails_without_plugin(self):
        proc = self.runIn(
            'scenario/layers',
            '-v')
        self.assertTestRunOutputMatches(proc, stderr='Ran 8 tests')
        self.assertTestRunOutputMatches(proc, stderr=r'FAILED \(failures=7\)')
        self.assertEqual(proc.poll(), 1)

    def test_methods_run_once_per_class(self):
        proc = self.runIn(
            'scenario/layers_with_inheritance',
            '-v',
            '--plugin=nose2.plugins.layers')

        expected = ('^'
                    'L1 setUp\n'
                    'L2 setUp\n'

                    'L1 testSetUp\n'
                    'L2 testSetUp\n'
                    'Run test1\n'
                    'L2 testTearDown\n'
                    'L1 testTearDown\n'

                    'L1 testSetUp\n'
                    'L2 testSetUp\n'
                    'Run test2\n'
                    'L2 testTearDown\n'
                    'L1 testTearDown\n'

                    'L1 tearDown\n'
                    '$')
        self.assertTestRunOutputMatches(proc, stdout=expected)
        self.assertEqual(proc.poll(), 0)

    def test_layer_reporter_output(self):
        proc = self.runIn(
            'scenario/layers',
            '-v',
            '--plugin=nose2.plugins.layers',
            '--layer-reporter')
        expect = r"""test \(test_layers.NoLayer\) ... ok
Base
  test \(test_layers.Outer\) ... ok
  LayerD
    test \(test_layers.InnerD\) ... ok
  LayerA
    test \(test_layers.InnerA\) ... ok
  LayerB
    LayerB_1
      test \(test_layers.InnerB_1\) ... ok
    LayerC
      test \(test_layers.InnerC\) ... ok
      test2 \(test_layers.InnerC\) ... ok
    LayerA_1
      test \(test_layers.InnerA_1\) ... ok""".split("\n")
        self.assertTestRunOutputMatches(proc, stderr='Ran 8 tests')
        for line in expect:
            self.assertTestRunOutputMatches(proc, stderr=line)
        self.assertEqual(proc.poll(), 0)

    def test_layer_reporter_error_output(self):
        proc = self.runIn(
            'scenario/layers_with_errors',
            '--plugin=nose2.plugins.layers',
            '--layer-reporter')
        expect = [
            r'ERROR: fixture with a value test_err '
            '\(test_layers_with_errors.Test\)',
            'ERROR: A test scenario with errors should check for an attribute '
            'that does not exist and raise an error',
            r'FAIL: fixture with a value test_fail '
            '\(test_layers_with_errors.Test\)',
            'FAIL: A test scenario with errors should check that value == 2 '
            'and fail']
        for line in expect:
            self.assertTestRunOutputMatches(proc, stderr=line)
        self.assertEqual(proc.poll(), 1)

    def test_layers_and_attributes(self):
        proc = self.runIn(
            'scenario/layers_and_attributes',
            '-v',
            '--plugin=nose2.plugins.attrib',
            '--plugin=nose2.plugins.layers',
            '-A',
            'a=1')
        self.assertTestRunOutputMatches(proc, stderr='Ran 1 test')
        self.assertEqual(proc.poll(), 0)

########NEW FILE########
__FILENAME__ = test_loading
"""
pkg1
pkg1.test
pkg1.test.test_things
pkg1.test.test_things.test_func
pkg1.test.test_things.test_gen
pkg1.test.test_things.test_gen:3
pkg1.test.test_things.SomeTests
pkg1.test.test_things.SomeTests.test_ok

# generator method
# generator method index

# param func
# param func index
# param method
# param method index

"""
from nose2.tests._common import FunctionalTestCase, support_file


class TestLoadTestsFromPackage(FunctionalTestCase):

    def test_module_name(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            'pkg1.test.test_things')
        self.assertTestRunOutputMatches(proc, stderr='Ran 25 tests')
        self.assertEqual(proc.poll(), 1)

    def test_package_name(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            'pkg1')
        self.assertTestRunOutputMatches(proc, stderr='Ran 25 tests')
        self.assertEqual(proc.poll(), 1)

    def test_module_name_with_start_dir(self):
        proc = self.runIn(
            '.', '-v', '-s', support_file('scenario/tests_in_package'),
            'pkg1.test.test_things')

        self.assertTestRunOutputMatches(proc, stderr='Ran 25 tests')
        self.assertEqual(proc.poll(), 1)

    def test_package_name_with_start_dir(self):
        proc = self.runIn(
            '.', '-v', '-s', support_file('scenario/tests_in_package'), 'pkg1')
        self.assertTestRunOutputMatches(proc, stderr='Ran 25 tests')
        self.assertEqual(proc.poll(), 1)

    def test_function_name(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            'pkg1.test.test_things.test_func')
        self.assertTestRunOutputMatches(
            proc, stderr='test_func')
        self.assertTestRunOutputMatches(
            proc, stderr='Ran 1 test')
        self.assertTestRunOutputMatches(
            proc, stderr='OK')
        self.assertEqual(proc.poll(), 0)

    def test_generator_function_name(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            'pkg1.test.test_things.test_gen')
        self.assertTestRunOutputMatches(proc, stderr='test_gen')
        self.assertTestRunOutputMatches(proc, stderr='Ran 5 tests')
        self.assertEqual(proc.poll(), 0)

    def test_generator_function_index(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            'pkg1.test.test_things.test_gen:3')
        self.assertTestRunOutputMatches(proc, stderr='test_gen')
        self.assertTestRunOutputMatches(proc, stderr='Ran 1 test')
        self.assertEqual(proc.poll(), 0)

    def test_generator_function_index_1_based(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            'pkg1.test.test_things.test_gen:1')

        self.assertTestRunOutputMatches(proc, stderr='test_gen')
        self.assertTestRunOutputMatches(proc, stderr='Ran 1 test')
        self.assertTestRunOutputMatches(proc, stderr='OK')
        self.assertEqual(proc.poll(), 0)

    def test_testcase_name(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            'pkg1.test.test_things.SomeTests')
        self.assertTestRunOutputMatches(proc, stderr='SomeTests')
        self.assertTestRunOutputMatches(proc, stderr='Ran 8 tests')
        self.assertEqual(proc.poll(), 1)

    def test_testcase_method(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            'pkg1.test.test_things.SomeTests.test_ok')
        self.assertTestRunOutputMatches(proc, stderr='SomeTests')
        self.assertTestRunOutputMatches(proc, stderr='Ran 1 test')
        self.assertTestRunOutputMatches(proc, stderr='OK')
        self.assertEqual(proc.poll(), 0)

    def test_generator_method(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            'pkg1.test.test_things.SomeTests.test_gen_method')
        self.assertTestRunOutputMatches(proc, stderr='test_gen_method')
        self.assertTestRunOutputMatches(proc, stderr='Ran 2 tests')
        self.assertEqual(proc.poll(), 1)

    def test_generator_method_index(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            'pkg1.test.test_things.SomeTests.test_gen_method:1')
        self.assertTestRunOutputMatches(proc, stderr='test_gen_method')
        self.assertTestRunOutputMatches(proc, stderr='Ran 1 test')
        self.assertTestRunOutputMatches(proc, stderr='OK')
        self.assertEqual(proc.poll(), 0)

    def test_parameterized_method(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            'pkg1.test.test_things.SomeTests.test_params_method')
        self.assertTestRunOutputMatches(proc, stderr='test_params_method')
        self.assertTestRunOutputMatches(proc, stderr='Ran 2 tests')
        self.assertEqual(proc.poll(), 1)

    def test_parameterized_method_index(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            'pkg1.test.test_things.SomeTests.test_params_method:1')
        self.assertTestRunOutputMatches(proc, stderr='test_params_method')
        self.assertTestRunOutputMatches(proc, stderr='Ran 1 test')
        self.assertTestRunOutputMatches(proc, stderr='OK')
        self.assertEqual(proc.poll(), 0)

    def test_parameterized_func(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            'pkg1.test.test_things.test_params_func')
        self.assertTestRunOutputMatches(proc, stderr='test_params_func')
        self.assertTestRunOutputMatches(proc, stderr='Ran 2 tests')
        self.assertEqual(proc.poll(), 1)

    def test_parameterized_func_index(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            'pkg1.test.test_things.test_params_func:1')
        self.assertTestRunOutputMatches(proc, stderr='test_params_func')
        self.assertTestRunOutputMatches(proc, stderr='Ran 1 test')
        self.assertTestRunOutputMatches(proc, stderr='OK')
        self.assertEqual(proc.poll(), 0)


class TestLoadTestsOutsideOfPackage(FunctionalTestCase):

    def test_module_name(self):
        proc = self.runIn(
            'scenario/package_in_lib',
            '-v',
            'tests')
        self.assertTestRunOutputMatches(proc, stderr='Ran 3 tests')
        self.assertEqual(proc.poll(), 1)

    def test_function_name(self):
        proc = self.runIn(
            'scenario/package_in_lib',
            '-v',
            'tests.test')
        self.assertTestRunOutputMatches(proc, stderr='test')
        self.assertTestRunOutputMatches(proc, stderr='Ran 1 test')
        self.assertTestRunOutputMatches(proc, stderr='OK')
        self.assertEqual(proc.poll(), 0)

    def test_module_name_with_start_dir(self):
        proc = self.runIn(
            '.', '-v', '-s', support_file('scenario/package_in_lib'), 'tests')
        self.assertTestRunOutputMatches(proc, stderr='Ran 3 tests')
        self.assertEqual(proc.poll(), 1)


class TestLoadingErrors(FunctionalTestCase):

    def test_import_error_module(self):
        proc = self.runIn(
            'scenario/module_import_err',
            '-v',
            'test_import_err')
        self.assertTestRunOutputMatches(proc, stderr='Ran 1 test')
        self.assertEqual(proc.poll(), 1)

    def test_import_error_func(self):
        proc = self.runIn(
            'scenario/module_import_err',
            '-v',
            'test_import_err.test')
        self.assertTestRunOutputMatches(proc, stderr='Ran 1 test')
        self.assertEqual(proc.poll(), 1)

    def test_import_error_testcase(self):
        proc = self.runIn(
            'scenario/module_import_err',
            '-v',
            'test_import_err.Test')
        self.assertTestRunOutputMatches(proc, stderr='Ran 1 test')
        self.assertEqual(proc.poll(), 1)

    def test_import_error_testcase_method(self):
        proc = self.runIn(
            'scenario/module_import_err',
            '-v',
            'test_import_err.Test.test')
        self.assertTestRunOutputMatches(proc, stderr='Ran 1 test')
        self.assertEqual(proc.poll(), 1)


class TestTestClassLoading(FunctionalTestCase):

    def test_load_testclass_by_name(self):
        proc = self.runIn(
            'scenario/test_classes',
            '-v',
            'test_classes.Test')
        self.assertTestRunOutputMatches(proc, stderr='Ran 8 tests')
        self.assertEqual(proc.poll(), 0)

    def test_load_testclass_method_by_name(self):
        proc = self.runIn(
            'scenario/test_classes',
            '-v',
            'test_classes.Test.test')
        self.assertTestRunOutputMatches(proc, stderr='Ran 1 test')
        self.assertEqual(proc.poll(), 0)

    def test_load_testclass_generator_method_by_name(self):
        proc = self.runIn(
            'scenario/test_classes',
            '-v',
            'test_classes.Test.test_gen')
        self.assertTestRunOutputMatches(proc, stderr='Ran 5 tests')
        self.assertEqual(proc.poll(), 0)

    def test_load_testclass_params_method_by_name(self):
        proc = self.runIn(
            'scenario/test_classes',
            '-v',
            'test_classes.Test.test_params')
        self.assertTestRunOutputMatches(proc, stderr='Ran 2 tests')
        self.assertEqual(proc.poll(), 0)

    def test_class_level_fixtures_supported(self):
        proc = self.runIn(
            'scenario/test_classes',
            '-v',
            'test_fixtures')
        self.assertTestRunOutputMatches(proc, stderr='Ran 5 tests')
        self.assertEqual(proc.poll(), 0)

    def test_error_in_test_class(self):
        proc = self.runIn(
            'scenario/test_class_fail',
            '-v',
            'test_class_fail')
        self.assertTestRunOutputMatches(proc, stderr='nose2.loader.LoadTestsFailure')
        self.assertTestRunOutputMatches(proc, stderr='Ran 1 test')
        self.assertTestRunOutputMatches(proc, stderr='FAILED')
        self.assertEqual(proc.poll(), 1)
        
########NEW FILE########
__FILENAME__ = test_loadtests_plugin
from nose2.tests._common import FunctionalTestCase


class TestLoadTestsPlugin(FunctionalTestCase):

    def test_simple(self):
        proc = self.runIn(
            'scenario/load_tests',
            '-v',
            '--plugin=nose2.plugins.loader.loadtests')
        self.assertTestRunOutputMatches(proc, stderr='Ran 6 tests')
        self.assertTestRunOutputMatches(proc, stderr='test_a..test_simple')
        self.assertTestRunOutputMatches(proc, stderr='test_b..test_simple')
        self.assertTestRunOutputMatches(proc, stderr='test_c..test_simple')
        self.assertTestRunOutputMatches(proc, stderr='test_d..test_simple')
        self.assertTestRunOutputMatches(proc, stderr='test_a..test_filter')
        self.assertTestRunOutputMatches(proc, stderr='test_c..test_filter')
        self.assertEqual(proc.poll(), 0)

    def test_package(self):
        proc = self.runIn(
            'scenario/load_tests_pkg',
            '-v',
            '-c='
            'nose2/tests/functional/support/scenario/load_tests_pkg/unittest.cfg',
            '--plugin=nose2.plugins.loader.loadtests')
        self.assertTestRunOutputMatches(proc, stderr='Ran 2 tests')
        self.assertTestRunOutputMatches(
            proc, stderr='test..ltpkg.tests.test_find_these.Test')
        self.assertTestRunOutputMatches(
            proc, stderr='test..ltpkg2.tests.Test')

########NEW FILE########
__FILENAME__ = test_logcapture_plugin
import re

from nose2.tests._common import FunctionalTestCase


class LogCaptureFunctionalTest(FunctionalTestCase):

    def test_package_in_lib(self):
        match = re.compile('>> begin captured logging <<')
        self.assertTestRunOutputMatches(
            self.runIn('scenario/package_in_lib', '--log-capture'),
            stderr=match)

########NEW FILE########
__FILENAME__ = test_main
from nose2.tests._common import FunctionalTestCase


class TestPluggableTestProgram(FunctionalTestCase):

    def test_run_in_empty_dir_succeeds(self):
        proc = self.runIn('scenario/no_tests')
        stdout, stderr = proc.communicate()
        self.assertEqual(proc.poll(), 0, stderr)

    def test_extra_hooks(self):
        class Check(object):
            ran = False

            def startTestRun(self, event):
                self.ran = True

        check = Check()
        proc = self.runIn('scenario/no_tests',
                          extraHooks=[('startTestRun', check)])
        stdout, stderr = proc.communicate()
        self.assertEqual(proc.poll(), 0, stderr)
        assert check.ran, "Extra hook did not execute"

    def test_run_in_module_from_its_main(self):
        proc = self.runModuleAsMain('scenario/one_test/tests.py')
        self.assertTestRunOutputMatches(proc, stderr='Ran 1 test')
        self.assertEqual(proc.poll(), 0)
########NEW FILE########
__FILENAME__ = test_mp_plugin
import sys

from nose2 import session
from nose2.compat import unittest
from nose2.plugins.mp import MultiProcess, procserver
from nose2.plugins import buffer
from nose2.plugins.loader import discovery, testcases
from nose2.tests._common import FunctionalTestCase, support_file, Conn
import multiprocessing
import threading
import time
from multiprocessing import connection


class TestMpPlugin(FunctionalTestCase):

    def setUp(self):
        super(TestMpPlugin, self).setUp()
        self.session = session.Session()
        self.plugin = MultiProcess(session=self.session)

    def test_flatten_without_fixtures(self):
        sys.path.append(support_file('scenario/slow'))
        import test_slow as mod

        suite = unittest.TestSuite()
        suite.addTest(mod.TestSlow('test_ok'))
        suite.addTest(mod.TestSlow('test_fail'))
        suite.addTest(mod.TestSlow('test_err'))

        flat = list(self.plugin._flatten(suite))
        self.assertEqual(len(flat), 3)

    def test_flatten_nested_suites(self):
        sys.path.append(support_file('scenario/slow'))
        import test_slow as mod

        suite = unittest.TestSuite()
        suite.addTest(mod.TestSlow('test_ok'))
        suite.addTest(mod.TestSlow('test_fail'))
        suite.addTest(mod.TestSlow('test_err'))

        suite2 = unittest.TestSuite()
        suite2.addTest(suite)

        flat = list(self.plugin._flatten(suite2))
        self.assertEqual(len(flat), 3)

    def test_flatten_respects_module_fixtures(self):
        sys.path.append(support_file('scenario/module_fixtures'))
        import test_mf_testcase as mod

        suite = unittest.TestSuite()
        suite.addTest(mod.Test('test_1'))
        suite.addTest(mod.Test('test_2'))

        flat = list(self.plugin._flatten(suite))
        self.assertEqual(flat, ['test_mf_testcase'])

    def test_flatten_respects_class_fixtures(self):
        sys.path.append(support_file('scenario/class_fixtures'))
        import test_cf_testcase as mod

        suite = unittest.TestSuite()
        suite.addTest(mod.Test('test_1'))
        suite.addTest(mod.Test('test_2'))
        suite.addTest(mod.Test2('test_1'))
        suite.addTest(mod.Test2('test_2'))
        suite.addTest(mod.Test3('test_3'))

        flat = list(self.plugin._flatten(suite))
        self.assertEqual(flat, ['test_cf_testcase.Test2.test_1',
                                'test_cf_testcase.Test2.test_2',
                                'test_cf_testcase.Test',
                                'test_cf_testcase.Test3',
                                ])

    def test_conn_prep(self):
        self.plugin.bind_host = None
        (parent_conn, child_conn) = self.plugin._prepConns()
        (parent_pipe, child_pipe) = multiprocessing.Pipe()
        self.assertIsInstance(parent_conn, type(parent_pipe))
        self.assertIsInstance(child_conn, type(child_pipe))

        self.plugin.bind_host = "127.0.0.1"
        self.plugin.bind_port = 0
        (parent_conn, child_conn) = self.plugin._prepConns()
        self.assertIsInstance(parent_conn, connection.Listener)
        self.assertIsInstance(child_conn, tuple)
        self.assertEqual(parent_conn.address, child_conn[:2])

    def test_conn_accept(self):
        (parent_conn, child_conn) = multiprocessing.Pipe()
        self.assertEqual(self.plugin._acceptConns(parent_conn), parent_conn)

        listener = connection.Listener(('127.0.0.1', 0))
        with self.assertRaises(RuntimeError):
            self.plugin._acceptConns(listener)

        def fake_client(address):
            client = connection.Client(address)
            time.sleep(10)
            client.close()

        t = threading.Thread(target=fake_client, args=(listener.address,))
        t.start()
        conn = self.plugin._acceptConns(listener)
        self.assertTrue(hasattr(conn, "send"))
        self.assertTrue(hasattr(conn, "recv"))


class TestProcserver(FunctionalTestCase):

    def setUp(self):
        super(TestProcserver, self).setUp()
        self.session = session.Session()

    def test_dispatch_tests_receive_events(self):
        ssn = {
            'config': self.session.config,
            'verbosity': 1,
            'startDir': support_file('scenario/tests_in_package'),
            'topLevelDir': support_file('scenario/tests_in_package'),
            'logLevel': 100,
            'pluginClasses': [discovery.DiscoveryLoader,
                              testcases.TestCaseLoader,
                              buffer.OutputBufferPlugin]

        }
        conn = Conn(['pkg1.test.test_things.SomeTests.test_ok',
                     'pkg1.test.test_things.SomeTests.test_failed'])
        procserver(ssn, conn)

        # check conn calls
        expect = [('pkg1.test.test_things.SomeTests.test_ok',
                   [('startTest', {}),
                    ('setTestOutcome', {'outcome': 'passed'}),
                    ('testOutcome', {'outcome': 'passed'}),
                    ('stopTest', {})]
                   ),
                  ('pkg1.test.test_things.SomeTests.test_failed',
                   [('startTest', {}),
                    ('setTestOutcome', {
                     'outcome': 'failed',
                     'expected': False,
                     'metadata': {'stdout': 'Hello stdout\n'}}),
                    ('testOutcome', {
                     'outcome': 'failed',
                     'expected': False,
                     'metadata': {'stdout': 'Hello stdout\n'}}),
                    ('stopTest', {})]
                   ),
                  ]
        for val in conn.sent:
            if val is None:
                break
            test, events = val
            exp_test, exp_events = expect.pop(0)
            self.assertEqual(test, exp_test)
            for method, event in events:
                exp_meth, exp_attr = exp_events.pop(0)
                self.assertEqual(method, exp_meth)
                for attr, val in exp_attr.items():
                    self.assertEqual(getattr(event, attr), val)


class MPPluginTestRuns(FunctionalTestCase):

    def test_tests_in_package(self):
        proc = self.runIn(
            'scenario/tests_in_package',
            '-v',
            '--plugin=nose2.plugins.mp',
            '-N=2')
        self.assertTestRunOutputMatches(proc, stderr='Ran 25 tests')
        self.assertEqual(proc.poll(), 1)

    def test_package_in_lib(self):
        proc = self.runIn(
            'scenario/package_in_lib',
            '-v',
            '--plugin=nose2.plugins.mp',
            '-N=2')
        self.assertTestRunOutputMatches(proc, stderr='Ran 3 tests')
        self.assertEqual(proc.poll(), 1)

    def test_module_fixtures(self):
        proc = self.runIn(
            'scenario/module_fixtures',
            '-v',
            '--plugin=nose2.plugins.mp',
            '-N=2')
        self.assertTestRunOutputMatches(proc, stderr='Ran 5 tests')
        self.assertEqual(proc.poll(), 0)

    def test_class_fixtures(self):
        proc = self.runIn(
            'scenario/class_fixtures',
            '-v',
            '--plugin=nose2.plugins.mp',
            '-N=2')
        self.assertTestRunOutputMatches(proc, stderr='Ran 7 tests')
        self.assertEqual(proc.poll(), 0)

    def test_large_number_of_tests_stresstest(self):
        proc = self.runIn(
            'scenario/many_tests',
            '-v',
            '--plugin=nose2.plugins.mp',
            '--plugin=nose2.plugins.loader.generators',
            '-N=1')
        self.assertTestRunOutputMatches(proc, stderr='Ran 600 tests')
        self.assertEqual(proc.poll(), 0)

    def test_socket_stresstest(self):
        proc = self.runIn(
            'scenario/many_tests_socket',
            '-v',
            '-c scenario/many_test_socket/nose2.cfg',
            '--plugin=nose2.plugins.mp',
            '--plugin=nose2.plugins.loader.generators',
            '-N=1')
        self.assertTestRunOutputMatches(proc, stderr='Ran 600 tests')
        self.assertEqual(proc.poll(), 0)


########NEW FILE########
__FILENAME__ = test_printhooks_plugin
import re

from nose2.tests._common import FunctionalTestCase


class TestPrintHooksPlugin(FunctionalTestCase):

    def test_invocation_by_double_dash_option(self):
        proc = self.runIn(
            'scenario/no_tests',
            '--plugin=nose2.plugins.printhooks',
            '--print-hooks')
        match = re.compile("\n"
                           "handleArgs: "
                           "CommandLineArgsEvent\(handled=False, args=")
        self.assertTestRunOutputMatches(proc, stderr=match)
        self.assertEqual(proc.poll(), 0)

    def test_invocation_by_single_dash_option(self):
        proc = self.runIn(
            'scenario/no_tests',
            '--plugin=nose2.plugins.printhooks',
            '-P')
        match = re.compile("\n"
                           "handleArgs: "
                           "CommandLineArgsEvent\(handled=False, args=")
        self.assertTestRunOutputMatches(proc, stderr=match)
        self.assertEqual(proc.poll(), 0)

    def test_nested_hooks_are_indented(self):
        proc = self.runIn(
            'scenario/no_tests',
            '--plugin=nose2.plugins.printhooks',
            '--print-hooks')
        match = re.compile("\n  handleFile: ")
        self.assertTestRunOutputMatches(proc, stderr=match)
        self.assertEqual(proc.poll(), 0)

########NEW FILE########
__FILENAME__ = test_session
import sys

from nose2 import session
from nose2.tests._common import support_file, FunctionalTestCase


class SessionFunctionalTests(FunctionalTestCase):

    def setUp(self):
        self.s = session.Session()
        self.s.loadConfigFiles(support_file('cfg', 'a.cfg'),
                               support_file('cfg', 'b.cfg'))
        sys.path.insert(0, support_file('lib'))

    def test_session_can_load_config_files(self):
        assert self.s.config.has_section('a')
        assert self.s.config.has_section('b')

    def test_session_holds_plugin_config(self):
        plug_config = self.s.get('a')
        assert plug_config

    def test_session_can_load_plugins_from_modules(self):
        self.s.loadPlugins()
        assert self.s.plugins
        plug = self.s.plugins[0]
        self.assertEqual(plug.a, 1)

########NEW FILE########
__FILENAME__ = test_such_dsl
from nose2.tests._common import FunctionalTestCase


class TestSuchDSL(FunctionalTestCase):
    def test_runs_example(self):
        proc = self.runIn(
            'such',
            '-v',
            '--plugin=nose2.plugins.layers',
            'test_such')
        self.assertTestRunOutputMatches(proc, stderr='Ran 9 tests')
        self.assertEqual(proc.poll(), 0, proc.stderr.getvalue())

    def test_load_top_level_by_name(self):
        proc = self.runIn(
            'such',
            '-v',
            '--plugin=nose2.plugins.layers',
            'test_such.A system with complex setup.should do something')
        self.assertTestRunOutputMatches(proc, stderr='Ran 1 test')
        self.assertEqual(proc.poll(), 0, proc.stderr.getvalue())

    def test_load_sublayer_test_by_name(self):
        proc = self.runIn(
            'such',
            '-v',
            '--plugin=nose2.plugins.layers',
            'test_such.having an expensive fixture.'
            'should do more things')
        self.assertTestRunOutputMatches(proc, stderr='Ran 1 test')
        self.assertEqual(proc.poll(), 0, proc.stderr.getvalue())

    def test_regression_tests_with_the_same_having_description_under_different_fixtures_in_the_same_module_should_be_run(
            self):
        proc = self.runIn(
            'such',
            '-v',
            '--plugin=nose2.plugins.layers',
            'test_regression_same_havings')
        self.assertTestRunOutputMatches(proc, stderr='Ran 2 test')
        self.assertEqual(proc.poll(), 0, proc.stderr.getvalue())

########NEW FILE########
__FILENAME__ = test_util
from nose2.tests._common import TestCase, support_file
from nose2 import util


class UtilTests(TestCase):

    def test_name_from_path(self):
        self.assertEqual(
            util.name_from_path(support_file('scenario/tests_in_package/pkg1/test/test_things.py')), 'pkg1.test.test_things')

########NEW FILE########
__FILENAME__ = test_attrib_plugin
import unittest

from nose2.plugins import attrib
from nose2 import events, session
from nose2.tests._common import TestCase


class TestAttribPlugin(TestCase):
    tags = ['unit']

    def setUp(self):
        class TC_1(TestCase):
            tags = ['a', 'b']

            def test_a(self):
                pass
            test_a.a = 1
            test_a.c = 0

            def test_b(self):
                pass
            test_b.b = 1
        self.TC_1 = TC_1
        self.session = session.Session()
        self.plugin = attrib.AttributeSelector(session=self.session)
        self.plugin.register()

    def test_validate_attribs_with_simple_values(self):
        assert self.plugin.validateAttrib(
            self.TC_1('test_a'), [[('a', '1')]])
        assert self.plugin.validateAttrib(
            self.TC_1('test_a'), [[('a', True)]])
        assert self.plugin.validateAttrib(
            self.TC_1('test_a'), [[('c', False)]])
        assert self.plugin.validateAttrib(
            self.TC_1('test_b'), [[('b', '1')]])
        assert not self.plugin.validateAttrib(
            self.TC_1('test_a'), [[('a', False)]])
        assert not self.plugin.validateAttrib(
            self.TC_1('test_a'), [[('c', True)]])
        assert not self.plugin.validateAttrib(
            self.TC_1('test_a'), [[('a', '2')]])
        assert not self.plugin.validateAttrib(
            self.TC_1('test_a'), [[('b', '1')]])

    def test_validate_attribs_with_callable(self):
        assert self.plugin.validateAttrib(
            self.TC_1('test_a'), [[('a', lambda key, test: True)]])
        assert not self.plugin.validateAttrib(
            self.TC_1('test_a'), [[('a', lambda key, test: False)]])

    def test_validate_attribs_against_list(self):
        assert self.plugin.validateAttrib(
            self.TC_1('test_a'), [[('tags', 'a')]])
        assert self.plugin.validateAttrib(
            self.TC_1('test_a'), [[('tags', 'b')]])
        assert not self.plugin.validateAttrib(
            self.TC_1('test_a'), [[('tags', 'c')]])

    def test_module_loaded_suite_filters_suite(self):
        self.plugin.attribs = ['a']
        suite = unittest.TestSuite()
        suite.addTest(self.TC_1('test_a'))
        suite.addTest(self.TC_1('test_b'))
        event = events.ModuleSuiteEvent(None, None, suite)
        self.session.hooks.moduleLoadedSuite(event)
        self.assertEqual(len(event.suite._tests), 1)
        self.assertEqual(event.suite._tests[0]._testMethodName, 'test_a')

########NEW FILE########
__FILENAME__ = test_buffer_plugin
import sys

import six

from nose2.plugins import buffer
from nose2 import events, result, session
from nose2.tests._common import TestCase


class TestBufferPlugin(TestCase):
    tags = ['unit']

    def setUp(self):
        self.session = session.Session()
        self.result = result.PluggableTestResult(self.session)
        self.plugin = buffer.OutputBufferPlugin(session=self.session)
        self.plugin.register()

        class Test(TestCase):

            def test_out(self):
                six.print_("hello")
                raise {}["oops"]

            def test_err(self):
                six.print_("goodbye", file=sys.stderr)
        self.case = Test

        class Watcher(events.Plugin):

            def __init__(self):
                self.events = []

            def testOutcome(self, event):
                self.events.append(event)
        self.watcher = Watcher(session=self.session)
        self.watcher.register()

    def test_captures_stdout(self):
        out = sys.stdout
        buf = six.StringIO()
        sys.stdout = buf
        try:
            test = self.case('test_out')
            test(self.result)
            assert "hello" not in buf.getvalue()
            assert "hello" in self.watcher.events[
                0].metadata['stdout'].getvalue()
        finally:
            sys.stdout = out

    def test_captures_stderr_when_configured(self):
        self.plugin.captureStderr = True
        err = sys.stderr
        buf = six.StringIO()
        sys.stderr = buf
        try:
            test = self.case('test_err')
            test(self.result)
            assert "goodbye" not in buf.getvalue()
            assert "goodbye" in self.watcher.events[
                0].metadata['stderr'].getvalue()
        finally:
            sys.stderr = err

    def test_decorates_outcome_detail(self):
        test = self.case('test_out')
        test(self.result)
        evt = events.OutcomeDetailEvent(self.watcher.events[0])
        self.session.hooks.outcomeDetail(evt)
        assert "hello" in "".join(evt.extraDetail)

########NEW FILE########
__FILENAME__ = test_collector
from nose2.tests._common import TestCase, RedirectStdStreams
from nose2 import collector
from textwrap import dedent
import re


class TestCollector(TestCase):
    _RUN_IN_TEMP = True
    tags = ['unit']

    def test_collector_completes_with_no_tests(self):
        with open("unittest.cfg", "w") as ut_file:
            ut_file.write(dedent("""
                [unittest]
                quiet = true
            """))
        test = collector.collector()
        with RedirectStdStreams() as redir:
            self.assertRaises(SystemExit, test.run, None)
        self.assertEqual("", redir.stdout.getvalue())
        self.assertTrue(re.match(r'\n-+\nRan 0 tests in \d.\d\d\ds\n\nOK\n',
                                 redir.stderr.getvalue()))

########NEW FILE########
__FILENAME__ = test_collect_plugin
from nose2.tests._common import FakeStartTestRunEvent, TestCase
from nose2.plugins import collect
from nose2 import session


class TestCollectOnly(TestCase):
    tags = ['unit']

    def setUp(self):
        self.session = session.Session()
        self.plugin = collect.CollectOnly(session=self.session)

    def test_startTestRun_sets_executeTests(self):
        event = FakeStartTestRunEvent()
        self.plugin.startTestRun(event)
        self.assertEqual(event.executeTests, self.plugin.collectTests)

########NEW FILE########
__FILENAME__ = test_config
from nose2 import config
from nose2.compat import unittest


class TestConfig(unittest.TestCase):

    def setUp(self):
        self.conf = config.Config([
            ('a', ' 1 '), ('b', '  x\n  y '), ('c', '0'),
            ('d', '123')])

    def test_as_int(self):
        self.assertEqual(self.conf.as_int('a'), 1)

    def test_as_str(self):
        self.assertEqual(self.conf.as_str('a'), '1')
        self.assertEqual(self.conf.as_str('b'), 'x\n  y')
        self.assertEqual(self.conf.as_str('missing', 'default'), 'default')

    def test_as_bool(self):
        self.assertEqual(self.conf.as_bool('a'), True)
        self.assertEqual(self.conf.as_bool('c'), False)

    def test_as_float(self):
        self.assertAlmostEqual(self.conf.as_float('a'), 1.0)

    def test_as_list(self):
        self.assertEqual(self.conf.as_list('b'), ['x', 'y'])
        self.assertEqual(self.conf.as_list('a'), ['1'])
        self.assertEqual(self.conf.as_list('d'), ['123'])

########NEW FILE########
__FILENAME__ = test_debugger_plugin
import logging

from nose2.tests._common import TestCase
from nose2.plugins import debugger
from nose2 import events, result, session


class NullHandler(logging.Handler):

    def emit(self, record):
        pass


class StubPdb(object):

    def __init__(self):
        self.called = False
        self.tb = None

    def post_mortem(self, tb):
        self.called = True
        self.tb = tb


class NoInteraction(events.Plugin):

    def beforeInteraction(self, event):
        event.handled = True
        return False


class TestDebugger(TestCase):
    tags = ['unit']

    def setUp(self):
        self.session = session.Session()
        self.plugin = debugger.Debugger(session=self.session)
        self.result = result.PluggableTestResult(self.session)

        class Test(TestCase):

            def test(self):
                pass

            def test_err(self):
                raise Exception("oops")

            def test_fail(self):
                assert False
        self.case = Test

        self.pdb = self.plugin.pdb
        self.plugin.pdb = StubPdb()

        self.plugin.register()

        super(TestCase, self).setUp()

    def tearDown(self):
        self.plugin.pdb = self.pdb
        super(TestCase, self).tearDown()

    def test_does_not_call_pdb_on_success(self):
        test = self.case('test')
        test(self.result)
        assert not self.plugin.pdb.called, "pdb was called on success"

    def test_does_call_pdb_on_error(self):
        test = self.case('test_err')
        test(self.result)
        assert self.plugin.pdb.called, "pdb was not called on error"

    def test_does_call_pdb_on_failure(self):
        test = self.case('test_fail')
        test(self.result)
        assert self.plugin.pdb.called, "pdb was not called on failure"

    def test_does_not_call_pdb_on_failure_if_config_set(self):
        self.plugin.errorsOnly = True
        test = self.case('test_fail')
        test(self.result)
        assert not self.plugin.pdb.called, \
            "pdb was called on failure when errorsOnly set"

    def test_other_plugins_can_prevent_interaction(self):
        # prevent 'no logger for x' warnings
        debugger.log.addHandler(NullHandler())
        nono = NoInteraction(session=self.session)
        nono.register()
        test = self.case('test_err')
        test(self.result)
        assert not self.plugin.pdb.called, \
            "pdb was called despite beforeInteraction returning False"

########NEW FILE########
__FILENAME__ = test_doctest_plugin
"""Test doctests plugin."""
import doctest

from nose2 import events, loader, session
from nose2.plugins import doctests
from nose2.tests._common import TestCase


class UnitTestDocTestLoader(TestCase):

    """Test class DocTestLoader."""
    tags = ['unit']

    _RUN_IN_TEMP = True

    def setUp(self):
        self.session = session.Session()
        self.loader = loader.PluggableTestLoader(self.session)
        self.plugin = doctests.DocTestLoader(session=self.session)
        super(UnitTestDocTestLoader, self).setUp()

    def test___init__(self):
        """Test the __init__ method."""
        self.assertEqual(self.plugin.extensions, ['.txt', '.rst'])

    def test_handle_file(self):
        """Test method handleFile."""
        # Create doctest files of supported types
        doc_test = """\
>>> 2 == 2
True
"""
        txt_event = self._handle_file('docs.txt', doc_test)
        rst_event = self._handle_file('docs.rst', doc_test)
        # Excercise loading of doctests from Python code
        py_event = self._handle_file('docs.py', """\
\"\"\"
>>> 2 == 2
True
\"\"\"
""")
        for event, ext in [(txt_event, 'txt'), (rst_event, 'rst')]:
            test, = event.extraTests
            self.assertTrue(isinstance(test, doctest.DocFileCase))
            self.assertEqual(repr(test), "docs.%s" % ext)

        testsuite, = py_event.extraTests
        test, = list(testsuite)
        self.assertEqual(repr(test), 'docs ()')

    def test_handle_file_python_without_doctests(self):
        """Test calling handleFile for a Python module without doctests."""
        event = self._handle_file("mod.py", """\
def func():
    pass
""")
        self.assertEqual(event.extraTests, [])

    def _handle_file(self, fpath, content):
        """Have plugin handle a file with certain content.

        The file is created, then a plugin is instantiated and its handleFile
        method is called for the file.
        """
        fh = open(fpath, "w")
        try:
            fh.write(content)
        finally:
            fh.close()

        event = events.HandleFileEvent(self.loader, fh.name, fpath, None, None)
        self.plugin.handleFile(event)
        return event

########NEW FILE########
__FILENAME__ = test_dundertest_plugin
import unittest

from nose2 import session
from nose2.plugins import dundertest
from nose2.tests._common import TestCase


class TestDunderTestPlugin(TestCase):
    tags = ['unit']

    def setUp(self):
        class DummyCase(TestCase):
            def test_a(self):
                pass

        self.suite = unittest.TestSuite()
        self.caseClass = DummyCase
        self.session = session.Session()
        self.plugin = dundertest.DunderTestFilter(session=self.session)
        self.plugin.register()

    def test_undefined_dunder_test_attribute_keeps_test(self):
        self.suite.addTest(self.caseClass('test_a'))
        self.plugin.removeNonTests(self.suite)
        self.assertEqual(len(list(self.suite)), 1)

    def test_false_dunder_test_attribute_removes_test(self):
        dummyTest = self.caseClass('test_a')
        dummyTest.__test__ = False
        self.suite.addTest(dummyTest)
        self.plugin.removeNonTests(self.suite)
        self.assertEqual(len(list(self.suite)), 0)

########NEW FILE########
__FILENAME__ = test_failfast
from nose2.tests._common import TestCase
from nose2.plugins import failfast
from nose2 import result, session
from nose2.compat import unittest


class TestFailFast(TestCase):
    tags = ['unit']

    def setUp(self):
        self.session = session.Session()
        self.result = result.PluggableTestResult(self.session)
        self.plugin = failfast.FailFast(session=self.session)
        self.plugin.register()

        class Test(TestCase):

            def test(self):
                pass

            def test_err(self):
                raise Exception("oops")

            def test_fail(self):
                assert False

            @unittest.expectedFailure
            def test_fail_expected(self):
                assert False

            @unittest.skipIf(True, "Always skip")
            def test_skip(self):
                pass
        self.case = Test

    def test_sets_shouldstop_on_unexpected_error(self):
        test = self.case('test_err')
        test(self.result)
        assert self.result.shouldStop

    def test_sets_shouldstop_on_unexpected_fail(self):
        test = self.case('test_fail')
        test(self.result)
        assert self.result.shouldStop

    def test_does_not_set_shouldstop_on_expected_fail(self):
        test = self.case('test_fail_expected')
        test(self.result)
        assert not self.result.shouldStop

    def test_does_not_set_shouldstop_on_success(self):
        test = self.case('test')
        test(self.result)
        assert not self.result.shouldStop

    def test_does_not_set_shouldstop_on_skip(self):
        test = self.case('test_skip')
        test(self.result)
        assert not self.result.shouldStop

########NEW FILE########
__FILENAME__ = test_functions_loader
from nose2.compat import unittest
from nose2 import events, loader, session
from nose2.plugins.loader import functions
from nose2.tests._common import TestCase


class TestFunctionLoader(TestCase):

    def setUp(self):
        self.session = session.Session()
        self.loader = loader.PluggableTestLoader(self.session)
        self.plugin = functions.Functions(session=self.session)

    def test_can_load_test_functions_from_module(self):
        class Mod(object):
            pass

        def test():
            pass
        m = Mod()
        m.test = test
        event = events.LoadFromModuleEvent(self.loader, m)
        self.session.hooks.loadTestsFromModule(event)
        self.assertEqual(len(event.extraTests), 1)
        assert isinstance(event.extraTests[0], unittest.FunctionTestCase)

    def test_ignores_generator_functions(self):
        class Mod(object):
            pass

        def test():
            yield
        m = Mod()
        m.test = test
        event = events.LoadFromModuleEvent(self.loader, m)
        self.session.hooks.loadTestsFromModule(event)
        self.assertEqual(len(event.extraTests), 0)

    def test_ignores_functions_that_take_args(self):
        class Mod(object):
            pass

        def test(a):
            pass
        m = Mod()
        m.test = test
        event = events.LoadFromModuleEvent(self.loader, m)
        self.session.hooks.loadTestsFromModule(event)
        self.assertEqual(len(event.extraTests), 0)

########NEW FILE########
__FILENAME__ = test_generators_plugin
from nose2 import events, loader, session, util
from nose2.plugins.loader import generators, testcases
from nose2.tests._common import TestCase


class TestGeneratorUnpack(TestCase):
    tags = ['unit']

    def setUp(self):
        self.session = session.Session()
        self.loader = loader.PluggableTestLoader(self.session)
        self.expect = [(0, ('call', (0, 1))),
                       (1, ('call', (1, 2))),
                       (2, ('call', (2, 3))), ]
        self.plugin = generators.Generators(session=self.session)
        # need testcase loader to make the initial response to load from module
        self.tcl = testcases.TestCaseLoader(session=self.session)

    def test_unpack_handles_nose_style_generators(self):
        def gen():
            for i in range(0, 3):
                yield 'call', i, i + 1
        out = list(self.plugin.unpack(gen()))
        self.assertEqual(out, self.expect)

    def test_unpack_handles_unittest2_style_generators(self):
        def gen():
            for i in range(0, 3):
                yield 'call', (i, i + 1)
        out = list(self.plugin.unpack(gen()))
        self.assertEqual(out, self.expect)

    def test_ignores_ordinary_functions(self):
        class Mod(object):
            pass

        def test():
            pass
        m = Mod()
        m.test = test
        event = events.LoadFromModuleEvent(self.loader, m)
        self.session.hooks.loadTestsFromModule(event)
        self.assertEqual(len(event.extraTests), 0)

    def test_can_load_tests_from_generator_functions(self):
        class Mod(object):
            __name__ = 'themod'

        def check(x):
            assert x == 1

        def test():
            yield check, 1
            yield check, 2
        m = Mod()
        m.test = test
        test.__module__ = m.__name__
        event = events.LoadFromModuleEvent(self.loader, m)
        self.session.hooks.loadTestsFromModule(event)
        self.assertEqual(len(event.extraTests), 2)
        # check that test names are sensible
        self.assertEqual(util.test_name(event.extraTests[0]),
                         'themod.test:1')
        self.assertEqual(util.test_name(event.extraTests[1]),
                         'themod.test:2')

    def test_can_load_tests_from_generator_methods(self):
        class Mod(object):
            pass

        def check(x):
            return x == 1

        class Test(TestCase):

            def test(self):
                yield check, 1
                yield check, 2
        m = Mod()
        m.Test = Test
        event = events.LoadFromModuleEvent(self.loader, m)
        self.session.hooks.loadTestsFromModule(event)
        self.assertEqual(len(event.extraTests), 1)
        self.assertEqual(len(event.extraTests[0]._tests), 2)

########NEW FILE########
__FILENAME__ = test_junitxml
from xml.etree import ElementTree as ET
from nose2.tests._common import TestCase
from nose2.compat import unittest
from nose2 import events, loader, result, session, tools
from nose2.plugins import junitxml
from nose2.plugins.loader import generators, parameters, testcases

import os
import six
import sys


class TestJunitXmlPlugin(TestCase):
    _RUN_IN_TEMP = True

    BAD_FOR_XML_U = six.u('A\x07 B\x0B C\x10 D\uD900 '
                          'E\uFFFE F\x80 G\x90 H\uFDDD')
    # UTF-8 string with double null (invalid)
    BAD_FOR_XML_B = six.b('A\x07 B\x0b C\x10 D\xed\xa4\x80 '
                          'E\xef\xbf\xbe F\xc2\x80 G\xc2\x90 H\xef\xb7\x9d '
                          '\x00\x00')

    # "byte" strings in PY2 and unicode in py3 works as expected will
    # will translate surrogates into UTF-16 characters  so BAD_FOR_XML_U
    # should have 8 letters follows by 0xFFFD, but only 4 when keeping
    # the discouraged/restricted ranges. Respectively:
    # "A\uFFFD B\uFFFD C\uFFFD D\uFFFD E\uFFFD F\uFFFD G\uFFFD H\uFFFD"
    # "A\uFFFD B\uFFFD C\uFFFD D\uFFFD E\uFFFD F\x80 G\x90 H\uFDDD"
    #
    # In Python 2 Invalid ascii characters seem to get escaped out as part
    # of tracebace.format_traceback so full and partial replacements are:
    # "A\uFFFD B\uFFFD C\uFFFD D\\\\ud900 E\\\\ufffe F\\\\x80 G\\\\x90 H\\\\ufddd"
    # "A\uFFFD B\uFFFD C\uFFFD D\\\\ud900 E\\\\ufffe F\\\\x80 G\\\\x90 H\\\\ufddd"
    #
    # Byte strings in py3 as errors are replaced by their representation string
    # So these will be safe and not have any replacements
    # "b'A\\x07 B\\x0b C\\x10 D\\xed\\xa4\\x80 E\\xef\\xbf\\xbe F\\xc2\\x80
    # G\\xc2\\x90 H\\xef\\xb7\\x9d \\x00\\x00"

    if sys.maxunicode <= 0xFFFF:
        EXPECTED_RE = six.u("^[\x09\x0A\x0D\x20\x21-\uD7FF\uE000-\uFFFD]*$")
        EXPECTED_RE_SAFE = six.u("^[\x09\x0A\x0D\x20\x21-\x7E\x85"
                                 "\xA0-\uD7FF\uE000-\uFDCF\uFDF0-\uFFFD]*$")
    else:
        EXPECTED_RE = six.u("^[\x09\x0A\x0D\x20\x21-\uD7FF\uE000-\uFFFD"
                            "\u10000-\u10FFFF]*$")
        EXPECTED_RE_SAFE = six.u("^[\x09\x0A\x0D\x20\x21-\x7E\x85"
                                 "\xA0-\uD7FF\uE000-\uFDCF\uFDF0-\uFFFD"
                                 "\u10000-\u1FFFD\u20000-\u2FFFD"
                                 "\u30000-\u3FFFD\u40000-\u4FFFD"
                                 "\u50000-\u5FFFD\u60000-\u6FFFD"
                                 "\u70000-\u7FFFD\u80000-\u8FFFD"
                                 "\u90000-\u8FFFD\uA0000-\uAFFFD"
                                 "\uB0000-\uBFFFD\uC0000-\uCFFFD"
                                 "\uD0000-\uDFFFD\uE0000-\uEFFFD"
                                 "\uF0000-\uFFFFD\u100000-\u10FFFD]*$")

    def setUp(self):
        super(TestJunitXmlPlugin, self).setUp()
        self.session = session.Session()
        self.loader = loader.PluggableTestLoader(self.session)
        self.result = result.PluggableTestResult(self.session)
        self.plugin = junitxml.JUnitXmlReporter(session=self.session)
        self.plugin.register()

        # unittest2 needs this
        if not hasattr(self, 'assertRegex'):
            self.assertRegex = self.assertRegexpMatches

        class Test(unittest.TestCase):

            def test(self):
                pass

            def test_chdir(self):
                TEMP_SUBFOLDER = 'test_chdir'

                os.mkdir(TEMP_SUBFOLDER)
                os.chdir(TEMP_SUBFOLDER)

            def test_fail(self):
                assert False

            def test_err(self):
                1 / 0

            def test_skip(self):
                raise unittest.SkipTest('skip')

            def test_bad_xml(self):
                raise RuntimeError(TestJunitXmlPlugin.BAD_FOR_XML_U)

            def test_bad_xml_b(self):
                raise RuntimeError(TestJunitXmlPlugin.BAD_FOR_XML_B)

            def test_gen(self):
                def check(a, b):
                    self.assertEqual(a, b)
                yield check, 1, 1
                yield check, 1, 2

            @tools.params(1, 2, 3)
            def test_params(self, p):
                self.assertEqual(p, 2)
        self.case = Test

    def test_success_added_to_xml(self):
        test = self.case('test')
        test(self.result)
        self.assertEqual(self.plugin.numtests, 1)
        self.assertEqual(len(self.plugin.tree.findall('testcase')), 1)

    def test_failure_includes_traceback(self):
        test = self.case('test_fail')
        test(self.result)
        case = self.plugin.tree.find('testcase')
        failure = case.find('failure')
        assert failure is not None
        assert 'Traceback' in failure.text

    def test_error_bad_xml(self):
        self.plugin.keep_restricted = False
        test = self.case('test_bad_xml')
        test(self.result)
        case = self.plugin.tree.find('testcase')
        error = case.find('error')
        self.assertRegex(error.text, self.EXPECTED_RE_SAFE)

    def test_error_bad_xml_keep(self):
        self.plugin.keep_restricted = True
        test = self.case('test_bad_xml')
        test(self.result)
        case = self.plugin.tree.find('testcase')
        error = case.find('error')
        self.assertRegex(error.text, self.EXPECTED_RE)

    def test_error_bad_xml_b(self):
        self.plugin.keep_restricted = False
        test = self.case('test_bad_xml_b')
        test(self.result)
        case = self.plugin.tree.find('testcase')
        error = case.find('error')
        ending = six.u(' \uFFFD\uFFFD')
        assert error is not None
        self.assertRegex(error.text, self.EXPECTED_RE_SAFE)

    def test_error_bad_xml_b_keep(self):
        self.plugin.keep_restricted = True
        test = self.case('test_bad_xml_b')
        test(self.result)
        case = self.plugin.tree.find('testcase')
        error = case.find('error')
        assert error is not None
        self.assertRegex(error.text, self.EXPECTED_RE)

    def test_error_includes_traceback(self):
        test = self.case('test_err')
        test(self.result)
        case = self.plugin.tree.find('testcase')
        error = case.find('error')
        assert error is not None
        assert 'Traceback' in error.text

    def test_skip_includes_skipped(self):
        test = self.case('test_skip')
        test(self.result)
        case = self.plugin.tree.find('testcase')
        skip = case.find('skipped')
        assert skip is not None

    def test_generator_test_name_correct(self):
        gen = generators.Generators(session=self.session)
        gen.register()
        event = events.LoadFromTestCaseEvent(self.loader, self.case)
        self.session.hooks.loadTestsFromTestCase(event)
        cases = event.extraTests
        for case in cases:
            case(self.result)
        xml = self.plugin.tree.findall('testcase')
        self.assertEqual(len(xml), 2)
        self.assertEqual(xml[0].get('name'), 'test_gen:1')
        self.assertEqual(xml[1].get('name'), 'test_gen:2')

    def test_params_test_name_correct(self):
        # param test loading is a bit more complex than generator
        # loading. XXX -- can these be reconciled so they both
        # support exclude and also both support loadTestsFromTestCase?
        plug1 = parameters.Parameters(session=self.session)
        plug1.register()
        plug2 = testcases.TestCaseLoader(session=self.session)
        plug2.register()
        # need module to fire top-level event

        class Mod(object):
            pass
        m = Mod()
        m.Test = self.case
        event = events.LoadFromModuleEvent(self.loader, m)
        self.session.hooks.loadTestsFromModule(event)
        for case in event.extraTests:
            case(self.result)
        xml = self.plugin.tree.findall('testcase')
        self.assertEqual(len(xml), 11)
        params = [x for x in xml if x.get('name').startswith('test_params')]
        self.assertEqual(len(params), 3)
        self.assertEqual(params[0].get('name'), 'test_params:1')
        self.assertEqual(params[1].get('name'), 'test_params:2')
        self.assertEqual(params[2].get('name'), 'test_params:3')

    def test_writes_xml_file_at_end(self):
        test = self.case('test')
        test(self.result)
        event = events.StopTestRunEvent(None, self.result, 1, 1)
        self.plugin.stopTestRun(event)
        with open(self.plugin.path, 'r') as fh:
            tree = ET.parse(fh).getroot()
        self.assertEqual(len(tree.findall('testcase')), 1)
        case = tree.find('testcase')
        assert 'time' in case.attrib
        assert 'classname' in case.attrib
        self.assertEqual(case.get('name'), 'test')
        self.assertEqual(tree.get('errors'), '0')
        self.assertEqual(tree.get('failures'), '0')
        self.assertEqual(tree.get('skipped'), '0')
        self.assertEqual(tree.get('tests'), '1')
        assert 'time' in tree.attrib

    def test_xml_file_path_is_not_affected_by_chdir_in_test(self):
        inital_dir = os.getcwd()
        test = self.case('test_chdir')
        test(self.result)
        self.assertEqual(inital_dir,
                         os.path.dirname(os.path.realpath(self.plugin.path)))

########NEW FILE########
__FILENAME__ = test_layers_plugin
from nose2.compat import unittest
from nose2.plugins import layers
from nose2 import events, loader, session
from nose2.tests._common import TestCase


class TestLayers(TestCase):
    tags = ['unit']

    def setUp(self):
        self.session = session.Session()
        self.loader = loader.PluggableTestLoader(session=self.session)
        self.session.testLoader = self.loader
        self.plugin = layers.Layers(session=self.session)

    def test_simple_layer_inheritance(self):
        class L1(object):
            pass

        class L2(L1):
            pass

        class T1(unittest.TestCase):
            layer = L1

            def test(self):
                pass

        class T2(unittest.TestCase):
            layer = L2

            def test(self):
                pass

        suite = unittest.TestSuite([T2('test'), T1('test')])
        event = events.StartTestRunEvent(None, suite, None, 0, None)
        self.plugin.startTestRun(event)
        expect = [['test (nose2.tests.unit.test_layers_plugin.T1)',
                   ['test (nose2.tests.unit.test_layers_plugin.T2)']]]
        self.assertEqual(self.names(event.suite), expect)

    def test_multiple_inheritance(self):
        class L1(object):
            pass

        class L2(L1):
            pass

        class L3(L1):
            pass

        class T1(unittest.TestCase):
            layer = L1

            def test(self):
                pass

        class T2(unittest.TestCase):
            layer = L2

            def test(self):
                pass

        class T3(unittest.TestCase):
            layer = L3

            def test(self):
                pass

        suite = unittest.TestSuite([T2('test'), T1('test'), T3('test')])
        event = events.StartTestRunEvent(None, suite, None, 0, None)
        self.plugin.startTestRun(event)
        expect = [['test (nose2.tests.unit.test_layers_plugin.T1)',
                   ['test (nose2.tests.unit.test_layers_plugin.T2)'],
                   ['test (nose2.tests.unit.test_layers_plugin.T3)']]]
        self.assertEqual(self.names(event.suite), expect)

    def test_deep_inheritance(self):
        class L1(object):
            pass

        class L2(L1):
            pass

        class L3(L1):
            pass

        class L4(L2, L1):
            pass

        class L5(L4):
            pass

        class T1(unittest.TestCase):
            layer = L1

            def test(self):
                pass

        class T2(unittest.TestCase):
            layer = L2

            def test(self):
                pass

        class T3(unittest.TestCase):
            layer = L3

            def test(self):
                pass

        class T4(unittest.TestCase):
            layer = L4

            def test(self):
                pass

        class T5(unittest.TestCase):
            layer = L5

            def test(self):
                pass

        suite = unittest.TestSuite([T2('test'), T1('test'), T3('test'),
                                    T4('test'), T5('test')])
        event = events.StartTestRunEvent(None, suite, None, 0, None)
        self.plugin.startTestRun(event)
        expect = [['test (nose2.tests.unit.test_layers_plugin.T1)',
                   ['test (nose2.tests.unit.test_layers_plugin.T2)',
                    ['test (nose2.tests.unit.test_layers_plugin.T4)',
                     ['test (nose2.tests.unit.test_layers_plugin.T5)']]],
                   ['test (nose2.tests.unit.test_layers_plugin.T3)']]]
        self.assertEqual(self.names(event.suite), expect)

    def test_mixed_layers_no_layers(self):
        class L1(object):
            pass

        class L2(L1):
            pass

        class T1(unittest.TestCase):
            layer = L1

            def test(self):
                pass

        class T2(unittest.TestCase):
            layer = L2

            def test(self):
                pass

        class T3(unittest.TestCase):

            def test(self):
                pass

        suite = unittest.TestSuite([T2('test'), T1('test'), T3('test')])
        event = events.StartTestRunEvent(None, suite, None, 0, None)
        self.plugin.startTestRun(event)
        expect = ['test (nose2.tests.unit.test_layers_plugin.T3)',
                  ['test (nose2.tests.unit.test_layers_plugin.T1)',
                   ['test (nose2.tests.unit.test_layers_plugin.T2)']]]
        self.assertEqual(self.names(event.suite), expect)

    def test_ordered_layers(self):
        class L1(object):
            pass

        class L2(L1):
            position = 1

        class L3(L1):
            position = 2

        class L4(L1):
            position = 3

        class L5(L2):
            position = 4

        class T1(unittest.TestCase):
            layer = L1

            def test(self):
                pass

        class T2(unittest.TestCase):
            layer = L2

            def test(self):
                pass

        class T3(unittest.TestCase):
            layer = L3

            def test(self):
                pass

        class T4(unittest.TestCase):
            layer = L4

            def test(self):
                pass

        class T5(unittest.TestCase):
            layer = L5

            def test(self):
                pass
        suite = unittest.TestSuite([T2('test'), T1('test'),
                                    T3('test'), T4('test'), T5('test')])
        event = events.StartTestRunEvent(None, suite, None, 0, None)
        self.plugin.startTestRun(event)
        expect = [['test (nose2.tests.unit.test_layers_plugin.T1)',
                   ['test (nose2.tests.unit.test_layers_plugin.T2)',
                    ['test (nose2.tests.unit.test_layers_plugin.T5)', ]],
                   ['test (nose2.tests.unit.test_layers_plugin.T3)', ],
                   ['test (nose2.tests.unit.test_layers_plugin.T4)', ]]]
        self.assertEqual(self.names(event.suite), expect)

    def test_mixin_inheritance(self):
        class L1(object):
            pass

        class L2(object):  # a mixin, doesn't share a base w/L1
            pass

        class L3(L1):
            pass

        class L4(L3):
            pass

        class L5(L4):
            pass

        class L6(L2):
            mixins = (L4,)

        class T1(unittest.TestCase):
            layer = L1

            def test(self):
                pass

        class T3(unittest.TestCase):
            layer = L3

            def test(self):
                pass

        class T4(unittest.TestCase):
            layer = L4

            def test(self):
                pass

        class T5(unittest.TestCase):
            layer = L5

            def test(self):
                pass

        class T6(unittest.TestCase):
            layer = L6

            def test(self):
                pass
        suite = unittest.TestSuite([T6('test'), T1('test'),
                                    T3('test'), T4('test'), T5('test')])
        event = events.StartTestRunEvent(None, suite, None, 0, None)
        self.plugin.startTestRun(event)
        expect = [['test (nose2.tests.unit.test_layers_plugin.T1)',
                   ['test (nose2.tests.unit.test_layers_plugin.T3)',
                    ['test (nose2.tests.unit.test_layers_plugin.T4)',
                     [['test (nose2.tests.unit.test_layers_plugin.T6)']],
                 ['test (nose2.tests.unit.test_layers_plugin.T5)', ]]]]]
        self.assertEqual(self.names(event.suite), expect)

    def names(self, suite):
        return [n for n in self.iternames(suite)]

    def iternames(self, suite):
        for t in suite:
            if isinstance(t, unittest.TestCase):
                yield str(t)
            else:
                yield [n for n in self.iternames(t)]

    def _listset(self, l):
        n = set([])
        for t in l:
            if isinstance(t, list):
                n.add(self._listset(t))
            else:
                n.add(t)
        return frozenset(n)

########NEW FILE########
__FILENAME__ = test_loader
from nose2 import events, loader, session
from nose2.tests._common import TestCase


class TestPluggableTestLoader(TestCase):

    def setUp(self):
        self.session = session.Session()
        self.loader = loader.PluggableTestLoader(self.session)

    def test_load_from_module_calls_hook(self):
        self.session.hooks.register('loadTestsFromModule', FakePlugin())
        evt = events.LoadFromModuleEvent(self.loader, 'some_module')
        self.session.hooks.loadTestsFromModule(evt)
        self.assertTrue(evt.fakeLoadFromModule,
                        "FakePlugin.loadTestsFromModule() was not called")

    def test_load_from_name_calls_hook(self):
        self.session.hooks.register('loadTestsFromName', FakePlugin())
        evt = events.LoadFromNameEvent(self.loader,
                                       'some_name',
                                       'some_module')
        self.session.hooks.loadTestsFromName(evt)
        self.assertTrue(evt.fakeLoadFromName,
                        "FakePlugin.fakeLoadFromName() was not called")

    def test_load_from_names_calls_hook(self):
        self.session.hooks.register('loadTestsFromNames', FakePlugin())
        evt = events.LoadFromNamesEvent(self.loader,
                                        ['some_name'],
                                        'some_module')
        self.session.hooks.loadTestsFromNames(evt)
        self.assertTrue(evt.fakeLoadFromNames,
                        "FakePlugin.fakeLoadFromNames() was not called")

    def test_loader_from_names_calls_module_hook(self):
        fake_plugin = FakePlugin()
        self.session.hooks.register('loadTestsFromModule', fake_plugin)
        self.loader.loadTestsFromNames([], 'some_module')
        self.assertTrue(fake_plugin.fakeLoadFromModule,
                        "FakePlugin.loadTestsFromModule() was not called")

    def test_loader_from_names_calls_name_hook(self):
        fake_plugin = FakePlugin()
        self.session.hooks.register('loadTestsFromName', fake_plugin)
        self.loader.loadTestsFromNames(['some_name'])
        self.assertTrue(fake_plugin.fakeLoadFromName,
                        "FakePlugin.loadTestsFromName() was not called")

    def test_loader_from_names_calls_names_hook(self):
        fake_plugin = FakePlugin()
        self.session.hooks.register('loadTestsFromNames', fake_plugin)
        self.loader.loadTestsFromNames(['some_name'])
        self.assertTrue(fake_plugin.fakeLoadFromNames,
                        "FakePlugin.loadTestsFromNames() was not called")


class FakePlugin(object):

    def __init__(self):
        self.fakeLoadFromModule = False
        self.fakeLoadFromName = False
        self.fakeLoadFromNames = False

    def loadTestsFromModule(self, event):
        event.fakeLoadFromModule = True
        self.fakeLoadFromModule = True

    def loadTestsFromName(self, event):
        event.fakeLoadFromName = True
        self.fakeLoadFromName = True

    def loadTestsFromNames(self, event):
        event.fakeLoadFromNames = True
        self.fakeLoadFromNames = True
########NEW FILE########
__FILENAME__ = test_logcapture_plugin
import logging

from nose2.tests._common import TestCase
from nose2.plugins import logcapture
from nose2 import session


log = logging.getLogger(__name__)


class StubLogging(object):

    def __init__(self, name=None):
        self.name = name
        self.handlers = []
        self.level = None

    def getLogger(self, _name=None):
        return self

    def addHandler(self, handler):
        self.handlers.append(handler)

    def setLevel(self, level):
        self.level = level

    def debug(self, message, *arg):
        # import pdb; pdb.set_trace()
        for handler in self.handlers:
            handler.emit(StubRecord(message % arg))


class StubRecord(object):

    def __init__(self, message):
        self.message = message
        self.name = 'stub'
        self.levelname = 'stub'
        self.exc_info = None
        self.exc_text = None
        self.stack_info = None

    def getMessage(self):
        return self.message


class LogCaptureUnitTest(TestCase):
    tags = ['unit']

    def setUp(self):
        self.session = session.Session()
        self.plugin = logcapture.LogCapture(session=self.session)
        self.logging = logcapture.logging
        logcapture.logging = StubLogging()

    def tearDown(self):
        logcapture.logging = self.logging

    def event(self, error=True, failed=False):
        e = Event()
        e.metadata = {}
        return e

    def test_buffer_cleared_after_each_test(self):
        self.plugin.startTestRun(None)
        self.plugin.startTest(None)
        logcapture.logging.getLogger('test').debug("hello")
        assert self.plugin.handler.buffer
        self.plugin.setTestOutcome(self.event())
        assert self.plugin.handler.buffer
        self.plugin.stopTest(None)
        assert not self.plugin.handler.buffer

    def test_buffered_logs_attached_to_event(self):
        self.plugin.startTestRun(None)
        self.plugin.startTest(None)
        logcapture.logging.getLogger('test').debug("hello")
        assert self.plugin.handler.buffer
        e = self.event()
        self.plugin.setTestOutcome(e)
        assert 'logs' in e.metadata, "No log in %s" % e.metadata


class Event:
    pass

########NEW FILE########
__FILENAME__ = test_mp_plugin
from nose2 import session
from nose2.tests._common import TestCase, Conn
from nose2.plugins import mp
import sys


class TestMPPlugin(TestCase):

    def setUp(self):
        self.session = session.Session()
        self.plugin = mp.MultiProcess(session=self.session)

    def test_gentests(self):
        conn = Conn([1, 2, 3])
        res = []
        for x in mp.gentests(conn):
            res.append(x)
        self.assertEqual(res, [1, 2, 3])

    def test_recording_plugin_interface(self):
        rpi = mp.RecordingPluginInterface()
        # this one should record
        rpi.setTestOutcome(None)
        # none of these should record
        rpi.getTestCaseNames(None)
        rpi.startSubprocess(None)
        rpi.stopSubprocess(None)
        rpi.registerInSubprocess(None)
        rpi.loadTestsFromModule(None)
        rpi.loadTestsFromTestCase(None)
        self.assertEqual(rpi.flush(), [('setTestOutcome', None)])

    def test_address(self):
        platform = sys.platform
        try:
            sys.platform = "linux"
            host = "1.2.3.4"
            port = 245
            self.plugin.setAddress(host)
            self.assertEqual((self.plugin.bind_host, self.plugin.bind_port),
                             (host, 0))
            self.plugin.setAddress("%s:%i" % (host, port))
            self.assertEqual((self.plugin.bind_host, self.plugin.bind_port),
                             (host, port))
            self.plugin.setAddress(None)
            self.assertEqual((self.plugin.bind_host, self.plugin.bind_port),
                             (None, 0))
            sys.platform = "win32"
            self.plugin.setAddress(host)
            self.assertEqual((self.plugin.bind_host, self.plugin.bind_port),
                             (host, 0))
            self.plugin.setAddress("%s:%i" % (host, port))
            self.assertEqual((self.plugin.bind_host, self.plugin.bind_port),
                             (host, port))
            self.plugin.setAddress(None)
            self.assertEqual((self.plugin.bind_host, self.plugin.bind_port),
                             ("127.116.157.163", 0))
        finally:
            sys.platform = platform


########NEW FILE########
__FILENAME__ = test_outcomes_plugin
from nose2.plugins import outcomes
from nose2 import events, result, session
from nose2.tests._common import TestCase


class TestOutComesPlugin(TestCase):
    tags = ['unit']

    def setUp(self):
        self.session = session.Session()
        self.result = result.PluggableTestResult(self.session)
        self.plugin = outcomes.Outcomes(session=self.session)
        self.plugin.register()

        class Test(TestCase):

            def test_e1(self):
                raise KeyError("k")

            def test_e2(self):
                raise TypeError("x")

            def test_e3(self):
                raise IOError("o")

        self.case = Test

        class Watcher(events.Plugin):

            def __init__(self):
                self.outcomes = {}

            def testOutcome(self, event):
                self.outcomes.setdefault(event.outcome, []).append(event)
        self.watcher = Watcher(session=self.session)
        self.watcher.register()

    def test_labels_upper(self):
        self.assertEqual(self.plugin.labels('xxx'), ('X', 'XXX'))

    def test_can_do_nothing_when_not_configured(self):
        test = self.case('test_e1')
        test(self.result)
        assert self.watcher.outcomes['error']
        assert not 'failed' in self.watcher.outcomes

    def test_can_treat_as_fail(self):
        self.plugin.treatAsFail.add('KeyError')
        test = self.case('test_e1')
        test(self.result)
        assert self.watcher.outcomes['failed']
        assert not 'error' in self.watcher.outcomes

    def test_can_treat_as_skip(self):
        self.plugin.treatAsSkip.add('KeyError')
        test = self.case('test_e1')
        test(self.result)
        assert self.watcher.outcomes['skipped']
        assert not 'error' in self.watcher.outcomes

    def test_can_handle_multiple_events_cleanly(self):
        self.plugin.treatAsSkip.add('KeyError')
        self.plugin.treatAsFail.add('TypeError')
        test = self.case('test_e1')
        test(self.result)
        test = self.case('test_e2')
        test(self.result)
        test = self.case('test_e3')
        test(self.result)
        self.assertEqual(len(self.watcher.outcomes['skipped']), 1)
        self.assertEqual(len(self.watcher.outcomes['error']), 1)
        self.assertEqual(len(self.watcher.outcomes['failed']), 1)

########NEW FILE########
__FILENAME__ = test_params_plugin
from nose2 import events, loader, session, util
from nose2.plugins.loader import parameters, testcases
from nose2.tests._common import TestCase
from nose2.tools import cartesian_params, params


class TestParams(TestCase):
    tags = ['unit']

    def setUp(self):
        self.session = session.Session()
        self.loader = loader.PluggableTestLoader(self.session)
        self.plugin = parameters.Parameters(session=self.session)
        # need testcase loader to make the initial response to load from module
        self.tcl = testcases.TestCaseLoader(session=self.session)

    def test_ignores_ordinary_functions(self):
        class Mod(object):
            pass

        def test():
            pass
        m = Mod()
        m.test = test
        event = events.LoadFromModuleEvent(self.loader, m)
        self.session.hooks.loadTestsFromModule(event)
        self.assertEqual(len(event.extraTests), 0)

    def test_can_load_tests_from_parameterized_by_params_functions(self):
        class Mod(object):
            __name__ = 'themod'

        def check(x):
            assert x == 1

        @params(1, 2)
        def test(a):
            check(a)
        m = Mod()
        m.test = test
        test.__module__ = m.__name__
        event = events.LoadFromModuleEvent(self.loader, m)
        self.session.hooks.loadTestsFromModule(event)
        self.assertEqual(len(event.extraTests), 2)
        # check that test names are sensible
        self.assertEqual(util.test_name(event.extraTests[0]),
                         'themod.test:1')
        self.assertEqual(util.test_name(event.extraTests[1]),
                         'themod.test:2')

    def test_can_load_tests_from_parameterized_by_cartesian_params_functions(self):
        class Mod(object):
            __name__ = 'themod'

        def check(x, y):
            assert x == y

        @cartesian_params(
            (1, 2),
            (2, 3),
        )
        def test(a, b):
            check(a, b)
        m = Mod()
        m.test = test
        test.__module__ = m.__name__
        event = events.LoadFromModuleEvent(self.loader, m)
        self.session.hooks.loadTestsFromModule(event)
        self.assertEqual(len(event.extraTests), 4)
        # check that test names are sensible
        self.assertEqual(util.test_name(event.extraTests[0]),
                         'themod.test:1')
        self.assertEqual(util.test_name(event.extraTests[1]),
                         'themod.test:2')
        self.assertEqual(util.test_name(event.extraTests[2]),
                         'themod.test:3')
        self.assertEqual(util.test_name(event.extraTests[3]),
                         'themod.test:4')

    def test_can_load_tests_from_parameterized_by_params_methods(self):
        class Mod(object):
            __name__ = 'themod'

        class Test(TestCase):

            @params(1, 2)
            def test(self, a):
                assert a == 1
        m = Mod()
        m.Test = Test
        Test.__module__ = m.__name__
        event = events.LoadFromModuleEvent(self.loader, m)
        self.session.hooks.loadTestsFromModule(event)
        self.assertEqual(len(event.extraTests), 1)
        self.assertEqual(len(event.extraTests[0]._tests), 2)
        # check that test names are sensible
        self.assertEqual(util.test_name(event.extraTests[0]._tests[0]),
                         'themod.Test.test:1')
        self.assertEqual(util.test_name(event.extraTests[0]._tests[1]),
                         'themod.Test.test:2')

    def test_can_load_tests_from_parameterized_by_cartesian_params_methods(self):
        class Mod(object):
            __name__ = 'themod'

        class Test(TestCase):

            @cartesian_params(
                (1, 2),
                (2, 3),
            )
            def test(self, a, b):
                assert a == b
        m = Mod()
        m.Test = Test
        Test.__module__ = m.__name__
        event = events.LoadFromModuleEvent(self.loader, m)
        self.session.hooks.loadTestsFromModule(event)
        self.assertEqual(len(event.extraTests), 1)
        self.assertEqual(len(event.extraTests[0]._tests), 4)
        # check that test names are sensible
        self.assertEqual(util.test_name(event.extraTests[0]._tests[0]),
                         'themod.Test.test:1')
        self.assertEqual(util.test_name(event.extraTests[0]._tests[1]),
                         'themod.Test.test:2')
        self.assertEqual(util.test_name(event.extraTests[0]._tests[2]),
                         'themod.Test.test:3')
        self.assertEqual(util.test_name(event.extraTests[0]._tests[3]),
                         'themod.Test.test:4')

    def test_params_creates_params_for_function(self):
        @params(
            (1, 2),
            ('a', 'b'),
        )
        def test(a, b):
            assert a == b
        self.assertTupleEqual(tuple(test.paramList), ((1, 2), ('a', 'b')))

    def test_cartesian_params_creates_cartesian_product_of_params_for_function(self):
        @cartesian_params(
            (1, 2),
            ('a', 'b'),
        )
        def test(a, b):
            assert a == b
        self.assertTupleEqual(tuple(test.paramList), ((1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')))

    def test_params_creates_params_for_method(self):
        class Test(TestCase):
            @params(
                (1, 2),
                ('a', 'b'),
            )
            def test(self, a, b):
                assert a == b
        self.assertTupleEqual(tuple(Test.test.paramList), ((1, 2), ('a', 'b')))

    def test_cartesian_params_creates_cartesian_product_of_params_for_method(self):
        class Test(TestCase):
            @cartesian_params(
                (1, 2),
                ('a', 'b'),
            )
            def test(self, a, b):
                assert a == b
        self.assertTupleEqual(tuple(Test.test.paramList), ((1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')))

########NEW FILE########
__FILENAME__ = test_plugin_api
from nose2 import events, session
from nose2.tests._common import TestCase


class Example(events.Plugin):
    commandLineSwitch = ('X', 'xxx', 'triple x')

    def testOutcome(self, event):
        pass


class TestPluginApi(TestCase):

    def setUp(self):
        self.session = session.Session()
        self.plug = Example(session=self.session)
        super(TestCase, self).setUp()

    def test_add_option_adds_option(self):
        helpt = self.session.argparse.format_help()
        assert '-X, --xxx' in helpt, \
            "commandLineSwitch arg not found in help text: %s" % helpt

    def test_short_opt_registers_plugin(self):
        args, argv = self.session.argparse.parse_known_args(['-X'])
        assert self.plug in self.session.plugins
        assert self.plug in self.session.hooks.testOutcome.plugins, \
            "short opt did not register plugin"

    def test_long_opt_registers_plugin(self):
        args, argv = self.session.argparse.parse_known_args(['--xxx'])
        assert self.plug in self.session.plugins
        assert self.plug in self.session.hooks.testOutcome.plugins, \
            "long opt did not register plugin"

########NEW FILE########
__FILENAME__ = test_printhooks_plugin
import sys

import six

from nose2.plugins import printhooks
from nose2 import events, session
from nose2.tests._common import TestCase


class CustomEvent(events.Event):

    _attrs = events.Event._attrs + ('args',)

    def __init__(self, args, **kw):
        self.args = args
        super(CustomEvent, self).__init__(**kw)


class TestPluginA(events.Plugin):

    def register(self):
        super(TestPluginA, self).register()
        self.addMethods('pluginHookA')

    def register_with_nested_hook(self):
        super(TestPluginA, self).register()
        self.addMethods('pluginHookB')


class TestPluginB(events.Plugin):

    def pluginHookA(self, event):
        event.handled = True
        return "TestPluginB.pluginHookA"


class TestPluginC(events.Plugin):

    def register(self):
        super(TestPluginC, self).register()
        self.addMethods('pluginHookB1')

    def pluginHookB(self, event):
        nested_event = CustomEvent('level_two_args')
        self.session.hooks.pluginHookB1(nested_event)
        event.handled = True
        return "TestPluginC.pluginHookB"


class IndentAwarePlugin(events.Plugin):

    def pluginHookA(self, event):
        event.handled = True
        return printhooks.INDENT.pop()


class TestPrintHooksPlugin(TestCase):
    tags = ['unit']

    def setUp(self):
        self.err = sys.stderr
        self.buf = six.StringIO()
        sys.stderr = self.buf
        self.addCleanup(self.restore_stderr)

        self.session = session.Session()
        self.print_hooks_plugin = printhooks.PrintHooks(session=self.session)
        self.plugin_a = TestPluginA(session=self.session)
        self.plugin_b = TestPluginB(session=self.session)

    def restore_stderr(self):
        sys.stderr = self.err

    def test_traces_hooks_created_after_own_registration(self):
        self.print_hooks_plugin.register()
        self.plugin_a.register()
        self.plugin_b.register()

        event = CustomEvent('args')
        result = self.session.hooks.pluginHookA(event)
        self.assertEqual(result, "TestPluginB.pluginHookA")
        self.assertEqual("\n"
                         "pluginHookA: "
                         "CustomEvent(handled=False, args='args')",
                         self.buf.getvalue())

    def test_traces_hooks_created_before_own_registration(self):
        self.plugin_a.register()
        self.plugin_b.register()
        self.print_hooks_plugin.register()

        event = CustomEvent('args')
        result = self.session.hooks.pluginHookA(event)
        self.assertEqual(result, "TestPluginB.pluginHookA")
        self.assertEqual("\n"
                         "pluginHookA: "
                         "CustomEvent(handled=False, args='args')",
                         self.buf.getvalue())

    def test_traces_hooks_that_nobody_implements(self):
        self.plugin_a.register()
        self.print_hooks_plugin.register()

        event = CustomEvent('args')
        result = self.session.hooks.pluginHookA(event)
        self.assertEqual(result, None)
        self.assertEqual("\n"
                         "pluginHookA: "
                         "CustomEvent(handled=False, args='args')",
                         self.buf.getvalue())

    def test_indents_nested_hooks_in_trace(self):
        self.plugin_c = TestPluginC(session=self.session)

        self.plugin_a.register_with_nested_hook()
        self.plugin_c.register()
        self.print_hooks_plugin.register()

        event = CustomEvent('level_one_args')
        result = self.session.hooks.pluginHookB(event)
        self.assertEqual(result, "TestPluginC.pluginHookB")
        self.assertEqual("\n"
                         "pluginHookB: "
                         "CustomEvent(handled=False, args='level_one_args')"
                         "\n  "
                         "pluginHookB1: "
                         "CustomEvent(handled=False, args='level_two_args')",
                         self.buf.getvalue())

    def test_hook_implementors_can_modify_trace_indent(self):
        self.indent_aware_plugin = IndentAwarePlugin(session=self.session)

        self.plugin_a.register()
        self.indent_aware_plugin.register()
        self.print_hooks_plugin.register()

        event = CustomEvent('args')
        result = self.session.hooks.pluginHookA(event)
        self.assertEqual(result, "  ")

########NEW FILE########
__FILENAME__ = test_prof_plugin
from nose2 import session
from nose2.plugins import prof
from nose2.events import StartTestRunEvent
from nose2.tests._common import Stub, TestCase


class TestProfPlugin(TestCase):
    tags = ['unit']

    def setUp(self):
        self.plugin = prof.Profiler(session=session.Session())
        self.hotshot = prof.hotshot
        self.stats = prof.stats
        prof.hotshot = Stub()
        prof.stats = Stub()

    def tearDown(self):
        prof.hotshot = self.hotshot
        prof.stats = self.stats

    def test_startTestRun_sets_executeTests(self):
        _prof = Stub()
        _prof.runcall = object()
        prof.hotshot.Profile = lambda filename: _prof
        event = StartTestRunEvent(runner=None, suite=None, result=None,
                                  startTime=None, executeTests=None)
        self.plugin.startTestRun(event)
        assert event.executeTests is _prof.runcall, \
            "executeTests was not replaced"

########NEW FILE########
__FILENAME__ = test_result
from nose2 import result, session
from nose2.tests._common import TestCase


class TestPluggableTestResult(TestCase):

    def setUp(self):
        self.session = session.Session()
        self.result = result.PluggableTestResult(self.session)

    def test_skip_reason_not_discarded(self):
        class Test(TestCase):

            def test(self):
                pass
        plugin = FakePlugin()
        self.session.hooks.register('testOutcome', plugin)
        self.result.addSkip(Test('test'), 'because')
        self.assertEqual(plugin.reason, 'because')


class FakePlugin(object):

    def testOutcome(self, event):
        self.reason = event.reason

########NEW FILE########
__FILENAME__ = test_session
from nose2 import events, session
from nose2.compat import unittest


class SessionUnitTests(unittest.TestCase):

    def test_can_create_session(self):
        session.Session()

    def test_load_plugins_from_module_can_load_plugins(self):
        class fakemod:
            pass
        f = fakemod()

        class A(events.Plugin):
            pass
        f.A = A
        s = session.Session()
        s.loadPluginsFromModule(f)
        assert s.plugins
        a = s.plugins[0]
        self.assertEqual(a.session, s)

########NEW FILE########
__FILENAME__ = test_testcase_loader
from nose2.tests._common import TestCase
from nose2.plugins.loader.testcases import TestCaseLoader
from nose2 import events, loader, session


class TestTestCaseLoader(TestCase):

    def setUp(self):
        self.session = session.Session()
        self.loader = loader.PluggableTestLoader(session=self.session)
        self.plugin = TestCaseLoader(session=self.session)

        class Mod(object):
            pass
        self.module = Mod()

        class A(TestCase):

            def test(self):
                pass

        class B(TestCase):

            def runTest(self):
                pass

        class C(TestCase):

            def foo(self):
                pass

        class Test(object):

            def test(self):
                pass

        self.module.A = A
        self.module.B = B
        self.module.C = C
        self.module.Test = Test

    def test_can_find_testcases_in_module(self):
        event = events.LoadFromModuleEvent(self.loader, self.module)
        result = self.session.hooks.loadTestsFromModule(event)
        self.assertEqual(result, None)
        self.assertEqual(len(event.extraTests), 3)
        self.assertEqual(len(event.extraTests[0]._tests), 1)  # A
        self.assertEqual(len(event.extraTests[1]._tests), 1)  # B
        self.assertEqual(len(event.extraTests[2]._tests), 0)  # C

    def test_get_testcase_names_can_override_name_selection(self):
        class FooIsOnlyTest(events.Plugin):

            def getTestCaseNames(self, event):
                event.handled = True
                return ['foo'] if 'foo' in dir(event.testCase) else []
        foo = FooIsOnlyTest(session=self.session)
        foo.register()
        event = events.LoadFromModuleEvent(self.loader, self.module)
        result = self.session.hooks.loadTestsFromModule(event)
        self.assertEqual(result, None)
        self.assertEqual(len(event.extraTests), 3)
        self.assertEqual(len(event.extraTests[0]._tests), 0)  # A
        self.assertEqual(len(event.extraTests[1]._tests), 1)  # B (runTest)
        self.assertEqual(len(event.extraTests[2]._tests), 1)  # C

    def test_plugins_can_exclude_test_names(self):
        class Excluder(events.Plugin):

            def getTestCaseNames(self, event):
                event.excludedNames.append('test')
        excl = Excluder(session=self.session)
        excl.register()
        event = events.LoadFromModuleEvent(self.loader, self.module)
        result = self.session.hooks.loadTestsFromModule(event)
        self.assertEqual(result, None)
        self.assertEqual(len(event.extraTests), 3)
        self.assertEqual(len(event.extraTests[0]._tests), 0)  # A
        self.assertEqual(len(event.extraTests[1]._tests), 1)  # B (runTest)
        self.assertEqual(len(event.extraTests[2]._tests), 0)  # C

########NEW FILE########
__FILENAME__ = test_testclass_loader
from nose2.tests._common import TestCase
from nose2.plugins.loader.testclasses import TestClassLoader
from nose2 import events, loader, session

class TestTestClassLoader(TestCase):

    def setUp(self):
        self.session = session.Session()
        self.loader = loader.PluggableTestLoader(session=self.session)
        self.plugin = TestClassLoader(session=self.session)

        class Mod(object):
            pass
        self.module = Mod()

        class TestA(object):

            def test(self):
                pass

        class TestB(object):

            def runTest(self):
                pass

        class TestC(object):

            def foo(self):
                pass

        class Test(TestCase):

            def test(self):
                pass

        self.module.TestA = TestA
        self.module.TestB = TestB
        self.module.TestC = TestC
        self.module.Test = Test

    def test_can_find_testclasses_in_module(self):
        event = events.LoadFromModuleEvent(self.loader, self.module)
        result = self.session.hooks.loadTestsFromModule(event)
        self.assertEqual(result, None)
        self.assertEqual(len(event.extraTests), 3)
        self.assertEqual(len(event.extraTests[0]._tests), 1)  # TestA
        self.assertEqual(len(event.extraTests[1]._tests), 0)  # TestB
        self.assertEqual(len(event.extraTests[2]._tests), 0)  # TestC

    def test_get_testmethod_names_can_override_name_selection(self):
        class FooIsOnlyTest(events.Plugin):

            def getTestMethodNames(self, event):
                event.handled = True
                return ['foo'] if 'foo' in dir(event.testCase) else []
        foo = FooIsOnlyTest(session=self.session)
        foo.register()
        event = events.LoadFromModuleEvent(self.loader, self.module)
        result = self.session.hooks.loadTestsFromModule(event)
        self.assertEqual(result, None)
        self.assertEqual(len(event.extraTests), 3)
        self.assertEqual(len(event.extraTests[0]._tests), 0)  # TestA
        self.assertEqual(len(event.extraTests[1]._tests), 0)  # TestB
        self.assertEqual(len(event.extraTests[2]._tests), 1)  # TestC

    def test_plugins_can_exclude_test_names(self):
        class Excluder(events.Plugin):

            def getTestMethodNames(self, event):
                event.excludedNames.append('test')
        excl = Excluder(session=self.session)
        excl.register()
        event = events.LoadFromModuleEvent(self.loader, self.module)
        result = self.session.hooks.loadTestsFromModule(event)
        self.assertEqual(result, None)
        self.assertEqual(len(event.extraTests), 3)
        self.assertEqual(len(event.extraTests[0]._tests), 0)  # TestA
        self.assertEqual(len(event.extraTests[1]._tests), 0)  # TestB
        self.assertEqual(len(event.extraTests[2]._tests), 0)  # TestC


class TestFailingTestClassLoader(TestCase):

    def setUp(self):
        self.session = session.Session()
        self.loader = loader.PluggableTestLoader(session=self.session)
        self.plugin = TestClassLoader(session=self.session)

        class Mod(object):
            pass
        self.module = Mod()

        class TestA(object):
            def __init__(self):
                raise RuntimeError('Something bad happened!')

            def test(self):
                pass

        self.module.TestA = TestA

    def test_can_find_testclasses_in_module(self):
        event = events.LoadFromModuleEvent(self.loader, self.module)
        result = self.session.hooks.loadTestsFromModule(event)
        self.assertEqual(result, None)
        self.assertEqual(len(event.extraTests), 1)
        self.assertEqual(len(event.extraTests[0]._tests), 1)  # TestA
        self.assertEqual(event.extraTests[0]._tests[0].__class__.__name__, 'LoadTestsFailure')

########NEW FILE########
__FILENAME__ = test_testid_plugin
"""Test testid plugin."""
import os.path
import pickle

from six import StringIO

from nose2 import session
from nose2.events import ReportTestEvent
from nose2.plugins import testid
from nose2.tests._common import (FakeStartTestEvent, FakeLoadFromNameEvent,
                                 FakeLoadFromNamesEvent, TestCase)


class UnitTestTestId(TestCase):

    """Test class TestId.

    Tests are carried out in a temporary directory, since TestId stores state
    to file. The temporary directory is removed after testing.
    """
    tags = ['unit']
    _RUN_IN_TEMP = True

    def setUp(self):
        super(UnitTestTestId, self).setUp()
        self.stream = StringIO()
        self.session = session.Session()
        self.plugin = testid.TestId(session=self.session)

    def test___init__(self):
        """Test the __init__ method."""
        plug = self.plugin
        # Test attributes
        for name, exp_val in [(
            'configSection', 'testid'), ('commandLineSwitch',
                                         ('I', 'with-id', 'Add test ids to output')), ('idfile',
                                                                                       os.path.abspath(
                                                                                           '.noseids')), ('ids', {}), ('tests', {}),
                ('id', 0)]:
            try:
                val = getattr(plug, name)
            except AttributeError:
                self.fail(
                    'TestId instance doesn\'t have attribute %s' % (name,))
            self.assertEqual(val, exp_val, 'Attribute %s should have value '
                             '\'%s\', but has value %s' % (name, exp_val, val))

    def test_start_test(self):
        """Test reportStartTest method."""
        self.session.verbosity = 2
        event = ReportTestEvent(FakeStartTestEvent(self), self.stream)
        plug = self.plugin
        plug.reportStartTest(event)

        self.assertEqual(plug.id, 1)
        test_id = self.id()
        self.assertEqual(plug.ids, {1: test_id})
        self.assertEqual(plug.tests, {test_id: 1})
        self.assertEqual(self.stream.getvalue(), '#1 ')

    def test_start_test_twice(self):
        """Test calling reportStartTest twice."""
        self.session.verbosity = 2
        event = ReportTestEvent(FakeStartTestEvent(self), self.stream)
        plug = self.plugin
        plug.reportStartTest(event)
        plug.reportStartTest(event)

        self.assertEqual(plug.id, 1)
        test_id = self.id()
        self.assertEqual(plug.ids, {1: test_id})
        self.assertEqual(plug.tests, {test_id: 1})
        self.assertEqual(self.stream.getvalue(), '#1 #1 ')

    def test_stop_test_run(self):
        """Test stopTestRun method."""
        plug = self.plugin
        plug.reportStartTest(
            ReportTestEvent(FakeStartTestEvent(self), self.stream))
        plug.stopTestRun(None)

        fh = open(plug.idfile, 'rb')
        try:
            data = pickle.load(fh)
        finally:
            fh.close()
        self.assertEqual(data, {'ids': plug.ids, 'tests': plug.tests})

    def test_load_tests_from_name(self):
        """Test loadTestsFromName method."""
        plug = self.plugin
        # By first starting/stopping a test, an ID is assigned by the plugin
        plug.reportStartTest(
            ReportTestEvent(FakeStartTestEvent(self), self.stream))
        plug.stopTestRun(None)
        event = FakeLoadFromNameEvent('1')
        plug.loadTestsFromName(event)

        # The numeric ID should be translated to this test's ID
        self.assertEqual(event.name, self.id())

    def test_load_tests_from_name_no_ids(self):
        """Test calling loadTestsFromName when no IDs have been saved."""
        plug = self.plugin
        event = FakeLoadFromNameEvent('1')
        plug.loadTestsFromName(event)

        # The event's name should be unchanged, since no IDs should be mapped
        self.assertEqual(event.name, '1')

    def test_load_tests_from_names(self):
        """Test loadTestsFromNames method."""
        plug = self.plugin
        # By first starting/stopping a test, an ID is assigned by the plugin
        plug.reportStartTest(
            ReportTestEvent(FakeStartTestEvent(self), self.stream))
        plug.stopTestRun(None)
        event = FakeLoadFromNamesEvent(['1', '2'])
        plug.loadTestsFromNames(event)

        name1, name2 = event.names
        # The first numeric ID should be translated to this test's ID
        self.assertEqual(name1, self.id())
        # The second one should not have a match
        self.assertEqual(name2, '2')

########NEW FILE########
__FILENAME__ = _common
"""Common functionality."""
import os.path
import tempfile
import shutil
import subprocess
import sys

import six

from nose2.compat import unittest
from nose2 import discover, util


HERE = os.path.abspath(os.path.dirname(__file__))
SUPPORT = os.path.join(HERE, 'functional', 'support')


class TestCase(unittest.TestCase):

    """TestCase extension.

    If the class variable _RUN_IN_TEMP is True (default: False), tests will be
    performed in a temporary directory, which is deleted afterwards.
    """
    _RUN_IN_TEMP = False

    def setUp(self):
        super(TestCase, self).setUp()

        if self._RUN_IN_TEMP:
            self._orig_dir = os.getcwd()
            work_dir = self._work_dir = tempfile.mkdtemp()
            os.chdir(self._work_dir)
            # Make sure it's possible to import modules from current directory
            sys.path.insert(0, work_dir)

    def tearDown(self):
        super(TestCase, self).tearDown()

        if self._RUN_IN_TEMP:
            os.chdir(self._orig_dir)
            shutil.rmtree(self._work_dir, ignore_errors=True)


class FunctionalTestCase(unittest.TestCase):
    tags = ['functional']

    def assertTestRunOutputMatches(self, proc, stdout=None, stderr=None):
        cmd_stdout, cmd_stderr = None, None
        try:
            cmd_stdout, cmd_stderr = self._output[proc.pid]
        except AttributeError:
            self._output = {}
        except KeyError:
            pass
        if cmd_stdout is None:
            cmd_stdout, cmd_stderr = proc.communicate()
            self._output[proc.pid] = cmd_stdout, cmd_stderr
        testf = self.assertRegex if hasattr(self, 'assertRegex') \
            else self.assertRegexpMatches
        if stdout:
            testf(util.safe_decode(cmd_stdout), stdout)
        if stderr:
            testf(util.safe_decode(cmd_stderr), stderr)

    def runIn(self, testdir, *args, **kw):
        return run_nose2(*args, cwd=testdir, **kw)

    def runModuleAsMain(self, testmodule):
        return run_module_as_main(testmodule)


class _FakeEventBase(object):

    """Baseclass for fake Events."""

    def __init__(self):
        self.handled = False
        self.version = '0.1'
        self.metadata = {}


class FakeHandleFileEvent(_FakeEventBase):

    """Fake HandleFileEvent."""

    def __init__(self, name):
        super(FakeHandleFileEvent, self).__init__()

        self.loader = Stub()  # FIXME
        self.name = name
        self.path = os.path.split(name)[1]
        self.extraTests = []


class FakeStartTestEvent(_FakeEventBase):

    """Fake StartTestEvent."""

    def __init__(self, test):
        super(FakeStartTestEvent, self).__init__()
        self.test = test
        self.result = test.defaultTestResult()
        import time
        self.startTime = time.time()


class FakeLoadFromNameEvent(_FakeEventBase):

    """Fake LoadFromNameEvent."""

    def __init__(self, name):
        super(FakeLoadFromNameEvent, self).__init__()
        self.name = name


class FakeLoadFromNamesEvent(_FakeEventBase):

    """Fake LoadFromNamesEvent."""

    def __init__(self, names):
        super(FakeLoadFromNamesEvent, self).__init__()
        self.names = names


class FakeStartTestRunEvent(_FakeEventBase):

    """Fake StartTestRunEvent"""

    def __init__(self, runner=None, suite=None, result=None, startTime=None,
                 executeTests=None):
        super(FakeStartTestRunEvent, self).__init__()
        self.suite = suite
        self.runner = runner
        self.result = result
        self.startTime = startTime
        self.executeTests = executeTests


class Stub(object):

    """Stub object for use in tests"""

    def __getattr__(self, attr):
        return Stub()

    def __call__(self, *arg, **kw):
        return Stub()


def support_file(*path_parts):
    return os.path.abspath(os.path.join(SUPPORT, *path_parts))


def run_nose2(*nose2_args, **nose2_kwargs):
    if 'cwd' in nose2_kwargs:
        cwd = nose2_kwargs.pop('cwd')
        if not os.path.isabs(cwd):
            nose2_kwargs['cwd'] = support_file(cwd)
    return NotReallyAProc(nose2_args, **nose2_kwargs)


def run_module_as_main(test_module):
    if not os.path.isabs(test_module):
        test_module = support_file(test_module)
    return subprocess.Popen([sys.executable, test_module],
                            stdout=subprocess.PIPE, stderr=subprocess.PIPE)


class NotReallyAProc(object):

    def __init__(self, args, cwd=None, **kwargs):
        self.args = args
        self.chdir = cwd
        self.kwargs = kwargs

    def __enter__(self):
        self._stdout = sys.__stdout__
        self._stderr = sys.__stderr__
        self.cwd = os.getcwd()
        if self.chdir:
            os.chdir(self.chdir)
        self.stdout = sys.stdout = sys.__stdout__ = six.StringIO()
        self.stderr = sys.stderr = sys.__stderr__ = six.StringIO()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        sys.stdout = sys.__stdout__ = self._stdout
        sys.stderr = sys.__stderr__ = self._stderr
        if self.chdir:
            os.chdir(self.cwd)
        return False

    def communicate(self):
        with self:
            try:
                self.result = discover(
                    argv=('nose2',) + self.args, exit=False,
                    **self.kwargs)
            except SystemExit as e:
                return "", "EXIT CODE %s" % str(e)
            return self.stdout.getvalue(), self.stderr.getvalue()

    @property
    def pid(self):
        return id(self)

    def poll(self):
        return not self.result.result.wasSuccessful()


class RedirectStdStreams(object):

    """
    Context manager that replaces the stdin/out streams with StringIO
    buffers.
    """

    def __init__(self):
        self.stdout = six.StringIO()
        self.stderr = six.StringIO()

    def __enter__(self):
        self.old_stdout, self.old_stderr = sys.stdout, sys.stderr
        self.old_stdout.flush()
        self.old_stderr.flush()
        sys.stdout, sys.stderr = self.stdout, self.stderr
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.stdout.flush()
        self.stderr.flush()
        sys.stdout = self.old_stdout
        sys.stderr = self.old_stderr


# mock multprocessing Connection
class Conn(object):

    def __init__(self, items):
        self.items = items
        self.sent = []
        self.closed = False

    def recv(self):
        if self.closed:
            raise EOFError("closed")
        try:
            return self.items.pop(0)
        except:
            raise EOFError("EOF")

    def send(self, item):
        self.sent.append(item)

    def close(self):
        self.closed = True

########NEW FILE########
__FILENAME__ = params
"""
This module contains some code copied from unittest2 and other
code developed in reference to unittest2.

unittest2 is Copyright (c) 2001-2010 Python Software Foundation; All
Rights Reserved. See: http://docs.python.org/license.html

"""
import itertools

__unittest = True


def cartesian_params(*paramList):
    """Make a test function or method parameterized by cartesian product
    of parameters

    .. code-block :: python

      import unittest

      from nose2.tools import cartesian_params


      @cartesian_params((1, 2, 3), ('a', 'b'))
      def test_nums(num, char):
          assert num < ord(char)


      class Test(unittest.TestCase):

          @cartesian_params((1, 2, 3), ('a', 'b'))
          def test_less_than(self, num, char):
              self.assertLess(num, ord(char))

    Parameters in the list must be defined as iterable objects such as
    tuple or list.

    """
    def decorator(func):
        func.paramList = itertools.product(*paramList)
        return func
    return decorator


def params(*paramList):
    """Make a test function or method parameterized by parameters.

    .. code-block :: python

      import unittest

      from nose2.tools import params


      @params(1, 2, 3)
      def test_nums(num):
          assert num < 4


      class Test(unittest.TestCase):

          @params((1, 2), (2, 3), (4, 5))
          def test_less_than(self, a, b):
              assert a < b

    Parameters in the list may be defined as simple values, or as
    tuples. To pass a tuple as a simple value, wrap it in another tuple.

    """
    def decorator(func):
        func.paramList = paramList
        return func
    return decorator

########NEW FILE########
__FILENAME__ = such
from contextlib import contextmanager
import inspect
import logging

import six

from nose2.compat import unittest
from nose2 import util

log = logging.getLogger(__name__)

__unittest = True


@contextmanager
def A(description):
    """Test scenario context manager.

    Returns a :class:`nose2.tools.such.Scenario` instance,
    which by convention is bound to ``it``:

    .. code-block :: python

      with such.A('test scenario') as it:
          # tests and fixtures

    """
    yield Scenario(description)


class Helper(unittest.TestCase):

    def runTest(self):
        pass


helper = Helper()


class Scenario(object):

    """A test scenario.

    A test scenario defines a set of fixtures and tests
    that depend on those fixtures.
    """
    _helper = helper

    def __init__(self, description):
        self._group = Group('A %s' % description, 0)

    @contextmanager
    def having(self, description):
        """Define a new group under the current group.

        Fixtures and tests defined within the block will
        belong to the new group.

        .. code-block :: python

           with it.having('a description of this group'):
               # ...

        """
        last = self._group
        self._group = self._group.child(
            "having %s" % description)
        log.debug("starting new group from %s", description)
        yield self
        log.debug("leaving group %s", description)
        self._group = last

    def uses(self, layer):
        log.debug("Adding %s as mixin to %s", layer, self._group)
        self._group.mixins.append(layer)

    def has_setup(self, func):
        """Add a setup method to this group.

        The setup method will run once, before any of the
        tests in the containing group.

        A group may define any number of setup functions. They
        will execute in the order in which they are defined.

        .. code-block :: python

           @it.has_setup
           def setup():
               # ...

        """
        self._group.addSetup(func)
        return func

    def has_teardown(self, func):
        """Add a teardown method to this group.

        The teardown method will run once, after all of the
        tests in the containing group.

        A group may define any number of teardown functions. They
        will execute in the order in which they are defined.

        .. code-block :: python

           @it.has_teardown
           def teardown():
               # ...

        """
        self._group.addTeardown(func)
        return func

    def has_test_setup(self, func):
        """Add a test case setup method to this group.

        The setup method will run before each of the
        tests in the containing group.

        A group may define any number of test case setup
        functions. They will execute in the order in which they are
        defined.

        Test setup functions may optionally take one argument. If
        they do, they will be passed the :class:`unittest.TestCase`
        instance generated for the test.

        .. code-block :: python

           @it.has_test_setup
           def setup(case):
               # ...

        """
        self._group.addTestSetUp(func)

    def has_test_teardown(self, func):
        """Add a test case teardown method to this group.

        The teardown method will run before each of the
        tests in the containing group.

        A group may define any number of test case teardown
        functions. They will execute in the order in which they are
        defined.

        Test teardown functions may optionally take one argument. If
        they do, they will be passed the :class:`unittest.TestCase`
        instance generated for the test.

        .. code-block :: python

           @it.has_test_teardown
           def teardown(case):
               # ...

        """
        self._group.addTestTearDown(func)

    def should(self, desc):
        """Define a test case.

        Each function marked with this decorator becomes a test
        case in the current group.

        The decorator takes one optional argument, the description
        of the test case: what it **should** do. If this argument
        is not provided, the docstring of the decorated function
        will be used as the test case description.

        Test functions may optionally take one argument. If they do,
        they will be passed the :class:`unittest.TestCase` instance generated
        for the test. They can use this TestCase instance to execute assert
        methods, among other things.

        .. code-block :: python

           @it.should('do this')
           def dothis(case):
               # ....

           @it.should
           def dothat():
               "do that also"
               # ....

        """
        def decorator(f):
            _desc = desc if isinstance(desc, six.string_types) else f.__doc__
            case = Case(self._group, f, "should %s" % _desc)
            self._group.addCase(case)
            return case
        if isinstance(desc, type(decorator)):
            return decorator(desc)
        return decorator

    def __getattr__(self, attr):
        return getattr(self._helper, attr)

    def createTests(self, mod):
        """Generate test cases for this scenario.

        .. warning ::

           You must call this, passing in ``globals()``, to
           generate tests from the scenario. If you don't
           call ``createTests``, **no tests will be
           created**.

        .. code-block :: python

           it.createTests(globals())

        """
        self._makeGroupTest(mod, self._group)

    def _makeGroupTest(self, mod, group, parent_layer=None, position=0):
        layer = self._makeLayer(group, parent_layer, position)
        case = self._makeTestCase(group, layer)
        log.debug(
            "Made test case %s with layer %s from %s", case, layer, group)
        mod[layer.__name__] = layer
        layer.__module__ = mod['__name__']
        name = case.__name__
        long_name = ' '.join(
            [n[0].description for n in util.ancestry(layer)] + [name])
        mod[long_name] = case
        if name not in mod:
            mod[name] = case
        case.__module__ = mod['__name__']
        for index, child in enumerate(group._children):
            self._makeGroupTest(mod, child, layer, index)

    def _makeTestCase(self, group, layer):
        attr = {
            'layer': layer,
            'group': group,
            'description': group.description,
        }

        for index, case in enumerate(group._cases):
            def _test(s, case=case):
                case(s)
            name = 'test %04d: %s' % (index, case.description)
            _test.__name__ = name
            _test.description = case.description
            _test.case = case
            _test.index = index
            attr[name] = _test  # for collection and sorting
            attr[case.description] = _test  # for random access by name

        setups = group._test_setups[:]
        teardowns = group._test_teardowns[:]
        if setups:
            def setUp(self):
                for func in setups:
                    args, _, _, _ = inspect.getargspec(func)
                    if args:
                        func(self)
                    else:
                        func()
            attr['setUp'] = setUp
        if teardowns:
            def tearDown(self):
                for func in teardowns:
                    args, _, _, _ = inspect.getargspec(func)
                    if args:
                        func(self)
                    else:
                        func()
            attr['tearDown'] = tearDown

        def methodDescription(self):
            return getattr(self, self._testMethodName).description
        attr['methodDescription'] = methodDescription

        return type(group.description, (unittest.TestCase,), attr)

    def _makeLayer(self, group, parent_layer=None, position=0):
        if parent_layer is None:
            parent_layer = object

        # FIXME test setups
        # test_setups = group._test_setups[:]
        # test_teardowns = group._testeardowns[:]

        def setUp(cls):
            for setup in cls.setups:
                setup()

        def tearDown(cls):
            for teardown in cls.teardowns:
                teardown()

        attr = {
            'description': group.description,
            'setUp': classmethod(setUp),
            'tearDown': classmethod(tearDown),
            'setups': group._setups[:],
            'teardowns': group._teardowns[:],
            'position': position,
            'mixins': ()
        }

        if group.base_layer:
            # inject this layer into the group class list
            # by making it a subclass of parent_layer
            layer = group.base_layer
            if parent_layer not in layer.__bases__:
                layer.mixins = (parent_layer,)
        else:
            layer = type("%s:layer" % group.description, (parent_layer,), attr)
        if group.mixins:
            layer.mixins = getattr(layer, 'mixins', ()) + tuple(group.mixins)
        log.debug("made layer %s with bases %s and mixins %s",
                  layer, layer.__bases__, layer.mixins)
        return layer


class Group(object):

    """Group of tests w/common fixtures & description"""

    def __init__(self, description, indent=0, parent=None, base_layer=None):
        self.description = description
        self.indent = indent
        self.parent = parent
        self.base_layer = base_layer
        self.mixins = []
        self._cases = []
        self._setups = []
        self._teardowns = []
        self._test_setups = []
        self._test_teardowns = []
        self._children = []

    def addCase(self, case):
        if not self._cases:
            case.first = True
        case.indent = self.indent
        self._cases.append(case)

    def addSetup(self, func):
        self._setups.append(func)

    def addTeardown(self, func):
        self._teardowns.append(func)

    def addTestSetUp(self, func):
        self._test_setups.append(func)

    def addTestTearDown(self, func):
        self._test_teardowns.append(func)

    def fullDescription(self):
        d = []
        p = self.parent
        while p:
            d.insert(0, p.description)
            p = p.parent
        d.append(self.description)
        return ' '.join(d)

    def child(self, description, base_layer=None):
        child = Group(description, self.indent + 1, self, base_layer)
        self._children.append(child)
        return child


class Case(object):

    """Information about a test case"""
    _helper = helper

    def __init__(self, group, func, description):
        self.group = group
        self.func = func
        self.description = description
        self._setups = []
        self._teardowns = []
        self.first = False
        self.full = False

    def __call__(self, testcase):
        # ... only if it takes an arg
        self._helper = testcase
        args, _, _, _ = inspect.getargspec(self.func)
        if args:
            self.func(testcase)
        else:
            self.func()

    def __getattr__(self, attr):
        return getattr(self._helper, attr)

########NEW FILE########
__FILENAME__ = util
# This module contains some code copied from unittest2/loader.py and other
# code developed in reference to that module and others within unittest2.

# unittest2 is Copyright (c) 2001-2010 Python Software Foundation; All
# Rights Reserved. See: http://docs.python.org/license.html

import logging
import os
import re
import sys
import traceback
import platform

try:
    from inspect import isgeneratorfunction  # new in 2.6
except ImportError:
    import inspect
    try:
        from compiler.consts import CO_GENERATOR
    except ImportError:
        # IronPython doesn't have a complier module
        CO_GENERATOR = 0x20
    # backported from Python 2.6

    def isgeneratorfunction(func):
        return bool((inspect.isfunction(func) or inspect.ismethod(func)) and
                    func.func_code.co_flags & CO_GENERATOR)

import six


__unittest = True
IDENT_RE = re.compile(r'^[_a-zA-Z]\w*$', re.UNICODE)
VALID_MODULE_RE = re.compile(r'[_a-zA-Z]\w*\.py$', re.UNICODE)


def ln(label, char='-', width=70):
    """Draw a divider, with label in the middle.

    >>> ln('hello there')
    '---------------------------- hello there -----------------------------'

    Width and divider char may be specified. Defaults are 70 and '-'
    respectively.

    """
    label_len = len(label) + 2
    chunk = (width - label_len) // 2
    out = '%s %s %s' % (char * chunk, label, char * chunk)
    pad = width - len(out)
    if pad > 0:
        out = out + (char * pad)
    return out


def valid_module_name(path):
    """Is path a valid module name?"""
    return VALID_MODULE_RE.search(path)


def name_from_path(path):
    """Translate path into module name"""
    # back up to find module root
    parts = []
    path = os.path.normpath(path)
    base = os.path.splitext(path)[0]
    candidate, top = os.path.split(base)
    parts.append(top)
    while candidate:
        if ispackage(candidate):
            candidate, top = os.path.split(candidate)
            parts.append(top)
        else:
            break
    return '.'.join(reversed(parts))


def module_from_name(name):
    """Import module from name"""
    __import__(name)
    return sys.modules[name]


def test_from_name(name, module):
    """Import test from name"""
    pos = name.find(':')
    index = None
    if pos != -1:
        real_name, digits = name[:pos], name[pos + 1:]
        try:
            index = int(digits)
        except ValueError:
            pass
        else:
            name = real_name
    parent, obj = object_from_name(name, module)
    return parent, obj, name, index


def object_from_name(name, module=None):
    """Import object from name"""
    parts = name.split('.')
    if module is None:
        parts_copy = parts[:]
        while parts_copy:
            try:
                module = __import__('.'.join(parts_copy))
                break
            except ImportError:
                del parts_copy[-1]
                if not parts_copy:
                    raise
        parts = parts[1:]

    parent = None
    obj = module
    for part in parts:
        parent, obj = obj, getattr(obj, part)
    return parent, obj


def name_from_args(name, index, args):
    """Create test name from test args"""
    summary = ', '.join(repr(arg) for arg in args)
    return '%s:%s\n%s' % (name, index + 1, summary[:79])


def test_name(test):
    # XXX does not work for test funcs, test.id() lacks module
    if hasattr(test, '_funcName'):
        tid = test._funcName
    elif hasattr(test, '_testFunc'):
        tid = "%s.%s" % (test._testFunc.__module__, test._testFunc.__name__)
    else:
        tid = test.id()
    if '\n' in tid:
        tid = tid.split('\n')[0]
    return tid


def ispackage(path):
    """Is this path a package directory?"""
    if os.path.isdir(path):
        # at least the end of the path must be a legal python identifier
        # and __init__.py[co] must exist
        end = os.path.basename(path)
        if IDENT_RE.match(end):
            for init in ('__init__.py', '__init__.pyc', '__init__.pyo'):
                if os.path.isfile(os.path.join(path, init)):
                    return True
            if sys.platform.startswith('java') and \
                    os.path.isfile(os.path.join(path, '__init__$py.class')):
                return True
    return False


def ensure_importable(dirname):
    """Ensure a directory is on sys.path"""
    if not dirname in sys.path:
        sys.path.insert(0, dirname)


def isgenerator(obj):
    """is this object a generator?"""
    return (isgeneratorfunction(obj)
            or getattr(obj, 'testGenerator', None) is not None)


def has_module_fixtures(test):
    """Does this test live in a module with module fixtures?"""
    modname = test.__class__.__module__
    try:
        mod = sys.modules[modname]
    except KeyError:
        return
    return hasattr(mod, 'setUpModule') or hasattr(mod, 'tearDownModule')


def has_class_fixtures(test):
    # hasattr would be the obvious thing to use here, unfortunately all tests
    # inherit from unittest2.case.TestCase and that *always* has setUpClass and
    # tearDownClass methods. Therefore will have the following (ugly) solution:
    ver = platform.python_version_tuple()
    if float('{0}.{1}'.format(*ver[:2])) >= 2.7:
        name = 'unittest.case'
    else:
        name = 'unittest2.case'
    has_class_setups = any(
        'setUpClass' in c.__dict__ for c in test.__class__.__mro__ if c.__module__.find(name) == -1)
    has_class_teardowns = any(
        'tearDownClass' in c.__dict__ for c in test.__class__.__mro__ if c.__module__.find(name) == -1)
    return has_class_setups or has_class_teardowns


def safe_decode(string):
    """Safely decode a byte string into unicode"""
    if string is None:
        return string
    try:
        return string.decode()
    except AttributeError:
        return string
    except UnicodeDecodeError:
        pass
    try:
        return string.decode('utf-8')
    except UnicodeDecodeError:
        return six.u('<unable to decode>')


def exc_info_to_string(err, test):
    """Format exception info for output"""
    formatTraceback = getattr(test, 'formatTraceback', None)
    if formatTraceback is not None:
        return test.formatTraceback(err)
    else:
        return format_traceback(test, err)


def format_traceback(test, err):
    """Converts a sys.exc_info()-style tuple of values into a string."""
    exctype, value, tb = err
    if not hasattr(tb, 'tb_next'):
        msgLines = tb
    else:
        # Skip test runner traceback levels
        while tb and _is_relevant_tb_level(tb):
            tb = tb.tb_next
        failure = getattr(test, 'failureException', AssertionError)
        if exctype is failure:
            # Skip assert*() traceback levels
            length = _count_relevant_tb_levels(tb)
            msgLines = traceback.format_exception(exctype, value, tb, length)
        else:
            msgLines = traceback.format_exception(exctype, value, tb)

    return ''.join(msgLines)


def transplant_class(cls, module):
    """Make class appear to reside in ``module``.

    :param cls: A class
    :param module: A module name
    :returns: A subclass of ``cls`` that appears to have been defined in ``module``.

    The returned class's ``__name__`` will be equal to
    ``cls.__name__``, and its ``__module__`` equal to ``module``.

    """
    class C(cls):
        pass
    C.__module__ = module
    C.__name__ = cls.__name__
    return C


def parse_log_level(lvl):
    """Return numeric log level given a string"""
    try:
        return int(lvl)
    except ValueError:
        pass
    return getattr(logging, lvl.upper(), logging.WARN)


def _is_relevant_tb_level(tb):
    return '__unittest' in tb.tb_frame.f_globals


def _count_relevant_tb_levels(tb):
    length = 0
    while tb and not _is_relevant_tb_level(tb):
        length += 1
        tb = tb.tb_next
    return length


class _WritelnDecorator(object):

    """Used to decorate file-like objects with a handy 'writeln' method"""

    def __init__(self, stream):
        self.stream = stream

    def __getattr__(self, attr):
        if attr in ('stream', '__getstate__'):
            raise AttributeError(attr)
        return getattr(self.stream, attr)

    def write(self, arg):
        self.stream.write(arg)

    def writeln(self, arg=None):
        if arg:
            self.stream.write(arg)
        self.stream.write('\n')
                          # text-mode streams translate to \r\n if needed


def ancestry(layer):
    layers = [[layer]]
    bases = [base for base in bases_and_mixins(layer)
             if base is not object]
    while bases:
        layers.append(bases)
        newbases = []
        for b in bases:
            for bb in bases_and_mixins(b):
                if bb is not object:
                    newbases.append(bb)
        bases = newbases
    layers.reverse()
    return layers


def bases_and_mixins(layer):
    return (layer.__bases__ + getattr(layer, 'mixins', ()))

########NEW FILE########
__FILENAME__ = __main__
"""Main entry point"""

import sys
if sys.argv[0].endswith("__main__.py"):
    sys.argv[0] = "nose2"

__unittest = True


if __name__ == '__main__':
    from nose2 import discover
    discover()

########NEW FILE########
__FILENAME__ = unit_workaround
"""
Python 2.7 Multiprocessing Unittest workaround.
=====================================================================
Due the manner in which multiprocessing is handled on windows
and the fact that __main__.py are actually called __main__

This workaround bypasses the fact that the calling unittest
script is called __main__

http://bugs.python.org/issue10845

This should be fine for python 3.2+, however, 2.7 and before will
not likely see a fix.  This only affects the unittests called by tox.

Also with python 2.6 , the windows balks on unit2 (the sh script) not 
being a valid executable.
"""
try:
    import unittest2
    from unittest2.main import main, TestProgram, USAGE_AS_MAIN
except ImportError:
    import unittest
    from unittest.main import main, TestProgram, USAGE_AS_MAIN

TestProgram.USAGE = USAGE_AS_MAIN

if __name__ == "__main__":
    main(module=None)


########NEW FILE########
