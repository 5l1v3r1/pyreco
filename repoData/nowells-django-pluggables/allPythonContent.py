__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-pluggables documentation build configuration file, created by
# sphinx-quickstart on Mon Aug  3 23:53:21 2009.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-pluggables'
copyright = u'2009, Nowell Strite, Shawn Rider'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1.0'
# The full version, including alpha/beta/rc tags.
release = '0.1.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-pluggables'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-pluggables.tex', u'django-pluggables Documentation',
   u'Nowell Strite, Shawn Rider', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = forms
from django import forms
from complaints.models import Complaint

class ComplaintForm(forms.ModelForm):
    def save(self, request=None, *args, **kwargs):
        kwargs['commit'] = False
        obj = super(ComplaintForm, self).save(*args, **kwargs)
        obj.save(request)
        return obj

    class Meta:
        model = Complaint
        exclude = ('pluggable_content_type', 'pluggable_object_id',)

########NEW FILE########
__FILENAME__ = models
from django.contrib import admin
from django.db import models

from pluggables.models import PluggableObjectModel

class Complaint(PluggableObjectModel):
    name = models.CharField(max_length=50)
    description = models.TextField()

    def __unicode__(self):
        return self.description

admin.site.register(Complaint)

########NEW FILE########
__FILENAME__ = traditional
from pluggables import PluggableApp, url, include, patterns

class ComplaintsApp(PluggableApp):
    urlpatterns = patterns('complaints.views.traditional',
        url(r'^$', 'index', name='complaints_index'),
        url(r'^create/$', 'edit', name='complaints_create'),
        url(r'^(?P<complaint_id>\d+)/edit/$', 'edit', name='complaints_edit'),
        url(r'^(?P<complaint_id>\d+)/delete/$', 'delete', name='complaints_delete'),
    )

########NEW FILE########
__FILENAME__ = traditional
from django.http import HttpResponseRedirect, Http404
from django.shortcuts import render_to_response
from django.template import RequestContext

from complaints.forms import ComplaintForm
from complaints.models import Complaint

def index(request):
    complaints = Complaint.objects.pluggable_object(request)
    form = ComplaintForm()
    return render_to_response(request.pluggable.config.get('template', 'complaints/index.html'), {
        'complaints': complaints,
        'form': form,
        'base_template': request.pluggable.config.get('base_template', 'base.html'),
        }, context_instance=RequestContext(request))

def edit(request, complaint_id=None):
    if complaint_id is not None:
        try:
            complaint = Complaint.objects.pluggable_object(request).get(pk=complaint_id)
        except Complaint.DoesNotExist:
            raise Http404
    else:
        complaint = None

    if request.method == 'POST':
        form = ComplaintForm(request.POST, instance=complaint)
        if form.is_valid():
            complaint = form.save(request)
            return HttpResponseRedirect(pluggable_reverse(request, 'complaints_index'))
    else:
        form = ComplaintForm(instance=complaint)

    return render_to_response(request.pluggable.config.get('template', 'complaints/edit.html'), {
        'form': form,
        'base_template': request.pluggable.config.get('base_template', 'base.html'),
        }, context_instance=RequestContext(request))

def delete(request, complaint_id):
    try:
        complaint = Complaint.objects.pluggable_object(request).get(pk=complaint_id)
    except Complaint.DoesNotExist:
        raise Http404

    complaint.delete()

    return HttpResponseRedirect(pluggable_reverse(request, 'complaints_index'))

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from sillywalks.models import SillyWalk

class SillyWalkAdmin(admin.ModelAdmin):
    prepopulated_fields = {"slug": ("title",)}

admin.site.register(SillyWalk, SillyWalkAdmin)

########NEW FILE########
__FILENAME__ = forms
from django import forms
from sillywalks.models import SillyWalk

class SillyWalkForm(forms.ModelForm):
    class Meta:
        model = SillyWalk
        exclude = ('slug',)

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import sys
import os

import settings
from django.core import management

if __name__ == "__main__":
    management.execute_manager(settings)

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.template.defaultfilters import slugify

class SillyWalk(models.Model):
    title = models.CharField(max_length=100)
    slug = models.SlugField(unique=True)
    description = models.TextField()
    video_url = models.URLField()

    def __unicode__(self):
        return self.title

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.title)
        super(SillyWalk, self).save(*args, **kwargs)

########NEW FILE########
__FILENAME__ = settings
DEBUG = True
ROOT_URLCONF = 'sillywalks.urls'
INSTALLED_APPS = (
    'complaints',
    'pluggables',
    'sillywalks',
    'django.contrib.auth',
    'django.contrib.admin',
    'django.contrib.sessions',
    'django.contrib.contenttypes',
    'uni_form',
)

import os
import shutil
db_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'db'))
DATABASE_NAME = os.path.join(db_root, '.database.db')
if not os.path.exists(DATABASE_NAME) and os.path.exists(os.path.join(db_root, 'database.db')):
    shutil.copyfile(os.path.join(db_root, 'database.db'), DATABASE_NAME)
DATABASE_ENGINE = 'sqlite3'
DATABASE_USER = ''
DATABASE_PASSWORD = ''
DATABASE_HOST = ''
DATABASE_PORT = ''
DATABASE_OPTIONS = {}

ADMIN_MEDIA_PREFIX = '/django-admin-media/'
MEDIA_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'media'))
SITE_SERVER_URL = 'http://127.0.0.1:8000'
MEDIA_SERVER_URL = SITE_SERVER_URL
SITE_RELATIVE_URL = '/'
MEDIA_RELATIVE_URL = '%smedia/' % SITE_RELATIVE_URL
SITE_URL = '%s%s' % (SITE_SERVER_URL, SITE_RELATIVE_URL)
MEDIA_URL = '%s%s' % (MEDIA_SERVER_URL, MEDIA_RELATIVE_URL)

TEMPLATE_CONTEXT_PROCESSORS = (
    'django.core.context_processors.request',
    'django.core.context_processors.debug',
    'django.core.context_processors.auth',
    'django.core.context_processors.media',
    'pluggables.pluggable_context_processor',
)

MIDDLEWARE_CLASSES = (
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.middleware.transaction.TransactionMiddleware',
)

########NEW FILE########
__FILENAME__ = urls
from django.conf import settings
from django.conf.urls.defaults import url, include, patterns, handler404, handler500
from django.contrib import admin

from complaints.views import ComplaintsApp
from sillywalks import views

admin.autodiscover()

urlpatterns = patterns('',
    url('^$', 'django.views.generic.simple.direct_to_template', {'template': 'index.html'}, name='index'),
    url('^complaints/', include(ComplaintsApp())),
)

urlpatterns += patterns('',
    url('^sillywalks/$', views.index, name='sillywalks_index'),
    url('^sillywalks/create/$', views.edit, name='sillywalks_create'),
    url('^sillywalks/(?P<walk_slug>[\w\-_]+)/$', views.view, name='sillywalks_view'),
    url('^sillywalks/(?P<walk_slug>[\w\-_]+)/edit/$', views.edit, name='sillywalks_edit'),
    url('^sillywalks/(?P<walk_slug>[\w\-_]+)/delete/$', views.delete, name='sillywalks_delete'),
    url('^sillywalks/(?P<walk_slug>[\w\-_]+)/complaints/', include(views.complaints_app)),
)

urlpatterns += patterns('',
    url('^django-admin/', include(admin.site.urls)),
)

if settings.DEBUG:
    from django.views.static import serve
    urlpatterns += patterns('', (r'^media/(?P<path>.*)$', serve, {'document_root': settings.MEDIA_ROOT}))

########NEW FILE########
__FILENAME__ = views
from django.core.urlresolvers import resolve, reverse
from django.http import Http404, HttpResponseRedirect
from django.shortcuts import render_to_response
from django.template import RequestContext

from complaints.views import ComplaintsApp
from sillywalks.forms import SillyWalkForm
from sillywalks.models import SillyWalk

def index(request):
    sillywalks = SillyWalk.objects.all()
    return render_to_response('sillywalks/index.html', {
        'sillywalks': sillywalks,
        }, context_instance=RequestContext(request))

def view(request, walk_slug):
    return complaints_app.index(request, walk_slug=walk_slug)

def edit(request, walk_slug=None):
    try:
        sillywalk = SillyWalk.objects.get(slug=walk_slug)
    except SillyWalk.DoesNotExist:
        sillywalk = None

    if request.method == 'POST':
        form = SillyWalkForm(request.POST, instance=sillywalk)
        if form.is_valid():
            sillywalk = form.save()
            return HttpResponseRedirect(reverse('sillywalks_view', args=[sillywalk.slug]))
    else:
        form = SillyWalkForm(instance=sillywalk)

    return render_to_response('sillywalks/edit.html', {
        'sillywalk': sillywalk,
        'form': form,
        }, context_instance=RequestContext(request))

def delete(request, walk_slug):
    try:
        sillywalk = SillyWalk.objects.get(slug=walk_slug)
    except SillyWalk.DoesNotExist:
        raise Http404

    sillywalk.delete()

    return HttpResponseRedirect(reverse('sillywalks_index'))

class SillyWalkComplaintsApp(ComplaintsApp):
    def pluggable_config(self, request, walk_slug=None):
        return {'base_template': 'sillywalks/view.html'}

    def pluggable_view_context(self, request, walk_slug):
        try:
            sillywalk = SillyWalk.objects.get(slug=walk_slug)
        except SillyWalk.DoesNotExist:
            raise Http404
        return sillywalk

    def pluggable_template_context(self, request, walk_slug):
        return {'sillywalk': request.pluggable.view_context}

complaints_app = SillyWalkComplaintsApp('sillywalks')

########NEW FILE########
__FILENAME__ = fabfile
import os
import glob
from fabric import local
import sys

LOCAL_PACKAGES = (
    'examples',
    '',
)

PROJECT_ROOT = os.path.abspath(os.path.curdir)
PY_VERSION = 'python%s.%s' % (sys.version_info[0], sys.version_info[1])

def bootstrap():
    # Create new virtual environment in a new location. We will atomically swap the current virtualenv with the new once at the end of this process.
    local("rm -Rf .ve~/")

    local('virtualenv .ve~')

    # hack activate so it uses project directory instead of ve in prompt
    local('sed \'s/(`basename \\\\"\\$VIRTUAL_ENV\\\\\"`)/(`basename \\\\`dirname \\\\"$VIRTUAL_ENV\\\\"\\\\``)/g\' .ve~/bin/activate > .ve~/bin/activate.tmp')
    local('mv .ve~/bin/activate.tmp .ve~/bin/activate')

    # PIP install requirements
    local("pip install -I --source=.ve~/src/ --environment=.ve~/ -r REQUIREMENTS")

    # Cleanup pip install process
    local("rm -Rf build/")

    # Add local src folders to python path.
    local("echo '%s' >> .ve~/lib/%s/site-packages/easy-install.pth" % ('\n'.join([ os.path.join(PROJECT_ROOT, x) for x in LOCAL_PACKAGES ]), PY_VERSION))

    # Apply patches.
    for patch in glob.glob(os.path.join(PROJECT_ROOT, 'dist', 'patches', '*.patch')):
        dirname, filename = os.path.split(patch)
        application_name = filename.split('.patch')[0]
        application_path = os.path.join(PROJECT_ROOT, '.ve~', 'src', application_name)
        if os.path.exists(application_path):
            print 'Patching %s...' % application_name
            local("cd %s; patch -p0 < %s" % (application_path, patch))

    # Cleanup and .pyc files that got generated so that we do not have any corrupt pyc files hanging out with the .ve~ path.
    local("find .ve~/ -type f -name '*.pyc' -print0 | xargs -0 rm -f")
    # Prepare the temporary virtualenv to take the place of the primary virtualenv by replacing the paths
    local("find .ve~/ -type f -print0 | xargs -0 sed -i 's/\.ve~/ve/g'")
    # Atomically move the new virtualenv into place, and move the old virtualenv into a backup location.
    local("mv ve/ .ve.old~/ 2> /dev/null; mv .ve~/ ve/")

def documentation():
    local("rm -Rf docs/modules/")
    local("rm -Rf docs/_build/html/")
    local("DJANGO_SETTINGS_MODULE=sillywalks.settings ve/bin/sphinx-build -aE docs/ docs/_build/html/")
    print "View the documentation here: file://%s" % os.path.join(PROJECT_ROOT, 'docs', '_build', 'html', 'index.html')

########NEW FILE########
__FILENAME__ = models
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes import generic
from django.db import models
from django.http import HttpRequest
from pluggables.utils.picklefield import PickledObjectField


class PluggableManager(models.Manager):
    def pluggable(self, request):
        return self.filter(pluggable_url=request.pluggable.pluggable_url_data)


class PluggableModel(models.Model):
    pluggable_url = PickledObjectField(blank=True)

    objects = PluggableManager()

    def save(self, request, *args, **kwargs):
        if request:
            self.pluggable_url = request.pluggable.pluggable_url_data
        super(PluggableModel, self).save(*args, **kwargs)

    class Meta:
        abstract = True


class PluggableObjectManager(PluggableManager):
    def pluggable_object(self, request):
        if request.pluggable.view_context is None:
            return self.filter(pluggable_content_type__isnull=True, pluggable_object_id__isnull=True)
        else:
            content_type = ContentType.objects.get_for_model(request.pluggable.view_context)
            return self.filter(pluggable_content_type=content_type, pluggable_object_id=request.pluggable.view_context.pk)


class PluggableObjectModel(PluggableModel):
    pluggable_content_type = models.ForeignKey(ContentType, null=True, blank=True)
    pluggable_object_id = models.PositiveIntegerField(null=True, blank=True)

    pluggable_object = generic.GenericForeignKey(fk_field='pluggable_object_id', ct_field='pluggable_content_type')

    objects = PluggableObjectManager()

    def save(self, request, *args, **kwargs):
        if request:
            self.pluggable_object = request.pluggable.view_context
        super(PluggableObjectModel, self).save(request, *args, **kwargs)

    class Meta:
        abstract = True

########NEW FILE########
__FILENAME__ = pluggables
from django.template import Node, Library
from django.conf import settings
from django.core.urlresolvers import reverse, NoReverseMatch
from django.utils.encoding import smart_str

register = Library()


class PluggableURLNode(Node):
    def __init__(self, request, view_name, args, kwargs, asvar):
        self.request = request
        self.view_name = view_name
        self.args = args
        self.kwargs = kwargs
        self.asvar = asvar

    def render(self, context):
        args = [arg.resolve(context) for arg in self.args]
        kwargs = dict([(smart_str(k, 'ascii'), v.resolve(context)) for k, v in self.kwargs.items()])

        request = self.request.resolve(context)
        view_name = self.view_name
        if hasattr(request, 'pluggable'):
            view_name = request.pluggable.prefix and '%s_%s' % (request.pluggable.prefix, self.view_name) or '%s' % self.view_name
            parent_args, parent_kwargs = request.pluggable.parent_arguments
            if parent_args:
                args = parent_args + args
            if parent_kwargs:
                kwargs.update(parent_kwargs)

        # Try to look up the URL twice: once given the view name, and again
        # relative to what we guess is the "main" app. If they both fail,
        # re-raise the NoReverseMatch unless we're using the
        # {% url ... as var %} construct in which cause return nothing.
        url = ''
        try:
            url = reverse(view_name, args=args, kwargs=kwargs)
        except NoReverseMatch:
            project_name = settings.SETTINGS_MODULE.split('.')[0]
            try:
                url = reverse(project_name + '.' + view_name,
                              args=args, kwargs=kwargs)
            except NoReverseMatch:
                if self.asvar is None:
                    raise

        if self.asvar:
            context[self.asvar] = url
            return ''
        else:
            return url


def pluggable_url(parser, token):
    """
    Returns an absolute URL matching given view with its parameters.

    This is a way to define links that aren't tied to a particular URL
    configuration::

        {% url path.to.some_view arg1,arg2,name1=value1 %}

    The first argument is a path to a view. It can be an absolute python path
    or just ``app_name.view_name`` without the project name if the view is
    located inside the project.  Other arguments are comma-separated values
    that will be filled in place of positional and keyword arguments in the
    URL. All arguments for the URL should be present.

    For example if you have a view ``app_name.client`` taking client's id and
    the corresponding line in a URLconf looks like this::

        ('^client/(\d+)/$', 'app_name.client')

    and this app's URLconf is included into the project's URLconf under some
    path::

        ('^clients/', include('project_name.app_name.urls'))

    then in a template you can create a link for a certain client like this::

        {% url app_name.client client.id %}

    The URL will look like ``/clients/client/123/``.
    """
    bits = token.contents.split(' ')
    if len(bits) < 2:
        raise TemplateSyntaxError("'%s' takes at least one argument"
                                  " (path to a view)" % bits[0])
    request = parser.compile_filter('request')
    viewname = bits[1]
    args = []
    kwargs = {}
    asvar = None

    if len(bits) > 2:
        bits = iter(bits[2:])
        for bit in bits:
            if bit == 'as':
                asvar = bits.next()
                break
            else:
                for arg in bit.split(","):
                    if '=' in arg:
                        k, v = arg.split('=', 1)
                        k = k.strip()
                        kwargs[k] = parser.compile_filter(v)
                    elif arg:
                        args.append(parser.compile_filter(arg))
    return PluggableURLNode(request, viewname, args, kwargs, asvar)
pluggable_url = register.tag(pluggable_url)

########NEW FILE########
__FILENAME__ = picklefield
"""
Original attribution from http://www.djangosnippets.org/snippets/1694/
"""

from copy import deepcopy
from base64 import b64encode, b64decode
from zlib import compress, decompress
try:
    from cPickle import loads, dumps
except ImportError:
    from pickle import loads, dumps

from django.db import models
from django.utils.encoding import force_unicode


class PickledObject(str):
    """
    A subclass of string so it can be told whether a string is a pickled
    object or not (if the object is an instance of this class then it must
    [well, should] be a pickled one).

    Only really useful for passing pre-encoded values to ``default``
    with ``dbsafe_encode``, not that doing so is necessary. If you
    remove PickledObject and its references, you won't be able to pass
    in pre-encoded values anymore, but you can always just pass in the
    python objects themselves.

    """
    pass


def dbsafe_encode(value, compress_object=False):
    """
    We use deepcopy() here to avoid a problem with cPickle, where dumps
    can generate different character streams for same lookup value if
    they are referenced differently.

    The reason this is important is because we do all of our lookups as
    simple string matches, thus the character streams must be the same
    for the lookups to work properly. See tests.py for more information.
    """
    if not compress_object:
        value = b64encode(dumps(deepcopy(value)))
    else:
        value = b64encode(compress(dumps(deepcopy(value))))
    return PickledObject(value)


def dbsafe_decode(value, compress_object=False):
    if not compress_object:
        value = loads(b64decode(value))
    else:
        value = loads(decompress(b64decode(value)))
    return value


class PickledObjectField(models.Field):
    """
    A field that will accept *any* python object and store it in the
    database. PickledObjectField will optionally compress it's values if
    declared with the keyword argument ``compress=True``.

    Does not actually encode and compress ``None`` objects (although you
    can still do lookups using None). This way, it is still possible to
    use the ``isnull`` lookup type correctly. Because of this, the field
    defaults to ``null=True``, as otherwise it wouldn't be able to store
    None values since they aren't pickled and encoded.

    """
    __metaclass__ = models.SubfieldBase

    def __init__(self, *args, **kwargs):
        self.compress = kwargs.pop('compress', False)
        self.protocol = kwargs.pop('protocol', 2)
        kwargs.setdefault('null', True)
        kwargs.setdefault('editable', False)
        super(PickledObjectField, self).__init__(*args, **kwargs)

    def get_default(self):
        """
        Returns the default value for this field.

        The default implementation on models.Field calls force_unicode
        on the default, which means you can't set arbitrary Python
        objects as the default. To fix this, we just return the value
        without calling force_unicode on it. Note that if you set a
        callable as a default, the field will still call it. It will
        *not* try to pickle and encode it.

        """
        if self.has_default():
            if callable(self.default):
                return self.default()
            return self.default
        # If the field doesn't have a default, then we punt to models.Field.
        return super(PickledObjectField, self).get_default()

    def to_python(self, value):
        """
        B64decode and unpickle the object, optionally decompressing it.

        If an error is raised in de-pickling and we're sure the value is
        a definite pickle, the error is allowed to propogate. If we
        aren't sure if the value is a pickle or not, then we catch the
        error and return the original value instead.

        """
        if value is not None:
            try:
                value = dbsafe_decode(value, self.compress)
            except:
                # If the value is a definite pickle; and an error is raised in
                # de-pickling it should be allowed to propogate.
                if isinstance(value, PickledObject):
                    raise
        return value

    def get_db_prep_value(self, value):
        """
        Pickle and b64encode the object, optionally compressing it.

        The pickling protocol is specified explicitly (by default 2),
        rather than as -1 or HIGHEST_PROTOCOL, because we don't want the
        protocol to change over time. If it did, ``exact`` and ``in``
        lookups would likely fail, since pickle would now be generating
        a different string.

        """
        if value is not None and not isinstance(value, PickledObject):
            # We call force_unicode here explicitly, so that the encoded string
            # isn't rejected by the postgresql_psycopg2 backend. Alternatively,
            # we could have just registered PickledObject with the psycopg
            # marshaller (telling it to store it like it would a string), but
            # since both of these methods result in the same value being stored,
            # doing things this way is much easier.
            value = force_unicode(dbsafe_encode(value, self.compress))
        return value

    def value_to_string(self, obj):
        value = self._get_val_from_obj(obj)
        return self.get_db_prep_value(value)

    def get_internal_type(self):
        return 'TextField'

    def get_db_prep_lookup(self, lookup_type, value):
        if lookup_type not in ['exact', 'in', 'isnull']:
            raise TypeError('Lookup type %s is not supported.' % lookup_type)
        # The Field model already calls get_db_prep_value before doing the
        # actual lookup, so all we need to do is limit the lookup types.
        return super(PickledObjectField, self).get_db_prep_lookup(lookup_type, value)

########NEW FILE########
