__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# git-codereview documentation build configuration file, created by
# sphinx-quickstart on Thu Dec 31 10:38:41 2009.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'git-codereview'
copyright = u'2009, Nowell Strike, Thibaud Morel l\'Horset'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'git-codereviewdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'git-codereview.tex', u'git-codereview Documentation',
   u'Nowell Strike, Thibaud Morel l\'Horset', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = asciitable
import math

from gitgoggles.utils import force_unicode, force_str, console, colored

class AsciiCell(object):
    def __init__(self, value, color=None, background=None, reverse=False, width=None, align='left', resizable=False):
        self.value = force_unicode(value)
        self.color = color
        self.align = align
        self.resizable = resizable
        self.background = background
        self.attrs = reverse and ['reverse'] or []
        self.width = width and int(width) or len(self.value)

    def lines(self):
        if self.width:
            return int(math.ceil(len(self.value) / float(self.width)))
        return self.width
    lines = property(lines)

    def line(self, num):
        return self.value[num * self.width:(1 + num) * self.width]

    def pad(self, text, width):
        if self.align == 'right':
            return text.rjust(width)
        elif self.align == 'center':
            return text.center(width)
        else:
            return text.ljust(width)

class AsciiRow(object):
    def __init__(self, *cells):
        super(AsciiRow, self).__init__()
        self.cells = [ isinstance(x, AsciiCell) and x or AsciiCell(x) for x in cells ]

    def lines(self):
        return max([ x.lines for x in self.cells ])
    lines = property(lines)

    def __getitem__(self, index):
        return self.cells[index]

    def __iter__(self):
        for cell in self.cells:
            yield cell

    def __len__(self):
        return len(self.cells)

class AsciiTable(object):
    def __init__(self, headers, left_padding=None, right_padding=None, horizontal_rule=True, max_width=None, border_characters=[u'+', u'|', u'-']):
        self.headers = AsciiRow(*headers)
        self.rows = []
        self._widths = [ x.width for x in self.headers ]
        self.left_padding = left_padding and int(left_padding) or 0
        self.right_padding = right_padding and int(right_padding) or 0
        self.horizontal_rule = horizontal_rule
        self.max_width = max_width
        self.border_corner = border_characters[0]
        self.border_vertical = border_characters[1]
        self.border_horizontal = border_characters[2]

    def add_row(self, data):
        if len(data) != len(self.headers):
            raise Exception('The number of columns in a row must be equal to the header column count.')
        self.rows.append(AsciiRow(*data))

    def __str__(self):
        self.__unicode__()

    def __unicode__(self):
        self._print()

    def _print_horizontal_rule(self):
        if self.border_corner or self.border_horizontal:
            console(self.border_corner)
            for column, width in zip(self.headers, self._widths):
                console(self.border_horizontal * (self.right_padding + self.left_padding + width))
                console(self.border_corner)
            console(u'\n')

    def _print_headers(self):
        self._print_horizontal_rule()
        self._print_row(self.headers)
        self._print_horizontal_rule()

    def _print_rows(self):
        for row in self.rows:
            self._print_row(row)
            if self.horizontal_rule:
                self._print_horizontal_rule()

    def _print_row(self, row):
        for line in xrange(row.lines):
            console(self.border_vertical)
            for cell, width in zip(row, self._widths):
                console(colored(u' ' * self.left_padding + cell.pad(cell.line(line), width) + u' ' * self.right_padding, cell.color, cell.background, attrs=cell.attrs))
                console(self.border_vertical)
            console(u'\n')

    def render(self):
        self._calculate_widths()

        self._print_headers()
        self._print_rows()
        if not self.horizontal_rule:
            self._print_horizontal_rule()

    def _calculate_widths(self):
        for row in self.rows:
            for column, cell in enumerate(row):
                self._widths[column] = max(self._widths[column], cell.width)

        width = sum([ x for x in self._widths ]) + ((self.left_padding + self.right_padding) * len(self._widths)) + len(self._widths) + 1
        if self.max_width and width > self.max_width:
            difference = width - self.max_width
            # TODO: being lazy right now, but should recalculate resizable columns widths based on percentage of current length (longer columns give up more)
            self._widths[1] = max(self._widths[1] - difference, 5)
            for row in self.rows + [ self.headers ]:
                row[1].width = self._widths[1]

########NEW FILE########
__FILENAME__ = codereview
import datetime
import subprocess
import itertools
import sys

from gitgoggles.asciitable import AsciiTable, AsciiCell
from gitgoggles.git import Repository, TrackingBranch, LocalBranch, PublishedBranch, TrackedBranch
from gitgoggles.utils import colored, terminal_dimensions, console
from gitgoggles.progress import handler

def get_status():
    repo = Repository()

    console(colored('# Working Tree: ', 'magenta'))
    console(colored(repo.branch(), 'cyan'))
    console(u'\n')

    uncommitted, changed, untracked, stashed = repo.status()
    if uncommitted or changed or untracked or stashed:
        table = AsciiTable(['', ''], 2, 0, False, border_characters=[u'', u'', u''])

        if uncommitted:
            table.add_row([
                AsciiCell('Uncommitted', 'green'),
                AsciiCell(str(len(uncommitted)), align='right'),
                ])

        if changed:
            table.add_row([
                AsciiCell('Changed', 'red'),
                AsciiCell(str(len(changed)), align='right'),
                ])

        if untracked:
            table.add_row([
                AsciiCell('Untracked', 'yellow'),
                AsciiCell(str(len(untracked)), align='right'),
                ])

        if stashed:
            table.add_row([
                AsciiCell('Stashed', 'cyan'),
                AsciiCell(str(len(stashed)), align='right'),
                ])

        table.render()

    console('\n')

    handler.uncapture_stdout()
    handler.capture_stdout()

    if repo.configs.get('gitgoggles.fetch', 'true') != 'false':
        repo.fetch()

    git_refs = repo.branches(LocalBranch, TrackedBranch, TrackingBranch, PublishedBranch)
    tags = repo.tags()

    BRANCH_WIDTH = repo.configs.get('gitgoggles.table.branch-width')
    LEFT_PADDING = repo.configs.get('gitgoggles.table.left-padding', 0)
    RIGHT_PADDING = repo.configs.get('gitgoggles.table.right-padding', 0)
    HORIZONTAL_RULE = repo.configs.get('gitgoggles.table.horizontal-rule', 'false') != 'false'

    TERMINAL_ROWS, TERMINAL_COLUMNS = terminal_dimensions()

    table = AsciiTable([
        AsciiCell('Branch', width=BRANCH_WIDTH, resizable=True),
        AsciiCell('Ahead', align='right'),
        AsciiCell('Behind', align='right'),
        AsciiCell('Pull'),
        AsciiCell('Push'),
        AsciiCell('Mod', align='right'),
        ], LEFT_PADDING, RIGHT_PADDING, HORIZONTAL_RULE, TERMINAL_COLUMNS)

    if repo.configs.get('gitgoggles.colors', 'true') == 'false':
        colored.disabled = True

    icons = {
        'unknown': repo.configs.get('gitgoggles.icons.unknown', u'\u203D'),
        'success': repo.configs.get('gitgoggles.icons.success', u'\u2714'),
        'failure': repo.configs.get('gitgoggles.icons.failure', u'\u2718'),
        }
    colors = {
        'local': repo.configs.get('gitgoggles.colors.local', 'cyan'),
        'new': repo.configs.get('gitgoggles.colors.new', 'red'),
        'review': repo.configs.get('gitgoggles.colors.review', 'red'),
        'merge': repo.configs.get('gitgoggles.colors.merge', 'yellow'),
        'done': repo.configs.get('gitgoggles.colors.done', 'green'),
        }

    key_func = lambda x: x.shortname
    git_refs = sorted(git_refs, key=key_func)
    groups = [ [x, list(y)] for x, y in itertools.groupby(git_refs, key_func) ]

    if repo.configs.get('gitgoggles.sorted', 'age') == 'age':
        groups = reversed(sorted(groups, key=lambda refs: min([ x.modified.date() for x in refs[1] ])))
    else:
        groups = sorted(groups, key=lambda refs: refs[0])

    for name, git_refs in groups:
        for ref in git_refs:
            if repo.configs.get('gitgoggles.ignore.%s' % ref.shortname, 'false') == 'true':
                continue

            color = 'red'
            ahead_commits = ref.ahead
            behind_commits = ref.behind
            pull = ref.pull
            push = ref.push

            if ref.__class__ == LocalBranch:
                color = colors['local']
            else:
                if ahead_commits:
                    color = colors['merge']
                else:
                    color = colors['done']

            ahead = bool(ahead_commits) or None
            behind = bool(behind_commits) or None
            tracked = ref.__class__ in (TrackingBranch, LocalBranch, TrackedBranch)

            ahead_text, ahead_color = ahead_commits is not None and (u'%s ahead' % ahead_commits, ahead and color) or (icons['unknown'], 'yellow',)
            behind_text, behind_color = behind_commits is not None and (u'%s behind' % behind_commits, behind and color) or (icons['unknown'], 'yellow',)

            pull_text, pull_color = not tracked and (icons['unknown'], 'yellow',) or (pull and (icons['failure'], 'red',) or (icons['success'], 'green',))
            push_text, push_color = not tracked and (icons['unknown'], 'yellow',) or (push and (icons['failure'], 'red',) or (icons['success'], 'green',))

            delta = datetime.date.today() - ref.modified.date()
            if delta <= datetime.timedelta(days=1):
                modified_color = 'cyan'
            elif delta <= datetime.timedelta(days=7):
                modified_color = 'green'
            elif delta < datetime.timedelta(days=31):
                modified_color = 'yellow'
            else:
                modified_color = 'red'

            ahead_color = behind_color = modified_color

            table.add_row([
                AsciiCell(ref.name, width=BRANCH_WIDTH, resizable=True),
                AsciiCell(ahead_text, ahead_color, reverse=ahead, align='right'),
                AsciiCell(behind_text, behind_color, reverse=behind, align='right'),
                AsciiCell(pull_text, pull_color, align='center'),
                AsciiCell(push_text, push_color, align='center'),
                AsciiCell(ref.timedelta, modified_color, align='right'),
                ])

    table.render()

def update_branches():
    repo = Repository()

    if repo.configs.get('gitgoggles.fetch', 'true') != 'false':
        repo.fetch()

    branch = repo.branch()
    refs = repo.branches(TrackingBranch)
    for branch in refs:
        if branch.pull:
            repo.shell('git', 'checkout', branch.name)
            repo.shell('git', 'pull')

########NEW FILE########
__FILENAME__ = git
import datetime
import os
import re
import subprocess

from gitgoggles.progress import log
from gitgoggles.utils import AccumulatorDict, memoize, force_unicode, force_str, console

def log_activity(func):
    def _(self, *args, **kwargs):
        log.info('Processing %s' % self.name)
        return func(self, *args, **kwargs)
    return _

class Ref(object):
    def __new__(cls, repo, sha, refspec):
        if cls != Ref:
            return object.__new__(cls)

        ref_type, name = refspec[5:].partition("/")[0::2]
        if ref_type in ('heads', 'remotes',):
            return Branch(repo, sha, refspec)
        elif ref_type in ('tags',):
            return Tag(repo, sha, refspec)
        return object.__new__(cls)

    def __init__(self, repo, sha, refspec):
        self.repo = repo
        self.refspec = refspec
        self.sha = sha

        self.ref_type, self.name = refspec[5:].partition("/")[0::2]
        self.shortname = re.match('^origin\/', self.name) and self.name.partition("/")[2] or self.name

    def modified(self):
        try:
            timestamp = float(self.repo.shell('git', 'log', '--no-merges', '-1', '--pretty=format:%at', '%s..%s' % (self.repo.master, self.refspec)).split[0].strip())
        except IndexError:
            timestamp = float(self.repo.shell('git', 'log', '--no-merges', '-1', '--pretty=format:%at', self.refspec).split[0].strip())
        return datetime.datetime.fromtimestamp(timestamp)
    modified = property(log_activity(memoize(modified)))

    def timedelta(self):
        delta = datetime.datetime.now() - self.modified
        if delta.days > 365:
            return '-%sy' % round(delta.days / 365.0, 1)
        elif delta.days >= 1:
            return '-%sd' % delta.days
        elif delta.seconds >= 3600:
            return '-%sh' % (delta.seconds / 3600)
        else:
            return '-%sm' % (delta.seconds / 60)
    timedelta = property(timedelta)

    def __unicode__(self):
        return '<%s %s>' % (self.__class__.__name__, self.name)

    def __str__(self):
        return self.__unicode__()

    def __repr__(self):
        return self.__unicode__()

class Branch(Ref):
    display_name = 'Branch'

    def __new__(cls, repo, sha, refspec):
        if cls != Branch:
            return object.__new__(cls)

        # This is a local branch, see if it is a tracking branch or a local branch
        if refspec.startswith('refs/heads/'):
            remote = repo.configs.get('branch.%s.remote' % '/'.join(refspec.split('/')[2:]), '.')
            remote = remote != '.' and remote or None
            if remote is None:
                cls = LocalBranch
            else:
                cls = TrackingBranch
        # This is a remote branch, see if it is a tracked branch or a published branch
        else:
            if refspec in repo.branch_parents.keys():
                cls = TrackedBranch
            else:
                cls = PublishedBranch
        return object.__new__(cls)

    def __init__(self, *args, **kwargs):
        super(Branch, self).__init__(*args, **kwargs)
        self.parent_refspec = self.repo.branch_parents.get(self.refspec, self.refspec)
        log.info('Processing %s' % self.name)
        # TODO: find a better way to determine parent refspec
        # Find the common merge ancestor to show ahead/behind statistics.
        self.merge_refspec = None
        if self.repo.master_sha:
            merge_refspec = self.repo.shell('git', 'merge-base', self.repo.master_sha, self.sha).split
            if merge_refspec:
                self.merge_refspec = merge_refspec[0].strip()

    def pull(self):
        return bool(self.repo.shell('git', 'log', '--pretty=format:%H', '%s..%s' % (self.refspec, self.parent_refspec)).split)
    pull = property(log_activity(memoize(pull)))

    def push(self):
        return bool(self.repo.shell('git', 'log', '--pretty=format:%H', '%s..%s' % (self.parent_refspec, self.refspec)).split)
    push = property(log_activity(memoize(push)))

    def ahead(self):
        if self.merge_refspec:
            return len(self.repo.shell('git', 'log', '--no-merges', '--pretty=format:%H', '%s..%s' % (self.repo.master, self.refspec)).split)
        return None
    ahead = property(log_activity(memoize(ahead)))

    def behind(self):
        if self.merge_refspec:
            # TODO: find a better way to determine how fare behind we are from our branch "parent"
            return len(self.repo.shell('git', 'log', '--no-merges', '--pretty=format:%H', '%s..%s' % (self.refspec, self.repo.master)).split)
        return None
    behind = property(log_activity(memoize(behind)))

    @property
    def tracking(self):
        return None

class LocalBranch(Branch):
    """
    A local branch that is not tracking a published branch.
    """
    display_name = 'Local'

    def push(self):
        return False
    push = property(push)

    def pull(self):
        return False
    pull = property(pull)

class PublishedBranch(Branch):
    """
    A branch on a remote server that is not being tracked locally.
    """
    display_name = 'Remote'

class TrackingBranch(PublishedBranch):
    """
    A local branch that is tracking a published branch.
    """
    display_name = 'Tracking'

    @property
    def tracking(self):
        return True

class TrackedBranch(PublishedBranch):
    """
    A branch on a remote server that is being tracked locally.
    """
    display_name = 'Tracked'

    @property
    def tracking(self):
        return True

class Tag(Ref):
    pass

class Repository(object):
    def __init__(self, path=None):
        self.path = os.path.abspath(path or os.path.curdir)
        # Hack, make configurable
        try:
            self.master = 'origin/master'
            master_sha = self.shell('git', 'log', '-1', '--pretty=format:%H', self.master, exceptions=True).split
        except:
            self.master = 'master'
            master_sha = self.shell('git', 'log', '-1', '--pretty=format:%H', self.master).split
        self.master_sha = master_sha and master_sha[0].strip() or ''

    def shell(self, *args, **kwargs):
        exceptions = kwargs.pop('exceptions', False)
        join = kwargs.pop('join', False)

        if kwargs:
            raise Exception('Unsupported kwargs provided to function.')

        log.debug(' '.join(args))

        if join:
            process = subprocess.Popen(args, cwd=self.path)
            process.communicate()
        else:
            process = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, cwd=self.path)
            stdout, stderr = process.communicate()
            process.stdout = stdout and force_unicode(stdout.strip()) or u''
            process.stderr = stderr and force_unicode(stderr.strip()) or u''
            process.split = filter(lambda x: x, map(lambda x: x.strip(), process.stdout.split(u'\n')))

            if process.returncode != 0:
                message = '%s: %s: %s' % (process.returncode, process.stderr, process.stdout)
                log.debug(message)
                if exceptions:
                    raise Exception(message)

            return process

    def status(self):
        UNCOMMITTED_RE = re.compile(r'^[MDA]')
        CHANGED_RE = re.compile(r'^ [MDA]')
        UNTRACKED_RE = re.compile(r'^\?\?')
        uncommitted, changed, untracked, stashed = [], [], [], []
        for entry in self.shell('git', 'status', '--porcelain').split:
            filename = entry[3:]
            if UNCOMMITTED_RE.match(entry):
                uncommitted.append(filename)
            elif CHANGED_RE.match(entry):
                changed.append(filename)
            elif UNTRACKED_RE.match(entry):
                untracked.append(filename)

        stashed = [ x for x in self.shell('git', 'stash', 'list').split if x ]

        return uncommitted, changed, untracked, stashed

    def configs(self):
        return dict([ x.partition('=')[0::2] for x in self.shell('git', 'config', '--list').split ])
    configs = property(memoize(configs))

    def fetch(self):
        log.info('Fetching updates.')
        self.shell('git', 'remote', 'update', '--prune')

    def remotes(self):
        log.info('Retreiving list of remotes')
        return self.shell('git', 'remote').split
    remotes = memoize(remotes)

    def refs(self):
        return [ Ref(self, *x.split()) for x in self.shell('git', 'show-ref').split ]
    refs = memoize(refs)

    def branches(self, *types):
        if types:
            return [ x for x in self.refs() if x.__class__ in types ]
        else:
            return [ x for x in self.refs() if isinstance(x, Branch) ]
    branches = memoize(branches)

    def tags(self):
        return [ x for x in self.refs() if isinstance(x, Tag) ]
    tags = memoize(tags)

    def branch(self):
        try:
            return '/'.join(self.shell('git', 'symbolic-ref', 'HEAD').stdout.split('/')[2:])
        except:
            return self.shell('git', 'rev-parse', '--short', 'HEAD').stdout

    def branch_parents(self):
        parents = {}
        for branch_refspec in [ x.split()[1] for x in self.shell('git', 'show-ref', '--heads').split ]:
            branch_name = '/'.join(branch_refspec.split('/')[2:])
            remote = self.configs.get('branch.%s.remote' % branch_name, '.')
            parent = self.configs.get('branch.%s.merge' % branch_name, '')
            if remote != '.' and parent:
                parent = 'refs/remotes/%s/%s' % (remote, '/'.join(parent.split('/')[2:]))
                parents[branch_refspec] = parent
                parents[parent] = branch_refspec
            else:
                parents[branch_refspec] = parent
        return parents
    branch_parents = property(memoize(branch_parents))

########NEW FILE########
__FILENAME__ = progress
import atexit
import logging
import StringIO
import sys
from gitgoggles.utils import console, force_unicode, force_str

class ProgressStreamHandler(logging.StreamHandler):
    def __init__(self, *args, **kwargs):
        self._stdout = sys.stdout
        self._capture_stdout = StringIO.StringIO()
        self.spinner = '-\\|/'
        self.msg = ''
        self.max_length = 0
        logging.StreamHandler.__init__(self, *args, **kwargs)

    def capture_stdout(self):
        self._stdout = sys.stdout
        sys.stdout = self._capture_stdout

    def uncapture_stdout(self):
        sys.__stdout__.write(''.ljust(self.max_length))
        sys.__stdout__.write('\r')
        sys.stdout = self._stdout
        console(force_unicode(self._capture_stdout.getvalue()))
        self._capture_stdout = StringIO.StringIO()

    def emit(self, record):
        if self.msg != record.msg:
            self.msg = record.msg
            msg = ' %s   %s' % (self.spinner[0], self.msg)
            self.max_length = max(len(msg), self.max_length)
            self.spinner = self.spinner[1:] + self.spinner[:1]
            sys.__stdout__.write(force_str(msg.ljust(self.max_length)))
            sys.__stdout__.write('\r')

handler = ProgressStreamHandler()

def enable_progress():
    log.addHandler(handler)
    log.setLevel(logging.INFO)
    handler.capture_stdout()
    atexit.register(handler.uncapture_stdout)

log = logging.getLogger('progress')

########NEW FILE########
__FILENAME__ = utils
import copy
import subprocess
import sys
import unicodedata

def disable_colored_func(text, *args, **kwargs):
    return text

try:
    from termcolor import colored as colored_func
except ImportError:
    print 'You should run "pip install termcolor" to fully utilize these utilities.'
    colored_func = disable_colored_func

def supports_color():
    """
    Returns True if the running system's terminal supports color, and False
    otherwise.
    """
    unsupported_platform = (sys.platform in ('win32', 'Pocket PC'))
    # isatty is not always implemented, #6223.
    is_a_tty = hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()
    if unsupported_platform or not is_a_tty:
        return False
    return True

if not supports_color():
    colored_func = disable_colored_func

class Colored(object):
    disabled = False
    def __call__(self, *args, **kwargs):
        if self.disabled:
            return disable_colored_func(*args, **kwargs)
        return colored_func(*args, **kwargs)

colored = Colored()

def force_unicode(obj, encoding='utf-8'):
    if isinstance(obj, basestring):
        if not isinstance(obj, unicode):
            obj = unicode(obj, encoding)
        # Normalize the unicode data to have characters that in NFKD format would be represented by 2 characters, instead of 1.
        obj = unicodedata.normalize('NFKC', obj)
    return obj

def force_str(obj, encoding='utf-8'):
    if isinstance(obj, basestring):
        if not isinstance(obj, str):
            obj = obj.encode(encoding)
    return obj

def console(obj):
    sys.stdout.write(force_str(obj))

class AccumulatorDict(dict):
    def __init__(self, default, *args, **kwargs):
        self.__default = default

    def __getitem__(self, key):
        if key not in self:
            self[key] = copy.copy(self.__default)
        return super(AccumulatorDict, self).__getitem__(key)

def memoize(func):
    def _(self, *args, **kwargs):
        if not hasattr(self, '__memoize_cache'):
            self.__memoize_cache = AccumulatorDict(AccumulatorDict({}))
        key = tuple([ tuple(args), tuple([ tuple([x, y]) for x, y in kwargs.items() ]) ])
        if key not in self.__memoize_cache[func]:
            self.__memoize_cache[func][key] = func(self, *args, **kwargs)
        return self.__memoize_cache[func][key]
    return _

def terminal_dimensions():
    try:
        # This probably does not work on windows, but it should work just about
        # everywhere else.
        p = subprocess.Popen(['stty', 'size'], stdout=subprocess.PIPE)
        (stdout, stderr) = p.communicate(None)
        stdout = force_unicode(stdout)
        stderr = force_unicode(stderr)
        rows, columns = [ int(x) for x in stdout.split() ]
    except:
        rows, columns = 40, 79
    return rows, columns

########NEW FILE########
