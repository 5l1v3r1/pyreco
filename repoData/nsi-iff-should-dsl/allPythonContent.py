__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Should-DSL documentation build configuration file, created by
# sphinx-quickstart on Wed Jun 23 10:10:24 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Should-DSL'
copyright = u'2010, Hugo Lopes Tavares'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '2.0'
# The full version, including alpha/beta/rc tags.
release = '2.0a3'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
#pygments_style = 'default'
#['manni', 'perldoc', 'borland', 'colorful', 'default', 'murphy', 'trac', 'fruity', 'autumn', 'bw', 'emacs', 'pastie', 'friendly', 'native']



# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'basic'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {
}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static', '_static/css']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
html_show_sphinx = False

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
html_show_copyright = False

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'Should-DSLdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Should-DSL.tex', u'Should-DSL Documentation',
   u'Hugo Lopes Tavares', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'should-dsl', u'Should-DSL Documentation',
     [u'Hugo Lopes Tavares'], 1)
]


########NEW FILE########
__FILENAME__ = run_all_examples
#!/usr/bin/env python
import os
import glob
from run_examples import run

def all_examples():
    documentation = glob.glob('docs/*.rst') + ['README.rst']
    doctests_path = os.path.join('should_dsl', 'doctests')
    doctests = list(map(lambda f: os.path.join(doctests_path, f),
        filter(lambda f: f.endswith('.txt'), os.listdir(doctests_path))))
    return documentation + doctests

if __name__ == '__main__':
    run(all_examples())


########NEW FILE########
__FILENAME__ = run_examples
#!/usr/bin/env python
import doctest
import unittest
import sys

def test_suite(docs):
    suite = unittest.TestSuite()
    for doc in docs:
        suite.addTest(doctest.DocFileSuite(doc, optionflags=flags()))
    return suite

def flags():
    flags = doctest.NORMALIZE_WHITESPACE|doctest.ELLIPSIS
    if sys.version_info >= (3,):
        flags |= doctest.IGNORE_EXCEPTION_DETAIL
    return flags

def run(docs):
    suite = test_suite(docs)
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    sys.exit(int(bool(result.failures or result.errors)))

if __name__ == '__main__':
    run(sys.argv)


########NEW FILE########
__FILENAME__ = backwardscompat
import sys

if sys.version_info >= (3,):
    string_types = (str,)
else:
    string_types = (basestring,)

########NEW FILE########
__FILENAME__ = dsl
import sys
import re
from types import FunctionType


_predicate_regexes = set(['is_(.+)', 'is(.+)'])


class Should(object):

    def __init__(self, negate=False):
        self._negate = negate
        self._matchers_by_name = dict()
        self._identifiers_named_equal_matchers = dict()
        self._outer_frame = None

    def _evaluate(self, value):
        if self._negate:
            return not value
        return value

    def __ror__(self, lvalue):
        self._lvalue = lvalue
        self._create_function_matchers()
        return self

    def __or__(self, rvalue):
        self._destroy_function_matchers()
        self._rvalue = rvalue
        return self._check_expectation()

    def _check_expectation(self):
        if not self._evaluate(self._rvalue.match(self._lvalue)):
            raise ShouldNotSatisfied(self._negate and \
                self._rvalue.message_for_failed_should_not() or \
                self._rvalue.message_for_failed_should())


    def _destroy_function_matchers(self):
        self._outer_frame = sys._getframe(2).f_globals
        self._remove_matchers_from_namespace()
        self._put_original_identifiers_back()

    def _remove_matchers_from_namespace(self):
        self._remove_regular_matchers_from_namespace()
        self._remove_predicate_matchers_from_namespace()

    def _remove_regular_matchers_from_namespace(self):
        f_globals = self._outer_frame
        for matcher_name in list(self._matchers_by_name.keys()):
            del f_globals[matcher_name]

    def _remove_predicate_matchers_from_namespace(self):
        f_globals = self._outer_frame
        for attr_name in dir(self._lvalue):
            matcher = 'be_%s' % attr_name
            if matcher in f_globals:
                del f_globals[matcher]

    def _put_original_identifiers_back(self):
        f_globals = self._outer_frame
        for attr_name, attr_ref in self._identifiers_named_equal_matchers.items():
            f_globals[attr_name] = attr_ref
        self._identifiers_named_equal_matchers.clear()


    def _create_function_matchers(self):
        self._outer_frame = sys._getframe(2).f_globals
        self._save_clashed_identifiers()
        self._put_matchers_on_namespace()

    def _save_clashed_identifiers(self):
        f_globals = self._outer_frame
        predicate_matcher_names = ['be_' + attr_name for attr_name in dir(self._lvalue) if not attr_name.startswith('_')]
        for matcher_name in list(self._matchers_by_name.keys()) + predicate_matcher_names:
            if matcher_name in f_globals:
                self._identifiers_named_equal_matchers[matcher_name] = f_globals[matcher_name]

    def _put_matchers_on_namespace(self):
        self._put_regular_matchers_on_namespace()
        self._put_predicate_matchers_on_namespace()

    def _put_regular_matchers_on_namespace(self):
        f_globals = self._outer_frame
        for matcher_name, matcher_function in self._matchers_by_name.items():
            matcher_function = self._matchers_by_name[matcher_name]
            matcher = matcher_function()
            self._inject_negate_information(matcher)
            f_globals[matcher_name] = matcher

    def _inject_negate_information(self, matcher):
        try:
            matcher.run_with_negate = self._negate
        except AttributeError:
            pass

    def _put_predicate_matchers_on_namespace(self):
        f_globals = self._outer_frame
        predicate_and_matcher_names = []
        public_names = self._get_all_public_attr_names(self._lvalue)
        for attr_name in public_names:
            for regex in _predicate_regexes:
                r = re.match(regex, attr_name)
                if r:
                    predicate_and_matcher_names.append((r.group(1), attr_name))
        predicate_and_matcher_names += [(attr_name, attr_name) for attr_name in public_names]
        for predicate_name, attr_name in predicate_and_matcher_names:
            f_globals['be_' + predicate_name] = _PredicateMatcher(attr_name)


    def add_matcher(self, matcher_object):
        if (hasattr(matcher_object, 'func_name') or
            isinstance(matcher_object, FunctionType)):
            function, message, not_for_should, not_for_should_not = \
                self._process_custom_matcher_function(matcher_object)
            class GeneratedMatcher(object):
                name = matcher_object.__name__
                def __init__(self):
                    self._function, self._message = function, message
                def __call__(self, arg):
                    self._arg = arg
                    return self
                def match(self, value):
                    self._value = value
                    return self._function(self._value, self._arg)
                def message_for_failed_should(self):
                    return self._build_message(not_for_should)
                def message_for_failed_should_not(self):
                    return self._build_message(not_for_should_not)
                def _build_message(self, not_):
                    try:
                        return self._message % (self._value, not_, self._arg)
                    except TypeError:
                        return self._message % {
                            'expected': self._arg,
                            'not': not_,
                            'actual': self._value}

            matcher_object = GeneratedMatcher
            name = GeneratedMatcher.name
        else:
            name = matcher_object.name
        self._ensure_matcher_init_doesnt_have_arguments(matcher_object)
        self._matchers_by_name[name] = matcher_object

    def _ensure_matcher_init_doesnt_have_arguments(self, matcher_object):
        try:
            matcher_object()
        except TypeError:
            e = sys.exc_info()[1]
            if str(e).startswith('__init__() takes exactly'):
                raise TypeError('matcher class constructor cannot have arguments')
            else:
                raise

    def _get_all_public_attr_names(self, obj):
        return [attr_name for attr_name in dir(obj) if not attr_name.startswith('_')]

    def _process_custom_matcher_function(self, matcher_function):
        values = matcher_function()
        function, message = values[0:2]
        if len(values) <= 2:
            nots = ('not ', '')
        else:
            nots = values[2]._negate and ('', 'not ') or ('not ', '')
        return (function, message) + nots

    def add_aliases(self, **aliases):
        for name, alias in aliases.items():
            matcher = self._matchers_by_name[name]
            self._matchers_by_name[alias] = matcher


class _PredicateMatcher(object):

    def __init__(self, attr_name):
        self._attr_name = attr_name

    def __call__(self, *params):
        self._params = params
        return self

    def match(self, value):
        self._value = value
        attr_value = getattr(self._value, self._attr_name)
        if self._is_method(attr_value):
            if self._has_param():
                attr_value = attr_value(*self._params)
            else:
                attr_value = attr_value()
        return attr_value

    def message_for_failed_should(self):
        return "expected %s to %s True, got False" % (
            self._display_attr(self._attr_name),
            self._display_verb(self._attr_name))

    def message_for_failed_should_not(self):
        return "expected %s to %s False, got True" % (
            self._display_attr(self._attr_name),
            self._display_verb(self._attr_name))

    def _is_method(self, object_):
        return (hasattr(object_, 'im_func') or hasattr(object_, '__func__'))

    def _display_attr(self, attr_name):
        if self._is_method(getattr(self._value, attr_name)):
            if self._has_param():
                repr_params = [repr(param) for param in self._params]
                param = ", ".join(repr_params)
            else:
                param = ""
            return "%s(%s)" % (attr_name, param)
        else:
            return attr_name

    def _display_verb(self, attr_name):
        return self._is_method(getattr(self._value, attr_name)) \
            and "return" or "be"

    def _has_param(self):
        return hasattr(self, '_params')


class ShouldNotSatisfied(AssertionError):
    '''Extends AssertionError for unittest compatibility'''


should = Should(negate=False)
should_not = Should(negate=True)

def matcher(matcher_object):
    '''Adds given matcher to should objects. We recommend you use it as a decorator'''
    should.add_matcher(matcher_object)
    should_not.add_matcher(matcher_object)
    return matcher_object

def add_predicate_regex(regex):
    _predicate_regexes.update([regex])

def matcher_configuration(verifier, message, word_not_for=should_not):
    return (verifier, message, word_not_for)

def aliases(**kwargs):
    should.add_aliases(**kwargs)
    should_not.add_aliases(**kwargs)


########NEW FILE########
__FILENAME__ = matchers
import re
import sys
import copy
from decimal import Decimal
from difflib import unified_diff
from should_dsl import matcher
from should_dsl.backwardscompat import string_types


class Be(object):

    name = 'be'

    def __call__(self, expected):
        self._expected = expected
        return self

    def match(self, actual):
        self._actual = actual
        return self._actual is self._expected

    def message_for_failed_should(self):
        return "%r was expected to be %r" % (self._actual, self._expected)

    def message_for_failed_should_not(self):
        return "%r was not expected to be %r" % (self._actual, self._expected)


matcher(Be)


class EqualTo(object):

    name = 'equal_to'

    def __call__(self, expected, diff=False, case_sensitive=True):
        self._expected = expected
        self._make_diff = diff
        self._case_sensitive = case_sensitive
        return self

    def match(self, actual):
        self._actual = actual
        self._diff = ''

        if not self._case_sensitive:
            self._prepare_strings_to_case_insensitive()

        if not self._actual == self._expected:
            if isinstance(self._expected, string_types) and isinstance(self._actual, string_types) and self._make_diff:
                self._prepare_strings_to_diff()
                diff_generator = unified_diff(self._actual, self._expected, fromfile='actual', tofile='expected')
                for line in diff_generator:
                    self._diff += line
            return False
        return True

    def _prepare_strings_to_case_insensitive(self):
            self._expected = self._expected.lower()
            self._actual = self._actual.lower()

    def _prepare_strings_to_diff(self):
            self._actual = self._actual.splitlines(True)
            self._expected = self._expected.splitlines(True)

    def message_for_failed_should(self):
        default_message = "%r is not equal to %r" % (self._actual, self._expected)
        if not self._make_diff:
            return default_message
        return "the strings are different, see the diff below:\n%s" % self._diff

    def message_for_failed_should_not(self):
        return "%r is equal to %r" % (self._actual, self._expected)

matcher(EqualTo)


@matcher
def include():
    return (lambda container, item: item in container, "%r does %sinclude %r")


@matcher
def contain():
    return (lambda container, item: item in container, "%r does %scontain %r")


@matcher
def be_into():
    return (lambda item, container: item in container, '%r is %sinto %r')


@matcher
def be_greater_than():
    return (lambda x, y: x > y, '%r is %sgreater than %r')


@matcher
def be_greater_than_or_equal_to():
    return (lambda x, y: x >= y, '%r is %sgreater than or equal to %r')


@matcher
def be_less_than():
    return (lambda x, y: x < y, '%r is %sless than %r')


@matcher
def be_less_than_or_equal_to():
    return (lambda x, y: x <= y, '%r is %sless than or equal to %r')


def check_exception(expected_exception, callable_and_possible_params):
    if getattr(callable_and_possible_params, '__getitem__', False):
        callable_object = callable_and_possible_params[0]
        params = callable_and_possible_params[1:]
    else:
        callable_object = callable_and_possible_params
        params = []

    try:
        callable_object(*params)
        return False
    except expected_exception:
        return True
    except Exception:
        return False


@matcher
def be_thrown_by():
    return (check_exception, '%r is %sthrown by %r')


class Throw:

    name = 'throw'

    def __call__(self, exception, message=None, message_regex=None):
        self._expected_message = message
        self._expected_message_regex = message_regex
        if isinstance(exception, Exception):
            self._expected_exception = exception.__class__
            if message is None and message_regex is None:
                self._expected_message = str(exception)
        else:
            self._expected_exception = exception
        return self

    def match(self, lvalue):
        self._lvalue = lvalue
        if getattr(lvalue, '__getitem__', False):
            args = lvalue[1:]
            lvalue = lvalue[0]
        else:
            args = []
        try:
            lvalue(*args)
            self._actual_exception = None
            return False
        except self._expected_exception:
            e = sys.exc_info()[1]
            self._actual_exception = self._expected_exception
            self._actual_message = str(e)
            return self._handle_expected_message() and self._handle_expected_regex()
        except Exception:
            e = sys.exc_info()[1]
            self._actual_exception = e.__class__
            return False

    def _using_message(self):
        return self._expected_message is not None

    def _using_regex(self):
        return self._expected_message_regex is not None and not self._using_message()

    def _got_exception(self):
        return hasattr(self, '_actual_exception') and self._actual_exception is not None

    def _handle_expected_message(self):
        if not self._using_message():
            return True
        return self._expected_message == self._actual_message

    def _handle_expected_regex(self):
        if not self._using_regex():
            return True
        return re.match(self._expected_message_regex, self._actual_message) is not None

    def message_for_failed_should(self):
        message = "expected to throw %r" % self._expected_exception.__name__
        if self._using_message():
            message += " with the message %r" % self._expected_message
        elif self._using_regex():
            message += " with a message that matches %r" % self._expected_message_regex
        if self._got_exception():
            message += ', got %r' % self._actual_exception.__name__
            if self._using_message():
                message += ' with %r' % self._actual_message
            elif self._using_regex():
                message += ' with no match for %r' % self._actual_message
        else:
            message += ', got no exception'
        return message

    def message_for_failed_should_not(self):
        message = "expected not to throw %r" % self._expected_exception.__name__
        if self._using_message():
            message += " with the message %r" % self._expected_message
        elif self._using_regex():
            message += " with a message that matches %r" % self._expected_message_regex
        return "%s, but got it" % message

matcher(Throw)


@matcher
def include_in_any_order():
    def contains_in_any_order(container, elements):
        for element in elements:
            if element not in container:
                return False
        return True
    return (contains_in_any_order, "%r does %sinclude in any order %r")


@matcher
def include_all_of():
    return (include_in_any_order()[0], "%r does %sinclude all of %r")


@matcher
def include_any_of():
    def include_any_of_func(container, elements):
        for element in elements:
            if element in container:
                return True
        return False
    return (include_any_of_func, "%r does %sinclude any of %r")


@matcher
def be_kind_of():
    return (lambda obj, kind: isinstance(obj, kind), "%r is %s a kind of %r")


@matcher
def be_instance_of():
    return (lambda obj, kind: isinstance(obj, kind), "%r is %s an instance of %r")


@matcher
def start_with():
    return (lambda x, y: x.startswith(y), "%r does %sstart with %r")


@matcher
def end_with():
    return (lambda x, y: x.endswith(y), "%r does %send with %r")


class BeLike(object):

    name = 'be_like'

    def __call__(self, regex, flags=0):
        self._regex = regex
        self._flags = flags
        return self

    def match(self, lvalue):
        self._lvalue = lvalue
        return re.match(self._regex, self._lvalue, self._flags) is not None

    def message_for_failed_should(self):
        return "%r is not like %r%s" % (self._lvalue, self._regex,
            self._flags and ' with given flags' or '')

    def message_for_failed_should_not(self):
        return "%r is like %r%s" % (self._lvalue, self._regex,
            self._flags and ' with given flags' or '')


matcher(BeLike)


@matcher
def equal_to_ignoring_case():
    try:
        unicode
        lower = lambda x: unicode(x, 'utf-8').lower()
    except NameError:
        # py3k is unicode by default
        lower = lambda x: x.lower()
    return (lambda x, y: lower(x) == lower(y), '%r is %sequal to %r ignoring case')


class Have(object):

    name = 'have'

    def __call__(self, count):
        self._count = count
        return self

    def __getattr__(self, collection_name):
        self._collection_name = collection_name
        self._humanized_collection_name = collection_name.replace('_', ' ')
        return self

    def match(self, lvalue):
        self._lvalue = lvalue
        if hasattr(self._lvalue, self._collection_name):
            self._collection = getattr(self._lvalue, self._collection_name)
            if not self._is_iterable(self._collection):
                if callable(self._collection):
                    self._collection = self._collection()
                    if not self._is_iterable(self._collection):
                        raise TypeError("target's '%s()' does not return an iterable" % self._collection_name)
                else:
                    raise TypeError("target's %r is not an iterable" % self._collection_name)
        elif self._is_iterable(self._lvalue):
            self._collection = self._lvalue
        elif self._is_collection_through():
            owned_by_owned, owned = self._collection_name.split('_on_')
            owned_object = self._retrieve_owned_object(self._lvalue, owned)
            owned_by_owned_object = self._retrieve_owned_object(owned_object, owned_by_owned)
            if not self._is_iterable(owned_by_owned_object):
                if callable(getattr(owned_object, owned_by_owned)):
                    raise TypeError("target's '%s()' does not return an iterable" % owned_by_owned)
                else:
                    raise TypeError("target's %r is not an iterable" % owned_by_owned)
            self._collection = owned_by_owned_object
        else:
            raise TypeError("target does not have a %r collection, nor it is an iterable" % (
                self._collection_name))
        return self._compare()

    def _retrieve_owned_object(self, object_, owned):
        owned_object = getattr(object_, owned)
        if callable(owned_object):
            owned_object = owned_object()
        return owned_object

    def _is_collection_through(self):
        splitted = self._collection_name.split('_on_')
        if len(splitted) == 1:
            return False
        owned_by_owned, owned = splitted

        if not hasattr(self._lvalue, owned):
            return False
        owned_object = self._retrieve_owned_object(self._lvalue, owned)
        return hasattr(owned_object, owned_by_owned)

    def _compare(self):
        return self._count == len(self._collection)

    def message_for_failed_should(self):
        if self.name == 'have':
            description = ''
        else:
            description = "%s " % self.name[5:].replace('_', ' ')
        return "expected %s%r %r, got %r" % (description, self._count,
            self._humanized_collection_name, len(self._collection))

    def message_for_failed_should_not(self):
        return "expected target not to %s %d %r, got %r" % (
            self.name.replace('_', ' '), self._count,
            self._humanized_collection_name, len(self._collection))

    def _is_iterable(self, objekt):
        return hasattr(objekt, '__len__')

matcher(Have)


class HaveAtLeast(Have):

    name = 'have_at_least'

    def _compare(self):
        return len(self._collection) >= self._count


matcher(HaveAtLeast)


class HaveAtMost(Have):

    name = 'have_at_most'

    def _compare(self):
        return len(self._collection) <= self._count

matcher(HaveAtMost)


class RespondTo(object):

    name = 'respond_to'

    def __call__(self, method_name):
        self._method_name = method_name
        return self

    def match(self, lvalue):
        self._lvalue = lvalue
        return hasattr(self._lvalue, self._method_name)

    def message_for_failed_should(self):
        return "expected %r to respond to %r" % (self._lvalue,
            self._method_name)

    def message_for_failed_should_not(self):
        return "expected %r not to respond to %r" % (self._lvalue,
            self._method_name)

matcher(RespondTo)


class CloseTo(object):

    name = 'close_to'

    def __call__(self, expected, delta):
        self._expected, self._delta = expected, delta
        return self

    def match(self, actual):
        self._actual = actual
        return abs(Decimal(str(self._actual)) - Decimal(str(self._expected))) <= Decimal(str(self._delta))

    def message_for_failed_should(self):
        return "expected to be close to %s (within +/- %s), got %s" % (
            self._expected, self._delta, self._actual)

    def message_for_failed_should_not(self):
        return "expected not to be close to %s (within +/- %s), got %s" % (
            self._expected, self._delta, self._actual)

matcher(CloseTo)


class Change(object):

    name = 'change'

    def __init__(self):
        self._by = None
        self._from_to = False
        self._only_to = False

    def __call__(self, verifier):
        self._verifier = self._to_callable(verifier)
        return self

    def match(self, action):
        self._action = self._to_callable(action)
        self._before_result = copy.copy(self._verifier())
        self._action()
        self._after_result = self._verifier()

        if self._by is not None:
            self._actual_difference = self._after_result - self._before_result
            return self._by.comparison(self._expected_difference, self._actual_difference)
        elif self._from_to:
            return self._before_result == self._from_value and self._after_result == self._to_value
        elif self._only_to:
            self._failure_on_to_initial_value = False
            if self._before_result == self._to_value:
                self._failure_on_to_initial_value = True
                return False
            else:
                return self._after_result == self._to_value
        else:
            return self._after_result != self._before_result

    def message_for_failed_should(self):
        if self._by is not None:
            return 'result should have changed %s %r, but was changed by %r' % (
                self._by.name, self._expected_difference, self._actual_difference)
        elif self._from_to:
            return 'result should have changed from %r to %r, but was changed from %r to %r' % (
                self._from_value, self._to_value, self._before_result, self._after_result)
        elif self._only_to:
            if self._failure_on_to_initial_value:
                return 'result should have been changed to %r, but is now %r' % (
                    self._to_value, self._before_result)
            else:
                return 'result should have changed to %r, but was changed to %r' % (
                    self._to_value, self._after_result)
        else:
            return 'result should have changed, but is still %r' % (
                self._before_result)

    def message_for_failed_should_not(self):
        if self._from_to:
            return 'result should not have changed from %r to %r' % (
                  self._from_value, self._to_value)
        elif self._only_to:
            return 'result should not have changed to %r' % self._to_value
        else:
            return 'should not have changed, but did change from %r to %r' % (
                self._before_result, self._after_result)

    def by(self, difference):
        self._expected_difference = difference
        self._by = Change._By(lambda exp_dif, act_dif: act_dif == exp_dif)
        return self

    def  by_at_least(self, difference):
        self._expected_difference = difference
        self._by = Change._By(lambda exp_dif, act_dif: act_dif >= exp_dif, 'at least')
        return self

    def by_at_most(self, difference):
        self._expected_difference = difference
        self._by = Change._By(lambda exp_dif, act_dif: act_dif <= exp_dif, 'at most')
        return self

    def from_(self, from_value):
        self._from_value = from_value
        self._from_to = True
        return self

    def to(self, to_value):
        self._only_to = not self._from_to
        self._to_value = to_value
        return self

    def _to_callable(self, objekt):
        if callable(objekt):
            return objekt
        if getattr(objekt, '__getitem__', False) and len(objekt) >= 2 and callable(objekt[0]):
            return lambda *params: objekt[0](*objekt[1:])
        else:
            raise TypeError('parameter passed to change must be a callable ' +
                'or a iterable having a callable as its first element')

    class _By(object):
        def __init__(self, comparison, name=''):
            self.name = ('by ' + name).strip()
            self.comparison = comparison

matcher(Change)


# matchers for backwards compatibility
@matcher
def into():
    return be_into()


@matcher
def greater_than():
    return be_greater_than()


@matcher
def greater_than_or_equal_to():
    return be_greater_than_or_equal_to()


@matcher
def less_than():
    return be_less_than()


@matcher
def less_than_or_equal_to():
    return be_less_than_or_equal_to()


@matcher
def thrown_by():
    return be_thrown_by()


@matcher
def in_any_order():
    return include_in_any_order()


@matcher
def all_of():
    return include_all_of()


@matcher
def any_of():
    return include_any_of()


@matcher
def kind_of():
    return be_kind_of()


@matcher
def ended_with():
    return (lambda x, y: x.endswith(y), "%r is %sended with %r")


class Like(BeLike):
    name = 'like'

matcher(Like)


class IncludeDictElement(object):

    def __call__(self, *elements):
        self._expected_elements = elements
        return self

    def match(self, dictionary):
        self._ensure_it_is_really_a_dict(dictionary)
        self._actual_elements = self._get_element_values(dictionary)
        self._undesired_elements = []
        if self.run_with_negate:
            self._undesired_elements = [elem for elem in self._expected_elements if elem in self._actual_elements]
            return len(self._undesired_elements) != 0
        else:
            self._undesired_elements = [elem for elem in self._expected_elements if elem not in self._actual_elements]
            return len(self._undesired_elements) == 0

    def message_for_failed_should(self):
        return "expected target to include %s %s" % (
            self._pluralize_element(), self._humanize_undesired_elements())

    def message_for_failed_should_not(self):
        return "expected target to not include %s %s" % (
            self._pluralize_element(), self._humanize_undesired_elements())

    def _pluralize_element(self):
        return len(self._undesired_elements) > 1 and ('%ss' % self._element_name) or self._element_name

    def _humanize_undesired_elements(self):
        list_ = self._undesired_elements
        if len(list_) == 1:
            return repr(list_[0])
        list_ = [repr(x) for x in list_]
        last = list_.pop()
        list_[-1] = "%s and %s" % (list_[-1], last)
        return ', '.join(list_)

    def _ensure_it_is_really_a_dict(self, target):
        if not isinstance(target, dict):
            raise TypeError('target must be a dictionary')


class IncludeKeys(IncludeDictElement):

    name = 'include_keys'

    def __init__(self):
        self._element_name = 'key'
        self._get_element_values = lambda d: d.keys()


matcher(IncludeKeys)


class IncludeValues(IncludeDictElement):

    name = 'include_values'

    def __init__(self):
        self._element_name = 'value'
        self._get_element_values = lambda d: d.values()


matcher(IncludeValues)


class BeEmpty(object):

    name = 'be_empty'

    def __call__(self):
        return self

    def match(self, container):
        self._container = container
        return len(container) == 0

    def message_for_failed_should(self):
        return "expected %s to be empty" % repr(self._container)

    def message_for_failed_should_not(self):
        return "expected %s not to be empty" % repr(self._container)


matcher(BeEmpty)

class HaveSameAttributeValues(object):

    name = 'have_same_attribute_values_as'

    def __call__(self, other_object):
        self._other_object = other_object
        return self

    def match(self, actual_object):
        self._actual_object = actual_object
        found_different_attribute = False

        for key in self._other_object.__dict__.keys():
            got = self._actual_object.__dict__.get(key)
            expected =  self._other_object.__dict__.get(key)
            if got != expected:
                found_different_attribute = True
                break

        return found_different_attribute == False

    def message_for_failed_should(self):
        return "expected %r to have the same attribute values as %r" % (self._actual_object, self._other_object)

    def message_for_failed_should_not(self):
        return "expected %r to have not the same attribute values as %r" % (self._actual_object, self._other_object)

matcher(HaveSameAttributeValues)

########NEW FILE########
