__FILENAME__ = build
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import os
import shutil
import sys
import tempfile


def prep_dir():
    shutil.rmtree('./build', ignore_errors=True)


def build():
    os.system('python setup.py build')


def develop():
    os.system('python setup.py develop')


def install():
    os.system('python setup.py install')


def upload():
    os.system('python setup.py register sdist upload')


def test():
    os.system('python setup.py check -r')
    build()
    os.chdir('./build')
    os.system('nosetests --exe -v')
    os.chdir('..')


def gh_pages():
    temp_dir = tempfile.mkdtemp()
    os.system('git checkout master')
    os.system('git pull origin master')
    shutil.rmtree('./docs/build', ignore_errors=True)
    os.chdir('./docs')
    os.system('make html')
    os.chdir('..')
    shutil.copytree('./docs/build/html', temp_dir + '/docs')
    os.system('git checkout gh-pages')
    shutil.rmtree('./docs')
    shutil.copytree(temp_dir + '/docs', './docs')
    os.system('git add ./docs')
    os.system('git commit -m "rebuild docs"')
    os.system('git push origin gh-pages')
    shutil.rmtree(temp_dir)
    os.system('git checkout master')
    shutil.rmtree('./docs/_images', ignore_errors=True)
    shutil.rmtree('./docs/_static', ignore_errors=True)
    os.remove('./docs/.buildinfo')


handlers = {
    'build': build,
    'develop': develop,
    'install': install,
    'upload': upload,
    'test': test,
    'gh_pages': gh_pages,
}


args = sys.argv[1:]
if not args or not all(arg in handlers for arg in args):
    print('usage: python build.py [build, [develop, [install, [upload, [test, '
          '[gh_pages]]]]]')
    sys.exit()
prep_dir()
for arg in args:
    handlers[arg]()

########NEW FILE########
__FILENAME__ = conf
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
# -*- coding: utf-8 -*-
#
# Enaml documentation build configuration file, created by
# sphinx-quickstart on Mon Aug 22 09:16:47 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

from enaml.version import version_info

import sphinx_bootstrap_theme

from enaml.core.import_hooks import EnamlImporter
EnamlImporter.install()

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('.'))
sys.path.insert(0, os.path.abspath('./_sphinxext'))
sys.path.insert(0, os.path.abspath('../'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
needs_sphinx = '1.0.7'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.doctest',
    'sphinx.ext.intersphinx',
    'sphinx.ext.todo',
    'sphinx.ext.coverage',
    'sphinx.ext.pngmath',
    'sphinx.ext.ifconfig',
    'sphinx.ext.viewcode',
    'sphinx.ext.graphviz',
    'sphinx.ext.inheritance_diagram',
    'sphinx.ext.autosummary',
    #'enamldoc'
    'numpydoc'
    ]

# Disable numpy auto-gen class members.
numpydoc_show_class_members = False

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Enaml'
copyright = u'2013, Nucleic Development Team'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '{}.{}.{}'.format(*version_info)
# The full version, including alpha/beta/rc tags.
release = '{}.{}.{}'.format(*version_info)

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_templates', '_sphinxext']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'trac'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

todo_include_todos = True

autodoc_member_order = 'bysource'
autodoc_default_flags = [
    'members',
    #'undoc-members',
    'special-members',
    'show-inheritance',
    ]

##inheritance_node_attrs = dict(shape='ellipse', fontsize=14, height=0.75,
##                              color='dodgerblue1', style='filled')

#: rankdir ['LR', 'TB', 'BT', 'RL']
inheritance_graph_attrs = dict(
    rankdir="LR",
    width="8.0",
    #size='"8.0, 20.0"',
    fontsize=14,
    ratio='compress'
    )

autosummary_generate = True

# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
# html_theme = 'nucleic_doc'
#'default'
#'agogo'
#
html_theme = 'bootstrap'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
## html_theme_options = {
##     'pagewidth' : '70em',
##     'sidebarwidth' : '20em'
##     }
html_theme_options = {
    #'navbar_class': 'navbar-inverse',
    'navbar_sidebarrel': False,
    'bootswatch_theme': 'cosmo',
    'bootstrap_version': '3',
}

# Add any paths that contain custom themes here, relative to this directory.
# html_theme_path = ['./']
html_theme_path = sphinx_bootstrap_theme.get_html_theme_path()

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
html_short_title = project + " v" + release

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = '_static/logo-rev.png'

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = 'nucleic.ico'

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
html_sidebars = {
    '**': ['realglobaltoc.html'],
    'index': [],
    'genindex': [],
    'search': [],
}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
html_domain_indices = True

# If false, no index is generated.
html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
html_show_sourcelink = False

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'enamldoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'enaml.tex', u'Enaml Documentation',
   u'Nucleic Development Team', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
latex_use_parts = True

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'enaml', u'Enaml Documentation',
     [u'Nucleic Development Team'], 1)
]


# -- Options for Epub output ---------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'Enaml'
epub_author = u'Chris Colbert'
epub_publisher = u'Nucleic Development Team'
epub_copyright = u'2013, Nucleic Development Team'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {
    'python' : ('http://docs.python.org/', None),
    #'atom' : ('https://github.com/nucleic/atom/', None)
    }

########NEW FILE########
__FILENAME__ = example_doc_generator
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
""" Generate the Example Documentation for the Enaml Examples

Run as part of the documentation build script. Requires PyQt4.
Look for example enaml files with the line:

<< autodoc-me >>

Generate an rst file, then open the app and take a snapshot.

"""
from __future__ import print_function
import os
os.environ['QT_API'] = 'pyqt'
import shutil

from atom.api import Atom, Unicode, Value
import enaml
from enaml.qt.qt_application import QtApplication
from enaml.qt.QtGui import QApplication, QPixmap
from enaml.application import timed_call


class SnapShot(Atom):
    """ Generate a snapshot of an enaml view.
    
    """
    
    #: The snapshot save path.
    path = Unicode()
    
    #: The enaml view object.
    view = Value()
        
    def _observe_view(self, change):
        """ Move window and allow it to draw before taking the snapshot.
        
        """
        if change['type'] == 'create':
            self.view.initial_position = (10, 10)
            self.view.always_on_top = True
            timed_call(1500, self.snapshot)

    def snapshot(self):
        """ Take a snapshot of the window and close it.
        
        """
        widget = self.view.proxy.widget
        framesize =  widget.window().frameSize()
        QPixmap.grabWindow(QApplication.desktop().winId(), widget.x(),
                           widget.y(), framesize.width(),
                           framesize.height() ).save(self.path)
        widget.close()


def generate_example_doc(app, docs_path, script_path):
    """ Generate an RST and a PNG for an example file.

    Parameters
    ----------
    app : QtApplication instance
    docs_path : str
         Full path to enaml/docs/source/examples
    script_path : str
         Full path to the example enaml file
    """
    script_name = os.path.basename(script_path)
    script_name = script_name[:script_name.find('.')]
    print('generating doc for %s' % script_name)
    
    script_title = script_name.replace('_', ' ').title()
    script_image_name = 'ex_' + script_name + '.png'
    image_path = os.path.join(docs_path, 'images', script_image_name)
    rst_path = os.path.join(
        docs_path, 'ex_' + script_name + '.rst')
    relative_script_path = script_path[
        script_path.find('examples'):].replace('\\', '/')

    with open(os.path.join(script_path)) as fid:
        script_text = fid.read()

    docstring = script_text[script_text.find('"""') + 3:]
    docstring = docstring[: docstring.find('"""')]
    docstring = docstring.replace('<< autodoc-me >>\n', '').strip()

    rst_template = """
{0} Example
===============================================================================

:download:`{1} <../../../{2}>`

::

    {3}

::

 $ enaml-run {1}

.. image:: images/{4}

.. literalinclude:: ../../../{2}
    :language: enaml

""".format(script_title, script_name, relative_script_path,
           docstring.replace('\n', '\n    '), script_image_name)

    with open(rst_path, 'wb') as fid:
        fid.write(rst_template.lstrip())

    temp_path = os.path.join(docs_path, os.path.basename(script_path))

    with open(temp_path, 'wb') as fid:
        fid.write(script_text)

    with enaml.imports():
        try:
            mod = __import__(script_name)
        except Exception as err:
            print('Could not create: %s' % script_name)
            print('    %s' % err)
            os.remove(temp_path)
            return
    try:
        view = mod.Main()
        snapshot = SnapShot(path=image_path, view=view)
        view.show()
        app.start()
    except Exception as err:
        print('Could not create: %s' % script_name)
        print('    %s' % err)
    finally:
        os.remove(temp_path)


def main():
    """ Generate documentation for all enaml examples requesting autodoc.

    Looks in enaml/examples for all enaml files, then looks for the line:
    << auto-doc >>

    If the line appears in the script, generate an RST and PNG for the example.
    """
    app = QtApplication()
    docs_path = os.path.dirname(__file__)
    base_path = '../../../examples'
    base_path = os.path.realpath(os.path.join(docs_path, base_path))
    
    enaml_cache_dir = os.path.join(docs_path, '__enamlcache__')

    for dirname, dirnames, filenames in os.walk(base_path):
        files = [os.path.join(dirname, f)
                 for f in filenames if f.endswith('.enaml')]

        for fname in files:
            with open(fname, 'rb') as fid:
                data = fid.read()
            if '<< autodoc-me >>' in data.splitlines():
                try:
                    generate_example_doc(app, docs_path, fname)
                except KeyboardInterrupt:
                    shutil.rmtree(enaml_cache_dir)
                    return
    shutil.rmtree(enaml_cache_dir)


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = main
# main.py
import enaml
from enaml.qt.qt_application import QtApplication

from person_model import Person


if __name__ == '__main__':
    with enaml.imports():
        from person_view import PersonView

    john = Person(first_name='John', last_name='Doe')

    app = QtApplication()

    view = PersonView(person=john)
    view.show()

    app.start()

########NEW FILE########
__FILENAME__ = person_model
# person_model.py
from atom.api import Atom, Unicode

class Person(Atom):
    first_name = Unicode()
    last_name = Unicode()

########NEW FILE########
__FILENAME__ = enamldoc
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import  re

from atom.api import Member


#------------------------------------------------------------------------------
# AST Nodes
#------------------------------------------------------------------------------
class Docstring(object):

    def __init__(self, body):
        self.body = body

    def render(self):
        lines = []
        for item in self.body:
            lines.extend(item.render())
        return lines


class NormalLine(object):

    def __init__(self, text):
        self.text = text

    def render(self):
        return [self.text]


class Parameters(object):

    def __init__(self, body):
        self.body = body

    def render(self):
        lines = []
        for item in self.body:
            lines.extend(item.render())
        return lines


class ParameterSpec(object):

    def __init__(self, pname, ptype, description):
        self.pname = pname
        self.ptype = ptype
        self.description = description

    def render(self):
        lines = []
        lines.append(':param %s: %s' % (self.pname, self.description))
        if self.ptype:
            lines.append(':type %s: %s' % (self.pname, self.ptype))
        return lines


class Returns(object):

    def __init__(self, body):
        self.body = body

    def render(self):
        lines = []
        for item in self.body:
            lines.extend(item.render())
        return lines


class ReturnSpec(object):

    def __init__(self, rtype, description):
        self.rtype = rtype
        self.description = description

    def render(self):
        lines = []
        lines.append(':rtype: %s' % self.rtype)
        lines.append(':returns: %s' % self.description)
        return lines


#------------------------------------------------------------------------------
# Lexer
#------------------------------------------------------------------------------
dashed_line = 'dashed_line'
empty_line = 'empty_line'
indented_line = 'indented_line'
normal_line = 'normal_line'
parameters_header = 'parameters_header'
parameter_spec = 'parameter_spec'
returns_header = 'returns_header'
star_args = 'star_args'
star_star_kwargs = 'star_star_kwargs'


line_regexes = (
    (parameters_header, re.compile(r'^Parameters$')),
    (returns_header, re.compile(r'^Returns$')),
    (star_args, re.compile(r'^\*([a-zA-Z_][a-zA-Z0-9_]*)$')),
    (star_star_kwargs, re.compile(r'^\*\*([a-zA-Z_][a-zA-Z0-9_]*)$')),
    (parameter_spec, re.compile(r'^([a-zA-Z_][a-zA-Z0-9_]*)\s*:\s*(.*)$')),
    (dashed_line, re.compile(r'^-+$')),
    (indented_line, re.compile(r'^(\s+)[^\s].*$')),
    (normal_line, re.compile(r'^[^\s].*$')),
    (empty_line, re.compile(r'^\s*$')),
)


def lex_line(line):
    for token, rgx in line_regexes:
        match = rgx.match(line)
        if match is not None:
            return (token, line, match)
    raise ValueError('line "%s" failed to lex' % line)


#------------------------------------------------------------------------------
# Parser
#------------------------------------------------------------------------------
def peek(stack):
    if len(stack) == 0:
        return ''
    return stack[-1][0]


def consume_blank_lines(stack):
    while peek(stack) == empty_line:
        stack.pop()


def extract_description(stack):
    parts = []
    while peek(stack) == indented_line:
        token, line, match = stack.pop()
        parts.append(line.strip())
    return ' '.join(parts)


def p_normal(line, match, stack):
    return NormalLine(line)


def p_parameters(line, match, stack):
    if peek(stack) != dashed_line:
        return p_normal(line, match, stack)
    stack.pop()
    body = []
    consume_blank_lines(stack)
    while True:
        p = peek(stack)
        if p == parameter_spec:
            token, line, match = stack.pop()
            consume_blank_lines(stack)
            descr = extract_description(stack)
            pname = match.group(1)
            ptype = match.group(2)
            spec = ParameterSpec(pname, ptype, descr)
            body.append(spec)
            consume_blank_lines(stack)
        elif p == star_args or p == star_star_kwargs:
            token, line, match = stack.pop()
            consume_blank_lines(stack)
            descr = extract_description(stack)
            pname = match.group(1)
            spec = ParameterSpec(pname, '', descr)
            body.append(spec)
            consume_blank_lines(stack)
        else:
            break
    return Parameters(body)


def p_returns(line, match, stack):
    if peek(stack) != dashed_line:
        return p_normal(line, match, stack)
    stack.pop()
    body = []
    consume_blank_lines(stack)
    if peek(stack) == parameter_spec:
        token, line, match = stack.pop()
        consume_blank_lines(stack)
        descr = extract_description(stack)
        rtype = match.group(2)
        spec = ReturnSpec(rtype, descr)
        body.append(spec)
        consume_blank_lines(stack)
    return Returns(body)


DISPATCH_TABLE = {
    dashed_line: p_normal,
    empty_line: p_normal,
    indented_line: p_normal,
    normal_line: p_normal,
    parameters_header: p_parameters,
    parameter_spec: p_normal,
    returns_header: p_returns,
    star_args: p_normal,
    star_star_kwargs: p_normal,
}


def parse(classified):
    body = []
    stack = classified[::-1]
    while stack:
        token, line, match = stack.pop()
        item = DISPATCH_TABLE[token](line, match, stack)
        body.append(item)
    return Docstring(body)


#------------------------------------------------------------------------------
# Docstring Processors
#------------------------------------------------------------------------------
def process_function(app, name, obj, options, lines):
    classified = map(lex_line, lines)
    return parse(classified).render()


def process_attribute(app, name, obj, options, lines):
    # if isinstance(obj, Member):
    #     # indent = '    '
    #     # name = type(obj).__name__
    #     # new = [indent + name, u'']
    #     # for line in lines:
    #     #     new.append(indent + line)
    #     # lines = new
    #     pass
    return lines


HANDLERS = {
    'function': process_function,
    'method': process_function,
    'attribute': process_attribute,
}


def process_docstring(app, what, name, obj, options, lines):
    handler = HANDLERS.get(what)
    if handler is not None:
        modified_lines = handler(app, name, obj, options, lines[:])
        lines[:] = modified_lines


def setup(app):
    app.connect('autodoc-process-docstring', process_docstring)

########NEW FILE########
__FILENAME__ = live_editor_model
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import linecache
import traceback
from types import ModuleType

from atom.api import Atom, Str, Typed, observe

import enaml
from enaml.core.object import Object
from enaml.core.enaml_compiler import EnamlCompiler
from enaml.core.parser import parse
from enaml.widgets.widget import Widget


def _fake_linecache(text, filename):
    """ Inject text into the linecache for traceback purposes.

    Parameters
    ----------
    text : str
        The text of the file.

    filename : str
        The name of the file.

    """
    size = len(text)
    mtime = 1343290295L
    lines = text.splitlines()
    lines = [l + '\n' for l in lines]
    linecache.cache[filename] = size, mtime, lines, filename


class LiveEditorModel(Atom):
    """ A model which works in concert with the live editor panels.

    This model manages the compiling and instantiation of the model
    and view objects defined by the user.

    The model has six inputs:

        'model_text'
            The full text of the Python module which defines the model.

        'view_text'
            The full text of the Enaml module which defines the view.

        'model_item'
            The name of the target model class in the model module.

        'view_item'
            The name of the target enamldef in the view module.

        'model_filename'
            An optional filename to associate with the model module.

        'view_filename'
            An optional filename to associate with the view module.

    The model has three outputs:

        'compiled_model'
            The instance of the user defined model, or None if no model
            could be created.

        'compiled_view'
            The instance of the user defined view, or None if no view
            could be created.

        'traceback'
            A string holding the traceback for any compilation and
            instantiation errors.

    If the 'compiled_view' object has a 'model' attribute, then the
    'compiled_model' object will be assigned to that attribute.

    """
    #: The current live model object bound to the main view.
    compiled_model = Typed(Atom)

    #: The current live view object to include in the main view.
    compiled_view = Typed(Object)

    #: The Python module input text for the model module.
    model_text = Str()

    #: The Enaml module input text for the view module.
    view_text = Str()

    #: The string name of the Atom class to use as the model.
    model_item = Str()

    #: The string name of the enamldef to use as the view.
    view_item = Str()

    #: An optional filename to use when compiling the python code.
    model_filename = Str('__live_model__.py')

    #: An optional filename to use when compiling the enaml code.
    view_filename = Str('__live_view__.enaml')

    #: A string which holds the most recent tracekback.
    traceback = Str()

    #: The module created from the model text.
    _model_module = Typed(ModuleType)

    #: The module created from the view text.
    _view_module = Typed(ModuleType)

    #--------------------------------------------------------------------------
    # Post Validators
    #--------------------------------------------------------------------------
    def _post_validate_model_text(self, old, new):
        """ Post validate the model text.

        This validator replaces CRLF with LF characters.

        """
        return new.replace('\r\n', '\n').replace('\r', '\n')

    def _post_validate_view_text(self, old, new):
        """ Post validate the view text.

        This validator replaces CRLF with LF characters.

        """
        return new.replace('\r\n', '\n').replace('\r', '\n')

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('model_text', 'model_item')
    def _refresh_model_trigger(self, change):
        """ An observer which triggers a compiled model refresh.

        """
        if change['type'] == 'update':
            self.refresh_model()

    @observe('view_text', 'view_item')
    def _refresh_view_trigger(self, change):
        """ An observer which triggers a compiled view refresh.

        """
        if change['type'] == 'update':
            self.refresh_view()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def refresh_model(self):
        """ Refresh the compiled model object.

        This method will (re)compile the model for the given model text
        and update the 'compiled_model' attribute. If a compiled view is
        available and has a member named 'model', the model will be
        applied to the view.

        """
        text = self.model_text
        filename = self.model_filename
        _fake_linecache(text, filename)
        try:
            if not text:
                self.compiled_model = None
                self._model_module = None
            else:
                code = compile(text, filename, 'exec')
                module = ModuleType(filename.rsplit('.', 1)[0])
                module.__file__ = filename
                namespace = module.__dict__
                exec code in namespace
                model = namespace.get(self.model_item, lambda: None)()
                self.compiled_model = model
                self._model_module = module
            self.relink_view()
        except Exception:
            self.traceback = traceback.format_exc()
        else:
            self.traceback = ''

    def refresh_view(self):
        """ Refresh the compiled view object.

        This method will (re)compile the view for the given view text
        and update the 'compiled_view' attribute. If a compiled model
        is available and the view has a member named 'model', the model
        will be applied to the view.

        """
        text = self.view_text
        filename = self.view_filename
        _fake_linecache(text, filename)
        try:
            if not text:
                self.compiled_view = None
                self._view_module = None
            else:
                ast = parse(text, filename=filename)
                code = EnamlCompiler.compile(ast, filename)
                module = ModuleType('__main__')
                module.__file__ = filename
                namespace = module.__dict__
                with enaml.imports():
                    exec code in namespace
                view = namespace.get(self.view_item, lambda: None)()
                if isinstance(view, Object) and 'model' in view.members():
                    view.model = self.compiled_model
                # trap any initialization errors and roll back the view
                old = self.compiled_view
                try:
                    self.compiled_view = view
                except Exception:
                    self.compiled_view = old
                    if isinstance(old, Widget):
                        old.show()
                    raise
                self._view_module = module
                if old is not None and not old.is_destroyed:
                    old.destroy()
        except Exception:
            self.traceback = traceback.format_exc()
        else:
            self.traceback = ''

    def relink_view(self):
        """ Relink the compiled view with the compiled model.

        """
        view = self.compiled_view
        if view is not None and 'model' in view.members():
            view.model = self.compiled_model

########NEW FILE########
__FILENAME__ = application
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from heapq import heappush, heappop
from itertools import count
from threading import Lock

from atom.api import (
    Atom, Bool, Typed, ForwardTyped, Tuple, Dict, Callable, Value, List,
    observe
)


class ScheduledTask(Atom):
    """ An object representing a task in the scheduler.

    """
    #: The callable to run when the task is executed.
    _callback = Callable()

    #: The args to pass to the callable.
    _args = Tuple()

    #: The keywords to pass to the callable.
    _kwargs = Dict()

    #: The result of invoking the callback.
    _result = Value()

    #: Whether or not the task is still valid.
    _valid = Bool(True)

    #: Whether or not the task is still pending.
    _pending = Bool(True)

    #: A callable to invoke with the result of running the task.
    _notify = Callable()

    def __init__(self, callback, args, kwargs):
        """ Initialize a ScheduledTask.

        Parameters
        ----------
        callback : callable
            The callable to run when the task is executed.

        args : tuple
            The tuple of positional arguments to pass to the callback.

        kwargs : dict
            The dict of keyword arguments to pass to the callback.

        """
        self._callback = callback
        self._args = args
        self._kwargs = kwargs

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _execute(self):
        """ Execute the underlying task. This should only been called
        by the scheduler loop.

        """
        try:
            if self._valid:
                self._result = self._callback(*self._args, **self._kwargs)
                if self._notify is not None:
                    self._notify(self._result)
        finally:
            del self._notify
            self._pending = False

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def notify(self, callback):
        """ Set a callback to be run when the task is executed.

        Parameters
        ----------
        callback : callable
            A callable which accepts a single argument which is the
            results of the task. It will be invoked immediate after
            the task is executed, on the main event loop thread.

        """
        self._notify = callback

    def pending(self):
        """ Returns True if this task is pending execution, False
        otherwise.

        """
        return self._pending

    def unschedule(self):
        """ Unschedule the task so that it will not be executed. If
        the task has already been executed, this call has no effect.

        """
        self._valid = False

    def result(self):
        """ Returns the result of the task, or ScheduledTask.undefined
        if the task has not yet been executed, was unscheduled before
        execution, or raised an exception on execution.

        """
        return self._result


class ProxyResolver(Atom):
    """ An object which resolves requests for proxy objects.

    """
    #: A dictionary of factories functions to use when resolving the
    #: proxy. The function should take no arguments, and return the
    #: proxy class when called.
    factories = Dict()

    def resolve(self, name):
        """ Resolve the given name to a proxy calls.

        For example, 'Field' should resolve to a class which implements
        the ProxyField interface.

        Parameters
        ----------
        name : string
            The name of the proxy object to resolve.

        Returns
        -------
        result : type or None
            A class which implements the proxy interface, or None if
            no class can be found for the given name.

        """
        factory = self.factories.get(name)
        if factory is not None:
            return factory()


def StyleSheet():
    """ A lazy importer for the Enaml StyleSheet class.

    """
    from enaml.styling import StyleSheet
    return StyleSheet


class Application(Atom):
    """ The application object which manages the top-level communication
    protocol for serving Enaml views.

    """
    #: The proxy resolver to use for the application. This will normally
    #: be supplied by application subclasses, but can also be supplied
    #: by the developer to supply custom proxy resolution behavior.
    resolver = Typed(ProxyResolver)

    #: The style sheet to apply to the entire application.
    style_sheet = ForwardTyped(StyleSheet)

    #: The task heap for application tasks.
    _task_heap = List()

    #: The counter to break heap ties.
    _counter = Value(factory=count)

    #: The heap lock for protecting heap access.
    _heap_lock = Value(factory=Lock)

    #: Private class storage for the singleton application instance.
    _instance = None

    @staticmethod
    def instance():
        """ Get the global Application instance.

        Returns
        -------
        result : Application or None
            The global application instance, or None if one has not yet
            been created.

        """
        return Application._instance

    def __new__(cls, *args, **kwargs):
        """ Create a new Enaml Application.

        There may be only one application instance in existence at any
        point in time. Attempting to create a new Application when one
        exists will raise an exception.

        """
        if Application._instance is not None:
            raise RuntimeError('An Application instance already exists')
        self = super(Application, cls).__new__(cls, *args, **kwargs)
        Application._instance = self
        return self

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _process_task(self, task):
        """ Processes the given task, then dispatches the next task.

        """
        try:
            task._execute()
        finally:
            self._next_task()

    def _next_task(self):
        """ Pulls the next task off the heap and processes it on the
        main gui thread.

        """
        heap = self._task_heap
        with self._heap_lock:
            if heap:
                priority, ignored, task = heappop(heap)
                self.deferred_call(self._process_task, task)

    @observe('style_sheet.destroyed')
    def _clear_destroyed_style_sheet(self, change):
        """ An observer which clears a destroyed style sheet.

        """
        self.style_sheet = None

    @observe('style_sheet')
    def _invalidate_style_cache(self, change):
        """ An observer which invalidates the style sheet cache.

        """
        if change['type'] == 'update':
            from enaml.styling import StyleCache
            StyleCache._app_sheet_changed()

    #--------------------------------------------------------------------------
    # Abstract API
    #--------------------------------------------------------------------------
    def start(self):
        """ Start the application's main event loop.

        """
        raise NotImplementedError

    def stop(self):
        """ Stop the application's main event loop.

        """
        raise NotImplementedError

    def deferred_call(self, callback, *args, **kwargs):
        """ Invoke a callable on the next cycle of the main event loop
        thread.

        Parameters
        ----------
        callback : callable
            The callable object to execute at some point in the future.

        *args, **kwargs
            Any additional positional and keyword arguments to pass to
            the callback.

        """
        raise NotImplementedError

    def timed_call(self, ms, callback, *args, **kwargs):
        """ Invoke a callable on the main event loop thread at a
        specified time in the future.

        Parameters
        ----------
        ms : int
            The time to delay, in milliseconds, before executing the
            callable.

        callback : callable
            The callable object to execute at some point in the future.

        *args, **kwargs
            Any additional positional and keyword arguments to pass to
            the callback.

        """
        raise NotImplementedError

    def is_main_thread(self):
        """ Indicates whether the caller is on the main gui thread.

        Returns
        -------
        result : bool
            True if called from the main gui thread. False otherwise.

        """
        raise NotImplementedError

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def resolve_proxy_class(self, declaration_class):
        """ Resolve the proxy implementation class for a declaration.

        This can be reimplemented by Application subclasses if more
        control is needed.

        Parameters
        ----------
        declaration_class : type
            A ToolkitObject subclass for which the proxy implementation
            class should be resolved.

        Returns
        -------
        result : type
            A ProxyToolkitObject subclass for the given class, or None
            if one could not be resolved.

        """
        resolver = self.resolver
        for base in declaration_class.mro():
            name = base.__name__
            cls = resolver.resolve(name)
            if cls is not None:
                return cls

    def create_proxy(self, declaration):
        """ Create the proxy object for the given declaration.

        This can be reimplemented by Application subclasses if more
        control is needed.

        Parameters
        ----------
        declaration : ToolkitObject
            The object for which a toolkit proxy should be created.

        Returns
        -------
        result : ProxyToolkitObject or None
            An appropriate toolkit proxy object, or None if one cannot
            be create for the given declaration object.

        """
        cls = self.resolve_proxy_class(type(declaration))
        if cls is not None:
            return cls(declaration=declaration)
        msg = "could not resolve a toolkit implementation for the '%s' "
        msg += "component when running under a '%s'"
        d_name = type(declaration).__name__
        a_name = type(self).__name__
        raise TypeError(msg % (d_name, a_name))

    def schedule(self, callback, args=None, kwargs=None, priority=0):
        """ Schedule a callable to be executed on the event loop thread.

        This call is thread-safe.

        Parameters
        ----------
        callback : callable
            The callable object to be executed.

        args : tuple, optional
            The positional arguments to pass to the callable.

        kwargs : dict, optional
            The keyword arguments to pass to the callable.

        priority : int, optional
            The queue priority for the callable. Smaller values indicate
            lower priority, larger values indicate higher priority. The
            default priority is zero.

        Returns
        -------
        result : ScheduledTask
            A task object which can be used to unschedule the task or
            retrieve the results of the callback after the task has
            been executed.

        """
        if args is None:
            args = ()
        if kwargs is None:
            kwargs = {}
        task = ScheduledTask(callback, args, kwargs)
        heap = self._task_heap
        with self._heap_lock:
            needs_start = len(heap) == 0
            item = (-priority, self._counter.next(), task)
            heappush(heap, item)
        if needs_start:
            if self.is_main_thread():
                self._next_task()
            else:
                self.deferred_call(self._next_task)
        return task

    def has_pending_tasks(self):
        """ Get whether or not the application has pending tasks.

        Returns
        -------
        result : bool
            True if there are pending tasks. False otherwise.

        """
        heap = self._task_heap
        with self._heap_lock:
            has_pending = len(heap) > 0
        return has_pending

    def destroy(self):
        """ Destroy this application instance.

        Once an application is created, it must be destroyed before a
        new application can be instantiated.

        """
        self.stop()
        Application._instance = None


#------------------------------------------------------------------------------
# Helper Functions
#------------------------------------------------------------------------------
def deferred_call(callback, *args, **kwargs):
    """ Invoke a callable on the next cycle of the main event loop
    thread.

    This is a convenience function for invoking the same method on the
    current application instance. If an application instance does not
    exist, a RuntimeError will be raised.

    Parameters
    ----------
    callback : callable
        The callable object to execute at some point in the future.

    *args, **kwargs
        Any additional positional and keyword arguments to pass to
        the callback.

    """
    app = Application.instance()
    if app is None:
        raise RuntimeError('Application instance does not exist')
    app.deferred_call(callback, *args, **kwargs)


def timed_call(ms, callback, *args, **kwargs):
    """ Invoke a callable on the main event loop thread at a specified
    time in the future.

    This is a convenience function for invoking the same method on the
    current application instance. If an application instance does not
    exist, a RuntimeError will be raised.

    Parameters
    ----------
    ms : int
        The time to delay, in milliseconds, before executing the
        callable.

    callback : callable
        The callable object to execute at some point in the future.

    *args, **kwargs
        Any additional positional and keyword arguments to pass to
        the callback.

    """
    app = Application.instance()
    if app is None:
        raise RuntimeError('Application instance does not exist')
    app.timed_call(ms, callback, *args, **kwargs)


def is_main_thread():
    """ Indicates whether the caller is on the main gui thread.

    This is a convenience function for invoking the same method on the
    current application instance. If an application instance does not
    exist, a RuntimeError will be raised.

    Returns
    -------
    result : bool
        True if called from the main gui thread. False otherwise.

    """
    app = Application.instance()
    if app is None:
        raise RuntimeError('Application instance does not exist')
    return app.is_main_thread()


def schedule(callback, args=None, kwargs=None, priority=0):
    """ Schedule a callable to be executed on the event loop thread.

    This call is thread-safe.

    This is a convenience function for invoking the same method on the
    current application instance. If an application instance does not
    exist, a RuntimeError will be raised.

    Parameters
    ----------
    callback : callable
        The callable object to be executed.

    args : tuple, optional
        The positional arguments to pass to the callable.

    kwargs : dict, optional
        The keyword arguments to pass to the callable.

    priority : int, optional
        The queue priority for the callable. Smaller values indicate
        lower priority, larger values indicate higher priority. The
        default priority is zero.

    Returns
    -------
    result : ScheduledTask
        A task object which can be used to unschedule the task or
        retrieve the results of the callback after the task has
        been executed.

    """
    app = Application.instance()
    if app is None:
        raise RuntimeError('Application instance does not exist')
    return app.schedule(callback, args, kwargs, priority)

########NEW FILE########
__FILENAME__ = colors
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
""" A utility module for dealing with CSS3 color strings.

"""
from colorsys import hls_to_rgb
import re

from atom.api import Coerced

from .colorext import Color


#: Regex sub-expressions used for building more complex expression.
_int = r'\s*((?:\+|\-)?[0-9]+)\s*'
_real = r'\s*((?:\+|\-)?[0-9]*(?:\.[0-9]+)?)\s*'
_perc = r'\s*((?:\+|\-)?[0-9]*(?:\.[0-9]+)?)%\s*'

#: Regular expressions used by the parsing routines.
_HEX_RE = re.compile(r'^#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{6})$', re.UNICODE)
_HEXA_RE = re.compile(r'^#([A-Fa-f0-9]{4}|[A-Fa-f0-9]{8})$', re.UNICODE)
_RGB_NUM_RE = re.compile(r'^rgb\(%s,%s,%s\)$' % (_int, _int, _int), re.UNICODE)
_RGB_PER_RE = re.compile(r'^rgb\(%s,%s,%s\)$' % (_perc, _perc, _perc), re.UNICODE)
_RGBA_NUM_RE = re.compile(r'^rgba\(%s,%s,%s,%s\)$' % (_int, _int, _int, _real), re.UNICODE)
_RGBA_PER_RE = re.compile(r'^rgba\(%s,%s,%s,%s\)$' % (_perc, _perc, _perc, _real), re.UNICODE)
_HSL_RE = re.compile(r'^hsl\(%s,%s,%s\)$' % (_real, _perc, _perc), re.UNICODE)
_HSLA_RE = re.compile(r'^hsla\(%s,%s,%s,%s\)$' % (_real, _perc, _perc, _real), re.UNICODE)


#: A table of all 147 named SVG colors supported by CSS3.
SVG_COLORS = {
    'aliceblue': Color(240, 248, 255),
    'antiquewhite': Color(250, 235, 215),
    'aqua': Color(0, 255, 255),
    'aquamarine': Color(127, 255, 212),
    'azure': Color(240, 255, 255),
    'beige': Color(245, 245, 220),
    'bisque': Color(255, 228, 196),
    'black': Color(0, 0, 0),
    'blanchedalmond': Color(255, 235, 205),
    'blue': Color(0, 0, 255),
    'blueviolet': Color(138, 43, 226),
    'brown': Color(165, 42, 42),
    'burlywood': Color(222, 184, 135),
    'cadetblue': Color(95, 158, 160),
    'chartreuse': Color(127, 255, 0),
    'chocolate': Color(210, 105, 30),
    'coral': Color(255, 127, 80),
    'cornflowerblue': Color(100, 149, 237),
    'cornsilk': Color(255, 248, 220),
    'crimson': Color(220, 20, 60),
    'cyan': Color(0, 255, 255),
    'darkblue': Color(0, 0, 139),
    'darkcyan': Color(0, 139, 139),
    'darkgoldenrod': Color(184, 134, 11),
    'darkgray': Color(169, 169, 169),
    'darkgreen': Color(0, 100, 0),
    'darkgrey': Color(169, 169, 169),
    'darkkhaki': Color(189, 183, 107),
    'darkmagenta': Color(139, 0, 139),
    'darkolivegreen': Color(85, 107, 47),
    'darkorange': Color(255, 140, 0),
    'darkorchid': Color(153, 50, 204),
    'darkred': Color(139, 0, 0),
    'darksalmon': Color(233, 150, 122),
    'darkseagreen': Color(143, 188, 143),
    'darkslateblue': Color(72, 61, 139),
    'darkslategray': Color(47, 79, 79),
    'darkslategrey': Color(47, 79, 79),
    'darkturquoise': Color(0, 206, 209),
    'darkviolet': Color(148, 0, 211),
    'deeppink': Color(255, 20, 147),
    'deepskyblue': Color(0, 191, 255),
    'dimgray': Color(105, 105, 105),
    'dimgrey': Color(105, 105, 105),
    'dodgerblue': Color(30, 144, 255),
    'firebrick': Color(178, 34, 34),
    'floralwhite': Color(255, 250, 240),
    'forestgreen': Color(34, 139, 34),
    'fuchsia': Color(255, 0, 255),
    'gainsboro': Color(220, 220, 220),
    'ghostwhite': Color(248, 248, 255),
    'gold': Color(255, 215, 0),
    'goldenrod': Color(218, 165, 32),
    'gray': Color(128, 128, 128),
    'grey': Color(128, 128, 128),
    'green': Color(0, 128, 0),
    'greenyellow': Color(173, 255, 47),
    'honeydew': Color(240, 255, 240),
    'hotpink': Color(255, 105, 180),
    'indianred': Color(205, 92, 92),
    'indigo': Color(75, 0, 130),
    'ivory': Color(255, 255, 240),
    'khaki': Color(240, 230, 140),
    'lavender': Color(230, 230, 250),
    'lavenderblush': Color(255, 240, 245),
    'lawngreen': Color(124, 252, 0),
    'lemonchiffon': Color(255, 250, 205),
    'lightblue': Color(173, 216, 230),
    'lightcoral': Color(240, 128, 128),
    'lightcyan': Color(224, 255, 255),
    'lightgoldenrodyellow': Color(250, 250, 210),
    'lightgray': Color(211, 211, 211),
    'lightgreen': Color(144, 238, 144),
    'lightgrey': Color(211, 211, 211),
    'lightpink': Color(255, 182, 193),
    'lightsalmon': Color(255, 160, 122),
    'lightseagreen': Color(32, 178, 170),
    'lightskyblue': Color(135, 206, 250),
    'lightslategray': Color(119, 136, 153),
    'lightslategrey': Color(119, 136, 153),
    'lightsteelblue': Color(176, 196, 222),
    'lightyellow': Color(255, 255, 224),
    'lime': Color(0, 255, 0),
    'limegreen': Color(50, 205, 50),
    'linen': Color(250, 240, 230),
    'magenta': Color(255, 0, 255),
    'maroon': Color(128, 0, 0),
    'mediumaquamarine': Color(102, 205, 170),
    'mediumblue': Color(0, 0, 205),
    'mediumorchid': Color(186, 85, 211),
    'mediumpurple': Color(147, 112, 219),
    'mediumseagreen': Color(60, 179, 113),
    'mediumslateblue': Color(123, 104, 238),
    'mediumspringgreen': Color(0, 250, 154),
    'mediumturquoise': Color(72, 209, 204),
    'mediumvioletred': Color(199, 21, 133),
    'midnightblue': Color(25, 25, 112),
    'mintcream': Color(245, 255, 250),
    'mistyrose': Color(255, 228, 225),
    'moccasin': Color(255, 228, 181),
    'navajowhite': Color(255, 222, 173),
    'navy': Color(0, 0, 128),
    'oldlace': Color(253, 245, 230),
    'olive': Color(128, 128, 0),
    'olivedrab': Color(107, 142, 35),
    'orange': Color(255, 165, 0),
    'orangered': Color(255, 69, 0),
    'orchid': Color(218, 112, 214),
    'palegoldenrod': Color(238, 232, 170),
    'palegreen': Color(152, 251, 152),
    'paleturquoise': Color(175, 238, 238),
    'palevioletred': Color(219, 112, 147),
    'papayawhip': Color(255, 239, 213),
    'peachpuff': Color(255, 218, 185),
    'peru': Color(205, 133, 63),
    'pink': Color(255, 192, 203),
    'plum': Color(221, 160, 221),
    'powderblue': Color(176, 224, 230),
    'purple': Color(128, 0, 128),
    'red': Color(255, 0, 0),
    'rosybrown': Color(188, 143, 143),
    'royalblue': Color(65, 105, 225),
    'saddlebrown': Color(139, 69, 19),
    'salmon': Color(250, 128, 114),
    'sandybrown': Color(244, 164, 96),
    'seagreen': Color(46, 139, 87),
    'seashell': Color(255, 245, 238),
    'sienna': Color(160, 82, 45),
    'silver': Color(192, 192, 192),
    'skyblue': Color(135, 206, 235),
    'slateblue': Color(106, 90, 205),
    'slategray': Color(112, 128, 144),
    'slategrey': Color(112, 128, 144),
    'snow': Color(255, 250, 250),
    'springgreen': Color(0, 255, 127),
    'steelblue': Color(70, 130, 180),
    'tan': Color(210, 180, 140),
    'teal': Color(0, 128, 128),
    'thistle': Color(216, 191, 216),
    'tomato': Color(255, 99, 71),
    'turquoise': Color(64, 224, 208),
    'violet': Color(238, 130, 238),
    'wheat': Color(245, 222, 179),
    'white': Color(255, 255, 255),
    'whitesmoke': Color(245, 245, 245),
    'yellow': Color(255, 255, 0),
    'yellowgreen': Color(154, 205, 50),
}


def _parse_hex_color(color):
    """ Parse a CSS color string which starts with the '#' character.

    """
    int_ = int
    match = _HEX_RE.match(color)
    if match is not None:
        hex_str = match.group(1)
        if len(hex_str) == 3:
            r = int_(hex_str[0], 16)
            r |= (r << 4)
            g = int_(hex_str[1], 16)
            g |= (g << 4)
            b = int_(hex_str[2], 16)
            b |= (b << 4)
        else:
            r = int_(hex_str[:2], 16)
            g = int_(hex_str[2:4], 16)
            b = int_(hex_str[4:6], 16)
        return Color(r, g, b, 255)
    match = _HEXA_RE.match(color)
    if match is not None:
        hex_str = match.group(1)
        if len(hex_str) == 4:
            r = int_(hex_str[0], 16)
            r |= (r << 4)
            g = int_(hex_str[1], 16)
            g |= (g << 4)
            b = int_(hex_str[2], 16)
            b |= (b << 4)
            a = int_(hex_str[3], 16)
            a |= (a << 4)
        else:
            r = int_(hex_str[:2], 16)
            g = int_(hex_str[2:4], 16)
            b = int_(hex_str[4:6], 16)
            a = int_(hex_str[6:8], 16)
        return Color(r, g, b, a)


def _parse_rgb_color(color):
    """ Parse a CSS color string which starts with the 'r' character.

    """
    int_ = int
    min_ = min
    max_ = max
    match = _RGB_NUM_RE.match(color)
    if match is not None:
        rs, gs, bs = match.groups()
        r = max_(0, min_(255, int_(rs)))
        g = max_(0, min_(255, int_(gs)))
        b = max_(0, min_(255, int_(bs)))
        return Color(r, g, b, 255)

    float_ = float
    match = _RGB_PER_RE.match(color)
    if match is not None:
        rs, gs, bs = match.groups()
        r = max_(0.0, min_(100.0, float_(rs))) / 100.0
        g = max_(0.0, min_(100.0, float_(gs))) / 100.0
        b = max_(0.0, min_(100.0, float_(bs))) / 100.0
        r = int_(255 * r)
        g = int_(255 * g)
        b = int_(255 * b)
        return Color(r, g, b, 255)

    match = _RGBA_NUM_RE.match(color)
    if match is not None:
        rs, gs, bs, as_ = match.groups()
        r = max_(0, min_(255, int_(rs)))
        g = max_(0, min_(255, int_(gs)))
        b = max_(0, min_(255, int_(bs)))
        a = max_(0.0, min_(1.0, float_(as_)))
        a = int_(255 * a)
        return Color(r, g, b, a)

    match = _RGBA_PER_RE.match(color)
    if match is not None:
        rs, gs, bs, as_ = match.groups()
        r = max_(0.0, min_(100.0, float_(rs))) / 100.0
        g = max_(0.0, min_(100.0, float_(gs))) / 100.0
        b = max_(0.0, min_(100.0, float_(bs))) / 100.0
        a = max_(0.0, min_(1.0, float_(as_)))
        r = int_(255 * r)
        g = int_(255 * g)
        b = int_(255 * b)
        a = int_(255 * a)
        return Color(r, g, b, a)


def _parse_hsl_color(color):
    """ Parse a CSS color string that starts with the 'h' character.

    """
    float_ = float
    int_ = int
    min_ = min
    max_ = max
    match = _HSL_RE.match(color)
    if match is not None:
        hs, ss, ls = match.groups()
        h = ((float_(hs) % 360.0 + 360.0) % 360.0) / 360.0
        s = max_(0.0, min_(100.0, float_(ss))) / 100.0
        l = max_(0.0, min_(100.0, float_(ls))) / 100.0
        r, g, b = hls_to_rgb(h, l, s)
        r = int_(255 * r)
        g = int_(255 * g)
        b = int_(255 * b)
        return Color(r, g, b, 255)

    match = _HSLA_RE.match(color)
    if match is not None:
        hs, ss, ls, as_ = match.groups()
        h = ((float_(hs) % 360.0 + 360.0) % 360.0) / 360.0
        s = max_(0.0, min_(100.0, float_(ss))) / 100.0
        l = max_(0.0, min_(100.0, float_(ls))) / 100.0
        a = max_(0.0, min_(1.0, float_(as_)))
        r, g, b = hls_to_rgb(h, l, s)
        r = int_(255 * r)
        g = int_(255 * g)
        b = int_(255 * b)
        a = int_(255 * a)
        return Color(r, g, b, a)


#: A dispatch table of color parser functions.
_COLOR_PARSERS = {
    '#': _parse_hex_color,
    'r': _parse_rgb_color,
    'h': _parse_hsl_color,
}


def parse_color(color):
    """ Parse a CSS3 color string into a tuple of RGBA values.

    Parameters
    ----------
    color : string
        A CSS3 string representation of the color.

    Returns
    -------
    result : Color or None
        A color object representing the parsed color. If the string
        is invalid, None will be returned.

    """
    if color in SVG_COLORS:
        return SVG_COLORS[color]
    color = color.strip()
    if color:
        key = color[0]
        if key in _COLOR_PARSERS:
            return _COLOR_PARSERS[key](color)


def coerce_color(color):
    """ The coercing function for the ColorMember.

    """
    if isinstance(color, basestring):
        return parse_color(color)


class ColorMember(Coerced):
    """ An Atom member class which coerces a value to a color.

    A color member can be set to a Color, a string, or None. A string
    color will be parsed into a Color object. If the parsing fails,
    the color will be None.

    """
    __slots__ = ()

    def __init__(self, default=None, factory=None):
        """ Initialize a ColorMember.

        default : Color, string, or None, optional
            The default color to use for the member.

        factory : callable, optional
            An optional callable which takes no arguments and returns
            the default value for the member. If this is provided, it
            will override any value passed as 'default'.

        Notes
        -----
        When providing a default color value, prefer using a Color
        object or a named color string as these color objects will be
        shared among all instances of the class. Using a color string
        which must be parsed will result in a new Color object being
        created for each class instance.

        """
        if factory is None:
            factory = lambda: default
        kind = (Color, type(None))
        sup = super(ColorMember, self)
        sup.__init__(kind, factory=factory, coercer=coerce_color)

########NEW FILE########
__FILENAME__ = api
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from .conditional import Conditional
from .declarative import Declarative, d_, d_func
from .dynamic_template import DynamicTemplate
from .include import Include
from .looper import Looper
from .object import Object

########NEW FILE########
__FILENAME__ = block_compiler
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from . import compiler_common as cmn


class BaseBlockCompiler(cmn.CompilerBase):
    """ The base class of the block compilers.

    """
    #: The set of local names for the compiler.
    local_names = Typed(set, ())

    #: A mapping of ast node -> compiler node index for the block.
    index_map = Typed(dict, ())

    def parent_index(self):
        """ Get the node index for the parent node.

        Returns
        -------
        result : int
            The compiler node index for the node represented by the
            current parent ast node.

        """
        return self.index_map[self.ancestor()]


class FirstPassBlockCompiler(BaseBlockCompiler):
    """ The first pass block compiler.

    This is a base class for the first pass compilers for the enamldef
    and template block definitions.

    """
    #: A mapping of auxiliary ast node -> compiler node index.
    aux_index_map = Typed(dict, ())

    def visit_ChildDef(self, node):
        # Claim the index for the compiler node.
        index = len(self.index_map)
        self.index_map[node] = index

        # Setup the line number for the child def.
        cg = self.code_generator
        cg.set_lineno(node.lineno)

        # Generate the child def compiler node.
        cmn.gen_child_def_node(cg, node, self.local_names)

        # Store the compiler node in the node list.
        cmn.store_node(cg, index)

        # Append the compiler node to the parent node.
        cmn.append_node(cg, self.parent_index(), index)

        # Visit the body of the child def.
        for item in node.body:
            self.visit(item)

    def visit_TemplateInst(self, node):
        # No pragmas are supported yet for template inst nodes.
        cmn.warn_pragmas(node, self.filename)

        # Claim the index for the compiler node.
        index = len(self.index_map)
        self.index_map[node] = index

        # Setup the line number for the template inst.
        cg = self.code_generator
        cg.set_lineno(node.lineno)

        # Generate the template inst compiler node.
        cmn.gen_template_inst_node(cg, node, self.local_names)

        # Store the compiler node in the node list.
        cmn.store_node(cg, index)

        # Append the compiler node to the parent node.
        cmn.append_node(cg, self.parent_index(), index)

        # Visit the body of the template inst.
        for item in node.body:
            self.visit(item)

    def visit_TemplateInstBinding(self, node):
        # Grab the index of the parent node for later use.
        self.aux_index_map[node] = self.parent_index()

    def visit_Binding(self, node):
        # Grab the index of the parent node for later use.
        self.aux_index_map[node] = self.parent_index()

    def visit_ExBinding(self, node):
        # Grab the index of the parent node for later use.
        self.aux_index_map[node] = self.parent_index()

    def visit_AliasExpr(self, node):
        # Grab the index of the parent node for later use.
        self.aux_index_map[node] = self.parent_index()

    def visit_StorageExpr(self, node):
        # Grab the index of the parent node for later use.
        self.aux_index_map[node] = self.parent_index()

    def visit_FuncDef(self, node):
        # Grab the index of the parent node for later use.
        self.aux_index_map[node] = self.parent_index()


class SecondPassBlockCompiler(BaseBlockCompiler):
    """ The second pass block compiler.

    This is a base class for the second pass compilers for the enamldef
    and template block definitions.

    """
    def visit_ChildDef(self, node):
        # Visit the body of the child def.
        for item in node.body:
            self.visit(item)

    def visit_TemplateInst(self, node):
        if node.body:
            # Create the unpack map.
            cg = self.code_generator
            index = self.index_map[node]
            cmn.load_helper(cg, 'make_unpack_map')
            cmn.load_node(cg, index)
            cg.call_function(1)
            cg.store_fast(cmn.UNPACK_MAP)

            # Visit the body of the template inst.
            for item in node.body:
                self.visit(item)

    def visit_TemplateInstBinding(self, node):
        # Generate the code for the template inst binding.
        cg = self.code_generator
        index = self.parent_index()
        cmn.gen_template_inst_binding(cg, node, index)

    def visit_Binding(self, node):
        # Generate the code for the operator binding.
        cg = self.code_generator
        index = self.parent_index()
        cmn.gen_operator_binding(cg, node.expr, index, node.name)

    def visit_ExBinding(self, node):
        # Generate the code for the operator binding.
        cg = self.code_generator
        index = self.parent_index()
        cmn.gen_operator_binding(cg, node.expr, index, node.chain)

    def visit_AliasExpr(self, node):
        # Generate the code for the alias expression.
        cg = self.code_generator
        index = self.parent_index()
        cmn.gen_alias_expr(cg, node, index)

    def visit_StorageExpr(self, node):
        # Generate the code for the storage expression.
        cg = self.code_generator
        index = self.parent_index()
        cmn.gen_storage_expr(cg, node, index, self.local_names)
        if node.expr is not None:
            cmn.gen_operator_binding(cg, node.expr, index, node.name)

    def visit_FuncDef(self, node):
        # Generate the code for the function declaration.
        cg = self.code_generator
        index = self.parent_index()
        cmn.gen_decl_funcdef(cg, node, index)

########NEW FILE########
__FILENAME__ = byteplay
# byteplay - Python bytecode assembler/disassembler.
# Copyright (C) 2006-2010 Noam Yorav-Raphael
# Homepage: http://code.google.com/p/byteplay
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

# Many thanks to Greg X for adding support for Python 2.6 and 2.7!

__version__ = '0.2'

__all__ = ['opmap', 'opname', 'opcodes',
           'cmp_op', 'hasarg', 'hasname', 'hasjrel', 'hasjabs',
           'hasjump', 'haslocal', 'hascompare', 'hasfree', 'hascode',
           'hasflow', 'getse',
           'Opcode', 'SetLineno', 'Label', 'isopcode', 'Code',
           'CodeList', 'printcodelist']

import opcode
from dis import findlabels
import types
from array import array
import operator
import itertools
import sys
import warnings
from cStringIO import StringIO

######################################################################
# Define opcodes and information about them

python_version = '.'.join(str(x) for x in sys.version_info[:2])
if python_version not in ('2.4', '2.5', '2.6', '2.7'):
    warnings.warn("byteplay doesn't support Python version "+python_version)

class Opcode(int):
    """An int which represents an opcode - has a nicer repr."""
    def __repr__(self):
        return opname[self]
    __str__ = __repr__

class CodeList(list):
    """A list for storing opcode tuples - has a nicer __str__."""
    def __str__(self):
        f = StringIO()
        printcodelist(self, f)
        return f.getvalue()

opmap = dict((name.replace('+', '_'), Opcode(code))
             for name, code in opcode.opmap.iteritems()
             if name != 'EXTENDED_ARG')
opname = dict((code, name) for name, code in opmap.iteritems())
opcodes = set(opname)

def globalize_opcodes():
    for name, code in opmap.iteritems():
        globals()[name] = code
        __all__.append(name)
globalize_opcodes()

cmp_op = opcode.cmp_op

hasarg = set(x for x in opcodes if x >= opcode.HAVE_ARGUMENT)
hasconst = set(Opcode(x) for x in opcode.hasconst)
hasname = set(Opcode(x) for x in opcode.hasname)
hasjrel = set(Opcode(x) for x in opcode.hasjrel)
hasjabs = set(Opcode(x) for x in opcode.hasjabs)
hasjump = hasjrel.union(hasjabs)
haslocal = set(Opcode(x) for x in opcode.haslocal)
hascompare = set(Opcode(x) for x in opcode.hascompare)
hasfree = set(Opcode(x) for x in opcode.hasfree)
hascode = set([MAKE_FUNCTION, MAKE_CLOSURE])

class _se:
    """Quick way of defining static stack effects of opcodes"""
    # Taken from assembler.py by Phillip J. Eby
    NOP       = 0,0

    POP_TOP   = 1,0
    ROT_TWO   = 2,2
    ROT_THREE = 3,3
    ROT_FOUR  = 4,4
    DUP_TOP   = 1,2

    UNARY_POSITIVE = UNARY_NEGATIVE = UNARY_NOT = UNARY_CONVERT = \
        UNARY_INVERT = GET_ITER = LOAD_ATTR = 1,1

    IMPORT_FROM = 1,2

    BINARY_POWER = BINARY_MULTIPLY = BINARY_DIVIDE = BINARY_FLOOR_DIVIDE = \
        BINARY_TRUE_DIVIDE = BINARY_MODULO = BINARY_ADD = BINARY_SUBTRACT = \
        BINARY_SUBSCR = BINARY_LSHIFT = BINARY_RSHIFT = BINARY_AND = \
        BINARY_XOR = BINARY_OR = COMPARE_OP = 2,1

    INPLACE_POWER = INPLACE_MULTIPLY = INPLACE_DIVIDE = \
        INPLACE_FLOOR_DIVIDE = INPLACE_TRUE_DIVIDE = INPLACE_MODULO = \
        INPLACE_ADD = INPLACE_SUBTRACT = INPLACE_LSHIFT = INPLACE_RSHIFT = \
        INPLACE_AND = INPLACE_XOR = INPLACE_OR = 2,1

    SLICE_0, SLICE_1, SLICE_2, SLICE_3 = \
        (1,1),(2,1),(2,1),(3,1)
    STORE_SLICE_0, STORE_SLICE_1, STORE_SLICE_2, STORE_SLICE_3 = \
        (2,0),(3,0),(3,0),(4,0)
    DELETE_SLICE_0, DELETE_SLICE_1, DELETE_SLICE_2, DELETE_SLICE_3 = \
        (1,0),(2,0),(2,0),(3,0)

    STORE_SUBSCR = 3,0
    DELETE_SUBSCR = STORE_ATTR = 2,0
    DELETE_ATTR = STORE_DEREF = 1,0
    PRINT_NEWLINE = 0,0
    PRINT_EXPR = PRINT_ITEM = PRINT_NEWLINE_TO = IMPORT_STAR = 1,0
    STORE_NAME = STORE_GLOBAL = STORE_FAST = 1,0
    PRINT_ITEM_TO = 2,0

    LOAD_LOCALS = LOAD_CONST = LOAD_NAME = LOAD_GLOBAL = LOAD_FAST = \
        LOAD_CLOSURE = LOAD_DEREF = BUILD_MAP = 0,1

    DELETE_FAST = DELETE_GLOBAL = DELETE_NAME = 0,0

    EXEC_STMT = 3,0
    BUILD_CLASS = 3,1

    STORE_MAP = MAP_ADD = 2,0
    SET_ADD = 1,0

    if   python_version == '2.4':
      YIELD_VALUE = 1,0
      IMPORT_NAME = 1,1
      LIST_APPEND = 2,0
    elif python_version == '2.5':
      YIELD_VALUE = 1,1
      IMPORT_NAME = 2,1
      LIST_APPEND = 2,0
    elif python_version == '2.6':
      YIELD_VALUE = 1,1
      IMPORT_NAME = 2,1
      LIST_APPEND = 2,0
    elif python_version == '2.7':
      YIELD_VALUE = 1,1
      IMPORT_NAME = 2,1
      LIST_APPEND = 1,0


_se = dict((op, getattr(_se, opname[op]))
           for op in opcodes
           if hasattr(_se, opname[op]))

hasflow = opcodes - set(_se) - \
          set([CALL_FUNCTION, CALL_FUNCTION_VAR, CALL_FUNCTION_KW,
               CALL_FUNCTION_VAR_KW, BUILD_TUPLE, BUILD_LIST,
               UNPACK_SEQUENCE, BUILD_SLICE, DUP_TOPX,
               RAISE_VARARGS, MAKE_FUNCTION, MAKE_CLOSURE])
if python_version == '2.7':
  hasflow = hasflow - set([BUILD_SET])

def getse(op, arg=None):
    """Get the stack effect of an opcode, as a (pop, push) tuple.

    If an arg is needed and is not given, a ValueError is raised.
    If op isn't a simple opcode, that is, the flow doesn't always continue
    to the next opcode, a ValueError is raised.
    """
    try:
        return _se[op]
    except KeyError:
        # Continue to opcodes with an effect that depends on arg
        pass

    if arg is None:
        raise ValueError, "Opcode stack behaviour depends on arg"

    def get_func_tup(arg, nextra):
        if arg > 0xFFFF:
            raise ValueError, "Can only split a two-byte argument"
        return (nextra + 1 + (arg & 0xFF) + 2*((arg >> 8) & 0xFF),
                1)

    if op == CALL_FUNCTION:
        return get_func_tup(arg, 0)
    elif op == CALL_FUNCTION_VAR:
        return get_func_tup(arg, 1)
    elif op == CALL_FUNCTION_KW:
        return get_func_tup(arg, 1)
    elif op == CALL_FUNCTION_VAR_KW:
        return get_func_tup(arg, 2)

    elif op == BUILD_TUPLE:
        return arg, 1
    elif op == BUILD_LIST:
        return arg, 1
    elif python_version == '2.7' and op == BUILD_SET:
        return arg, 1
    elif op == UNPACK_SEQUENCE:
        return 1, arg
    elif op == BUILD_SLICE:
        return arg, 1
    elif op == DUP_TOPX:
        return arg, arg*2
    elif op == RAISE_VARARGS:
        return 1+arg, 1
    elif op == MAKE_FUNCTION:
        return 1+arg, 1
    elif op == MAKE_CLOSURE:
        if python_version == '2.4':
            raise ValueError, "The stack effect of MAKE_CLOSURE depends on TOS"
        else:
            return 2+arg, 1
    else:
        raise ValueError, "The opcode %r isn't recognized or has a special "\
              "flow control" % op

class SetLinenoType(object):
    def __repr__(self):
        return 'SetLineno'
SetLineno = SetLinenoType()

class Label(object):
    pass

def isopcode(obj):
    """Return whether obj is an opcode - not SetLineno or Label"""
    return obj is not SetLineno and not isinstance(obj, Label)

# Flags from code.h
CO_OPTIMIZED              = 0x0001      # use LOAD/STORE_FAST instead of _NAME
CO_NEWLOCALS              = 0x0002      # only cleared for module/exec code
CO_VARARGS                = 0x0004
CO_VARKEYWORDS            = 0x0008
CO_NESTED                 = 0x0010      # ???
CO_GENERATOR              = 0x0020
CO_NOFREE                 = 0x0040      # set if no free or cell vars
CO_GENERATOR_ALLOWED      = 0x1000      # unused
# The future flags are only used on code generation, so we can ignore them.
# (It does cause some warnings, though.)
CO_FUTURE_DIVISION        = 0x2000
CO_FUTURE_ABSOLUTE_IMPORT = 0x4000
CO_FUTURE_WITH_STATEMENT  = 0x8000


######################################################################
# Define the Code class

class Code(object):
    """An object which holds all the information which a Python code object
    holds, but in an easy-to-play-with representation.

    The attributes are:

    Affecting action
    ----------------
    code - list of 2-tuples: the code
    freevars - list of strings: the free vars of the code (those are names
               of variables created in outer functions and used in the function)
    args - list of strings: the arguments of the code
    varargs - boolean: Does args end with a '*args' argument
    varkwargs - boolean: Does args end with a '**kwargs' argument
    newlocals - boolean: Should a new local namespace be created.
                (True in functions, False for module and exec code)

    Not affecting action
    --------------------
    name - string: the name of the code (co_name)
    filename - string: the file name of the code (co_filename)
    firstlineno - int: the first line number (co_firstlineno)
    docstring - string or None: the docstring (the first item of co_consts,
                if it's str or unicode)

    code is a list of 2-tuples. The first item is an opcode, or SetLineno, or a
    Label instance. The second item is the argument, if applicable, or None.
    code can be a CodeList instance, which will produce nicer output when
    being printed.
    """
    def __init__(self, code, freevars, args, varargs, varkwargs, newlocals,
                 name, filename, firstlineno, docstring):
        self.code = code
        self.freevars = freevars
        self.args = args
        self.varargs = varargs
        self.varkwargs = varkwargs
        self.newlocals = newlocals
        self.name = name
        self.filename = filename
        self.firstlineno = firstlineno
        self.docstring = docstring

    @staticmethod
    def _findlinestarts(code):
        """Find the offsets in a byte code which are start of lines in the
        source.

        Generate pairs (offset, lineno) as described in Python/compile.c.

        This is a modified version of dis.findlinestarts, which allows multiple
        "line starts" with the same line number.
        """
        byte_increments = [ord(c) for c in code.co_lnotab[0::2]]
        line_increments = [ord(c) for c in code.co_lnotab[1::2]]

        lineno = code.co_firstlineno
        addr = 0
        for byte_incr, line_incr in zip(byte_increments, line_increments):
            if byte_incr:
                yield (addr, lineno)
                addr += byte_incr
            lineno += line_incr
        yield (addr, lineno)

    @classmethod
    def from_code(cls, co):
        """Disassemble a Python code object into a Code object."""
        co_code = co.co_code
        labels = dict((addr, Label()) for addr in findlabels(co_code))
        linestarts = dict(cls._findlinestarts(co))
        cellfree = co.co_cellvars + co.co_freevars

        code = CodeList()
        n = len(co_code)
        i = 0
        extended_arg = 0
        while i < n:
            op = Opcode(ord(co_code[i]))
            if i in labels:
                code.append((labels[i], None))
            if i in linestarts:
                code.append((SetLineno, linestarts[i]))
            i += 1
            if op in hascode:
                lastop, lastarg = code[-1]
                if lastop != LOAD_CONST:
                    raise ValueError, \
                          "%s should be preceded by LOAD_CONST code" % op
                code[-1] = (LOAD_CONST, Code.from_code(lastarg))
            if op not in hasarg:
                code.append((op, None))
            else:
                arg = ord(co_code[i]) + ord(co_code[i+1])*256 + extended_arg
                extended_arg = 0
                i += 2
                if op == opcode.EXTENDED_ARG:
                    extended_arg = arg << 16
                elif op in hasconst:
                    code.append((op, co.co_consts[arg]))
                elif op in hasname:
                    code.append((op, co.co_names[arg]))
                elif op in hasjabs:
                    code.append((op, labels[arg]))
                elif op in hasjrel:
                    code.append((op, labels[i + arg]))
                elif op in haslocal:
                    code.append((op, co.co_varnames[arg]))
                elif op in hascompare:
                    code.append((op, cmp_op[arg]))
                elif op in hasfree:
                    code.append((op, cellfree[arg]))
                else:
                    code.append((op, arg))

        varargs = bool(co.co_flags & CO_VARARGS)
        varkwargs = bool(co.co_flags & CO_VARKEYWORDS)
        newlocals = bool(co.co_flags & CO_NEWLOCALS)
        args = co.co_varnames[:co.co_argcount + varargs + varkwargs]
        if co.co_consts and isinstance(co.co_consts[0], basestring):
            docstring = co.co_consts[0]
        else:
            docstring = None
        return cls(code = code,
                   freevars = co.co_freevars,
                   args = args,
                   varargs = varargs,
                   varkwargs = varkwargs,
                   newlocals = newlocals,
                   name = co.co_name,
                   filename = co.co_filename,
                   firstlineno = co.co_firstlineno,
                   docstring = docstring,
                   )

    def __eq__(self, other):
        if (self.freevars != other.freevars or
            self.args != other.args or
            self.varargs != other.varargs or
            self.varkwargs != other.varkwargs or
            self.newlocals != other.newlocals or
            self.name != other.name or
            self.filename != other.filename or
            self.firstlineno != other.firstlineno or
            self.docstring != other.docstring or
            len(self.code) != len(other.code)
            ):
            return False

        # Compare code. This isn't trivial because labels should be matching,
        # not equal.
        labelmapping = {}
        for (op1, arg1), (op2, arg2) in itertools.izip(self.code, other.code):
            if isinstance(op1, Label):
                if labelmapping.setdefault(op1, op2) is not op2:
                    return False
            else:
                if op1 != op2:
                    return False
                if op1 in hasjump:
                    if labelmapping.setdefault(arg1, arg2) is not arg2:
                        return False
                elif op1 in hasarg:
                    if arg1 != arg2:
                        return False
        return True

    def _compute_flags(self):
        opcodes = set(op for op, arg in self.code if isopcode(op))

        optimized = (STORE_NAME not in opcodes and
                     LOAD_NAME not in opcodes and
                     DELETE_NAME not in opcodes)
        generator = (YIELD_VALUE in opcodes)
        nofree = not (opcodes.intersection(hasfree))

        flags = 0
        if optimized: flags |= CO_OPTIMIZED
        if self.newlocals: flags |= CO_NEWLOCALS
        if self.varargs: flags |= CO_VARARGS
        if self.varkwargs: flags |= CO_VARKEYWORDS
        if generator: flags |= CO_GENERATOR
        if nofree: flags |= CO_NOFREE
        return flags

    def _compute_stacksize(self):
        """Get a code list, compute its maximal stack usage."""
        # This is done by scanning the code, and computing for each opcode
        # the stack state at the opcode.
        code = self.code

        # A mapping from labels to their positions in the code list
        label_pos = dict((op, pos)
                         for pos, (op, arg) in enumerate(code)
                         if isinstance(op, Label))

        # sf_targets are the targets of SETUP_FINALLY opcodes. They are recorded
        # because they have special stack behaviour. If an exception was raised
        # in the block pushed by a SETUP_FINALLY opcode, the block is popped
        # and 3 objects are pushed. On return or continue, the block is popped
        # and 2 objects are pushed. If nothing happened, the block is popped by
        # a POP_BLOCK opcode and 1 object is pushed by a (LOAD_CONST, None)
        # operation.
        #
        # Our solution is to record the stack state of SETUP_FINALLY targets
        # as having 3 objects pushed, which is the maximum. However, to make
        # stack recording consistent, the get_next_stacks function will always
        # yield the stack state of the target as if 1 object was pushed, but
        # this will be corrected in the actual stack recording.

        sf_targets = set(label_pos[arg]
                         for op, arg in code
                         if op == SETUP_FINALLY)

        # What we compute - for each opcode, its stack state, as an n-tuple.
        # n is the number of blocks pushed. For each block, we record the number
        # of objects pushed.
        stacks = [None] * len(code)

        def get_next_stacks(pos, curstack):
            """Get a code position and the stack state before the operation
            was done, and yield pairs (pos, curstack) for the next positions
            to be explored - those are the positions to which you can get
            from the given (pos, curstack).

            If the given position was already explored, nothing will be yielded.
            """
            op, arg = code[pos]

            if isinstance(op, Label):
                # We should check if we already reached a node only if it is
                # a label.
                if pos in sf_targets:
                    curstack = curstack[:-1] + (curstack[-1] + 2,)
                if stacks[pos] is None:
                    stacks[pos] = curstack
                else:
                    if stacks[pos] != curstack:
                        raise ValueError, "Inconsistent code"
                    return

            def newstack(n):
                # Return a new stack, modified by adding n elements to the last
                # block
                if curstack[-1] + n < 0:
                    raise ValueError, "Popped a non-existing element"
                return curstack[:-1] + (curstack[-1]+n,)

            if not isopcode(op):
                # label or SetLineno - just continue to next line
                yield pos+1, curstack

            elif op in (STOP_CODE, RETURN_VALUE, RAISE_VARARGS):
                # No place in particular to continue to
                pass

            elif op == MAKE_CLOSURE and python_version == '2.4':
                # This is only relevant in Python 2.4 - in Python 2.5 the stack
                # effect of MAKE_CLOSURE can be calculated from the arg.
                # In Python 2.4, it depends on the number of freevars of TOS,
                # which should be a code object.
                if pos == 0:
                    raise ValueError, \
                          "MAKE_CLOSURE can't be the first opcode"
                lastop, lastarg = code[pos-1]
                if lastop != LOAD_CONST:
                    raise ValueError, \
                          "MAKE_CLOSURE should come after a LOAD_CONST op"
                try:
                    nextrapops = len(lastarg.freevars)
                except AttributeError:
                    try:
                        nextrapops = len(lastarg.co_freevars)
                    except AttributeError:
                        raise ValueError, \
                              "MAKE_CLOSURE preceding const should "\
                              "be a code or a Code object"

                yield pos+1, newstack(-arg-nextrapops)

            elif op not in hasflow:
                # Simple change of stack
                pop, push = getse(op, arg)
                yield pos+1, newstack(push - pop)

            elif op in (JUMP_FORWARD, JUMP_ABSOLUTE):
                # One possibility for a jump
                yield label_pos[arg], curstack

            elif python_version < '2.7' and op in (JUMP_IF_FALSE, JUMP_IF_TRUE):
                # Two possibilities for a jump
                yield label_pos[arg], curstack
                yield pos+1, curstack

            elif python_version >= '2.7' and op in (POP_JUMP_IF_FALSE, POP_JUMP_IF_TRUE):
                # Two possibilities for a jump
                yield label_pos[arg], newstack(-1)
                yield pos+1, newstack(-1)

            elif python_version >= '2.7' and op in (JUMP_IF_TRUE_OR_POP, JUMP_IF_FALSE_OR_POP):
                # Two possibilities for a jump
                yield label_pos[arg], curstack
                yield pos+1, newstack(-1)

            elif op == FOR_ITER:
                # FOR_ITER pushes next(TOS) on success, and pops TOS and jumps
                # on failure
                yield label_pos[arg], newstack(-1)
                yield pos+1, newstack(1)

            elif op == BREAK_LOOP:
                # BREAK_LOOP jumps to a place specified on block creation, so
                # it is ignored here
                pass

            elif op == CONTINUE_LOOP:
                # CONTINUE_LOOP jumps to the beginning of a loop which should
                # already ave been discovered, but we verify anyway.
                # It pops a block.
                if python_version == '2.6':
                  pos, stack = label_pos[arg], curstack[:-1]
                  if stacks[pos] != stack: #this could be a loop with a 'with' inside
                    yield pos, stack[:-1] + (stack[-1]-1,)
                  else:
                    yield pos, stack
                else:
                  yield label_pos[arg], curstack[:-1]

            elif op == SETUP_LOOP:
                # We continue with a new block.
                # On break, we jump to the label and return to current stack
                # state.
                yield label_pos[arg], curstack
                yield pos+1, curstack + (0,)

            elif op == SETUP_EXCEPT:
                # We continue with a new block.
                # On exception, we jump to the label with 3 extra objects on
                # stack
                yield label_pos[arg], newstack(3)
                yield pos+1, curstack + (0,)

            elif op == SETUP_FINALLY:
                # We continue with a new block.
                # On exception, we jump to the label with 3 extra objects on
                # stack, but to keep stack recording consistent, we behave as
                # if we add only 1 object. Extra 2 will be added to the actual
                # recording.
                yield label_pos[arg], newstack(1)
                yield pos+1, curstack + (0,)

            elif python_version == '2.7' and op == SETUP_WITH:
                yield label_pos[arg], curstack
                yield pos+1, newstack(-1) + (1,)

            elif op == POP_BLOCK:
                # Just pop the block
                yield pos+1, curstack[:-1]

            elif op == END_FINALLY:
                # Since stack recording of SETUP_FINALLY targets is of 3 pushed
                # objects (as when an exception is raised), we pop 3 objects.
                yield pos+1, newstack(-3)

            elif op == WITH_CLEANUP:
                # Since WITH_CLEANUP is always found after SETUP_FINALLY
                # targets, and the stack recording is that of a raised
                # exception, we can simply pop 1 object and let END_FINALLY
                # pop the remaining 3.
                if python_version == '2.7':
                  yield pos+1, newstack(2)
                else:
                  yield pos+1, newstack(-1)

            else:
                assert False, "Unhandled opcode: %r" % op


        # Now comes the calculation: open_positions holds positions which are
        # yet to be explored. In each step we take one open position, and
        # explore it by adding the positions to which you can get from it, to
        # open_positions. On the way, we update maxsize.
        # open_positions is a list of tuples: (pos, stack state)
        maxsize = 0
        open_positions = [(0, (0,))]
        while open_positions:
            pos, curstack = open_positions.pop()
            maxsize = max(maxsize, sum(curstack))
            open_positions.extend(get_next_stacks(pos, curstack))

        return maxsize

    def to_code(self):
        """Assemble a Python code object from a Code object."""
        co_argcount = len(self.args) - self.varargs - self.varkwargs
        co_stacksize = self._compute_stacksize()
        co_flags = self._compute_flags()

        co_consts = [self.docstring]
        co_names = []
        co_varnames = list(self.args)

        co_freevars = tuple(self.freevars)

        # We find all cellvars beforehand, for two reasons:
        # 1. We need the number of them to construct the numeric argument
        #    for ops in "hasfree".
        # 2. We need to put arguments which are cell vars in the beginning
        #    of co_cellvars
        cellvars = set(arg for op, arg in self.code
                       if isopcode(op) and op in hasfree
                       and arg not in co_freevars)
        co_cellvars = [x for x in self.args if x in cellvars]

        def index(seq, item, eq=operator.eq, can_append=True):
            """Find the index of item in a sequence and return it.
            If it is not found in the sequence, and can_append is True,
            it is appended to the sequence.

            eq is the equality operator to use.
            """
            for i, x in enumerate(seq):
                if eq(x, item):
                    return i
            else:
                if can_append:
                    seq.append(item)
                    return len(seq) - 1
                else:
                    raise IndexError, "Item not found"

        # List of tuples (pos, label) to be filled later
        jumps = []
        # A mapping from a label to its position
        label_pos = {}
        # Last SetLineno
        lastlineno = self.firstlineno
        lastlinepos = 0

        co_code = array('B')
        co_lnotab = array('B')
        for i, (op, arg) in enumerate(self.code):
            if isinstance(op, Label):
                label_pos[op] = len(co_code)

            elif op is SetLineno:
                incr_lineno = arg - lastlineno
                incr_pos = len(co_code) - lastlinepos
                lastlineno = arg
                lastlinepos = len(co_code)

                if incr_lineno == 0 and incr_pos == 0:
                    co_lnotab.append(0)
                    co_lnotab.append(0)
                else:
                    while incr_pos > 255:
                        co_lnotab.append(255)
                        co_lnotab.append(0)
                        incr_pos -= 255
                    while incr_lineno > 255:
                        co_lnotab.append(incr_pos)
                        co_lnotab.append(255)
                        incr_pos = 0
                        incr_lineno -= 255
                    if incr_pos or incr_lineno:
                        co_lnotab.append(incr_pos)
                        co_lnotab.append(incr_lineno)

            elif op == opcode.EXTENDED_ARG:
                raise ValueError, "EXTENDED_ARG not supported in Code objects"

            elif not op in hasarg:
                co_code.append(op)

            else:
                if op in hasconst:
                    if isinstance(arg, Code) and i < len(self.code)-1 and \
                       self.code[i+1][0] in hascode:
                        arg = arg.to_code()
                    arg = index(co_consts, arg, operator.is_)
                elif op in hasname:
                    arg = index(co_names, arg)
                elif op in hasjump:
                    # arg will be filled later
                    jumps.append((len(co_code), arg))
                    arg = 0
                elif op in haslocal:
                    arg = index(co_varnames, arg)
                elif op in hascompare:
                    arg = index(cmp_op, arg, can_append=False)
                elif op in hasfree:
                    try:
                        arg = index(co_freevars, arg, can_append=False) \
                              + len(cellvars)
                    except IndexError:
                        arg = index(co_cellvars, arg)
                else:
                    # arg is ok
                    pass

                if arg > 0xFFFF:
                    co_code.append(opcode.EXTENDED_ARG)
                    co_code.append((arg >> 16) & 0xFF)
                    co_code.append((arg >> 24) & 0xFF)
                co_code.append(op)
                co_code.append(arg & 0xFF)
                co_code.append((arg >> 8) & 0xFF)

        for pos, label in jumps:
            jump = label_pos[label]
            if co_code[pos] in hasjrel:
                jump -= pos+3
            if jump > 0xFFFF:
                raise NotImplementedError, "Extended jumps not implemented"
            co_code[pos+1] = jump & 0xFF
            co_code[pos+2] = (jump >> 8) & 0xFF

        co_code = co_code.tostring()
        co_lnotab = co_lnotab.tostring()

        co_consts = tuple(co_consts)
        co_names = tuple(co_names)
        co_varnames = tuple(co_varnames)
        co_nlocals = len(co_varnames)
        co_cellvars = tuple(co_cellvars)

        return types.CodeType(co_argcount, co_nlocals, co_stacksize, co_flags,
                              co_code, co_consts, co_names, co_varnames,
                              self.filename, self.name, self.firstlineno, co_lnotab,
                              co_freevars, co_cellvars)


def printcodelist(codelist, to=sys.stdout):
    """Get a code list. Print it nicely."""

    labeldict = {}
    pendinglabels = []
    for i, (op, arg) in enumerate(codelist):
        if isinstance(op, Label):
            pendinglabels.append(op)
        elif op is SetLineno:
            pass
        else:
            while pendinglabels:
                labeldict[pendinglabels.pop()] = i

    lineno = None
    islabel = False
    for i, (op, arg) in enumerate(codelist):
        if op is SetLineno:
            lineno = arg
            print >> to
            continue

        if isinstance(op, Label):
            islabel = True
            continue

        if lineno is None:
            linenostr = ''
        else:
            linenostr = str(lineno)
            lineno = None

        if islabel:
            islabelstr = '>>'
            islabel = False
        else:
            islabelstr = ''

        if op in hasconst:
            argstr = repr(arg)
        elif op in hasjump:
            try:
                argstr = 'to ' + str(labeldict[arg])
            except KeyError:
                argstr = repr(arg)
        elif op in hasarg:
            argstr = str(arg)
        else:
            argstr = ''

        print >> to, '%3s     %2s %4d %-20s %s' % (
            linenostr,
            islabelstr,
            i,
            op,
            argstr)

def recompile(filename):
    """Create a .pyc by disassembling the file and assembling it again, printing
    a message that the reassembled file was loaded."""
    # Most of the code here based on the compile.py module.
    import os
    import imp
    import marshal
    import struct

    f = open(filename, 'U')
    try:
        timestamp = long(os.fstat(f.fileno()).st_mtime)
    except AttributeError:
        timestamp = long(os.stat(filename).st_mtime)
    codestring = f.read()
    f.close()
    if codestring and codestring[-1] != '\n':
        codestring = codestring + '\n'
    try:
        codeobject = compile(codestring, filename, 'exec')
    except SyntaxError:
        print >> sys.stderr, "Skipping %s - syntax error." % filename
        return
    cod = Code.from_code(codeobject)
    message = "reassembled %r imported.\n" % filename
    cod.code[:0] = [ # __import__('sys').stderr.write(message)
        (LOAD_GLOBAL, '__import__'),
        (LOAD_CONST, 'sys'),
        (CALL_FUNCTION, 1),
        (LOAD_ATTR, 'stderr'),
        (LOAD_ATTR, 'write'),
        (LOAD_CONST, message),
        (CALL_FUNCTION, 1),
        (POP_TOP, None),
        ]
    codeobject2 = cod.to_code()
    fc = open(filename+'c', 'wb')
    fc.write('\0\0\0\0')
    fc.write(struct.pack('<l', timestamp))
    marshal.dump(codeobject2, fc)
    fc.flush()
    fc.seek(0, 0)
    fc.write(imp.get_magic())
    fc.close()

def recompile_all(path):
    """recursively recompile all .py files in the directory"""
    import os
    if os.path.isdir(path):
        for root, dirs, files in os.walk(path):
            for name in files:
                if name.endswith('.py'):
                    filename = os.path.abspath(os.path.join(root, name))
                    print >> sys.stderr, filename
                    recompile(filename)
    else:
        filename = os.path.abspath(path)
        recompile(filename)

def main():
    import os
    if len(sys.argv) != 2 or not os.path.exists(sys.argv[1]):
        print """\
Usage: %s dir

Search recursively for *.py in the given directory, disassemble and assemble
them, adding a note when each file is imported.

Use it to test byteplay like this:
> byteplay.py Lib
> make test

Some FutureWarnings may be raised, but that's expected.

Tip: before doing this, check to see which tests fail even without reassembling
them...
""" % sys.argv[0]
        sys.exit(1)
    recompile_all(sys.argv[1])

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = code_generator
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from contextlib import contextmanager

from atom.api import Atom, Bool, Int, List, Str

from . import byteplay as bp


class CodeGenerator(Atom):
    """ A class for generating bytecode operations.

    """
    #: The free variables for the code.
    freevars = List()

    #: The arguments for the code.
    args = List()

    #: Whether the code takes variadic args.
    varargs = Bool(False)

    #: Whether the code takes variadic kwargs.
    varkwargs = Bool(False)

    #: Whether the code object should get new locals.
    newlocals = Bool(False)

    #: The name for the code object.
    name = Str()

    #: The full name of the file which is being compiled.
    filename = Str()

    #: The first line number for the code object.
    firstlineno = Int()

    #: The docstring for the code object.
    docstring = Str()

    #: The list of generated byteplay code operations.
    code_ops = List()

    def to_code(self):
        """ Create a Python code object from the current code ops.

        """
        bp_code = bp.Code(
            self.code_ops, self.freevars, self.args, self.varargs,
            self.varkwargs, self.newlocals, self.name, self.filename,
            self.firstlineno, self.docstring or None
        )
        return bp_code.to_code()

    def set_lineno(self, lineno):
        """ Set the current line number in the code.

        """
        self.code_ops.append(                           # TOS
            (bp.SetLineno, lineno),                     # TOS
        )

    def load_global(self, name):
        """ Load a global variable onto the TOS.

        """
        self.code_ops.append(                           # TOS
            (bp.LOAD_GLOBAL, name),                     # TOS -> value
        )

    def load_fast(self, name):
        """ Load a fast local variable onto the TOS.

        """
        self.code_ops.append(                           # TOS
            (bp.LOAD_FAST, name),                       # TOS -> value
        )

    def load_const(self, const):
        """ Load a const value onto the TOS.

        """
        self.code_ops.append(                           # TOS
            (bp.LOAD_CONST, const),                     # TOS -> value
        )

    def load_attr(self, name):
        """ Load an attribute from the object on TOS.

        """
        self.code_ops.append(                           # TOS -> obj
            (bp.LOAD_ATTR, name),                       # TOS -> value
        )

    def store_global(self, name):
        """ Store the TOS as a global.

        """
        self.code_ops.append(                           # TOS -> value
            (bp.STORE_GLOBAL, name),                    # TOS
        )

    def store_fast(self, name):
        """ Store the TOS as a fast local.

        """
        self.code_ops.append(                           # TOS -> value
            (bp.STORE_FAST, name),                      # TOS
        )

    def store_attr(self, name):
        """ Store the value at 2nd as an attr on 1st.

        """
        self.code_ops.append(                           # TOS -> val -> obj
            (bp.STORE_ATTR, name),                      # TOS
        )

    def delete_global(self, name):
        """ Delete a named global variable.

        """
        self.code_ops.append(                           # TOS
            (bp.DELETE_GLOBAL, name),                   # TOS
        )

    def delete_fast(self, name):
        """ Delete a named fast local variable.

        """
        self.code_ops.append(                           # TOS
            (bp.DELETE_FAST, name),                     # TOS
        )

    def return_value(self):
        """ Return the value from the TOS.

        """
        self.code_ops.append(                           # TOS -> value
            (bp.RETURN_VALUE, None),                    # TOS
        )

    def binary_subscr(self):
        """ Subscript the #2 item with the TOS.

        """
        self.code_ops.append(                           # TOS -> obj -> idx
            (bp.BINARY_SUBSCR, None),                   # TOS -> value
        )

    def binary_multiply(self):
        """ Multiple the 2 items on the TOS.

        """
        self.code_ops.append(                           # TOS -> val_1 -> val_2
            (bp.BINARY_MULTIPLY, None),                 # TOS -> retval
        )

    def binary_add(self):
        """ Multiple the 2 items on the TOS.

        """
        self.code_ops.append(                           # TOS -> val_1 -> val_2
            (bp.BINARY_ADD, None),                      # TOS -> retval
        )

    def dup_top(self):
        """ Duplicate the value on the TOS.

        """
        self.code_ops.append(                           # TOS -> value
            (bp.DUP_TOP, None),                         # TOS -> value -> value
        )

    def build_map(self, n=0):
        """ Build a map and store it onto the TOS.

        """
        self.code_ops.append(                           # TOS
            (bp.BUILD_MAP, n),                          # TOS -> map
        )

    def build_tuple(self, n=0):
        """ Build a tuple from items on the TOS.

        """
        if n == 0:
            self.code_ops.append(                       # TOS
                (bp.LOAD_CONST, ()),                    # TOS -> tuple
            )
        else:
            self.code_ops.append(                       # TOS
                (bp.BUILD_TUPLE, n),                    # TOS -> tuple
            )

    def build_list(self, n=0):
        """ Build a list from items on the TOS.

        """
        self.code_ops.append(                           # TOS
            (bp.BUILD_LIST, n),                         # TOS -> list
        )

    def store_map(self):
        """ Store the key/value pair on the TOS into the map at 3rd pos.

        """
        self.code_ops.append(                           # TOS -> map -> value -> key
            (bp.STORE_MAP, None),                       # TOS -> map
        )

    def store_subscr(self):
        """ Store the index/value pair on the TOS into the 3rd item.

        """
        self.code_ops.append(                           # TOS -> value -> obj -> index
            (bp.STORE_SUBSCR, None),                    # TOS
        )

    def build_class(self):
        """ Build a class from the top 3 stack items.

        """
        self.code_ops.append(                           # TOS -> name -> bases -> dict
            (bp.BUILD_CLASS, None),                     # TOS -> class
        )

    def make_function(self, n_defaults=0):
        """ Make a function from a code object on the TOS.

        """
        self.code_ops.append(                           # TOS -> code -> defaults
            (bp.MAKE_FUNCTION, n_defaults),             # TOS -> func
        )

    def call_function(self, n_args=0, n_kwds=0):
        """ Call a function on the TOS with the given args and kwargs.

        """
        argspec = ((n_kwds & 0xFF) << 8) + (n_args & 0xFF)
        self.code_ops.append(                           # TOS -> func -> args -> kwargs
            (bp.CALL_FUNCTION, argspec),                # TOS -> retval
        )

    def call_function_var(self, n_args=0, n_kwds=0):
        """ Call a var function on the TOS with the given args and kwargs.

        """
        argspec = ((n_kwds & 0xFF) << 8) + (n_args & 0xFF)
        self.code_ops.append(                           # TOS -> func -> args -> kwargs -> varargs
            (bp.CALL_FUNCTION_VAR, argspec),            # TOS -> retval
        )

    def pop_top(self):
        """ Pop the value from the TOS.

        """
        self.code_ops.append(                           # TOS -> value
            (bp.POP_TOP, None),                         # TOS
        )

    def rot_two(self):
        """ Rotate the two values on the TOS.

        """
        self.code_ops.append(                           # TOS -> val_1 -> val_2
            (bp.ROT_TWO, None),                         # TOS -> val_2 -> val_1
        )

    def rot_three(self):
        """ Rotate the three values on the TOS.

        """
        self.code_ops.append(                           # TOS -> val_1 -> val_2 -> val_3
            (bp.ROT_THREE, None),                       # TOS -> val_3 -> val_1 -> val_2
        )

    def unpack_sequence(self, n):
        """ Unpack the sequence on the TOS.

        """
        self.code_ops.append(                           # TOS -> obj
            (bp.UNPACK_SEQUENCE, n),                    # TOS -> val_n -> val_2 -> val_1
        )

    @contextmanager
    def try_squash_raise(self):
        """ A context manager for squashing tracebacks.

        The code written during this context will be wrapped so that
        any exception raised will appear to have been generated from
        the code, rather than any function called by the code.

        """
        exc_label = bp.Label()
        end_label = bp.Label()
        self.code_ops.append(
            (bp.SETUP_EXCEPT, exc_label),               # TOS
        )
        yield
        self.code_ops.extend([                          # TOS
            (bp.POP_BLOCK, None),                       # TOS
            (bp.JUMP_FORWARD, end_label),               # TOS
            (exc_label, None),                          # TOS -> tb -> val -> exc
            (bp.ROT_THREE, None),                       # TOS -> exc -> tb -> val
            (bp.ROT_TWO, None),                         # TOS -> exc -> val -> tb
            (bp.POP_TOP, None),                         # TOS -> exc -> val
            (bp.RAISE_VARARGS, 2),                      # TOS
            (bp.JUMP_FORWARD, end_label),               # TOS
            (bp.END_FINALLY, None),                     # TOS
            (end_label, None),                          # TOS
        ])

    @contextmanager
    def for_loop(self, iter_var, fast_var=True):
        """ A context manager for creating for-loops.

        Parameters
        ----------
        iter_var : str
            The name of the loop iter variable.

        fast_var : bool, optional
            Whether the iter_var lives in fast locals. The default is
            True. If False, the iter_var is loaded from globals.

        """
        start_label = bp.Label()
        jump_label = bp.Label()
        end_label = bp.Label()
        load_op = bp.LOAD_FAST if fast_var else bp.LOAD_GLOBAL
        self.code_ops.extend([
            (bp.SETUP_LOOP, end_label),
            (load_op, iter_var),
            (bp.GET_ITER, None),
            (start_label, None),
            (bp.FOR_ITER, jump_label),
        ])
        yield
        self.code_ops.extend([
            (bp.JUMP_ABSOLUTE, start_label),
            (jump_label, None),
            (bp.POP_BLOCK, None),
            (end_label, None),
        ])

    def insert_python_block(self, pydata, trim=True):
        """ Insert the compiled code for a Python Module ast or string.

        """
        code = compile(pydata, self.filename, mode='exec')
        bp_code = bp.Code.from_code(code).code
        if trim:  # skip SetLineno and ReturnValue
            bp_code = bp_code[1:-2]
        self.code_ops.extend(bp_code)

    def insert_python_expr(self, pydata, trim=True):
        """ Insert the compiled code for a Python Expression ast or string.

        """
        code = compile(pydata, self.filename, mode='eval')
        bp_code = bp.Code.from_code(code).code
        if trim:  # skip ReturnValue
            bp_code = bp_code[:-1]
        self.code_ops.extend(bp_code)

    def rewrite_to_fast_locals(self, local_names):
        """ Rewrite the locals to be loaded from fast locals.

        Given a set of available local names, this method will rewrite
        the current code ops, replaces every instance of a *_NAME opcode
        with a *_FAST or *_GLOBAL depending on whether or not the name
        exists in local_names or was written via STORE_NAME. This method
        is useful to convert the code so it can be used as a function.

        Parameters
        ----------
        local_names : set
            The set of available locals for the code.

        Returns
        -------
        result : list
            The list of names which must be provided as arguments.

        """
        arg_names = []
        stored_names = set()
        code_ops = self.code_ops
        for idx, (op, op_arg) in enumerate(code_ops):
            if op == bp.STORE_NAME:
                stored_names.add(op_arg)
                code_ops[idx] = (bp.STORE_FAST, op_arg)
        for idx, (op, op_arg) in enumerate(code_ops):
            if op == bp.LOAD_NAME:
                if op_arg in local_names:
                    op = bp.LOAD_FAST
                    arg_names.append(op_arg)
                elif op_arg in stored_names:
                    op = bp.LOAD_FAST
                else:
                    op = bp.LOAD_GLOBAL
                code_ops[idx] = (op, op_arg)
            elif op == bp.DELETE_NAME:          # py2.6 list comps
                if op_arg in stored_names:
                    op = bp.DELETE_FAST
                else:
                    op = bp.DELETE_GLOBAL
                code_ops[idx] = (op, op_arg)
        self.args = arg_names
        self.newlocals = True
        return arg_names

########NEW FILE########
__FILENAME__ = code_tracing
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from .byteplay import (
    LOAD_ATTR, LOAD_CONST, ROT_TWO, DUP_TOP, CALL_FUNCTION, POP_TOP, LOAD_FAST,
    BUILD_TUPLE, ROT_THREE, UNPACK_SEQUENCE, DUP_TOPX, BINARY_SUBSCR, GET_ITER,
    LOAD_NAME, RETURN_VALUE
)


class CodeTracer(object):
    """ A base class for implementing code tracers.

    This class defines the interface for a code tracer object, which is
    an object which can be passed as the first argument to a code object
    which has been transformed to enable tracing. Methods on the tracer
    are called with relevant arguments from the Python stack when that
    particular code segment is executing. The return value of a tracer
    method is ignored; exceptions are propagated.

    """
    __slots__ = ()

    def dynamic_load(self, obj, attr, value):
        """ Called when an dynamic attribute is loaded.

        This method is called by the dynamic scope when it loads an
        attribute from some object in the object hierarchy due to the
        execution of the LOAD_NAME opcode.

        Parameters
        ----------
        obj : Object
            The Enaml object which owns the dynamically scoped attr.

        attr : str
            The name of the attribute which was loaded.

        value : object
            The value which was loaded.

        """
        pass

    def load_attr(self, obj, attr):
        """ Called before the LOAD_ATTR opcode is executed.

        Parameters
        ----------
        obj : object
            The object which owns the attribute.

        attr : string
            The attribute being loaded.

        """
        pass

    def call_function(self, func, argtuple, argspec):
        """ Called before the CALL_FUNCTION opcode is executed.

        Parameters
        ----------
        func : object
            The object being called.

        argtuple : tuple
            The argument tuple from the stack (see notes).

        argspec : int
            The argument tuple specification.

        Notes
        -----
        The `argstuple` contains both positional and keyword argument
        information. `argspec` is an int which specifies how to parse
        the information. The lower 16bits of `argspec` are significant.
        The lowest 8 bits are the number of positional arguments which
        are the first n items in `argtuple`. The second 8 bits are the
        number of keyword arguments which follow the positional args in
        `argtuple` and alternate name -> value. `argtuple` can be parsed
        into a conventional tuple and dict with the following:

            nargs = argspec & 0xFF
            args = argtuple[:nargs]
            kwargs = dict(zip(argtuple[nargs::2], argtuple[nargs+1::2]))

        """
        pass

    def binary_subscr(self, obj, idx):
        """ Called before the BINARY_SUBSCR opcode is executed.

        Parameters
        ----------
        obj : object
            The object being indexed.

        idx : object
            The index.

        """
        pass

    def get_iter(self, obj):
        """ Called before the GET_ITER opcode is executed.

        Parameters
        ----------
        obj : object
            The object which should return an iterator.

        """
        pass

    def return_value(self, value):
        """ Called before the RETURN_VALUE opcode is executed.

        Parameters
        ----------
        value : object
            The value that will be returned from the code object.

        """
        pass


class CodeInverter(object):
    """ A base class for implementing code inverters.

    This class defines the interface for a code inverter object, which is
    an object which can be passed as the first argument to a code object
    which has been transformed to enable inversion. The methods on the
    inverter are called with relevant arguments from the Python stack
    when that particular code segment is executing. The return values of
    a tracer method is ignored; exceptions are propagated.

    The default behavior of an inverter is to raise. Implementations
    must provide their own code in order to enable inversion.

    """
    __slots__ = ()

    def fail(self):
        """ Called by handlers to raise an inversion exception.

        """
        raise RuntimeError("can't assign to expression")

    def load_name(self, name, value):
        """ Called before the LOAD_NAME opcode is executed.

        This method should perform a STORE_NAME operation.

        Parameters
        ----------
        name : string
            The name being loaded.

        value : object
            The value to store.

        """
        self.fail()

    def load_attr(self, obj, attr, value):
        """ Called before the LOAD_ATTR opcode is executed.

        This method should perform a STORE_ATTR operation.

        Parameters
        ----------
        obj : object
            The object which owns the attribute.

        attr : string
            The attribute being loaded.

        value : object
            The value to store

        """
        self.fail()

    def call_function(self, func, argtuple, argspec, value):
        """ Called before the CALL_FUNCTION opcode is executed.

        This method should perform an appropriate store operation.

        Parameters
        ----------
        func : object
            The object being called.

        argtuple : tuple
            The argument tuple from the stack (see Notes).

        argspec : int
            The argument tuple specification.

        value : object
            The value to store.

        Notes
        -----
        The semantics of the arguments is identical to the method
        `call_function` on the `CodeTracer` type.

        """
        self.fail()

    def binary_subscr(self, obj, idx, value):
        """ Called before the BINARY_SUBSCR opcode is executed.

        This method should perform a STORE_SUBSCR operation.

        Parameters
        ----------
        obj : object
            The object being indexed.

        idx : object
            The index.

        value : object
            The value to store.

        """
        self.fail()


def inject_tracing(codelist):
    """ Inject tracing code into the given code list.

    This will inject the bytecode operations required to trace the
    execution of the code using a `CodeTracer` object. The generated
    opcodes expect a fast local '_[tracer]' to be available when the
    code is executed.

    Parameters
    ----------
    codelist : list
        The list of byteplay code ops to modify.

    Returns
    -------
    result : list
        A *new* list of code ops which implement the desired behavior.

    """
    # This builds a mapping of code idx to a list of ops, which are the
    # tracing bytecode instructions which will be inserted into the code
    # object being transformed. The ops assume that a tracer object is
    # available in the fast locals using a non-clashable name. All of
    # the ops have a net-zero effect on the execution stack. Provided
    # that the tracer has no visible side effects, the tracing is
    # transparent.
    inserts = {}
    for idx, (op, op_arg) in enumerate(codelist):
        if op == LOAD_ATTR:
            code = [                        # obj
                (DUP_TOP, None),            # obj -> obj
                (LOAD_FAST, '_[tracer]'),   # obj -> obj -> tracer
                (LOAD_ATTR, 'load_attr'),   # obj -> obj -> tracefunc
                (ROT_TWO, None),            # obj -> tracefunc -> obj
                (LOAD_CONST, op_arg),       # obj -> tracefunc -> obj -> attr
                (CALL_FUNCTION, 0x0002),    # obj -> retval
                (POP_TOP, None),            # obj
            ]
            inserts[idx] = code
        elif op == CALL_FUNCTION:
            # This computes the number of objects on the stack between
            # TOS and the object being called. Only the last 16bits of
            # the op_arg are signifcant. The lowest 8 are the number of
            # positional args on the stack, the upper 8 is the number of
            # kwargs. For kwargs, the number of items on the stack is
            # twice this number since the values on the stack alternate
            # name, value.
            n_stack_args = (op_arg & 0xFF) + 2 * ((op_arg >> 8) & 0xFF)
            code = [                                # func -> arg(0) -> arg(1) -> ... -> arg(n-1)
                (BUILD_TUPLE, n_stack_args),        # func -> argtuple
                (DUP_TOPX, 2),                      # func -> argtuple -> func -> argtuple
                (LOAD_FAST, '_[tracer]'),           # func -> argtuple -> func -> argtuple -> tracer
                (LOAD_ATTR, 'call_function'),       # func -> argtuple -> func -> argtuple -> tracefunc
                (ROT_THREE, None),                  # func -> argtuple -> tracefunc -> func -> argtuple
                (LOAD_CONST, op_arg),               # func -> argtuple -> tracefunc -> func -> argtuple -> argspec
                (CALL_FUNCTION, 0x0003),            # func -> argtuple -> retval
                (POP_TOP, None),                    # func -> argtuple
                (UNPACK_SEQUENCE, n_stack_args),    # func -> arg(n-1) -> arg(n-2) -> ... -> arg(0)
                (BUILD_TUPLE, n_stack_args),        # func -> reversedargtuple
                (UNPACK_SEQUENCE, n_stack_args),    # func -> arg(0) -> arg(1) -> ... -> arg(n-1)
            ]
            inserts[idx] = code
        elif op == BINARY_SUBSCR:
            code = [                            # obj -> idx
                (DUP_TOPX, 2),                  # obj -> idx -> obj -> idx
                (LOAD_FAST, '_[tracer]'),       # obj -> idx -> obj -> idx -> tracer
                (LOAD_ATTR, 'binary_subscr'),   # obj -> idx -> obj -> idx -> tracefunc
                (ROT_THREE, None),              # obj -> idx -> tracefunc -> obj -> idx
                (CALL_FUNCTION, 0x0002),        # obj -> idx -> retval
                (POP_TOP, None),                # obj -> idx
            ]
            inserts[idx] = code
        elif op == GET_ITER:
            code = [                        # obj
                (DUP_TOP, None),            # obj -> obj
                (LOAD_FAST, '_[tracer]'),   # obj -> obj -> tracer
                (LOAD_ATTR, 'get_iter'),    # obj -> obj -> tracefunc
                (ROT_TWO, None),            # obj -> tracefunc -> obj
                (CALL_FUNCTION, 0x0001),    # obj -> retval
                (POP_TOP, None),            # obj
            ]
            inserts[idx] = code
        elif op == RETURN_VALUE:
            code = [
                (DUP_TOP, None),                # obj
                (LOAD_FAST, '_[tracer]'),       # obj -> obj -> tracer
                (LOAD_ATTR, 'return_value'),    # obj -> obj -> tracefunc
                (ROT_TWO, None),                # obj -> tracefunc -> obj
                (CALL_FUNCTION, 0x0001),        # obj -> retval
                (POP_TOP, None),                # obj
            ]
            inserts[idx] = code

    # Create a new code list which interleaves the generated code with
    # the original code at the appropriate location.
    new_code = []
    for idx, code_op in enumerate(codelist):
        if idx in inserts:
            new_code.extend(inserts[idx])
        new_code.append(code_op)

    return new_code


def inject_inversion(codelist):
    """ Inject inversion code into the given code list.

    This will inject the bytecode operations required to invert the
    execution of the code using a `CodeInverter` object. The generated
    opcodes expect the fast local '_[inverter]' and '_[value]' to be
    available when the code is executed.

    Parameters
    ----------
    codelist : list
        The list of byteplay code ops to modify.

    Returns
    -------
    result : list
        A *new* list of code ops which implement the desired behavior.

    Raises
    ------
    ValueError
        The given code is not suitable for inversion.

    """
    opcode, oparg = codelist[-2]
    new_code = codelist[:-2]
    if opcode == LOAD_NAME and len(codelist) == 3:
        new_code.extend([                   #:
            (LOAD_FAST, '_[inverter]'),     #: inverter
            (LOAD_ATTR, 'load_name'),       #: invertfunc
            (LOAD_CONST, oparg),            #: invertfunc -> name
            (LOAD_FAST, '_[value]'),        #: invertfunc -> name - > value
            (CALL_FUNCTION, 0x0002),        #: retval
            (RETURN_VALUE, None),           #:
        ])
    elif opcode == LOAD_ATTR:
        new_code.extend([                   #: obj
            (LOAD_FAST, '_[inverter]'),     #: obj -> inverter
            (LOAD_ATTR, 'load_attr'),       #: obj -> invertfunc
            (ROT_TWO, None),                #: invertfunc -> obj
            (LOAD_CONST, oparg),            #: invertfunc -> obj -> attr
            (LOAD_FAST, '_[value]'),        #: invertfunc -> obj -> attr -> value
            (CALL_FUNCTION, 0x0003),        #: retval
            (RETURN_VALUE, None),           #:
        ])
    elif opcode == CALL_FUNCTION:
        n_stack_args = (oparg & 0xFF) + 2 * ((oparg >> 8) & 0xFF)
        new_code.extend([                   #: func -> arg(0) -> arg(1) -> ... -> arg(n-1)
            (BUILD_TUPLE, n_stack_args),    #: func -> argtuple
            (LOAD_FAST, '_[inverter]'),     #: func -> argtuple -> inverter
            (LOAD_ATTR, 'call_function'),   #: func -> argtuple -> invertfunc
            (ROT_THREE, None),              #: invertfunc -> func -> argtuple
            (LOAD_CONST, oparg),            #: invertfunc -> func -> argtuple -> argspec
            (LOAD_FAST, '_[value]'),        #: invertfunc -> func -> argtuple -> argspec -> value
            (CALL_FUNCTION, 0x0004),        #: retval
            (RETURN_VALUE, None),           #:
        ])
    elif opcode == BINARY_SUBSCR:
        new_code.extend([                   #: obj -> index
            (LOAD_FAST, '_[inverter]'),     #: obj -> index -> inverter
            (LOAD_ATTR, 'binary_subscr'),   #: obj -> index -> invertfunc
            (ROT_THREE, None),              #: invertfunc -> obj -> index
            (LOAD_FAST, '_[value]'),        #: invertfunc -> obj -> index -> value
            (CALL_FUNCTION, 0x0003),        #: retval
            (RETURN_VALUE, None),           #:
        ])
    else:
        raise ValueError("can't invert code")

    return new_code

########NEW FILE########
__FILENAME__ = compiler_common
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
""" A collection of common compiler functionality.

"""
import ast

from atom.api import Str, Typed

from . import byteplay as bp
from .code_generator import CodeGenerator
from .enaml_ast import (
    AliasExpr, ASTVisitor, Binding, ChildDef, EnamlDef, StorageExpr, Template,
    TemplateInst, PythonExpression, PythonModule, FuncDef
)


#: The name of the compiler helpers in the global scope.
COMPILER_HELPERS = '__compiler_helpers'

#: The name of the compiler helpers in the fast locals.
C_HELPERS = '_[helpers]'

#: The name of the scope key in the fast locals.
SCOPE_KEY = '_[scope_key]'

#: The name of the node list in the fast locals.
NODE_LIST = '_[node_list]'

#: The name of the globals map in the fast locals.
F_GLOBALS = '_[f_globals]'

#: The name of the template parameter tuple.
T_PARAMS = '_[t_params]'

#: The name of the stored template const values.
T_CONSTS = '_[t_consts]'

#: The global name of the template map in a module.
TEMPLATE_MAP = '_[template_map]'

#: The name of the unpack mapping for the template instance.
UNPACK_MAP = '_[unpack_map]'

#: A mapping of enaml ast node to compile(...) mode string.
COMPILE_MODE = {
    PythonExpression: 'eval',
    PythonModule: 'exec',
}


def unhandled_pragma(name, filename, lineno):
    """ Emit a warning for an unhandled pragma.

    Parameters
    ----------
    name : str
        The name of the unhandled pragma.

    filename : str
        The name of the file with the unhandled pragma.

    lineno : int
        The line number of the unhandled pragma.

    """
    import warnings
    msg = "unhandled pragma '%s'" % name
    warnings.warn_explicit(msg, SyntaxWarning, filename, lineno)


def warn_pragmas(node, filename):
    """ Emit a warning if there are any pragmas defined on the node.

    Parameters
    ----------
    node : ASTNode
        An enaml ast node which supports pragmas

    filename : str
        The filename for the node.

    """
    for pragma in node.pragmas:
        unhandled_pragma(pragma.command, filename, pragma.lineno)


def should_store_locals(node):
    """ Get whether or not a node should store its locals.

    A node must store its local scope if it has alias exprs,
    attribute bindings, or storage exprs with default bindings.

    Parameters
    ----------
    node : EnamlDef or ChildDef
        The ast node of interest.

    Returns
    -------
    result : bool
        True if instances of the enamldef should store their local
        scopes, False otherwise.

    """
    types = (AliasExpr, Binding, FuncDef)
    for item in node.body:
        if isinstance(item, types):
            return True
        if isinstance(item, StorageExpr) and item.expr is not None:
            return True
    return False


def count_nodes(node):
    """ Count the number of compiler nodes needed for the template.

    Parameters
    ----------
    node : Template
        The template node of interest.

    Returns
    -------
    result : int
        The number of compiler nodes needed for the template.

    """
    node_count = 0
    stack = [node]
    types = (EnamlDef, Template, ChildDef, TemplateInst)
    while stack:
        node = stack.pop()
        if isinstance(node, types):
            node_count += 1
            stack.extend(node.body)
    return node_count


def has_list_comp(pyast):
    """ Determine whether a Python expression has a list comprehension.

    Parameters
    ----------
    pyast : Expression
        The Python Expression ast of interest.

    Returns
    -------
    result : bool
        True if the ast includes a list comprehension, False otherwise.

    """
    for item in ast.walk(pyast):
        if isinstance(item, ast.ListComp):
            return True
    return False


def fetch_helpers(cg):
    """ Fetch the compiler helpers and store in fast locals.

    This function should be called once on a code generator before
    using the 'load_helper' function.

    Parameters
    ----------
    cg : CodeGenerator
        The code generator with which to write the code.

    """
    cg.load_global(COMPILER_HELPERS)
    cg.store_fast(C_HELPERS)


def fetch_globals(cg):
    """ Fetch the globals and store in fast locals.

    Parameters
    ----------
    cg : CodeGenerator
        The code generator with which to write the code.

    """
    cg.load_global('globals')
    cg.call_function()
    cg.store_fast(F_GLOBALS)


def load_helper(cg, name, from_globals=False):
    """ Load a compiler helper onto the TOS.

    The caller should have already invoked the 'fetch_locals' function
    for the code generator before using this function, unless the
    'from_globals' keyword is set to True.

    Parameters
    ----------
    cg : CodeGenerator
        The code generator with which to write the code.

    name : str
        The name of the compiler helper to load onto the TOS.

    from_globals : bool, optional
        If True, the helpers will be loaded from the globals instead of
        the fast locals. The default is False.
    """
    if from_globals:
        cg.load_global(COMPILER_HELPERS)
    else:
        cg.load_fast(C_HELPERS)
    cg.load_const(name)
    cg.binary_subscr()


def load_name(cg, name, local_names):
    """ Load a name onto the TOS.

    If the name exists in the local names set, it is loaded from
    the fast locals. Otherwise, it is loaded from the globals.

    Parameters
    ----------
    cg : CodeGenerator
        The code generator with which to write the code.

    name : str
        The name of the value to load onto the TOS.

    local_names : set
        The set of fast local names available to the code object.

    """
    if name in local_names:
        cg.load_fast(name)
    else:
        cg.load_global(name)


def make_node_list(cg, count):
    """ Create the node list and store in fast locals.

    Parameters
    ----------
    cg : CodeGenerator
        The code generator with which to write the code.

    count : int
        The required size of the node list.

    """
    cg.load_const(None)
    cg.build_list(1)
    cg.load_const(count)
    cg.binary_multiply()
    cg.store_fast(NODE_LIST)


def store_node(cg, index):
    """ Store the node on TOS into the node list.

    The caller should ensure that NODE_LIST exists in fast locals.

    Parameters
    ----------
    cg : CodeGenerator
        The code generator with which to write the code.

    index : int
        The index at which to store the node in the node list.

    """
    cg.load_fast(NODE_LIST)
    cg.load_const(index)
    cg.store_subscr()


def load_node(cg, index):
    """ Load the node at the given index in the node list.

    The caller should ensure that NODE_LIST exists in fast locals.

    Parameters
    ----------
    cg : CodeGenerator
        The code generator with which to write the code.

    index : int
        The index of the parent node in the node list.

    """
    cg.load_fast(NODE_LIST)
    cg.load_const(index)
    cg.binary_subscr()


def append_node(cg, parent, index):
    """ Append the node on the TOS as a child of the specified node.

    The caller should ensure that NODE_LIST exists in fast locals.

    Parameters
    ----------
    cg : CodeGenerator
        The code generator with which to write the code.

    parent : int
        The index of the parent node in the node list.

    index : int
        The index of the target node in the node list.

    """
    load_node(cg, parent)
    cg.load_attr('children')
    cg.load_attr('append')
    load_node(cg, index)
    cg.call_function(1)
    cg.pop_top()


def safe_eval_ast(cg, node, name, lineno, local_names):
    """ Safe eval a Python ast node.

    This method will eval the python code represented by the ast
    in the local namespace. If the code would have the side effect
    of storing a value in the namespace, such as a list comp, then
    the expression will be evaluated in it's own namespace.

    Parameters
    ----------
    cg : CodeGenerator
        The code generator with which to write the code.

    node : ast.Expression
        The Python expression ast node of interest.

    name : str
        The name to use any internal code object.

    lineno : int
        The line number to use for any internal code object.

    local_names : set
        The set of fast local names available to the code object.

    """
    if has_list_comp(node):
        expr_cg = CodeGenerator()
        expr_cg.filename = cg.filename
        expr_cg.name = name
        expr_cg.firstlineno = lineno
        expr_cg.set_lineno(lineno)
        expr_cg.insert_python_expr(node, trim=False)
        call_args = expr_cg.rewrite_to_fast_locals(local_names)
        expr_code = expr_cg.to_code()
        cg.load_const(expr_code)
        cg.make_function()
        for arg in call_args:
            if arg in local_names:
                cg.load_fast(arg)
            else:
                cg.load_global(arg)
        cg.call_function(len(call_args))
    else:
        expr_cg = CodeGenerator()
        expr_cg.insert_python_expr(node)
        expr_cg.rewrite_to_fast_locals(local_names)
        cg.code_ops.extend(expr_cg.code_ops)


def gen_child_def_node(cg, node, local_names):
    """ Generate the code to create the child def compiler node.

    The caller should ensure that SCOPE_KEY is present in the fast
    locals of the code object.

    Parameters
    ----------
    cg : CodeGenerator
        The code generator with which to write the code.

    node : ChildDef
        The enaml ast node of interest.

    local_names : set
        The set of local names available to the code object.

    """
    # Validate the type of the child
    load_name(cg, node.typename, local_names)
    with cg.try_squash_raise():
        cg.dup_top()
        load_helper(cg, 'validate_declarative')
        cg.rot_two()                            # base -> helper -> base
        cg.call_function(1)                     # base -> retval
        cg.pop_top()                            # base

    # Subclass the child class if needed
    store_types = (StorageExpr, AliasExpr, FuncDef)
    if any(isinstance(item, store_types) for item in node.body):
        cg.load_const(node.typename)
        cg.rot_two()
        cg.build_tuple(1)
        cg.build_map()
        cg.load_global('__name__')
        cg.load_const('__module__')
        cg.store_map()                          # name -> bases -> dict
        cg.build_class()                        # class

    # Build the declarative compiler node
    store_locals = should_store_locals(node)
    load_helper(cg, 'declarative_node')
    cg.rot_two()
    cg.load_const(node.identifier)
    cg.load_fast(SCOPE_KEY)
    cg.load_const(store_locals)                 # helper -> class -> identifier -> key -> bool
    cg.call_function(4)                         # node


def gen_template_inst_node(cg, node, local_names):
    """ Generate the code to create a template inst compiler node.

    The caller should ensure that SCOPE_KEY is present in the fast
    locals of the code object.

    Parameters
    ----------
    cg : CodeGenerator
        The code generator with which to write the code.

    node : TemplateInst
        The enaml ast node of interest.

    local_names : set
        The set of local names available to the code object.

    """
    # Validate the type of the template.
    load_name(cg, node.name, local_names)
    with cg.try_squash_raise():
        cg.dup_top()
        load_helper(cg, 'validate_template')
        cg.rot_two()
        cg.call_function(1)
        cg.pop_top()

    # Load the arguments for the instantiation call.
    arguments = node.arguments
    for arg in arguments.args:
        safe_eval_ast(cg, arg.ast, node.name, arg.lineno, local_names)
    if arguments.stararg:
        arg = arguments.stararg
        safe_eval_ast(cg, arg.ast, node.name, arg.lineno, local_names)

    # Instantiate the template.
    argcount = len(arguments.args)
    varargs = bool(arguments.stararg)
    if varargs:
        cg.call_function_var(argcount)
    else:
        cg.call_function(argcount)

    # Validate the instantiation size, if needed.
    names = ()
    starname = ''
    identifiers = node.identifiers
    if identifiers is not None:
        names = tuple(identifiers.names)
        starname = identifiers.starname
        with cg.try_squash_raise():
            cg.dup_top()
            load_helper(cg, 'validate_unpack_size')
            cg.rot_two()
            cg.load_const(len(names))
            cg.load_const(bool(starname))
            cg.call_function(3)
            cg.pop_top()

    # Load and call the helper to create the compiler node
    load_helper(cg, 'template_inst_node')
    cg.rot_two()
    cg.load_const(names)
    cg.load_const(starname)
    cg.load_fast(SCOPE_KEY)
    cg.load_const(bool(node.body))
    cg.call_function(5)


def gen_template_inst_binding(cg, node, index):
    """ Generate the code for a template inst binding.

    The caller should ensure that UNPACK_MAP and F_GLOBALS are present
    in the fast locals of the code object.

    Parameters
    ----------
    cg : CodeGenerator
        The code generator with which to write the code.

    node : TemplateInstBinding
        The enaml ast node of interest.

    index : int
        The index of the template inst node in the node list.

    """
    op_node = node.expr
    mode = COMPILE_MODE[type(op_node.value)]
    code = compile(op_node.value.ast, cg.filename, mode=mode)
    with cg.try_squash_raise():
        cg.set_lineno(node.lineno)
        load_helper(cg, 'run_operator')
        load_node(cg, index)
        cg.load_fast(UNPACK_MAP)
        cg.load_const(node.name)
        cg.binary_subscr()
        cg.load_const(node.chain)
        cg.load_const(op_node.operator)
        cg.load_const(code)
        cg.load_fast(F_GLOBALS)
        cg.call_function(6)
        cg.pop_top()


def gen_operator_binding(cg, node, index, name):
    """ Generate the code for a template inst binding.

    The caller should ensure that F_GLOBALS and NODE_LIST are present
    in the fast locals of the code object.

    Parameters
    ----------
    cg : CodeGenerator
        The code generator with which to write the code.

    node : OperatorExpr
        The enaml ast node of interest.

    index : int
        The index of the target node in the node list.

    name : str
        The attribute name to be bound.

    """
    mode = COMPILE_MODE[type(node.value)]
    code = compile(node.value.ast, cg.filename, mode=mode)
    with cg.try_squash_raise():
        cg.set_lineno(node.lineno)
        load_helper(cg, 'run_operator')
        load_node(cg, index)
        cg.dup_top()
        cg.load_const(name)
        cg.load_const(node.operator)
        cg.load_const(code)
        cg.load_fast(F_GLOBALS)
        cg.call_function(6)
        cg.pop_top()


def gen_alias_expr(cg, node, index):
    """ Generate the code for an alias expression.

    The caller should ensure that NODE_LIST is present in the fast
    locals of the code object.

    Parameters
    ----------
    cg : CodeGenerator
        The code generator with which to write the code.

    node : AliasExpr
        The enaml ast node of interest.

    index : int
        The index of the target node in the node list.

    """
    with cg.try_squash_raise():
        cg.set_lineno(node.lineno)
        load_helper(cg, 'add_alias')
        load_node(cg, index)
        cg.load_const(node.name)
        cg.load_const(node.target)
        cg.load_const(node.chain)
        cg.call_function(4)
        cg.pop_top()


def gen_storage_expr(cg, node, index, local_names):
    """ Generate the code for a storage expression.

    The caller should ensure that NODE_LIST is present in the fast
    locals of the code object.

    Parameters
    ----------
    cg : CodeGenerator
        The code generator with which to write the code.

    node : StorageExpr
        The enaml ast node of interest.

    index : int
        The index of the target node in the node list.

    local_names : set
        The set of fast local names available to the code object.

    """
    with cg.try_squash_raise():
        cg.set_lineno(node.lineno)
        load_helper(cg, 'add_storage')
        load_node(cg, index)
        cg.load_const(node.name)
        if node.typename:
            load_name(cg, node.typename, local_names)
        else:
            cg.load_const(None)
        cg.load_const(node.kind)
        cg.call_function(4)
        cg.pop_top()


def _insert_decl_function(cg, funcdef):
    """ Create and place a declarative function on the TOS.

    This will rewrite the function to convert each LOAD_GLOBAL opcode
    into a LOAD_NAME opcode, unless the associated name was explicitly
    made global via the 'global' keyword.

    Parameters
    ----------
    funcdef : ast node
        The python FunctionDef ast node.

    """
    # collect the explicit 'global' variable names
    global_vars = set()
    for node in ast.walk(funcdef):
        if isinstance(node, ast.Global):
            global_vars.update(node.names)

    # generate the code object which will create the function
    mod = ast.Module(body=[funcdef])
    code = compile(mod, cg.filename, mode='exec')

    # convert to a byteplay object and remove the leading and
    # trailing ops: SetLineno STORE_NAME LOAD_CONST RETURN_VALUE
    outer_ops = bp.Code.from_code(code).code[1:-3]

    # the stack now looks like the following:
    #   ...
    #   ...
    #   LOAD_CONST      (<code object>)
    #   MAKE_FUCTION    (num defaults)      // TOS

    # extract the inner code object which represents the actual
    # function code and update its flags and global loads
    inner = outer_ops[-2][1]
    inner.newlocals = False
    inner_ops = inner.code
    for idx, (op, op_arg) in enumerate(inner_ops):
        if op == bp.LOAD_GLOBAL and op_arg not in global_vars:
            inner_ops[idx] = (bp.LOAD_NAME, op_arg)

    # inline the modified code ops into the code generator
    cg.code_ops.extend(outer_ops)


def gen_decl_funcdef(cg, node, index):
    """ Generate the code for a declarative function definition.

    The caller should ensure that NODE_LIST is present in the fast
    locals of the code object.

    Parameters
    ----------
    cg : CodeGenerator
        The code generator with which to write the code.

    node : FuncDef
        The enaml ast node of interest.

    index : int
        The index of the target node in the node list.

    """
    with cg.try_squash_raise():
        cg.set_lineno(node.lineno)
        load_helper(cg, 'add_decl_function')
        load_node(cg, index)
        _insert_decl_function(cg, node.funcdef)
        cg.load_const(node.is_override)
        cg.call_function(3)
        cg.pop_top()


class CompilerBase(ASTVisitor):
    """ A base class for defining compilers.

    """
    #: The filename for the code being generated.
    filename = Str()

    #: The code generator to use for this compiler.
    code_generator = Typed(CodeGenerator)

    def _default_code_generator(self):
        """ Create the default code generator instance.

        """
        return CodeGenerator(filename=self.filename)

########NEW FILE########
__FILENAME__ = compiler_helpers
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Event, Instance, Member
from atom.datastructures.api import sortedmap

from .alias import Alias
from .compiler_nodes import (
    DeclarativeNode, EnamlDefNode, TemplateNode, TemplateInstanceNode
)
from .declarative import Declarative, d_
from .declarative_function import DeclarativeFunction
from .declarative_meta import patch_d_member
from .enamldef_meta import EnamlDefMeta
from .expression_engine import ExpressionEngine
from .operators import __get_operators
from .template import Template


def resolve_alias(node, alias):
    """ Resolve the compiler item pointed to by an alias.

    Parameters
    ----------
    node : DeclarativeNode
        The declarative node on which the alias is being accessed.

    alias : Alias
        The alias object which is being accessed.

    Returns
    -------
    result : 2-tuple
        A 2-tuple of (node, member) which represents the resolved alias.
        If the alias does not point to a member, then the member will be
        None. Both values will be None if the alias is not valid.

    """
    if node is None:
        return (None, None)
    if node.scope_key != alias.key:
        return resolve_alias(node.super_node, alias)
    target = node.id_nodes.get(alias.target)
    if target is None:
        return (None, None)
    chain = alias.chain
    if not chain:
        return (target, None)
    last = len(chain) - 1
    for index, name in enumerate(chain):
        item = getattr(target.klass, name, None)
        if isinstance(item, Member):
            if index == last:
                return (target, item)
            return (None, None)
        if isinstance(item, Alias):
            target, member = resolve_alias(target, item)
            if target is None:
                return (None, None)
            if member is not None:
                if index == last:
                    return (target, member)
                return (None, None)
            if index == last:
                return (target, None)
        else:
            return (None, None)
    return (None, None)


def _override_fail(klass, name):
    msg = "can't override '%s.%s'"
    raise TypeError(msg % (klass.__name__, name))


def add_alias(node, name, target, chain):
    """ Add an alias to a Declarative subclass.

    Parameters
    ----------
    node : EnamlDefNode
        The enamldef node for which the alias should be added.

    name : str
        The attribute name to use when adding the alias to the class.

    target : str
        The node target for the alias.

    chain : tuple
        The chain of names to associate with the alias.

    """
    klass = node.klass
    if hasattr(klass, name):
        _override_fail(klass, name)
    alias = Alias(target, chain, node.scope_key)
    res_node, res_member = resolve_alias(node, alias)
    if res_node is None:
        msg = "'%s' is not a valid alias reference"
        parts = [target] + list(chain)
        raise TypeError(msg % '.'.join(parts))
    alias.canset = res_member is not None
    setattr(klass, name, alias)


def add_storage(node, name, store_type, kind):
    """ Add user storage to a Declarative subclass.

    Parameters
    ----------
    node : DeclarativeNode
        The declarative node to which storage should be added.

    name : str
        The name of the attribute or event to add to the class.

    store_type : type or None
        The type of values to allow on the attribute.

    kind : 'attr' or 'event'
        The kind of storage to add to the class.

    """
    if store_type is None:
        store_type = object
    elif not isinstance(store_type, type):
        raise TypeError("%s is not a type" % store_type)

    klass = node.klass
    members = klass.members()
    member = members.get(name)
    if member is not None:
        if member.metadata is None or not member.metadata.get('d_member'):
            msg = "can't override non-declarative member '%s.%s'"
            raise TypeError(msg % (klass.__name__, name))
        if member.metadata.get('d_final'):
            msg = "can't override final member '%s.%s'"
            raise TypeError(msg % (klass.__name__, name))
    elif hasattr(klass, name):
        _override_fail(klass, name)

    if kind == 'event':
        new = d_(Event(store_type), writable=False, final=False)
    elif kind == 'attr':
        new = d_(Instance(store_type), final=False)
    else:
        raise RuntimeError("invalid kind '%s'" % kind)

    if member is not None:
        new.set_index(member.index)
        new.copy_static_observers(member)
    else:
        new.set_index(len(members))

    new.set_name(name)
    patch_d_member(new)
    members[name] = new
    setattr(klass, name, new)


def declarative_node(klass, identifier, scope_key, store_locals):
    """ Create and return a DeclarativeNode for the given klass.

    Parameters
    ----------
    klass : type
        The resolved declarative class for the node.

    identifier : str
        The local string identifier to associate with instances.

    scope_key : object
        The key for the local scope in the local storage maps.

    store_locals : bool
        Whether instances of the class should store the local scope in
        their storage map.

    Returns
    -------
    result : DeclarativeNode
        The compiler node for the given klass.

    """
    node = DeclarativeNode()
    node.klass = klass
    node.identifier = identifier
    node.scope_key = scope_key
    node.store_locals = store_locals
    node.child_intercept = klass.__intercepts_child_nodes__
    # If the class is an enamldef, copy its node as the super node.
    super_node = getattr(klass, '__node__', None)
    if super_node is not None:
        super_node = super_node.copy()
        node.super_node = super_node
        node.engine = super_node.engine
    return node


def enamldef_node(klass, identifier, scope_key, store_locals):
    """ Create and return an EnamlDefNode for the given class.

    Parameters
    ----------
    klass : type
        The enamldef declarative class for the node.

    identifier : str
        The local string identifier to associate with instances.

    scope_key : object
        The key for the local scope in the local storage maps.

    store_locals : bool
        Whether instances of the class should store the local scope in
        their storage map.

    Returns
    -------
    result : EnamlDefNode
        The compiler node for the given class.

    """
    node = EnamlDefNode()
    node.klass = klass
    node.identifier = identifier
    node.scope_key = scope_key
    node.store_locals = store_locals
    node.child_intercept = klass.__intercepts_child_nodes__
    # If the class is an enamldef, copy its node as the super node.
    super_node = getattr(klass, '__node__', None)
    if super_node is not None:
        super_node = super_node.copy()
        node.super_node = super_node
        node.engine = super_node.engine
    klass.__node__ = node
    return node


def template_node(scope_key):
    """ Create and return a new template node.

    Parameters
    ----------
    scope_key : object
        The key for the local scope in the local storage maps.

    Returns
    -------
    result : TemplateNode
        A new compiler template node.

    """
    node = TemplateNode()
    node.scope_key = scope_key
    return node


def template_inst_node(templ, names, starname, scope_key, copy):
    """ Create and return a new template inst node.

    Parameters
    ----------
    templ : TemplateInst
        The template instantiation object.

    names : tuple
        The identifier names to associate with the instantiation items.
        This may be an empty tuple if there are no such identifiers.

    starname : str
        The star name to associate with the extra instantiated items.
        This may be an empty string if there is no such item.

    scope_key : object
        The key for the local scope in the local storage maps.

    copy : bool
        Whether a copy of the underlying template node is required. A
        copy will be required when the template instance has bindings
        so that the closure keys remain isolated to this instance.

    Returns
    -------
    result : TemplateInstNode
        The compiler node for the template instantiation.

    """
    node = TemplateInstanceNode()
    node.template = templ.node.copy() if copy else templ.node
    node.names = names
    node.starname = starname
    node.scope_key = scope_key
    return node


def add_template_scope(node, names, values):
    """ Create and add the template scope to a template node.

    Parameters
    ----------
    node : TemplateNode
        The template node for which to create the scope.

    scope_tuple : tuple
        A tuple of alternating key, value pairs representing the
        scope of a template instantiation.

    Returns
    -------
    result : sortedmap
        The scope mapping for the given scope tuple.

    """
    scope = sortedmap()
    for name, value in zip(names, values):
        scope[name] = value
    node.scope = scope


def make_enamldef(name, bases, dct):
    """ Make an enamldef class for the given data.

    Parameters
    ----------
    name : str
        The name of the new enamldef.

    bases : tuple
        The tuple of base classes.

    dct : dict
        The class dictionary.

    Returns
    -------
    result : EnamlDefMeta
        A new class generator from the EnamlDefMeta metaclass.

    """
    return EnamlDefMeta(name, bases, dct)


def make_object():
    """ Create a new empty object instance.

    Returns
    -------
    result : object
        A new object instance.

    """
    return object()


def make_template(paramspec, func, name, f_globals, template_map):
    """ Create a new template object.

    This method will create a new template if necessary, add the
    specialization, and store the template in the globals and the
    template map. If a template already exists in the template map
    but not in the globals, it indicates an error and an exception
    will be raised.

    Parameters
    ----------
    paramspec : tuple
        The tuple of the parameter specialization arguments.

    func : FunctionType
        The function which implements the template.

    name : str
        The name of the template.

    f_globals : dict
        The globals dictionary for the module.

    template_map : dict
        The mapping of templates already created for the module.

    """
    template = template_map.get(name)
    if template is not None:
        if f_globals.get(name) is not template:
            msg = "template '%s' was deleted before being specialized"
            raise TypeError(msg % name)
    else:
        template = Template()
        template.module = f_globals.get('__name__', '')
        template.name = name
        template_map[name] = template
        f_globals[name] = template
    template.add_specialization(paramspec, func)


def bind_aliased_member_impl(name, node, member, pair, scope_key):
    """ Bind a pair for the given aliased node and member.

    This function validates the declarative member, adds the pair
    to the node's engine, and adds the closure key for the scope.

    Parameters
    ----------
    name : str
        The pre-resolved name of the alias member. This is used for
        error reporting. The member name is used for binding.

    node : DeclarativeNode
        The compiler node holding the declarative class.

    member : Member
        The member which is being bound. It will be checked to ensure
        it is declarative and appropriately readable and writable.

    pair : HandlerPair
        The handler pair to add to the expression engine.

    scope_key : object
        The closure scope key for adding to the node's closure keys.

    """
    if member.metadata is None or not member.metadata.get('d_member'):
        raise TypeError("alias '%s' is not a declarative member" % name)
    if pair.writer is not None and not member.metadata.get('d_readable'):
        raise TypeError("alias '%s' is not readable from enaml" % name)
    if pair.reader is not None and not member.metadata.get('d_writable'):
        raise TypeError("alias '%s' is not writable from enaml" % name)
    if node.engine is None:
        node.engine = ExpressionEngine()
    node.engine.add_pair(member.name, pair)
    if node.closure_keys is None:
        node.closure_keys = set()
    node.closure_keys.add(scope_key)


def bind_aliased_member(node, name, alias, pair, scope_key):
    """ Bind a handler pair to an aliased member.

    Parameters
    ----------
    node : DeclarativeNode
        The compiler node holding the declarative class.

    name : str
        The name being bound for the class.

    alias : Alias
        The alias being bound.

    pair : HandlerPair
        The handler pair to add to the expression engine.

    scope_key : object
        The closure scope key for adding to the node's closure keys.

    """
    target_node, member = resolve_alias(node, alias)
    if target_node is None or member is None:
        msg = "alias '%s' does not resolve to a declarative member"
        raise TypeError(msg % name)
    bind_aliased_member_impl(name, target_node, member, pair, scope_key)


def bind_extended_member(node, chain, pair, scope_key):
    """ Bind a handler pair to an extended member.

    Parameters
    ----------
    node : DeclarativeNode
        The compiler node holding the declarative class.

    chain : tuple
        A tuple of names for the extended binding.

    pair : HandlerPair
        The handler pair to add to the expression engine.

    scope_key : object
        The closure scope key for adding to the node's closure keys.

    """
    # Resolve everything but the last item in the chain. Everything
    # up to that point must be aliases which resolve to an object.
    seen = []
    target_node = node
    for name in chain[:-1]:
        seen.append(name)
        alias = getattr(target_node.klass, name, None)
        if not isinstance(alias, Alias):
            raise TypeError("'%s' is not an alias" % '.'.join(seen))
        target_node, member = resolve_alias(target_node, alias)
        if target_node is None or member is not None:
            msg = "'%s' does not alias an object"
            raise TypeError(msg % '.'.join(seen))

    # Resolve the final item in the chain, which must be a Member.
    # The call to bind_member() will validate that it is declarative.
    name = chain[-1]
    member = getattr(target_node.klass, name, None)
    if isinstance(member, Alias):
        target_node, member = resolve_alias(target_node, member)
        if target_node is None or member is None:
            msg = "'%s' does not alias a member"
            raise TypeError(msg % '.'.join(chain))
    elif not isinstance(member, Member):
        msg = "'%s' does not alias a member"
        raise TypeError(msg % '.'.join(chain))

    # Bind the final aliased member.
    bind_aliased_member_impl(name, target_node, member, pair, scope_key)


def bind_member(node, name, pair):
    """ Bind a handler pair to a node.

    Parameters
    ----------
    node : DeclarativeNode
        The compiler node holding the declarative class.

    name : str
        The name being bound for the class.

    pair : HandlerPair
        The handler pair to add to the expression engine.

    """
    member = node.klass.members().get(name)
    if member is None:
        raise TypeError("'%s' is not a declarative member" % name)
    if member.metadata is None or not member.metadata.get('d_member'):
        raise TypeError("'%s' is not a declarative member" % name)
    if pair.writer is not None and not member.metadata.get('d_readable'):
        raise TypeError("'%s' is not readable from enaml" % name)
    if pair.reader is not None and not member.metadata.get('d_writable'):
        raise TypeError("'%s' is not writable from enaml" % name)
    if node.engine is None:
        node.engine = ExpressionEngine()
    node.engine.add_pair(name, pair)


def run_operator(scope_node, node, name, op, code, f_globals):
    """ Run the operator for a given node.

    Parameters
    ----------
    scope_node : DeclarativeNode
        The node which holds the scope key for the scope in which the
        code will execute.

    node : DeclarativeNode
        The compiler node holding the declarative class being bound.

    name : str or tuple
        The name or names being bound for the class.

    op : str
        The operator string which should be run to create the handlers.

    code : CodeType
        The code object for the RHS expression.

    f_globals : dict
        The globals dictionary to pass to the operator.

    """
    operators = __get_operators()
    if op not in operators:
        raise TypeError("failed to load operator '%s'" % op)
    scope_key = scope_node.scope_key
    pair = operators[op](code, scope_key, f_globals)
    if isinstance(name, tuple):
        # The template inst binding with a single name will take this
        # path by using a length-1 name tuple. See bug #78.
        bind_extended_member(node, name, pair, scope_key)
    else:
        item = getattr(node.klass, name, None)
        if isinstance(item, Alias):
            bind_aliased_member(node, name, item, pair, scope_key)
        else:
            # This is the path for a standard binding on a child def.
            # It does not need the closure scope key. See bug #78.
            bind_member(node, name, pair)


def make_unpack_map(node):
    """ Make a mapping of unpack values for a template instance.

    Parameters
    ----------
    node : TemplateInstanceNode
        The compiler node for the template instantiation.

    Returns
    -------
    result : dict
        A dict mapping unpack name to compiler node for the template
        instantiation.

    """
    return dict(zip(node.names, node.iternodes()))


def type_check_expr(value, kind):
    """ Type check the value of an expression.

    Parameters
    ----------
    value : object
        The value to type check.

    kind : type
        The allowed type of the value.

    """
    if not isinstance(kind, type):
        raise TypeError("%s is not a type" % kind)
    if not isinstance(value, kind):
        msg = "expression value has invalid type '%s'"
        raise TypeError(msg % type(value).__name__)


def validate_declarative(klass):
    """ Validate that an object is a Declarative type.

    Parameters
    ----------
    klass : object
        The object to validate.

    """
    if not isinstance(klass, type):
        raise TypeError("%s is not a type" % klass)
    if not issubclass(klass, Declarative):
        raise TypeError("'%s' is not a Declarative type" % klass.__name__)


def validate_spec(index, spec):
    """ Validate the value for a parameter specialization.

    This validator ensures that the value is hashable and not None.

    Parameters
    ----------
    index : int
        The integer index of the parameter being specialized.

    spec : object
        The parameter specialization.

    Returns
    -------
    result : object
        The validated specialization object.

    """
    if spec is None:
        msg = "cannot specialize template parameter %d with None"
        raise TypeError(msg % index)
    try:
        hash(spec)
    except TypeError:
        msg = "template parameter %d has unhashable type: '%s'"
        raise TypeError(msg % (index, type(spec).__name__))
    return spec


def validate_template(template):
    """ Validate that the object is a template.

    Parameters
    ----------
    template : object
        The object to validate.

    """
    if not isinstance(template, Template):
        raise TypeError("%s is not a template" % template)


def validate_unpack_size(template_inst, count, variadic):
    """ Validate the length of a template instantiation.

    Parameters
    ----------
    template_inst : TemplateInstance
        An instantiation of a template.

    count : int
        The number of singular unpack parameters.

    variadic : bool
        Whether or not a variadic unpacking parameter is present.

    """
    size = template_inst.node.size()
    if size < count:
        suffix = 'values' if size > 1 else 'value'
        raise ValueError("need more than %d %s to unpack" % (size, suffix))
    if not variadic and size > count:
        raise ValueError("too many values to unpack")


def add_decl_function(node, func, is_override):
    """ Add a declarative function to a declarative class.

    Parameters
    ----------
    node : DeclarativeNode
        The compiler node holding the declarative class.

    func : FunctionType
        The python function to add to the class.

    is_override : bool
        True if the function was declared with override syntax, False
        if declared as a new function on the declarative class.

    """
    name = func.__name__
    klass = node.klass
    if is_override:
        current = getattr(klass, name, None)
        if not getattr(current, "_d_func", False):
            raise TypeError("'%s' is not a declarative function" % name)
    elif hasattr(klass, name):
        _override_fail(klass, name)
    d_func = DeclarativeFunction(func, node.scope_key)
    setattr(klass, name, d_func)


__compiler_helpers = {
    'add_alias': add_alias,
    'add_decl_function': add_decl_function,
    'add_template_scope': add_template_scope,
    'add_storage': add_storage,
    'declarative_node': declarative_node,
    'enamldef_node': enamldef_node,
    'make_enamldef': make_enamldef,
    'make_object': make_object,
    'make_template': make_template,
    'make_unpack_map': make_unpack_map,
    'run_operator': run_operator,
    'template_node': template_node,
    'template_inst_node': template_inst_node,
    'type_check_expr': type_check_expr,
    'validate_declarative': validate_declarative,
    'validate_spec': validate_spec,
    'validate_template': validate_template,
    'validate_unpack_size': validate_unpack_size,
}

########NEW FILE########
__FILENAME__ = compiler_nodes
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from contextlib import contextmanager

from atom.api import Atom, Bool, Str, Tuple, Typed, ForwardTyped
from atom.datastructures.api import sortedmap

from .expression_engine import ExpressionEngine


#: The private stack of active local scopes.
__stack = []


#: The private map of active local scopes.
__map = {}


@contextmanager
def new_scope(key, seed=None):
    """ Create a new scope mapping and push it onto the stack.

    The currently active scope can be retrieved with 'peek_scope' and
    a specific scope can be retrieved with 'fetch_scope'.

    Parameters
    ----------
    key : object
        The scope key to associate with this local scope.

    seed : sortedmap, optional
        The seed map values for creating the scope.

    Returns
    -------
    result : contextmanager
        A contextmanager which will pop the scope after the context
        exits. It yields the new scope as the context variable.

    """
    if seed is not None:
        scope = seed.copy()
    else:
        scope = sortedmap()
    __map[key] = scope
    __stack.append(scope)
    yield scope
    __stack.pop()
    del __map[key]


def peek_scope():
    """ Get the local scope object from the top of the scope stack.

    Returns
    -------
    result : sortedmap
        The active scope mapping.

    """
    return __stack[-1]


def fetch_scope(key):
    """ Fetch a specific local scope by key.

    Parameters
    ----------
    key : object
        The scope key associated with the scope of interest.

    Returns
    -------
    result : sortedmap
        The relevant local scope.

    """
    return __map[key]


class CompilerNode(Atom):
    """ A base class for defining compiler nodes.

    """
    #: The scope key for the for the local scope of the node.
    scope_key = Typed(object)

    #: The child compiler nodes of this node.
    children = Typed(list, ())

    #: A mapping of id->node for the nodes in the block. This mapping
    #: is shared among all nodes in the same block.
    id_nodes = Typed(sortedmap)

    def update_id_nodes(self, mapping):
        """ Recursively update the id nodes for this node.

        Parameters
        ----------
        mapping : sortedmap
            The mapping to fill with the identifier information.

        """
        self.id_nodes = mapping
        for child in self.children:
            child.update_id_nodes(mapping)

    def copy(self):
        """ Create a copy of the compiler node.

        """
        node = type(self)()
        node.scope_key = self.scope_key
        node.children = [child.copy() for child in self.children]
        return node


class DeclarativeNode(CompilerNode):
    """ A compiler node which represents a declarative declaration.

    Instances of this class are generated by the compiler and contain
    the information needed to create an instance of the hierarchy at
    runtime.

    """
    #: The declarative type object to instantiate.
    klass = Typed(type)

    #: The local identifier to associate with the instance.
    identifier = Str()

    #: Whether or not the node should store the locals in the map.
    store_locals = Bool(False)

    #: Whether or not the instance intercepts the child nodes.
    child_intercept = Bool(False)

    #: The expression engine to associate with the instance.
    engine = Typed(ExpressionEngine)

    #: The set of scope keys for the closure scopes. This will be None
    #: if the node does not require any closure scopes.
    closure_keys = Typed(set)

    #: The superclass nodes of this node. This will be None if the
    #: node represents a raw declarative object vs an enamldef.
    super_node = ForwardTyped(lambda: EnamlDefNode)

    def __call__(self, parent):
        """ Instantiate the type hierarchy.

        This is invoked by a parent compiler node when the declarative
        hierarchy is being instantiated.

        Parameters
        ----------
        parent : Declarative or None
            The parent declarative object for the hierarchy.

        Returns
        -------
        result : Declarative
            The declarative instance created by the node.

        """
        klass = self.klass
        instance = klass.__new__(klass)
        self.populate(instance)
        instance.__init__(parent)
        return instance

    def populate(self, instance):
        """ Populate an instance generated for the node.

        Parameters
        ----------
        instance : Declarative
            The declarative instance for this node.

        """
        if self.super_node is not None:
            self.super_node(instance)
        f_locals = peek_scope()
        scope_key = self.scope_key
        if self.identifier:
            f_locals[self.identifier] = instance
        if self.store_locals:
            instance._d_storage[scope_key] = f_locals
        if self.engine is not None:
            instance._d_engine = self.engine
        if self.closure_keys is not None:
            for key in self.closure_keys:
                instance._d_storage[key] = fetch_scope(key)
        if self.child_intercept:
            children_copy = self.children[:]
            instance.child_node_intercept(children_copy, scope_key, f_locals)
        else:
            for node in self.children:
                node(instance)

    def size(self):
        """ Return the size of the instantiated node.

        """
        return 1

    def update_id_nodes(self, mapping):
        """ Update the id nodes for this node.

        Parameters
        ----------
        mapping : sortedmap
            The mapping to fill with the identifier information.

        """
        if self.identifier:
            mapping[self.identifier] = self
        super(DeclarativeNode, self).update_id_nodes(mapping)

    def copy(self):
        """ Create a copy of this portion of the node hierarchy.

        Returns
        -------
        result : DeclarativeNode
            A copy of the node hierarchy from this node down.

        """
        node = super(DeclarativeNode, self).copy()
        node.klass = self.klass
        node.identifier = self.identifier
        node.store_locals = self.store_locals
        node.child_intercept = self.child_intercept
        if self.engine is not None:
            node.engine = self.engine.copy()
        if self.super_node is not None:
            node.super_node = self.super_node.copy()
        if self.closure_keys is not None:
            node.closure_keys = self.closure_keys.copy()
        return node


class EnamlDefNode(DeclarativeNode):
    """ A declarative node which represents an 'enamldef' block.

    """
    def __call__(self, instance):
        """ Instantiate the declarative hierarchy for the node.

        This is invoked by the EnamlDefMeta class when an enamldef
        class is called, or when a DeclarativeNode invokes its
        super node.

        Parameters
        ----------
        instance : EnamlDef
            The enamldef instance which should be populated.

        """
        with new_scope(self.scope_key):
            self.populate(instance)

    def update_id_nodes(self):
        """ Update the id nodes for this node.

        """
        mapping = sortedmap()
        if self.identifier:
            mapping[self.identifier] = self
        super(DeclarativeNode, self).update_id_nodes(mapping)

    def copy(self):
        """ Create a copy the enamldef node hierarchy.

        """
        node = super(EnamlDefNode, self).copy()
        node.update_id_nodes()
        return node


class TemplateNode(CompilerNode):
    """ A compiler node which represents a template declaration.

    """
    #: The params and consts for the template instantiation. This is
    #: provided by the compiler, and should be considered read-only.
    scope = Typed(sortedmap, ())

    def __call__(self, parent):
        """ Instantiate the type hierarchy.

        Parameters
        ----------
        parent : Declarative or None
            The parent declarative object for the templates.

        Returns
        -------
        result : list
            The list of declarative objects generated by the template.

        """
        instances = []
        with new_scope(self.scope_key, self.scope):
            for node in self.children:
                if isinstance(node, DeclarativeNode):
                    instances.append(node(parent))
                elif isinstance(node, TemplateInstanceNode):
                    instances.extend(node(parent))
        return instances

    def update_id_nodes(self):
        """ Update the id nodes for this node.

        """
        super(TemplateNode, self).update_id_nodes(sortedmap())

    def size(self):
        """ Return the size of the instantiated node.

        """
        return sum(child.size() for child in self.children)

    def iternodes(self):
        """ Iterate over the nodes of the template.

        Returns
        -------
        result : generator
            A generator which yields the unrolled nodes of the template
            instantiation.

        """
        for child in self.children:
            if isinstance(child, DeclarativeNode):
                yield child
            elif isinstance(child, TemplateInstanceNode):
                for node in child.iternodes():
                    yield node

    def copy(self):
        """ Create a copy of the node.

        """
        node = super(TemplateNode, self).copy()
        node.scope = self.scope
        node.update_id_nodes()
        return node


class TemplateInstanceNode(CompilerNode):
    """ A compiler node which represents a template instantiation.

    """
    #: The template node which is invoked to generate the object.
    template = Typed(TemplateNode)

    #: The named identifiers for the instantiated objects.
    names = Tuple()

    #: The starname identifier for the instantiated objects.
    starname = Str()

    def __call__(self, parent):
        """ Invoke the template instantiation to build the objects.

        Parameters
        ----------
        parent : Declarative
            The parent declarative object for the instantiation.

        """
        instances = self.template(parent)
        f_locals = peek_scope()
        if self.names:
            for name, instance in zip(self.names, instances):
                f_locals[name] = instance
        if self.starname:
            f_locals[self.starname] = tuple(instances[len(self.names):])
        return instances

    def update_id_nodes(self, mapping):
        """ Update the id nodes for this node.

        Parameters
        ----------
        mapping : sortedmap
            The mapping to fill with the identifier information.

        """
        if self.names:
            nodeiter = self.iternodes()
            for name in self.names:
                mapping[name] = nodeiter.next()
        super(TemplateInstanceNode, self).update_id_nodes(mapping)

    def size(self):
        """ Return the size of the instantiated node.

        """
        return self.template.size()

    def iternodes(self):
        """ Iterate over the nodes of the instantiation.

        Returns
        -------
        result : generator
            A generator which yields the unrolled nodes of the template
            instantiation.

        """
        return self.template.iternodes()

    def copy(self):
        """ Create a copy of the node.

        """
        node = super(TemplateInstanceNode, self).copy()
        node.template = self.template.copy()
        node.names = self.names
        node.starname = self.starname
        return node

########NEW FILE########
__FILENAME__ = conditional
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, List

from .compiler_nodes import new_scope
from .declarative import d_
from .pattern import Pattern


class Conditional(Pattern):
    """ A pattern object that represents conditional objects.

    When the `condition` attribute is True, the conditional will create
    its child items and insert them into its parent; when False, the old
    items will be destroyed.

    """
    #: The condition variable. If this is True, a copy of the children
    #: will be inserted into the parent. Otherwise, the old copies will
    #: be destroyed.
    condition = d_(Bool(True))

    #: The list of items created by the conditional. This list should
    #: not be manipulated directly by user code.
    items = List()

    #--------------------------------------------------------------------------
    # Lifetime API
    #--------------------------------------------------------------------------
    def destroy(self):
        """ A reimplemented destructor.

        The conditional will release the owned items on destruction.

        """
        super(Conditional, self).destroy()
        del self.items

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    def _observe_condition(self, change):
        """ A private observer for the `condition` attribute.

        If the condition changes while the conditional is active, the
        items will be refreshed.

        """
        if change['type'] == 'update' and self.is_initialized:
            self.refresh_items()

    #--------------------------------------------------------------------------
    # Pattern API
    #--------------------------------------------------------------------------
    def pattern_items(self):
        """ Get a list of items created by the pattern.

        """
        return self.items[:]

    def refresh_items(self):
        """ Refresh the items of the pattern.

        This method destroys the old items and creates and initializes
        the new items.

        """
        items = []
        if self.condition:
            for nodes, key, f_locals in self.pattern_nodes:
                with new_scope(key, f_locals):
                    for node in nodes:
                        child = node(None)
                        if isinstance(child, list):
                            items.extend(child)
                        else:
                            items.append(child)

        for old in self.items:
            if not old.is_destroyed:
                old.destroy()

        if len(items) > 0:
            self.parent.insert_children(self, items)

        self.items = items

########NEW FILE########
__FILENAME__ = declarative
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Event, Typed, Unicode
from atom.datastructures.api import sortedmap

from .declarative_meta import DeclarativeMeta
from .expression_engine import ExpressionEngine
from .object import Object, flag_generator, flag_property


def d_(member, readable=True, writable=True, final=True):
    """ Mark an Atom member as bindable from Enaml syntax.

    Parameters
    ----------
    member : Member
        The atom member to mark as bindable from Enaml syntax.

    readable : bool, optional
        Whether the member is readable from Enaml syntax. The member
        must be readable to use the '>>', ':=', and '::' operators.
        The default is True.

    writable : bool, optional
        Whether the member is writable from Enaml syntax. The member
        must be writable to use the '=', '<<', and ':=' operators.
        The default is True.

    final : bool, optional
        Whether or not the member can be redefined from Enaml syntax
        using the 'attr' keyword. The default is True and indicates
        that the member cannot be overridden.

    """
    metadata = member.metadata
    if metadata is None:
        metadata = member.metadata = {}
    metadata['d_member'] = True
    metadata['d_readable'] = readable
    metadata['d_writable'] = writable
    metadata['d_final'] = final
    return member


def d_func(func):
    """ Mark a method as overridable from Enaml syntax.

    Parameters
    ----------
    func : FunctionType
        The function to tag as declarative.

    Returns
    -------
    result : func
        The original function tagged with the compiler metadata.

    """
    func._d_func = True
    return func


#: The flag indicating that the Declarative object has been initialized.
INITIALIZED_FLAG = flag_generator.next()


class Declarative(Object):
    """ The most base class of the Enaml declarative objects.

    This class provides the core functionality required of declarative
    Enaml types. It can be used directly in a declarative Enaml object
    tree to store and react to state changes. It has no concept of a
    visual representation; that functionality is added by subclasses.

    """
    __metaclass__ = DeclarativeMeta

    #: Export the 'name' attribute as a declarative member.
    name = d_(Unicode())

    #: An event fired when an object is initialized. It is triggered
    #: once during the object lifetime, at the end of the initialize
    #: method.
    initialized = d_(Event(), writable=False)

    #: A property which gets and sets the initialized flag. This should
    #: not be manipulated directly by user code.
    is_initialized = flag_property(INITIALIZED_FLAG)

    #: Storage space for the declarative runtime. This value should not
    #: be manipulated by user code.
    _d_storage = Typed(sortedmap, ())

    #: Storage space for the declarative engine. This value should not
    #: be manipulated by user code.
    _d_engine = Typed(ExpressionEngine)

    def initialize(self):
        """ Initialize this object all of its children recursively.

        This is called to give the objects in the tree the opportunity
        to initialize additional state which depends upon the object
        tree being fully built. It is the responsibility of external
        code to call this method at the appropriate time. This will
        emit the `initialized` signal after all of the children have
        been initialized.

        """
        # Iterate over a copy since the children add and remove
        # other children during initialization.
        for child in self.children[:]:
            if isinstance(child, Declarative):
                child.initialize()
        self.is_initialized = True
        self.initialized()

    def destroy(self):
        """ An overridden destructor method for declarative cleanup.

        """
        self.is_initialized = False
        del self._d_storage
        del self._d_engine
        super(Declarative, self).destroy()

    def child_added(self, child):
        """ An overridden child added event handler.

        This handler will automatically initialize a declarative child
        if this object itself has already been initialized.

        """
        super(Declarative, self).child_added(child)
        if isinstance(child, Declarative):
            if self.is_initialized and not child.is_initialized:
                child.initialize()

########NEW FILE########
__FILENAME__ = declarative_function
#------------------------------------------------------------------------------
# Copyright (c) 2014, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from .dynamicscope import DynamicScope
from .funchelper import call_func


def _super_disallowed(*args, **kwargs):
    """ A function which disallows super() in a declarative function.

    """
    msg = ('super() is not allowed in a declarative function, '
           'use SomeClass.some_method(self, ...) instead.')
    raise TypeError(msg)


def _invoke(func, key, self, args, kwargs):
    """ Invoke a declarative function.

    Parameters
    ----------
    func : FunctionType
        The Python function to invoke.

    key : object
        The local scope key for the scope locals.

    self : Declarative
        The declarative context 'self' object.

    args : tuple
        The positional arguments to pass to the function.

    kwargs : dict
        The keyword arguments to pass to the function.

    """
    f_globals = func.func_globals
    f_builtins = f_globals['__builtins__']
    f_locals = self._d_storage.get(key) or {}
    scope = DynamicScope(self, f_locals, f_globals, f_builtins)
    scope['super'] = _super_disallowed
    return call_func(func, args, kwargs, scope)


class DeclarativeFunction(object):
    """ A descriptor which implements a declarative function.

    """
    # XXX move this class to C++
    __slots__ = ('im_func', 'im_key')

    def __init__(self, im_func, im_key):
        """ Initialize a DeclarativeFunction.

        Parameters
        ----------
        im_func : FunctionType
            The Python function which implements the actual logic.

        im_key : object
            The scope key to lookup the function locals.

        """
        self.im_func = im_func
        self.im_key = im_key

    @property
    def _d_func(self):
        """ An internal compiler metadata flag.

        This allows the function to be overridden from Enaml syntax.

        """
        return True

    def __repr__(self):
        """ Returns a nice string representation of the function.

        """
        im_func = self.im_func
        args = (im_func.__module__, im_func.__name__)
        return '<declarative function %s.%s>' % args

    def __get__(self, im_self, im_class):
        """ Invoke the descriptor protocol for the function.

        If accessed unbound, this method returns 'self'. Otherwise, it
        returns a bound declarative method object.

        Parameters
        ----------
        im_self : Declarative
            The declarative instance owner object.

        im_class : type
            The declarative class type owner.

        """
        if im_self is None:
            return self
        return BoundDeclarativeMethod(
            self.im_func, self.im_key, im_self, im_class)

    def __call__(self, im_self, *args, **kwargs):
        """ Invoke the unbound declarative function.

        Parameters
        ----------
        im_self : Declarative
            The declarative instance owner object.

        *args
            The positional arguments to pass to the function.

        **kwargs
            The keyword arguments to pass to the function.

        """
        return _invoke(self.im_func, self.im_key, im_self, args, kwargs)


class BoundDeclarativeMethod(object):
    """ An object which represents a bound declarative method.

    """
    # XXX move this class to C++
    __slots__ = ('im_func', 'im_key', 'im_self', 'im_class')

    def __init__(self, im_func, im_key, im_self, im_class):
        """ Initialize a BoundDeclarativeMethod.

        Parameters
        ----------
        im_func : FunctionType
            The Python function which implements the actual logic.

        im_key : object
            The scope key to lookup the function locals.

        im_self : Declarative
            The declarative 'self' context for the function.

        im_class : type
            The type of the declarative context object.

        """
        self.im_func = im_func
        self.im_key = im_key
        self.im_self = im_self
        self.im_class = im_class

    def __repr__(self):
        """ Returns a nice string representation of the method.

        """
        im_func = self.im_func
        im_self = self.im_self
        im_class = self.im_class
        args = (im_class.__name__, im_func.__name__, im_self)
        return '<bound declarative method %s.%s of %r>' % args

    def __call__(self, *args, **kwargs):
        """ Invoke the unbound declarative method object.

        Parameters
        ----------
        *args
            The positional arguments to pass to the function.

        **kwargs
            The keyword arguments to pass to the function.

        """
        return _invoke(self.im_func, self.im_key, self.im_self, args, kwargs)

########NEW FILE########
__FILENAME__ = declarative_meta
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, AtomMeta, DefaultValue, Member, Typed


class DeclarativeDefaultHandler(Atom):
    """ A callable object which handles Declarative default values.

    This handler attempts to read the default value from the declarative
    engine, falling back on the default delegate if the engine does not
    have an implemented reader. Instances of this handler are created
    and installed by the DeclarativeMeta class.

    """
    delegate = Typed(Member, ())

    def __call__(self, owner, name):
        """ Invoke the declarative default handler.

        Parameters
        ----------
        owner : Declarative
            The declarative owner for which the default value should
            be computed.

        name : str
            The name of the attribute which should be read from the
            declarative engine.

        Returns
        -------
        result : object
            The default value for the object.

        """
        engine = owner._d_engine
        if engine is not None:
            value = engine.read(owner, name)
            if value is not NotImplemented:
                return value
        return self.delegate.do_default_value(owner)


def declarative_change_handler(change):
    """ A static observer which writes to a declarative engine.

    This handler will write the change to the declarative engine
    so that the engine can notify any bound expressions. This handler
    is attached by the DeclarativeMeta class.

    Parameters
    ----------
    change : dict
        The change dictionary generated by the notification.

    """
    # TODO think about whether this is the right place to filter on change_t
    change_t = change['type']
    if change_t == 'update' or change_t == 'event' or change_t == 'property':
        owner = change['object']
        engine = owner._d_engine
        if engine is not None:
            engine.write(owner, change['name'], change)


def patch_d_member(member):
    """ Patch the d_ member for declarative handling.

    This function will add the default value and change handlers to
    pull data from the declarative engine.

    Parameters
    ----------
    member : Member
        A member declared as a d_ member.

    """
    metadata = member.metadata
    if metadata['d_writable']:
        mode, ctxt = member.default_value_mode
        handler = DeclarativeDefaultHandler()
        handler.delegate = member.clone()
        new_mode = DefaultValue.CallObject_ObjectName
        member.set_default_value_mode(new_mode, handler)
    if metadata['d_readable']:
        member.add_static_observer(declarative_change_handler)


class DeclarativeMeta(AtomMeta):
    """ The metaclass for Declarative classes.

    This metaclass patches up the default value handlers and default
    static observers based on the 'd_' members defined on the class.
    The patching must be done after the parent metaclass runs, since
    the bindings for the default engine must occur after the standard
    default handler hookups.

    """
    #: A flag which can be set on a declarative class to indicate to
    #: the compiler that instances of the class will build out their
    #: children. If this flag is set, the class must provide a method
    #: named 'child_node_intercept' which accepts the list of nodes
    #: and the local scope for their instantiation and returns None.
    __intercepts_child_nodes__ = False

    def __new__(meta, name, bases, dct):
        """ Create a new Declarative subclass.

        """
        # Create the subclass then pass over it's update dict and
        # patch up the default value and static change handlers for
        # the d_ members. This must done *after* the main metaclass
        # runs, or the declarative default values can get clobbered.
        cls = AtomMeta.__new__(meta, name, bases, dct)
        for key, value in cls.__dict__.iteritems():
            if isinstance(value, Member):
                metadata = value.metadata
                if metadata is not None and metadata.get('d_member'):
                    patch_d_member(value)
        return cls

########NEW FILE########
__FILENAME__ = dynamic_template
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Dict, List, Str, Tuple, Typed, observe

from enaml.application import ScheduledTask, schedule
from enaml.objectdict import ObjectDict

from .declarative import Declarative, d_
from .template import Template


class Tagged(ObjectDict):
    """ An empty ObjectDict subclass.

    This subclass helps provide more informative error messages by
    having a class name which reflects it's used.

    """
    __slots__ = ()


def make_tagged(items, tags, startag):
    """ Create a Tagged object for the given items.

    Parameters
    ----------
    items : list
        The list of objects which should be tagged.

    tags : tuple
        A tuple of string tag names. This should be an empty tuple if
        no named tags are available.

    startag : str
        The star tag name. This should be an empty string if there is
        no star tag available.

    Returns
    -------
    result : Tagged
        The tagged object for the given items.

    """
    if tags and len(tags) > len(items):
        msg = 'need more than %d values to unpack'
        raise ValueError(msg % len(items))
    if tags and not startag and len(items) > len(tags):
        raise ValueError('too many values to unpack')
    tagged = Tagged()
    if tags:
        for name, item in zip(tags, items):
            tagged[name] = item
    if startag:
        tagged[startag] = tuple(items[len(tags):])
    return tagged


class DynamicTemplate(Declarative):
    """ An object which dynamically instantiates a template.

    A DynamicTemplate allows a template to be instantiated using the
    runtime scope available to RHS expressions.

    Creating a DynamicTemplate without a parent is a programming error.

    """
    #: The template object to instantiate.
    base = d_(Typed(Template))

    #: The arguments to pass to the template.
    args = d_(Tuple())

    #: The tags to apply to the return values of the template. The tags
    #: are used as the key names for the 'tagged' ObjectDict.
    tags = d_(Tuple(Str()))

    #: The tag to apply to overflow return items from the template.
    startag = d_(Str())

    #: The data keywords to apply to the instantiated items.
    data = d_(Dict())

    #: The object dictionary which maps tag name to tagged object. This
    #: is updated automatically when the template is instantiated.
    tagged = Typed(ObjectDict, ())

    #: The internal task used to collapse template updates.
    _update_task = Typed(ScheduledTask)

    #: The internal list of items generated by the template.
    _items = List(Declarative)

    def initialize(self):
        """ A reimplemented initializer.

        This method will instantiate the template and initialize the
        items for the first time.

        """
        self._refresh()
        for item in self._items:
            item.initialize()
        super(DynamicTemplate, self).initialize()

    def destroy(self):
        """ A reimplemented destructor.

        This method will ensure that the instantiated tempalte items are
        destroyed and that any potential reference cycles are released.

        """
        parent = self.parent
        destroy_items = parent is None or not parent.is_destroyed
        super(DynamicTemplate, self).destroy()
        if destroy_items:
            for item in self._items:
                if not item.is_destroyed:
                    item.destroy()
        del self.data
        del self.tagged
        if self._update_task is not None:
            self._update_task.unschedule()
            del self._update_task
        del self._items

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @observe('base', 'args', 'tags', 'startag', 'data')
    def _schedule_refresh(self, change):
        """ Schedule an item refresh when the item dependencies change.

        """
        if change['type'] == 'update':
            if self._update_task is None:
                self._update_task = schedule(self._refresh)

    def _refresh(self):
        """ Refresh the template instantiation.

        This method will destroy the old items, build the new items,
        and then update the parent object and tagged object.

        """
        self._update_task = None

        if self.base is not None:
            items = self.base(*self.args)(**self.data)
        else:
            items = []

        for old in self._items:
            if not old.is_destroyed:
                old.destroy()

        if len(items) > 0:
            self.parent.insert_children(self, items)

        self._items = items
        self.tagged = make_tagged(items, self.tags, self.startag)

########NEW FILE########
__FILENAME__ = enamldef_compiler
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from . import block_compiler as block
from . import compiler_common as cmn
from .enaml_ast import EnamlDef


class FirstPassEnamlDefCompiler(block.FirstPassBlockCompiler):
    """ The first pass enamldef compiler.

    This compiler generates the code which builds the compiler nodes
    for the enamldef definition. The main entry point is the 'compile'
    class method.

    """
    @classmethod
    def compile(cls, node, args, filename):
        """ Invoke the compiler for the given node.

        The generated code object expects the SCOPE_KEY to be passed as
        one of the arguments. The code object will return the compiler
        node list.

        Parameters
        ----------
        node : EnamlDef
            The enaml ast node of interest.

        args : list
            The list of argument names which will be passed to the
            code object when it is invoked.

        filename : str
            The filename of the node being compiled.

        Returns
        -------
        result : tuple
            A 2-tuple of (code, index_map) which is the generated code
            object for the first compiler pass, and a mapping of ast
            node to relevant compiler node index.

        """
        compiler = cls(filename=filename)
        cg = compiler.code_generator

        # Setup the block for execution.
        cmn.fetch_helpers(cg)
        cmn.make_node_list(cg, cmn.count_nodes(node))

        # Dispatch the visitors.
        compiler.visit(node)

        # Setup the parameters and generate the code object.
        cg.name = node.typename
        cg.firstlineno = node.lineno
        cg.newlocals = True
        cg.args = args
        code = cg.to_code()

        # Union the two index maps for use by the second compiler pass.
        final_index_map = dict(compiler.index_map)
        final_index_map.update(compiler.aux_index_map)

        return (code, final_index_map)

    def visit_EnamlDef(self, node):
        # No pragmas are supported yet for template nodes.
        cmn.warn_pragmas(node, self.filename)

        # Claim the index for the compiler node
        index = len(self.index_map)
        self.index_map[node] = index

        cg = self.code_generator
        cg.set_lineno(node.lineno)

        # Preload the helper to generate the enamldef
        cmn.load_helper(cg, 'make_enamldef')

        # Load the base class for the enamldef
        cg.load_const(node.typename)
        cg.load_global(node.base)                   # helper -> name -> base

        # Validate the type of the base class
        with cg.try_squash_raise():
            cg.dup_top()
            cmn.load_helper(cg, 'validate_declarative')
            cg.rot_two()                            # helper -> name -> base -> helper -> base
            cg.call_function(1)                     # helper -> name -> base -> retval
            cg.pop_top()                            # helper -> name -> base

        # Build the enamldef class
        cg.build_tuple(1)
        cg.build_map()
        cg.load_global('__name__')
        cg.load_const('__module__')
        cg.store_map()                              # helper -> name -> bases -> dict
        if node.docstring:
            cg.load_const(node.docstring)
            cg.load_const('__doc__')
            cg.store_map()
        cg.call_function(3)                         # class

        # Build the compiler node
        should_store = cmn.should_store_locals(node)
        cmn.load_helper(cg, 'enamldef_node')
        cg.rot_two()
        cg.load_const(node.identifier)
        cg.load_fast(cmn.SCOPE_KEY)
        cg.load_const(should_store)                 # helper -> class -> identifier -> bool
        cg.call_function(4)                         # node

        # Store the node into the node list
        cmn.store_node(cg, index)

        # Visit the body of the enamldef
        for item in node.body:
            self.visit(item)

        # Update the internal node ids for the hierarchy.
        cmn.load_node(cg, 0)
        cg.load_attr('update_id_nodes')
        cg.call_function()
        cg.pop_top()

        # Load and return the compiler node list..
        cg.load_fast(cmn.NODE_LIST)
        cg.return_value()


class SecondPassEnamlDefCompiler(block.SecondPassBlockCompiler):
    """ The second pass enamldef compiler.

    This compiler generates code which binds the data to the compiler
    nodes for the enamldef definition. The main entry point is the
    'compile' class method.

    """
    @classmethod
    def compile(cls, node, args, index_map, filename):
        """ Invoke the compiler for the given node.

        The generated code object expects NODE_LIST to be passed as part
        of the arguments.

        Parameters
        ----------
        node : Template
            The enaml ast Template node of interest.

        args : list
            The list of argument names which will be passed to the
            code object when it is invoked.

        index_map : dict
            A mapping of ast node to compiler node index in the node list.

        filename : str
            The filename of the node being compiled.

        Returns
        -------
        result : CodeType
            The code object which will bind the data for the block.

        """
        compiler = cls()
        compiler.filename = filename
        compiler.index_map = index_map

        cg = compiler.code_generator

        # Setup the block for execution.
        cmn.fetch_helpers(cg)
        cmn.fetch_globals(cg)

        # Dispatch the visitors.
        compiler.visit(node)

        # Setup the parameters and generate the code object.
        cg.name = node.typename
        cg.firstlineno = node.lineno
        cg.newlocals = True
        cg.args = args
        return cg.to_code()

    def visit_EnamlDef(self, node):
        # Visit the body of the enamldef.
        for item in node.body:
            self.visit(item)

        # Add the return value for the code.
        cg = self.code_generator
        cg.load_const(None)
        cg.return_value()


class EnamlDefCompiler(cmn.CompilerBase):
    """ A compiler which will compile an enamldef definition.

    The entry point is the `compile` classmethod which will compile
    the ast into a python code object which will generate the enamldef
    when invoked.

    """
    @classmethod
    def compile(cls, node, filename):
        """ The main entry point to the compiler.

        Parameters
        ----------
        node : Template
            The enaml ast node to compile.

        filename : str
            The filename of the node being compiled.

        Returns
        -------
        result : CodeType
            The compiled code object for the node.

        """
        assert isinstance(node, EnamlDef), 'invalid node'
        compiler = cls(filename=filename)
        return compiler.visit(node)

    def visit_EnamlDef(self, node):
        cg = self.code_generator
        filename = self.filename

        # Generate the code for the first pass.
        first_args = [cmn.SCOPE_KEY]
        first_code, index_map = FirstPassEnamlDefCompiler.compile(
            node, first_args, filename
        )

        # Generate the code for the second pass.
        second_args = [cmn.NODE_LIST]
        second_code = SecondPassEnamlDefCompiler.compile(
            node, second_args, index_map, filename
        )

        # Prepare the code block for execution.
        cmn.fetch_helpers(cg)
        cmn.load_helper(cg, 'make_object')
        cg.call_function()
        cg.store_fast(cmn.SCOPE_KEY)

        # Load and invoke the first pass code object.
        cg.load_const(first_code)
        cg.make_function()
        for arg in first_args:
            cg.load_fast(arg)
        cg.call_function(len(first_args))
        cg.store_fast(cmn.NODE_LIST)

        # Load and invoke the second pass code object.
        cg.load_const(second_code)
        cg.make_function()
        for arg in second_args:
            cg.load_fast(arg)
        cg.call_function(len(second_args))
        cg.pop_top()

        # Load the root template compiler node and return the class.
        cmn.load_node(cg, 0)
        cg.load_attr('klass')
        cg.return_value()

        # Setup the parameters and generate the code object.
        cg.name = node.typename
        cg.firstlineno = node.lineno
        cg.newlocals = True
        cg.docstring = node.docstring
        return cg.to_code()

########NEW FILE########
__FILENAME__ = enamldef_meta
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from .declarative_meta import DeclarativeMeta


def __enamldef_newobj__(cls, *args):
    """ An enamldef pickler function.

    This function is not part of the public Enaml api.

    """
    instance = cls.__new__(cls, *args)
    cls.__node__(instance)
    return instance


def __reduce_ex__(self, proto):
    """ An implementation of the reduce protocol.

    This method creates a reduction tuple for enamldef instances. It
    is not part of the public Enaml api.

    """
    args = (type(self),) + self.__getnewargs__()
    return (__enamldef_newobj__, args, self.__getstate__())


class EnamlDefMeta(DeclarativeMeta):
    """ The metaclass which creates types for the 'enamldef' keyword.

    """
    #: Class level storage for the compiler node. This is populated by
    #: the compiler when the enamldef class is created. It should not
    #: be modified by user code.
    __node__ = None

    def __new__(meta, name, bases, dct):
        """ Create a new enamldef subclass.

        This method overrides the default Atom pickle reducer with one
        which invokes the Enaml compiler node during unpickling.

        """
        cls = DeclarativeMeta.__new__(meta, name, bases, dct)
        if cls.__reduce_ex__ is not __reduce_ex__:
            cls.__reduce_ex__ = __reduce_ex__
        return cls

    def __repr__(cls):
        """ A nice repr for a type created by the `enamldef` keyword.

        """
        return "<enamldef '%s.%s'>" % (cls.__module__, cls.__name__)

    def __call__(cls, parent=None, **kwargs):
        """ Create a new instance of the enamldef class.

        This method will create the new instance, then populate that
        instance with children defined in the enamldef. Once those
        children are added, the __init__ method of the instance will
        be invoked with the provided arguments.

        Parameters
        ----------
        parent : Object or None
            The parent object of the new instance.

        **kwargs
            Additional keyword arguments to pass to the constructor.

        """
        instance = cls.__new__(cls)
        cls.__node__(instance)
        instance.__init__(parent, **kwargs)
        return instance

########NEW FILE########
__FILENAME__ = enaml_ast
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import ast

from atom.api import Atom, Bool, Enum, Int, List, Str, Instance, Tuple, Typed


class ASTNode(Atom):
    """ The base class for Enaml ast nodes.

    """
    #: The line number in the .enaml file which generated the node.
    lineno = Int(-1)


class PragmaArg(Atom):
    """ An atom class which represents a pragma argument.

    """
    #: The kind of the argument.
    kind = Enum("token", "number", "string")

    #: The value of the argument.
    value = Str()


class Pragma(ASTNode):
    """ An AST node which represents a $pragma expression.

    """
    #: The pragma command to execute.
    command = Str()

    #: The list of arguments for the command.
    arguments = List(PragmaArg)


class Module(ASTNode):
    """ An ASTNode representing an Enaml module.

    """
    #: The list of ast nodes for the body of the module. This will be
    #: composed of PythonModule, EnamlDef, and Template nodes.
    body = List()

    #: The pragmas to apply for the module.
    pragmas = List(Pragma)


class PythonExpression(ASTNode):
    """ An ASTNode representing a Python expression.

    """
    #: The python ast node for the given python code.
    ast = Typed(ast.Expression)


class PythonModule(ASTNode):
    """ An ASTNode representing a chunk of Python code.

    """
    #: The python ast node for the given python code.
    ast = Typed(ast.Module)


class EnamlDef(ASTNode):
    """ An ASTNode representing an enamldef block.

    """
    #: The type name given to the enamldef.
    typename = Str()

    #: The name of the base class which is being inherited.
    base = Str()

    #: The identifier given to the enamldef.
    identifier = Str()

    #: The docstring for the enamldef.
    docstring = Str()

    #: The pragmas to apply to the enamldef.
    pragmas = List(Pragma)

    #: The list of body nodes for the enamldef. This will be composed
    #: of StorageExpr, Binding, FuncDef, ChildDef and TemplateInst nodes.
    body = List()


class ChildDef(ASTNode):
    """ An ASTNode representing a child definition.

    """
    #: The type name of the child to create.
    typename = Str()

    #: The identifier given to the child.
    identifier = Str()

    #: The list of body nodes for the child def. This will be composed
    #: of StorageExpr, Binding, FuncDef, ChildDef and TemplateInst nodes.
    body = List()


class ConstExpr(ASTNode):
    """ An AST node which represents a 'const' expression.

    """
    #: The name being assigned by the expression.
    name = Str()

    #: The name of the type of allowed values for the expression.
    typename = Str()

    #: The Python expression to evaluate.
    expr = Typed(PythonExpression)


class AliasExpr(ASTNode):
    """ An AST node which represents an 'alias' expression.

    """
    #: The name of the alias.
    name = Str()

    #: The identifier of the target being aliased.
    target = Str()

    #: The chain of names being accessed by the alias.
    chain = Tuple()


class FuncDef(ASTNode):
    """ An AST node which represents a 'func' declaration or override.

    """
    #: The Python function definition.
    funcdef = Typed(ast.FunctionDef)

    #: Whether the function is an override or a 'func' declaration.
    is_override = Bool(False)


class OperatorExpr(ASTNode):
    """ An AST node which represents an operator expression.

    """
    #: The operator used to bind the code.
    operator = Str()

    #: The python ast node for the bound python code.
    value = Instance((PythonExpression, PythonModule))


class Binding(ASTNode):
    """ An AST node which represents a code binding.

    """
    #: The name of the attribute being bound.
    name = Str()

    #: The operator expression for the binding.
    expr = Typed(OperatorExpr)


class ExBinding(ASTNode):
    """ An AST node which represents an extended code binding.

    """
    #: The chain of names being bound for the expression.
    chain = Tuple()

    #: The operator expression for the binding.
    expr = Typed(OperatorExpr)


class StorageExpr(ASTNode):
    """ An AST node representing a storage expression.

    """
    #: The stype of the storage expression.
    kind = Enum('attr', 'event')

    #: The name of the storage object being defined.
    name = Str()

    #: The name of the type of allowed values for the storage object.
    typename = Str()

    #: The default expression bound to the storage object. This may
    #: be None if the storage object has no default expr binding.
    expr = Typed(OperatorExpr)


class PositionalParameter(ASTNode):
    """ An AST node for storing a positional template parameter.

    """
    #: The name of the parameter.
    name = Str()

    #: The parameter specialization.
    specialization = Typed(PythonExpression)


class KeywordParameter(ASTNode):
    """ An AST node for storing a keyword template parameter.

    """
    #: The name of the parameter.
    name = Str()

    #: The default value for the parameter.
    default = Typed(PythonExpression)


class TemplateParameters(ASTNode):
    """ An AST node for template parameters.

    """
    #: The positional parameters.
    positional = List(PositionalParameter)

    #: The keyword parameters.
    keywords = List(KeywordParameter)

    #: The variadic star param.
    starparam = Str()


class Template(ASTNode):
    """ An AST node for template definitions.

    """
    #: The name given to the template.
    name = Str()

    #: The pragmas to apply to the template.
    pragmas = List(Pragma)

    #: The parameters associated with the template.
    parameters = Typed(TemplateParameters)

    #: The docstring for the template.
    docstring = Str()

    #: The body of the template. This will be composed of ConstExpr,
    #: ChildDef, and TemplateInst nodes.
    body = List()


class TemplateArguments(ASTNode):
    """ An ASTNode representing template instatiation arguments.

    """
    #: The list of python expressions for the arguments.
    args = List(PythonExpression)

    #: The variadic argument.
    stararg = Typed(PythonExpression)


class TemplateIdentifiers(ASTNode):
    """ An AST node representing template identifiers.

    """
    #: The list of identifier names
    names = List(Str())

    #: The capturing star name.
    starname = Str()


class TemplateInst(ASTNode):
    """ An AST node for template instantiation definitions.

    """
    #: The name of the template to instantiate.
    name = Str()

    #: The pragmas to apply to the template instance.
    pragmas = List(Pragma)

    #: The arguments to pass to the template.
    arguments = Typed(TemplateArguments)

    #: The identifiers to apply to the template items.
    identifiers = Typed(TemplateIdentifiers)

    #: The body of the template instance.
    body = List()


class TemplateInstBinding(ASTNode):
    """ An AST node for a template binding.

    """
    #: The name of the object being bound.
    name = Str()

    #: The chain of names being bound on the object.
    chain = Tuple()

    #: The operator expression for the binding.
    expr = Typed(OperatorExpr)


class ASTVisitor(Atom):
    """ A base class for creating AST visitors.

    """
    #: An internal stack of the nodes being visited.
    _node_stack = List()

    def visit(self, node, *args, **kwargs):
        """ The main visitor dispatch method.

        This method will dispatch to a method which has a name which
        matches the pattern visit_<type> where <type> is the name of
        the type of the node. If no visitor method for the node exists,
        the 'default_visit' method will be invoked.

        Parameters
        ----------
        node : object
            The ast node of interest.

        *args
            Additional arguments to pass to the visitor.

        **kwargs
            Additional keywords to pass to the visitor.

        Returns
        -------
        result : object
            The object returned by the visitor, if any.

        """
        name = 'visit_' + type(node).__name__
        visitor = getattr(self, name, None)
        if visitor is None:
            visitor = self.default_visit
        self._node_stack.append(node)
        try:
            result = visitor(node, *args, **kwargs)
        finally:
            self._node_stack.pop()
        return result

    def default_visit(self, node, *args, **kwargs):
        """ The default node visitor method.

        This method is invoked when no named visitor method is found
        for a given node. This default behavior raises an exception for
        the missing handler. Subclasses may reimplement this method for
        custom default behavior.

        """
        msg = "no visitor found for node of type `%s`"
        raise TypeError(msg % type(node).__name__)

    def ancestor(self, n=1):
        """ Retrieve an ancestor node from the internal stack.

        Parameters
        ----------
        n : int, optional
            The depth of the target parent in the ancestry. The default
            is 1 and indicates the parent of the active node.

        Returns
        -------
        result : ASTNode or None
            The desired ancestor node, or None if the index is out of
            range.

        """
        try:
            # the -1 index is the current node
            result = self._node_stack[-1 - n]
        except IndexError:
            result = None
        return result

########NEW FILE########
__FILENAME__ = enaml_compiler
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import sys

from . import compiler_common as cmn
from .enaml_ast import Module
from .enamldef_compiler import EnamlDefCompiler
from .template_compiler import TemplateCompiler

# Increment this number whenever the compiler changes the code which it
# generates. This number is used by the import hooks to know which version
# of a .enamlc file is valid for the Enaml compiler version in use. If
# this number is not incremented on change, it may result in .enamlc
# files which fail on import.
#
# Version History
# ---------------
# 1 : Initial compiler version - 2 February 2012
# 2 : Update line number handling - 26 March 2012
#     When compiling code objects with mode='eval', Python ignores the
#     line number specified by the ast. The workaround is to compile the
#     code object, then make a new copy of it with the proper firstlineno
#     set via the types.CodeType constructor.
# 3 : Update the generated code to remove the toolkit - 21 June 2012
#     This updates the compiler for the coming switch to async UI's
#     which will see the removal of the Toolkit concept. The only
#     magic scope maintained is for that of operators.
# 4 : Update component building - 27 July 2012
#     This updates the compiler to handle the new Enaml creation semantics
#     that don't rely on __enaml_call__. Instead the parent is passed
#     directly to the component cls which is a subclass of Declarative.
#     That class handles calling the builder functions upon instance
#     creation. This allows us to get rid of the EnamlDef class and
#     make enamldef constructs proper subclasses of Declarative.
# 5 : Change the import names - 28 July 2012
#     This changes the imported helper name from _make_decl_subclass_
#     to _make_enamldef_helper_ which is more descriptive, but equally
#     mangled. It also updates the method name used on the Declarative
#     component for adding attribute from _add_decl_attr to the more
#     descriptive _add_user_attribute. Finally, it adds the eval_compile
#     function for compiling Python code in 'eval' mode with proper line
#     number handling.
# 6 : Compile with code tracing - 24 November 2012
#     This updates the compiler to generate code using the idea of code
#     tracing instead of monitors and inverters. The compiler compiles
#     the expressions into functions which are augmented to accept
#     additional arguments. These arguments are tracer objects which will
#     have methods called in response to bytecode ops executing. These
#     methods can then attach listeners as necessary. This is an easier
#     paradigm to develop with than the previous incarnation. This new
#     way also allows the compiler to generate the final code objects
#     upfront, instead of needed to specialize at runtime for a given
#     operator context. This results in a much smaller footprint since
#     then number of code objects created is n instead of n x m.
# 7 : Fix bug with local deletes - 10 December 2012
#     This fixes a bug in the locals optimization where the DELETE_NAME
#     opcode was not being replaced with DELETE_FAST.
# 8 : Generate description dicts instead of builders - 27 January 2013
#     This updates the compiler to generate marshalable description
#     dicts instead of builder functions. The responsibility of building
#     out the object tree has been shifted to the Declarative class. This
#     is a touch slower, but provides a ton more flexibility and enables
#     templated components like `Looper` and `Conditional`.
# 9 : Generate description dicts for attrs and events - 11 March 2013
#     This augments the description dictionary for an enamldef with
#     a list of dicts describing the 'attr' and 'event' keywords for
#     the given enamldef block. These dicts are used by the compiler
#     helper to generate atom members for the new class.
# 10 : Class time post processing and decorators - 17 March 2013
#     This moves a large amount of processing from instantiation time
#     to class definition time. In particular, operators are now bound
#     at the class level. This also adds support for decorators on an
#     enamldef block.
# 11 : Fix a bug in code generation for Python 2.6 - 18 March 2013
#     On Python 2.6 the LIST_APPEND instruction consumes the TOS. This
#     update adds a check for running on < 2.7 and dups the TOS.
# 12 : Post process an enamldef immediately. - 18 March 2013
#     This removes the need for the 2.6 check from version 11 since it
#     does not rely on the LIST_APPEND instruction. It also means
#     that widget names must appear before they are used, just like in
#     normal Python class bodies.
# 13 : Move the post processing of enamldefs to before running the
#     decorators. This means a decorator gets a complete class.
# 14 : Updates to the parser and ast to be more structured - 22 March 2013
#     This updates ast generated by the parser and updates the process
#     for class creation when a module is imported. The serialized data
#     which lives in the code object is unpacked into a construction
#     tree which is then used for various transformations.
# 15 : Complete reimplementation of the expression engine - 22 August 2013
#     This updates the compiler to generate the building logic so that
#     all of the type resolution and type hierarchy building is performed
#     at import time using native code instead of serialized dict and a
#     runtime resolver object (I have no idea what I was thinking with
#     with compiler versions 9 - 14).
# 16 : Support for templates - 9 September 2013
#     This overhauls the compiler with added support for templates to
#     the language grammar. The various compiler bits have been broken
#     out into their own classes and delegate to a CodeGenerator for
#     actually writing the bytecode operations. A large number of new
#     compiler helpers were needed for this, and they are now held in
#     a module level dictionary since the dict must persist for the
#     lifetime of the module in order to insantiate templates. The dict
#     helps remove namespace pollution.
# 17 : Support for aliases - 19 September 2013
#     The introduction of templates with version 16 introduced a strong
#     need for an alias construct. This version implements suppor for
#     such a thing. It was quite the overhaul and represents almost an
#     entirely new compiler.
# 18 : Allow const exprs to raise unsquashed - 20 September 2013
#     There was a bug in the code generated for evaluating template
#     const expressions, where an error raised by a function called
#     by the expression would have its traceback erroneously squashed.
#     This version fixes that bug.
# 19 : Fix a bug in variadic template args - 20 September 2013
#     The code generated for variadic template functions did not set
#     the varargs flag on the code object. This is now fixed.
# 20 : Fix a bug in template instantiation scoping - 13 January 2014
#     The generated code did not properly handle the scope key for
#     binding expressions on template instantiations.
#     https://github.com/nucleic/enaml/issues/78
# 21 : Add support for declarative functions - 2 May 2014
#     This update add support for the 'func' keyword and '->' style
#     declarative method overrides.
# 22 : Update the syntax of arrow functions - 5 May 2014
#     This updates the arrow functions to use "=>" instead of "->".
COMPILER_VERSION = 22


# Code that will be executed at the top of every enaml module
STARTUP = ['from enaml.core.compiler_helpers import __compiler_helpers']


# Cleanup code that will be included at the end of every enaml module
CLEANUP = []


class EnamlCompiler(cmn.CompilerBase):
    """ A compiler which will compile an Enaml module.

    The entry point is the `compile` classmethod which will compile
    the ast into an appropriate python code object for a module.

    """
    @classmethod
    def compile(cls, node, filename):
        """ The main entry point of the compiler.

        Parameters
        ----------
        node : Module
            The enaml ast Module node that should be compiled.

        filename : str
            The string filename of the module ast being compiled.

        Returns
        -------
        result : CodeType
            The code object for the compiled module.

        """
        assert isinstance(node, Module), 'invalid node'

        # Protect against unicode filenames, which are incompatible
        # with code objects created via types.CodeType
        if isinstance(filename, unicode):
            filename = filename.encode(sys.getfilesystemencoding())

        # Create the compiler and generate the code.
        compiler = cls(filename=filename)
        return compiler.visit(node)

    def visit_Module(self, node):
        cg = self.code_generator

        # Generate the startup code for the module.
        cg.set_lineno(1)
        for start in STARTUP:
            cg.insert_python_block(start)

        # Create the template map.
        cg.build_map()
        cg.store_global(cmn.TEMPLATE_MAP)

        # Populate the body of the module.
        for item in node.body:
            self.visit(item)

        # Delete the template map.
        cg.delete_global(cmn.TEMPLATE_MAP)

        # Generate the cleanup code for the module.
        for end in CLEANUP:
            cg.insert_python_block(end)

        # Finalize the ops and return the code object.
        cg.load_const(None)
        cg.return_value()
        return cg.to_code()

    def visit_PythonModule(self, node):
        # Inline the bytecode for the Python statement block.
        cg = self.code_generator
        cg.set_lineno(node.lineno)
        cg.insert_python_block(node.ast)

    def visit_EnamlDef(self, node):
        # Invoke the enamldef code and store result in the namespace.
        cg = self.code_generator
        code = EnamlDefCompiler.compile(node, cg.filename)
        cg.load_const(code)
        cg.make_function()
        cg.call_function()
        cg.store_global(node.typename)

    def visit_Template(self, node):
        cg = self.code_generator
        cg.set_lineno(node.lineno)

        with cg.try_squash_raise():

            # Load and validate the parameter specializations
            for index, param in enumerate(node.parameters.positional):
                spec = param.specialization
                if spec is not None:
                    cmn.load_helper(cg, 'validate_spec', from_globals=True)
                    cg.load_const(index)
                    cmn.safe_eval_ast(
                        cg, spec.ast, node.name, param.lineno, set()
                    )
                    cg.call_function(2)
                else:
                    cg.load_const(None)

            # Store the specializations as a tuple
            cg.build_tuple(len(node.parameters.positional))

            # Evaluate the default parameters
            for param in node.parameters.keywords:
                cmn.safe_eval_ast(
                    cg, param.default.ast, node.name, param.lineno, set()
                )

            # Generate the template code and function
            code = TemplateCompiler.compile(node, cg.filename)
            cg.load_const(code)
            cg.make_function(len(node.parameters.keywords))

            # Load and call the helper which will build the template
            cmn.load_helper(cg, 'make_template', from_globals=True)
            cg.rot_three()
            cg.load_const(node.name)
            cg.load_global('globals')
            cg.call_function()
            cg.load_global(cmn.TEMPLATE_MAP)
            cg.call_function(5)
            cg.pop_top()

########NEW FILE########
__FILENAME__ = expression_engine
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, List, Typed
from atom.datastructures.api import sortedmap


class ReadHandler(Atom):
    """ A base class for defining expression read handlers.

    """
    def __call__(self, owner, name):
        """ Evaluate and return the expression value.

        This method must be implemented by subclasses.

        Parameters
        ----------
        owner : Declarative
            The declarative object on which the expression should
            execute.

        name : str
            The attribute name on the declarative object for which
            the expression is providing a value.

        Returns
        -------
        result : object
            The evaluated value of the expression.

        """
        raise NotImplementedError


class WriteHandler(Atom):
    """ A base class for defining expression write handlers.

    """
    def __call__(self, owner, name, change):
        """ Write the change to the expression.

        This method must be implemented by subclasses.

        Parameters
        ----------
        owner : Declarative
            The declarative object on which the expression should
            execute.

        name : str
            The attribute name on the declarative object for which
            the expression is providing a value.

        change : dict
            The change dict generated by the declarative object.

        """
        raise NotImplementedError


class HandlerPair(Atom):
    """ An object which represents a pair of handlers.

    A handler pair is used to provide read and write handlers to the
    expression engine as the result of an operator call. The runtime
    adds the pair returned by the operator to the relevant expression
    engine.

    """
    #: The read handler for the pair. This may be None if the given
    #: operator does not support read semantics.
    reader = Typed(ReadHandler)

    #: The write handler for the pair. This may be None if the given
    #: operator does not support write semantics.
    writer = Typed(WriteHandler)


class HandlerSet(Atom):
    """ A class which aggregates handler pairs for an expression.

    This class is used internally by the runtime to manage handler
    pair precedence. It should not be used directly by user code.

    """
    #: The handler pair which holds the precedent read handler.
    read_pair = Typed(HandlerPair)

    #: The list of handler pairs which hold write handlers. The pairs
    #: are ordered from oldest to newest (execution order).
    write_pairs = List(HandlerPair)

    #: The complete list of handler pairs for an attribute.
    all_pairs = List(HandlerPair)

    def copy(self):
        """ Create a copy of this handler set.

        Returns
        -------
        result : HandlerSet
            A copy of the handler set with independent lists.

        """
        new = HandlerSet()
        new.read_pair = self.read_pair
        new.write_pairs = self.write_pairs
        new.all_pairs = self.all_pairs
        return new


class ExpressionEngine(Atom):
    """ A class which manages reading and writing bound expressions.

    """
    #: A private mapping of string attribute name to HandlerSet.
    _handlers = Typed(sortedmap, ())

    #: A private set of guard tuples for preventing feedback loops.
    _guards = Typed(set, ())

    def __nonzero__(self):
        """ Get the boolean value for the engine.

        An expression engine will test boolean False if there are
        no handlers associated with the engine.

        """
        return len(self._handlers) > 0

    def add_pair(self, name, pair):
        """ Add a HandlerPair to the engine.

        Parameters
        ----------
        name : str
            The name of the attribute to which the pair is bound.

        pair : HandlerPair
            The pair to bind to the expression.

        """
        handler = self._handlers.get(name)
        if handler is None:
            handler = self._handlers[name] = HandlerSet()
        handler.all_pairs.append(pair)
        if pair.reader is not None:
            handler.read_pair = pair
        if pair.writer is not None:
            handler.write_pairs.append(pair)

    def read(self, owner, name):
        """ Compute and return the value of an expression.

        Parameters
        ----------
        owner : Declarative
            The declarative object which owns the engine.

        name : str
            The name of the relevant bound expression.

        Returns
        -------
        result : object or NotImplemented
            The evaluated value of the expression, or NotImplemented
            if there is no readable expression in the engine.

        """
        handler = self._handlers.get(name)
        if handler is not None:
            pair = handler.read_pair
            if pair is not None:
                return pair.reader(owner, name)
        return NotImplemented

    def write(self, owner, name, change):
        """ Write a change to an expression.

        This method will not run the handler if its paired read handler
        is actively updating the owner attribute. This behavior protects
        against feedback loops and saves useless computation.

        Parameters
        ----------
        owner : Declarative
            The declarative object which owns the engine.

        name : str
            The name of the relevant bound expression.

        change : dict
            The change dictionary generated by the declarative object
            which owns the engine.

        """
        handler = self._handlers.get(name)
        if handler is not None:
            guards = self._guards
            for pair in handler.write_pairs:
                key = (owner, pair)
                if key not in guards:
                    guards.add(key)
                    try:
                        pair.writer(owner, name, change)
                    finally:
                        guards.remove(key)

    def update(self, owner, name):
        """ Update the named attribute of the owner.

        This method will update the named attribute by re-reading the
        expression and setting the value of the attribute. This method
        will not run the handler if its paired write handler is actively
        updating the owner attribute. This behavior protects against
        feedback loops and saves useless computation.

        Parameters
        ----------
        owner : Declarative
            The declarative object which owns the engine.

        name : str
            The name of the relevant bound expression.

        """
        handler = self._handlers.get(name)
        if handler is not None:
            pair = handler.read_pair
            if pair is not None:
                guards = self._guards
                key = (owner, pair)
                if key not in guards:
                    guards.add(key)
                    try:
                        setattr(owner, name, pair.reader(owner, name))
                    finally:
                        guards.remove(key)

    def copy(self):
        """ Create a copy of the expression engine.

        Returns
        -------
        result : ExpressionEngine
            A copy of the engine with independent handler sets.

        """
        new = ExpressionEngine()
        handlers = sortedmap()
        for key, value in self._handlers.items():
            handlers[key] = value.copy()
        new._handlers = handlers
        return new

########NEW FILE########
__FILENAME__ = import_hooks
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from abc import ABCMeta, abstractmethod
from collections import defaultdict, namedtuple
import imp
import marshal
import os
import struct
import sys
import types

from .enaml_compiler import EnamlCompiler, COMPILER_VERSION
from .parser import parse


# The magic number as symbols for the current Python interpreter. These
# define the naming scheme used when create cached files and directories.
MAGIC = imp.get_magic()
try:
    MAGIC_TAG = 'enaml-py%s%s-cv%s' % (
        sys.version_info.major, sys.version_info.minor, COMPILER_VERSION,
    )
except AttributeError:
    # Python 2.6 compatibility
    MAGIC_TAG = 'enaml-py%s%s-cv%s' % (
        sys.version_info[0], sys.version_info[1], COMPILER_VERSION,
    )
CACHEDIR = '__enamlcache__'


#------------------------------------------------------------------------------
# Import Helpers
#------------------------------------------------------------------------------
EnamlFileInfo = namedtuple('EnamlFileInfo', 'src_path, cache_path, cache_dir')


def make_file_info(src_path):
    """ Create an EnamlFileInfo object for the given src_path.

    Parameters
    ----------
    src_path : string
        The full path to the .enaml file.

    Returns
    -------
    result : FileInfo
        A properly populated EnamlFileInfo object.

    """
    root, tail = os.path.split(src_path)
    fnroot, _ = os.path.splitext(tail)
    cache_dir = os.path.join(root, CACHEDIR)
    fn = ''.join((fnroot, '.', MAGIC_TAG, os.path.extsep, 'enamlc'))
    cache_path = os.path.join(cache_dir, fn)
    return EnamlFileInfo(src_path, cache_path, cache_dir)


class abstractclassmethod(classmethod):
    """ A backport of the Python 3's abc.abstractclassmethod.

    """
    __isabstractmethod__ = True

    def __init__(self, func):
        func.__isabstractmethod__ = True
        super(abstractclassmethod, self).__init__(func)


#------------------------------------------------------------------------------
# Abstract Enaml Importer
#------------------------------------------------------------------------------
class AbstractEnamlImporter(object):
    """ An abstract base class which defines the api required to
    implement an Enaml importer.

    """
    __metaclass__ = ABCMeta

    # Count the number of times an importer has been installed.
    # Only uninstall it when the count hits 0 again. This permits
    # proper nesting of import contexts.
    _install_count = defaultdict(int)

    @classmethod
    def install(cls):
        """ Appends this importer into sys.meta_path.

        """
        cls._install_count[cls] += 1
        if cls not in sys.meta_path:
            sys.meta_path.append(cls)

    @classmethod
    def uninstall(cls):
        """ Removes this importer from sys.meta_path.

        """
        cls._install_count[cls] -= 1
        if cls._install_count[cls] <= 0 and cls in sys.meta_path:
            sys.meta_path.remove(cls)

    #--------------------------------------------------------------------------
    # Python Import API
    #--------------------------------------------------------------------------
    @classmethod
    def find_module(cls, fullname, path=None):
        """ Finds the given Enaml module and returns an importer, or
        None if the module is not found.

        """
        loader = cls.locate_module(fullname, path)
        if loader is not None:
            if not isinstance(loader, AbstractEnamlImporter):
                msg = 'Enaml imports received invalid loader object %s'
                raise ImportError(msg % loader)
            return loader

    def load_module(self, fullname):
        """ Loads and returns the Python module for the given enaml path.
        If a module already exisist in sys.path, the existing module is
        reused, otherwise a new one is created.

        """
        code, path = self.get_code()
        if fullname in sys.modules:
            mod = sys.modules[fullname]
        else:
            mod = sys.modules[fullname] = types.ModuleType(fullname)
        mod.__loader__ = self
        mod.__file__ = path
        # Even though the import hook is already installed, this is a
        # safety net to avoid potentially hard to find bugs if code has
        # manually installed and removed a hook. The contract here is
        # that the import hooks are always installed when executing the
        # module code of an Enaml file.
        with imports():
            exec code in mod.__dict__
        return mod

    #--------------------------------------------------------------------------
    # Abstract API
    #--------------------------------------------------------------------------
    @abstractclassmethod
    def locate_module(cls, fullname, path=None):
        """ Searches for the given Enaml module and returns an instance
        of AbstractEnamlImporter on success.

        Paramters
        ---------
        fullname : string
            The fully qualified name of the module.

        path : string or None
            The subpackage __path__ for submodules and subpackages
            or None if a top-level module.

        Returns
        -------
        result : Instance(AbstractEnamlImporter) or None
            If the Enaml module is located an instance of the importer
            that will perform the rest of the operations is returned.
            Otherwise, returns None.

        """
        raise NotImplementedError

    @abstractmethod
    def get_code(self):
        """ Loads and returns the code object for the Enaml module and
        the full path to the module for use as the __file__ attribute
        of the module.

        Returns
        -------
        result : (code, path)
            The Python code object for the .enaml module, and the full
            path to the module as a string.

        """
        raise NotImplementedError


#------------------------------------------------------------------------------
# Default Enaml Importer
#------------------------------------------------------------------------------
class EnamlImporter(AbstractEnamlImporter):
    """ The standard Enaml importer which can import Enaml modules from
    standard locations on the python path and compile them appropriately
    to .enamlc files.

    This importer adopts the Python 3 conventions and scheme for creating
    the cached files and setting the __file__ attribute on the module.
    See this discussion thread for more info:
    http://www.mail-archive.com/python-dev@python.org/msg45203.html

    """
    @classmethod
    def locate_module(cls, fullname, path=None):
        """ Searches for the given Enaml module and returns an instance
        of this class on success.

        Paramters
        ---------
        fullname : string
            The fully qualified name of the module.

        path : list or None
            The subpackage __path__ for submodules and subpackages
            or None if a top-level module.

        Returns
        -------
        results : Instance(AbstractEnamlImporter) or None
            If the Enaml module is located an instance of the importer
            that will perform the rest of the operations is returned.
            Otherwise, returns None.

        """
        # We're looking inside a package and 'path' the package path
        if path is not None:
            modname = fullname.rsplit('.', 1)[-1]
            leaf = ''.join((modname, os.path.extsep, 'enaml'))
            for stem in path:
                enaml_path = os.path.join(stem, leaf)
                file_info = make_file_info(enaml_path)
                if (os.path.exists(file_info.src_path) or
                    os.path.exists(file_info.cache_path)):
                    return cls(file_info)

        # We're trying a load a package
        elif '.' in fullname:
            return

        # We're doing a direct import
        else:
            leaf = fullname + os.path.extsep + 'enaml'
            for stem in sys.path:
                enaml_path = os.path.join(stem, leaf)
                file_info = make_file_info(enaml_path)
                if (os.path.exists(file_info.src_path) or
                    os.path.exists(file_info.cache_path)):
                    return cls(file_info)

    def __init__(self, file_info):
        """ Initialize an importer object.

        Parameters
        ----------
        file_info : EnamlFileInfo
            An instance of EnamlFileInfo.

        """
        self.file_info = file_info

    def _load_cache(self, file_info):
        """ Loads and returns the code object for the given file info.

        Parameters
        ----------
        file_info : EnamlFileInfo
            The file info object for the file.

        Returns
        -------
        result : types.CodeType
            The code object for the file.

        """
        with open(file_info.cache_path, 'rb') as cache_file:
            cache_file.read(8)
            code = marshal.load(cache_file)
        return code

    def _write_cache(self, code, ts, file_info):
        """ Write the cached file for then given info, creating the
        cache directory if needed. This call will suppress any
        IOError or OSError exceptions.

        Parameters
        ----------
        code : types.CodeType
            The code object to write to the cache.

        ts : int
            The integer timestamp for the file.

        file_info : EnamlFileInfo
            The file info object for the file.

        """
        try:
            if not os.path.exists(file_info.cache_dir):
                os.mkdir(file_info.cache_dir)
            with open(file_info.cache_path, 'w+b') as cache_file:
                cache_file.write(MAGIC)
                cache_file.write(struct.pack('i', ts))
                marshal.dump(code, cache_file)
        except (OSError, IOError):
            pass

    def _get_magic_info(self, file_info):
        """ Loads and returns the magic info for the given path.

        Parameters
        ----------
        file_info : EnamlFileInfo
            The file info object for the file.

        Returns
        -------
        result : (magic, timestamp)
            The magic string and integer timestamp for the file.

        """
        with open(file_info.cache_path, 'rb') as cache_file:
            magic = cache_file.read(4)
            timestamp = struct.unpack('i', cache_file.read(4))[0]
        return (magic, timestamp)

    def get_code(self):
        """ Loads and returns the code object for the Enaml module and
        the full path to the module for use as the __file__ attribute
        of the module.

        Returns
        -------
        result : (code, path)
            The Python code object for the .enaml module, and the full
            path to the module as a string.

        """
        # If the .enaml file does not exists, just use the .enamlc file.
        # We can presume that the latter exists because it was already
        # checked by the loader. Should the situation ever arise that
        # it was deleted between then and now, an IOError is more
        # informative than an ImportError.
        file_info = self.file_info
        if not os.path.exists(file_info.src_path):
            code = self._load_cache(file_info)
            return (code, file_info.src_path)

        # Use the cached file if it exists and is current
        src_mod_time = int(os.path.getmtime(file_info.src_path))
        if os.path.exists(file_info.cache_path):
            magic, ts = self._get_magic_info(file_info)
            if magic == MAGIC and src_mod_time <= ts:
                code = self._load_cache(file_info)
                return (code, file_info.src_path)

        # Otherwise, compile from source and attempt to cache
        with open(file_info.src_path, 'rU') as src_file:
            src = src_file.read()
        ast = parse(src)
        code = EnamlCompiler.compile(ast, file_info.src_path)
        self._write_cache(code, src_mod_time, file_info)
        return (code, file_info.src_path)


#------------------------------------------------------------------------------
# Enaml Imports Context
#------------------------------------------------------------------------------
class imports(object):
    """ A context manager that hooks/unhooks the enaml meta path
    importer for the duration of the block. The helps user avoid
    unintended consequences of a having a meta path importer slow
    down all of their other imports.

    """
    #: The framework-wide importers in use. We always have the default
    #: importer available, unless it is explicitly removed.
    __importers = [EnamlImporter]

    @classmethod
    def get_importers(cls):
        """ Returns a tuple of currently active importers in use for the
        framework.

        """
        return tuple(cls.__importers)

    @classmethod
    def add_importer(cls, importer):
        """ Add an importer to the list of importers for use with the
        framework. It must be a subclass of AbstractEnamlImporter.
        The most recently appended importer is used first. If the
        importer has already been added, this is a no-op. To move
        an importer up in precedence, remove it and add it again.

        """
        if not issubclass(importer, AbstractEnamlImporter):
            msg = ('An Enaml importer must be a subclass of '
                   'AbstractEnamlImporter. Got %s instead.')
            raise TypeError(msg % importer)
        importers = cls.__importers
        if importer not in importers:
            importers.append(importer)

    @classmethod
    def remove_importer(cls, importer):
        """ Removes the importer from the list of active importers.
        If the importer is not in the list, this is a no-op.

        """
        importers = cls.__importers
        if importer in importers:
            importers.remove(importer)

    def __init__(self):
        """ Initializes an Enaml import context.

        """
        self.importers = self.get_importers()

    def __enter__(self):
        """ Installs the current importer upon entering the context.

        """
        # Install the importers reversed so that the newest ones
        # get first crack at the import on sys.meta_path.
        for importer in reversed(self.importers):
            importer.install()

    def __exit__(self, *args, **kwargs):
        """ Uninstalls the current importer when leaving the context.

        """
        # We removed in standard order since thats a more efficient
        # operation on sys.meta_path.
        for importer in self.importers:
            importer.uninstall()


########NEW FILE########
__FILENAME__ = include
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import ContainerList, Bool

from .declarative import Declarative, d_
from .object import Object


class Include(Declarative):
    """ An object which dynamically inserts children into its parent.

    The 'Include' object is used to cleanly and easily insert objects
    into the children of its parent. 'Object' instances assigned to the
    'objects' list of the 'Include' will be parented with the parent of
    the 'Include'. Creating an 'Include' with no parent is a programming
    error.

    """
    #: The list of objects belonging to this Include. Objects in this
    #: list will be automatically parented with the Include's parent.
    objects = d_(ContainerList(Object))

    #: A boolean flag indicating whether to destroy the old objects that
    #: are removed from the parent. The default is True.
    destroy_old = d_(Bool(True))

    def initialize(self):
        """ A reimplemented initializer.

        This method will add the include objects to the parent of the
        include and ensure that they are initialized.

        """
        super(Include, self).initialize()
        self.parent.insert_children(self, self.objects)
        for obj in self.objects:
            obj.initialize()

    def destroy(self):
        """ A reimplemented destructor.

        The Include will destroy all of its objects if the 'destroy_old'
        flag is set and the parent is not also being destroyed.

        """
        destroy_items = self.destroy_old
        if destroy_items:
            parent = self.parent
            destroy_items = parent is None or not parent.is_destroyed
        super(Include, self).destroy()
        if destroy_items:
            for item in self.objects:
                if not item.is_destroyed:
                    item.destroy()
        del self.objects

    def _observe_objects(self, change):
        """ A change handler for the 'objects' list of the Include.

        If the object is initialized objects which are removed will be
        unparented and objects which are added will be reparented. Old
        objects will be destroyed if the 'destroy_old' flag is True.

        """
        # TODO clean this up
        if self.is_initialized:
            if change['type'] == 'update':
                oldvalue = change['oldvalue']
                newvalue = change['value']
                newset = set(newvalue)
                if self.destroy_old:
                    for obj in oldvalue:
                        if obj not in newset:
                            obj.destroy()
                else:
                    for obj in oldvalue:
                        if obj not in newset:
                            obj.set_parent(None)
                if newvalue:
                    self.parent.insert_children(self, newvalue)
            elif change['type'] == 'container':
                added = []
                removed = []
                op = change['operation']
                if op == '__delitem__':
                    item = change['item']
                    if isinstance(item, list):
                        removed.extend(item)
                    else:
                        removed.append(item)
                elif op == '__iadd__':
                    added.extend(change['items'])
                elif op == '__setitem__':
                    olditem = change['olditem']
                    newitem = change['newitem']
                    if isinstance(olditem, list):
                        removed.extend(olditem)
                    else:
                        removed.append(olditem)
                    if isinstance(newitem, list):
                        added.extend(newitem)
                    else:
                        added.append(newitem)
                elif op == 'append':
                    added.append(change['item'])
                elif op == 'extend':
                    added.extend(change['items'])
                elif op == 'insert':
                    added.append(change['item'])
                elif op == 'pop':
                    removed.append(change['item'])
                elif op == 'remove':
                    removed.append(change['item'])
                addset = set(added)
                if self.destroy_old:
                    for obj in removed:
                        if obj not in addset:
                            obj.destroy()
                else:
                    for obj in removed:
                        if obj not in addset:
                            obj.set_parent(None)
                self.parent.insert_children(self, change['value'])

########NEW FILE########
__FILENAME__ = lexer
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import os
import tokenize

import ply.lex as lex


# Get a save directory for the lex and parse tables
_lex_dir = os.path.join(os.path.dirname(__file__), 'parse_tab')
_lex_module = 'enaml.core.parse_tab.lextab'


#------------------------------------------------------------------------------
# Lexing Helpers
#------------------------------------------------------------------------------
class ParsingError(Exception):
    """ A helper class to bubble up exceptions out of the parsers
    control to be re-raised at the parsing entry point. It avoids
    problems with raise SyntaxErrors from within Ply parsing rules.

    """
    def __init__(self, exc_class, *args, **kwargs):
        self.exc_class = exc_class
        self.args = args
        self.kwargs = kwargs

    def __call__(self):
        return self.exc_class(*self.args, **self.kwargs)


def _parsing_error(klass, message, token):
    """ Create and raise a parsing error for the syntax_error and
    indentation_error functions below.

    Parameters
    ----------
    klass : Exception class
        The exception type to raise.

    message : string
        The message to pass to the exception.

    token : LexToken
        The current lextoken for the error.

    """
    filename = token.lexer.filename
    lexdata = token.lexer.lexdata
    lineno = token.lineno
    text = lexdata.splitlines()[lineno - 1]
    info = (filename, lineno, 0, text)
    raise ParsingError(klass, message, info)


def syntax_error(message, token):
    """ Raise a ParsingError which will be converted into an proper
    SyntaxError during parsing.

    Parameters
    ----------
    message : string
        The message to pass to the IndentationError

    token : LexToken
        The current lextoken for the error.

    """
    _parsing_error(SyntaxError, message, token)


def syntax_warning(message, token):
    """ Raise a warning about dubious syntax.

    Parameters
    ----------
    message : string
        The message to pass to the IndentationError

    token : LexToken
        The current lextoken for the error.

    """
    import warnings
    filename = token.lexer.filename
    lineno = token.lineno
    warnings.warn_explicit(message, SyntaxWarning, filename, lineno)


def indentation_error(message, token):
    """ Raise a ParsingError which will be converted into an proper
    IndentationError during parsing.

    Parameters
    ----------
    message : string
        The message to pass to the IndentationError

    token : LexToken
        The current lextoken for the error.

    """
    _parsing_error(IndentationError, message, token)


#------------------------------------------------------------------------------
# Enaml Lexer
#------------------------------------------------------------------------------
class EnamlLexer(object):

    operators = (
        (r'@', 'AT'),
        (r'&', 'AMPER'),
        (r'&=', 'AMPEREQUAL'),
        (r'\^', 'CIRCUMFLEX'),
        (r'\^=', 'CIRCUMFLEXEQUAL'),
        (r':', 'COLON'),
        (r'\.', 'DOT'),
        (r'//', 'DOUBLESLASH'),
        (r'//=', 'DOUBLESLASHEQUAL'),
        (r'\*\*', 'DOUBLESTAR'),
        (r'\*\*=', 'DOUBLESTAREQUAL'),
        (r'==', 'EQEQUAL'),
        (r'=', 'EQUAL'),
        (r'>', 'GREATER'),
        (r'>=', 'GREATEREQUAL'),
        (r'<<', 'LEFTSHIFT'),
        (r'<<=', 'LEFTSHIFTEQUAL'),
        (r'<', 'LESS'),
        (r'<=', 'LESSEQUAL'),
        (r'-', 'MINUS'),
        (r'-=', 'MINUSEQUAL'),
        (r'!=', 'NOTEQUAL'),
        (r'%', 'PERCENT'),
        (r'%=', 'PERCENTEQUAL'),
        (r'\+', 'PLUS'),
        (r'\+=', 'PLUSEQUAL'),
        (r'>>', 'RIGHTSHIFT'),
        (r'>>=', 'RIGHTSHIFTEQUAL'),
        (r';', 'SEMI'),
        (r'/', 'SLASH'),
        (r'/=', 'SLASHEQUAL',),
        (r'\*', 'STAR'),
        (r'\*=', 'STAREQUAL'),
        (r'~', 'TILDE'),
        (r'\|', 'VBAR'),
        (r'\|=', 'VBAREQUAL'),
        (r'::', 'DOUBLECOLON'),
        (r'\.\.\.', 'ELLIPSIS'),
        (r':=', 'COLONEQUAL'),
        (r'=>', 'RIGHTARROW'),
    )

    tokens = (
        'COMMA',
        'DEDENT',
        'ENDMARKER',
        'INDENT',
        'LBRACE',
        'LPAR',
        'LSQB',
        'NAME',
        'NEWLINE',
        'NUMBER',
        'RBRACE',
        'RPAR',
        'RSQB',
        'PRAGMA',
        'STRING',
        'WS',

        # string token sentinels
        'STRING_START_SINGLE',
        'STRING_START_TRIPLE',
        'STRING_CONTINUE',
        'STRING_END',

    )

    reserved = {
        'and': 'AND',
        'alias': 'ALIAS',
        'as': 'AS',
        'assert': 'ASSERT',
        'break': 'BREAK',
        'class': 'CLASS',
        'const': 'CONST',
        'continue': 'CONTINUE',
        'def': 'DEF',
        'del': 'DEL',
        'elif': 'ELIF',
        'else': 'ELSE',
        'enamldef': 'ENAMLDEF',
        'exec': 'EXEC',
        'except': 'EXCEPT',
        'finally': 'FINALLY',
        'from': 'FROM',
        'for': 'FOR',
        'global': 'GLOBAL',
        'if': 'IF',
        'import': 'IMPORT',
        'in': 'IN',
        'is': 'IS',
        'lambda': 'LAMBDA',
        'not': 'NOT',
        'or': 'OR',
        'pass': 'PASS',
        'print': 'PRINT',
        'raise': 'RAISE',
        'return': 'RETURN',
        'template': 'TEMPLATE',
        'try': 'TRY',
        'while': 'WHILE',
        'with': 'WITH',
        'yield': 'YIELD',
    }

    tokens = (tokens +
              tuple(val[1] for val in operators) +
              tuple(reserved.values()))

    #--------------------------------------------------------------------------
    # Lexer States
    #--------------------------------------------------------------------------
    states = (
        ('SINGLEQ1', 'exclusive'),
        ('SINGLEQ2', 'exclusive'),
        ('TRIPLEQ1', 'exclusive'),
        ('TRIPLEQ2', 'exclusive'),
    )

    #--------------------------------------------------------------------------
    # Default Rules
    #--------------------------------------------------------------------------
    t_COMMA = r','
    t_NUMBER = tokenize.Number
    t_PRAGMA = r'\$pragma'

    # Generate the token matching rules for the operators
    for tok_pattern, tok_name in operators:
        tok_name = 't_' + tok_name
        locals()[tok_name] = tok_pattern

    def t_comment(self, t):
        r'[ ]*\#[^\r\n]*'
        pass

    def t_WS(self, t):
        r' [ \t\f]+ '
        value = t.value

        # A formfeed character may be present at the start of the
        # line; it will be ignored for the indentation calculations
        # above. Formfeed characters occurring elsewhere in the
        # leading whitespace have an undefined effect (for instance,
        # they may reset the space count to zero).
        value = value.rsplit("\f", 1)[-1]

        # First, tabs are replaced (from left to right) by one to eight
        # spaces such that the total number of characters up to and
        # including the replacement is a multiple of eight (this is
        # intended to be the same rule as used by Unix). The total number
        # of spaces preceding the first non-blank character then
        # determines the line's indentation. Indentation cannot be split
        # over multiple physical lines using backslashes; the whitespace
        # up to the first backslash determines the indentation.
        pos = 0
        while True:
            pos = value.find("\t")
            if pos == -1:
                break
            n = 8 - (pos % 8)
            value = value[:pos] + " " * n + value[pos+1:]

        if self.at_line_start and self.paren_count == 0:
            return t

    # string continuation - ignored beyond the tokenizer level
    def t_escaped_newline(self, t):
        r"\\\n"
        t.type = "STRING_CONTINUE"
        # Raw strings don't escape the newline
        assert not self.is_raw, "only occurs outside of quoted strings"
        t.lexer.lineno += 1

    def t_newline(self, t):
        r'\n+'
        t.lexer.lineno += len(t.value)
        t.type = 'NEWLINE'
        if self.paren_count == 0:
            return t

    def t_LPAR(self, t):
        r'\('
        self.paren_count += 1
        return t

    def t_RPAR(self, t):
        r'\)'
        self.paren_count -= 1
        return t

    def t_LBRACE(self, t):
        r'\{'
        self.paren_count += 1
        return t

    def t_RBRACE(self, t):
        r'\}'
        self.paren_count -= 1
        return t

    def t_LSQB(self, t):
        r'\['
        self.paren_count += 1
        return t

    def t_RSQB(self, t):
        r'\]'
        self.paren_count -= 1
        return t

    #--------------------------------------------------------------------------
    # State string escapes
    #--------------------------------------------------------------------------
    def t_SINGLEQ1_SINGLEQ2_TRIPLEQ1_TRIPLEQ2_escaped(self, t):
        r"\\(.|\n)"
        t.type = "STRING_CONTINUE"
        t.lexer.lineno += t.value.count("\n")
        return t

    #--------------------------------------------------------------------------
    # TRIPLEQ1 strings
    #--------------------------------------------------------------------------
    def t_start_triple_quoted_q1_string(self, t):
        r"[uU]?[rR]?'''"
        t.lexer.push_state("TRIPLEQ1")
        t.type = "STRING_START_TRIPLE"
        if "r" in t.value or "R" in t.value:
            self.is_raw = True
        t.value = t.value.split("'", 1)[0]
        return t

    def t_TRIPLEQ1_simple(self, t):
        r"[^'\\]+"
        t.type = "STRING_CONTINUE"
        t.lexer.lineno += t.value.count("\n")
        return t

    def t_TRIPLEQ1_q1_but_not_triple(self, t):
        r"'(?!'')"
        t.type = "STRING_CONTINUE"
        return t

    def t_TRIPLEQ1_end(self, t):
        r"'''"
        t.type = "STRING_END"
        t.lexer.pop_state()
        self.is_raw = False
        return t

    # supress PLY warning
    t_TRIPLEQ1_ignore = ''

    def t_TRIPLEQ1_error(self, t):
        syntax_error('invalid syntax', t)

    #--------------------------------------------------------------------------
    # TRIPLEQ2 strings
    #--------------------------------------------------------------------------
    def t_start_triple_quoted_q2_string(self, t):
        r'[uU]?[rR]?"""'
        t.lexer.push_state("TRIPLEQ2")
        t.type = "STRING_START_TRIPLE"
        if "r" in t.value or "R" in t.value:
            self.is_raw = True
        t.value = t.value.split('"', 1)[0]
        return t

    def t_TRIPLEQ2_simple(self, t):
        r'[^"\\]+'
        t.type = "STRING_CONTINUE"
        t.lexer.lineno += t.value.count("\n")
        return t

    def t_TRIPLEQ2_q2_but_not_triple(self, t):
        r'"(?!"")'
        t.type = "STRING_CONTINUE"
        return t

    def t_TRIPLEQ2_end(self, t):
        r'"""'
        t.type = "STRING_END"
        t.lexer.pop_state()
        self.is_raw = False
        return t

    # supress PLY warning
    t_TRIPLEQ2_ignore = ''

    def t_TRIPLEQ2_error(self, t):
        syntax_error('invalid syntax', t)

    #--------------------------------------------------------------------------
    # SINGLEQ1 strings
    #--------------------------------------------------------------------------
    def t_start_single_quoted_q1_string(self, t):
        r"[uU]?[rR]?'"
        t.lexer.push_state("SINGLEQ1")
        t.type = "STRING_START_SINGLE"
        if "r" in t.value or "R" in t.value:
            self.is_raw = True
        t.value = t.value.split("'", 1)[0]
        return t

    def t_SINGLEQ1_simple(self, t):
        r"[^'\\\n]+"
        t.type = "STRING_CONTINUE"
        return t

    def t_SINGLEQ1_end(self, t):
        r"'"
        t.type = "STRING_END"
        t.lexer.pop_state()
        self.is_raw = False
        return t

    # supress PLY warning
    t_SINGLEQ1_ignore = ''

    def t_SINGLEQ1_error(self, t):
        syntax_error('EOL while scanning single quoted string.', t)

    #--------------------------------------------------------------------------
    # SINGLEQ2 strings
    #--------------------------------------------------------------------------
    def t_start_single_quoted_q2_string(self, t):
        r'[uU]?[rR]?"'
        t.lexer.push_state("SINGLEQ2")
        t.type = "STRING_START_SINGLE"
        if "r" in t.value or "R" in t.value:
            self.is_raw = True
        t.value = t.value.split('"', 1)[0]
        return t

    def t_SINGLEQ2_simple(self, t):
        r'[^"\\\n]+'
        t.type = "STRING_CONTINUE"
        return t

    def t_SINGLEQ2_end(self, t):
        r'"'
        t.type = "STRING_END"
        t.lexer.pop_state()
        self.is_raw = False
        return t

    # supress PLY warning
    t_SINGLEQ2_ignore = ''

    def t_SINGLEQ2_error(self, t):
        syntax_error('EOL while scanning single quoted string.', t)

    #--------------------------------------------------------------------------
    # Miscellaneous Token Rules
    #--------------------------------------------------------------------------
    # This is placed after the string rules so r"" is not matched as a name.
    def t_NAME(self, t):
        r'[a-zA-Z_][a-zA-Z0-9_]*'
        t.type = self.reserved.get(t.value, "NAME")
        return t

    def t_error(self, t):
        syntax_error('invalid syntax', t)

    #--------------------------------------------------------------------------
    # Normal Class Items
    #--------------------------------------------------------------------------
    def __init__(self, filename='Enaml'):
        self.lexer = lex.lex(
            module=self, outputdir=_lex_dir, lextab=_lex_module, optimize=1,
        )
        self.token_stream = None
        self.filename = filename

        # Ply has a bit of an inconsistency when using a class as a
        # lexer instead of a module. The .lexer attribute of tokens
        # created by the ply lexer are set to that ply lexer instance,
        # but the .lexer attribute of tokens created by the ply parser
        # are set to the instance of this class. So, when the p_error
        # function is called in the parser, we can't be sure which lexer
        # will be set on the error token. Since we need the filename in
        # that function, we add it as an attribute on both lexers.
        self.lexer.filename = filename

    def input(self, txt):
        self.lexer.input(txt)
        self.next_token = self.make_token_stream().next

        # State initialization
        self.paren_count = 0
        self.is_raw = False
        self.at_line_start = False

    def token(self):
        try:
            tok = self.next_token()
            return tok
        except StopIteration:
            pass

    def dedent(self, lineno):
        # Synthesize a DEDENT Token
        tok = lex.LexToken()
        tok.type = 'DEDENT'
        tok.value = None
        tok.lineno = lineno
        tok.lexpos = -1
        tok.lexer = self.lexer
        return tok

    def indent(self, lineno):
        # Synthesize an INDENT Token.
        tok = lex.LexToken()
        tok.type = 'INDENT'
        tok.value = None
        tok.lineno = lineno
        tok.lexpos = -1
        tok.lexer = self.lexer
        return tok

    def newline(self, lineno):
        tok = lex.LexToken()
        tok.type = 'NEWLINE'
        tok.value = '\n'
        tok.lineno = lineno
        tok.lexpos = -1
        tok.lexer = self.lexer
        return tok

    def make_token_stream(self):
        token_stream = iter(self.lexer.token, None)
        token_stream = self.ensure_token_lexer(token_stream)
        token_stream = self.create_strings(token_stream)
        token_stream = self.annotate_indentation_state(token_stream)
        token_stream = self.synthesize_indentation_tokens(token_stream)
        token_stream = self.add_endmarker(token_stream)
        return token_stream

    def ensure_token_lexer(self, token_stream):
        # PLY only assigns the lexer to tokens which are passed
        # to t_* functions. This ensures each token gets assigned
        # a lexer, since that is required by the error handlers.
        lexer = self.lexer
        for tok in token_stream:
            if getattr(tok, 'lexer', None) is None:
                tok.lexer = lexer
            yield tok

    def create_strings(self, token_stream):
        for tok in token_stream:
            if not tok.type.startswith("STRING_START_"):
                yield tok
                continue

            # This is a string start; process until string end
            start_tok = tok
            string_toks = []
            for tok in token_stream:
                if tok.type == "STRING_END":
                    break
                else:
                    assert tok.type == "STRING_CONTINUE", tok.type
                    string_toks.append(tok)
            else:
                # Reached end of input without string termination
                msg = 'EOF while scanning %s-quoted string.'
                if start_tok.type == 'STRING_START_TRIPLE':
                    msg = msg % 'triple'
                else:
                    msg = msg % 'single'
                syntax_error(msg, start_tok)

            # Parse the quoted string.
            #
            # The four combinations are:
            #  "ur"  - raw_unicode_escape
            #  "u"   - unicode_escape
            #  "r"   - no need to do anything
            #  ""    - string_escape
            s = "".join(tok.value for tok in string_toks)
            quote_type = start_tok.value.lower()
            if quote_type == "":
                s = s.decode("string_escape")
            elif quote_type == "u":
                s = s.decode("unicode_escape")
            elif quote_type == "ur":
                s = s.decode("raw_unicode_escape")
            elif quote_type == "r":
                s = s
            else:
                msg = 'Unknown string quote type: %r' % quote_type
                raise AssertionError(msg)

            start_tok.type = "STRING"
            start_tok.value = s

            yield start_tok

    # Keep track of indentation state
    #
    # I implemented INDENT / DEDENT generation as a post-processing filter
    #
    # The original lex token stream contains WS and NEWLINE characters.
    # WS will only occur before any other tokens on a line.
    #
    # I have three filters.  One tags tokens by adding two attributes.
    # "must_indent" is True if the token must be indented from the
    # previous code.  The other is "at_line_start" which is True for WS
    # and the first non-WS/non-NEWLINE on a line.  It flags the check to
    # see if the new line has changed indication level.
    #
    # Python's syntax has three INDENT states
    #  0) no colon hence no need to indent
    #  1) "if 1: go()" - simple statements have a COLON but no need for an indent
    #  2) "if 1:\n  go()" - complex statements have a COLON NEWLINE and must indent
    #
    # We only care about whitespace at the start of a line
    def annotate_indentation_state(self, token_stream):
        NO_INDENT = 0
        MAY_INDENT = 1
        MUST_INDENT = 2

        self.at_line_start = at_line_start = True
        indent = NO_INDENT

        for token in token_stream:
            token.at_line_start = at_line_start

            # The double colon serves double purpose: in slice operations
            # and also as the notification operator. In the case of a
            # slice operation, newline continuation is already allowed
            # by suppressing NEWLINE tokens in a multiline expression.
            # So, we can treat double colon the same as colon here for
            # handling the logic surrounding indentation state.
            if token.type in ("COLON", "DOUBLECOLON"):
                at_line_start = False
                indent = MAY_INDENT
                token.must_indent = False

            elif token.type == "NEWLINE":
                at_line_start = True
                if indent == MAY_INDENT:
                    indent = MUST_INDENT
                token.must_indent = False

            elif token.type == "WS":
                assert token.at_line_start == True
                at_line_start = True
                token.must_indent = False

            else:
                # A real token; only indent after COLON NEWLINE
                if indent == MUST_INDENT:
                    token.must_indent = True
                else:
                    token.must_indent = False
                at_line_start = False
                indent = NO_INDENT

            yield token
            self.at_line_start = at_line_start

    def synthesize_indentation_tokens(self, token_stream):
        # A stack of indentation levels; will never pop item 0
        levels = [0]
        depth = 0
        prev_was_ws = False

        # In case the token stream is empty for a completely
        # empty file.
        token = None

        for token in token_stream:
            # WS only occurs at the start of the line
            # There may be WS followed by NEWLINE so
            # only track the depth here.  Don't indent/dedent
            # until there's something real.
            if token.type == 'WS':
                assert depth == 0
                depth = len(token.value)
                prev_was_ws = True
                # WS tokens are never passed to the parser
                continue

            if token.type == 'NEWLINE':
                depth = 0
                if prev_was_ws or token.at_line_start:
                    # ignore blank lines
                    continue
                # pass the other cases on through
                yield token
                continue

            # then it must be a real token (not WS, not NEWLINE)
            # which can affect the indentation level
            prev_was_ws = False

            if token.must_indent:
                # The current depth must be larger than the previous level
                if not (depth > levels[-1]):
                    indentation_error('expected an indented block', token)
                levels.append(depth)
                yield self.indent(token.lineno)

            elif token.at_line_start:
                # Must be on the same level or one of the previous levels
                if depth == levels[-1]:
                    # At the same level
                    pass
                elif depth > levels[-1]:
                    # indentation increase but not in new block
                    indentation_error('unexpected indent', token)
                else:
                    # Back up; but only if it matches a previous level
                    try:
                        i = levels.index(depth)
                    except ValueError:
                        msg = ('unindent does not match any outer level '
                               'of indentation.')
                        indentation_error(msg, token)
                    for _ in range(i + 1, len(levels)):
                        yield self.dedent(token.lineno)
                        levels.pop()

            yield token

        # If the current token is WS (which is only emitted at the start
        # of a line), then the token before that was a newline unless
        # we're on line number 1. If that's the case, then we don't
        # need another newline token.
        if token is None:
            yield self.newline(self.lexer.lineno)
        elif token.type != 'NEWLINE':
            if token.type != 'WS' or token.lineno == 1:
                yield self.newline(self.lexer.lineno)

        # Must dedent any remaining levels
        if len(levels) > 1:
            assert token is not None
            for _ in range(1, len(levels)):
                yield self.dedent(token.lineno)

    def add_endmarker(self, token_stream):
        for tok in token_stream:
            yield tok

        end_marker = lex.LexToken()
        end_marker.type = 'ENDMARKER'
        end_marker.value = None
        end_marker.lineno = -1
        end_marker.lexpos = -1
        end_marker.lexer = self.lexer
        yield end_marker


########NEW FILE########
__FILENAME__ = looper
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from collections import Iterable

from atom.api import Instance, List, Typed
from atom.datastructures.api import sortedmap

from .compiler_nodes import new_scope
from .declarative import d_
from .pattern import Pattern


class Looper(Pattern):
    """ A pattern object that repeats its children over an iterable.

    The children of a `Looper` are used as a template when creating new
    objects for each item in the given `iterable`. Each iteration of the
    loop will be given an indenpendent scope which is the union of the
    outer scope and any identifiers created during the iteration. This
    scope will also contain `loop_index` and `loop_item` variables which
    are the index and value of the iterable, respectively.

    All items created by the looper will be added as children of the
    parent of the `Looper`. The `Looper` keeps ownership of all items
    it creates. When the iterable for the looper is changed, the looper
    will only create and destroy children for the items in the iterable
    which have changed.

    """
    #: The iterable to use when creating the items for the looper.
    iterable = d_(Instance(Iterable))

    #: The list of items created by the conditional. Each item in the
    #: list represents one iteration of the loop and is a list of the
    #: items generated during that iteration. This list should not be
    #: manipulated directly by user code.
    items = List()

    #: Private data storage which maps the user iterable data to the
    #: list of items created for that iteration. This allows the looper
    #: to only create and destroy the items which have changed.
    _iter_data = Typed(sortedmap, ())

    #--------------------------------------------------------------------------
    # Lifetime API
    #--------------------------------------------------------------------------
    def destroy(self):
        """ A reimplemented destructor.

        The looper will release the owned items on destruction.

        """
        super(Looper, self).destroy()
        del self.iterable
        del self.items
        del self._iter_data

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    def _observe_iterable(self, change):
        """ A private observer for the `iterable` attribute.

        If the iterable changes while the looper is active, the loop
        items will be refreshed.

        """
        if change['type'] == 'update' and self.is_initialized:
            self.refresh_items()

    #--------------------------------------------------------------------------
    # Pattern API
    #--------------------------------------------------------------------------
    def pattern_items(self):
        """ Get a list of items created by the pattern.

        """
        return sum(self.items, [])

    def refresh_items(self):
        """ Refresh the items of the pattern.

        This method destroys the old items and creates and initializes
        the new items.

        """
        old_items = self.items[:]
        old_iter_data = self._iter_data
        iterable = self.iterable
        pattern_nodes = self.pattern_nodes
        new_iter_data = sortedmap()
        new_items = []

        if iterable is not None and len(pattern_nodes) > 0:
            for loop_index, loop_item in enumerate(iterable):
                iteration = old_iter_data.get(loop_item)
                if iteration is not None:
                    new_iter_data[loop_item] = iteration
                    new_items.append(iteration)
                    old_items.remove(iteration)
                    continue
                iteration = []
                new_iter_data[loop_item] = iteration
                new_items.append(iteration)
                for nodes, key, f_locals in pattern_nodes:
                    with new_scope(key, f_locals) as f_locals:
                        f_locals['loop_index'] = loop_index
                        f_locals['loop_item'] = loop_item
                        for node in nodes:
                            child = node(None)
                            if isinstance(child, list):
                                iteration.extend(child)
                            else:
                                iteration.append(child)

        for iteration in old_items:
            for old in iteration:
                if not old.is_destroyed:
                    old.destroy()

        if len(new_items) > 0:
            expanded = []
            recursive_expand(sum(new_items, []), expanded)
            self.parent.insert_children(self, expanded)

        self.items = new_items
        self._iter_data = new_iter_data


def recursive_expand(items, expanded):
    """ Recursively expand the list of items created by the looper.

    This allows the final list to be inserted into the parent and
    maintain the proper ordering of children.

    Parameters
    ----------
    items : list
        The list of items to expand. This should be composed of
        Pattern and other Object instances.

    expanded : list
        The output list. This list will be modified in-place.

    """
    for item in items:
        if isinstance(item, Pattern):
            recursive_expand(item.pattern_items(), expanded)
        expanded.append(item)

########NEW FILE########
__FILENAME__ = object
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from collections import deque
import re

from atom.api import Atom, Unicode, Value, List, Event


def flag_generator():
    """ A generator which yields success bit flags.

    This should be used when creating flag values for a subclass of
    Object in order to not trample on superclass flags.

    """
    flag = 1
    while True:
        yield flag
        flag <<= 1
flag_generator = flag_generator()


#: A flag indicated that an object has been destroyed.
DESTROYED_FLAG = flag_generator.next()


def flag_property(flag):
    """ A factory function which creates a flag accessor property.

    """
    def getter(self):
        return (self._flags & flag) != 0
    def setter(self, value):
        if value:
            self._flags |= flag
        else:
            self._flags &= ~flag
    return property(getter, setter)


class Object(Atom):
    """ The most base class of the Enaml object hierarchy.

    An Enaml Object provides supports parent-children relationships and
    provides methods for navigating, searching, and destroying the tree.

    """
    #: An optional name to give to this object to assist in finding it
    #: in the tree (see . the 'find' method). There is no guarantee of
    #: uniqueness for an object `name`. It is left to the developer to
    #: choose an appropriate name.
    name = Unicode()

    #: The read-only property which returns the object parent. This will
    #: be an Object or None. Use 'set_parent()' or pass the parent to
    #: the constructor to set the parent of an object.
    parent = property(lambda self: self._parent)

    #: A read-only property which returns the object children. This is
    #: a list of Object instances. User code should not modify the list
    #: directly. Instead, use 'set_parent()' or 'insert_children()'.
    children = property(lambda self: self._children)

    #: A property which gets and sets the destroyed flag. This should
    #: not be manipulated directly by user code.
    is_destroyed = flag_property(DESTROYED_FLAG)

    #: An event fired when an object has been destroyed. It is triggered
    #: once during the object lifetime, just before the object is
    #: removed from the tree structure.
    destroyed = Event()

    #: Private storage values. These should *never* be manipulated by
    #: user code. For performance reasons, these are not type checked.
    _parent = Value()   # Object or None
    _children = List()  # list of Object
    _flags = Value(0)   # object flags

    def __init__(self, parent=None, **kwargs):
        """ Initialize an Object.

        Parameters
        ----------
        parent : Object or None, optional
            The Object instance which is the parent of this object, or
            None if the object has no parent. Defaults to None.

        **kwargs
            Additional keyword arguments to apply as attributes to the
            object.

        """
        super(Object, self).__init__(**kwargs)
        if parent is not None:
            self.set_parent(parent)

    def destroy(self):
        """ Destroy this object and all of its children recursively.

        This will emit the `destroyed` event before any change to the
        object tree is made. After this returns, the object should be
        considered invalid and should no longer be used.

        """
        self.is_destroyed = True
        self.destroyed()
        self.unobserve()
        for child in self._children:
            child.destroy()
        del self._children
        parent = self._parent
        if parent is not None:
            if parent.is_destroyed:
                self._parent = None
            else:
                self.set_parent(None)

    #--------------------------------------------------------------------------
    # Parenting API
    #--------------------------------------------------------------------------
    def set_parent(self, parent):
        """ Set the parent for this object.

        If the parent is not None, the child will be appended to the end
        of the parent's children. If the parent is already the parent of
        this object, then this method is a no-op. If this object already
        has a parent, then it will be properly reparented.

        Parameters
        ----------
        parent : Object or None
            The Object instance to use for the parent, or None if this
            object should be unparented.

        Notes
        -----
        It is the responsibility of the caller to initialize and activate
        the object as needed, if it is reparented dynamically at runtime.

        """
        old_parent = self._parent
        if parent is old_parent:
            return
        if parent is self:
            raise ValueError('cannot use `self` as Object parent')
        if parent is not None and not isinstance(parent, Object):
            raise TypeError('parent must be an Object or None')
        self._parent = parent
        self.parent_changed(old_parent, parent)
        if old_parent is not None:
            old_parent._children.remove(self)
            old_parent.child_removed(self)
        if parent is not None:
            parent._children.append(self)
            parent.child_added(self)

    def insert_children(self, before, insert):
        """ Insert children into this object at the given location.

        The children will be automatically parented and inserted into
        the object's children. If any children are already children of
        this object, then they will be moved appropriately.

        Parameters
        ----------
        before : Object, int or None
            A child object or int to use as the marker for inserting
            the new children. The new children will be inserted before
            this marker. If the Object is None or not a child, or if
            the int is not a valid index, then the new children will be
            added to the end of the children.

        insert : iterable
            An iterable of Object children to insert into this object.

        Notes
        -----
        It is the responsibility of the caller to initialize and activate
        the object as needed, if it is reparented dynamically at runtime.

        """
        insert_list = list(insert)
        insert_set = set(insert_list)
        if self in insert_set:
            raise ValueError('cannot use `self` as Object child')
        if len(insert_list) != len(insert_set):
            raise ValueError('cannot insert duplicate children')
        if not all(isinstance(child, Object) for child in insert_list):
            raise TypeError('children must be an Object instances')

        if isinstance(before, int):
            try:
                before = self._children[before]
            except IndexError:
                before = None

        new = []
        added = False
        for child in self._children:
            if child in insert_set:
                insert_set.remove(child)
                continue
            if child is before:
                new.extend(insert_list)
                added = True
            new.append(child)
        if not added:
            new.extend(insert_list)

        for child in insert_list:
            old_parent = child._parent
            if old_parent is not self:
                child._parent = self
                child.parent_changed(old_parent, self)
                if old_parent is not None:
                    old_parent.child_removed(child)

        self._children = new
        child_added = self.child_added
        for child in insert_list:
            if child in insert_set:
                child_added(child)

    def parent_changed(self, old, new):
        """ A method invoked when the parent of the object changes.

        This method is called when the parent on the object has changed,
        but before the children of the new parent have been updated.
        Sublasses may reimplement this method as required.

        Parameters
        ----------
        old : Object or None
            The old parent of the object.

        new : Object or None
            the new parent of the object.

        """
        pass

    def child_added(self, child):
        """ A method invoked when a child is added to the object.

        Sublasses may reimplement this method as required.

        Parameters
        ----------
        child : Object
            The child added to this object.

        """
        pass

    def child_removed(self, child):
        """ A method invoked when a child is removed from the object.

        Sublasses may reimplement this method as required.

        Parameters
        ----------
        child : Object
            The child removed from the object.

        """
        pass

    #--------------------------------------------------------------------------
    # Object Tree API
    #--------------------------------------------------------------------------
    def root_object(self):
        """ Get the root object for this hierarchy.

        Returns
        -------
        result : Object
            The top-most object in the hierarchy to which this object
            belongs.

        """
        obj = self
        while obj._parent is not None:
            obj = obj._parent
        return obj

    def traverse(self, depth_first=False):
        """ Yield all of the objects in the tree, from this object down.

        Parameters
        ----------
        depth_first : bool, optional
            If True, yield the nodes in depth first order. If False,
            yield the nodes in breadth first order. Defaults to False.

        """
        if depth_first:
            stack = [self]
            stack_pop = stack.pop
            stack_extend = stack.extend
        else:
            stack = deque([self])
            stack_pop = stack.popleft
            stack_extend = stack.extend
        while stack:
            obj = stack_pop()
            yield obj
            stack_extend(obj._children)

    def traverse_ancestors(self, root=None):
        """ Yield all of the objects in the tree, from this object up.

        Parameters
        ----------
        root : Object, optional
            The object at which to stop traversal. Defaults to None.

        """
        parent = self._parent
        while parent is not root and parent is not None:
            yield parent
            parent = parent._parent

    def find(self, name, regex=False):
        """ Find the first object in the subtree with the given name.

        This method will traverse the tree of objects, breadth first,
        from this object downward, looking for an object with the given
        name. The first object with the given name is returned, or None
        if no object is found with the given name.

        Parameters
        ----------
        name : string
            The name of the object for which to search.

        regex : bool, optional
            Whether the given name is a regex string which should be
            matched against the names of children instead of tested
            for equality. Defaults to False.

        Returns
        -------
        result : Object or None
            The first object found with the given name, or None if no
            object is found with the given name.

        """
        if regex:
            rgx = re.compile(name)
            match = lambda n: bool(rgx.match(n))
        else:
            match = lambda n: n == name
        for obj in self.traverse():
            if match(obj.name):
                return obj

    def find_all(self, name, regex=False):
        """ Find all objects in the subtree with the given name.

        This method will traverse the tree of objects, breadth first,
        from this object downward, looking for a objects with the given
        name. All of the objects with the given name are returned as a
        list.

        Parameters
        ----------
        name : string
            The name of the objects for which to search.

        regex : bool, optional
            Whether the given name is a regex string which should be
            matched against the names of objects instead of testing
            for equality. Defaults to False.

        Returns
        -------
        result : list of Object
            The list of objects found with the given name, or an empty
            list if no objects are found with the given name.

        """
        if regex:
            rgx = re.compile(name)
            match = lambda n: bool(rgx.match(n))
        else:
            match = lambda n: n == name
        res = []
        push = res.append
        for obj in self.traverse():
            if match(obj.name):
                push(obj)
        return res

########NEW FILE########
__FILENAME__ = operators
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from contextlib import contextmanager
from types import FunctionType

from .byteplay import (
    Code, LOAD_NAME, LOAD_FAST, STORE_NAME, STORE_FAST, DELETE_NAME,
    DELETE_FAST
)
from .code_tracing import inject_tracing, inject_inversion
from .expression_engine import HandlerPair
from .standard_handlers import (
    StandardReadHandler, StandardWriteHandler, StandardTracedReadHandler,
    StandardInvertedWriteHandler
)


def optimize_locals(codelist):
    """ Optimize the codelist for fast locals access.

    All STORE_NAME opcodes will be replaced with STORE_FAST. Names
    which are stored and then loaded via LOAD_NAME are rewritten to
    LOAD_FAST and DELETE_NAME is rewritten to DELETE_FAST. This
    transformation is performed in-place.

    Parameters
    ----------
    codelist : list
        The list of byteplay code ops to modify.

    """
    fast_locals = set()
    for idx, (op, op_arg) in enumerate(codelist):
        if op == STORE_NAME:
            fast_locals.add(op_arg)
            codelist[idx] = (STORE_FAST, op_arg)
    for idx, (op, op_arg) in enumerate(codelist):
        if op == LOAD_NAME and op_arg in fast_locals:
            codelist[idx] = (LOAD_FAST, op_arg)
        elif op == DELETE_NAME and op_arg in fast_locals:
            codelist[idx] = (DELETE_FAST, op_arg)  # py2.6 list comps


def gen_simple(code, f_globals):
    """ Generate a simple function from a code object.

    Parameters
    ----------
    code : CodeType
        The code object created by the Enaml compiler.

    f_globals : dict
        The global scope for the returned function.

    Returns
    -------
    result : FunctionType
        A new function with optimized local variable access.

    """
    bp_code = Code.from_code(code)
    optimize_locals(bp_code.code)
    bp_code.newlocals = False
    new_code = bp_code.to_code()
    return FunctionType(new_code, f_globals)


def gen_tracer(code, f_globals):
    """ Generate a trace function from a code object.

    Parameters
    ----------
    code : CodeType
        The code object created by the Enaml compiler.

    f_globals : dict
        The global scope for the returned function.

    Returns
    -------
    result : FunctionType
        A new function with optimized local variable access
        and instrumentation for invoking a code tracer.

    """
    bp_code = Code.from_code(code)
    optimize_locals(bp_code.code)
    bp_code.code = inject_tracing(bp_code.code)
    bp_code.newlocals = False
    bp_code.args = ('_[tracer]',) + bp_code.args
    new_code = bp_code.to_code()
    return FunctionType(new_code, f_globals)


def gen_inverter(code, f_globals):
    """ Generate an inverter function from a code object.

    Parameters
    ----------
    code : CodeType
        The code object created by the Enaml compiler.

    f_globals : dict
        The global scope for the returned function.

    Returns
    -------
    result : FunctionType
        A new function with optimized local variable access
        and instrumentation for inverting the operation.

    """
    bp_code = Code.from_code(code)
    optimize_locals(bp_code.code)
    bp_code.code = inject_inversion(bp_code.code)
    bp_code.newlocals = False
    bp_code.args = ('_[inverter]', '_[value]') + bp_code.args
    new_code = bp_code.to_code()
    return FunctionType(new_code, f_globals)


def op_simple(code, scope_key, f_globals):
    """ The default Enaml operator function for the `=` operator.

    This operator generates a simple function with optimized local
    access and hooks it up to a StandardReadHandler. This operator
    does not support write semantics.

    Parameters
    ----------
    code : CodeType
        The code object created by the Enaml compiler.

    scope_key : object
        The block scope key created by the Enaml compiler.

    f_globals : dict
        The global scope for the for code execution.

    Returns
    -------
    result : HandlerPair
        A pair with the reader set to a StandardReadHandler.

    """
    func = gen_simple(code, f_globals)
    reader = StandardReadHandler(func=func, scope_key=scope_key)
    return HandlerPair(reader=reader)


def op_notify(code, scope_key, f_globals):
    """ The default Enaml operator function for the `::` operator.

    This operator generates a simple function with optimized local
    access and hooks it up to a StandardWriteHandler. This operator
    does not support read semantics.

    Parameters
    ----------
    code : CodeType
        The code object created by the Enaml compiler.

    scope_key : object
        The block scope key created by the Enaml compiler.

    f_globals : dict
        The global scope for the for code execution.

    Returns
    -------
    result : HandlerPair
        A pair with the writer set to a StandardWriteHandler.

    """
    func = gen_simple(code, f_globals)
    writer = StandardWriteHandler(func=func, scope_key=scope_key)
    return HandlerPair(writer=writer)


def op_subscribe(code, scope_key, f_globals):
    """ The default Enaml operator function for the `<<` operator.

    This operator generates a tracer function with optimized local
    access and hooks it up to a StandardTracedReadHandler. This
    operator does not support write semantics.

    Parameters
    ----------
    code : CodeType
        The code object created by the Enaml compiler.

    scope_key : object
        The block scope key created by the Enaml compiler.

    f_globals : dict
        The global scope for the for code execution.

    Returns
    -------
    result : HandlerPair
        A pair with the reader set to a StandardTracedReadHandler.

    """
    func = gen_tracer(code, f_globals)
    reader = StandardTracedReadHandler(func=func, scope_key=scope_key)
    return HandlerPair(reader=reader)


def op_update(code, scope_key, f_globals):
    """ The default Enaml operator function for the `>>` operator.

    This operator generates a inverter function with optimized local
    access and hooks it up to a StandardInvertedWriteHandler. This
    operator does not support read semantics.

    Parameters
    ----------
    code : CodeType
        The code object created by the Enaml compiler.

    scope_key : object
        The block scope key created by the Enaml compiler.

    f_globals : dict
        The global scope for the for code execution.

    Returns
    -------
    result : HandlerPair
        A pair with the writer set to a StandardInvertedWriteHandler.

    """
    func = gen_inverter(code, f_globals)
    writer = StandardInvertedWriteHandler(func=func, scope_key=scope_key)
    return HandlerPair(writer=writer)


def op_delegate(code, scope_key, f_globals):
    """ The default Enaml operator function for the `:=` operator.

    This operator combines the '<<' and the '>>' operators into a
    single operator. It supports both read and write semantics.

    Parameters
    ----------
    code : CodeType
        The code object created by the Enaml compiler.

    scope_key : object
        The block scope key created by the Enaml compiler.

    f_globals : dict
        The global scope for the for code execution.

    Returns
    -------
    result : HandlerPair
        A pair with the reader set to a StandardTracedReadHandler and
        the writer set to a StandardInvertedWriteHandler.

    """
    p1 = op_subscribe(code, scope_key, f_globals)
    p2 = op_update(code, scope_key, f_globals)
    return HandlerPair(reader=p1.reader, writer=p2.writer)


DEFAULT_OPERATORS = {
    '=': op_simple,
    '::': op_notify,
    '>>': op_update,
    '<<': op_subscribe,
    ':=': op_delegate,
}


#: The internal stack of operators pushed by the operator context.
__operator_stack = []


@contextmanager
def operator_context(ops, union=False):
    """ Push operators onto the stack for the duration of the context.

    Parameters
    ----------
    ops : dict
        The dictionary of operators to push onto the stack.

    union : bool, optional
        Whether or to union the operators with the existing operators
        on the top of the stack. The default is False.

    """
    if union:
        new = dict(__get_operators())
        new.update(ops)
        ops = new
    __operator_stack.append(ops)
    yield
    __operator_stack.pop()


def __get_default_operators():
    """ Set the default operators.

    This function is for internal use only and may disappear at any time.

    """
    return DEFAULT_OPERATORS


def __set_default_operators(ops):
    """ Set the default operators.

    This function is for internal use only and may disappear at any time.

    """
    global DEFAULT_OPERATORS
    DEFAULT_OPERATORS = ops


def __get_operators():
    """ An internal routine used to get the operators for a given class.

    Operators resolution is performed in the following order:

        - The operators on the top of the operators stack.
        - The default operators via __get_default_operators()

    This function may disappear at any time.

    """
    if __operator_stack:
        return __operator_stack[-1]
    return __get_default_operators()

########NEW FILE########
__FILENAME__ = parser
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import ast
import os

import ply.yacc as yacc

from . import enaml_ast
from .lexer import syntax_error, syntax_warning, EnamlLexer, ParsingError


#------------------------------------------------------------------------------
# Parser Setup
#------------------------------------------------------------------------------
# Lexer tokens which need to be exposed to the parser
tokens = EnamlLexer.tokens


#------------------------------------------------------------------------------
# Parsing Helpers
#------------------------------------------------------------------------------
# Ast Context Singletons
Store = ast.Store()
Load = ast.Load()
Del = ast.Del()


# The allowed ast node types for ast.Store contexts
context_allowed = set([
    ast.Attribute,
    ast.Subscript,
    ast.Name,
    ast.List,
    ast.Tuple,
])


# Python 2.6 compatibility. Transform set comprehension into set(generator)
try:
    SetComp = ast.SetComp
except AttributeError:
    def SetComp(elt, generators):
        gen = ast.GeneratorExp(elt=elt, generators=generators)
        call = ast.Call()
        call.func = ast.Name(id='set', ctx=Load)
        call.args = [gen]
        call.keywords = []
        call.starargs = None
        call.kwargs = None
        return call


# Python 2.6 compatibility. Transform dict comprehension into dict(generator)
try:
    DictComp = ast.DictComp
except AttributeError:
    def DictComp(key, value, generators):
        elt = ast.Tuple(elts=[key, value], ctx=Load)
        gen = ast.GeneratorExp(elt=elt, generators=generators)
        call = ast.Call()
        call.func = ast.Name(id='dict', ctx=Load)
        call.args = [gen]
        call.keywords = []
        call.starargs = None
        call.kwargs = None
        return call


# Python 2.6 compatibility. Transform set literal in set(list_literal)
try:
    Set = ast.Set
except AttributeError:
    def Set(elts):
        lst = ast.List(elts=elts, ctx=Load)
        call = ast.Call()
        call.func = ast.Name(id='set', ctx=Load)
        call.args = [lst]
        call.keywords = []
        call.starargs = None
        call.kwargs = None
        return call


# The disallowed ast node types for ast.Store contexts and
# the associated message tag for error reporting.
context_disallowed = {
    ast.Lambda: 'lambda',
    ast.Call: 'function call',
    ast.BoolOp: 'operator',
    ast.BinOp: 'operator',
    ast.UnaryOp: 'operator',
    ast.GeneratorExp: 'generator expression',
    ast.Yield: 'yield expression',
    ast.ListComp: 'list comprehension',
    SetComp: 'set comprehension',
    DictComp: 'dict comprehension',
    ast.Dict: 'literal',
    Set: 'literal',
    ast.Num: 'literal',
    ast.Str: 'literal',
    ast.Ellipsis: 'Ellipsis',
    ast.Compare: 'comparison',
    ast.IfExp: 'conditional expression',
}


# The node types allowed in aug assignment
aug_assign_allowed = set([
    ast.Name,
    ast.Attribute,
    ast.Subscript,
])


# A mapping of aug assignment operators to ast types
augassign_table = {
    '&=': ast.BitAnd(),
    '^=': ast.BitXor(),
    '//=': ast.FloorDiv(),
    '<<=': ast.LShift(),
    '-=': ast.Sub(),
    '%=': ast.Mod(),
    '+=': ast.Add(),
    '>>=': ast.RShift(),
    '/=': ast.Div(),
    '*=': ast.Mult(),
    '|=': ast.BitOr(),
    '**=': ast.Pow(),
}


class FakeToken(object):
    """ A fake token used to store the lexer before calling the
    syntax error functions.

    """
    def __init__(self, lexer, lineno):
        self.lexer = lexer
        self.lineno = lineno


def set_context(node, ctx, p):
    """ Recursively sets the context of the node to the given context
    which should be Store or Del. If the node is not one of the allowed
    types for the context, an erro is raised with an appropriate message.

    """
    # XXX passing the yacc production object to raise the error
    # message is a bit flakey and gets things wrong occasionally
    # when there are blank lines around the error. We can do better.
    items = None
    err_msg = ''
    node_type = type(node)
    if node_type in context_allowed:
        node.ctx = ctx
        if ctx == Store:
            if node_type == ast.Tuple:
                if len(node.elts) == 0:
                    err_msg = '()'
                else:
                    items = node.elts
            elif node_type == ast.List:
                items = node.elts
    elif node_type in context_disallowed:
        err_msg = context_disallowed[node_type]
    else:
        msg = 'unexpected expression in assignment %d (line %d)'
        raise SystemError(msg % (node_type.__name__, node.lineno))

    if err_msg:
        m = 'assign to' if ctx == Store else 'delete'
        msg = "can't %s %s" % (m, err_msg)
        tok = FakeToken(p.lexer.lexer, p.lexer.lexer.lineno - 1)
        syntax_error(msg, tok)

    if items is not None:
        for item in items:
            set_context(item, ctx, p)


def ast_for_testlist(testlist):
    """ If the testlist is a list, returns an ast.Tuple with a Load
    context, otherwise returns the orginal node.

    """
    if isinstance(testlist, list):
        value = ast.Tuple()
        value.elts = testlist
        value.ctx = Load
    else:
        value = testlist
    return value


def ast_for_dotted_name(dotted_name):
    parts = dotted_name.split('.')
    name = ast.Name(id=parts.pop(0), ctx=Load)
    res = name
    for part in parts:
        attr = ast.Attribute()
        attr.value = res
        attr.attr = part
        attr.ctx = Load
        res = attr
    return res


class CommaSeparatedList(object):
    """ A parsing helper to delineate a comma separated list.

    """
    def __init__(self, values=None):
        self.values = values or []


class GeneratorInfo(object):
    """ A parsing helper to delineate a generator body.

    """
    def __init__(self, elt=None, generators=None):
        self.elt = elt
        self.generators = generators or []


class Arguments(object):
    """ A parsing helper object to delineate call arguments.

    """
    def __init__(self, args=None, keywords=None, starargs=None, kwargs=None):
        self.args = args or []
        self.keywords = keywords or []
        self.starargs = starargs
        self.kwargs = kwargs


#==============================================================================
# Begin Parsing Rules
#==============================================================================

#------------------------------------------------------------------------------
# Enaml Module
#------------------------------------------------------------------------------
# These special rules to handle the variations of newline and endmarkers
# are because of the various lexer states that deal with python blocks
# and enaml code, as well as completely empty files.
def p_enaml1(p):
    ''' enaml : enaml_module NEWLINE ENDMARKER
              | enaml_module ENDMARKER '''
    p[0] = p[1]


def p_enaml2(p):
    ''' enaml : NEWLINE ENDMARKER
              | ENDMARKER '''
    p[0] = enaml_ast.Module()


def p_enaml_module(p):
    ''' enaml_module : enaml_module_body '''
    body = []
    stmts = []
    for item in p[1]:
        if isinstance(item, (enaml_ast.EnamlDef, enaml_ast.Template)):
            if stmts:
                mod = ast.Module(body=stmts)
                python = enaml_ast.PythonModule(ast=mod, lineno=stmts[0].lineno)
                body.append(python)
                stmts = []
            body.append(item)
        else:
            stmts.append(item)
    if stmts:
        mod = ast.Module(body=stmts)
        python = enaml_ast.PythonModule(ast=mod, lineno=stmts[0].lineno)
        body.append(python)
    p[0] = enaml_ast.Module(body=body)


def p_enaml_module_body1(p):
    ''' enaml_module_body : enaml_module_body enaml_module_item '''
    items = p[2]  # a stmt can be a list
    if not isinstance(items, list):
        items = [items]
    p[0] = p[1] + items


def p_enaml_module_body2(p):
    ''' enaml_module_body : enaml_module_item '''
    items = p[1]  # a stmt can be a list
    if not isinstance(items, list):
        items = [items]
    p[0] = items


def p_enaml_module_item(p):
    ''' enaml_module_item : stmt
                          | enamldef
                          | template '''
    p[0] = p[1]


#------------------------------------------------------------------------------
# EnamlDef
#------------------------------------------------------------------------------
def _validate_enamldef(node, lexer):
    """ Validate the correctness of names in an enamldef definition.

    This function ensures that identifiers do not shadow one another.

    """
    ident_names = set()

    def check_id(name, node):
        if name in ident_names:
            msg = "redeclaration of identifier '%s'"
            msg += " (this will be an error in Enaml version 1.0)"
            syntax_warning(msg % name, FakeToken(lexer, node.lineno))
        ident_names.add(name)

    # validate the identifiers
    ChildDef = enaml_ast.ChildDef
    TemplateInst = enaml_ast.TemplateInst
    stack = list(reversed(node.body))
    while stack:
        node = stack.pop()
        if isinstance(node, ChildDef):
            if node.identifier:
                check_id(node.identifier, node)
            stack.extend(reversed(node.body))
        elif isinstance(node, TemplateInst):
            idents = node.identifiers
            if idents is not None:
                for name in idents.names:
                    check_id(name, idents)
                if idents.starname:
                    check_id(idents.starname, idents)


def p_enamldef1(p):
    ''' enamldef : enamldef_impl '''
    p[0] = p[1]


def p_enamldef2(p):
    ''' enamldef : pragmas enamldef_impl '''
    node = p[2]
    node.pragmas = p[1]
    p[0] = node


def p_enamldef_impl1(p):
    ''' enamldef_impl : ENAMLDEF NAME LPAR NAME RPAR COLON enamldef_suite '''
    doc, body = p[7]
    enamldef = enaml_ast.EnamlDef(
        typename=p[2], base=p[4], docstring=doc, body=body, lineno=p.lineno(1)
    )
    _validate_enamldef(enamldef, p.lexer.lexer)
    p[0] = enamldef


def p_enamldef_impl2(p):
    ''' enamldef_impl : ENAMLDEF NAME LPAR NAME RPAR COLON enamldef_simple_item '''
    body = filter(None, [p[7]])
    enamldef = enaml_ast.EnamlDef(
        typename=p[2], base=p[4], body=body, lineno=p.lineno(1)
    )
    _validate_enamldef(enamldef, p.lexer.lexer)
    p[0] = enamldef


def p_enamldef_impl3(p):
    ''' enamldef_impl : ENAMLDEF NAME LPAR NAME RPAR COLON NAME COLON enamldef_suite '''
    doc, body = p[9]
    enamldef = enaml_ast.EnamlDef(
        typename=p[2], base=p[4], identifier=p[7], docstring=doc, body=body,
        lineno=p.lineno(1)
    )
    _validate_enamldef(enamldef, p.lexer.lexer)
    p[0] = enamldef


def p_enamldef_impl4(p):
    ''' enamldef_impl : ENAMLDEF NAME LPAR NAME RPAR COLON NAME COLON enamldef_simple_item '''
    body = filter(None, [p[9]])
    enamldef = enaml_ast.EnamlDef(
        typename=p[2], base=p[4], identifier=p[7], body=body, lineno=p.lineno(1)
    )
    _validate_enamldef(enamldef, p.lexer.lexer)
    p[0] = enamldef


def p_enamldef_suite1(p):
    ''' enamldef_suite : NEWLINE INDENT enamldef_suite_items DEDENT '''
    # Filter out any pass statements
    items = filter(None, p[3])
    p[0] = ('', items)


def p_enamldef_suite2(p):
    ''' enamldef_suite : NEWLINE INDENT STRING NEWLINE enamldef_suite_items DEDENT '''
    # Filter out any pass statements
    items = filter(None, p[5])
    p[0] = (p[3], items)


def p_enamldef_suite_items1(p):
    ''' enamldef_suite_items : enamldef_suite_item '''
    p[0] = [p[1]]


def p_enamldef_suite_items2(p):
    ''' enamldef_suite_items : enamldef_suite_items enamldef_suite_item '''
    p[0] = p[1] + [p[2]]


def p_enamldef_suite_item(p):
    ''' enamldef_suite_item : enamldef_simple_item
                            | decl_funcdef
                            | child_def
                            | template_inst '''
    p[0] = p[1]


def p_enamldef_simple_item1(p):
    ''' enamldef_simple_item : binding
                             | ex_binding
                             | alias_expr
                             | storage_expr '''
    p[0] = p[1]


def p_enamldef_simple_item2(p):
    ''' enamldef_simple_item : PASS NEWLINE '''
    p[0] = None


#------------------------------------------------------------------------------
# Pragmas
#------------------------------------------------------------------------------
def p_pragmas1(p):
    ''' pragmas : pragma pragmas '''
    p[0] = [p[1]] + p[2]


def p_pragmas2(p):
    ''' pragmas : pragma '''
    p[0] = [p[1]]


def p_pragma1(p):
    ''' pragma : PRAGMA NAME NEWLINE
               | PRAGMA NAME LPAR RPAR NEWLINE '''
    node = enaml_ast.Pragma()
    node.lineno = p.lineno(1)
    node.command = p[2]
    p[0] = node


def p_pragma2(p):
    ''' pragma : PRAGMA NAME LPAR pragma_args RPAR NEWLINE '''
    node = enaml_ast.Pragma()
    node.lineno = p.lineno(1)
    node.command = p[2]
    node.arguments = p[4]
    p[0] = node


def p_pragma_args1(p):
    ''' pragma_args : pragma_arg COMMA pragma_args '''
    p[0] = [p[1]] + p[3]


def p_pragma_args2(p):
    ''' pragma_args : pragma_arg '''
    p[0] = [p[1]]


def p_pragma_arg(p):
    ''' pragma_arg : NAME '''
    p[0] = enaml_ast.PragmaArg(kind='token', value=p[1])


def p_pragma_arg2(p):
    ''' pragma_arg : NUMBER '''
    p[0] = enaml_ast.PragmaArg(kind='number', value=p[1])


def p_pragma_arg3(p):
    ''' pragma_arg : STRING '''
    p[0] = enaml_ast.PragmaArg(kind='string', value=p[1])


#------------------------------------------------------------------------------
# AliasExpr
#------------------------------------------------------------------------------
def p_alias_expr1(p):
    ''' alias_expr : ALIAS NAME NEWLINE '''
    node = enaml_ast.AliasExpr()
    node.lineno = p.lineno(1)
    node.name = p[2]
    node.target = p[2]
    p[0] = node


def p_alias_expr2(p):
    ''' alias_expr : ALIAS NAME COLON NAME NEWLINE '''
    node = enaml_ast.AliasExpr()
    node.lineno = p.lineno(1)
    node.name = p[2]
    node.target = p[4]
    p[0] = node


def p_alias_expr3(p):
    ''' alias_expr : ALIAS NAME COLON NAME ex_dotted_names NEWLINE '''
    node = enaml_ast.AliasExpr()
    node.lineno = p.lineno(1)
    node.name = p[2]
    node.target = p[4]
    node.chain = tuple(p[5])
    p[0] = node


#------------------------------------------------------------------------------
# ConstExpr
#------------------------------------------------------------------------------
def p_const_expr1(p):
    ''' const_expr : CONST NAME EQUAL test NEWLINE '''
    lineno = p.lineno(1)
    body = p[4]
    body.lineno = lineno
    ast.fix_missing_locations(body)
    expr = ast.Expression(body=body)
    python = enaml_ast.PythonExpression(ast=expr, lineno=lineno)
    node = enaml_ast.ConstExpr()
    node.lineno = lineno
    node.name = p[2]
    node.expr = python
    p[0] = node


def p_const_expr2(p):
    ''' const_expr : CONST NAME COLON NAME EQUAL test NEWLINE '''
    lineno = p.lineno(1)
    body = p[6]
    body.lineno = lineno
    ast.fix_missing_locations(body)
    expr = ast.Expression(body=body)
    python = enaml_ast.PythonExpression(ast=expr, lineno=lineno)
    node = enaml_ast.ConstExpr()
    node.lineno = lineno
    node.name = p[2]
    node.typename = p[4]
    node.expr = python
    p[0] = node


#------------------------------------------------------------------------------
# StorageExpr
#------------------------------------------------------------------------------
def _validate_storage_expr(kind, lineno, lexer):
    if kind not in ('attr', 'event'):
        syntax_error('invalid syntax', FakeToken(lexer, lineno))


def p_storage_expr1(p):
    ''' storage_expr : NAME NAME NEWLINE '''
    kind = p[1]
    lineno = p.lineno(1)
    _validate_storage_expr(kind, lineno, p.lexer.lexer)
    node = enaml_ast.StorageExpr()
    node.lineno = lineno
    node.kind = kind
    node.name = p[2]
    p[0] = node


def p_storage_expr2(p):
    ''' storage_expr : NAME NAME COLON NAME NEWLINE '''
    kind = p[1]
    lineno = p.lineno(1)
    _validate_storage_expr(kind, lineno, p.lexer.lexer)
    node = enaml_ast.StorageExpr()
    node.lineno = lineno
    node.kind = kind
    node.name = p[2]
    node.typename = p[4]
    p[0] = node


def p_storage_expr3(p):
    ''' storage_expr : NAME NAME operator_expr '''
    kind = p[1]
    lineno = p.lineno(1)
    _validate_storage_expr(kind, lineno, p.lexer.lexer)
    node = enaml_ast.StorageExpr()
    node.lineno = lineno
    node.kind = kind
    node.name = p[2]
    node.expr = p[3]
    p[0] = node


def p_storage_expr4(p):
    ''' storage_expr : NAME NAME COLON NAME operator_expr '''
    kind = p[1]
    lineno = p.lineno(1)
    _validate_storage_expr(kind, lineno, p.lexer.lexer)
    node = enaml_ast.StorageExpr()
    node.lineno = lineno
    node.kind = kind
    node.name = p[2]
    node.typename = p[4]
    node.expr = p[5]
    p[0] = node


#------------------------------------------------------------------------------
# ChildDef
#------------------------------------------------------------------------------
def p_child_def1(p):
    ''' child_def : NAME COLON child_def_suite '''
    child_def = enaml_ast.ChildDef(
        typename=p[1], body=p[3], lineno=p.lineno(1)
    )
    p[0] = child_def


def p_child_def2(p):
    ''' child_def : NAME COLON child_def_simple_item '''
    body = filter(None, [p[3]])
    p[0] = enaml_ast.ChildDef(typename=p[1], body=body, lineno=p.lineno(1))


def p_child_def3(p):
    ''' child_def : NAME COLON NAME COLON child_def_suite '''
    child_def = enaml_ast.ChildDef(
        typename=p[1], identifier=p[3], body=p[5], lineno=p.lineno(1)
    )
    p[0] = child_def


def p_child_def4(p):
    ''' child_def : NAME COLON NAME COLON child_def_simple_item  '''
    body = filter(None, [p[5]])
    child_def = enaml_ast.ChildDef(
        typename=p[1], identifier=p[3], body=body, lineno=p.lineno(1)
    )
    p[0] = child_def


def p_child_def_suite(p):
    ''' child_def_suite : NEWLINE INDENT child_def_suite_items DEDENT '''
    # Filter out any pass statements
    items = filter(None, p[3])
    p[0] = items


def p_child_def_suite_items1(p):
    ''' child_def_suite_items : child_def_suite_item '''
    p[0] = [p[1]]


def p_child_def_suite_items2(p):
    ''' child_def_suite_items : child_def_suite_items child_def_suite_item '''
    p[0] = p[1] + [p[2]]


def p_child_def_suite_item(p):
    ''' child_def_suite_item : child_def_simple_item
                             | decl_funcdef
                             | child_def
                             | template_inst '''
    p[0] = p[1]


def p_child_def_simple_item1(p):
    ''' child_def_simple_item : binding
                              | ex_binding
                              | alias_expr
                              | storage_expr '''
    p[0] = p[1]


def p_child_def_simple_item2(p):
    ''' child_def_simple_item : PASS NEWLINE '''
    p[0] = None


#------------------------------------------------------------------------------
# Binding
#------------------------------------------------------------------------------
def p_binding(p):
    ''' binding : NAME operator_expr '''
    p[0] = enaml_ast.Binding(name=p[1], expr=p[2], lineno=p.lineno(1))


#------------------------------------------------------------------------------
# ExBinding
#------------------------------------------------------------------------------
def p_ex_binding(p):
    ''' ex_binding : NAME ex_dotted_names operator_expr '''
    node = enaml_ast.ExBinding()
    node.lineno = p.lineno(1)
    node.chain = (p[1],) + tuple(p[2])
    node.expr = p[3]
    p[0] = node


def p_ex_dotted_names1(p):
    ''' ex_dotted_names : DOT NAME '''
    p[0] = [p[2]]


def p_ex_dotted_names2(p):
    ''' ex_dotted_names : DOT NAME ex_dotted_names '''
    p[0] = [p[2]] + p[3]


#------------------------------------------------------------------------------
# OperatorExpr
#------------------------------------------------------------------------------
def p_operator_expr1(p):
    ''' operator_expr : EQUAL test NEWLINE
                      | LEFTSHIFT test NEWLINE '''
    lineno = p.lineno(1)
    body = p[2]
    body.lineno = lineno
    ast.fix_missing_locations(body)
    expr = ast.Expression(body=body)
    python = enaml_ast.PythonExpression(ast=expr, lineno=lineno)
    p[0] = enaml_ast.OperatorExpr(operator=p[1], value=python, lineno=lineno)


# The nodes which can be inverted to form an assignable expression.
_INVERTABLE = (ast.Name, ast.Attribute, ast.Call, ast.Subscript)


def p_operator_expr2(p):
    ''' operator_expr : COLONEQUAL test NEWLINE
                      | RIGHTSHIFT test NEWLINE '''
    lineno = p.lineno(1)
    body = p[2]
    if not isinstance(body, _INVERTABLE):
        msg = "can't assign to expression of this form"
        syntax_error(msg, FakeToken(p.lexer.lexer, lineno))
    body.lineno = lineno
    ast.fix_missing_locations(body)
    expr = ast.Expression(body=body)
    python = enaml_ast.PythonExpression(ast=expr, lineno=lineno)
    p[0] = enaml_ast.OperatorExpr(operator=p[1], value=python, lineno=lineno)


# The disallowed ast types on the rhs of a :: operator
_NOTIFICATION_DISALLOWED = {
    ast.FunctionDef: 'function definition',
    ast.ClassDef: 'class definition',
    ast.Yield: 'yield statement',
    ast.Return: 'return statement',
}


def p_operator_expr3(p):
    ''' operator_expr : DOUBLECOLON suite '''
    lineno = p.lineno(1)
    mod = ast.Module()
    mod.body = p[2]
    for item in ast.walk(mod):
        if type(item) in _NOTIFICATION_DISALLOWED:
            msg = '%s not allowed in a notification block'
            msg = msg % _NOTIFICATION_DISALLOWED[type(item)]
            syntax_error(msg, FakeToken(p.lexer.lexer, item.lineno))
    python = enaml_ast.PythonModule(ast=mod, lineno=lineno)
    p[0] = enaml_ast.OperatorExpr(operator=p[1], value=python, lineno=lineno)


#------------------------------------------------------------------------------
# Declarative Function Definition
#------------------------------------------------------------------------------
# The disallowed ast types in the body of a declarative function
_DECL_FUNCDEF_DISALLOWED = {
    ast.FunctionDef: 'function definition',
    ast.ClassDef: 'class definition',
    ast.Yield: 'yield statement',
}


def _validate_decl_funcdef(funcdef, lexer):
    walker = ast.walk(funcdef)
    walker.next()  # discard toplevel funcdef
    for item in walker:
        if type(item) in _DECL_FUNCDEF_DISALLOWED:
            msg = '%s not allowed in a declarative function block'
            msg = msg % _DECL_FUNCDEF_DISALLOWED[type(item)]
            syntax_error(msg, FakeToken(lexer, item.lineno))


def p_decl_funcdef1(p):
    ''' decl_funcdef : NAME NAME parameters COLON suite '''
    lineno = p.lineno(1)
    if p[1] != 'func':
        syntax_error('invalid syntax', FakeToken(p.lexer.lexer, lineno))
    funcdef = ast.FunctionDef()
    funcdef.name = p[2]
    funcdef.args = p[3]
    funcdef.body = p[5]
    funcdef.decorator_list = []
    funcdef.lineno = lineno
    ast.fix_missing_locations(funcdef)
    _validate_decl_funcdef(funcdef, p.lexer.lexer)
    decl_funcdef = enaml_ast.FuncDef()
    decl_funcdef.lineno = lineno
    decl_funcdef.funcdef = funcdef
    decl_funcdef.is_override = False
    p[0] = decl_funcdef


def p_decl_funcdef2(p):
    ''' decl_funcdef : NAME RIGHTARROW parameters COLON suite '''
    lineno = p.lineno(1)
    funcdef = ast.FunctionDef()
    funcdef.name = p[1]
    funcdef.args = p[3]
    funcdef.body = p[5]
    funcdef.decorator_list = []
    funcdef.lineno = lineno
    ast.fix_missing_locations(funcdef)
    _validate_decl_funcdef(funcdef, p.lexer.lexer)
    decl_funcdef = enaml_ast.FuncDef()
    decl_funcdef.lineno = lineno
    decl_funcdef.funcdef = funcdef
    decl_funcdef.is_override = True
    p[0] = decl_funcdef


#------------------------------------------------------------------------------
# Template
#------------------------------------------------------------------------------
def _validate_template(node, lexer):
    """ Validate the correctness of names in a template definitions.

    This function ensures that parameters, const expressions, and
    identifiers do not shadow one another.

    """
    param_names = set()
    const_names = set()
    ident_names = set()

    def check_const(name, node):
        msg = None
        if name in param_names:
            msg = "declaration of 'const %s' shadows a parameter"
        elif name in const_names:
            msg = "redeclaration of 'const %s'"
        if msg is not None:
            syntax_error(msg % name, FakeToken(lexer, node.lineno))
        const_names.add(name)

    def check_id(name, node):
        msg = None
        if name in param_names:
            msg = "identifier '%s' shadows a parameter"
        elif name in const_names:
            msg = "identifier '%s' shadows a const expression"
        elif name in ident_names:
            msg = "redeclaration of identifier '%s'"
        if msg is not None:
            syntax_error(msg % name, FakeToken(lexer, node.lineno))
        ident_names.add(name)

    # collect the parameter names
    params = node.parameters
    for param in params.positional:
        param_names.add(param.name)
    for param in params.keywords:
        param_names.add(param.name)
    if params.starparam:
        param_names.add(params.starparam)

    # validate the const expressions
    ConstExpr = enaml_ast.ConstExpr
    for item in node.body:
        if isinstance(item, ConstExpr):
            check_const(item.name, item)

    # validate the identifiers
    ChildDef = enaml_ast.ChildDef
    TemplateInst = enaml_ast.TemplateInst
    stack = list(reversed(node.body))
    while stack:
        node = stack.pop()
        if isinstance(node, ChildDef):
            if node.identifier:
                check_id(node.identifier, node)
            stack.extend(reversed(node.body))
        elif isinstance(node, TemplateInst):
            idents = node.identifiers
            if idents is not None:
                for name in idents.names:
                    check_id(name, idents)
                if idents.starname:
                    check_id(idents.starname, idents)


def p_template1(p):
    ''' template : template_impl '''
    p[0] = p[1]


def p_template2(p):
    ''' template : pragmas template_impl '''
    node = p[2]
    node.pragmas = p[1]
    p[0] = node


def p_template_impl1(p):
    ''' template_impl : TEMPLATE NAME template_params COLON template_suite '''
    node = enaml_ast.Template()
    node.lineno = p.lineno(1)
    node.name = p[2]
    node.parameters = p[3]
    node.body = p[5]
    _validate_template(node, p.lexer.lexer)
    p[0] = node


def p_template_impl2(p):
    ''' template_impl : TEMPLATE NAME template_params COLON template_simple_item '''
    node = enaml_ast.Template()
    node.lineno = p.lineno(1)
    node.name = p[2]
    node.parameters = p[3]
    node.body = filter(None, [p[5]])
    _validate_template(node, p.lexer.lexer)
    p[0] = node


def p_template_impl3(p):
    ''' template_impl : TEMPLATE NAME template_params COLON template_doc_suite '''
    doc, body = p[5]
    node = enaml_ast.Template()
    node.lineno = p.lineno(1)
    node.name = p[2]
    node.parameters = p[3]
    node.docstring = doc
    node.body = body
    _validate_template(node, p.lexer.lexer)
    p[0] = node


def p_template_suite(p):
    ''' template_suite : NEWLINE INDENT template_suite_items DEDENT '''
    # Filter out any pass statements
    p[0] = filter(None, p[3])


def p_template_doc_suite(p):
    ''' template_doc_suite : NEWLINE INDENT STRING NEWLINE template_suite_items DEDENT '''
    # Filter out any pass statements
    p[0] = (p[3], filter(None, p[5]))


def p_template_suite_items1(p):
    ''' template_suite_items : template_suite_item '''
    p[0] = [p[1]]


def p_template_suite_items2(p):
    ''' template_suite_items : template_suite_items template_suite_item '''
    p[0] = p[1] + [p[2]]


def p_template_suite_item(p):
    ''' template_suite_item : template_simple_item
                            | child_def
                            | template_inst '''
    p[0] = p[1]


def p_template_simple_item1(p):
    ''' template_simple_item : const_expr '''
    p[0] = p[1]


def p_template_simple_item2(p):
    ''' template_simple_item : PASS NEWLINE '''
    p[0] = None


def p_template_params1(p):
    ''' template_params : LPAR RPAR '''
    node = enaml_ast.TemplateParameters()
    node.lineno = p.lineno(1)
    p[0] = node


def _validate_template_paramlist(paramlist, starparam, lexer):
    keywords = []
    positional = []
    seen_params = set([starparam])
    for param in paramlist:
        if param.name in seen_params:
            msg = "duplicate argument '%s' in template definition"
            syntax_error(msg % param.name, FakeToken(lexer, param.lineno))
        seen_params.add(param.name)
        if isinstance(param, enaml_ast.KeywordParameter):
            keywords.append(param)
        elif keywords:
            msg = "non-default argument follows default argument"
            syntax_error(msg, FakeToken(lexer, param.lineno))
        else:
            positional.append(param)
    return positional, keywords


def p_template_params2(p):
    ''' template_params : LPAR template_paramlist RPAR '''
    params, starparam = p[2]
    pos, kwds = _validate_template_paramlist(params, starparam, p.lexer.lexer)
    node = enaml_ast.TemplateParameters()
    node.positional = pos
    node.keywords = kwds
    node.starparam = starparam
    p[0] = node


def p_template_paramlist1(p):
    ''' template_paramlist : template_param '''
    p[0] = ([p[1]], '')


def p_template_paramlist2(p):
    ''' template_paramlist : STAR NAME '''
    p[0] = ([], p[2])


def p_template_paramlist3(p):
    ''' template_paramlist : template_param template_paramlist_list '''
    p[0] = ([p[1]] + p[2], '')


def p_template_paramlist4(p):
    ''' template_paramlist : template_param COMMA STAR NAME '''
    p[0] = ([p[1]], p[4])


def p_template_paramlist5(p):
    ''' template_paramlist : template_param template_paramlist_list COMMA STAR NAME '''
    p[0] = ([p[1]] + p[2], p[5])


def p_template_paramlist_list1(p):
    ''' template_paramlist_list : COMMA template_param '''
    p[0] = [p[2]]


def p_template_paramlist_list2(p):
    ''' template_paramlist_list : template_paramlist_list COMMA template_param '''
    p[0] = p[1] + [p[3]]


def p_template_param1(p):
    ''' template_param : NAME '''
    node = enaml_ast.PositionalParameter()
    node.lineno = p.lineno(1)
    node.name = p[1]
    p[0] = node


def p_template_param2(p):
    ''' template_param : NAME COLON test '''
    lineno = p.lineno(1)
    node = enaml_ast.PositionalParameter()
    node.lineno = lineno
    node.name = p[1]
    body = p[3]
    body.lineno = lineno
    ast.fix_missing_locations(body)
    expr = ast.Expression(body=body)
    python = enaml_ast.PythonExpression(ast=expr, lineno=lineno)
    node.specialization = python
    p[0] = node


def p_template_param3(p):
    ''' template_param : NAME EQUAL test '''
    lineno = p.lineno(1)
    node = enaml_ast.KeywordParameter()
    node.lineno = lineno
    node.name = p[1]
    body = p[3]
    body.lineno = lineno
    ast.fix_missing_locations(body)
    expr = ast.Expression(body=body)
    python = enaml_ast.PythonExpression(ast=expr, lineno=lineno)
    node.default = python
    p[0] = node


#------------------------------------------------------------------------------
# Template Instantiation
#------------------------------------------------------------------------------
def _validate_template_inst(node, lexer):
    """ Validate a template instantiation.

    This function ensures that the bindings on the instantiation refer
    to declared identifiers on the instantiation.

    """
    names = set()
    if node.identifiers:
        names.update(node.identifiers.names)
    for binding in node.body:
        if binding.name not in names:
            msg = "'%s' is not a valid template id reference"
            syntax_error(msg % binding.name, FakeToken(lexer, binding.lineno))


def p_template_inst1(p):
    ''' template_inst : template_inst_impl '''
    p[0] = p[1]


def p_template_inst2(p):
    ''' template_inst : pragmas template_inst_impl '''
    node = p[2]
    node.pragmas = p[1]
    p[0] = node


def p_template_inst_impl1(p):
    ''' template_inst_impl : NAME template_args COLON template_inst_suite_item '''
    node = enaml_ast.TemplateInst()
    node.lineno = p.lineno(1)
    node.name = p[1]
    node.arguments = p[2]
    node.body = filter(None, [p[4]])
    _validate_template_inst(node, p.lexer.lexer)
    p[0] = node


def p_template_inst_impl2(p):
    ''' template_inst_impl : NAME template_args COLON template_ids COLON template_inst_suite_item '''
    node = enaml_ast.TemplateInst()
    node.lineno = p.lineno(1)
    node.name = p[1]
    node.arguments = p[2]
    node.identifiers = p[4]
    node.body = filter(None, [p[6]])
    _validate_template_inst(node, p.lexer.lexer)
    p[0] = node


def p_template_inst_impl3(p):
    ''' template_inst_impl : NAME template_args COLON template_inst_suite '''
    node = enaml_ast.TemplateInst()
    node.lineno = p.lineno(1)
    node.name = p[1]
    node.arguments = p[2]
    node.body = filter(None, p[4])
    _validate_template_inst(node, p.lexer.lexer)
    p[0] = node


def p_template_inst_impl4(p):
    ''' template_inst_impl : NAME template_args COLON template_ids COLON template_inst_suite '''
    node = enaml_ast.TemplateInst()
    node.lineno = p.lineno(1)
    node.name = p[1]
    node.arguments = p[2]
    node.identifiers = p[4]
    node.body = filter(None, p[6])
    _validate_template_inst(node, p.lexer.lexer)
    p[0] = node


def p_template_args1(p):
    ''' template_args : LPAR RPAR '''
    node = enaml_ast.TemplateArguments()
    node.lineno = p.lineno(1)
    p[0] = node


def _fixup_template_args(node):
    lineno = node.lineno
    for arg in node.args:
        if arg.lineno == -1:
            arg.lineno = lineno
        else:
            lineno = arg.lineno
        arg.ast.body.lineno = lineno
        ast.fix_missing_locations(arg.ast.body)


def p_template_args2(p):
    ''' template_args : LPAR template_arglist RPAR '''
    args, stararg = p[2]
    node = enaml_ast.TemplateArguments()
    node.lineno = p.lineno(1)
    node.args = args
    node.stararg = stararg
    _fixup_template_args(node)
    p[0] = node


def p_template_arglist1(p):
    ''' template_arglist : template_argument '''
    p[0] = ([p[1]], None)


def p_template_arglist2(p):
    ''' template_arglist : STAR test '''
    lineno = p.lineno(1)
    body = p[2]
    body.lineno = lineno
    ast.fix_missing_locations(body)
    expr = ast.Expression(body=body)
    node = enaml_ast.PythonExpression(ast=expr, lineno=lineno)
    p[0] = ([], node)


def p_template_arglist3(p):
    ''' template_arglist : template_argument template_arglist_list '''
    p[0] = ([p[1]] + p[2], None)


def p_template_arglist4(p):
    ''' template_arglist : template_argument COMMA STAR test '''
    lineno = p.lineno(3)
    body = p[4]
    body.lineno = lineno
    ast.fix_missing_locations(body)
    expr = ast.Expression(body=body)
    node = enaml_ast.PythonExpression(ast=expr, lineno=lineno)
    p[0] = ([p[1]], node)


def p_template_arglist5(p):
    ''' template_arglist : template_argument template_arglist_list COMMA STAR test '''
    lineno = p.lineno(4)
    body = p[5]
    body.lineno = lineno
    ast.fix_missing_locations(body)
    expr = ast.Expression(body=body)
    node = enaml_ast.PythonExpression(ast=expr, lineno=lineno)
    p[0] = ([p[1]] + p[2], node)


def p_template_arglist_list1(p):
    ''' template_arglist_list : COMMA template_argument '''
    arg = p[2]
    if arg.lineno == -1:
        arg.lineno = p.lineno(1)
    p[0] = [arg]


def p_template_arglist_list2(p):
    ''' template_arglist_list : template_arglist_list COMMA template_argument '''
    arg = p[3]
    if arg.lineno == -1:
        arg.lineno = p.lineno(2)
    p[0] = p[1] + [arg]


def p_template_argument1(p):
    ''' template_argument : test '''
    expr = ast.Expression(body=p[1])
    node = enaml_ast.PythonExpression(ast=expr)
    p[0] = node


def p_template_argument2(p):
    ''' template_argument : test comp_for '''
    expr = ast.GeneratorExp(elt=p[1], generators=p[2])
    node = enaml_ast.PythonExpression(ast=expr)
    p[0] = node


def p_template_ids1(p):
    ''' template_ids : NAME '''
    node = enaml_ast.TemplateIdentifiers()
    node.lineno = p.lineno(1)
    node.names = [p[1]]
    p[0] = node


def p_template_ids2(p):
    ''' template_ids : template_id_list NAME '''
    node = enaml_ast.TemplateIdentifiers()
    node.lineno = p.lineno(2)
    node.names = p[1] + [p[2]]
    p[0] = node


def p_template_ids3(p):
    ''' template_ids : STAR NAME '''
    node = enaml_ast.TemplateIdentifiers()
    node.lineno = p.lineno(1)
    node.starname = p[2]
    p[0] = node


def p_template_ids4(p):
    ''' template_ids : template_id_list STAR NAME '''
    node = enaml_ast.TemplateIdentifiers()
    node.lineno = p.lineno(2)
    node.names = p[1]
    node.starname = p[3]
    p[0] = node


def p_template_id_list1(p):
    ''' template_id_list : NAME COMMA '''
    p[0] = [p[1]]


def p_template_id_list2(p):
    ''' template_id_list : template_id_list NAME COMMA '''
    p[0] = p[1] + [p[2]]


def p_template_inst_suite(p):
    ''' template_inst_suite : NEWLINE INDENT template_inst_suite_items DEDENT '''
    p[0] = p[3]


def p_template_inst_suite_items1(p):
    ''' template_inst_suite_items : template_inst_suite_items template_inst_suite_item '''
    p[0] = p[1] + [p[2]]


def p_template_inst_suite_items2(p):
    ''' template_inst_suite_items : template_inst_suite_item '''
    p[0] = [p[1]]


def p_template_inst_suite_item1(p):
    ''' template_inst_suite_item : template_inst_binding '''
    p[0] = p[1]


def p_template_inst_suite_item2(p):
    ''' template_inst_suite_item : PASS NEWLINE '''
    p[0] = None


def p_template_inst_binding(p):
    ''' template_inst_binding : NAME ex_dotted_names operator_expr '''
    node = enaml_ast.TemplateInstBinding()
    node.lineno = p.lineno(1)
    node.name = p[1]
    node.chain = tuple(p[2])
    node.expr = p[3]
    p[0] = node


#------------------------------------------------------------------------------
# Python Grammar
#------------------------------------------------------------------------------
def p_suite1(p):
    ''' suite : simple_stmt '''
    # stmt may be a list of simple_stmt due to this piece of grammar:
    # simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE
    stmt = p[1]
    if isinstance(stmt, list):
        res = stmt
    else:
        res = [stmt]
    p[0] = res


def p_suite2(p):
    ''' suite : NEWLINE INDENT stmt_list DEDENT '''
    p[0] = p[3]


def p_stmt_list1(p):
    ''' stmt_list : stmt stmt_list '''
    # stmt may be a list of simple_stmt due to this piece of grammar:
    # simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE
    stmt = p[1]
    if isinstance(stmt, list):
        res = stmt + p[2]
    else:
        res = [stmt] + p[2]
    p[0] = res


def p_stmt_list2(p):
    ''' stmt_list : stmt '''
    # stmt may be a list of simple_stmt due to this piece of grammar:
    # simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE
    stmt = p[1]
    if isinstance(stmt, list):
        res = stmt
    else:
        res = [stmt]
    p[0] = res


def p_stmt(p):
    ''' stmt : simple_stmt
             | compound_stmt '''
    p[0] = p[1]


def p_simple_stmt1(p):
    ''' simple_stmt : small_stmt NEWLINE '''
    stmt = p[1]
    stmt.lineno = p.lineno(2)
    ast.fix_missing_locations(stmt)
    p[0] = stmt


def p_simple_stmt2(p):
    ''' simple_stmt : small_stmt_list NEWLINE '''
    lineno = p.lineno(2)
    stmts = p[1]
    for stmt in stmts:
        stmt.lineno = lineno
        ast.fix_missing_locations(stmt)
    p[0] = stmts


def p_small_stmt_list1(p):
    ''' small_stmt_list : small_stmt SEMI '''
    p[0] = [p[1]]


def p_small_stmt_list2(p):
    ''' small_stmt_list : small_stmt small_stmt_list_list '''
    p[0] = [p[1]] + p[2]


def p_small_stmt_list3(p):
    ''' small_stmt_list : small_stmt small_stmt_list_list SEMI '''
    p[0] = [p[1]] + p[2]


def p_small_stmt_list_list1(p):
    ''' small_stmt_list_list : SEMI small_stmt '''
    p[0] = [p[2]]


def p_small_stmt_list_list2(p):
    ''' small_stmt_list_list : small_stmt_list_list SEMI small_stmt '''
    p[0] = p[1] + [p[3]]


def p_small_stmt1(p):
    ''' small_stmt : expr_stmt
                   | print_stmt
                   | del_stmt
                   | pass_stmt
                   | flow_stmt
                   | import_stmt
                   | global_stmt
                   | exec_stmt
                   | assert_stmt '''
    p[0] = p[1]


def p_print_stmt1(p):
    ''' print_stmt : PRINT '''
    prnt = ast.Print()
    prnt.dest = None
    prnt.values = []
    prnt.nl = True
    p[0] = prnt


def p_print_stmt2(p):
    ''' print_stmt : PRINT test '''
    prnt = ast.Print()
    prnt.dest = None
    prnt.values = [p[2]]
    prnt.nl = True
    p[0] = prnt


def p_print_stmt3(p):
    ''' print_stmt : PRINT print_list '''
    prnt = ast.Print()
    all_values = p[2]
    good_values = [item for item in all_values if item is not None]
    if all_values[-1] is None:
        nl = False
    else:
        nl = True
    prnt.dest = None
    prnt.values = good_values
    prnt.nl = nl
    p[0] = prnt


def p_print_stmt4(p):
    ''' print_stmt : PRINT RIGHTSHIFT test '''
    prnt = ast.Print()
    prnt.dest = p[3]
    prnt.values = []
    prnt.nl = True
    p[0] = prnt


def p_print_stmt5(p):
    ''' print_stmt : PRINT RIGHTSHIFT test COMMA test '''
    prnt = ast.Print()
    prnt.dest = p[3]
    prnt.values = [p[5]]
    prnt.nl = True
    p[0] = prnt


def p_print_stmt6(p):
    ''' print_stmt : PRINT RIGHTSHIFT test COMMA print_list '''
    prnt = ast.Print()
    all_values = p[5]
    good_values = [item for item in all_values if item is not None]
    if all_values[-1] is None:
        nl = False
    else:
        nl = True
    prnt.dest = p[3]
    prnt.values = good_values
    prnt.nl = nl
    p[0] = prnt


def p_print_list1(p):
    ''' print_list : test COMMA '''
    p[0] = [p[1], None]


def p_print_list2(p):
    ''' print_list : test print_list_list '''
    p[0] = [p[1]] + p[2]


def p_print_list3(p):
    ''' print_list : test print_list_list COMMA '''
    p[0] = [p[1]] + p[2] + [None]


def p_print_list_list1(p):
    ''' print_list_list : COMMA test '''
    p[0] = [p[2]]


def p_print_list_list2(p):
    ''' print_list_list : print_list_list COMMA test '''
    p[0] = p[1] + [p[3]]


def p_del_stmt(p):
    ''' del_stmt : DEL exprlist '''
    exprlist = p[2]
    set_context(exprlist, Del, p)
    del_stmt = ast.Delete()
    del_stmt.targets = [exprlist]
    p[0] = del_stmt


def p_pass_stmt(p):
    ''' pass_stmt : PASS '''
    pass_stmt = ast.Pass()
    pass_stmt.lineno = p.lineno(1)
    p[0] = pass_stmt


def p_flow_stmt(p):
    ''' flow_stmt : break_stmt
                  | continue_stmt
                  | return_stmt
                  | raise_stmt
                  | yield_stmt '''
    p[0] = p[1]


def p_break_stmt(p):
    ''' break_stmt : BREAK '''
    break_stmt = ast.Break()
    break_stmt.lineno = p.lineno(1)
    p[0] = break_stmt


def p_continue_stmt(p):
    ''' continue_stmt : CONTINUE '''
    continue_stmt = ast.Continue()
    continue_stmt.lineno = p.lineno(1)
    p[0] = continue_stmt


def p_return_stmt1(p):
    ''' return_stmt : RETURN '''
    ret = ast.Return()
    ret.value = None
    p[0] = ret


def p_return_stmt2(p):
    ''' return_stmt : RETURN testlist '''
    value = ast_for_testlist(p[2])
    ret = ast.Return()
    ret.value = value
    p[0] = ret


def p_raise_stmt1(p):
    ''' raise_stmt : RAISE '''
    raise_stmt = ast.Raise()
    raise_stmt.type = None
    raise_stmt.inst = None
    raise_stmt.tback = None
    p[0] = raise_stmt


def p_raise_stmt2(p):
    ''' raise_stmt : RAISE test '''
    raise_stmt = ast.Raise()
    raise_stmt.type = p[2]
    raise_stmt.inst = None
    raise_stmt.tback = None
    p[0] = raise_stmt


def p_raise_stmt3(p):
    ''' raise_stmt : RAISE test COMMA test '''
    raise_stmt = ast.Raise()
    raise_stmt.type = p[2]
    raise_stmt.inst = p[4]
    raise_stmt.tback = None
    p[0] = raise_stmt


def p_raise_stmt4(p):
    ''' raise_stmt : RAISE test COMMA test COMMA test '''
    raise_stmt = ast.Raise()
    raise_stmt.type = p[2]
    raise_stmt.inst = p[4]
    raise_stmt.tback = p[6]
    p[0] = raise_stmt


def p_yield_stmt(p):
    ''' yield_stmt : yield_expr '''
    p[0] = ast.Expr(value=p[1])


def p_yield_expr1(p):
    ''' yield_expr : YIELD '''
    p[0] = ast.Yield(value=None, lineno=p.lineno(1))


def p_yield_expr2(p):
    ''' yield_expr : YIELD testlist '''
    value = ast_for_testlist(p[2])
    p[0] = ast.Yield(value=value, lineno=p.lineno(1))


def p_global_stmt1(p):
    ''' global_stmt : GLOBAL NAME '''
    global_stmt = ast.Global()
    global_stmt.names = [p[2]]
    global_stmt.lineno = p.lineno(1)
    p[0] = global_stmt


def p_global_stmt2(p):
    ''' global_stmt : GLOBAL NAME globals_list '''
    global_stmt = ast.Global()
    global_stmt.names = [p[2]] + p[3]
    global_stmt.lineno = p.lineno(1)
    p[0] = global_stmt


def p_globals_list1(p):
    ''' globals_list : COMMA NAME globals_list '''
    p[0] = [p[2]] + p[3]


def p_globals_list2(p):
    ''' globals_list : COMMA NAME '''
    p[0] = [p[2]]


def p_exec_stmt1(p):
    ''' exec_stmt : EXEC expr '''
    exec_stmt = ast.Exec()
    exec_stmt.body = p[2]
    exec_stmt.globals = None
    exec_stmt.locals = None
    p[0] = exec_stmt


def p_exec_stmt2(p):
    ''' exec_stmt : EXEC expr IN test '''
    exec_stmt = ast.Exec()
    exec_stmt.body = p[2]
    exec_stmt.globals = p[4]
    exec_stmt.locals = None
    p[0] = exec_stmt


def p_exec_stmt3(p):
    ''' exec_stmt : EXEC expr IN test COMMA test '''
    exec_stmt = ast.Exec()
    exec_stmt.body = p[2]
    exec_stmt.globals = p[4]
    exec_stmt.locals = p[6]
    p[0] = exec_stmt


def p_assert_stmt1(p):
    ''' assert_stmt : ASSERT test '''
    assert_stmt = ast.Assert()
    assert_stmt.test = p[2]
    assert_stmt.msg = None
    p[0] = assert_stmt


def p_assert_stmt2(p):
    ''' assert_stmt : ASSERT test COMMA test '''
    assert_stmt = ast.Assert()
    assert_stmt.test = p[2]
    assert_stmt.msg = p[4]
    p[0] = assert_stmt


def p_expr_stmt1(p):
    ''' expr_stmt : testlist '''
    expr = ast.Expr()
    expr.value = ast_for_testlist(p[1])
    p[0] = expr


def p_expr_stmt2(p):
    ''' expr_stmt : testlist augassign testlist
                  | testlist augassign yield_expr '''
    op, lineno = p[2]
    lhs = ast_for_testlist(p[1])
    rhs = ast_for_testlist(p[3])
    set_context(lhs, Store, p)
    if type(lhs) not in aug_assign_allowed:
        msg = 'illegal expression for augmented assignment'
        syntax_error(msg, FakeToken(p.lexer.lexer, lineno))
    aug = ast.AugAssign()
    aug.target = lhs
    aug.value = rhs
    aug.op = op
    p[0] = aug


def p_expr_stmt3(p):
    ''' expr_stmt : testlist equal_list '''
    all_items = [p[1]] + p[2]
    targets = map(ast_for_testlist, all_items)
    value = targets.pop()
    for item in targets:
        if type(item) == ast.Yield:
            msg = "assignment to yield expression not possible"
            syntax_error(msg, FakeToken(p.lexer.lexer, item.lineno))
        set_context(item, Store, p)
    assg = ast.Assign()
    assg.targets = targets
    assg.value = value
    p[0] = assg


def p_augassign(p):
    ''' augassign : AMPEREQUAL
                  | CIRCUMFLEXEQUAL
                  | DOUBLESLASHEQUAL
                  | DOUBLESTAREQUAL
                  | LEFTSHIFTEQUAL
                  | MINUSEQUAL
                  | PERCENTEQUAL
                  | PLUSEQUAL
                  | RIGHTSHIFTEQUAL
                  | SLASHEQUAL
                  | STAREQUAL
                  | VBAREQUAL '''
    lineno = p.lineno(1)
    op = augassign_table[p[1]]
    p[0] = (op, lineno)


def p_equal_list1(p):
    ''' equal_list : EQUAL testlist
                   | EQUAL yield_expr '''
    p[0] = [p[2]]


def p_equal_list2(p):
    ''' equal_list : EQUAL testlist equal_list
                   | EQUAL yield_expr equal_list '''
    p[0] = [p[2]] + p[3]


def p_testlist1(p):
    ''' testlist : test '''
    p[0] = p[1]


def p_testlist2(p):
    ''' testlist : test COMMA '''
    p[0] = [p[1]]


def p_testlist3(p):
    ''' testlist : test testlist_list '''
    p[0] = [p[1]] + p[2]


def p_testlist4(p):
    ''' testlist : test testlist_list COMMA '''
    p[0] = [p[1]] + p[2]


def p_testlist_list1(p):
    ''' testlist_list : COMMA test '''
    p[0] = [p[2]]


def p_testlist_list2(p):
    ''' testlist_list : testlist_list COMMA test '''
    p[0] = p[1] + [p[3]]


def p_compound_stmt(p):
    ''' compound_stmt : if_stmt
                      | while_stmt
                      | for_stmt
                      | try_stmt
                      | with_stmt
                      | funcdef
                      | classdef
                      | decorated '''
    p[0] = p[1]


def p_if_stmt1(p):
    ''' if_stmt : IF test COLON suite '''
    if_stmt = ast.If()
    if_stmt.test = p[2]
    if_stmt.body = p[4]
    if_stmt.lineno = p.lineno(1)
    ast.fix_missing_locations(if_stmt)
    if_stmt.orelse = []
    p[0] = if_stmt


def p_if_stmt2(p):
    ''' if_stmt : IF test COLON suite elif_stmts '''
    if_stmt = ast.If()
    if_stmt.test = p[2]
    if_stmt.body = p[4]
    if_stmt.lineno = p.lineno(1)
    if_stmt.orelse = [p[5]]
    ast.fix_missing_locations(if_stmt)
    p[0] = if_stmt


def p_if_stmt3(p):
    ''' if_stmt : IF test COLON suite else_stmt '''
    if_stmt = ast.If()
    if_stmt.test = p[2]
    if_stmt.body = p[4]
    if_stmt.lineno = p.lineno(1)
    if_stmt.orelse = p[5]
    ast.fix_missing_locations(if_stmt)
    p[0] = if_stmt


def p_if_stmt4(p):
    ''' if_stmt : IF test COLON suite elif_stmts else_stmt '''
    if_stmt = ast.If()
    if_stmt.test = p[2]
    if_stmt.body = p[4]
    if_stmt.lineno = p.lineno(1)
    elif_stmt = p[5]
    if_stmt.orelse = [elif_stmt]
    else_stmt = p[6]
    while elif_stmt.orelse:
        elif_stmt = elif_stmt.orelse[0]
    elif_stmt.orelse = else_stmt
    ast.fix_missing_locations(if_stmt)
    p[0] = if_stmt


def p_elif_stmts1(p):
    ''' elif_stmts : elif_stmt elif_stmts '''
    elif_stmt = p[1]
    elif_stmt.orelse = [p[2]]
    p[0] = elif_stmt


def p_elif_stmts2(p):
    ''' elif_stmts : elif_stmt '''
    p[0] = p[1]


def p_elif_stmt(p):
    ''' elif_stmt : ELIF test COLON suite '''
    if_stmt = ast.If()
    if_stmt.test = p[2]
    if_stmt.body = p[4]
    if_stmt.lineno = p.lineno(1)
    if_stmt.orelse = []
    ast.fix_missing_locations(if_stmt)
    p[0] = if_stmt


def p_else_stmt(p):
    ''' else_stmt : ELSE COLON suite '''
    p[0] = p[3]


def p_while_stmt1(p):
    ''' while_stmt : WHILE test COLON suite '''
    while_stmt = ast.While()
    while_stmt.test = p[2]
    while_stmt.body = p[4]
    while_stmt.orelse = []
    while_stmt.lineno = p.lineno(1)
    ast.fix_missing_locations(while_stmt)
    p[0] = while_stmt


def p_while_stmt2(p):
    ''' while_stmt : WHILE test COLON suite ELSE COLON suite '''
    while_stmt = ast.While()
    while_stmt.test = p[2]
    while_stmt.body = p[4]
    while_stmt.orelse = p[7]
    while_stmt.lineno = p.lineno(1)
    ast.fix_missing_locations(while_stmt)
    p[0] = while_stmt


def p_for_stmt1(p):
    ''' for_stmt : FOR exprlist IN testlist COLON suite '''
    for_stmt = ast.For()
    target = p[2]
    set_context(target, Store, p)
    for_stmt.target = target
    for_stmt.iter = ast_for_testlist(p[4])
    for_stmt.body = p[6]
    for_stmt.orelse = []
    for_stmt.lineno = p.lineno(1)
    ast.fix_missing_locations(for_stmt)
    p[0] = for_stmt


def p_for_stmt2(p):
    ''' for_stmt : FOR exprlist IN testlist COLON suite ELSE COLON suite '''
    for_stmt = ast.For()
    target = p[2]
    set_context(target, Store, p)
    for_stmt.target = target
    for_stmt.iter = ast_for_testlist(p[4])
    for_stmt.body = p[6]
    for_stmt.orelse = p[9]
    for_stmt.lineno = p.lineno(1)
    ast.fix_missing_locations(for_stmt)
    p[0] = for_stmt


def p_try_stmt1(p):
    ''' try_stmt : TRY COLON suite FINALLY COLON suite '''
    try_finally = ast.TryFinally()
    try_finally.body = p[3]
    try_finally.finalbody = p[6]
    try_finally.lineno = p.lineno(1)
    ast.fix_missing_locations(try_finally)
    p[0] = try_finally


def p_try_stmt2(p):
    ''' try_stmt : TRY COLON suite except_clauses '''
    try_stmt = ast.TryExcept()
    try_stmt.body = p[3]
    try_stmt.handlers = p[4]
    try_stmt.orelse = []
    try_stmt.lineno = p.lineno(1)
    ast.fix_missing_locations(try_stmt)
    p[0] = try_stmt


def p_try_stmt3(p):
    ''' try_stmt : TRY COLON suite except_clauses ELSE COLON suite '''
    try_stmt = ast.TryExcept()
    try_stmt.body = p[3]
    try_stmt.handlers = p[4]
    try_stmt.orelse = p[7]
    try_stmt.lineno = p.lineno(1)
    ast.fix_missing_locations(try_stmt)
    p[0] = try_stmt


def p_try_stmt4(p):
    ''' try_stmt : TRY COLON suite except_clauses FINALLY COLON suite '''
    lineno = p.lineno(1)
    try_finally = ast.TryFinally()
    try_stmt = ast.TryExcept()
    try_stmt.body = p[3]
    try_stmt.handlers = p[4]
    try_stmt.orelse = []
    try_stmt.lineno = lineno
    ast.fix_missing_locations(try_stmt)
    try_finally.body = [try_stmt]
    try_finally.finalbody = p[7]
    try_finally.lineno = lineno
    ast.fix_missing_locations(try_finally)
    p[0] = try_finally


def p_try_stmt5(p):
    ''' try_stmt : TRY COLON suite except_clauses ELSE COLON suite FINALLY COLON suite '''
    lineno = p.lineno(1)
    try_finally = ast.TryFinally()
    try_stmt = ast.TryExcept()
    try_stmt.body = p[3]
    try_stmt.handlers = p[4]
    try_stmt.orelse = p[7]
    try_stmt.lineno = lineno
    ast.fix_missing_locations(try_stmt)
    try_finally.body = [try_stmt]
    try_finally.finalbody = p[10]
    try_finally.lineno = lineno
    ast.fix_missing_locations(try_finally)
    p[0] = try_finally


def p_except_clauses1(p):
    ''' except_clauses : except_clause except_clauses '''
    p[0] = [p[1]] + p[2]


def p_except_clauses2(p):
    ''' except_clauses : except_clause '''
    p[0] = [p[1]]


def p_except_clause1(p):
    ''' except_clause : EXCEPT COLON suite '''
    excpt = ast.ExceptHandler()
    excpt.type = None
    excpt.name = None
    excpt.body = p[3]
    excpt.lineno = p.lineno(1)
    ast.fix_missing_locations(excpt)
    p[0] = excpt


def p_except_clause2(p):
    ''' except_clause : EXCEPT test COLON suite '''
    excpt = ast.ExceptHandler()
    excpt.type = p[2]
    excpt.name = None
    excpt.body = p[4]
    excpt.lineno = p.lineno(1)
    ast.fix_missing_locations(excpt)
    p[0] = excpt


def p_except_clause3(p):
    ''' except_clause : EXCEPT test AS test COLON suite
                      | EXCEPT test COMMA test COLON suite '''
    excpt = ast.ExceptHandler()
    excpt.type = p[2]
    name = p[4]
    set_context(name, Store, p)
    excpt.name = name
    excpt.body = p[6]
    excpt.lineno = p.lineno(1)
    ast.fix_missing_locations(excpt)
    p[0] = excpt


def p_with_stmt1(p):
    ''' with_stmt : WITH with_item COLON suite '''
    with_stmt = ast.With()
    ctxt, opt_vars = p[2]
    with_stmt.context_expr = ctxt
    with_stmt.optional_vars = opt_vars
    with_stmt.body = p[4]
    with_stmt.lineno = p.lineno(1)
    ast.fix_missing_locations(with_stmt)
    p[0] = with_stmt


def p_with_stmt2(p):
    ''' with_stmt : WITH with_item with_item_list COLON suite '''
    with_stmt = ast.With()
    ctxt, opt_vars = p[2]
    with_stmt.context_expr = ctxt
    with_stmt.optional_vars = opt_vars
    root = with_stmt
    last = with_stmt
    for ctxt, opt_vars in p[3]:
        with_stmt = ast.With()
        with_stmt.context_expr = ctxt
        with_stmt.optional_vars = opt_vars
        last.body = [with_stmt]
        last = with_stmt
    last.body = p[5]
    root.lineno = p.lineno(1)
    ast.fix_missing_locations(root)
    p[0] = root


def p_with_item1(p):
    ''' with_item : test '''
    p[0] = (p[1], None)


def p_with_item2(p):
    ''' with_item : test AS expr '''
    expr = p[3]
    set_context(expr, Store, p)
    p[0] = (p[1], expr)


def p_with_item_list1(p):
    ''' with_item_list : COMMA with_item with_item_list '''
    p[0] = [p[2]] + p[3]


def p_with_item_list2(p):
    ''' with_item_list : COMMA with_item '''
    p[0] = [p[2]]


def p_funcdef(p):
    ''' funcdef : DEF NAME parameters COLON suite '''
    funcdef = ast.FunctionDef()
    funcdef.name = p[2]
    funcdef.args = p[3]
    funcdef.body = p[5]
    funcdef.decorator_list = []
    funcdef.lineno = p.lineno(1)
    ast.fix_missing_locations(funcdef)
    p[0] = funcdef


def p_parameters1(p):
    ''' parameters : LPAR RPAR '''
    p[0] = ast.arguments(args=[], defaults=[], vararg=None, kwarg=None)


def p_parameters2(p):
    ''' parameters : LPAR varargslist RPAR '''
    p[0] = p[2]


def p_classdef1(p):
    ''' classdef : CLASS NAME COLON suite '''
    classdef = ast.ClassDef()
    classdef.name = p[2]
    classdef.bases = []
    classdef.body = p[4]
    classdef.decorator_list = []
    classdef.lineno = p.lineno(1)
    ast.fix_missing_locations(classdef)
    p[0] = classdef


def p_classdef2(p):
    ''' classdef : CLASS NAME LPAR RPAR COLON suite '''
    classdef = ast.ClassDef()
    classdef.name = p[2]
    classdef.bases = []
    classdef.body = p[6]
    classdef.decorator_list = []
    classdef.lineno = p.lineno(1)
    ast.fix_missing_locations(classdef)
    p[0] = classdef


def p_classdef3(p):
    ''' classdef : CLASS NAME LPAR testlist RPAR COLON suite '''
    classdef = ast.ClassDef()
    classdef.name = p[2]
    bases = p[4]
    if not isinstance(bases, list):
        bases = [bases]
    classdef.bases = bases
    classdef.body = p[7]
    classdef.decorator_list = []
    classdef.lineno = p.lineno(1)
    ast.fix_missing_locations(classdef)
    p[0] = classdef


def p_decorated(p):
    ''' decorated : decorators funcdef
                  | decorators classdef '''
    decs = p[1]
    target = p[2]
    target.decorator_list = decs
    p[0] = target


def p_decorators1(p):
    ''' decorators : decorator decorators '''
    p[0] = [p[1]] + p[2]


def p_decorators2(p):
    ''' decorators : decorator '''
    p[0] = [p[1]]


def p_decorator1(p):
    ''' decorator : AT dotted_name NEWLINE '''
    name = ast_for_dotted_name(p[2])
    name.lineno = p.lineno(1)
    ast.fix_missing_locations(name)
    p[0] = name


def p_decorator2(p):
    ''' decorator : AT dotted_name LPAR RPAR NEWLINE '''
    call = ast.Call()
    call.func = ast_for_dotted_name(p[2])
    call.args = []
    call.keywords = []
    call.stargs = None
    call.kwargs = None
    call.lineno = p.lineno(1)
    ast.fix_missing_locations(call)
    p[0] = call


def p_decorator3(p):
    ''' decorator : AT dotted_name LPAR arglist RPAR NEWLINE '''
    args = p[4]
    call = ast.Call()
    call.func = ast_for_dotted_name(p[2])
    call.args = args.args
    call.keywords = args.keywords
    call.starargs = args.starargs
    call.kwargs = args.kwargs
    call.lineno = p.lineno(1)
    ast.fix_missing_locations(call)
    p[0] = call


def p_import_stmt1(p):
    ''' import_stmt : import_name '''
    p[0] = p[1]


def p_import_stmt2(p):
    ''' import_stmt : import_from '''
    p[0] = p[1]


def p_import_name(p):
    ''' import_name : IMPORT dotted_as_names '''
    imprt = ast.Import(names=p[2])
    imprt.col_offset = 0
    p[0] = imprt


def p_import_from1(p):
    ''' import_from : FROM dotted_name IMPORT STAR '''
    alias = ast.alias(name=p[4], asname=None)
    imprt = ast.ImportFrom(module=p[2], names=[alias], level=0)
    imprt.col_offset = 0
    p[0] = imprt


def p_import_from2(p):
    ''' import_from : FROM dotted_name IMPORT import_as_names '''
    imprt = ast.ImportFrom(module=p[2], names=p[4], level=0)
    imprt.col_offset = 0
    p[0] = imprt


def p_import_from3(p):
    ''' import_from : FROM dotted_name IMPORT LPAR import_as_names RPAR '''
    imprt = ast.ImportFrom(module=p[2], names=p[5], level=0)
    imprt.col_offset = 0
    p[0] = imprt


def p_import_from4(p):
    ''' import_from : FROM import_from_dots dotted_name IMPORT STAR '''
    alias = ast.alias(name=p[5], asname=None)
    imprt = ast.ImportFrom(module=p[3], names=[alias], level=len(p[2]))
    imprt.col_offset = 0
    p[0] = imprt


def p_import_from5(p):
    ''' import_from : FROM import_from_dots dotted_name IMPORT import_as_names '''
    imprt = ast.ImportFrom(module=p[3], names=p[5], level=len(p[2]))
    imprt.col_offset = 0
    p[0] = imprt


def p_import_from6(p):
    ''' import_from : FROM import_from_dots dotted_name IMPORT LPAR import_as_names RPAR '''
    imprt = ast.ImportFrom(module=p[3], names=p[6], level=len(p[2]))
    imprt.col_offset = 0
    p[0] = imprt


def p_import_from7(p):
    ''' import_from : FROM import_from_dots IMPORT STAR '''
    alias = ast.alias(name=p[4], asname=None)
    imprt = ast.ImportFrom(module=None, names=[alias], level=len(p[2]))
    imprt.col_offset = 0
    p[0] = imprt


def p_import_from8(p):
    ''' import_from : FROM import_from_dots IMPORT import_as_names '''
    imprt = ast.ImportFrom(module=None, names=p[4], level=len(p[2]))
    imprt.col_offset = 0
    p[0] = imprt


def p_import_from9(p):
    ''' import_from : FROM import_from_dots IMPORT LPAR import_as_names RPAR '''
    imprt = ast.ImportFrom(module=None, names=p[5], level=len(p[2]))
    imprt.col_offset = 0
    p[0] = imprt


def p_import_from_dots1(p):
    ''' import_from_dots : DOT '''
    p[0] = [p[1]]


def p_import_from_dots2(p):
    ''' import_from_dots : import_from_dots DOT '''
    p[0] = p[1] + [p[2]]


def p_import_from_dots3(p):
    ''' import_from_dots : ELLIPSIS '''
    p[0] = ['.', '.', '.']


def p_import_from_dots4(p):
    ''' import_from_dots : import_from_dots ELLIPSIS '''
    p[0] = p[1] + ['.', '.', '.']


def p_import_as_name1(p):
    ''' import_as_name : NAME '''
    p[0] = ast.alias(name=p[1], asname=None)


def p_import_as_name2(p):
    ''' import_as_name : NAME AS NAME '''
    p[0] = ast.alias(name=p[1], asname=p[3])


def p_dotted_as_name1(p):
    ''' dotted_as_name : dotted_name '''
    alias = ast.alias(name=p[1], asname=None)
    p[0] = alias


def p_dotted_as_name2(p):
    ''' dotted_as_name : dotted_name AS NAME '''
    alias = ast.alias(name=p[1], asname=p[3])
    p[0] = alias


def p_import_as_names1(p):
    ''' import_as_names : import_as_name '''
    p[0] = [p[1]]


def p_import_as_names2(p):
    ''' import_as_names : import_as_name COMMA '''
    p[0] = [p[1]]


def p_import_as_names3(p):
    ''' import_as_names : import_as_name import_as_names_list '''
    p[0] = [p[1]] + p[2]


def p_import_as_names4(p):
    ''' import_as_names : import_as_name import_as_names_list COMMA '''
    p[0] = [p[1]] + p[2]


def p_import_as_names_list1(p):
    ''' import_as_names_list : COMMA import_as_name '''
    p[0] = [p[2]]


def p_import_as_names_list2(p):
    ''' import_as_names_list : import_as_names_list COMMA import_as_name '''
    p[0] = p[1] + [p[3]]


def p_dotted_as_names1(p):
    ''' dotted_as_names : dotted_as_name '''
    p[0] = [p[1]]


def p_dotted_as_names2(p):
    ''' dotted_as_names : dotted_as_name dotted_as_names_list '''
    p[0] = [p[1]] + p[2]


def p_dotted_as_names_list1(p):
    ''' dotted_as_names_list : COMMA dotted_as_name '''
    p[0] = [p[2]]


def p_dotted_as_names_star_list2(p):
    ''' dotted_as_names_list : dotted_as_names_list COMMA dotted_as_name '''
    p[0] = p[1] + [p[3]]


def p_dotted_name1(p):
    ''' dotted_name : NAME '''
    p[0] = p[1]


def p_dotted_name2(p):
    ''' dotted_name : NAME dotted_name_list '''
    p[0] = p[1] + p[2]


def p_dotted_name_list1(p):
    ''' dotted_name_list : DOT NAME '''
    p[0] = p[1] + p[2]


def p_dotted_name_list2(p):
    ''' dotted_name_list : dotted_name_list DOT NAME '''
    p[0] = p[1] + p[2] + p[3]


def p_test1(p):
    ''' test : or_test '''
    p[0] = p[1]


def p_test2(p):
    ''' test : or_test IF or_test ELSE test '''
    ifexp = ast.IfExp(body=p[1], test=p[3], orelse=p[5])
    p[0] = ifexp


def p_test3(p):
    ''' test : lambdef '''
    p[0] = p[1]


def p_or_test1(p):
    ''' or_test : and_test '''
    p[0] = p[1]


def p_or_test2(p):
    ''' or_test : and_test or_test_list '''
    values = [p[1]] + p[2]
    or_node = ast.BoolOp(op=ast.Or(), values=values)
    p[0] = or_node


def p_or_test_list1(p):
    ''' or_test_list : OR and_test '''
    p[0] = [p[2]]


def p_or_test_list2(p):
    ''' or_test_list : or_test_list OR and_test '''
    p[0] = p[1] + [p[3]]


def p_and_test1(p):
    ''' and_test : not_test '''
    p[0] = p[1]


def p_and_test2(p):
    ''' and_test : not_test and_test_list '''
    values = [p[1]] + p[2]
    and_node = ast.BoolOp(op=ast.And(), values=values)
    p[0] = and_node


def p_and_test_list1(p):
    ''' and_test_list : AND not_test '''
    p[0] = [p[2]]


def p_and_test_list2(p):
    ''' and_test_list : and_test_list AND not_test '''
    p[0] = p[1] + [p[3]]


def p_not_test(p):
    ''' not_test : comparison '''
    p[0] = p[1]


def p_not_test2(p):
    ''' not_test : NOT not_test '''
    un_node = ast.UnaryOp(op=ast.Not(), operand=p[2])
    p[0] = un_node


def p_comparison1(p):
    ''' comparison : expr '''
    p[0] = p[1]


def p_comparison2(p):
    ''' comparison : expr comparison_list '''
    left = p[1]
    ops, comparators = zip(*p[2])
    cmpr = ast.Compare(left=left, ops=list(ops), comparators=list(comparators))
    p[0] = cmpr


def p_comparison_list1(p):
    ''' comparison_list : comp_op expr '''
    p[0] = [[p[1], p[2]]]


def p_comparison_list2(p):
    ''' comparison_list : comparison_list comp_op expr '''
    p[0] = p[1] + [[p[2], p[3]]]


def p_comp_op1(p):
    ''' comp_op : LESS '''
    p[0] = ast.Lt()


def p_comp_op2(p):
    ''' comp_op : GREATER '''
    p[0] = ast.Gt()


def p_comp_op3(p):
    ''' comp_op : EQEQUAL '''
    p[0] = ast.Eq()


def p_comp_op4(p):
    ''' comp_op : GREATEREQUAL '''
    p[0] = ast.GtE()


def p_comp_op5(p):
    ''' comp_op : LESSEQUAL '''
    p[0] = ast.LtE()


def p_comp_op6(p):
    ''' comp_op : NOTEQUAL '''
    p[0] = ast.NotEq()


def p_comp_op7(p):
    ''' comp_op : IN '''
    p[0] = ast.In()


def p_comp_op8(p):
    ''' comp_op : NOT IN '''
    p[0] = ast.NotIn()


def p_comp_op9(p):
    ''' comp_op : IS '''
    p[0] = ast.Is()


def p_comp_op10(p):
    ''' comp_op : IS NOT '''
    p[0] = ast.IsNot()


def p_expr1(p):
    ''' expr : xor_expr '''
    p[0] = p[1]


def p_expr2(p):
    ''' expr : xor_expr expr_list '''
    node = p[1]
    for op, right in p[2]:
        node = ast.BinOp(left=node, op=op, right=right)
    p[0] = node


def p_expr_list1(p):
    ''' expr_list : VBAR xor_expr '''
    p[0] = [[ast.BitOr(), p[2]]]


def p_expr_list2(p):
    ''' expr_list : expr_list VBAR xor_expr '''
    p[0] = p[1] + [[ast.BitOr(), p[3]]]


def p_xor_expr1(p):
    ''' xor_expr : and_expr '''
    p[0] = p[1]


def p_xor_expr2(p):
    ''' xor_expr : and_expr xor_expr_list '''
    node = p[1]
    for op, right in p[2]:
        node = ast.BinOp(left=node, op=op, right=right)
    p[0] = node


def p_xor_expr_list1(p):
    ''' xor_expr_list : CIRCUMFLEX and_expr '''
    p[0] = [[ast.BitXor(), p[2]]]


def p_xor_expr_list2(p):
    ''' xor_expr_list : xor_expr_list CIRCUMFLEX and_expr '''
    p[0] = p[1] + [[ast.BitXor(), p[3]]]


def p_and_expr1(p):
    ''' and_expr : shift_expr '''
    p[0] = p[1]


def p_and_expr2(p):
    ''' and_expr : shift_expr and_expr_list '''
    node = p[1]
    for op, right in p[2]:
        node = ast.BinOp(left=node, op=op, right=right)
    p[0] = node


def p_and_expr_list1(p):
    ''' and_expr_list : AMPER shift_expr '''
    p[0] = [[ast.BitAnd(), p[2]]]


def p_and_expr_list2(p):
    ''' and_expr_list : and_expr_list AMPER shift_expr '''
    p[0] = p[1] + [[ast.BitAnd(), p[3]]]


def p_shift_expr1(p):
    ''' shift_expr : arith_expr '''
    p[0] = p[1]


def p_shift_expr2(p):
    ''' shift_expr : arith_expr shift_list '''
    node = p[1]
    for op, right in p[2]:
        node = ast.BinOp(left=node, op=op, right=right)
    p[0] = node


def p_shift_list1(p):
    ''' shift_list : shift_op '''
    p[0] = [p[1]]


def p_shift_list2(p):
    ''' shift_list : shift_list shift_op '''
    p[0] = p[1] + [p[2]]


def p_shift_op1(p):
    ''' shift_op : LEFTSHIFT arith_expr '''
    p[0] = [ast.LShift(), p[2]]


def p_shift_op2(p):
    ''' shift_op : RIGHTSHIFT arith_expr '''
    p[0] = [ast.RShift(), p[2]]


def p_arith_expr1(p):
    ''' arith_expr : term '''
    p[0] = p[1]


def p_arith_expr2(p):
    ''' arith_expr : term arith_expr_list '''
    node = p[1]
    for op, right in p[2]:
        node = ast.BinOp(left=node, op=op, right=right)
    p[0] = node


def p_arith_expr_list1(p):
    ''' arith_expr_list : arith_op '''
    p[0] = [p[1]]


def p_arith_expr_list2(p):
    ''' arith_expr_list : arith_expr_list arith_op '''
    p[0] = p[1] + [p[2]]


def p_arith_op1(p):
    ''' arith_op : PLUS term '''
    node = ast.Add()
    p[0] = [node, p[2]]


def p_arith_op2(p):
    ''' arith_op : MINUS term '''
    p[0] = [ast.Sub(), p[2]]


def p_term1(p):
    ''' term : factor '''
    p[0] = p[1]


def p_term2(p):
    ''' term : factor term_list '''
    node = p[1]
    for op, right in p[2]:
        node = ast.BinOp(left=node, op=op, right=right)
    p[0] = node


def p_term_list1(p):
    ''' term_list : term_op '''
    p[0] = [p[1]]


def p_term_list2(p):
    ''' term_list : term_list term_op '''
    p[0] = p[1] + [p[2]]


def p_term_op1(p):
    ''' term_op : STAR factor '''
    p[0] = [ast.Mult(), p[2]]


def p_term_op2(p):
    ''' term_op : SLASH factor '''
    p[0] = [ast.Div(), p[2]]


def p_term_op3(p):
    ''' term_op : PERCENT factor '''
    p[0] = [ast.Mod(), p[2]]


def p_term_op4(p):
    ''' term_op : DOUBLESLASH factor '''
    p[0] = [ast.FloorDiv(), p[2]]


def p_factor1(p):
    ''' factor : power '''
    p[0] = p[1]


def p_factor2(p):
    ''' factor : PLUS factor '''
    op = ast.UAdd()
    operand = p[2]
    node = ast.UnaryOp(op=op, operand=operand)
    p[0] = node


def p_factor3(p):
    ''' factor : MINUS factor '''
    op = ast.USub()
    operand = p[2]
    node = ast.UnaryOp(op=op, operand=operand)
    p[0] = node


def p_factor4(p):
    ''' factor : TILDE factor '''
    op = ast.Invert()
    operand = p[2]
    node = ast.UnaryOp(op=op, operand=operand)
    p[0] = node


def p_power1(p):
    ''' power : atom '''
    p[0] = p[1]


def p_power2(p):
    ''' power : atom DOUBLESTAR factor '''
    node = ast.BinOp(left=p[1], op=ast.Pow(), right=p[3])
    p[0] = node


def p_power3(p):
    ''' power : atom power_list '''
    root = p[1]
    for node in p[2]:
        if isinstance(node, ast.Call):
            node.func = root
        elif isinstance(node, ast.Attribute):
            node.value = root
        elif isinstance(node, ast.Subscript):
            node.value = root
        else:
            raise TypeError('Unexpected trailer node: %s' % node)
        root = node
    p[0] = root


def p_power4(p):
    ''' power : atom power_list DOUBLESTAR factor '''
    root = p[1]
    for node in p[2]:
        if isinstance(node, ast.Call):
            node.func = root
        elif isinstance(node, ast.Attribute):
            node.value = root
        elif isinstance(node, ast.Subscript):
            node.value = root
        else:
            raise TypeError('Unexpected trailer node: %s' % node)
        root = node
    power = ast.BinOp(left=root, op=ast.Pow(), right=p[4])
    p[0] = power


def p_power_list1(p):
    ''' power_list : trailer '''
    p[0] = [p[1]]


def p_power_list2(p):
    ''' power_list : power_list trailer '''
    p[0] = p[1] + [p[2]]


def p_atom1(p):
    ''' atom : LPAR RPAR '''
    p[0] = ast.Tuple(elts=[], ctx=Load)


def p_atom2(p):
    ''' atom : LPAR yield_expr RPAR '''
    p[0] = p[2]


def p_atom3(p):
    ''' atom : LPAR testlist_comp RPAR '''
    info = p[2]
    if isinstance(info, CommaSeparatedList):
        node = ast.Tuple(elts=info.values, ctx=Load)
    elif isinstance(info, GeneratorInfo):
        node = ast.GeneratorExp(elt=info.elt, generators=info.generators)
    else:
        # We have a test node by itself in parenthesis controlling
        # order of operations, so just return the node.
        node = info
    p[0] = node


def p_atom4(p):
    ''' atom : LSQB RSQB '''
    p[0] = ast.List(elts=[], ctx=Load)


def p_atom5(p):
    ''' atom : LSQB listmaker RSQB '''
    info = p[2]
    if isinstance(info, CommaSeparatedList):
        node = ast.List(elts=info.values, ctx=Load)
    elif isinstance(info, GeneratorInfo):
        node = ast.ListComp(elt=info.elt, generators=info.generators)
    else:
        raise TypeError('Unexpected node for listmaker: %s' % info)
    p[0] = node


def p_atom6(p):
    ''' atom : LBRACE RBRACE '''
    p[0] = ast.Dict(keys=[], values=[])


def p_atom7(p):
    ''' atom : LBRACE dictorsetmaker RBRACE '''
    info = p[2]
    if isinstance(info, GeneratorInfo):
        if isinstance(info.elt, tuple):
            key, value = info.elt
            generators = info.generators
            node = DictComp(key=key, value=value, generators=generators)
        else:
            node = SetComp(elt=info.elt, generators=info.generators)
    elif isinstance(info, CommaSeparatedList):
        if isinstance(info.values[0], tuple):
            keys, values = zip(*info.values)
            node = ast.Dict(keys=list(keys), values=list(values))
        else:
            node = Set(elts=info.values)
    else:
        raise TypeError('Unexpected node for dictorsetmaker: %s' % info)
    p[0] = node


def p_atom8(p):
    ''' atom : NAME '''
    p[0] = ast.Name(id=p[1], ctx=Load, lineno=p.lineno(1))


def p_atom9(p):
    ''' atom : NUMBER '''
    n = ast.Num(n=eval(p[1]))
    p[0] = n


def p_atom10(p):
    ''' atom : atom_string_list '''
    s = ast.Str(s=p[1])
    p[0] = s


def p_atom_string_list1(p):
    ''' atom_string_list : STRING '''
    p[0] = p[1]


def p_atom_string_list2(p):
    ''' atom_string_list : atom_string_list STRING '''
    p[0] = p[1] + p[2]


# We dont' allow the backqoute atom from standard Python. Just
# use repr(...). This simplifies the grammar since we don't have
# to define a testlist1.


def p_listmaker1(p):
    ''' listmaker : test list_for '''
    p[0] = GeneratorInfo(elt=p[1], generators=p[2])


def p_listmaker2(p):
    ''' listmaker : test '''
    p[0] = CommaSeparatedList(values=[p[1]])


def p_listmaker3(p):
    ''' listmaker : test COMMA '''
    p[0] = CommaSeparatedList(values=[p[1]])


def p_listmaker4(p):
    ''' listmaker : test listmaker_list '''
    values = [p[1]] + p[2]
    p[0] = CommaSeparatedList(values=values)


def p_listmaker5(p):
    ''' listmaker : test listmaker_list COMMA '''
    values = [p[1]] + p[2]
    p[0] = CommaSeparatedList(values=values)


def p_listmaker_list1(p):
    ''' listmaker_list : COMMA test '''
    p[0] = [p[2]]


def p_listmaker_list2(p):
    ''' listmaker_list : listmaker_list COMMA test '''
    p[0] = p[1] + [p[3]]


def p_testlist_comp1(p):
    ''' testlist_comp : test comp_for '''
    p[0] = GeneratorInfo(elt=p[1], generators=p[2])


def p_testlist_comp2(p):
    ''' testlist_comp : test '''
    p[0] = p[1]


def p_testlist_comp3(p):
    ''' testlist_comp : test COMMA '''
    p[0] = CommaSeparatedList(values=[p[1]])


def p_testlist_comp4(p):
    ''' testlist_comp : test testlist_comp_list '''
    values = [p[1]] + p[2]
    p[0] = CommaSeparatedList(values=values)


def p_testlist_comp5(p):
    ''' testlist_comp : test testlist_comp_list COMMA '''
    values = [p[1]] + p[2]
    p[0] = CommaSeparatedList(values=values)


def p_testlist_comp_list1(p):
    ''' testlist_comp_list : COMMA test '''
    p[0] = [p[2]]


def p_testlist_comp_list2(p):
    ''' testlist_comp_list : testlist_comp_list COMMA test '''
    p[0] = p[1] + [p[3]]


def p_trailer1(p):
    ''' trailer : LPAR RPAR '''
    p[0] = ast.Call(args=[], keywords=[], starargs=None, kwargs=None)


def p_trailer2(p):
    ''' trailer : LPAR arglist RPAR '''
    args = p[2]
    p[0] = ast.Call(args=args.args, keywords=args.keywords,
                    starargs=args.starargs, kwargs=args.kwargs)


def p_trailer3(p):
    ''' trailer : LSQB subscriptlist RSQB '''
    p[0] = ast.Subscript(slice=p[2], ctx=Load)


def p_trailer4(p):
    ''' trailer : DOT NAME '''
    p[0] = ast.Attribute(attr=p[2], ctx=Load, lineno=p.lineno(2))


def p_subscriptlist1(p):
    ''' subscriptlist : subscript '''
    p[0] = p[1]


def p_subscriptlist2(p):
    ''' subscriptlist : subscript COMMA '''
    dims = [p[1]]
    p[0] = ast.ExtSlice(dims=dims)


def p_subscriptlist3(p):
    ''' subscriptlist : subscript subscriptlist_list '''
    dims = [p[1]] + p[2]
    p[0] = ast.ExtSlice(dims=dims)


def p_subscriptlist4(p):
    ''' subscriptlist : subscript subscriptlist_list COMMA '''
    dims = [p[1]] + p[2]
    p[0] = ast.ExtSlice(dims=dims)


def p_subscriptlist_list1(p):
    ''' subscriptlist_list : COMMA subscript '''
    p[0] = [p[2]]


def p_subscript_list2(p):
    ''' subscriptlist_list : subscriptlist_list COMMA subscript '''
    p[0] = p[1] + [p[3]]


def p_subscript1(p):
    ''' subscript : ELLIPSIS '''
    p[0] = ast.Ellipsis()


def p_subcript2(p):
    ''' subscript : test '''
    p[0] = ast.Index(value=p[1])


def p_subscript3(p):
    ''' subscript : COLON '''
    p[0] = ast.Slice(lower=None, upper=None, step=None)


def p_subscript4(p):
    ''' subscript : DOUBLECOLON '''
    name = ast.Name(id='None', ctx=Load)
    p[0] = ast.Slice(lower=None, upper=None, step=name)


def p_subscript5(p):
    ''' subscript : test COLON '''
    p[0] = ast.Slice(lower=p[1], uppper=None, step=None)


def p_subscrip6(p):
    ''' subscript : test DOUBLECOLON '''
    name = ast.Name(id='None', ctx=Load)
    p[0] = ast.Slice(lower=p[1], upper=None, step=name)


def p_subscript7(p):
    ''' subscript : COLON test '''
    p[0] = ast.Slice(lower=None, upper=p[2], step=None)


def p_subscript8(p):
    ''' subscript : COLON test COLON '''
    name = ast.Name(id='None', ctx=Load)
    p[0] = ast.Slice(lower=None, upper=p[2], step=name)


def p_subscript9(p):
    ''' subscript : DOUBLECOLON test '''
    p[0] = ast.Slice(lower=None, upper=None, step=p[2])


def p_subscript10(p):
    ''' subscript : test COLON test '''
    p[0] = ast.Slice(lower=p[1], upper=p[3], step=None)


def p_subscript11(p):
    ''' subscript : test COLON test COLON '''
    name = ast.Name(id='None', ctx=Load)
    p[0] = ast.Slice(lower=p[1], upper=p[3], step=name)


def p_subscript12(p):
    ''' subscript : COLON test COLON test '''
    p[0] = ast.Slice(lower=None, upper=p[2], step=p[4])


def p_subscript13(p):
    ''' subscript : test COLON test COLON test '''
    p[0] = ast.Slice(lower=p[1], upper=p[3], step=p[5])


def p_subscript14(p):
    ''' subscript : test DOUBLECOLON test '''
    p[0] = ast.Slice(lower=p[1], upper=None, step=p[3])


def p_exprlist1(p):
    ''' exprlist : expr '''
    p[0] = p[1]


def p_exprlist2(p):
    ''' exprlist : expr COMMA '''
    tup = ast.Tuple()
    tup.elts = [p[1]]
    p[0] = tup


def p_exprlist3(p):
    ''' exprlist : expr exprlist_list '''
    tup = ast.Tuple()
    tup.elts = [p[1]] + p[2]
    p[0] = tup


def p_exprlist4(p):
    ''' exprlist : expr exprlist_list COMMA '''
    tup = ast.Tuple()
    tup.elts = [p[1]] + p[2]
    p[0] = tup


def p_exprlist_list1(p):
    ''' exprlist_list : COMMA expr '''
    p[0] = [p[2]]


def p_exprlist_list2(p):
    ''' exprlist_list : exprlist_list COMMA expr '''
    p[0] = p[1] + [p[3]]


def p_dictorsetmaker1(p):
    ''' dictorsetmaker : test COLON test comp_for '''
    p[0] = GeneratorInfo(elt=(p[1], p[3]), generators=p[4])


def p_dictorsetmaker2(p):
    ''' dictorsetmaker : test COLON test '''
    values = [(p[1], p[3])]
    p[0] = CommaSeparatedList(values=values)


def p_dictorsetmaker3(p):
    ''' dictorsetmaker : test COLON test COMMA '''
    values = [(p[1], p[3])]
    p[0] = CommaSeparatedList(values=values)


def p_dictorsetmaker4(p):
    ''' dictorsetmaker : test COLON test dosm_colon_list '''
    values = [(p[1], p[3])] + p[4]
    p[0] = CommaSeparatedList(values=values)


def p_dictorsetmaker5(p):
    ''' dictorsetmaker : test COLON test dosm_colon_list COMMA '''
    values = [(p[1], p[3])] + p[4]
    p[0] = CommaSeparatedList(values=values)


def p_dictorsetmaker6(p):
    ''' dictorsetmaker : test comp_for '''
    p[0] = GeneratorInfo(elt=p[1], generators=p[2])


def p_dictorsetmaker7(p):
    ''' dictorsetmaker : test COMMA '''
    values = [p[1]]
    p[0] = CommaSeparatedList(values=values)


def p_dictorsetmaker8(p):
    ''' dictorsetmaker : test dosm_comma_list '''
    values = [p[1]] + p[2]
    p[0] = CommaSeparatedList(values=values)


def p_dictorsetmaker9(p):
    ''' dictorsetmaker : test dosm_comma_list COMMA '''
    values = [p[1]] + p[2]
    p[0] = CommaSeparatedList(values=values)


def p_dosm_colon_list1(p):
    ''' dosm_colon_list : COMMA test COLON test '''
    p[0] = [(p[2], p[4])]


def p_dosm_colon_list2(p):
    ''' dosm_colon_list : dosm_colon_list COMMA test COLON test '''
    p[0] = p[1] + [(p[3], p[5])]


def p_dosm_comma_list1(p):
    ''' dosm_comma_list : COMMA test '''
    p[0] = [p[2]]


def p_dosm_comma_list2(p):
    ''' dosm_comma_list : dosm_comma_list COMMA test '''
    p[0] = p[1] + [p[3]]


def p_arglist1(p):
    ''' arglist : argument '''
    if isinstance(p[1], ast.keyword):
        p[0] = Arguments(keywords=[p[1]])
    else:
        p[0] = Arguments(args=[p[1]])


def p_arglist2(p):
    ''' arglist : argument COMMA '''
    if isinstance(p[1], ast.keyword):
        p[0] = Arguments(keywords=[p[1]])
    else:
        p[0] = Arguments(args=[p[1]])


def p_arglist3(p):
    ''' arglist : STAR test '''
    p[0] = Arguments(starargs=p[2])


def p_arglist4(p):
    ''' arglist : STAR test COMMA DOUBLESTAR test '''
    p[0] = Arguments(starargs=p[2], kwargs=p[5])


def p_arglist5(p):
    ''' arglist : DOUBLESTAR test '''
    p[0] = Arguments(kwargs=p[2])


def _validate_arglist_list(items, lexer):
    kwnames = set()
    saw_kw = False
    for item in items:
        if isinstance(item, ast.keyword):
            saw_kw = True
            if item.arg in kwnames:
                msg = 'keyword argument repeated'
                tok = FakeToken(lexer, item.lineno)
                syntax_error(msg, tok)
            kwnames.add(item.arg)
        elif saw_kw:
            msg = 'non-keyword arg after keyword arg'
            tok = FakeToken(lexer, item.lineno)
            syntax_error(msg, tok)


def p_arglist6(p):
    ''' arglist : arglist_list argument '''
    args = []
    kws = []
    arglist = p[1]
    arg = p[2]
    # TODO get the proper linenumber for the argument
    arg.lineno = arglist[-1].lineno
    items = arglist + [arg]
    _validate_arglist_list(items, p.lexer.lexer)
    for arg in items:
        if isinstance(arg, ast.keyword):
            kws.append(arg)
        else:
            args.append(arg)
    p[0] = Arguments(args=args, keywords=kws)


def p_arglist7(p):
    ''' arglist : arglist_list argument COMMA '''
    args = []
    kws = []
    arglist = p[1]
    arg = p[2]
    arg.lineno = p.lineno(3)
    items = arglist + [arg]
    _validate_arglist_list(items, p.lexer.lexer)
    for arg in items:
        if isinstance(arg, ast.keyword):
            kws.append(arg)
        else:
            args.append(arg)
    p[0] = Arguments(args=args, keywords=kws)


def p_arglist8(p):
    ''' arglist : arglist_list STAR test '''
    args = []
    kws = []
    items = p[1]
    _validate_arglist_list(items, p.lexer.lexer)
    for arg in items:
        if isinstance(arg, ast.keyword):
            kws.append(arg)
        else:
            args.append(arg)
    p[0] = Arguments(args=args, keywords=kws, starargs=p[3])


def p_arglist9(p):
    ''' arglist : arglist_list STAR test COMMA DOUBLESTAR test '''
    args = []
    kws = []
    items = p[1]
    _validate_arglist_list(items, p.lexer.lexer)
    for arg in items:
        if isinstance(arg, ast.keyword):
            kws.append(arg)
        else:
            args.append(arg)
    p[0] = Arguments(args=args, keywords=kws, starargs=p[3], kwargs=p[6])


def p_arglist10(p):
    ''' arglist : arglist_list DOUBLESTAR test '''
    args = []
    kws = []
    items = p[1]
    _validate_arglist_list(items, p.lexer.lexer)
    for arg in items:
        if isinstance(arg, ast.keyword):
            kws.append(arg)
        else:
            args.append(arg)
    p[0] = Arguments(args=args, keywords=kws, kwargs=p[3])


def p_arglist11(p):
    ''' arglist : STAR test COMMA argument '''
    keyword = p[4]
    if isinstance(keyword, ast.keyword):
        p[0] = Arguments(keywords=[keyword], starargs=p[2])
    else:
        msg = 'only named arguments may follow *expression'
        tok = FakeToken(p.lexer.lexer, p.lineno(1))
        syntax_error(msg, tok)


def p_arglist12(p):
    ''' arglist : STAR test COMMA argument COMMA DOUBLESTAR test '''
    keyword = p[4]
    if isinstance(keyword, ast.keyword):
        p[0] = Arguments(keywords=[keyword], starargs=p[2], kwargs=p[7])
    else:
        msg = 'only named arguments may follow *expression'
        tok = FakeToken(p.lexer.lexer, p.lineno(1))
        syntax_error(msg, tok)


def p_arglist13(p):
    ''' arglist : STAR test COMMA arglist_list argument '''
    kwnames = set()
    keywords = p[4] + [p[5]]
    for kw in keywords:
        if not isinstance(kw, ast.keyword):
            msg = 'only named arguments may follow *expression'
            tok = FakeToken(p.lexer.lexer, p.lineno(1))
            syntax_error(msg, tok)
        if kw.arg in kwnames:
            msg = 'keyword argument repeated'
            tok = FakeToken(p.lexer.lexer, kw.lineno)
            syntax_error(msg, tok)
        kwnames.add(kw.arg)
    p[0] = Arguments(keywords=keywords, starargs=p[2])


def p_arglist14(p):
    ''' arglist : STAR test COMMA arglist_list argument COMMA DOUBLESTAR test '''
    kwnames = set()
    keywords = p[4] + [p[5]]
    for kw in keywords:
        if not isinstance(kw, ast.keyword):
            msg = 'only named arguments may follow *expression'
            tok = FakeToken(p.lexer.lexer, p.lineno(1))
            syntax_error(msg, tok)
        if kw.arg in kwnames:
            msg = 'keyword argument repeated'
            tok = FakeToken(p.lexer.lexer, kw.lineno)
            syntax_error(msg, tok)
        kwnames.add(kw.arg)
    p[0] = Arguments(keywords=keywords, starargs=p[2], kwargs=p[8])


def p_arglist_list1(p):
    ''' arglist_list : argument COMMA '''
    arg = p[1]
    arg.lineno = p.lineno(2)
    p[0] = [arg]


def p_arglist_list2(p):
    ''' arglist_list : arglist_list argument COMMA '''
    arg = p[2]
    arg.lineno = p.lineno(3)
    p[0] = p[1] + [arg]


def p_argument1(p):
    ''' argument : test '''
    p[0] = p[1]


def p_argument2(p):
    ''' argument : test comp_for '''
    p[0] = ast.GeneratorExp(elt=p[1], generators=p[2])


# This keyword argument needs to be asserted as a NAME, but using NAME
# here causes ambiguity in the parse tables.
def p_argument3(p):
    ''' argument : test EQUAL test '''
    arg = p[1]
    if not isinstance(arg, ast.Name):
        msg = 'Keyword arg must be a Name.'
        tok = FakeToken(p.lexer.lexer, p.lineno(2))
        syntax_error(msg, tok)
    value = p[3]
    p[0] = ast.keyword(arg=arg.id, value=value, lineno=p.lineno(2))


def p_list_for1(p):
    ''' list_for : FOR exprlist IN testlist_safe '''
    target = p[2]
    set_context(target, Store, p)
    p[0] = [ast.comprehension(target=target, iter=p[4], ifs=[])]


def p_list_for2(p):
    ''' list_for : FOR exprlist IN testlist_safe list_iter '''
    target = p[2]
    set_context(target, Store, p)
    gens = []
    gens.append(ast.comprehension(target=target, iter=p[4], ifs=[]))
    for item in p[5]:
        if isinstance(item, ast.comprehension):
            gens.append(item)
        else:
            gens[-1].ifs.append(item)
    p[0] = gens


def p_list_iter1(p):
    ''' list_iter : list_for '''
    p[0] = p[1]


def p_list_iter2(p):
    ''' list_iter : list_if '''
    p[0] = p[1]


def p_list_if1(p):
    ''' list_if : IF old_test '''
    p[0] = [p[2]]


def p_list_if2(p):
    ''' list_if : IF old_test list_iter '''
    p[0] = [p[2]] + p[3]


def p_comp_for1(p):
    ''' comp_for : FOR exprlist IN or_test '''
    target = p[2]
    set_context(target, Store, p)
    p[0] = [ast.comprehension(target=target, iter=p[4], ifs=[])]


def p_comp_for2(p):
    ''' comp_for : FOR exprlist IN or_test comp_iter '''
    target = p[2]
    set_context(target, Store, p)
    gens = []
    gens.append(ast.comprehension(target=target, iter=p[4], ifs=[]))
    for item in p[5]:
        if isinstance(item, ast.comprehension):
            gens.append(item)
        else:
            gens[-1].ifs.append(item)
    p[0] = gens


def p_comp_iter1(p):
    ''' comp_iter : comp_for '''
    p[0] = p[1]


def p_comp_iter2(p):
    ''' comp_iter : comp_if '''
    p[0] = p[1]


def p_comp_if1(p):
    ''' comp_if : IF old_test '''
    p[0] = [p[2]]


def p_comp_if2(p):
    ''' comp_if : IF old_test comp_iter '''
    p[0] = [p[2]] + p[3]


def p_testlist_safe1(p):
    ''' testlist_safe : old_test '''
    p[0] = p[1]


def p_testlist_safe2(p):
    ''' testlist_safe : old_test testlist_safe_list '''
    values = [p[1]] + p[2]
    p[0] = ast.Tuple(elts=values, ctx=Load)


def p_testlist_safe3(p):
    ''' testlist_safe : old_test testlist_safe_list COMMA '''
    values = [p[1]] + p[2]
    p[0] = ast.Tuple(elts=values, ctx=Load)


def p_testlist_safe_list1(p):
    ''' testlist_safe_list : COMMA old_test '''
    p[0] = [p[2]]


def p_testlist_safe_list2(p):
    ''' testlist_safe_list : testlist_safe_list COMMA old_test '''
    p[0] = p[1] + [p[3]]


def p_old_test1(p):
    ''' old_test : or_test '''
    p[0] = p[1]


def p_old_test2(p):
    ''' old_test : old_lambdef '''
    p[0] = p[1]


def p_old_lambdef1(p):
    ''' old_lambdef : LAMBDA COLON old_test '''
    args = ast.arguments(args=[], defaults=[], kwarg=None, vararg=None)
    body = p[3]
    p[0] = ast.Lambda(args=args, body=body)


def p_old_lambdef2(p):
    ''' old_lambdef : LAMBDA varargslist COLON old_test '''
    args = p[2]
    body = p[4]
    p[0] = ast.Lambda(args=args, body=body)


def p_lambdef1(p):
    ''' lambdef : LAMBDA COLON test '''
    args = ast.arguments(args=[], defaults=[], kwarg=None, vararg=None)
    body = p[3]
    p[0] = ast.Lambda(args=args, body=body)


def p_lambdef2(p):
    ''' lambdef : LAMBDA varargslist COLON test '''
    args = p[2]
    body = p[4]
    p[0] = ast.Lambda(args=args, body=body)


def p_varargslist1(p):
    ''' varargslist : fpdef COMMA STAR NAME '''
    # def f(a, *args): pass
    # def f((a, b), *args): pass
    p[0] = ast.arguments(args=[p[1]], defaults=[], vararg=p[4], kwarg=None)


def p_varargslist2(p):
    ''' varargslist : fpdef COMMA STAR NAME COMMA DOUBLESTAR NAME '''
    # def f(a, *args, **kwargs): pass
    # def f((a, b), *args, **kwargs): pass
    p[0] = ast.arguments(args=[p[1]], defaults=[], vararg=p[4], kwarg=p[7])


def p_varargslist3(p):
    ''' varargslist : fpdef COMMA DOUBLESTAR NAME '''
    # def f(a, **kwargs): pass
    # def f((a, b), **kwargs): pass
    p[0] = ast.arguments(args=[p[1]], defaults=[], vararg=None, kwarg=p[4])


def p_varargslist4(p):
    ''' varargslist : fpdef '''
    # def f(a): pass
    # def f((a, b)): pass
    p[0] = ast.arguments(args=[p[1]], defaults=[], vararg=None, kwarg=None)


def p_varargslist5(p):
    ''' varargslist : fpdef COMMA '''
    # def f(a,): pass
    # def f((a,b),): pass
    p[0] = ast.arguments(args=[p[1]], defaults=[], vararg=None, kwarg=None)


def p_varargslist6(p):
    ''' varargslist : fpdef varargslist_list COMMA STAR NAME '''
    # def f((a, b), c, *args): pass
    # def f((a, b), c, d=4, *args): pass
    list_args, defaults = p[2]
    args = [p[1]] + list_args
    p[0] = ast.arguments(args=args, defaults=defaults, vararg=p[5], kwarg=None)


def p_varargslist7(p):
    ''' varargslist : fpdef varargslist_list COMMA STAR NAME COMMA DOUBLESTAR NAME '''
    # def f((a, b), c, *args, **kwargs): pass
    # def f((a, b), c, d=4, *args, **kwargs): pass
    list_args, defaults = p[2]
    args = [p[1]] + list_args
    p[0] = ast.arguments(args=args, defaults=defaults, vararg=p[5], kwarg=p[8])


def p_varargslist8(p):
    ''' varargslist : fpdef varargslist_list COMMA DOUBLESTAR NAME '''
    # def f((a, b), c, **kwargs): pass
    # def f((a, b), c, d=4, **kwargs): pass
    list_args, defaults = p[2]
    args = [p[1]] + list_args
    p[0] = ast.arguments(args=args, defaults=defaults, vararg=None, kwarg=p[5])


def p_varargslist9(p):
    ''' varargslist : fpdef varargslist_list '''
    # def f((a, b), c): pass
    # def f((a, b), c, d=4): pass
    list_args, defaults = p[2]
    args = [p[1]] + list_args
    p[0] = ast.arguments(args=args, defaults=defaults, vararg=None, kwarg=None)


def p_varargslist10(p):
    ''' varargslist : fpdef varargslist_list COMMA '''
    # def f((a, b), c,): pass
    # def f((a, b), c, d=4,): pass
    list_args, defaults = p[2]
    args = [p[1]] + list_args
    p[0] = ast.arguments(args=args, defaults=defaults, vararg=None, kwarg=None)


def p_varargslist11(p):
    ''' varargslist : fpdef EQUAL test COMMA STAR NAME '''
    # def f(a=1, *args): pass
    # def f((a,b)=(1,2), *args): pass
    p[0] = ast.arguments(args=[p[1]], defaults=[p[3]], vararg=p[6], kwarg=None)


def p_varargslist12(p):
    ''' varargslist : fpdef EQUAL test COMMA STAR NAME COMMA DOUBLESTAR NAME '''
    # def f(a=1, *args, **kwargs): pass
    # def f((a,b)=(1,2), *args, **kwargs): pass
    p[0] = ast.arguments(args=[p[1]], defaults=[p[3]], vararg=p[6], kwarg=p[9])


def p_varargslist13(p):
    ''' varargslist : fpdef EQUAL test COMMA DOUBLESTAR NAME '''
    # def f(a=1, **kwargs): pass
    # def f((a,b)=(1,2), **kwargs): pass
    p[0] = ast.arguments(args=[p[1]], defaults=[p[3]], vararg=None, kwarg=p[6])


def p_varargslist14(p):
    ''' varargslist : fpdef EQUAL test '''
    # def f(a=1): pass
    # def f((a,b)=(1,2)): pass
    p[0] = ast.arguments(args=[p[1]], defaults=[p[3]], vararg=None, kwarg=None)


def p_varargslist15(p):
    ''' varargslist : fpdef EQUAL test COMMA '''
    # def f(a=1,): pass
    # def f((a,b)=(1,2),): pass
    p[0] = ast.arguments(args=[p[1]], defaults=[p[3]], vararg=None, kwarg=None)


def p_varargslist16(p):
    ''' varargslist : fpdef EQUAL test varargslist_list COMMA STAR NAME '''
    # def f(a=1, b=2, *args): pass
    list_args, list_defaults = p[4]
    if len(list_args) != len(list_defaults):
        msg = 'non-default argument follows default argument.'
        tok = FakeToken(p.lexer.lexer, p.lineno(2))
        syntax_error(msg, tok)
    args = [p[1]] + list_args
    defaults = [p[3]] + list_defaults
    p[0] = ast.arguments(args=args, defaults=defaults, vararg=p[7], kwarg=None)


def p_varargslist17(p):
    ''' varargslist : fpdef EQUAL test varargslist_list COMMA STAR NAME COMMA DOUBLESTAR NAME '''
    # def f(a=1, b=2, *args, **kwargs)
    list_args, list_defaults = p[4]
    if len(list_args) != len(list_defaults):
        msg = 'non-default argument follows default argument.'
        tok = FakeToken(p.lexer.lexer, p.lineno(2))
        syntax_error(msg, tok)
    args = [p[1]] + list_args
    defaults = [p[3]] + list_defaults
    p[0] = ast.arguments(args=args, defaults=defaults, vararg=p[7], kwarg=p[10])


def p_varargslist18(p):
    ''' varargslist : fpdef EQUAL test varargslist_list COMMA DOUBLESTAR NAME '''
    # def f(a=1, b=2, **kwargs): pass
    list_args, list_defaults = p[4]
    if len(list_args) != len(list_defaults):
        msg = 'non-default argument follows default argument.'
        tok = FakeToken(p.lexer.lexer, p.lineno(2))
        syntax_error(msg, tok)
    args = [p[1]] + list_args
    defaults = [p[3]] + list_defaults
    p[0] = ast.arguments(args=args, defaults=defaults, vararg=None, kwarg=p[7])


def p_varargslist19(p):
    ''' varargslist : fpdef EQUAL test varargslist_list '''
    # def f(a=1, b=2): pass
    list_args, list_defaults = p[4]
    if len(list_args) != len(list_defaults):
        msg = 'non-default argument follows default argument.'
        tok = FakeToken(p.lexer.lexer, p.lineno(2))
        syntax_error(msg, tok)
    args = [p[1]] + list_args
    defaults = [p[3]] + list_defaults
    p[0] = ast.arguments(args=args, defaults=defaults, vararg=None, kwarg=None)


def p_varargslist20(p):
    ''' varargslist : fpdef EQUAL test varargslist_list COMMA '''
    # def f(a=1, b=2,): pass
    list_args, list_defaults = p[4]
    if len(list_args) != len(list_defaults):
        msg = 'non-default argument follows default argument.'
        tok = FakeToken(p.lexer.lexer, p.lineno(2))
        syntax_error(msg, tok)
    args = [p[1]] + list_args
    defaults = [p[3]] + list_defaults
    p[0] = ast.arguments(args=args, defaults=defaults, vararg=None, kwarg=None)


def p_varargslist21(p):
    ''' varargslist : STAR NAME '''
    # def f(*args): pass
    p[0] = ast.arguments(args=[], defaults=[], vararg=p[2], kwarg=None)


def p_varargslist22(p):
    ''' varargslist : STAR NAME COMMA DOUBLESTAR NAME '''
    # def f(*args, **kwargs): pass
    p[0] = ast.arguments(args=[], defaults=[], vararg=p[2], kwarg=p[5])


def p_varargslist23(p):
    ''' varargslist : DOUBLESTAR NAME '''
    # def f(**kwargs): pass
    p[0] = ast.arguments(args=[], defaults=[], vararg=None, kwarg=p[2])


# The varargslist_list handlers return a 2-tuple of (args, defaults) lists
def p_varargslist_list1(p):
    ''' varargslist_list : COMMA fpdef '''
    p[0] = ([p[2]], [])


def p_varargslist_list2(p):
    ''' varargslist_list : COMMA fpdef EQUAL test '''
    p[0] = ([p[2]], [p[4]])


def p_varargslist_list3(p):
    ''' varargslist_list : varargslist_list COMMA fpdef '''
    list_args, list_defaults = p[1]
    if list_defaults:
        msg = 'non-default argument follows default argument.'
        tok = FakeToken(p.lexer.lexer, p.lineno(2))
        syntax_error(msg, tok)
    args = list_args + [p[3]]
    p[0] = (args, list_defaults)


def p_varargslist_list4(p):
    ''' varargslist_list : varargslist_list COMMA fpdef EQUAL test '''
    list_args, list_defaults = p[1]
    args = list_args + [p[3]]
    defaults = list_defaults + [p[5]]
    p[0] = (args, defaults)


def p_fpdef1(p):
    ''' fpdef : NAME '''
    p[0] = ast.Name(id=p[1], ctx=ast.Param(), lineno=p.lineno(1))


def p_fpdef2(p):
    ''' fpdef : LPAR fplist RPAR '''
    # fplist will return a NAME or a TUPLE, so we don't need that
    # logic here.
    p[0] = p[2]


def p_fplist1(p):
    ''' fplist : fpdef '''
    p[0] = p[1]


def p_fplist2(p):
    ''' fplist : fpdef COMMA '''
    tup = ast.Tuple()
    tup.elts = [p[1]]
    set_context(tup, Store, p)
    p[0] = tup


def p_fplist3(p):
    ''' fplist : fpdef fplist_list '''
    elts = [p[1]] + p[2]
    tup = ast.Tuple()
    tup.elts = elts
    set_context(tup, Store, p)
    p[0] = tup


def p_fplist4(p):
    ''' fplist : fpdef fplist_list COMMA '''
    elts = [p[1]] + p[2]
    tup = ast.Tuple()
    tup.elts = elts
    set_context(tup, Store, p)
    p[0] = tup


def p_fplist_list1(p):
    ''' fplist_list : COMMA fpdef '''
    p[0] = [p[2]]


def p_fplist_list2(p):
    ''' fplist_list : fplist_list COMMA fpdef '''
    p[0] = p[1] + [p[3]]


def p_error(t):
    msg = 'invalid syntax'
    lexer = t.lexer
    # Ply has a weird thing where sometimes we get the EnamlLexer and
    # other times we get the Ply lexer
    if isinstance(lexer, EnamlLexer):
        lexer = lexer.lexer
    syntax_error(msg, FakeToken(lexer, t.lineno))


#==============================================================================
# End Parsing Rules
#==============================================================================
# Get a save directory for the lex and parse tables
_parse_dir = os.path.join(os.path.dirname(__file__), 'parse_tab')
_parse_module = 'enaml.core.parse_tab.parsetab'
_parser = yacc.yacc(
    debug=0, outputdir=_parse_dir, tabmodule=_parse_module, optimize=1,
    errorlog=yacc.NullLogger(),
)


def parse(enaml_source, filename='Enaml'):
    # All errors in the parsing and lexing rules are raised as a custom
    # ParsingError. This exception object can be called to return the
    # actual exception instance that should be raised. This is done
    # because Ply enters an error recovery mode whenever a SyntaxError
    # is raised from within a rule. We don't want error recovery, we'd
    # rather just fail immediately. So this mechanism allows us to
    # stop parsing immediately and then re-raise the errors outside
    # of the control of Ply.
    try:
        lexer = EnamlLexer(filename)
        return _parser.parse(enaml_source, debug=0, lexer=lexer)
    except ParsingError as parse_error:
        raise parse_error()

########NEW FILE########
__FILENAME__ = lextab
# enaml.core.parse_tab.lextab.py. This file automatically created by PLY (version 3.4). Don't edit!
_tabversion   = '3.4'
_lextokens    = {'LPAR': 1, 'ENDMARKER': 1, 'LESS': 1, 'AMPEREQUAL': 1, 'CIRCUMFLEX': 1, 'WS': 1, 'WITH': 1, 'MINUS': 1, 'NEWLINE': 1, 'EXCEPT': 1, 'PLUS': 1, 'PERCENTEQUAL': 1, 'ELLIPSIS': 1, 'EQEQUAL': 1, 'RIGHTSHIFTEQUAL': 1, 'EXEC': 1, 'AMPER': 1, 'STRING_START_SINGLE': 1, 'SLASH': 1, 'PASS': 1, 'NAME': 1, 'INDENT': 1, 'MINUSEQUAL': 1, 'ENAMLDEF': 1, 'DEDENT': 1, 'STRING_START_TRIPLE': 1, 'STAR': 1, 'NOTEQUAL': 1, 'PRINT': 1, 'DOUBLESTAR': 1, 'DEF': 1, 'CIRCUMFLEXEQUAL': 1, 'COLON': 1, 'DOUBLECOLON': 1, 'TEMPLATE': 1, 'FOR': 1, 'DOUBLESTAREQUAL': 1, 'ELSE': 1, 'TRY': 1, 'AND': 1, 'LBRACE': 1, 'AS': 1, 'OR': 1, 'LEFTSHIFT': 1, 'CONTINUE': 1, 'NOT': 1, 'LAMBDA': 1, 'RAISE': 1, 'GLOBAL': 1, 'WHILE': 1, 'VBAR': 1, 'RETURN': 1, 'DOT': 1, 'LEFTSHIFTEQUAL': 1, 'TILDE': 1, 'RSQB': 1, 'PERCENT': 1, 'DOUBLESLASH': 1, 'RBRACE': 1, 'EQUAL': 1, 'PLUSEQUAL': 1, 'IMPORT': 1, 'LESSEQUAL': 1, 'LSQB': 1, 'RIGHTARROW': 1, 'GREATER': 1, 'VBAREQUAL': 1, 'BREAK': 1, 'STRING_CONTINUE': 1, 'DEL': 1, 'STAREQUAL': 1, 'ELIF': 1, 'CONST': 1, 'SLASHEQUAL': 1, 'NUMBER': 1, 'RPAR': 1, 'ASSERT': 1, 'STRING_END': 1, 'GREATEREQUAL': 1, 'SEMI': 1, 'DOUBLESLASHEQUAL': 1, 'COMMA': 1, 'CLASS': 1, 'RIGHTSHIFT': 1, 'STRING': 1, 'COLONEQUAL': 1, 'IS': 1, 'YIELD': 1, 'ALIAS': 1, 'FINALLY': 1, 'AT': 1, 'PRAGMA': 1, 'IN': 1, 'IF': 1, 'FROM': 1}
_lexreflags   = 0
_lexliterals  = ''
_lexstateinfo = {'TRIPLEQ2': 'exclusive', 'TRIPLEQ1': 'exclusive', 'INITIAL': 'inclusive', 'SINGLEQ2': 'exclusive', 'SINGLEQ1': 'exclusive'}
_lexstatere   = {'TRIPLEQ2': [('(?P<t_SINGLEQ1_SINGLEQ2_TRIPLEQ1_TRIPLEQ2_escaped>\\\\(.|\\n))|(?P<t_TRIPLEQ2_simple>[^"\\\\]+)|(?P<t_TRIPLEQ2_q2_but_not_triple>"(?!""))|(?P<t_TRIPLEQ2_end>""")', [None, ('t_SINGLEQ1_SINGLEQ2_TRIPLEQ1_TRIPLEQ2_escaped', 'escaped'), None, ('t_TRIPLEQ2_simple', 'simple'), ('t_TRIPLEQ2_q2_but_not_triple', 'q2_but_not_triple'), ('t_TRIPLEQ2_end', 'end')])], 'TRIPLEQ1': [("(?P<t_SINGLEQ1_SINGLEQ2_TRIPLEQ1_TRIPLEQ2_escaped>\\\\(.|\\n))|(?P<t_TRIPLEQ1_simple>[^'\\\\]+)|(?P<t_TRIPLEQ1_q1_but_not_triple>'(?!''))|(?P<t_TRIPLEQ1_end>''')", [None, ('t_SINGLEQ1_SINGLEQ2_TRIPLEQ1_TRIPLEQ2_escaped', 'escaped'), None, ('t_TRIPLEQ1_simple', 'simple'), ('t_TRIPLEQ1_q1_but_not_triple', 'q1_but_not_triple'), ('t_TRIPLEQ1_end', 'end')])], 'INITIAL': [('(?P<t_comment>[ ]*\\#[^\\r\\n]*)|(?P<t_WS> [ \\t\\f]+ )|(?P<t_escaped_newline>\\\\\\n)|(?P<t_newline>\\n+)|(?P<t_LPAR>\\()|(?P<t_RPAR>\\))|(?P<t_LBRACE>\\{)|(?P<t_RBRACE>\\})|(?P<t_LSQB>\\[)|(?P<t_RSQB>\\])|(?P<t_start_triple_quoted_q1_string>[uU]?[rR]?\'\'\')|(?P<t_start_triple_quoted_q2_string>[uU]?[rR]?""")|(?P<t_start_single_quoted_q1_string>[uU]?[rR]?\')|(?P<t_start_single_quoted_q2_string>[uU]?[rR]?")|(?P<t_NAME>[a-zA-Z_][a-zA-Z0-9_]*)|(?P<t_NUMBER>((\\d+[jJ]|((\\d+\\.\\d*|\\.\\d+)([eE][-+]?\\d+)?|\\d+[eE][-+]?\\d+)[jJ])|((\\d+\\.\\d*|\\.\\d+)([eE][-+]?\\d+)?|\\d+[eE][-+]?\\d+)|(0[xX][\\da-fA-F]+[lL]?|0[bB][01]+[lL]?|(0[oO][0-7]+)|(0[0-7]*)[lL]?|[1-9]\\d*[lL]?)))|(?P<t_PRAGMA>\\$pragma)|(?P<t_ELLIPSIS>\\.\\.\\.)|(?P<t_DOUBLESTAREQUAL>\\*\\*=)|(?P<t_DOUBLESTAR>\\*\\*)|(?P<t_LEFTSHIFTEQUAL><<=)|(?P<t_RIGHTSHIFTEQUAL>>>=)|(?P<t_VBAREQUAL>\\|=)|(?P<t_STAREQUAL>\\*=)|(?P<t_CIRCUMFLEXEQUAL>\\^=)|(?P<t_DOUBLESLASHEQUAL>//=)|(?P<t_PLUSEQUAL>\\+=)|(?P<t_VBAR>\\|)|(?P<t_LEFTSHIFT><<)|(?P<t_EQEQUAL>==)|(?P<t_PLUS>\\+)|(?P<t_PERCENTEQUAL>%=)|(?P<t_SLASHEQUAL>/=)|(?P<t_RIGHTARROW>=>)|(?P<t_COLONEQUAL>:=)|(?P<t_NOTEQUAL>!=)|(?P<t_STAR>\\*)|(?P<t_GREATEREQUAL>>=)|(?P<t_CIRCUMFLEX>\\^)|(?P<t_DOUBLESLASH>//)|(?P<t_DOT>\\.)|(?P<t_MINUSEQUAL>-=)|(?P<t_DOUBLECOLON>::)|(?P<t_AMPEREQUAL>&=)|(?P<t_RIGHTSHIFT>>>)|(?P<t_LESSEQUAL><=)|(?P<t_EQUAL>=)|(?P<t_AMPER>&)|(?P<t_SLASH>/)|(?P<t_GREATER>>)|(?P<t_LESS><)|(?P<t_COMMA>,)|(?P<t_PERCENT>%)|(?P<t_TILDE>~)|(?P<t_SEMI>;)|(?P<t_MINUS>-)|(?P<t_COLON>:)|(?P<t_AT>@)', [None, ('t_comment', 'comment'), ('t_WS', 'WS'), ('t_escaped_newline', 'escaped_newline'), ('t_newline', 'newline'), ('t_LPAR', 'LPAR'), ('t_RPAR', 'RPAR'), ('t_LBRACE', 'LBRACE'), ('t_RBRACE', 'RBRACE'), ('t_LSQB', 'LSQB'), ('t_RSQB', 'RSQB'), ('t_start_triple_quoted_q1_string', 'start_triple_quoted_q1_string'), ('t_start_triple_quoted_q2_string', 'start_triple_quoted_q2_string'), ('t_start_single_quoted_q1_string', 'start_single_quoted_q1_string'), ('t_start_single_quoted_q2_string', 'start_single_quoted_q2_string'), ('t_NAME', 'NAME'), (None, 'NUMBER'), None, None, None, None, None, None, None, None, None, None, None, (None, 'PRAGMA'), (None, 'ELLIPSIS'), (None, 'DOUBLESTAREQUAL'), (None, 'DOUBLESTAR'), (None, 'LEFTSHIFTEQUAL'), (None, 'RIGHTSHIFTEQUAL'), (None, 'VBAREQUAL'), (None, 'STAREQUAL'), (None, 'CIRCUMFLEXEQUAL'), (None, 'DOUBLESLASHEQUAL'), (None, 'PLUSEQUAL'), (None, 'VBAR'), (None, 'LEFTSHIFT'), (None, 'EQEQUAL'), (None, 'PLUS'), (None, 'PERCENTEQUAL'), (None, 'SLASHEQUAL'), (None, 'RIGHTARROW'), (None, 'COLONEQUAL'), (None, 'NOTEQUAL'), (None, 'STAR'), (None, 'GREATEREQUAL'), (None, 'CIRCUMFLEX'), (None, 'DOUBLESLASH'), (None, 'DOT'), (None, 'MINUSEQUAL'), (None, 'DOUBLECOLON'), (None, 'AMPEREQUAL'), (None, 'RIGHTSHIFT'), (None, 'LESSEQUAL'), (None, 'EQUAL'), (None, 'AMPER'), (None, 'SLASH'), (None, 'GREATER'), (None, 'LESS'), (None, 'COMMA'), (None, 'PERCENT'), (None, 'TILDE'), (None, 'SEMI'), (None, 'MINUS'), (None, 'COLON'), (None, 'AT')])], 'SINGLEQ2': [('(?P<t_SINGLEQ1_SINGLEQ2_TRIPLEQ1_TRIPLEQ2_escaped>\\\\(.|\\n))|(?P<t_SINGLEQ2_simple>[^"\\\\\\n]+)|(?P<t_SINGLEQ2_end>")', [None, ('t_SINGLEQ1_SINGLEQ2_TRIPLEQ1_TRIPLEQ2_escaped', 'escaped'), None, ('t_SINGLEQ2_simple', 'simple'), ('t_SINGLEQ2_end', 'end')])], 'SINGLEQ1': [("(?P<t_SINGLEQ1_SINGLEQ2_TRIPLEQ1_TRIPLEQ2_escaped>\\\\(.|\\n))|(?P<t_SINGLEQ1_simple>[^'\\\\\\n]+)|(?P<t_SINGLEQ1_end>')", [None, ('t_SINGLEQ1_SINGLEQ2_TRIPLEQ1_TRIPLEQ2_escaped', 'escaped'), None, ('t_SINGLEQ1_simple', 'simple'), ('t_SINGLEQ1_end', 'end')])]}
_lexstateignore = {'TRIPLEQ2': '', 'TRIPLEQ1': '', 'INITIAL': '', 'SINGLEQ2': '', 'SINGLEQ1': ''}
_lexstateerrorf = {'TRIPLEQ2': 't_TRIPLEQ2_error', 'TRIPLEQ1': 't_TRIPLEQ1_error', 'INITIAL': 't_error', 'SINGLEQ2': 't_SINGLEQ2_error', 'SINGLEQ1': 't_SINGLEQ1_error'}

########NEW FILE########
__FILENAME__ = parsetab

# c:\users\i341972\development\enaml\enaml\core\parse_tab\parsetab.py
# This file is automatically generated. Do not edit.
_tabversion = '3.2'

_lr_method = 'LALR'

_lr_signature = '=\x07G\xdb.X\xdc9-:\x90\xe0\x18\xf2\xa2\x80'
    
_lr_action_items = {'LPAR':([0,1,6,7,9,10,13,14,15,17,19,25,29,30,31,32,34,36,40,42,44,45,46,51,54,55,57,58,60,62,64,68,69,71,78,79,80,88,89,92,93,96,97,102,103,104,109,110,111,113,115,119,120,121,122,123,124,125,126,127,128,129,130,131,132,136,137,138,139,140,141,143,147,150,151,153,158,160,163,164,166,168,169,171,172,173,174,180,187,191,193,194,195,196,197,199,201,202,203,204,205,206,207,210,212,213,216,217,223,224,226,228,229,231,232,233,241,242,252,254,256,259,261,264,266,268,270,271,273,278,279,280,282,285,286,287,289,290,299,300,301,304,307,309,313,314,316,319,320,321,324,325,327,329,330,331,335,336,339,342,346,348,354,356,359,360,363,366,367,368,369,373,377,378,380,381,383,387,388,390,391,392,396,404,407,412,425,434,440,444,447,448,456,457,458,460,463,465,468,470,472,475,478,481,487,489,491,494,496,498,499,501,504,506,507,511,518,519,521,522,534,536,537,538,539,540,541,542,543,544,547,548,551,556,558,564,569,571,578,579,583,585,586,596,597,598,601,603,604,606,608,609,611,614,615,618,627,631,632,635,644,645,650,651,652,656,659,660,661,663,664,668,669,671,672,673,675,676,685,686,689,690,693,699,702,703,705,709,711,712,721,722,724,725,726,727,730,738,753,754,755,757,758,759,761,764,765,767,771,774,790,791,796,798,800,817,818,819,820,821,823,],[1,1,-220,1,-11,1,-76,1,-135,-223,-219,-217,-221,1,-379,1,1,-380,1,-10,-136,1,-8,1,-9,168,174,1,1,-7,1,-222,1,-377,-378,1,1,1,1,-224,1,-218,-370,-137,1,-138,1,1,1,1,1,1,-205,-196,-200,-195,1,-198,-202,-197,-201,-204,-206,-203,-199,1,1,-261,-260,250,1,-381,1,1,259,1,1,1,-375,1,1,1,168,1,1,-368,174,1,-297,-373,-323,1,-319,-318,-326,-321,-324,-322,-320,323,-77,-12,-6,1,1,329,331,333,-372,1,1,-371,1,1,1,1,1,1,1,1,1,174,1,1,-131,1,-376,1,1,1,-396,1,1,1,-369,-399,1,1,1,174,1,1,1,-298,-374,1,1,-327,1,-325,1,1,1,1,1,1,1,438,441,1,-248,1,1,1,1,1,1,1,-243,-238,1,1,-397,1,1,1,-453,1,1,1,-398,174,174,-233,-299,1,-257,-225,528,1,-249,1,-254,1,1,-242,1,1,1,1,-454,1,1,174,174,1,1,-300,1,-80,-88,-78,-79,1,1,1,-230,1,-226,-227,-235,-132,1,1,-244,1,1,1,-237,1,1,1,1,1,174,1,174,-89,-258,1,-229,1,-228,1,-13,-28,-25,-14,-27,-26,-239,-240,-245,1,-453,1,-234,1,1,1,693,1,-259,1,-232,1,1,1,1,-65,1,-29,1,1,1,1,1,-454,1,1,693,-81,1,-231,-45,-47,-66,-15,-16,-73,693,-40,-236,1,-246,-247,1,1,-43,1,-72,-71,-69,-70,-17,259,259,-241,-82,1,-46,-48,-41,1,1,-44,-18,1,1,-42,1,]),'ENDMARKER':([0,6,8,9,13,15,17,19,25,29,42,43,44,46,54,62,68,79,92,96,102,104,138,139,156,205,206,207,266,346,367,368,404,425,434,447,456,460,498,499,501,504,518,521,522,534,536,539,543,571,578,583,586,597,598,601,603,604,606,608,609,611,627,650,652,663,668,690,699,702,703,705,709,711,712,722,724,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,821,],[2,-220,107,-11,-76,-135,-223,-219,-217,-221,-10,155,-136,-8,-9,-7,-222,-5,-224,-218,-137,-138,-261,-260,263,-77,-12,-6,-131,-248,-243,-238,-233,-257,-225,-249,-254,-242,-80,-88,-78,-79,-230,-226,-227,-235,-132,-244,-237,-89,-258,-229,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,-232,-65,-29,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,-42,]),'NOTEQUAL':([11,12,24,31,33,36,38,39,53,55,71,72,78,97,108,112,114,116,134,135,143,146,152,154,163,165,167,169,173,184,191,198,223,228,235,236,237,238,239,240,247,248,249,255,262,270,275,276,277,279,286,287,288,313,318,349,357,364,377,384,391,413,],[-352,-332,-346,-379,-328,-380,-360,-336,-340,-364,-377,193,-378,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-375,-342,-341,-366,-368,-363,-373,193,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-376,-344,-345,-343,-396,-369,-399,-365,-374,-316,-335,-331,-339,-397,-367,-398,-317,]),'AMPEREQUAL':([11,12,16,20,24,28,31,33,36,38,39,48,50,53,55,71,72,78,81,83,97,108,112,114,116,134,135,143,146,152,154,159,163,165,167,169,173,184,191,198,209,211,212,215,223,228,235,236,237,238,239,240,247,248,249,255,262,269,270,275,276,277,279,286,287,288,303,313,318,326,327,328,349,357,364,371,377,384,391,401,413,421,422,450,],[-352,-332,123,-303,-346,-301,-379,-328,-380,-360,-336,-304,-312,-340,-364,-377,-314,-378,-308,-211,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-305,-375,-342,-341,-366,-368,-363,-373,-315,-309,-213,-212,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-306,-376,-344,-345,-343,-396,-369,-399,-365,-479,-374,-316,-310,-214,-215,-335,-331,-339,-307,-397,-367,-398,-480,-317,-311,-216,-302,]),'CIRCUMFLEX':([11,12,24,31,36,38,39,53,55,71,78,97,108,112,114,116,134,135,143,152,154,163,165,167,169,173,184,191,223,228,235,236,237,238,239,240,247,248,249,262,270,275,276,277,279,286,287,288,313,349,364,377,384,391,],[-352,115,-346,-379,-380,-360,-336,-340,-364,-377,-378,-370,-361,-354,-353,241,-347,-348,-381,-337,-362,-375,-342,-341,-366,-368,-363,-373,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-338,-376,-344,-345,-343,-396,-369,-399,-365,-374,-335,-339,-397,-367,-398,]),'WITH':([0,6,9,13,15,17,19,25,29,42,44,46,54,62,68,79,92,96,102,104,138,139,205,206,207,266,346,366,367,368,404,425,434,447,456,458,460,498,499,501,504,518,521,522,534,536,539,543,571,578,583,586,597,598,601,603,604,606,608,609,611,627,650,652,663,668,690,699,702,703,705,709,711,712,722,724,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,821,],[7,-220,-11,-76,-135,-223,-219,-217,-221,-10,-136,-8,-9,-7,-222,7,-224,-218,-137,-138,-261,-260,-77,-12,-6,-131,-248,7,-243,-238,-233,-257,-225,-249,-254,7,-242,-80,-88,-78,-79,-230,-226,-227,-235,-132,-244,-237,-89,-258,-229,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,-232,-65,-29,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,-42,]),'MINUS':([0,1,6,7,9,10,11,13,14,15,17,19,24,25,29,30,31,32,34,36,38,40,42,44,45,46,51,54,55,58,60,62,64,68,69,71,78,79,80,88,89,92,93,96,97,102,103,104,108,109,110,111,112,113,114,115,119,120,121,122,123,124,125,126,127,128,129,130,131,132,134,135,136,137,138,139,141,143,147,150,153,154,158,160,163,164,166,168,169,171,172,173,180,184,191,193,194,195,196,197,199,201,202,203,205,206,207,210,212,223,224,226,228,229,231,232,233,235,236,237,238,239,241,242,247,248,249,252,254,256,261,264,266,268,270,271,273,278,279,280,282,285,286,287,288,289,290,299,301,304,307,313,314,316,319,320,321,324,325,327,329,330,331,335,342,346,348,354,356,359,360,363,366,367,368,369,373,377,378,380,381,383,384,387,388,390,391,404,412,425,434,444,447,448,456,457,458,460,463,465,468,470,472,475,478,489,491,496,498,499,501,504,506,507,511,518,519,521,522,534,536,537,538,539,540,541,542,543,544,547,548,551,556,564,571,578,579,583,585,586,596,597,598,601,603,604,606,608,609,611,614,615,618,627,631,632,635,645,650,651,652,656,659,660,661,663,664,668,669,671,672,673,675,676,685,686,690,693,699,702,703,705,709,711,712,722,724,725,726,727,730,738,753,754,755,757,758,759,761,767,771,774,790,791,796,798,800,817,818,819,820,821,823,],[40,40,-220,40,-11,40,-352,-76,40,-135,-223,-219,137,-217,-221,40,-379,40,40,-380,-360,40,-10,-136,40,-8,40,-9,-364,40,40,-7,40,-222,40,-377,-378,40,40,40,40,-224,40,-218,-370,-137,40,-138,-361,40,40,40,-354,40,-353,40,40,-205,-196,-200,-195,40,-198,-202,-197,-201,-204,-206,-203,-199,137,-348,40,40,-261,-260,40,-381,40,40,40,-362,40,40,-375,40,40,40,-366,40,40,-368,40,-363,-373,-323,40,-319,-318,-326,-321,-324,-322,-320,-77,-12,-6,40,40,-372,40,40,-371,40,40,40,40,-356,-358,-359,-357,-355,40,40,-349,-350,-351,40,40,40,40,40,-131,40,-376,40,40,40,-396,40,40,40,-369,-399,-365,40,40,40,40,40,40,-374,40,40,-327,40,-325,40,40,40,40,40,40,40,40,-248,40,40,40,40,40,40,40,-243,-238,40,40,-397,40,40,40,-453,-367,40,40,40,-398,-233,40,-257,-225,40,-249,40,-254,40,40,-242,40,40,40,40,-454,40,40,40,40,40,-80,-88,-78,-79,40,40,40,-230,40,-226,-227,-235,-132,40,40,-244,40,40,40,-237,40,40,40,40,40,40,-89,-258,40,-229,40,-228,40,-13,-28,-25,-14,-27,-26,-239,-240,-245,40,-453,40,-234,40,40,40,40,-259,40,-232,40,40,40,40,-65,40,-29,40,40,40,40,40,-454,40,40,-81,40,-231,-45,-47,-66,-15,-16,-73,-40,-236,40,-246,-247,40,40,-43,40,-72,-71,-69,-70,-17,-241,-82,40,-46,-48,-41,40,40,-44,-18,40,40,-42,40,]),'LESS':([11,12,24,31,33,36,38,39,53,55,71,72,78,97,108,112,114,116,134,135,143,146,152,154,163,165,167,169,173,184,191,198,223,228,235,236,237,238,239,240,247,248,249,255,262,270,275,276,277,279,286,287,288,313,318,349,357,364,377,384,391,413,],[-352,-332,-346,-379,-328,-380,-360,-336,-340,-364,-377,196,-378,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-375,-342,-341,-366,-368,-363,-373,196,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-376,-344,-345,-343,-396,-369,-399,-365,-374,-316,-335,-331,-339,-397,-367,-398,-317,]),'EXCEPT':([102,104,266,267,367,536,539,611,726,727,],[-137,-138,-131,369,369,-132,-244,-245,-246,-247,]),'PLUS':([0,1,6,7,9,10,11,13,14,15,17,19,24,25,29,30,31,32,34,36,38,40,42,44,45,46,51,54,55,58,60,62,64,68,69,71,78,79,80,88,89,92,93,96,97,102,103,104,108,109,110,111,112,113,114,115,119,120,121,122,123,124,125,126,127,128,129,130,131,132,134,135,136,137,138,139,141,143,147,150,153,154,158,160,163,164,166,168,169,171,172,173,180,184,191,193,194,195,196,197,199,201,202,203,205,206,207,210,212,223,224,226,228,229,231,232,233,235,236,237,238,239,241,242,247,248,249,252,254,256,261,264,266,268,270,271,273,278,279,280,282,285,286,287,288,289,290,299,301,304,307,313,314,316,319,320,321,324,325,327,329,330,331,335,342,346,348,354,356,359,360,363,366,367,368,369,373,377,378,380,381,383,384,387,388,390,391,404,412,425,434,444,447,448,456,457,458,460,463,465,468,470,472,475,478,489,491,496,498,499,501,504,506,507,511,518,519,521,522,534,536,537,538,539,540,541,542,543,544,547,548,551,556,564,571,578,579,583,585,586,596,597,598,601,603,604,606,608,609,611,614,615,618,627,631,632,635,645,650,651,652,656,659,660,661,663,664,668,669,671,672,673,675,676,685,686,690,693,699,702,703,705,709,711,712,722,724,725,726,727,730,738,753,754,755,757,758,759,761,767,771,774,790,791,796,798,800,817,818,819,820,821,823,],[10,10,-220,10,-11,10,-352,-76,10,-135,-223,-219,136,-217,-221,10,-379,10,10,-380,-360,10,-10,-136,10,-8,10,-9,-364,10,10,-7,10,-222,10,-377,-378,10,10,10,10,-224,10,-218,-370,-137,10,-138,-361,10,10,10,-354,10,-353,10,10,-205,-196,-200,-195,10,-198,-202,-197,-201,-204,-206,-203,-199,136,-348,10,10,-261,-260,10,-381,10,10,10,-362,10,10,-375,10,10,10,-366,10,10,-368,10,-363,-373,-323,10,-319,-318,-326,-321,-324,-322,-320,-77,-12,-6,10,10,-372,10,10,-371,10,10,10,10,-356,-358,-359,-357,-355,10,10,-349,-350,-351,10,10,10,10,10,-131,10,-376,10,10,10,-396,10,10,10,-369,-399,-365,10,10,10,10,10,10,-374,10,10,-327,10,-325,10,10,10,10,10,10,10,10,-248,10,10,10,10,10,10,10,-243,-238,10,10,-397,10,10,10,-453,-367,10,10,10,-398,-233,10,-257,-225,10,-249,10,-254,10,10,-242,10,10,10,10,-454,10,10,10,10,10,-80,-88,-78,-79,10,10,10,-230,10,-226,-227,-235,-132,10,10,-244,10,10,10,-237,10,10,10,10,10,10,-89,-258,10,-229,10,-228,10,-13,-28,-25,-14,-27,-26,-239,-240,-245,10,-453,10,-234,10,10,10,10,-259,10,-232,10,10,10,10,-65,10,-29,10,10,10,10,10,-454,10,10,-81,10,-231,-45,-47,-66,-15,-16,-73,-40,-236,10,-246,-247,10,10,-43,10,-72,-71,-69,-70,-17,-241,-82,10,-46,-48,-41,10,10,-44,-18,10,10,-42,10,]),'PERCENTEQUAL':([11,12,16,20,24,28,31,33,36,38,39,48,50,53,55,71,72,78,81,83,97,108,112,114,116,134,135,143,146,152,154,159,163,165,167,169,173,184,191,198,209,211,212,215,223,228,235,236,237,238,239,240,247,248,249,255,262,269,270,275,276,277,279,286,287,288,303,313,318,326,327,328,349,357,364,371,377,384,391,401,413,421,422,450,],[-352,-332,128,-303,-346,-301,-379,-328,-380,-360,-336,-304,-312,-340,-364,-377,-314,-378,-308,-211,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-305,-375,-342,-341,-366,-368,-363,-373,-315,-309,-213,-212,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-306,-376,-344,-345,-343,-396,-369,-399,-365,-479,-374,-316,-310,-214,-215,-335,-331,-339,-307,-397,-367,-398,-480,-317,-311,-216,-302,]),'IMPORT':([0,6,9,13,15,17,19,25,29,42,44,46,54,62,68,79,92,96,102,103,104,138,139,158,187,205,206,207,219,220,221,222,229,232,266,307,309,330,335,337,338,340,346,348,363,366,367,368,404,407,425,434,447,456,457,458,460,463,465,494,498,499,501,504,511,518,521,522,534,536,537,538,539,541,543,564,571,578,579,583,585,586,597,598,601,603,604,606,608,609,611,627,650,651,652,663,664,668,669,671,672,690,699,702,703,705,709,711,712,722,724,725,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,819,820,821,],[67,-220,-11,-76,-135,-223,-219,-217,-221,-10,-136,-8,-9,-7,-222,67,-224,-218,-137,67,-138,-261,-260,67,-297,-77,-12,-6,336,-281,339,-279,67,67,-131,67,-298,67,67,440,-282,-280,-248,67,67,67,-243,-238,-233,-299,-257,-225,-249,-254,67,67,-242,67,67,-300,-80,-88,-78,-79,67,-230,-226,-227,-235,-132,67,67,-244,67,-237,67,-89,-258,67,-229,67,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,67,-232,-65,67,-29,67,67,67,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,67,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,67,67,-42,]),'EQEQUAL':([11,12,24,31,33,36,38,39,53,55,71,72,78,97,108,112,114,116,134,135,143,146,152,154,163,165,167,169,173,184,191,198,223,228,235,236,237,238,239,240,247,248,249,255,262,270,275,276,277,279,286,287,288,313,318,349,357,364,377,384,391,413,],[-352,-332,-346,-379,-328,-380,-360,-336,-340,-364,-377,203,-378,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-375,-342,-341,-366,-368,-363,-373,203,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-376,-344,-345,-343,-396,-369,-399,-365,-374,-316,-335,-331,-339,-397,-367,-398,-317,]),'RBRACE':([11,12,20,24,28,31,33,36,38,39,48,50,51,53,55,71,72,78,81,97,108,112,114,116,134,135,143,146,152,154,159,161,163,165,167,169,173,184,191,198,209,215,223,228,235,236,237,238,239,240,247,248,249,255,262,269,270,271,272,274,275,276,277,279,286,287,288,303,313,318,326,349,357,364,371,372,373,374,377,384,391,401,413,421,450,466,467,468,469,531,544,567,568,593,594,595,655,674,687,700,728,736,],[-352,-332,-303,-346,-301,-379,-328,-380,-360,-336,-304,-312,163,-340,-364,-377,-314,-378,-308,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-305,270,-375,-342,-341,-366,-368,-363,-373,-315,-309,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-306,-376,-432,-433,-431,-344,-345,-343,-396,-369,-399,-365,-479,-374,-316,-310,-335,-331,-339,-307,-437,-434,-427,-397,-367,-398,-480,-317,-311,-302,-438,-429,-428,-426,-464,-430,-476,-475,-467,-466,-465,-468,-435,-477,-469,-436,-478,]),'EXEC':([0,6,9,13,15,17,19,25,29,42,44,46,54,62,68,79,92,96,102,103,104,138,139,158,205,206,207,229,232,266,307,330,335,346,348,363,366,367,368,404,425,434,447,456,457,458,460,463,465,498,499,501,504,511,518,521,522,534,536,537,538,539,541,543,564,571,578,579,583,585,586,597,598,601,603,604,606,608,609,611,627,650,651,652,663,664,668,669,671,672,690,699,702,703,705,709,711,712,722,724,725,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,819,820,821,],[14,-220,-11,-76,-135,-223,-219,-217,-221,-10,-136,-8,-9,-7,-222,14,-224,-218,-137,14,-138,-261,-260,14,-77,-12,-6,14,14,-131,14,14,14,-248,14,14,14,-243,-238,-233,-257,-225,-249,-254,14,14,-242,14,14,-80,-88,-78,-79,14,-230,-226,-227,-235,-132,14,14,-244,14,-237,14,-89,-258,14,-229,14,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,14,-232,-65,14,-29,14,14,14,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,14,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,14,14,-42,]),'SLASH':([11,31,36,38,55,71,78,97,108,112,114,143,154,163,169,173,184,191,223,228,235,236,237,238,239,270,279,286,287,288,313,377,384,391,],[113,-379,-380,-360,-364,-377,-378,-370,-361,-354,113,-381,-362,-375,-366,-368,-363,-373,-372,-371,-356,-358,-359,-357,-355,-376,-396,-369,-399,-365,-374,-397,-367,-398,]),'PASS':([0,6,9,13,15,17,19,25,29,42,44,46,54,62,68,79,92,96,102,103,104,138,139,158,205,206,207,229,232,266,307,330,335,346,348,363,366,367,368,404,414,425,434,447,456,457,458,460,463,465,498,499,501,504,511,518,521,522,533,534,536,537,538,539,541,543,564,570,571,578,579,583,585,586,597,598,601,603,604,606,608,609,611,627,637,638,639,640,642,643,650,651,652,662,663,664,666,668,669,671,672,688,690,691,692,695,699,702,703,705,709,711,712,714,715,716,717,719,720,722,724,725,726,727,737,743,744,745,747,749,750,752,753,755,757,758,759,761,762,763,767,771,780,783,784,786,787,788,790,791,792,796,801,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,826,827,828,831,832,833,834,835,836,838,839,],[21,-220,-11,-76,-135,-223,-219,-217,-221,-10,-136,-8,-9,-7,-222,21,-224,-218,-137,21,-138,-261,-260,21,-77,-12,-6,21,21,-131,21,21,21,-248,21,21,21,-243,-238,-233,502,-257,-225,-249,-254,21,21,-242,21,21,-80,-88,-78,-79,21,-230,-226,-227,605,-235,-132,21,21,-244,21,-237,21,502,-89,-258,21,-229,21,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-85,-102,-87,502,-86,-83,-259,21,-232,605,-65,21,605,-29,21,21,21,-103,-81,-84,502,751,-231,-45,-47,-66,-15,-16,-73,-21,-24,-22,605,-23,-19,-40,-236,21,-246,-247,502,782,-63,-49,-50,-60,-62,-61,-43,-72,-71,-69,-70,-17,-20,605,-241,-82,-128,-104,-106,751,751,-64,-46,-48,605,-41,782,-129,782,-51,-52,751,-54,-56,-59,-57,-58,-44,-18,21,21,-42,782,-127,-130,-105,-107,-53,-55,-75,-74,-125,-126,]),'NAME':([0,1,6,7,9,10,13,14,15,17,19,25,27,29,30,32,34,35,40,42,44,45,46,51,54,57,58,59,60,62,64,66,67,68,69,74,79,80,86,88,89,90,91,92,93,94,96,102,103,104,109,110,111,113,115,119,120,121,122,123,124,125,126,127,128,129,130,131,132,136,137,138,139,141,147,150,153,158,160,164,166,168,170,171,172,174,175,179,180,185,193,194,195,196,197,199,201,202,203,205,206,207,210,212,220,221,222,224,226,229,231,232,233,241,242,250,252,254,256,259,261,264,266,268,271,273,278,280,282,285,289,290,299,300,301,304,306,307,308,310,311,314,316,319,320,321,323,324,325,327,329,330,331,333,334,335,336,338,339,340,342,346,348,354,356,359,360,363,366,367,368,369,373,378,380,381,383,387,388,390,392,396,398,400,404,406,409,412,415,425,434,438,440,441,444,447,448,456,457,458,460,463,465,468,470,472,475,478,481,482,483,485,487,489,491,496,498,499,501,503,504,506,507,510,511,515,517,518,519,521,522,523,525,528,533,534,536,537,538,539,540,541,542,543,544,547,548,551,556,558,559,560,564,569,570,571,575,576,578,579,581,583,585,586,588,596,597,598,599,601,602,603,604,606,608,609,611,614,615,618,622,623,626,627,631,632,635,636,637,638,639,640,642,643,645,646,647,650,651,652,656,659,660,661,662,663,664,665,666,668,669,671,672,673,675,676,678,685,686,688,690,691,692,693,695,699,702,703,704,705,709,710,711,712,714,715,716,717,719,720,721,722,723,724,725,726,727,730,733,737,738,743,744,745,746,747,749,750,752,753,754,755,757,758,759,761,762,763,767,769,771,774,778,780,781,783,784,786,787,788,790,791,792,796,798,800,801,804,805,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,823,826,827,828,830,831,832,833,834,835,836,838,839,],[71,71,-220,71,-11,71,-76,71,-135,-223,-219,-217,140,-221,71,71,71,151,71,-10,-136,71,-8,71,-9,176,71,182,71,-7,71,-31,187,-222,71,204,71,71,213,71,71,187,217,-224,71,187,-218,-137,71,-138,71,71,71,71,71,71,-205,-196,-200,-195,71,-198,-202,-197,-201,-204,-206,-203,-199,71,71,-261,-260,71,71,71,71,71,71,71,71,71,287,71,71,176,297,302,71,-30,-323,71,-319,-318,-326,-321,-324,-322,-320,-77,-12,-6,71,71,-281,187,-279,71,71,71,71,71,71,71,71,353,71,71,71,176,71,71,-131,71,71,71,71,71,71,71,71,71,71,176,71,71,403,71,405,407,187,71,71,-327,71,-325,416,71,71,71,71,71,71,428,-32,71,437,-282,437,-280,71,-248,71,71,71,71,71,71,71,-243,-238,71,71,71,71,71,-453,71,71,71,176,176,488,490,-233,494,187,71,505,-257,-225,437,437,437,71,-249,71,-254,71,71,-242,71,71,71,71,-454,71,71,176,554,555,557,176,71,71,71,-80,-88,-78,572,-79,71,71,416,71,-33,428,-230,71,-226,-227,437,589,437,599,-235,-132,71,71,-244,71,71,71,-237,71,71,71,71,71,176,624,625,71,176,644,-89,416,649,-258,71,-34,-229,71,-228,437,71,-13,-28,657,-25,667,-14,-27,-26,-239,-240,-245,71,-453,71,679,680,682,-234,71,71,71,689,-85,-102,-87,644,-86,-83,71,697,698,-259,71,-232,71,71,71,71,710,-65,71,713,721,-29,71,71,71,71,71,-454,731,71,71,-103,-81,-84,644,71,746,-231,-45,-47,756,-66,-15,657,-16,-73,-21,-24,-22,721,-23,-19,765,-40,766,-236,71,-246,-247,71,770,644,71,779,-63,-49,657,-50,-60,-62,-61,-43,71,-72,-71,-69,-70,-17,-20,721,-241,797,-82,71,802,-128,806,-104,-106,710,721,-64,-46,-48,721,-41,71,71,825,-123,829,-129,825,-51,-52,721,-54,-56,-59,-57,-58,-44,-18,71,71,-42,71,825,-127,-130,-124,-105,-107,-53,-55,-75,-74,-125,-126,]),'INDENT':([265,500,600,748,777,],[366,570,666,787,801,]),'MINUSEQUAL':([11,12,16,20,24,28,31,33,36,38,39,48,50,53,55,71,72,78,81,83,97,108,112,114,116,134,135,143,146,152,154,159,163,165,167,169,173,184,191,198,209,211,212,215,223,228,235,236,237,238,239,240,247,248,249,255,262,269,270,275,276,277,279,286,287,288,303,313,318,326,327,328,349,357,364,371,377,384,391,401,413,421,422,450,],[-352,-332,122,-303,-346,-301,-379,-328,-380,-360,-336,-304,-312,-340,-364,-377,-314,-378,-308,-211,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-305,-375,-342,-341,-366,-368,-363,-373,-315,-309,-213,-212,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-306,-376,-344,-345,-343,-396,-369,-399,-365,-479,-374,-316,-310,-214,-215,-335,-331,-339,-307,-397,-367,-398,-480,-317,-311,-216,-302,]),'ENAMLDEF':([0,6,9,13,15,17,19,25,29,42,44,46,54,62,66,68,76,79,92,96,102,104,138,139,185,205,206,207,266,334,346,367,368,404,425,434,447,456,460,498,499,501,504,515,518,521,522,534,536,539,543,571,578,581,583,586,597,598,601,603,604,606,608,609,611,627,650,652,663,668,690,699,702,703,705,709,711,712,722,724,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,821,],[27,-220,-11,-76,-135,-223,-219,-217,-221,-10,-136,-8,-9,-7,-31,-222,27,27,-224,-218,-137,-138,-261,-260,-30,-77,-12,-6,-131,-32,-248,-243,-238,-233,-257,-225,-249,-254,-242,-80,-88,-78,-79,-33,-230,-226,-227,-235,-132,-244,-237,-89,-258,-34,-229,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,-232,-65,-29,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,-42,]),'DEDENT':([6,15,17,19,25,29,44,68,92,96,102,104,138,139,266,346,367,368,404,425,434,447,456,458,459,460,499,518,521,522,534,535,536,539,543,571,578,583,586,598,601,604,606,608,609,611,627,637,638,639,640,642,643,650,652,663,668,688,691,699,702,703,705,712,714,715,716,717,719,720,722,724,726,727,737,744,745,747,749,750,752,753,755,757,758,759,762,767,780,783,784,788,790,791,792,796,807,809,810,811,812,813,814,815,816,817,821,826,827,828,831,832,833,834,835,836,838,839,],[-220,-135,-223,-219,-217,-221,-136,-222,-224,-218,-137,-138,-261,-260,-131,-248,-243,-238,-233,-257,-225,-249,-254,-134,536,-242,-88,-230,-226,-227,-235,-133,-132,-244,-237,-89,-258,-229,-228,-28,-25,-27,-26,-239,-240,-245,-234,-85,-102,-87,690,-86,-83,-259,-232,-65,-29,-103,-84,-231,-45,-47,-66,-73,-21,-24,-22,761,-23,-19,-40,-236,-246,-247,771,-63,-49,-50,-60,-62,-61,-43,-72,-71,-69,-70,-20,-241,-128,-104,-106,-64,-46,-48,818,-41,-129,-51,-52,833,-54,-56,-59,-57,-58,-44,-42,838,-127,-130,-105,-107,-53,-55,-75,-74,-125,-126,]),'RETURN':([0,6,9,13,15,17,19,25,29,42,44,46,54,62,68,79,92,96,102,103,104,138,139,158,205,206,207,229,232,266,307,330,335,346,348,363,366,367,368,404,425,434,447,456,457,458,460,463,465,498,499,501,504,511,518,521,522,534,536,537,538,539,541,543,564,571,578,579,583,585,586,597,598,601,603,604,606,608,609,611,627,650,651,652,663,664,668,669,671,672,690,699,702,703,705,709,711,712,722,724,725,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,819,820,821,],[30,-220,-11,-76,-135,-223,-219,-217,-221,-10,-136,-8,-9,-7,-222,30,-224,-218,-137,30,-138,-261,-260,30,-77,-12,-6,30,30,-131,30,30,30,-248,30,30,30,-243,-238,-233,-257,-225,-249,-254,30,30,-242,30,30,-80,-88,-78,-79,30,-230,-226,-227,-235,-132,30,30,-244,30,-237,30,-89,-258,30,-229,30,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,30,-232,-65,30,-29,30,30,30,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,30,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,30,30,-42,]),'DEL':([0,6,9,13,15,17,19,25,29,42,44,46,54,62,68,79,92,96,102,103,104,138,139,158,205,206,207,229,232,266,307,330,335,346,348,363,366,367,368,404,425,434,447,456,457,458,460,463,465,498,499,501,504,511,518,521,522,534,536,537,538,539,541,543,564,571,578,579,583,585,586,597,598,601,603,604,606,608,609,611,627,650,651,652,663,664,668,669,671,672,690,699,702,703,705,709,711,712,722,724,725,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,819,820,821,],[32,-220,-11,-76,-135,-223,-219,-217,-221,-10,-136,-8,-9,-7,-222,32,-224,-218,-137,32,-138,-261,-260,32,-77,-12,-6,32,32,-131,32,32,32,-248,32,32,32,-243,-238,-233,-257,-225,-249,-254,32,32,-242,32,32,-80,-88,-78,-79,32,-230,-226,-227,-235,-132,32,32,-244,32,-237,32,-89,-258,32,-229,32,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,32,-232,-65,32,-29,32,32,32,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,32,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,32,32,-42,]),'PRINT':([0,6,9,13,15,17,19,25,29,42,44,46,54,62,68,79,92,96,102,103,104,138,139,158,205,206,207,229,232,266,307,330,335,346,348,363,366,367,368,404,425,434,447,456,457,458,460,463,465,498,499,501,504,511,518,521,522,534,536,537,538,539,541,543,564,571,578,579,583,585,586,597,598,601,603,604,606,608,609,611,627,650,651,652,663,664,668,669,671,672,690,699,702,703,705,709,711,712,722,724,725,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,819,820,821,],[34,-220,-11,-76,-135,-223,-219,-217,-221,-10,-136,-8,-9,-7,-222,34,-224,-218,-137,34,-138,-261,-260,34,-77,-12,-6,34,34,-131,34,34,34,-248,34,34,34,-243,-238,-233,-257,-225,-249,-254,34,34,-242,34,34,-80,-88,-78,-79,34,-230,-226,-227,-235,-132,34,34,-244,34,-237,34,-89,-258,34,-229,34,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,34,-232,-65,34,-29,34,34,34,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,34,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,34,34,-42,]),'DOUBLESTAR':([31,36,55,57,71,78,97,143,163,168,169,173,191,223,228,259,270,279,282,286,287,300,313,331,377,383,391,395,396,470,472,487,549,558,561,569,615,620,676,681,732,],[-379,-380,171,179,-377,-378,-370,-381,-375,280,285,-368,-373,-372,-371,179,-376,-396,380,-369,-399,400,-374,280,-397,-453,-398,482,485,547,-454,560,618,623,626,179,675,678,730,733,769,]),'DEF':([0,6,9,13,15,17,19,23,25,26,29,42,44,46,54,62,68,79,92,96,102,104,133,138,139,205,206,207,266,332,346,366,367,368,404,425,434,447,456,458,460,498,499,501,504,513,518,521,522,534,536,539,543,571,578,580,583,586,597,598,601,603,604,606,608,609,611,627,650,652,663,668,690,699,702,703,705,709,711,712,722,724,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,821,],[35,-220,-11,-76,-135,-223,-219,-263,-217,35,-221,-10,-136,-8,-9,-7,-222,35,-224,-218,-137,-138,-262,-261,-260,-77,-12,-6,-131,-264,-248,35,-243,-238,-233,-257,-225,-249,-254,35,-242,-80,-88,-78,-79,-265,-230,-226,-227,-235,-132,-244,-237,-89,-258,-266,-229,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,-232,-65,-29,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,-42,]),'CIRCUMFLEXEQUAL':([11,12,16,20,24,28,31,33,36,38,39,48,50,53,55,71,72,78,81,83,97,108,112,114,116,134,135,143,146,152,154,159,163,165,167,169,173,184,191,198,209,211,212,215,223,228,235,236,237,238,239,240,247,248,249,255,262,269,270,275,276,277,279,286,287,288,303,313,318,326,327,328,349,357,364,371,377,384,391,401,413,421,422,450,],[-352,-332,121,-303,-346,-301,-379,-328,-380,-360,-336,-304,-312,-340,-364,-377,-314,-378,-308,-211,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-305,-375,-342,-341,-366,-368,-363,-373,-315,-309,-213,-212,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-306,-376,-344,-345,-343,-396,-369,-399,-365,-479,-374,-316,-310,-214,-215,-335,-331,-339,-307,-397,-367,-398,-480,-317,-311,-216,-302,]),'COLON':([11,12,20,24,28,31,33,36,38,39,47,48,50,53,55,57,71,72,78,81,83,97,105,106,108,112,114,116,134,135,143,146,152,154,159,162,163,165,167,169,172,173,176,177,178,183,184,191,198,209,211,212,213,215,218,223,228,234,235,236,237,238,239,240,247,248,249,255,260,262,269,270,275,276,277,279,286,287,288,291,297,298,300,302,303,313,318,322,326,327,328,345,347,349,357,361,364,365,369,370,371,377,384,385,390,391,394,396,397,399,401,413,416,418,421,422,423,446,449,450,455,461,462,464,476,478,484,486,487,488,490,493,508,512,520,545,554,555,557,558,562,569,572,584,599,607,610,612,613,621,624,625,634,644,657,667,670,679,680,682,694,721,731,739,746,765,770,776,779,785,793,794,797,802,806,829,],[-352,-332,-303,-346,-301,-379,-328,-380,-360,-336,158,-304,-312,-340,-364,180,-377,-314,-378,-308,-211,-370,-250,232,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-305,273,-375,-342,-341,-366,289,-368,-508,-484,301,307,-363,-373,-315,-309,-213,-212,330,-313,335,-372,-371,348,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,363,-338,-306,-376,-344,-345,-343,-396,-369,-399,-365,387,-501,-489,-485,-503,-479,-374,-316,414,-310,-214,-215,-251,-253,-335,-331,-255,-339,457,463,465,-307,-397,-367,475,289,-398,-509,-490,-494,-504,-480,-317,506,-90,-311,-216,511,-252,533,-302,-256,537,538,541,551,289,-506,-499,-495,-481,-483,564,-91,579,585,614,-502,-486,-488,-500,-505,635,646,651,662,669,671,672,673,-507,-491,-493,686,695,704,723,725,-496,-498,-482,743,695,-487,-108,786,704,-492,-109,-119,808,819,820,-497,-121,-120,-122,]),'DOUBLECOLON':([11,12,20,24,28,31,33,36,38,39,48,50,53,55,71,72,78,81,97,108,112,114,116,134,135,143,146,152,154,159,163,165,167,169,172,173,184,191,198,209,215,223,228,235,236,237,238,239,240,247,248,249,255,262,269,270,275,276,277,279,286,287,288,291,303,313,318,326,349,357,364,371,377,384,390,391,401,413,421,450,478,599,657,658,710,713,721,746,756,760,765,803,],[-352,-332,-303,-346,-301,-379,-328,-380,-360,-336,-304,-312,-340,-364,-377,-314,-378,-308,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-305,-375,-342,-341,-366,290,-368,-363,-373,-315,-309,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-306,-376,-344,-345,-343,-396,-369,-399,-365,388,-479,-374,-316,-310,-335,-331,-339,-307,-397,-367,290,-398,-480,-317,-311,-302,290,664,664,664,664,-67,664,664,664,-68,664,664,]),'$end':([2,77,107,155,263,],[-4,0,-3,-2,-1,]),'FOR':([0,6,9,11,12,13,15,17,19,20,24,25,28,29,31,33,36,38,39,42,44,46,48,50,53,54,55,62,68,71,72,78,79,81,92,96,97,99,102,104,108,112,114,116,134,135,138,139,143,146,152,154,159,162,163,165,167,169,173,184,191,192,198,205,206,207,209,215,223,228,235,236,237,238,239,240,247,248,249,255,262,266,269,270,275,276,277,279,283,286,287,288,303,313,318,326,346,349,357,364,366,367,368,371,374,377,384,391,401,404,413,421,425,434,447,450,456,458,460,498,499,501,504,518,521,522,531,534,536,539,543,565,566,567,568,571,578,583,586,597,598,601,603,604,606,608,609,611,627,633,650,652,655,663,668,683,684,685,687,690,699,702,703,705,709,711,712,722,724,726,727,735,736,740,753,755,757,758,759,761,767,771,790,791,796,817,818,821,],[45,-220,-11,-352,-332,-76,-135,-223,-219,-303,-346,-217,-301,-221,-379,-328,-380,-360,-336,-10,-136,-8,-304,-312,-340,-9,-364,-7,-222,-377,-314,-378,45,-308,-224,-218,-370,224,-137,-138,-361,-354,-353,-333,-347,-348,-261,-260,-381,-329,-337,-362,-305,224,-375,-342,-341,-366,-368,-363,-373,314,-315,-77,-12,-6,-309,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-131,-306,-376,-344,-345,-343,-396,224,-369,-399,-365,-479,-374,-316,-310,-248,-335,-331,-339,45,-243,-238,-307,224,-397,-367,-398,-480,-233,-317,-311,-257,-225,-249,-302,-254,45,-242,-80,-88,-78,-79,-230,-226,-227,224,-235,-132,-244,-237,314,-470,-476,-475,-89,-258,-229,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-471,-259,-232,224,-65,-29,314,-473,-472,-477,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,-246,-247,-474,-478,224,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,-42,]),'DOUBLESTAREQUAL':([11,12,16,20,24,28,31,33,36,38,39,48,50,53,55,71,72,78,81,83,97,108,112,114,116,134,135,143,146,152,154,159,163,165,167,169,173,184,191,198,209,211,212,215,223,228,235,236,237,238,239,240,247,248,249,255,262,269,270,275,276,277,279,286,287,288,303,313,318,326,327,328,349,357,364,371,377,384,391,401,413,421,422,450,],[-352,-332,125,-303,-346,-301,-379,-328,-380,-360,-336,-304,-312,-340,-364,-377,-314,-378,-308,-211,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-305,-375,-342,-341,-366,-368,-363,-373,-315,-309,-213,-212,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-306,-376,-344,-345,-343,-396,-369,-399,-365,-479,-374,-316,-310,-214,-215,-335,-331,-339,-307,-397,-367,-398,-480,-317,-311,-216,-302,]),'ELSE':([11,12,24,31,33,36,38,39,48,50,53,55,71,72,78,81,97,102,104,108,112,114,116,134,135,143,146,152,154,159,163,165,167,169,173,184,191,198,209,215,223,228,235,236,237,238,239,240,247,248,249,251,255,262,266,269,270,275,276,277,279,286,287,288,313,318,326,349,357,364,367,368,371,377,384,391,404,413,421,434,460,518,521,534,536,539,583,611,699,726,727,],[-352,-332,-346,-379,-328,-380,-360,-336,-304,-312,-340,-364,-377,-314,-378,-308,-370,-137,-138,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-305,-375,-342,-341,-366,-368,-363,-373,-315,-309,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,354,-330,-338,-131,-306,-376,-344,-345,-343,-396,-369,-399,-365,-374,-316,-310,-335,-331,-339,-243,461,-307,-397,-367,-398,493,-317,-311,520,-242,-230,520,607,-132,-244,-229,-245,-231,-246,-247,]),'TRY':([0,6,9,13,15,17,19,25,29,42,44,46,54,62,68,79,92,96,102,104,138,139,205,206,207,266,346,366,367,368,404,425,434,447,456,458,460,498,499,501,504,518,521,522,534,536,539,543,571,578,583,586,597,598,601,603,604,606,608,609,611,627,650,652,663,668,690,699,702,703,705,709,711,712,722,724,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,821,],[47,-220,-11,-76,-135,-223,-219,-217,-221,-10,-136,-8,-9,-7,-222,47,-224,-218,-137,-138,-261,-260,-77,-12,-6,-131,-248,47,-243,-238,-233,-257,-225,-249,-254,47,-242,-80,-88,-78,-79,-230,-226,-227,-235,-132,-244,-237,-89,-258,-229,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,-232,-65,-29,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,-42,]),'AND':([11,12,24,31,33,36,38,39,50,53,55,71,72,78,81,97,108,112,114,116,134,135,143,146,152,154,163,165,167,169,173,184,191,198,209,215,223,228,235,236,237,238,239,240,247,248,249,255,262,270,275,276,277,279,286,287,288,313,318,326,349,357,364,377,384,391,413,421,],[-352,-332,-346,-379,-328,-380,-360,-336,-312,-340,-364,-377,-314,-378,210,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-375,-342,-341,-366,-368,-363,-373,-315,325,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-376,-344,-345,-343,-396,-369,-399,-365,-374,-316,-310,-335,-331,-339,-397,-367,-398,-317,-311,]),'LBRACE':([0,1,6,7,9,10,13,14,15,17,19,25,29,30,32,34,40,42,44,45,46,51,54,58,60,62,64,68,69,79,80,88,89,92,93,96,102,103,104,109,110,111,113,115,119,120,121,122,123,124,125,126,127,128,129,130,131,132,136,137,138,139,141,147,150,153,158,160,164,166,168,171,172,180,193,194,195,196,197,199,201,202,203,205,206,207,210,212,224,226,229,231,232,233,241,242,252,254,256,261,264,266,268,271,273,278,280,282,285,289,290,299,301,304,307,314,316,319,320,321,324,325,327,329,330,331,335,342,346,348,354,356,359,360,363,366,367,368,369,373,378,380,381,383,387,388,390,404,412,425,434,444,447,448,456,457,458,460,463,465,468,470,472,475,478,489,491,496,498,499,501,504,506,507,511,518,519,521,522,534,536,537,538,539,540,541,542,543,544,547,548,551,556,564,571,578,579,583,585,586,596,597,598,601,603,604,606,608,609,611,614,615,618,627,631,632,635,645,650,651,652,656,659,660,661,663,664,668,669,671,672,673,675,676,685,686,690,693,699,702,703,705,709,711,712,722,724,725,726,727,730,738,753,754,755,757,758,759,761,767,771,774,790,791,796,798,800,817,818,819,820,821,823,],[51,51,-220,51,-11,51,-76,51,-135,-223,-219,-217,-221,51,51,51,51,-10,-136,51,-8,51,-9,51,51,-7,51,-222,51,51,51,51,51,-224,51,-218,-137,51,-138,51,51,51,51,51,51,-205,-196,-200,-195,51,-198,-202,-197,-201,-204,-206,-203,-199,51,51,-261,-260,51,51,51,51,51,51,51,51,51,51,51,51,-323,51,-319,-318,-326,-321,-324,-322,-320,-77,-12,-6,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,-131,51,51,51,51,51,51,51,51,51,51,51,51,51,51,51,-327,51,-325,51,51,51,51,51,51,51,51,-248,51,51,51,51,51,51,51,-243,-238,51,51,51,51,51,-453,51,51,51,-233,51,-257,-225,51,-249,51,-254,51,51,-242,51,51,51,51,-454,51,51,51,51,51,-80,-88,-78,-79,51,51,51,-230,51,-226,-227,-235,-132,51,51,-244,51,51,51,-237,51,51,51,51,51,51,-89,-258,51,-229,51,-228,51,-13,-28,-25,-14,-27,-26,-239,-240,-245,51,-453,51,-234,51,51,51,51,-259,51,-232,51,51,51,51,-65,51,-29,51,51,51,51,51,-454,51,51,-81,51,-231,-45,-47,-66,-15,-16,-73,-40,-236,51,-246,-247,51,51,-43,51,-72,-71,-69,-70,-17,-241,-82,51,-46,-48,-41,51,51,-44,-18,51,51,-42,51,]),'FINALLY':([102,104,266,267,367,368,460,536,539,608,611,726,727,],[-137,-138,-131,370,-243,462,-242,-132,-244,670,-245,-246,-247,]),'OR':([11,12,24,31,33,36,38,39,48,50,53,55,71,72,78,81,97,108,112,114,116,134,135,143,146,152,154,159,163,165,167,169,173,184,191,198,209,215,223,228,235,236,237,238,239,240,247,248,249,255,262,269,270,275,276,277,279,286,287,288,313,318,326,349,357,364,371,377,384,391,413,421,],[-352,-332,-346,-379,-328,-380,-360,-336,160,-312,-340,-364,-377,-314,-378,-308,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,268,-375,-342,-341,-366,-368,-363,-373,-315,-309,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-306,-376,-344,-345,-343,-396,-369,-399,-365,-374,-316,-310,-335,-331,-339,-307,-397,-367,-398,-317,-311,]),'LEFTSHIFT':([11,24,31,36,38,53,55,71,78,97,108,112,114,134,135,143,154,163,165,167,169,173,184,191,223,228,235,236,237,238,239,247,248,249,270,275,276,277,279,286,287,288,313,377,384,391,599,657,658,710,713,721,746,756,760,765,803,],[-352,-346,-379,-380,-360,164,-364,-377,-378,-370,-361,-354,-353,-347,-348,-381,-362,-375,-342,164,-366,-368,-363,-373,-372,-371,-356,-358,-359,-357,-355,-349,-350,-351,-376,-344,-345,-343,-396,-369,-399,-365,-374,-397,-367,-398,661,661,661,661,-67,661,661,661,-68,661,661,]),'CONTINUE':([0,6,9,13,15,17,19,25,29,42,44,46,54,62,68,79,92,96,102,103,104,138,139,158,205,206,207,229,232,266,307,330,335,346,348,363,366,367,368,404,425,434,447,456,457,458,460,463,465,498,499,501,504,511,518,521,522,534,536,537,538,539,541,543,564,571,578,579,583,585,586,597,598,601,603,604,606,608,609,611,627,650,651,652,663,664,668,669,671,672,690,699,702,703,705,709,711,712,722,724,725,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,819,820,821,],[56,-220,-11,-76,-135,-223,-219,-217,-221,-10,-136,-8,-9,-7,-222,56,-224,-218,-137,56,-138,-261,-260,56,-77,-12,-6,56,56,-131,56,56,56,-248,56,56,56,-243,-238,-233,-257,-225,-249,-254,56,56,-242,56,56,-80,-88,-78,-79,56,-230,-226,-227,-235,-132,56,56,-244,56,-237,56,-89,-258,56,-229,56,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,56,-232,-65,56,-29,56,56,56,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,56,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,56,56,-42,]),'NOT':([0,1,6,7,9,11,12,13,15,17,19,24,25,29,30,31,33,34,36,38,39,42,44,46,51,53,54,55,58,60,62,68,69,71,72,78,79,80,88,89,92,93,96,97,102,103,104,108,112,114,116,119,120,121,122,123,124,125,126,127,128,129,130,131,132,134,135,138,139,141,143,146,150,152,154,158,160,163,165,167,168,169,172,173,180,184,191,197,198,205,206,207,210,212,223,226,228,229,232,233,235,236,237,238,239,240,242,247,248,249,255,256,262,264,266,268,270,271,273,275,276,277,278,279,280,282,286,287,288,289,290,299,301,304,307,313,316,318,324,325,327,329,330,331,335,342,346,348,349,354,357,359,360,363,364,366,367,368,369,373,377,378,380,381,383,384,387,388,390,391,404,412,413,425,434,444,447,448,456,457,458,460,463,465,468,470,472,475,478,489,491,496,498,499,501,504,506,507,511,518,519,521,522,534,536,537,538,539,540,541,542,543,544,547,548,551,556,564,571,578,579,583,585,586,596,597,598,601,603,604,606,608,609,611,614,615,618,627,631,632,635,645,650,651,652,656,659,660,661,663,664,668,669,671,672,673,675,676,685,686,690,693,699,702,703,705,709,711,712,722,724,725,726,727,730,738,753,754,755,757,758,759,761,767,771,774,790,791,796,798,800,817,818,819,820,821,823,],[89,89,-220,89,-11,-352,-332,-76,-135,-223,-219,-346,-217,-221,89,-379,-328,89,-380,-360,-336,-10,-136,-8,89,-340,-9,-364,89,89,-7,-222,89,-377,200,-378,89,89,89,89,-224,89,-218,-370,-137,89,-138,-361,-354,-353,-333,89,-205,-196,-200,-195,89,-198,-202,-197,-201,-204,-206,-203,-199,-347,-348,-261,-260,89,-381,-329,89,-337,-362,89,89,-375,-342,-341,89,-366,89,-368,89,-363,-373,319,200,-77,-12,-6,89,89,-372,89,-371,89,89,89,-356,-358,-359,-357,-355,-334,89,-349,-350,-351,-330,89,-338,89,-131,89,-376,89,89,-344,-345,-343,89,-396,89,89,-369,-399,-365,89,89,89,89,89,89,-374,89,-316,89,89,89,89,89,89,89,89,-248,89,-335,89,-331,89,89,89,-339,89,-243,-238,89,89,-397,89,89,89,-453,-367,89,89,89,-398,-233,89,-317,-257,-225,89,-249,89,-254,89,89,-242,89,89,89,89,-454,89,89,89,89,89,-80,-88,-78,-79,89,89,89,-230,89,-226,-227,-235,-132,89,89,-244,89,89,89,-237,89,89,89,89,89,89,-89,-258,89,-229,89,-228,89,-13,-28,-25,-14,-27,-26,-239,-240,-245,89,-453,89,-234,89,89,89,89,-259,89,-232,89,89,89,89,-65,89,-29,89,89,89,89,89,-454,89,89,-81,89,-231,-45,-47,-66,-15,-16,-73,-40,-236,89,-246,-247,89,89,-43,89,-72,-71,-69,-70,-17,-241,-82,89,-46,-48,-41,89,89,-44,-18,89,89,-42,89,]),'LAMBDA':([0,1,6,7,9,13,15,17,19,25,29,30,34,42,44,46,51,54,58,60,62,68,69,79,80,88,92,93,96,102,103,104,119,120,121,122,123,124,125,126,127,128,129,130,131,132,138,139,150,158,168,172,180,205,206,207,212,226,229,232,233,242,256,264,266,271,273,278,280,282,289,290,299,301,304,307,316,324,327,329,330,331,335,342,346,348,354,359,360,363,366,367,368,369,373,378,380,381,383,387,388,390,404,412,425,434,447,448,456,457,458,460,463,465,468,470,472,475,478,489,491,496,498,499,501,504,506,507,511,518,519,521,522,534,536,537,538,539,540,541,542,543,544,547,548,551,556,564,571,578,579,583,585,586,596,597,598,601,603,604,606,608,609,611,614,615,618,627,631,632,635,645,650,651,652,656,659,660,661,663,664,668,669,671,672,673,675,676,685,686,690,693,699,702,703,705,709,711,712,722,724,725,726,727,730,738,753,754,755,757,758,759,761,767,771,774,790,791,796,798,800,817,818,819,820,821,823,],[57,57,-220,57,-11,-76,-135,-223,-219,-217,-221,57,57,-10,-136,-8,57,-9,57,57,-7,-222,57,57,57,57,-224,57,-218,-137,57,-138,57,-205,-196,-200,-195,57,-198,-202,-197,-201,-204,-206,-203,-199,-261,-260,57,57,57,57,57,-77,-12,-6,57,57,57,57,57,57,57,57,-131,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,57,-248,57,57,57,57,57,57,-243,-238,57,57,57,57,57,-453,57,57,57,-233,57,-257,-225,-249,57,-254,57,57,-242,57,57,57,57,-454,57,57,57,57,569,-80,-88,-78,-79,57,57,57,-230,57,-226,-227,-235,-132,57,57,-244,57,57,57,-237,57,57,57,57,57,57,-89,-258,57,-229,57,-228,569,-13,-28,-25,-14,-27,-26,-239,-240,-245,57,-453,57,-234,569,569,569,57,-259,57,-232,57,57,57,57,-65,57,-29,57,57,57,57,57,-454,569,569,-81,57,-231,-45,-47,-66,-15,-16,-73,-40,-236,57,-246,-247,57,57,-43,57,-72,-71,-69,-70,-17,-241,-82,57,-46,-48,-41,57,57,-44,-18,57,57,-42,57,]),'NEWLINE':([0,3,4,5,6,9,11,12,13,15,16,17,18,19,20,21,22,24,25,28,29,30,31,33,34,36,37,38,39,41,42,43,44,46,48,49,50,52,53,54,55,56,58,61,62,63,65,68,70,71,72,73,75,78,79,81,82,83,84,85,87,88,92,95,96,97,101,102,103,104,108,112,114,116,117,118,134,135,138,139,142,143,144,145,146,148,149,152,154,158,159,163,165,167,169,173,181,182,184,186,187,188,189,191,198,205,206,207,208,209,211,212,214,215,216,217,223,228,229,230,232,235,236,237,238,239,240,243,244,245,246,247,248,249,252,253,255,256,257,258,262,266,269,270,275,276,277,279,286,287,288,303,305,307,309,312,313,318,326,327,328,330,335,344,346,348,349,350,351,352,355,356,357,358,359,363,364,367,368,371,377,384,391,401,402,403,404,405,407,408,413,414,420,421,422,425,426,430,434,435,436,437,439,442,443,447,450,451,452,453,454,456,457,460,463,465,492,494,495,498,499,501,502,504,511,514,516,518,521,522,523,524,527,529,532,533,534,536,537,538,539,541,543,563,564,571,578,579,583,585,586,587,588,589,590,592,597,598,601,603,604,605,606,608,609,611,627,641,650,651,652,653,654,657,662,663,664,667,668,669,671,672,690,695,696,699,701,702,703,705,706,707,708,709,711,712,713,718,722,724,725,726,727,743,751,753,755,756,757,758,759,760,761,765,766,767,771,782,786,789,790,791,795,796,808,817,818,819,820,821,],[8,102,-268,104,-220,-11,-352,-332,-76,-135,-191,-223,-152,-219,-303,-165,-144,-346,-217,-301,-221,-173,-379,-328,-153,-380,-148,-360,-336,-151,-10,156,-136,-8,-304,-149,-312,-147,-340,-9,-364,-172,-175,-168,-7,-167,-145,-222,-169,-377,-314,-171,-170,-378,-5,-308,-166,-211,-150,-267,-179,-180,-224,-146,-218,-370,-140,-137,-139,-138,-361,-354,-353,-333,-186,-194,-347,-348,-261,-260,-174,-381,-164,-420,-329,-155,-154,-337,-362,265,-305,-375,-342,-341,-366,-368,-176,-182,-363,-285,-297,-269,-293,-373,-315,-77,-12,-6,-189,-309,-213,-212,-181,-313,332,334,-372,-371,-141,-142,265,-356,-358,-359,-357,-355,-334,-193,-192,-208,-207,-349,-350,-351,-421,-422,-330,-159,-160,-156,-338,-131,-306,-376,-344,-345,-343,-396,-369,-399,-365,-479,-183,265,-298,-294,-374,-316,-310,-214,-215,265,265,-143,-248,265,-335,-187,-210,-209,-424,-423,-331,-162,-161,265,-339,-243,-238,-307,-397,-367,-398,-480,-177,-185,-233,-286,-299,-295,-317,500,-190,-311,-216,-257,513,515,-225,-287,-270,-283,-271,-276,-277,-249,-302,-425,-163,-158,-157,-254,265,-242,265,265,-184,-300,-296,-80,-88,-78,571,-79,265,580,581,-230,-226,-227,-288,-289,-273,-274,-188,600,-235,-132,265,265,-244,265,-237,-178,265,-89,-258,265,-229,265,-228,-291,-290,-284,-272,-278,-13,-28,-25,-14,-27,668,-26,-239,-240,-245,-234,692,-259,265,-232,-292,-275,702,600,-65,265,722,-29,265,265,265,-81,748,753,-231,755,-45,-47,-66,757,758,759,-15,-16,-73,-67,763,-40,-236,265,-246,-247,777,788,-43,-72,790,-71,-69,-70,-68,-17,702,796,-241,-82,807,748,817,-46,-48,821,-41,777,-44,-18,265,265,-42,]),'RAISE':([0,6,9,13,15,17,19,25,29,42,44,46,54,62,68,79,92,96,102,103,104,138,139,158,205,206,207,229,232,266,307,330,335,346,348,363,366,367,368,404,425,434,447,456,457,458,460,463,465,498,499,501,504,511,518,521,522,534,536,537,538,539,541,543,564,571,578,579,583,585,586,597,598,601,603,604,606,608,609,611,627,650,651,652,663,664,668,669,671,672,690,699,702,703,705,709,711,712,722,724,725,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,819,820,821,],[58,-220,-11,-76,-135,-223,-219,-217,-221,-10,-136,-8,-9,-7,-222,58,-224,-218,-137,58,-138,-261,-260,58,-77,-12,-6,58,58,-131,58,58,58,-248,58,58,58,-243,-238,-233,-257,-225,-249,-254,58,58,-242,58,58,-80,-88,-78,-79,58,-230,-226,-227,-235,-132,58,58,-244,58,-237,58,-89,-258,58,-229,58,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,58,-232,-65,58,-29,58,58,58,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,58,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,58,58,-42,]),'GLOBAL':([0,6,9,13,15,17,19,25,29,42,44,46,54,62,68,79,92,96,102,103,104,138,139,158,205,206,207,229,232,266,307,330,335,346,348,363,366,367,368,404,425,434,447,456,457,458,460,463,465,498,499,501,504,511,518,521,522,534,536,537,538,539,541,543,564,571,578,579,583,585,586,597,598,601,603,604,606,608,609,611,627,650,651,652,663,664,668,669,671,672,690,699,702,703,705,709,711,712,722,724,725,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,819,820,821,],[59,-220,-11,-76,-135,-223,-219,-217,-221,-10,-136,-8,-9,-7,-222,59,-224,-218,-137,59,-138,-261,-260,59,-77,-12,-6,59,59,-131,59,59,59,-248,59,59,59,-243,-238,-233,-257,-225,-249,-254,59,59,-242,59,59,-80,-88,-78,-79,59,-230,-226,-227,-235,-132,59,59,-244,59,-237,59,-89,-258,59,-229,59,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,59,-232,-65,59,-29,59,59,59,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,59,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,59,59,-42,]),'WHILE':([0,6,9,13,15,17,19,25,29,42,44,46,54,62,68,79,92,96,102,104,138,139,205,206,207,266,346,366,367,368,404,425,434,447,456,458,460,498,499,501,504,518,521,522,534,536,539,543,571,578,583,586,597,598,601,603,604,606,608,609,611,627,650,652,663,668,690,699,702,703,705,709,711,712,722,724,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,821,],[60,-220,-11,-76,-135,-223,-219,-217,-221,-10,-136,-8,-9,-7,-222,60,-224,-218,-137,-138,-261,-260,-77,-12,-6,-131,-248,60,-243,-238,-233,-257,-225,-249,-254,60,-242,-80,-88,-78,-79,-230,-226,-227,-235,-132,-244,-237,-89,-258,-229,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,-232,-65,-29,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,-42,]),'VBAR':([11,12,24,31,33,36,38,39,53,55,71,78,97,108,112,114,116,134,135,143,146,152,154,163,165,167,169,173,184,191,223,228,235,236,237,238,239,240,247,248,249,255,262,270,275,276,277,279,286,287,288,313,349,357,364,377,384,391,],[-352,-332,-346,-379,147,-380,-360,-336,-340,-364,-377,-378,-370,-361,-354,-353,-333,-347,-348,-381,254,-337,-362,-375,-342,-341,-366,-368,-363,-373,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-376,-344,-345,-343,-396,-369,-399,-365,-374,-335,-331,-339,-397,-367,-398,]),'STAR':([11,31,36,38,55,57,71,78,97,108,112,114,143,154,163,168,169,173,184,191,223,228,235,236,237,238,239,259,270,279,282,286,287,288,300,313,323,331,336,339,377,383,384,391,396,440,472,487,510,558,569,575,693,743,774,781,800,804,830,],[109,-379,-380,-360,-364,175,-377,-378,-370,-361,-354,109,-381,-362,-375,278,-366,-368,-363,-373,-372,-371,-356,-358,-359,-357,-355,175,-376,-396,378,-369,-399,-365,398,-374,415,278,436,442,-397,-453,-367,-398,483,527,-454,559,576,622,175,647,738,778,798,805,823,-123,-124,]),'DOT':([31,36,55,71,78,94,97,143,163,169,173,187,191,220,221,222,223,228,270,279,286,287,309,313,338,340,377,391,407,494,599,710,713,721,746,766,779,825,],[-379,-380,170,-377,-378,222,-370,-381,-375,170,-368,310,-373,-281,340,-279,-372,-371,-376,-396,-369,-399,406,-374,-282,-280,-397,-398,-299,-300,665,665,665,665,665,665,665,665,]),'LEFTSHIFTEQUAL':([11,12,16,20,24,28,31,33,36,38,39,48,50,53,55,71,72,78,81,83,97,108,112,114,116,134,135,143,146,152,154,159,163,165,167,169,173,184,191,198,209,211,212,215,223,228,235,236,237,238,239,240,247,248,249,255,262,269,270,275,276,277,279,286,287,288,303,313,318,326,327,328,349,357,364,371,377,384,391,401,413,421,422,450,],[-352,-332,132,-303,-346,-301,-379,-328,-380,-360,-336,-304,-312,-340,-364,-377,-314,-378,-308,-211,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-305,-375,-342,-341,-366,-368,-363,-373,-315,-309,-213,-212,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-306,-376,-344,-345,-343,-396,-369,-399,-365,-479,-374,-316,-310,-214,-215,-335,-331,-339,-307,-397,-367,-398,-480,-317,-311,-216,-302,]),'TILDE':([0,1,6,7,9,10,13,14,15,17,19,25,29,30,32,34,40,42,44,45,46,51,54,58,60,62,64,68,69,79,80,88,89,92,93,96,102,103,104,109,110,111,113,115,119,120,121,122,123,124,125,126,127,128,129,130,131,132,136,137,138,139,141,147,150,153,158,160,164,166,168,171,172,180,193,194,195,196,197,199,201,202,203,205,206,207,210,212,224,226,229,231,232,233,241,242,252,254,256,261,264,266,268,271,273,278,280,282,285,289,290,299,301,304,307,314,316,319,320,321,324,325,327,329,330,331,335,342,346,348,354,356,359,360,363,366,367,368,369,373,378,380,381,383,387,388,390,404,412,425,434,444,447,448,456,457,458,460,463,465,468,470,472,475,478,489,491,496,498,499,501,504,506,507,511,518,519,521,522,534,536,537,538,539,540,541,542,543,544,547,548,551,556,564,571,578,579,583,585,586,596,597,598,601,603,604,606,608,609,611,614,615,618,627,631,632,635,645,650,651,652,656,659,660,661,663,664,668,669,671,672,673,675,676,685,686,690,693,699,702,703,705,709,711,712,722,724,725,726,727,730,738,753,754,755,757,758,759,761,767,771,774,790,791,796,798,800,817,818,819,820,821,823,],[64,64,-220,64,-11,64,-76,64,-135,-223,-219,-217,-221,64,64,64,64,-10,-136,64,-8,64,-9,64,64,-7,64,-222,64,64,64,64,64,-224,64,-218,-137,64,-138,64,64,64,64,64,64,-205,-196,-200,-195,64,-198,-202,-197,-201,-204,-206,-203,-199,64,64,-261,-260,64,64,64,64,64,64,64,64,64,64,64,64,-323,64,-319,-318,-326,-321,-324,-322,-320,-77,-12,-6,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,-131,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,-327,64,-325,64,64,64,64,64,64,64,64,-248,64,64,64,64,64,64,64,-243,-238,64,64,64,64,64,-453,64,64,64,-233,64,-257,-225,64,-249,64,-254,64,64,-242,64,64,64,64,-454,64,64,64,64,64,-80,-88,-78,-79,64,64,64,-230,64,-226,-227,-235,-132,64,64,-244,64,64,64,-237,64,64,64,64,64,64,-89,-258,64,-229,64,-228,64,-13,-28,-25,-14,-27,-26,-239,-240,-245,64,-453,64,-234,64,64,64,64,-259,64,-232,64,64,64,64,-65,64,-29,64,64,64,64,64,-454,64,64,-81,64,-231,-45,-47,-66,-15,-16,-73,-40,-236,64,-246,-247,64,64,-43,64,-72,-71,-69,-70,-17,-241,-82,64,-46,-48,-41,64,64,-44,-18,64,64,-42,64,]),'RSQB':([11,12,20,24,28,31,33,36,38,39,48,50,53,55,69,71,72,78,81,97,108,112,114,116,134,135,143,146,152,154,159,163,165,167,169,173,184,190,191,192,198,209,215,223,228,235,236,237,238,239,240,247,248,249,255,262,269,270,275,276,277,279,286,287,288,289,290,291,292,293,294,303,313,315,316,317,318,326,349,357,364,371,377,384,385,386,387,388,389,390,391,401,411,412,413,421,450,475,476,477,478,479,497,550,551,552,565,566,567,568,619,628,629,630,633,683,684,685,687,734,735,736,],[-352,-332,-303,-346,-301,-379,-328,-380,-360,-336,-304,-312,-340,-364,191,-377,-314,-378,-308,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-305,-375,-342,-341,-366,-368,-363,313,-373,-383,-315,-309,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-306,-376,-344,-345,-343,-396,-369,-399,-365,-408,-409,-407,-400,391,-406,-479,-374,-382,-384,-385,-316,-310,-335,-331,-339,-307,-397,-367,-412,-414,-410,-411,-402,-401,-398,-480,-387,-386,-317,-311,-302,-413,-415,-419,-403,-404,-388,-417,-416,-405,-458,-470,-476,-475,-418,-459,-461,-460,-471,-462,-473,-472,-477,-463,-474,-478,]),'PRAGMA':([0,6,9,13,15,17,19,25,29,42,44,46,54,62,66,68,79,92,96,102,104,138,139,205,206,207,266,334,346,367,368,404,425,434,447,456,460,498,499,501,504,515,518,521,522,534,536,539,543,570,571,578,581,583,586,597,598,601,603,604,606,608,609,611,627,637,638,639,640,642,643,650,652,663,666,668,688,690,691,692,699,702,703,705,709,711,712,714,715,716,717,719,720,722,724,726,727,737,744,745,747,749,750,752,753,755,757,758,759,761,762,763,767,771,780,783,784,787,788,790,791,792,796,807,809,810,811,812,813,814,815,816,817,818,821,828,831,832,833,834,835,836,838,],[91,-220,-11,-76,-135,-223,-219,-217,-221,-10,-136,-8,-9,-7,91,-222,91,-224,-218,-137,-138,-261,-260,-77,-12,-6,-131,-32,-248,-243,-238,-233,-257,-225,-249,-254,-242,-80,-88,-78,-79,-33,-230,-226,-227,-235,-132,-244,-237,91,-89,-258,-34,-229,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-85,-102,-87,91,-86,-83,-259,-232,-65,91,-29,-103,-81,-84,91,-231,-45,-47,-66,-15,-16,-73,-21,-24,-22,91,-23,-19,-40,-236,-246,-247,91,-63,-49,-50,-60,-62,-61,-43,-72,-71,-69,-70,-17,-20,91,-241,-82,-128,-104,-106,91,-64,-46,-48,91,-41,-129,-51,-52,91,-54,-56,-59,-57,-58,-44,-18,-42,-130,-105,-107,-53,-55,-75,-74,-125,]),'PERCENT':([11,31,36,38,55,71,78,97,108,112,114,143,154,163,169,173,184,191,223,228,235,236,237,238,239,270,279,286,287,288,313,377,384,391,],[110,-379,-380,-360,-364,-377,-378,-370,-361,-354,110,-381,-362,-375,-366,-368,-363,-373,-372,-371,-356,-358,-359,-357,-355,-376,-396,-369,-399,-365,-374,-397,-367,-398,]),'DOUBLESLASH':([11,31,36,38,55,71,78,97,108,112,114,143,154,163,169,173,184,191,223,228,235,236,237,238,239,270,279,286,287,288,313,377,384,391,],[111,-379,-380,-360,-364,-377,-378,-370,-361,-354,111,-381,-362,-375,-366,-368,-363,-373,-372,-371,-356,-358,-359,-357,-355,-376,-396,-369,-399,-365,-374,-397,-367,-398,]),'EQUAL':([11,12,16,20,24,28,31,33,36,38,39,48,50,53,55,71,72,78,81,83,88,97,108,112,114,116,134,135,143,146,152,154,159,163,165,167,169,173,176,177,184,191,198,209,211,212,214,215,223,228,235,236,237,238,239,240,245,246,247,248,249,255,262,269,270,275,276,277,279,283,286,287,288,303,313,318,326,327,328,349,357,364,371,377,384,391,394,399,401,413,416,421,422,450,484,572,599,657,658,697,710,713,721,746,756,760,765,803,],[-352,-332,124,-303,-346,-301,-379,-328,-380,-360,-336,-304,-312,-340,-364,-377,-314,-378,-308,-211,-180,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-305,-375,-342,-341,-366,-368,-508,299,-363,-373,-315,-309,-213,-212,-181,-313,-372,-371,-356,-358,-359,-357,-355,-334,124,124,-349,-350,-351,-330,-338,-306,-376,-344,-345,-343,-396,381,-369,-399,-365,-479,-374,-316,-310,-214,-215,-335,-331,-339,-307,-397,-367,-398,-509,489,-480,-317,507,-311,-216,-302,556,645,660,660,660,754,660,-67,660,660,660,-68,660,660,]),'PLUSEQUAL':([11,12,16,20,24,28,31,33,36,38,39,48,50,53,55,71,72,78,81,83,97,108,112,114,116,134,135,143,146,152,154,159,163,165,167,169,173,184,191,198,209,211,212,215,223,228,235,236,237,238,239,240,247,248,249,255,262,269,270,275,276,277,279,286,287,288,303,313,318,326,327,328,349,357,364,371,377,384,391,401,413,421,422,450,],[-352,-332,126,-303,-346,-301,-379,-328,-380,-360,-336,-304,-312,-340,-364,-377,-314,-378,-308,-211,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-305,-375,-342,-341,-366,-368,-363,-373,-315,-309,-213,-212,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-306,-376,-344,-345,-343,-396,-369,-399,-365,-479,-374,-316,-310,-214,-215,-335,-331,-339,-307,-397,-367,-398,-480,-317,-311,-216,-302,]),'ELLIPSIS':([94,172,220,221,222,338,340,390,478,],[220,294,-281,338,-279,-282,-280,294,294,]),'LESSEQUAL':([11,12,24,31,33,36,38,39,53,55,71,72,78,97,108,112,114,116,134,135,143,146,152,154,163,165,167,169,173,184,191,198,223,228,235,236,237,238,239,240,247,248,249,255,262,270,275,276,277,279,286,287,288,313,318,349,357,364,377,384,391,413,],[-352,-332,-346,-379,-328,-380,-360,-336,-340,-364,-377,202,-378,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-375,-342,-341,-366,-368,-363,-373,202,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-376,-344,-345,-343,-396,-369,-399,-365,-374,-316,-335,-331,-339,-397,-367,-398,-317,]),'LSQB':([0,1,6,7,9,10,13,14,15,17,19,25,29,30,31,32,34,36,40,42,44,45,46,51,54,55,58,60,62,64,68,69,71,78,79,80,88,89,92,93,96,97,102,103,104,109,110,111,113,115,119,120,121,122,123,124,125,126,127,128,129,130,131,132,136,137,138,139,141,143,147,150,153,158,160,163,164,166,168,169,171,172,173,180,191,193,194,195,196,197,199,201,202,203,205,206,207,210,212,223,224,226,228,229,231,232,233,241,242,252,254,256,261,264,266,268,270,271,273,278,279,280,282,285,286,287,289,290,299,301,304,307,313,314,316,319,320,321,324,325,327,329,330,331,335,342,346,348,354,356,359,360,363,366,367,368,369,373,377,378,380,381,383,387,388,390,391,404,412,425,434,444,447,448,456,457,458,460,463,465,468,470,472,475,478,489,491,496,498,499,501,504,506,507,511,518,519,521,522,534,536,537,538,539,540,541,542,543,544,547,548,551,556,564,571,578,579,583,585,586,596,597,598,601,603,604,606,608,609,611,614,615,618,627,631,632,635,645,650,651,652,656,659,660,661,663,664,668,669,671,672,673,675,676,685,686,690,693,699,702,703,705,709,711,712,722,724,725,726,727,730,738,753,754,755,757,758,759,761,767,771,774,790,791,796,798,800,817,818,819,820,821,823,],[69,69,-220,69,-11,69,-76,69,-135,-223,-219,-217,-221,69,-379,69,69,-380,69,-10,-136,69,-8,69,-9,172,69,69,-7,69,-222,69,-377,-378,69,69,69,69,-224,69,-218,-370,-137,69,-138,69,69,69,69,69,69,-205,-196,-200,-195,69,-198,-202,-197,-201,-204,-206,-203,-199,69,69,-261,-260,69,-381,69,69,69,69,69,-375,69,69,69,172,69,69,-368,69,-373,-323,69,-319,-318,-326,-321,-324,-322,-320,-77,-12,-6,69,69,-372,69,69,-371,69,69,69,69,69,69,69,69,69,69,69,-131,69,-376,69,69,69,-396,69,69,69,-369,-399,69,69,69,69,69,69,-374,69,69,-327,69,-325,69,69,69,69,69,69,69,69,-248,69,69,69,69,69,69,69,-243,-238,69,69,-397,69,69,69,-453,69,69,69,-398,-233,69,-257,-225,69,-249,69,-254,69,69,-242,69,69,69,69,-454,69,69,69,69,69,-80,-88,-78,-79,69,69,69,-230,69,-226,-227,-235,-132,69,69,-244,69,69,69,-237,69,69,69,69,69,69,-89,-258,69,-229,69,-228,69,-13,-28,-25,-14,-27,-26,-239,-240,-245,69,-453,69,-234,69,69,69,69,-259,69,-232,69,69,69,69,-65,69,-29,69,69,69,69,69,-454,69,69,-81,69,-231,-45,-47,-66,-15,-16,-73,-40,-236,69,-246,-247,69,69,-43,69,-72,-71,-69,-70,-17,-241,-82,69,-46,-48,-41,69,69,-44,-18,69,69,-42,69,]),'RIGHTARROW':([721,],[764,]),'GREATER':([11,12,24,31,33,36,38,39,53,55,71,72,78,97,108,112,114,116,134,135,143,146,152,154,163,165,167,169,173,184,191,198,223,228,235,236,237,238,239,240,247,248,249,255,262,270,275,276,277,279,286,287,288,313,318,349,357,364,377,384,391,413,],[-352,-332,-346,-379,-328,-380,-360,-336,-340,-364,-377,195,-378,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-375,-342,-341,-366,-368,-363,-373,195,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-376,-344,-345,-343,-396,-369,-399,-365,-374,-316,-335,-331,-339,-397,-367,-398,-317,]),'VBAREQUAL':([11,12,16,20,24,28,31,33,36,38,39,48,50,53,55,71,72,78,81,83,97,108,112,114,116,134,135,143,146,152,154,159,163,165,167,169,173,184,191,198,209,211,212,215,223,228,235,236,237,238,239,240,247,248,249,255,262,269,270,275,276,277,279,286,287,288,303,313,318,326,327,328,349,357,364,371,377,384,391,401,413,421,422,450,],[-352,-332,130,-303,-346,-301,-379,-328,-380,-360,-336,-304,-312,-340,-364,-377,-314,-378,-308,-211,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-305,-375,-342,-341,-366,-368,-363,-373,-315,-309,-213,-212,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-306,-376,-344,-345,-343,-396,-369,-399,-365,-479,-374,-316,-310,-214,-215,-335,-331,-339,-307,-397,-367,-398,-480,-317,-311,-216,-302,]),'BREAK':([0,6,9,13,15,17,19,25,29,42,44,46,54,62,68,79,92,96,102,103,104,138,139,158,205,206,207,229,232,266,307,330,335,346,348,363,366,367,368,404,425,434,447,456,457,458,460,463,465,498,499,501,504,511,518,521,522,534,536,537,538,539,541,543,564,571,578,579,583,585,586,597,598,601,603,604,606,608,609,611,627,650,651,652,663,664,668,669,671,672,690,699,702,703,705,709,711,712,722,724,725,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,819,820,821,],[73,-220,-11,-76,-135,-223,-219,-217,-221,-10,-136,-8,-9,-7,-222,73,-224,-218,-137,73,-138,-261,-260,73,-77,-12,-6,73,73,-131,73,73,73,-248,73,73,73,-243,-238,-233,-257,-225,-249,-254,73,73,-242,73,73,-80,-88,-78,-79,73,-230,-226,-227,-235,-132,73,73,-244,73,-237,73,-89,-258,73,-229,73,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,73,-232,-65,73,-29,73,73,73,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,73,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,73,73,-42,]),'TEMPLATE':([0,6,9,13,15,17,19,25,29,42,44,46,54,62,66,68,76,79,92,96,102,104,138,139,185,205,206,207,266,334,346,367,368,404,425,434,447,456,460,498,499,501,504,515,518,521,522,534,536,539,543,571,578,581,583,586,597,598,601,603,604,606,608,609,611,627,650,652,663,668,690,699,702,703,705,709,711,712,722,724,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,821,],[74,-220,-11,-76,-135,-223,-219,-217,-221,-10,-136,-8,-9,-7,-31,-222,74,74,-224,-218,-137,-138,-261,-260,-30,-77,-12,-6,-131,-32,-248,-243,-238,-233,-257,-225,-249,-254,-242,-80,-88,-78,-79,-33,-230,-226,-227,-235,-132,-244,-237,-89,-258,-34,-229,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,-232,-65,-29,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,-42,]),'STAREQUAL':([11,12,16,20,24,28,31,33,36,38,39,48,50,53,55,71,72,78,81,83,97,108,112,114,116,134,135,143,146,152,154,159,163,165,167,169,173,184,191,198,209,211,212,215,223,228,235,236,237,238,239,240,247,248,249,255,262,269,270,275,276,277,279,286,287,288,303,313,318,326,327,328,349,357,364,371,377,384,391,401,413,421,422,450,],[-352,-332,120,-303,-346,-301,-379,-328,-380,-360,-336,-304,-312,-340,-364,-377,-314,-378,-308,-211,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-305,-375,-342,-341,-366,-368,-363,-373,-315,-309,-213,-212,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-306,-376,-344,-345,-343,-396,-369,-399,-365,-479,-374,-316,-310,-214,-215,-335,-331,-339,-307,-397,-367,-398,-480,-317,-311,-216,-302,]),'ELIF':([102,104,266,434,518,536,699,],[-137,-138,-131,519,519,-132,-231,]),'CONST':([102,104,266,414,499,536,570,571,637,638,639,640,642,643,663,688,691,692,702,703,705,712,722,737,744,745,747,749,750,752,753,755,757,758,759,780,783,784,788,790,791,796,807,809,810,817,821,828,831,832,833,838,],[-137,-138,-131,503,-88,-132,503,-89,-85,-102,-87,503,-86,-83,-65,-103,-84,503,-45,-47,-66,-73,-40,503,-63,-49,-50,-60,-62,-61,-43,-72,-71,-69,-70,-128,-104,-106,-64,-46,-48,-41,-129,-51,-52,-44,-42,-130,-105,-107,-53,-125,]),'SLASHEQUAL':([11,12,16,20,24,28,31,33,36,38,39,48,50,53,55,71,72,78,81,83,97,108,112,114,116,134,135,143,146,152,154,159,163,165,167,169,173,184,191,198,209,211,212,215,223,228,235,236,237,238,239,240,247,248,249,255,262,269,270,275,276,277,279,286,287,288,303,313,318,326,327,328,349,357,364,371,377,384,391,401,413,421,422,450,],[-352,-332,129,-303,-346,-301,-379,-328,-380,-360,-336,-304,-312,-340,-364,-377,-314,-378,-308,-211,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-305,-375,-342,-341,-366,-368,-363,-373,-315,-309,-213,-212,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-306,-376,-344,-345,-343,-396,-369,-399,-365,-479,-374,-316,-310,-214,-215,-335,-331,-339,-307,-397,-367,-398,-480,-317,-311,-216,-302,]),'NUMBER':([0,1,6,7,9,10,13,14,15,17,19,25,29,30,32,34,40,42,44,45,46,51,54,58,60,62,64,68,69,79,80,88,89,92,93,96,102,103,104,109,110,111,113,115,119,120,121,122,123,124,125,126,127,128,129,130,131,132,136,137,138,139,141,147,150,153,158,160,164,166,168,171,172,180,193,194,195,196,197,199,201,202,203,205,206,207,210,212,224,226,229,231,232,233,241,242,252,254,256,261,264,266,268,271,273,278,280,282,285,289,290,299,301,304,307,314,316,319,320,321,324,325,327,329,330,331,333,335,342,346,348,354,356,359,360,363,366,367,368,369,373,378,380,381,383,387,388,390,404,412,425,434,444,447,448,456,457,458,460,463,465,468,470,472,475,478,489,491,496,498,499,501,504,506,507,511,517,518,519,521,522,534,536,537,538,539,540,541,542,543,544,547,548,551,556,564,571,578,579,583,585,586,596,597,598,601,603,604,606,608,609,611,614,615,618,627,631,632,635,645,650,651,652,656,659,660,661,663,664,668,669,671,672,673,675,676,685,686,690,693,699,702,703,705,709,711,712,722,724,725,726,727,730,738,753,754,755,757,758,759,761,767,771,774,790,791,796,798,800,817,818,819,820,821,823,],[78,78,-220,78,-11,78,-76,78,-135,-223,-219,-217,-221,78,78,78,78,-10,-136,78,-8,78,-9,78,78,-7,78,-222,78,78,78,78,78,-224,78,-218,-137,78,-138,78,78,78,78,78,78,-205,-196,-200,-195,78,-198,-202,-197,-201,-204,-206,-203,-199,78,78,-261,-260,78,78,78,78,78,78,78,78,78,78,78,78,-323,78,-319,-318,-326,-321,-324,-322,-320,-77,-12,-6,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,-131,78,78,78,78,78,78,78,78,78,78,78,78,78,78,78,-327,78,-325,78,78,78,78,78,78,429,78,78,-248,78,78,78,78,78,78,78,-243,-238,78,78,78,78,78,-453,78,78,78,-233,78,-257,-225,78,-249,78,-254,78,78,-242,78,78,78,78,-454,78,78,78,78,78,-80,-88,-78,-79,78,78,78,429,-230,78,-226,-227,-235,-132,78,78,-244,78,78,78,-237,78,78,78,78,78,78,-89,-258,78,-229,78,-228,78,-13,-28,-25,-14,-27,-26,-239,-240,-245,78,-453,78,-234,78,78,78,78,-259,78,-232,78,78,78,78,-65,78,-29,78,78,78,78,78,-454,78,78,-81,78,-231,-45,-47,-66,-15,-16,-73,-40,-236,78,-246,-247,78,78,-43,78,-72,-71,-69,-70,-17,-241,-82,78,-46,-48,-41,78,78,-44,-18,78,78,-42,78,]),'RPAR':([1,11,12,20,24,28,31,33,36,38,39,48,50,53,55,71,72,78,81,83,88,97,98,99,100,108,112,114,116,134,135,143,146,152,154,159,163,165,167,168,169,173,176,177,184,191,198,209,211,212,214,215,223,225,226,227,228,235,236,237,238,239,240,247,248,249,255,259,262,269,270,275,276,277,279,281,283,284,286,287,288,295,296,297,298,300,302,303,313,318,323,326,327,328,329,331,333,342,343,349,353,357,362,364,371,375,376,377,379,382,383,384,391,392,393,394,396,397,399,401,413,416,417,419,421,422,424,427,428,429,431,432,433,435,437,445,450,471,472,473,474,480,481,484,486,487,488,490,505,509,523,524,526,530,531,546,553,554,555,557,558,562,567,568,573,574,577,582,587,588,589,591,593,594,595,616,617,621,624,625,648,649,653,655,677,679,680,682,687,693,698,700,729,731,736,740,741,742,768,770,772,773,775,797,799,822,824,837,],[97,-352,-332,-303,-346,-301,-379,-328,-380,-360,-336,-304,-312,-340,-364,-377,-314,-378,-308,-211,-180,-370,223,-390,228,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-305,-375,-342,-341,279,-366,-368,-508,-484,-363,-373,-315,-309,-213,-212,-181,-313,-372,-392,-391,-389,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,361,-338,-306,-376,-344,-345,-343,-396,377,-455,-439,-369,-399,-365,-510,394,-501,-489,-485,-503,-479,-374,-316,418,-310,-214,-215,423,426,430,-393,-394,-335,449,-331,455,-339,-307,-441,-443,-397,-444,-456,-440,-367,-398,-511,-512,-509,-490,-494,-504,-480,-317,-99,508,-92,-311,-216,512,514,-37,-38,516,-36,-39,-287,-283,-395,-302,-446,-445,-448,-457,-514,-513,-506,-499,-495,-481,-483,-93,-94,-288,-289,590,592,-464,-449,-515,-502,-486,-488,-500,-505,-476,-475,-100,-101,-97,-35,-291,-290,-284,654,-467,-466,-465,-442,-451,-507,-491,-493,-98,-95,-292,-468,-447,-496,-498,-482,-477,739,-96,-469,-450,-487,-478,-117,-110,776,-452,-492,-111,-118,-112,-497,-115,-113,-116,-114,]),'ASSERT':([0,6,9,13,15,17,19,25,29,42,44,46,54,62,68,79,92,96,102,103,104,138,139,158,205,206,207,229,232,266,307,330,335,346,348,363,366,367,368,404,425,434,447,456,457,458,460,463,465,498,499,501,504,511,518,521,522,534,536,537,538,539,541,543,564,571,578,579,583,585,586,597,598,601,603,604,606,608,609,611,627,650,651,652,663,664,668,669,671,672,690,699,702,703,705,709,711,712,722,724,725,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,819,820,821,],[80,-220,-11,-76,-135,-223,-219,-217,-221,-10,-136,-8,-9,-7,-222,80,-224,-218,-137,80,-138,-261,-260,80,-77,-12,-6,80,80,-131,80,80,80,-248,80,80,80,-243,-238,-233,-257,-225,-249,-254,80,80,-242,80,80,-80,-88,-78,-79,80,-230,-226,-227,-235,-132,80,80,-244,80,-237,80,-89,-258,80,-229,80,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,80,-232,-65,80,-29,80,80,80,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,80,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,80,80,-42,]),'RIGHTSHIFTEQUAL':([11,12,16,20,24,28,31,33,36,38,39,48,50,53,55,71,72,78,81,83,97,108,112,114,116,134,135,143,146,152,154,159,163,165,167,169,173,184,191,198,209,211,212,215,223,228,235,236,237,238,239,240,247,248,249,255,262,269,270,275,276,277,279,286,287,288,303,313,318,326,327,328,349,357,364,371,377,384,391,401,413,421,422,450,],[-352,-332,131,-303,-346,-301,-379,-328,-380,-360,-336,-304,-312,-340,-364,-377,-314,-378,-308,-211,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-305,-375,-342,-341,-366,-368,-363,-373,-315,-309,-213,-212,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-306,-376,-344,-345,-343,-396,-369,-399,-365,-479,-374,-316,-310,-214,-215,-335,-331,-339,-307,-397,-367,-398,-480,-317,-311,-216,-302,]),'GREATEREQUAL':([11,12,24,31,33,36,38,39,53,55,71,72,78,97,108,112,114,116,134,135,143,146,152,154,163,165,167,169,173,184,191,198,223,228,235,236,237,238,239,240,247,248,249,255,262,270,275,276,277,279,286,287,288,313,318,349,357,364,377,384,391,413,],[-352,-332,-346,-379,-328,-380,-360,-336,-340,-364,-377,199,-378,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-375,-342,-341,-366,-368,-363,-373,199,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-376,-344,-345,-343,-396,-369,-399,-365,-374,-316,-335,-331,-339,-397,-367,-398,-317,]),'SEMI':([3,4,11,12,16,18,20,21,22,24,28,30,31,33,34,36,37,38,39,41,48,49,50,52,53,55,56,58,61,63,65,70,71,72,73,75,78,81,82,83,84,85,87,88,95,97,101,108,112,114,116,117,118,134,135,142,143,144,145,146,148,149,152,154,159,163,165,167,169,173,181,182,184,186,187,188,189,191,198,208,209,211,212,214,215,223,228,230,235,236,237,238,239,240,243,244,245,246,247,248,249,252,253,255,256,257,258,262,269,270,275,276,277,279,286,287,288,303,305,309,312,313,318,326,327,328,344,349,350,351,352,355,356,357,358,359,364,371,377,384,391,401,402,403,405,407,408,413,420,421,422,435,436,437,439,442,443,450,451,452,453,454,492,494,495,523,524,527,529,532,563,587,588,589,590,592,653,654,],[103,-268,-352,-332,-191,-152,-303,-165,-144,-346,-301,-173,-379,-328,-153,-380,-148,-360,-336,-151,-304,-149,-312,-147,-340,-364,-172,-175,-168,-167,-145,-169,-377,-314,-171,-170,-378,-308,-166,-211,-150,-267,-179,-180,-146,-370,229,-361,-354,-353,-333,-186,-194,-347,-348,-174,-381,-164,-420,-329,-155,-154,-337,-362,-305,-375,-342,-341,-366,-368,-176,-182,-363,-285,-297,-269,-293,-373,-315,-189,-309,-213,-212,-181,-313,-372,-371,-142,-356,-358,-359,-357,-355,-334,-193,-192,-208,-207,-349,-350,-351,-421,-422,-330,-159,-160,-156,-338,-306,-376,-344,-345,-343,-396,-369,-399,-365,-479,-183,-298,-294,-374,-316,-310,-214,-215,-143,-335,-187,-210,-209,-424,-423,-331,-162,-161,-339,-307,-397,-367,-398,-480,-177,-185,-286,-299,-295,-317,-190,-311,-216,-287,-270,-283,-271,-276,-277,-302,-425,-163,-158,-157,-184,-300,-296,-288,-289,-273,-274,-188,-178,-291,-290,-284,-272,-278,-292,-275,]),'DOUBLESLASHEQUAL':([11,12,16,20,24,28,31,33,36,38,39,48,50,53,55,71,72,78,81,83,97,108,112,114,116,134,135,143,146,152,154,159,163,165,167,169,173,184,191,198,209,211,212,215,223,228,235,236,237,238,239,240,247,248,249,255,262,269,270,275,276,277,279,286,287,288,303,313,318,326,327,328,349,357,364,371,377,384,391,401,413,421,422,450,],[-352,-332,127,-303,-346,-301,-379,-328,-380,-360,-336,-304,-312,-340,-364,-377,-314,-378,-308,-211,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-305,-375,-342,-341,-366,-368,-363,-373,-315,-309,-213,-212,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-306,-376,-344,-345,-343,-396,-369,-399,-365,-479,-374,-316,-310,-214,-215,-335,-331,-339,-307,-397,-367,-398,-480,-317,-311,-216,-302,]),'COMMA':([11,12,20,24,28,31,33,36,38,39,48,50,53,55,71,72,78,81,83,97,99,105,106,108,112,114,116,134,135,143,145,146,149,152,154,159,162,163,165,167,169,173,176,177,181,182,184,186,187,189,191,192,198,208,209,211,215,223,225,228,235,236,237,238,239,240,247,248,249,253,255,257,258,262,269,270,272,275,276,277,279,283,284,286,287,288,289,290,291,292,294,295,297,298,303,309,312,313,317,318,326,328,343,345,347,349,350,355,357,358,364,371,372,374,375,377,379,382,384,385,386,387,388,389,391,393,394,397,399,401,402,403,405,407,408,411,413,416,419,421,422,428,429,432,433,435,437,445,450,451,452,454,464,466,467,471,474,475,476,477,479,480,484,486,488,494,495,497,509,524,531,546,550,551,552,553,555,562,566,567,568,573,574,577,587,589,593,594,595,617,619,621,624,633,648,653,655,674,679,684,687,700,728,735,736,740,741,773,775,779,799,806,824,],[-352,-332,-303,-346,-301,-379,-328,-380,-360,-336,-304,-312,-340,-364,-377,-314,-378,-308,212,-370,226,-250,233,-361,-354,-353,-333,-347,-348,-381,252,-329,256,-337,-362,-305,271,-375,-342,-341,-366,-368,-508,300,304,306,-363,-285,-297,311,-373,316,-315,324,-309,327,-313,-372,342,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,356,-330,359,360,-338,-306,-376,373,-344,-345,-343,-396,-455,383,-369,-399,-365,-408,-409,-407,390,-406,392,395,396,-479,-298,409,-374,412,-316,-310,-215,-394,-251,233,-335,448,-424,-331,-162,-339,-307,-437,468,470,-397,472,-456,-367,-412,-414,-410,-411,478,-398,481,-509,487,-504,-480,491,306,-286,-299,-295,-387,-317,-99,510,-311,-216,-37,-38,517,-39,523,-283,-395,-302,-425,-163,256,542,-438,544,549,-457,-413,-415,-419,-404,-514,-506,558,561,-300,-296,-388,575,588,-464,615,-417,-416,-405,-515,620,-505,632,-476,-475,-100,-101,-97,-291,-284,-467,-466,-465,676,-418,-507,681,685,-98,-292,-468,-435,732,-473,-477,-469,-436,-474,-478,-117,774,-118,800,804,-115,830,-116,]),'CLASS':([0,6,9,13,15,17,19,23,25,26,29,42,44,46,54,62,68,79,92,96,102,104,133,138,139,205,206,207,266,332,346,366,367,368,404,425,434,447,456,458,460,498,499,501,504,513,518,521,522,534,536,539,543,571,578,580,583,586,597,598,601,603,604,606,608,609,611,627,650,652,663,668,690,699,702,703,705,709,711,712,722,724,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,821,],[86,-220,-11,-76,-135,-223,-219,-263,-217,86,-221,-10,-136,-8,-9,-7,-222,86,-224,-218,-137,-138,-262,-261,-260,-77,-12,-6,-131,-264,-248,86,-243,-238,-233,-257,-225,-249,-254,86,-242,-80,-88,-78,-79,-265,-230,-226,-227,-235,-132,-244,-237,-89,-258,-266,-229,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,-232,-65,-29,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,-42,]),'RIGHTSHIFT':([11,24,31,34,36,38,53,55,71,78,97,108,112,114,134,135,143,154,163,165,167,169,173,184,191,223,228,235,236,237,238,239,247,248,249,270,275,276,277,279,286,287,288,313,377,384,391,599,657,658,710,713,721,746,756,760,765,803,],[-352,-346,-379,150,-380,-360,166,-364,-377,-378,-370,-361,-354,-353,-347,-348,-381,-362,-375,-342,166,-366,-368,-363,-373,-372,-371,-356,-358,-359,-357,-355,-349,-350,-351,-376,-344,-345,-343,-396,-369,-399,-365,-374,-397,-367,-398,656,656,656,656,-67,656,656,656,-68,656,656,]),'STRING':([0,1,6,7,9,10,13,14,15,17,19,25,29,30,31,32,34,36,40,42,44,45,46,51,54,58,60,62,64,68,69,79,80,88,89,92,93,96,102,103,104,109,110,111,113,115,119,120,121,122,123,124,125,126,127,128,129,130,131,132,136,137,138,139,141,143,147,150,153,158,160,164,166,168,171,172,180,193,194,195,196,197,199,201,202,203,205,206,207,210,212,224,226,229,231,232,233,241,242,252,254,256,261,264,266,268,271,273,278,280,282,285,289,290,299,301,304,307,314,316,319,320,321,324,325,327,329,330,331,333,335,342,346,348,354,356,359,360,363,366,367,368,369,373,378,380,381,383,387,388,390,404,412,425,434,444,447,448,456,457,458,460,463,465,468,470,472,475,478,489,491,496,498,499,501,504,506,507,511,517,518,519,521,522,534,536,537,538,539,540,541,542,543,544,547,548,551,556,564,570,571,578,579,583,585,586,596,597,598,601,603,604,606,608,609,611,614,615,618,627,631,632,635,645,650,651,652,656,659,660,661,663,664,666,668,669,671,672,673,675,676,685,686,690,693,699,702,703,705,709,711,712,722,724,725,726,727,730,738,753,754,755,757,758,759,761,767,771,774,790,791,796,798,800,817,818,819,820,821,823,],[36,36,-220,36,-11,36,-76,36,-135,-223,-219,-217,-221,36,143,36,36,-380,36,-10,-136,36,-8,36,-9,36,36,-7,36,-222,36,36,36,36,36,-224,36,-218,-137,36,-138,36,36,36,36,36,36,-205,-196,-200,-195,36,-198,-202,-197,-201,-204,-206,-203,-199,36,36,-261,-260,36,-381,36,36,36,36,36,36,36,36,36,36,36,-323,36,-319,-318,-326,-321,-324,-322,-320,-77,-12,-6,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,-131,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,-327,36,-325,36,36,36,36,36,36,433,36,36,-248,36,36,36,36,36,36,36,-243,-238,36,36,36,36,36,-453,36,36,36,-233,36,-257,-225,36,-249,36,-254,36,36,-242,36,36,36,36,-454,36,36,36,36,36,-80,-88,-78,-79,36,36,36,433,-230,36,-226,-227,-235,-132,36,36,-244,36,36,36,-237,36,36,36,36,36,36,641,-89,-258,36,-229,36,-228,36,-13,-28,-25,-14,-27,-26,-239,-240,-245,36,-453,36,-234,36,36,36,36,-259,36,-232,36,36,36,36,-65,36,718,-29,36,36,36,36,36,-454,36,36,-81,36,-231,-45,-47,-66,-15,-16,-73,-40,-236,36,-246,-247,36,36,-43,36,-72,-71,-69,-70,-17,-241,-82,36,-46,-48,-41,36,36,-44,-18,36,36,-42,36,]),'COLONEQUAL':([599,657,658,710,713,721,746,756,760,765,803,],[659,659,659,659,-67,659,659,659,-68,659,659,]),'IS':([11,12,24,31,33,36,38,39,53,55,71,72,78,97,108,112,114,116,134,135,143,146,152,154,163,165,167,169,173,184,191,198,223,228,235,236,237,238,239,240,247,248,249,255,262,270,275,276,277,279,286,287,288,313,318,349,357,364,377,384,391,413,],[-352,-332,-346,-379,-328,-380,-360,-336,-340,-364,-377,197,-378,-370,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-375,-342,-341,-366,-368,-363,-373,197,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-376,-344,-345,-343,-396,-369,-399,-365,-374,-316,-335,-331,-339,-397,-367,-398,-317,]),'YIELD':([0,1,6,9,13,15,17,19,25,29,42,44,46,54,62,68,79,92,96,102,103,104,119,120,121,122,123,124,125,126,127,128,129,130,131,132,138,139,158,205,206,207,229,232,266,307,330,335,346,348,363,366,367,368,404,425,434,447,456,457,458,460,463,465,498,499,501,504,511,518,521,522,534,536,537,538,539,541,543,564,571,578,579,583,585,586,597,598,601,603,604,606,608,609,611,627,650,651,652,663,664,668,669,671,672,690,699,702,703,705,709,711,712,722,724,725,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,819,820,821,],[88,88,-220,-11,-76,-135,-223,-219,-217,-221,-10,-136,-8,-9,-7,-222,88,-224,-218,-137,88,-138,88,-205,-196,-200,-195,88,-198,-202,-197,-201,-204,-206,-203,-199,-261,-260,88,-77,-12,-6,88,88,-131,88,88,88,-248,88,88,88,-243,-238,-233,-257,-225,-249,-254,88,88,-242,88,88,-80,-88,-78,-79,88,-230,-226,-227,-235,-132,88,88,-244,88,-237,88,-89,-258,88,-229,88,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,88,-232,-65,88,-29,88,88,88,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,88,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,88,88,-42,]),'ALIAS':([102,104,266,533,536,598,601,604,606,638,662,663,666,668,688,695,702,703,705,712,714,715,716,717,719,720,722,744,745,747,749,750,752,755,757,758,759,762,763,780,783,784,786,787,788,790,791,792,796,807,809,810,811,812,813,814,815,816,821,828,831,832,833,834,835,836,838,],[-137,-138,-131,602,-132,-28,-25,-27,-26,-102,602,-65,602,-29,-103,602,-45,-47,-66,-73,-21,-24,-22,602,-23,-19,-40,-63,-49,-50,-60,-62,-61,-72,-71,-69,-70,-20,602,-128,-104,-106,602,602,-64,-46,-48,602,-41,-129,-51,-52,602,-54,-56,-59,-57,-58,-42,-130,-105,-107,-53,-55,-75,-74,-125,]),'AS':([11,12,20,24,28,31,33,36,38,39,48,50,53,55,71,72,78,81,97,105,108,112,114,116,134,135,143,146,152,154,159,163,165,167,169,173,184,186,187,191,198,209,215,223,228,235,236,237,238,239,240,247,248,249,255,262,269,270,275,276,277,279,286,287,288,303,309,313,318,326,349,357,364,371,377,384,391,401,407,413,421,437,450,464,494,],[-352,-332,-303,-346,-301,-379,-328,-380,-360,-336,-304,-312,-340,-364,-377,-314,-378,-308,-370,231,-361,-354,-353,-333,-347,-348,-381,-329,-337,-362,-305,-375,-342,-341,-366,-368,-363,308,-297,-373,-315,-309,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-306,-376,-344,-345,-343,-396,-369,-399,-365,-479,-298,-374,-316,-310,-335,-331,-339,-307,-397,-367,-398,-480,-299,-317,-311,525,-302,540,-300,]),'AT':([0,6,9,13,15,17,19,23,25,29,42,44,46,54,62,68,79,92,96,102,104,138,139,205,206,207,266,332,346,366,367,368,404,425,434,447,456,458,460,498,499,501,504,513,518,521,522,534,536,539,543,571,578,580,583,586,597,598,601,603,604,606,608,609,611,627,650,652,663,668,690,699,702,703,705,709,711,712,722,724,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,821,],[90,-220,-11,-76,-135,-223,-219,90,-217,-221,-10,-136,-8,-9,-7,-222,90,-224,-218,-137,-138,-261,-260,-77,-12,-6,-131,-264,-248,90,-243,-238,-233,-257,-225,-249,-254,90,-242,-80,-88,-78,-79,-265,-230,-226,-227,-235,-132,-244,-237,-89,-258,-266,-229,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,-232,-65,-29,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,-42,]),'AMPER':([11,24,31,36,38,39,53,55,71,78,97,108,112,114,134,135,143,152,154,163,165,167,169,173,184,191,223,228,235,236,237,238,239,247,248,249,262,270,275,276,277,279,286,287,288,313,364,377,384,391,],[-352,-346,-379,-380,-360,153,-340,-364,-377,-378,-370,-361,-354,-353,-347,-348,-381,261,-362,-375,-342,-341,-366,-368,-363,-373,-372,-371,-356,-358,-359,-357,-355,-349,-350,-351,-338,-376,-344,-345,-343,-396,-369,-399,-365,-374,-339,-397,-367,-398,]),'IN':([11,12,24,31,33,36,38,39,53,55,71,72,78,97,108,112,114,116,117,134,135,143,145,146,152,154,157,163,165,167,169,173,184,191,198,200,223,228,235,236,237,238,239,240,247,248,249,252,253,255,262,270,275,276,277,279,286,287,288,313,318,341,349,355,356,357,364,377,384,391,410,413,451,],[-352,-332,-346,-379,-328,-380,-360,-336,-340,-364,-377,201,-378,-370,-361,-354,-353,-333,242,-347,-348,-381,-420,-329,-337,-362,264,-375,-342,-341,-366,-368,-363,-373,201,321,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-421,-422,-330,-338,-376,-344,-345,-343,-396,-369,-399,-365,-374,-316,444,-335,-424,-423,-331,-339,-397,-367,-398,496,-317,-425,]),'IF':([0,6,9,11,12,13,15,17,19,24,25,28,29,31,33,36,38,39,42,44,46,48,50,53,54,55,62,68,71,72,78,79,81,92,96,97,102,104,108,112,114,116,134,135,138,139,143,146,152,154,159,163,165,167,169,173,184,191,198,205,206,207,209,215,223,228,235,236,237,238,239,240,247,248,249,255,262,266,269,270,275,276,277,279,286,287,288,313,318,326,346,349,357,364,366,367,368,371,377,384,391,404,413,421,425,434,447,456,458,460,498,499,501,504,518,521,522,531,534,536,539,543,565,566,567,568,571,578,583,586,597,598,601,603,604,606,608,609,611,627,633,650,652,655,663,668,683,684,685,687,690,699,702,703,705,709,711,712,722,724,726,727,735,736,753,755,757,758,759,761,767,771,790,791,796,817,818,821,],[93,-220,-11,-352,-332,-76,-135,-223,-219,-346,-217,141,-221,-379,-328,-380,-360,-336,-10,-136,-8,-304,-312,-340,-9,-364,-7,-222,-377,-314,-378,93,-308,-224,-218,-370,-137,-138,-361,-354,-353,-333,-347,-348,-261,-260,-381,-329,-337,-362,-305,-375,-342,-341,-366,-368,-363,-373,-315,-77,-12,-6,-309,-313,-372,-371,-356,-358,-359,-357,-355,-334,-349,-350,-351,-330,-338,-131,-306,-376,-344,-345,-343,-396,-369,-399,-365,-374,-316,-310,-248,-335,-331,-339,93,-243,-238,-307,-397,-367,-398,-233,-317,-311,-257,-225,-249,-254,93,-242,-80,-88,-78,-79,-230,-226,-227,596,-235,-132,-244,-237,631,-470,-476,-475,-89,-258,-229,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-471,-259,-232,596,-65,-29,631,-473,-472,-477,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,-246,-247,-474,-478,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,-42,]),'FROM':([0,6,9,13,15,17,19,25,29,42,44,46,54,62,68,79,92,96,102,103,104,138,139,158,205,206,207,229,232,266,307,330,335,346,348,363,366,367,368,404,425,434,447,456,457,458,460,463,465,498,499,501,504,511,518,521,522,534,536,537,538,539,541,543,564,571,578,579,583,585,586,597,598,601,603,604,606,608,609,611,627,650,651,652,663,664,668,669,671,672,690,699,702,703,705,709,711,712,722,724,725,726,727,753,755,757,758,759,761,767,771,790,791,796,817,818,819,820,821,],[94,-220,-11,-76,-135,-223,-219,-217,-221,-10,-136,-8,-9,-7,-222,94,-224,-218,-137,94,-138,-261,-260,94,-77,-12,-6,94,94,-131,94,94,94,-248,94,94,94,-243,-238,-233,-257,-225,-249,-254,94,94,-242,94,94,-80,-88,-78,-79,94,-230,-226,-227,-235,-132,94,94,-244,94,-237,94,-89,-258,94,-229,94,-228,-13,-28,-25,-14,-27,-26,-239,-240,-245,-234,-259,94,-232,-65,94,-29,94,94,94,-81,-231,-45,-47,-66,-15,-16,-73,-40,-236,94,-246,-247,-43,-72,-71,-69,-70,-17,-241,-82,-46,-48,-41,-44,-18,94,94,-42,]),}

_lr_action = { }
for _k, _v in _lr_action_items.items():
   for _x,_y in zip(_v[0],_v[1]):
      if not _x in _lr_action:  _lr_action[_x] = { }
      _lr_action[_x][_k] = _y
del _lr_action_items

_lr_goto_items = {'import_as_name':([336,339,438,440,441,523,528,588,],[435,435,435,435,435,587,435,653,]),'try_stmt':([0,79,366,458,],[6,6,6,6,]),'child_def_suite_items':([787,],[811,]),'small_stmt':([0,79,103,158,229,232,307,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[3,3,230,3,344,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,]),'template_inst':([570,640,666,692,717,737,763,787,792,811,],[639,639,715,639,715,639,715,814,715,814,]),'augassign':([16,],[119,]),'import_from':([0,79,103,158,229,232,307,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,]),'small_stmt_list':([0,79,158,232,307,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,]),'import_as_names':([336,339,438,440,441,528,],[439,443,526,529,530,591,]),'else_stmt':([434,521,],[522,586,]),'enamldef_suite':([533,662,],[597,709,]),'comp_op':([72,198,],[194,320,]),'parameters':([151,764,765,],[260,793,794,]),'enamldef_impl':([0,76,79,],[9,206,9,]),'factor':([0,1,7,10,14,30,32,34,40,45,51,58,60,64,69,79,80,88,89,93,103,109,110,111,113,115,119,124,136,137,141,147,150,153,158,160,164,166,168,171,172,180,194,210,212,224,226,229,231,232,233,241,242,252,254,256,261,264,268,271,273,278,280,282,285,289,290,299,301,304,307,314,316,320,324,325,327,329,330,331,335,342,348,354,356,359,360,363,366,369,373,378,380,381,387,388,390,412,444,448,457,458,463,465,468,470,475,478,489,491,496,506,507,511,519,537,538,540,541,542,544,547,548,551,556,564,579,585,596,614,618,631,632,635,645,651,656,659,660,661,664,669,671,672,673,675,685,686,693,725,730,738,754,774,798,800,819,820,823,],[11,11,11,108,11,11,11,11,154,11,11,11,11,184,11,11,11,11,11,11,11,235,236,237,238,11,11,11,11,11,11,11,11,11,11,11,11,11,11,288,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,384,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,]),'suite':([158,232,307,330,335,348,363,457,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[267,346,404,425,434,447,456,534,539,543,578,608,609,611,627,650,652,699,712,724,726,727,767,835,836,]),'globals_list':([182,403,],[305,492,]),'exec_stmt':([0,79,103,158,229,232,307,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,41,]),'and_expr_list':([39,],[152,]),'or_test_list':([48,],[159,]),'template_impl':([0,76,79,],[13,205,13,]),'simple_stmt':([0,79,158,232,307,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[15,15,266,266,266,266,266,266,266,15,266,15,266,266,266,266,266,266,266,266,266,266,266,266,266,266,266,266,266,]),'dotted_as_names_list':([189,],[312,]),'subscriptlist':([172,],[293,]),'testlist':([0,30,79,88,103,119,124,158,229,232,264,307,329,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[16,142,16,214,16,244,246,16,16,16,365,16,424,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,]),'classdef':([0,26,79,366,458,],[17,138,17,17,17,]),'assert_stmt':([0,79,103,158,229,232,307,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,]),'for_stmt':([0,79,366,458,],[19,19,19,19,]),'template_arglist':([693,],[742,]),'lambdef':([0,1,7,30,34,51,58,60,69,79,80,88,93,103,119,124,150,158,168,172,180,212,226,229,232,233,242,256,264,271,273,278,280,282,289,290,299,301,304,307,316,324,327,329,330,331,335,342,348,354,359,360,363,366,369,373,378,380,381,387,388,390,412,448,457,458,463,465,468,470,475,478,489,491,506,507,511,519,537,538,540,541,542,544,547,548,551,556,564,579,585,614,618,645,651,656,659,660,661,664,669,671,672,673,675,693,725,730,738,754,774,798,800,819,820,823,],[20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,]),'expr_stmt':([0,79,103,158,229,232,307,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,]),'child_def_suite_item':([787,811,],[812,834,]),'decl_funcdef':([666,717,763,787,792,811,],[716,716,716,815,716,815,]),'decorator':([0,23,79,366,458,],[23,23,23,23,23,]),'arith_op':([24,134,],[135,247,]),'term':([0,1,7,14,30,32,34,45,51,58,60,69,79,80,88,89,93,103,115,119,124,136,137,141,147,150,153,158,160,164,166,168,172,180,194,210,212,224,226,229,231,232,233,241,242,252,254,256,261,264,268,271,273,278,280,282,289,290,299,301,304,307,314,316,320,324,325,327,329,330,331,335,342,348,354,356,359,360,363,366,369,373,378,380,381,387,388,390,412,444,448,457,458,463,465,468,470,475,478,489,491,496,506,507,511,519,537,538,540,541,542,544,547,548,551,556,564,579,585,596,614,618,631,632,635,645,651,656,659,660,661,664,669,671,672,673,675,685,686,693,725,730,738,754,774,798,800,819,820,823,],[24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,248,249,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,]),'ex_binding':([533,662,666,695,717,763,786,787,792,811,],[606,606,606,752,606,606,752,752,606,752,]),'enamldef_suite_item':([666,717,763,792,],[720,762,720,762,]),'if_stmt':([0,79,366,458,],[25,25,25,25,]),'ex_dotted_names':([599,710,713,721,746,766,779,825,],[658,658,760,658,658,795,803,803,]),'enaml_module':([0,],[43,]),'or_test':([0,1,7,30,34,51,58,60,69,79,80,88,93,103,119,124,141,150,158,168,172,180,212,226,229,232,233,242,256,264,271,273,278,280,282,289,290,299,301,304,307,316,324,327,329,330,331,335,342,348,354,359,360,363,366,369,373,378,380,381,387,388,390,412,444,448,457,458,463,465,468,470,475,478,489,491,496,506,507,511,519,537,538,540,541,542,544,547,548,551,556,564,579,585,596,614,618,631,632,635,645,651,656,659,660,661,664,669,671,672,673,675,685,686,693,725,730,738,754,774,798,800,819,820,823,],[28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,251,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,531,28,28,28,28,28,28,28,28,28,28,28,568,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,568,28,28,568,568,568,28,28,28,28,28,28,28,28,28,28,28,28,568,568,28,28,28,28,28,28,28,28,28,28,28,]),'with_stmt':([0,79,366,458,],[29,29,29,29,]),'comp_for':([99,162,283,374,531,655,740,],[227,274,382,469,594,594,773,]),'and_test_list':([81,],[209,]),'trailer':([55,169,],[173,286,]),'with_item_list':([106,347,],[234,446,]),'expr_list':([33,],[146,]),'varargslist_list':([177,397,],[298,486,]),'atom_string_list':([0,1,7,10,14,30,32,34,40,45,51,58,60,64,69,79,80,88,89,93,103,109,110,111,113,115,119,124,136,137,141,147,150,153,158,160,164,166,168,171,172,180,194,210,212,224,226,229,231,232,233,241,242,252,254,256,261,264,268,271,273,278,280,282,285,289,290,299,301,304,307,314,316,320,324,325,327,329,330,331,335,342,348,354,356,359,360,363,366,369,373,378,380,381,387,388,390,412,444,448,457,458,463,465,468,470,475,478,489,491,496,506,507,511,519,537,538,540,541,542,544,547,548,551,556,564,579,585,596,614,618,631,632,635,645,651,656,659,660,661,664,669,671,672,673,675,685,686,693,725,730,738,754,774,798,800,819,820,823,],[31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,]),'listmaker':([69,],[190,]),'arglist':([168,331,],[281,427,]),'exprlist_list':([145,],[253,]),'flow_stmt':([0,79,103,158,229,232,307,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,]),'comp_if':([531,655,],[593,593,]),'child_def_simple_item':([695,786,787,811,],[747,810,813,813,]),'child_def':([570,640,666,692,717,737,763,787,792,811,],[642,642,719,642,719,642,719,816,719,816,]),'shift_expr':([0,1,7,14,30,32,34,45,51,58,60,69,79,80,88,89,93,103,115,119,124,141,147,150,153,158,160,168,172,180,194,210,212,224,226,229,231,232,233,241,242,252,254,256,261,264,268,271,273,278,280,282,289,290,299,301,304,307,314,316,320,324,325,327,329,330,331,335,342,348,354,356,359,360,363,366,369,373,378,380,381,387,388,390,412,444,448,457,458,463,465,468,470,475,478,489,491,496,506,507,511,519,537,538,540,541,542,544,547,548,551,556,564,579,585,596,614,618,631,632,635,645,651,656,659,660,661,664,669,671,672,673,675,685,686,693,725,730,738,754,774,798,800,819,820,823,],[39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,262,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,364,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,]),'template_suite_items':([570,692,],[640,737,]),'import_from_dots':([94,],[221,]),'arglist_list':([168,331,470,],[282,282,548,]),'list_iter':([565,683,],[628,734,]),'dictorsetmaker':([51,],[161,]),'template':([0,79,],[42,42,]),'list_for':([192,565,683,],[315,630,630,]),'subscript':([172,390,478,],[292,479,552,]),'template_inst_suite':([743,808,],[784,832,]),'decorators':([0,23,79,366,458,],[26,133,26,26,26,]),'compound_stmt':([0,79,366,458,],[44,44,44,44,]),'dosm_comma_list':([162,],[272,]),'dotted_name':([67,90,94,221,311,409,],[186,216,219,337,186,186,]),'power':([0,1,7,10,14,30,32,34,40,45,51,58,60,64,69,79,80,88,89,93,103,109,110,111,113,115,119,124,136,137,141,147,150,153,158,160,164,166,168,171,172,180,194,210,212,224,226,229,231,232,233,241,242,252,254,256,261,264,268,271,273,278,280,282,285,289,290,299,301,304,307,314,316,320,324,325,327,329,330,331,335,342,348,354,356,359,360,363,366,369,373,378,380,381,387,388,390,412,444,448,457,458,463,465,468,470,475,478,489,491,496,506,507,511,519,537,538,540,541,542,544,547,548,551,556,564,579,585,596,614,618,631,632,635,645,651,656,659,660,661,664,669,671,672,673,675,685,686,693,725,730,738,754,774,798,800,819,820,823,],[38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,]),'xor_expr_list':([12,],[116,]),'stmt':([0,79,366,458,],[46,46,458,458,]),'fplist_list':([295,],[393,]),'xor_expr':([0,1,7,14,30,32,34,45,51,58,60,69,79,80,88,89,93,103,119,124,141,147,150,158,160,168,172,180,194,210,212,224,226,229,231,232,233,242,252,254,256,264,268,271,273,278,280,282,289,290,299,301,304,307,314,316,320,324,325,327,329,330,331,335,342,348,354,356,359,360,363,366,369,373,378,380,381,387,388,390,412,444,448,457,458,463,465,468,470,475,478,489,491,496,506,507,511,519,537,538,540,541,542,544,547,548,551,556,564,579,585,596,614,618,631,632,635,645,651,656,659,660,661,664,669,671,672,673,675,685,686,693,725,730,738,754,774,798,800,819,820,823,],[33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,255,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,357,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,]),'term_list':([11,],[114,]),'comparison':([0,1,7,30,34,51,58,60,69,79,80,88,89,93,103,119,124,141,150,158,160,168,172,180,210,212,226,229,232,233,242,256,264,268,271,273,278,280,282,289,290,299,301,304,307,316,324,325,327,329,330,331,335,342,348,354,359,360,363,366,369,373,378,380,381,387,388,390,412,444,448,457,458,463,465,468,470,475,478,489,491,496,506,507,511,519,537,538,540,541,542,544,547,548,551,556,564,579,585,596,614,618,631,632,635,645,651,656,659,660,661,664,669,671,672,673,675,685,686,693,725,730,738,754,774,798,800,819,820,823,],[50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,]),'pass_stmt':([0,79,103,158,229,232,307,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,]),'arith_expr':([0,1,7,14,30,32,34,45,51,58,60,69,79,80,88,89,93,103,115,119,124,141,147,150,153,158,160,164,166,168,172,180,194,210,212,224,226,229,231,232,233,241,242,252,254,256,261,264,268,271,273,278,280,282,289,290,299,301,304,307,314,316,320,324,325,327,329,330,331,335,342,348,354,356,359,360,363,366,369,373,378,380,381,387,388,390,412,444,448,457,458,463,465,468,470,475,478,489,491,496,506,507,511,519,537,538,540,541,542,544,547,548,551,556,564,579,585,596,614,618,631,632,635,645,651,656,659,660,661,664,669,671,672,673,675,685,686,693,725,730,738,754,774,798,800,819,820,823,],[53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,275,276,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,]),'enamldef':([0,79,],[54,54,]),'alias_expr':([533,662,666,695,717,763,786,787,792,811,],[604,604,604,750,604,604,750,750,604,750,]),'import_stmt':([0,79,103,158,229,232,307,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,49,]),'elif_stmts':([434,518,],[521,583,]),'template_inst_suite_item':([743,801,808,826,],[783,827,831,839,]),'comp_iter':([531,655,],[595,700,]),'print_list_list':([149,454,],[257,257,]),'template_argument':([693,774,800,],[741,799,824,]),'dotted_as_names':([67,],[188,]),'shift_op':([53,167,],[165,277,]),'storage_expr':([533,662,666,695,717,763,786,787,792,811,],[598,598,598,744,598,598,744,744,598,744,]),'template_doc_suite':([414,],[498,]),'return_stmt':([0,79,103,158,229,232,307,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,]),'testlist_comp':([1,],[98,]),'old_test':([496,596,631,632,635,685,686,],[566,655,683,684,687,735,736,]),'template_simple_item':([414,570,640,692,737,],[504,637,637,637,637,]),'testlist_safe_list':([566,],[633,]),'template_params':([204,],[322,]),'enaml_module_item':([0,79,],[62,207,]),'child_def_suite':([695,786,],[745,809,]),'continue_stmt':([0,79,103,158,229,232,307,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,]),'testlist_list':([83,],[211,]),'dotted_as_name':([67,311,409,],[189,408,495,]),'template_inst_binding':([743,801,808,826,],[780,780,780,780,]),'enamldef_simple_item':([533,662,666,717,763,792,],[603,711,714,714,714,714,]),'equal_list':([16,245,246,],[118,351,352,]),'enamldef_suite_items':([666,763,],[717,792,]),'print_stmt':([0,79,103,158,229,232,307,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,]),'binding':([533,662,666,695,717,763,786,787,792,811,],[601,601,601,749,601,601,749,749,601,749,]),'const_expr':([414,570,640,692,737,],[499,499,499,499,499,]),'template_inst_suite_items':([801,],[826,]),'term_op':([11,114,],[112,239,]),'pragma':([0,66,79,570,640,666,692,717,737,763,787,792,811,],[66,66,66,66,66,66,66,66,66,66,66,66,66,]),'atom':([0,1,7,10,14,30,32,34,40,45,51,58,60,64,69,79,80,88,89,93,103,109,110,111,113,115,119,124,136,137,141,147,150,153,158,160,164,166,168,171,172,180,194,210,212,224,226,229,231,232,233,241,242,252,254,256,261,264,268,271,273,278,280,282,285,289,290,299,301,304,307,314,316,320,324,325,327,329,330,331,335,342,348,354,356,359,360,363,366,369,373,378,380,381,387,388,390,412,444,448,457,458,463,465,468,470,475,478,489,491,496,506,507,511,519,537,538,540,541,542,544,547,548,551,556,564,579,585,596,614,618,631,632,635,645,651,656,659,660,661,664,669,671,672,673,675,685,686,693,725,730,738,754,774,798,800,819,820,823,],[55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,]),'funcdef':([0,26,79,366,458,],[68,139,68,68,68,]),'raise_stmt':([0,79,103,158,229,232,307,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,]),'old_lambdef':([496,596,631,632,635,685,686,],[567,567,567,567,567,567,567,]),'exprlist':([32,45,224,314,],[144,157,341,410,]),'expr':([0,1,7,14,30,32,34,45,51,58,60,69,79,80,88,89,93,103,119,124,141,150,158,160,168,172,180,194,210,212,224,226,229,231,232,233,242,252,256,264,268,271,273,278,280,282,289,290,299,301,304,307,314,316,320,324,325,327,329,330,331,335,342,348,354,356,359,360,363,366,369,373,378,380,381,387,388,390,412,444,448,457,458,463,465,468,470,475,478,489,491,496,506,507,511,519,537,538,540,541,542,544,547,548,551,556,564,579,585,596,614,618,631,632,635,645,651,656,659,660,661,664,669,671,672,673,675,685,686,693,725,730,738,754,774,798,800,819,820,823,],[72,72,72,117,72,145,72,145,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,318,72,72,145,72,72,345,72,72,72,355,72,72,72,72,72,72,72,72,72,72,72,72,72,72,145,72,413,72,72,72,72,72,72,72,72,72,72,451,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,]),'template_paramlist':([323,],[417,]),'operator_expr':([599,657,658,710,721,746,756,765,803,],[663,703,705,663,663,663,791,703,828,]),'except_clause':([267,367,],[367,367,]),'testlist_safe':([496,],[565,]),'template_args':([644,689,721,],[694,694,694,]),'template_id_list':([743,],[781,]),'template_param':([323,510,575,],[419,577,648,]),'and_expr':([0,1,7,14,30,32,34,45,51,58,60,69,79,80,88,89,93,103,115,119,124,141,147,150,158,160,168,172,180,194,210,212,224,226,229,231,232,233,241,242,252,254,256,264,268,271,273,278,280,282,289,290,299,301,304,307,314,316,320,324,325,327,329,330,331,335,342,348,354,356,359,360,363,366,369,373,378,380,381,387,388,390,412,444,448,457,458,463,465,468,470,475,478,489,491,496,506,507,511,519,537,538,540,541,542,544,547,548,551,556,564,579,585,596,614,618,631,632,635,645,651,656,659,660,661,664,669,671,672,673,675,685,686,693,725,730,738,754,774,798,800,819,820,823,],[12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,240,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,349,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,]),'yield_stmt':([0,79,103,158,229,232,307,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,]),'arith_expr_list':([24,],[134,]),'template_suite_item':([570,640,692,737,],[643,691,643,691,]),'pragmas':([0,66,79,570,640,666,692,717,737,763,787,792,811,],[76,185,76,636,636,636,636,636,636,636,636,636,636,]),'shift_list':([53,],[167,]),'enaml':([0,],[77,]),'subscriptlist_list':([292,],[389,]),'argument':([168,282,331,470,548,],[284,379,284,546,617,]),'enaml_module_body':([0,],[79,]),'pragma_arg':([333,517,],[432,432,]),'fplist':([174,],[296,]),'template_suite':([414,],[501,]),'not_test':([0,1,7,30,34,51,58,60,69,79,80,88,89,93,103,119,124,141,150,158,160,168,172,180,210,212,226,229,232,233,242,256,264,268,271,273,278,280,282,289,290,299,301,304,307,316,324,325,327,329,330,331,335,342,348,354,359,360,363,366,369,373,378,380,381,387,388,390,412,444,448,457,458,463,465,468,470,475,478,489,491,496,506,507,511,519,537,538,540,541,542,544,547,548,551,556,564,579,585,596,614,618,631,632,635,645,651,656,659,660,661,664,669,671,672,673,675,685,686,693,725,730,738,754,774,798,800,819,820,823,],[81,81,81,81,81,81,81,81,81,81,81,81,215,81,81,81,81,81,81,81,81,81,81,81,326,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,421,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,]),'print_list':([34,360,],[148,453,]),'template_ids':([743,],[785,]),'break_stmt':([0,79,103,158,229,232,307,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,82,]),'del_stmt':([0,79,103,158,229,232,307,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,]),'template_inst_impl':([570,636,640,666,692,717,737,763,787,792,811,],[638,688,638,638,638,638,638,638,638,638,638,]),'fpdef':([57,174,259,300,392,396,481,487,558,569,],[177,295,177,399,480,484,553,399,484,177,]),'testlist_comp_list':([99,],[225,]),'small_stmt_list_list':([3,],[101,]),'template_paramlist_list':([419,],[509,]),'list_if':([565,683,],[629,629,]),'pragma_args':([333,517,],[431,582,]),'test':([0,1,7,30,34,51,58,60,69,79,80,88,93,103,119,124,150,158,168,172,180,212,226,229,232,233,242,256,264,271,273,278,280,282,289,290,299,301,304,307,316,324,327,329,330,331,335,342,348,354,359,360,363,366,369,373,378,380,381,387,388,390,412,448,457,458,463,465,468,470,475,478,489,491,506,507,511,519,537,538,540,541,542,544,547,548,551,556,564,579,585,614,618,645,651,656,659,660,661,664,669,671,672,673,675,693,725,730,738,754,774,798,800,819,820,823,],[83,99,105,83,149,162,181,183,192,83,208,83,218,83,83,83,258,83,283,291,303,328,343,83,83,105,350,358,83,372,374,375,376,283,385,386,397,401,402,83,411,420,422,83,83,283,83,445,83,450,452,454,83,83,464,466,471,473,474,476,477,291,497,532,83,83,83,83,545,283,550,291,562,563,573,574,83,584,83,83,610,83,612,613,616,283,619,621,83,83,83,674,677,696,83,701,706,707,708,83,83,83,83,728,729,740,83,768,772,789,740,822,740,83,83,837,]),'global_stmt':([0,79,103,158,229,232,307,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,]),'import_as_names_list':([435,],[524,]),'with_item':([7,233,],[106,347,]),'import_name':([0,79,103,158,229,232,307,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,]),'template_arglist_list':([741,],[775,]),'yield_expr':([0,1,79,103,119,124,158,229,232,307,330,335,348,363,366,457,458,463,465,511,537,538,541,564,579,585,651,664,669,671,672,725,819,820,],[87,100,87,87,243,245,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,87,]),'except_clauses':([267,367,],[368,460,]),'comparison_list':([72,],[198,]),'and_test':([0,1,7,30,34,51,58,60,69,79,80,88,93,103,119,124,141,150,158,160,168,172,180,212,226,229,232,233,242,256,264,268,271,273,278,280,282,289,290,299,301,304,307,316,324,327,329,330,331,335,342,348,354,359,360,363,366,369,373,378,380,381,387,388,390,412,444,448,457,458,463,465,468,470,475,478,489,491,496,506,507,511,519,537,538,540,541,542,544,547,548,551,556,564,579,585,596,614,618,631,632,635,645,651,656,659,660,661,664,669,671,672,673,675,685,686,693,725,730,738,754,774,798,800,819,820,823,],[48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,269,48,48,48,48,48,48,48,48,48,48,48,371,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,]),'decorated':([0,79,366,458,],[92,92,92,92,]),'stmt_list':([366,458,],[459,535,]),'elif_stmt':([434,518,],[518,518,]),'dosm_colon_list':([374,],[467,]),'power_list':([55,],[169,]),'while_stmt':([0,79,366,458,],[96,96,96,96,]),'varargslist':([57,259,569,],[178,362,634,]),'dotted_name_list':([187,],[309,]),'listmaker_list':([192,],[317,]),}

_lr_goto = { }
for _k, _v in _lr_goto_items.items():
   for _x,_y in zip(_v[0],_v[1]):
       if not _x in _lr_goto: _lr_goto[_x] = { }
       _lr_goto[_x][_k] = _y
del _lr_goto_items
_lr_productions = [
  ("S' -> enaml","S'",1,None,None,None),
  ('enaml -> enaml_module NEWLINE ENDMARKER','enaml',3,'p_enaml1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',252),
  ('enaml -> enaml_module ENDMARKER','enaml',2,'p_enaml1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',253),
  ('enaml -> NEWLINE ENDMARKER','enaml',2,'p_enaml2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',258),
  ('enaml -> ENDMARKER','enaml',1,'p_enaml2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',259),
  ('enaml_module -> enaml_module_body','enaml_module',1,'p_enaml_module','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',264),
  ('enaml_module_body -> enaml_module_body enaml_module_item','enaml_module_body',2,'p_enaml_module_body1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',285),
  ('enaml_module_body -> enaml_module_item','enaml_module_body',1,'p_enaml_module_body2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',293),
  ('enaml_module_item -> stmt','enaml_module_item',1,'p_enaml_module_item','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',301),
  ('enaml_module_item -> enamldef','enaml_module_item',1,'p_enaml_module_item','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',302),
  ('enaml_module_item -> template','enaml_module_item',1,'p_enaml_module_item','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',303),
  ('enamldef -> enamldef_impl','enamldef',1,'p_enamldef1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',345),
  ('enamldef -> pragmas enamldef_impl','enamldef',2,'p_enamldef2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',350),
  ('enamldef_impl -> ENAMLDEF NAME LPAR NAME RPAR COLON enamldef_suite','enamldef_impl',7,'p_enamldef_impl1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',357),
  ('enamldef_impl -> ENAMLDEF NAME LPAR NAME RPAR COLON enamldef_simple_item','enamldef_impl',7,'p_enamldef_impl2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',367),
  ('enamldef_impl -> ENAMLDEF NAME LPAR NAME RPAR COLON NAME COLON enamldef_suite','enamldef_impl',9,'p_enamldef_impl3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',377),
  ('enamldef_impl -> ENAMLDEF NAME LPAR NAME RPAR COLON NAME COLON enamldef_simple_item','enamldef_impl',9,'p_enamldef_impl4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',388),
  ('enamldef_suite -> NEWLINE INDENT enamldef_suite_items DEDENT','enamldef_suite',4,'p_enamldef_suite1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',398),
  ('enamldef_suite -> NEWLINE INDENT STRING NEWLINE enamldef_suite_items DEDENT','enamldef_suite',6,'p_enamldef_suite2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',405),
  ('enamldef_suite_items -> enamldef_suite_item','enamldef_suite_items',1,'p_enamldef_suite_items1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',412),
  ('enamldef_suite_items -> enamldef_suite_items enamldef_suite_item','enamldef_suite_items',2,'p_enamldef_suite_items2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',417),
  ('enamldef_suite_item -> enamldef_simple_item','enamldef_suite_item',1,'p_enamldef_suite_item','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',422),
  ('enamldef_suite_item -> decl_funcdef','enamldef_suite_item',1,'p_enamldef_suite_item','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',423),
  ('enamldef_suite_item -> child_def','enamldef_suite_item',1,'p_enamldef_suite_item','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',424),
  ('enamldef_suite_item -> template_inst','enamldef_suite_item',1,'p_enamldef_suite_item','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',425),
  ('enamldef_simple_item -> binding','enamldef_simple_item',1,'p_enamldef_simple_item1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',430),
  ('enamldef_simple_item -> ex_binding','enamldef_simple_item',1,'p_enamldef_simple_item1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',431),
  ('enamldef_simple_item -> alias_expr','enamldef_simple_item',1,'p_enamldef_simple_item1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',432),
  ('enamldef_simple_item -> storage_expr','enamldef_simple_item',1,'p_enamldef_simple_item1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',433),
  ('enamldef_simple_item -> PASS NEWLINE','enamldef_simple_item',2,'p_enamldef_simple_item2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',438),
  ('pragmas -> pragma pragmas','pragmas',2,'p_pragmas1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',446),
  ('pragmas -> pragma','pragmas',1,'p_pragmas2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',451),
  ('pragma -> PRAGMA NAME NEWLINE','pragma',3,'p_pragma1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',456),
  ('pragma -> PRAGMA NAME LPAR RPAR NEWLINE','pragma',5,'p_pragma1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',457),
  ('pragma -> PRAGMA NAME LPAR pragma_args RPAR NEWLINE','pragma',6,'p_pragma2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',465),
  ('pragma_args -> pragma_arg COMMA pragma_args','pragma_args',3,'p_pragma_args1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',474),
  ('pragma_args -> pragma_arg','pragma_args',1,'p_pragma_args2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',479),
  ('pragma_arg -> NAME','pragma_arg',1,'p_pragma_arg','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',484),
  ('pragma_arg -> NUMBER','pragma_arg',1,'p_pragma_arg2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',489),
  ('pragma_arg -> STRING','pragma_arg',1,'p_pragma_arg3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',494),
  ('alias_expr -> ALIAS NAME NEWLINE','alias_expr',3,'p_alias_expr1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',502),
  ('alias_expr -> ALIAS NAME COLON NAME NEWLINE','alias_expr',5,'p_alias_expr2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',511),
  ('alias_expr -> ALIAS NAME COLON NAME ex_dotted_names NEWLINE','alias_expr',6,'p_alias_expr3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',520),
  ('const_expr -> CONST NAME EQUAL test NEWLINE','const_expr',5,'p_const_expr1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',533),
  ('const_expr -> CONST NAME COLON NAME EQUAL test NEWLINE','const_expr',7,'p_const_expr2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',548),
  ('storage_expr -> NAME NAME NEWLINE','storage_expr',3,'p_storage_expr1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',572),
  ('storage_expr -> NAME NAME COLON NAME NEWLINE','storage_expr',5,'p_storage_expr2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',584),
  ('storage_expr -> NAME NAME operator_expr','storage_expr',3,'p_storage_expr3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',597),
  ('storage_expr -> NAME NAME COLON NAME operator_expr','storage_expr',5,'p_storage_expr4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',610),
  ('child_def -> NAME COLON child_def_suite','child_def',3,'p_child_def1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',627),
  ('child_def -> NAME COLON child_def_simple_item','child_def',3,'p_child_def2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',635),
  ('child_def -> NAME COLON NAME COLON child_def_suite','child_def',5,'p_child_def3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',641),
  ('child_def -> NAME COLON NAME COLON child_def_simple_item','child_def',5,'p_child_def4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',649),
  ('child_def_suite -> NEWLINE INDENT child_def_suite_items DEDENT','child_def_suite',4,'p_child_def_suite','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',658),
  ('child_def_suite_items -> child_def_suite_item','child_def_suite_items',1,'p_child_def_suite_items1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',665),
  ('child_def_suite_items -> child_def_suite_items child_def_suite_item','child_def_suite_items',2,'p_child_def_suite_items2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',670),
  ('child_def_suite_item -> child_def_simple_item','child_def_suite_item',1,'p_child_def_suite_item','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',675),
  ('child_def_suite_item -> decl_funcdef','child_def_suite_item',1,'p_child_def_suite_item','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',676),
  ('child_def_suite_item -> child_def','child_def_suite_item',1,'p_child_def_suite_item','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',677),
  ('child_def_suite_item -> template_inst','child_def_suite_item',1,'p_child_def_suite_item','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',678),
  ('child_def_simple_item -> binding','child_def_simple_item',1,'p_child_def_simple_item1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',683),
  ('child_def_simple_item -> ex_binding','child_def_simple_item',1,'p_child_def_simple_item1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',684),
  ('child_def_simple_item -> alias_expr','child_def_simple_item',1,'p_child_def_simple_item1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',685),
  ('child_def_simple_item -> storage_expr','child_def_simple_item',1,'p_child_def_simple_item1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',686),
  ('child_def_simple_item -> PASS NEWLINE','child_def_simple_item',2,'p_child_def_simple_item2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',691),
  ('binding -> NAME operator_expr','binding',2,'p_binding','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',699),
  ('ex_binding -> NAME ex_dotted_names operator_expr','ex_binding',3,'p_ex_binding','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',707),
  ('ex_dotted_names -> DOT NAME','ex_dotted_names',2,'p_ex_dotted_names1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',716),
  ('ex_dotted_names -> DOT NAME ex_dotted_names','ex_dotted_names',3,'p_ex_dotted_names2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',721),
  ('operator_expr -> EQUAL test NEWLINE','operator_expr',3,'p_operator_expr1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',729),
  ('operator_expr -> LEFTSHIFT test NEWLINE','operator_expr',3,'p_operator_expr1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',730),
  ('operator_expr -> COLONEQUAL test NEWLINE','operator_expr',3,'p_operator_expr2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',745),
  ('operator_expr -> RIGHTSHIFT test NEWLINE','operator_expr',3,'p_operator_expr2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',746),
  ('operator_expr -> DOUBLECOLON suite','operator_expr',2,'p_operator_expr3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',769),
  ('decl_funcdef -> NAME NAME parameters COLON suite','decl_funcdef',5,'p_decl_funcdef1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',804),
  ('decl_funcdef -> NAME RIGHTARROW parameters COLON suite','decl_funcdef',5,'p_decl_funcdef2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',824),
  ('template -> template_impl','template',1,'p_template1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',912),
  ('template -> pragmas template_impl','template',2,'p_template2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',917),
  ('template_impl -> TEMPLATE NAME template_params COLON template_suite','template_impl',5,'p_template_impl1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',924),
  ('template_impl -> TEMPLATE NAME template_params COLON template_simple_item','template_impl',5,'p_template_impl2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',935),
  ('template_impl -> TEMPLATE NAME template_params COLON template_doc_suite','template_impl',5,'p_template_impl3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',946),
  ('template_suite -> NEWLINE INDENT template_suite_items DEDENT','template_suite',4,'p_template_suite','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',959),
  ('template_doc_suite -> NEWLINE INDENT STRING NEWLINE template_suite_items DEDENT','template_doc_suite',6,'p_template_doc_suite','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',965),
  ('template_suite_items -> template_suite_item','template_suite_items',1,'p_template_suite_items1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',971),
  ('template_suite_items -> template_suite_items template_suite_item','template_suite_items',2,'p_template_suite_items2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',976),
  ('template_suite_item -> template_simple_item','template_suite_item',1,'p_template_suite_item','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',981),
  ('template_suite_item -> child_def','template_suite_item',1,'p_template_suite_item','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',982),
  ('template_suite_item -> template_inst','template_suite_item',1,'p_template_suite_item','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',983),
  ('template_simple_item -> const_expr','template_simple_item',1,'p_template_simple_item1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',988),
  ('template_simple_item -> PASS NEWLINE','template_simple_item',2,'p_template_simple_item2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',993),
  ('template_params -> LPAR RPAR','template_params',2,'p_template_params1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',998),
  ('template_params -> LPAR template_paramlist RPAR','template_params',3,'p_template_params2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1024),
  ('template_paramlist -> template_param','template_paramlist',1,'p_template_paramlist1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1035),
  ('template_paramlist -> STAR NAME','template_paramlist',2,'p_template_paramlist2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1040),
  ('template_paramlist -> template_param template_paramlist_list','template_paramlist',2,'p_template_paramlist3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1045),
  ('template_paramlist -> template_param COMMA STAR NAME','template_paramlist',4,'p_template_paramlist4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1050),
  ('template_paramlist -> template_param template_paramlist_list COMMA STAR NAME','template_paramlist',5,'p_template_paramlist5','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1055),
  ('template_paramlist_list -> COMMA template_param','template_paramlist_list',2,'p_template_paramlist_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1060),
  ('template_paramlist_list -> template_paramlist_list COMMA template_param','template_paramlist_list',3,'p_template_paramlist_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1065),
  ('template_param -> NAME','template_param',1,'p_template_param1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1070),
  ('template_param -> NAME COLON test','template_param',3,'p_template_param2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1078),
  ('template_param -> NAME EQUAL test','template_param',3,'p_template_param3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1093),
  ('template_inst -> template_inst_impl','template_inst',1,'p_template_inst1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1127),
  ('template_inst -> pragmas template_inst_impl','template_inst',2,'p_template_inst2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1132),
  ('template_inst_impl -> NAME template_args COLON template_inst_suite_item','template_inst_impl',4,'p_template_inst_impl1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1139),
  ('template_inst_impl -> NAME template_args COLON template_ids COLON template_inst_suite_item','template_inst_impl',6,'p_template_inst_impl2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1150),
  ('template_inst_impl -> NAME template_args COLON template_inst_suite','template_inst_impl',4,'p_template_inst_impl3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1162),
  ('template_inst_impl -> NAME template_args COLON template_ids COLON template_inst_suite','template_inst_impl',6,'p_template_inst_impl4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1173),
  ('template_args -> LPAR RPAR','template_args',2,'p_template_args1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1185),
  ('template_args -> LPAR template_arglist RPAR','template_args',3,'p_template_args2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1203),
  ('template_arglist -> template_argument','template_arglist',1,'p_template_arglist1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1214),
  ('template_arglist -> STAR test','template_arglist',2,'p_template_arglist2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1219),
  ('template_arglist -> template_argument template_arglist_list','template_arglist',2,'p_template_arglist3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1230),
  ('template_arglist -> template_argument COMMA STAR test','template_arglist',4,'p_template_arglist4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1235),
  ('template_arglist -> template_argument template_arglist_list COMMA STAR test','template_arglist',5,'p_template_arglist5','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1246),
  ('template_arglist_list -> COMMA template_argument','template_arglist_list',2,'p_template_arglist_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1257),
  ('template_arglist_list -> template_arglist_list COMMA template_argument','template_arglist_list',3,'p_template_arglist_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1265),
  ('template_argument -> test','template_argument',1,'p_template_argument1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1273),
  ('template_argument -> test comp_for','template_argument',2,'p_template_argument2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1280),
  ('template_ids -> NAME','template_ids',1,'p_template_ids1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1287),
  ('template_ids -> template_id_list NAME','template_ids',2,'p_template_ids2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1295),
  ('template_ids -> STAR NAME','template_ids',2,'p_template_ids3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1303),
  ('template_ids -> template_id_list STAR NAME','template_ids',3,'p_template_ids4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1311),
  ('template_id_list -> NAME COMMA','template_id_list',2,'p_template_id_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1320),
  ('template_id_list -> template_id_list NAME COMMA','template_id_list',3,'p_template_id_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1325),
  ('template_inst_suite -> NEWLINE INDENT template_inst_suite_items DEDENT','template_inst_suite',4,'p_template_inst_suite','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1330),
  ('template_inst_suite_items -> template_inst_suite_items template_inst_suite_item','template_inst_suite_items',2,'p_template_inst_suite_items1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1335),
  ('template_inst_suite_items -> template_inst_suite_item','template_inst_suite_items',1,'p_template_inst_suite_items2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1340),
  ('template_inst_suite_item -> template_inst_binding','template_inst_suite_item',1,'p_template_inst_suite_item1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1345),
  ('template_inst_suite_item -> PASS NEWLINE','template_inst_suite_item',2,'p_template_inst_suite_item2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1350),
  ('template_inst_binding -> NAME ex_dotted_names operator_expr','template_inst_binding',3,'p_template_inst_binding','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1355),
  ('suite -> simple_stmt','suite',1,'p_suite1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1368),
  ('suite -> NEWLINE INDENT stmt_list DEDENT','suite',4,'p_suite2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1380),
  ('stmt_list -> stmt stmt_list','stmt_list',2,'p_stmt_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1385),
  ('stmt_list -> stmt','stmt_list',1,'p_stmt_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1397),
  ('stmt -> simple_stmt','stmt',1,'p_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1409),
  ('stmt -> compound_stmt','stmt',1,'p_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1410),
  ('simple_stmt -> small_stmt NEWLINE','simple_stmt',2,'p_simple_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1415),
  ('simple_stmt -> small_stmt_list NEWLINE','simple_stmt',2,'p_simple_stmt2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1423),
  ('small_stmt_list -> small_stmt SEMI','small_stmt_list',2,'p_small_stmt_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1433),
  ('small_stmt_list -> small_stmt small_stmt_list_list','small_stmt_list',2,'p_small_stmt_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1438),
  ('small_stmt_list -> small_stmt small_stmt_list_list SEMI','small_stmt_list',3,'p_small_stmt_list3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1443),
  ('small_stmt_list_list -> SEMI small_stmt','small_stmt_list_list',2,'p_small_stmt_list_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1448),
  ('small_stmt_list_list -> small_stmt_list_list SEMI small_stmt','small_stmt_list_list',3,'p_small_stmt_list_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1453),
  ('small_stmt -> expr_stmt','small_stmt',1,'p_small_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1458),
  ('small_stmt -> print_stmt','small_stmt',1,'p_small_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1459),
  ('small_stmt -> del_stmt','small_stmt',1,'p_small_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1460),
  ('small_stmt -> pass_stmt','small_stmt',1,'p_small_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1461),
  ('small_stmt -> flow_stmt','small_stmt',1,'p_small_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1462),
  ('small_stmt -> import_stmt','small_stmt',1,'p_small_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1463),
  ('small_stmt -> global_stmt','small_stmt',1,'p_small_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1464),
  ('small_stmt -> exec_stmt','small_stmt',1,'p_small_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1465),
  ('small_stmt -> assert_stmt','small_stmt',1,'p_small_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1466),
  ('print_stmt -> PRINT','print_stmt',1,'p_print_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1471),
  ('print_stmt -> PRINT test','print_stmt',2,'p_print_stmt2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1480),
  ('print_stmt -> PRINT print_list','print_stmt',2,'p_print_stmt3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1489),
  ('print_stmt -> PRINT RIGHTSHIFT test','print_stmt',3,'p_print_stmt4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1504),
  ('print_stmt -> PRINT RIGHTSHIFT test COMMA test','print_stmt',5,'p_print_stmt5','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1513),
  ('print_stmt -> PRINT RIGHTSHIFT test COMMA print_list','print_stmt',5,'p_print_stmt6','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1522),
  ('print_list -> test COMMA','print_list',2,'p_print_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1537),
  ('print_list -> test print_list_list','print_list',2,'p_print_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1542),
  ('print_list -> test print_list_list COMMA','print_list',3,'p_print_list3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1547),
  ('print_list_list -> COMMA test','print_list_list',2,'p_print_list_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1552),
  ('print_list_list -> print_list_list COMMA test','print_list_list',3,'p_print_list_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1557),
  ('del_stmt -> DEL exprlist','del_stmt',2,'p_del_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1562),
  ('pass_stmt -> PASS','pass_stmt',1,'p_pass_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1571),
  ('flow_stmt -> break_stmt','flow_stmt',1,'p_flow_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1578),
  ('flow_stmt -> continue_stmt','flow_stmt',1,'p_flow_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1579),
  ('flow_stmt -> return_stmt','flow_stmt',1,'p_flow_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1580),
  ('flow_stmt -> raise_stmt','flow_stmt',1,'p_flow_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1581),
  ('flow_stmt -> yield_stmt','flow_stmt',1,'p_flow_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1582),
  ('break_stmt -> BREAK','break_stmt',1,'p_break_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1587),
  ('continue_stmt -> CONTINUE','continue_stmt',1,'p_continue_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1594),
  ('return_stmt -> RETURN','return_stmt',1,'p_return_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1601),
  ('return_stmt -> RETURN testlist','return_stmt',2,'p_return_stmt2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1608),
  ('raise_stmt -> RAISE','raise_stmt',1,'p_raise_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1616),
  ('raise_stmt -> RAISE test','raise_stmt',2,'p_raise_stmt2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1625),
  ('raise_stmt -> RAISE test COMMA test','raise_stmt',4,'p_raise_stmt3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1634),
  ('raise_stmt -> RAISE test COMMA test COMMA test','raise_stmt',6,'p_raise_stmt4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1643),
  ('yield_stmt -> yield_expr','yield_stmt',1,'p_yield_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1652),
  ('yield_expr -> YIELD','yield_expr',1,'p_yield_expr1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1657),
  ('yield_expr -> YIELD testlist','yield_expr',2,'p_yield_expr2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1662),
  ('global_stmt -> GLOBAL NAME','global_stmt',2,'p_global_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1668),
  ('global_stmt -> GLOBAL NAME globals_list','global_stmt',3,'p_global_stmt2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1676),
  ('globals_list -> COMMA NAME globals_list','globals_list',3,'p_globals_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1684),
  ('globals_list -> COMMA NAME','globals_list',2,'p_globals_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1689),
  ('exec_stmt -> EXEC expr','exec_stmt',2,'p_exec_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1694),
  ('exec_stmt -> EXEC expr IN test','exec_stmt',4,'p_exec_stmt2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1703),
  ('exec_stmt -> EXEC expr IN test COMMA test','exec_stmt',6,'p_exec_stmt3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1712),
  ('assert_stmt -> ASSERT test','assert_stmt',2,'p_assert_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1721),
  ('assert_stmt -> ASSERT test COMMA test','assert_stmt',4,'p_assert_stmt2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1729),
  ('expr_stmt -> testlist','expr_stmt',1,'p_expr_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1737),
  ('expr_stmt -> testlist augassign testlist','expr_stmt',3,'p_expr_stmt2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1744),
  ('expr_stmt -> testlist augassign yield_expr','expr_stmt',3,'p_expr_stmt2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1745),
  ('expr_stmt -> testlist equal_list','expr_stmt',2,'p_expr_stmt3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1761),
  ('augassign -> AMPEREQUAL','augassign',1,'p_augassign','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1777),
  ('augassign -> CIRCUMFLEXEQUAL','augassign',1,'p_augassign','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1778),
  ('augassign -> DOUBLESLASHEQUAL','augassign',1,'p_augassign','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1779),
  ('augassign -> DOUBLESTAREQUAL','augassign',1,'p_augassign','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1780),
  ('augassign -> LEFTSHIFTEQUAL','augassign',1,'p_augassign','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1781),
  ('augassign -> MINUSEQUAL','augassign',1,'p_augassign','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1782),
  ('augassign -> PERCENTEQUAL','augassign',1,'p_augassign','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1783),
  ('augassign -> PLUSEQUAL','augassign',1,'p_augassign','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1784),
  ('augassign -> RIGHTSHIFTEQUAL','augassign',1,'p_augassign','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1785),
  ('augassign -> SLASHEQUAL','augassign',1,'p_augassign','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1786),
  ('augassign -> STAREQUAL','augassign',1,'p_augassign','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1787),
  ('augassign -> VBAREQUAL','augassign',1,'p_augassign','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1788),
  ('equal_list -> EQUAL testlist','equal_list',2,'p_equal_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1795),
  ('equal_list -> EQUAL yield_expr','equal_list',2,'p_equal_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1796),
  ('equal_list -> EQUAL testlist equal_list','equal_list',3,'p_equal_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1801),
  ('equal_list -> EQUAL yield_expr equal_list','equal_list',3,'p_equal_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1802),
  ('testlist -> test','testlist',1,'p_testlist1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1807),
  ('testlist -> test COMMA','testlist',2,'p_testlist2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1812),
  ('testlist -> test testlist_list','testlist',2,'p_testlist3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1817),
  ('testlist -> test testlist_list COMMA','testlist',3,'p_testlist4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1822),
  ('testlist_list -> COMMA test','testlist_list',2,'p_testlist_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1827),
  ('testlist_list -> testlist_list COMMA test','testlist_list',3,'p_testlist_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1832),
  ('compound_stmt -> if_stmt','compound_stmt',1,'p_compound_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1837),
  ('compound_stmt -> while_stmt','compound_stmt',1,'p_compound_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1838),
  ('compound_stmt -> for_stmt','compound_stmt',1,'p_compound_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1839),
  ('compound_stmt -> try_stmt','compound_stmt',1,'p_compound_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1840),
  ('compound_stmt -> with_stmt','compound_stmt',1,'p_compound_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1841),
  ('compound_stmt -> funcdef','compound_stmt',1,'p_compound_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1842),
  ('compound_stmt -> classdef','compound_stmt',1,'p_compound_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1843),
  ('compound_stmt -> decorated','compound_stmt',1,'p_compound_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1844),
  ('if_stmt -> IF test COLON suite','if_stmt',4,'p_if_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1849),
  ('if_stmt -> IF test COLON suite elif_stmts','if_stmt',5,'p_if_stmt2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1860),
  ('if_stmt -> IF test COLON suite else_stmt','if_stmt',5,'p_if_stmt3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1871),
  ('if_stmt -> IF test COLON suite elif_stmts else_stmt','if_stmt',6,'p_if_stmt4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1882),
  ('elif_stmts -> elif_stmt elif_stmts','elif_stmts',2,'p_elif_stmts1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1898),
  ('elif_stmts -> elif_stmt','elif_stmts',1,'p_elif_stmts2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1905),
  ('elif_stmt -> ELIF test COLON suite','elif_stmt',4,'p_elif_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1910),
  ('else_stmt -> ELSE COLON suite','else_stmt',3,'p_else_stmt','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1921),
  ('while_stmt -> WHILE test COLON suite','while_stmt',4,'p_while_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1926),
  ('while_stmt -> WHILE test COLON suite ELSE COLON suite','while_stmt',7,'p_while_stmt2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1937),
  ('for_stmt -> FOR exprlist IN testlist COLON suite','for_stmt',6,'p_for_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1948),
  ('for_stmt -> FOR exprlist IN testlist COLON suite ELSE COLON suite','for_stmt',9,'p_for_stmt2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1962),
  ('try_stmt -> TRY COLON suite FINALLY COLON suite','try_stmt',6,'p_try_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1976),
  ('try_stmt -> TRY COLON suite except_clauses','try_stmt',4,'p_try_stmt2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1986),
  ('try_stmt -> TRY COLON suite except_clauses ELSE COLON suite','try_stmt',7,'p_try_stmt3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',1997),
  ('try_stmt -> TRY COLON suite except_clauses FINALLY COLON suite','try_stmt',7,'p_try_stmt4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2008),
  ('try_stmt -> TRY COLON suite except_clauses ELSE COLON suite FINALLY COLON suite','try_stmt',10,'p_try_stmt5','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2025),
  ('except_clauses -> except_clause except_clauses','except_clauses',2,'p_except_clauses1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2042),
  ('except_clauses -> except_clause','except_clauses',1,'p_except_clauses2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2047),
  ('except_clause -> EXCEPT COLON suite','except_clause',3,'p_except_clause1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2052),
  ('except_clause -> EXCEPT test COLON suite','except_clause',4,'p_except_clause2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2063),
  ('except_clause -> EXCEPT test AS test COLON suite','except_clause',6,'p_except_clause3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2074),
  ('except_clause -> EXCEPT test COMMA test COLON suite','except_clause',6,'p_except_clause3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2075),
  ('with_stmt -> WITH with_item COLON suite','with_stmt',4,'p_with_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2088),
  ('with_stmt -> WITH with_item with_item_list COLON suite','with_stmt',5,'p_with_stmt2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2100),
  ('with_item -> test','with_item',1,'p_with_item1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2120),
  ('with_item -> test AS expr','with_item',3,'p_with_item2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2125),
  ('with_item_list -> COMMA with_item with_item_list','with_item_list',3,'p_with_item_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2132),
  ('with_item_list -> COMMA with_item','with_item_list',2,'p_with_item_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2137),
  ('funcdef -> DEF NAME parameters COLON suite','funcdef',5,'p_funcdef','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2142),
  ('parameters -> LPAR RPAR','parameters',2,'p_parameters1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2154),
  ('parameters -> LPAR varargslist RPAR','parameters',3,'p_parameters2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2159),
  ('classdef -> CLASS NAME COLON suite','classdef',4,'p_classdef1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2164),
  ('classdef -> CLASS NAME LPAR RPAR COLON suite','classdef',6,'p_classdef2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2176),
  ('classdef -> CLASS NAME LPAR testlist RPAR COLON suite','classdef',7,'p_classdef3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2188),
  ('decorated -> decorators funcdef','decorated',2,'p_decorated','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2203),
  ('decorated -> decorators classdef','decorated',2,'p_decorated','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2204),
  ('decorators -> decorator decorators','decorators',2,'p_decorators1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2212),
  ('decorators -> decorator','decorators',1,'p_decorators2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2217),
  ('decorator -> AT dotted_name NEWLINE','decorator',3,'p_decorator1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2222),
  ('decorator -> AT dotted_name LPAR RPAR NEWLINE','decorator',5,'p_decorator2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2230),
  ('decorator -> AT dotted_name LPAR arglist RPAR NEWLINE','decorator',6,'p_decorator3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2243),
  ('import_stmt -> import_name','import_stmt',1,'p_import_stmt1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2257),
  ('import_stmt -> import_from','import_stmt',1,'p_import_stmt2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2262),
  ('import_name -> IMPORT dotted_as_names','import_name',2,'p_import_name','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2267),
  ('import_from -> FROM dotted_name IMPORT STAR','import_from',4,'p_import_from1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2274),
  ('import_from -> FROM dotted_name IMPORT import_as_names','import_from',4,'p_import_from2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2282),
  ('import_from -> FROM dotted_name IMPORT LPAR import_as_names RPAR','import_from',6,'p_import_from3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2289),
  ('import_from -> FROM import_from_dots dotted_name IMPORT STAR','import_from',5,'p_import_from4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2296),
  ('import_from -> FROM import_from_dots dotted_name IMPORT import_as_names','import_from',5,'p_import_from5','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2304),
  ('import_from -> FROM import_from_dots dotted_name IMPORT LPAR import_as_names RPAR','import_from',7,'p_import_from6','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2311),
  ('import_from -> FROM import_from_dots IMPORT STAR','import_from',4,'p_import_from7','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2318),
  ('import_from -> FROM import_from_dots IMPORT import_as_names','import_from',4,'p_import_from8','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2326),
  ('import_from -> FROM import_from_dots IMPORT LPAR import_as_names RPAR','import_from',6,'p_import_from9','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2333),
  ('import_from_dots -> DOT','import_from_dots',1,'p_import_from_dots1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2340),
  ('import_from_dots -> import_from_dots DOT','import_from_dots',2,'p_import_from_dots2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2345),
  ('import_from_dots -> ELLIPSIS','import_from_dots',1,'p_import_from_dots3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2350),
  ('import_from_dots -> import_from_dots ELLIPSIS','import_from_dots',2,'p_import_from_dots4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2355),
  ('import_as_name -> NAME','import_as_name',1,'p_import_as_name1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2360),
  ('import_as_name -> NAME AS NAME','import_as_name',3,'p_import_as_name2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2365),
  ('dotted_as_name -> dotted_name','dotted_as_name',1,'p_dotted_as_name1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2370),
  ('dotted_as_name -> dotted_name AS NAME','dotted_as_name',3,'p_dotted_as_name2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2376),
  ('import_as_names -> import_as_name','import_as_names',1,'p_import_as_names1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2382),
  ('import_as_names -> import_as_name COMMA','import_as_names',2,'p_import_as_names2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2387),
  ('import_as_names -> import_as_name import_as_names_list','import_as_names',2,'p_import_as_names3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2392),
  ('import_as_names -> import_as_name import_as_names_list COMMA','import_as_names',3,'p_import_as_names4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2397),
  ('import_as_names_list -> COMMA import_as_name','import_as_names_list',2,'p_import_as_names_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2402),
  ('import_as_names_list -> import_as_names_list COMMA import_as_name','import_as_names_list',3,'p_import_as_names_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2407),
  ('dotted_as_names -> dotted_as_name','dotted_as_names',1,'p_dotted_as_names1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2412),
  ('dotted_as_names -> dotted_as_name dotted_as_names_list','dotted_as_names',2,'p_dotted_as_names2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2417),
  ('dotted_as_names_list -> COMMA dotted_as_name','dotted_as_names_list',2,'p_dotted_as_names_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2422),
  ('dotted_as_names_list -> dotted_as_names_list COMMA dotted_as_name','dotted_as_names_list',3,'p_dotted_as_names_star_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2427),
  ('dotted_name -> NAME','dotted_name',1,'p_dotted_name1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2432),
  ('dotted_name -> NAME dotted_name_list','dotted_name',2,'p_dotted_name2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2437),
  ('dotted_name_list -> DOT NAME','dotted_name_list',2,'p_dotted_name_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2442),
  ('dotted_name_list -> dotted_name_list DOT NAME','dotted_name_list',3,'p_dotted_name_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2447),
  ('test -> or_test','test',1,'p_test1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2452),
  ('test -> or_test IF or_test ELSE test','test',5,'p_test2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2457),
  ('test -> lambdef','test',1,'p_test3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2463),
  ('or_test -> and_test','or_test',1,'p_or_test1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2468),
  ('or_test -> and_test or_test_list','or_test',2,'p_or_test2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2473),
  ('or_test_list -> OR and_test','or_test_list',2,'p_or_test_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2480),
  ('or_test_list -> or_test_list OR and_test','or_test_list',3,'p_or_test_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2485),
  ('and_test -> not_test','and_test',1,'p_and_test1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2490),
  ('and_test -> not_test and_test_list','and_test',2,'p_and_test2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2495),
  ('and_test_list -> AND not_test','and_test_list',2,'p_and_test_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2502),
  ('and_test_list -> and_test_list AND not_test','and_test_list',3,'p_and_test_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2507),
  ('not_test -> comparison','not_test',1,'p_not_test','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2512),
  ('not_test -> NOT not_test','not_test',2,'p_not_test2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2517),
  ('comparison -> expr','comparison',1,'p_comparison1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2523),
  ('comparison -> expr comparison_list','comparison',2,'p_comparison2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2528),
  ('comparison_list -> comp_op expr','comparison_list',2,'p_comparison_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2536),
  ('comparison_list -> comparison_list comp_op expr','comparison_list',3,'p_comparison_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2541),
  ('comp_op -> LESS','comp_op',1,'p_comp_op1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2546),
  ('comp_op -> GREATER','comp_op',1,'p_comp_op2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2551),
  ('comp_op -> EQEQUAL','comp_op',1,'p_comp_op3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2556),
  ('comp_op -> GREATEREQUAL','comp_op',1,'p_comp_op4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2561),
  ('comp_op -> LESSEQUAL','comp_op',1,'p_comp_op5','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2566),
  ('comp_op -> NOTEQUAL','comp_op',1,'p_comp_op6','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2571),
  ('comp_op -> IN','comp_op',1,'p_comp_op7','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2576),
  ('comp_op -> NOT IN','comp_op',2,'p_comp_op8','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2581),
  ('comp_op -> IS','comp_op',1,'p_comp_op9','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2586),
  ('comp_op -> IS NOT','comp_op',2,'p_comp_op10','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2591),
  ('expr -> xor_expr','expr',1,'p_expr1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2596),
  ('expr -> xor_expr expr_list','expr',2,'p_expr2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2601),
  ('expr_list -> VBAR xor_expr','expr_list',2,'p_expr_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2609),
  ('expr_list -> expr_list VBAR xor_expr','expr_list',3,'p_expr_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2614),
  ('xor_expr -> and_expr','xor_expr',1,'p_xor_expr1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2619),
  ('xor_expr -> and_expr xor_expr_list','xor_expr',2,'p_xor_expr2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2624),
  ('xor_expr_list -> CIRCUMFLEX and_expr','xor_expr_list',2,'p_xor_expr_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2632),
  ('xor_expr_list -> xor_expr_list CIRCUMFLEX and_expr','xor_expr_list',3,'p_xor_expr_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2637),
  ('and_expr -> shift_expr','and_expr',1,'p_and_expr1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2642),
  ('and_expr -> shift_expr and_expr_list','and_expr',2,'p_and_expr2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2647),
  ('and_expr_list -> AMPER shift_expr','and_expr_list',2,'p_and_expr_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2655),
  ('and_expr_list -> and_expr_list AMPER shift_expr','and_expr_list',3,'p_and_expr_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2660),
  ('shift_expr -> arith_expr','shift_expr',1,'p_shift_expr1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2665),
  ('shift_expr -> arith_expr shift_list','shift_expr',2,'p_shift_expr2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2670),
  ('shift_list -> shift_op','shift_list',1,'p_shift_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2678),
  ('shift_list -> shift_list shift_op','shift_list',2,'p_shift_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2683),
  ('shift_op -> LEFTSHIFT arith_expr','shift_op',2,'p_shift_op1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2688),
  ('shift_op -> RIGHTSHIFT arith_expr','shift_op',2,'p_shift_op2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2693),
  ('arith_expr -> term','arith_expr',1,'p_arith_expr1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2698),
  ('arith_expr -> term arith_expr_list','arith_expr',2,'p_arith_expr2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2703),
  ('arith_expr_list -> arith_op','arith_expr_list',1,'p_arith_expr_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2711),
  ('arith_expr_list -> arith_expr_list arith_op','arith_expr_list',2,'p_arith_expr_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2716),
  ('arith_op -> PLUS term','arith_op',2,'p_arith_op1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2721),
  ('arith_op -> MINUS term','arith_op',2,'p_arith_op2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2727),
  ('term -> factor','term',1,'p_term1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2732),
  ('term -> factor term_list','term',2,'p_term2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2737),
  ('term_list -> term_op','term_list',1,'p_term_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2745),
  ('term_list -> term_list term_op','term_list',2,'p_term_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2750),
  ('term_op -> STAR factor','term_op',2,'p_term_op1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2755),
  ('term_op -> SLASH factor','term_op',2,'p_term_op2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2760),
  ('term_op -> PERCENT factor','term_op',2,'p_term_op3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2765),
  ('term_op -> DOUBLESLASH factor','term_op',2,'p_term_op4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2770),
  ('factor -> power','factor',1,'p_factor1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2775),
  ('factor -> PLUS factor','factor',2,'p_factor2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2780),
  ('factor -> MINUS factor','factor',2,'p_factor3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2788),
  ('factor -> TILDE factor','factor',2,'p_factor4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2796),
  ('power -> atom','power',1,'p_power1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2804),
  ('power -> atom DOUBLESTAR factor','power',3,'p_power2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2809),
  ('power -> atom power_list','power',2,'p_power3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2815),
  ('power -> atom power_list DOUBLESTAR factor','power',4,'p_power4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2831),
  ('power_list -> trailer','power_list',1,'p_power_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2848),
  ('power_list -> power_list trailer','power_list',2,'p_power_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2853),
  ('atom -> LPAR RPAR','atom',2,'p_atom1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2858),
  ('atom -> LPAR yield_expr RPAR','atom',3,'p_atom2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2863),
  ('atom -> LPAR testlist_comp RPAR','atom',3,'p_atom3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2868),
  ('atom -> LSQB RSQB','atom',2,'p_atom4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2882),
  ('atom -> LSQB listmaker RSQB','atom',3,'p_atom5','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2887),
  ('atom -> LBRACE RBRACE','atom',2,'p_atom6','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2899),
  ('atom -> LBRACE dictorsetmaker RBRACE','atom',3,'p_atom7','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2904),
  ('atom -> NAME','atom',1,'p_atom8','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2925),
  ('atom -> NUMBER','atom',1,'p_atom9','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2930),
  ('atom -> atom_string_list','atom',1,'p_atom10','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2936),
  ('atom_string_list -> STRING','atom_string_list',1,'p_atom_string_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2942),
  ('atom_string_list -> atom_string_list STRING','atom_string_list',2,'p_atom_string_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2947),
  ('listmaker -> test list_for','listmaker',2,'p_listmaker1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2957),
  ('listmaker -> test','listmaker',1,'p_listmaker2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2962),
  ('listmaker -> test COMMA','listmaker',2,'p_listmaker3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2967),
  ('listmaker -> test listmaker_list','listmaker',2,'p_listmaker4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2972),
  ('listmaker -> test listmaker_list COMMA','listmaker',3,'p_listmaker5','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2978),
  ('listmaker_list -> COMMA test','listmaker_list',2,'p_listmaker_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2984),
  ('listmaker_list -> listmaker_list COMMA test','listmaker_list',3,'p_listmaker_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2989),
  ('testlist_comp -> test comp_for','testlist_comp',2,'p_testlist_comp1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2994),
  ('testlist_comp -> test','testlist_comp',1,'p_testlist_comp2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',2999),
  ('testlist_comp -> test COMMA','testlist_comp',2,'p_testlist_comp3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3004),
  ('testlist_comp -> test testlist_comp_list','testlist_comp',2,'p_testlist_comp4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3009),
  ('testlist_comp -> test testlist_comp_list COMMA','testlist_comp',3,'p_testlist_comp5','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3015),
  ('testlist_comp_list -> COMMA test','testlist_comp_list',2,'p_testlist_comp_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3021),
  ('testlist_comp_list -> testlist_comp_list COMMA test','testlist_comp_list',3,'p_testlist_comp_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3026),
  ('trailer -> LPAR RPAR','trailer',2,'p_trailer1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3031),
  ('trailer -> LPAR arglist RPAR','trailer',3,'p_trailer2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3036),
  ('trailer -> LSQB subscriptlist RSQB','trailer',3,'p_trailer3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3043),
  ('trailer -> DOT NAME','trailer',2,'p_trailer4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3048),
  ('subscriptlist -> subscript','subscriptlist',1,'p_subscriptlist1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3053),
  ('subscriptlist -> subscript COMMA','subscriptlist',2,'p_subscriptlist2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3058),
  ('subscriptlist -> subscript subscriptlist_list','subscriptlist',2,'p_subscriptlist3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3064),
  ('subscriptlist -> subscript subscriptlist_list COMMA','subscriptlist',3,'p_subscriptlist4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3070),
  ('subscriptlist_list -> COMMA subscript','subscriptlist_list',2,'p_subscriptlist_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3076),
  ('subscriptlist_list -> subscriptlist_list COMMA subscript','subscriptlist_list',3,'p_subscript_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3081),
  ('subscript -> ELLIPSIS','subscript',1,'p_subscript1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3086),
  ('subscript -> test','subscript',1,'p_subcript2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3091),
  ('subscript -> COLON','subscript',1,'p_subscript3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3096),
  ('subscript -> DOUBLECOLON','subscript',1,'p_subscript4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3101),
  ('subscript -> test COLON','subscript',2,'p_subscript5','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3107),
  ('subscript -> test DOUBLECOLON','subscript',2,'p_subscrip6','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3112),
  ('subscript -> COLON test','subscript',2,'p_subscript7','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3118),
  ('subscript -> COLON test COLON','subscript',3,'p_subscript8','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3123),
  ('subscript -> DOUBLECOLON test','subscript',2,'p_subscript9','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3129),
  ('subscript -> test COLON test','subscript',3,'p_subscript10','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3134),
  ('subscript -> test COLON test COLON','subscript',4,'p_subscript11','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3139),
  ('subscript -> COLON test COLON test','subscript',4,'p_subscript12','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3145),
  ('subscript -> test COLON test COLON test','subscript',5,'p_subscript13','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3150),
  ('subscript -> test DOUBLECOLON test','subscript',3,'p_subscript14','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3155),
  ('exprlist -> expr','exprlist',1,'p_exprlist1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3160),
  ('exprlist -> expr COMMA','exprlist',2,'p_exprlist2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3165),
  ('exprlist -> expr exprlist_list','exprlist',2,'p_exprlist3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3172),
  ('exprlist -> expr exprlist_list COMMA','exprlist',3,'p_exprlist4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3179),
  ('exprlist_list -> COMMA expr','exprlist_list',2,'p_exprlist_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3186),
  ('exprlist_list -> exprlist_list COMMA expr','exprlist_list',3,'p_exprlist_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3191),
  ('dictorsetmaker -> test COLON test comp_for','dictorsetmaker',4,'p_dictorsetmaker1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3196),
  ('dictorsetmaker -> test COLON test','dictorsetmaker',3,'p_dictorsetmaker2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3201),
  ('dictorsetmaker -> test COLON test COMMA','dictorsetmaker',4,'p_dictorsetmaker3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3207),
  ('dictorsetmaker -> test COLON test dosm_colon_list','dictorsetmaker',4,'p_dictorsetmaker4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3213),
  ('dictorsetmaker -> test COLON test dosm_colon_list COMMA','dictorsetmaker',5,'p_dictorsetmaker5','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3219),
  ('dictorsetmaker -> test comp_for','dictorsetmaker',2,'p_dictorsetmaker6','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3225),
  ('dictorsetmaker -> test COMMA','dictorsetmaker',2,'p_dictorsetmaker7','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3230),
  ('dictorsetmaker -> test dosm_comma_list','dictorsetmaker',2,'p_dictorsetmaker8','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3236),
  ('dictorsetmaker -> test dosm_comma_list COMMA','dictorsetmaker',3,'p_dictorsetmaker9','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3242),
  ('dosm_colon_list -> COMMA test COLON test','dosm_colon_list',4,'p_dosm_colon_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3248),
  ('dosm_colon_list -> dosm_colon_list COMMA test COLON test','dosm_colon_list',5,'p_dosm_colon_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3253),
  ('dosm_comma_list -> COMMA test','dosm_comma_list',2,'p_dosm_comma_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3258),
  ('dosm_comma_list -> dosm_comma_list COMMA test','dosm_comma_list',3,'p_dosm_comma_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3263),
  ('arglist -> argument','arglist',1,'p_arglist1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3268),
  ('arglist -> argument COMMA','arglist',2,'p_arglist2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3276),
  ('arglist -> STAR test','arglist',2,'p_arglist3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3284),
  ('arglist -> STAR test COMMA DOUBLESTAR test','arglist',5,'p_arglist4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3289),
  ('arglist -> DOUBLESTAR test','arglist',2,'p_arglist5','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3294),
  ('arglist -> arglist_list argument','arglist',2,'p_arglist6','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3316),
  ('arglist -> arglist_list argument COMMA','arglist',3,'p_arglist7','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3334),
  ('arglist -> arglist_list STAR test','arglist',3,'p_arglist8','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3351),
  ('arglist -> arglist_list STAR test COMMA DOUBLESTAR test','arglist',6,'p_arglist9','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3365),
  ('arglist -> arglist_list DOUBLESTAR test','arglist',3,'p_arglist10','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3379),
  ('arglist -> STAR test COMMA argument','arglist',4,'p_arglist11','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3393),
  ('arglist -> STAR test COMMA argument COMMA DOUBLESTAR test','arglist',7,'p_arglist12','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3404),
  ('arglist -> STAR test COMMA arglist_list argument','arglist',5,'p_arglist13','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3415),
  ('arglist -> STAR test COMMA arglist_list argument COMMA DOUBLESTAR test','arglist',8,'p_arglist14','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3432),
  ('arglist_list -> argument COMMA','arglist_list',2,'p_arglist_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3449),
  ('arglist_list -> arglist_list argument COMMA','arglist_list',3,'p_arglist_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3456),
  ('argument -> test','argument',1,'p_argument1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3463),
  ('argument -> test comp_for','argument',2,'p_argument2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3468),
  ('argument -> test EQUAL test','argument',3,'p_argument3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3475),
  ('list_for -> FOR exprlist IN testlist_safe','list_for',4,'p_list_for1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3486),
  ('list_for -> FOR exprlist IN testlist_safe list_iter','list_for',5,'p_list_for2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3493),
  ('list_iter -> list_for','list_iter',1,'p_list_iter1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3507),
  ('list_iter -> list_if','list_iter',1,'p_list_iter2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3512),
  ('list_if -> IF old_test','list_if',2,'p_list_if1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3517),
  ('list_if -> IF old_test list_iter','list_if',3,'p_list_if2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3522),
  ('comp_for -> FOR exprlist IN or_test','comp_for',4,'p_comp_for1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3527),
  ('comp_for -> FOR exprlist IN or_test comp_iter','comp_for',5,'p_comp_for2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3534),
  ('comp_iter -> comp_for','comp_iter',1,'p_comp_iter1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3548),
  ('comp_iter -> comp_if','comp_iter',1,'p_comp_iter2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3553),
  ('comp_if -> IF old_test','comp_if',2,'p_comp_if1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3558),
  ('comp_if -> IF old_test comp_iter','comp_if',3,'p_comp_if2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3563),
  ('testlist_safe -> old_test','testlist_safe',1,'p_testlist_safe1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3568),
  ('testlist_safe -> old_test testlist_safe_list','testlist_safe',2,'p_testlist_safe2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3573),
  ('testlist_safe -> old_test testlist_safe_list COMMA','testlist_safe',3,'p_testlist_safe3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3579),
  ('testlist_safe_list -> COMMA old_test','testlist_safe_list',2,'p_testlist_safe_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3585),
  ('testlist_safe_list -> testlist_safe_list COMMA old_test','testlist_safe_list',3,'p_testlist_safe_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3590),
  ('old_test -> or_test','old_test',1,'p_old_test1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3595),
  ('old_test -> old_lambdef','old_test',1,'p_old_test2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3600),
  ('old_lambdef -> LAMBDA COLON old_test','old_lambdef',3,'p_old_lambdef1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3605),
  ('old_lambdef -> LAMBDA varargslist COLON old_test','old_lambdef',4,'p_old_lambdef2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3612),
  ('lambdef -> LAMBDA COLON test','lambdef',3,'p_lambdef1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3619),
  ('lambdef -> LAMBDA varargslist COLON test','lambdef',4,'p_lambdef2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3626),
  ('varargslist -> fpdef COMMA STAR NAME','varargslist',4,'p_varargslist1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3633),
  ('varargslist -> fpdef COMMA STAR NAME COMMA DOUBLESTAR NAME','varargslist',7,'p_varargslist2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3640),
  ('varargslist -> fpdef COMMA DOUBLESTAR NAME','varargslist',4,'p_varargslist3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3647),
  ('varargslist -> fpdef','varargslist',1,'p_varargslist4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3654),
  ('varargslist -> fpdef COMMA','varargslist',2,'p_varargslist5','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3661),
  ('varargslist -> fpdef varargslist_list COMMA STAR NAME','varargslist',5,'p_varargslist6','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3668),
  ('varargslist -> fpdef varargslist_list COMMA STAR NAME COMMA DOUBLESTAR NAME','varargslist',8,'p_varargslist7','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3677),
  ('varargslist -> fpdef varargslist_list COMMA DOUBLESTAR NAME','varargslist',5,'p_varargslist8','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3686),
  ('varargslist -> fpdef varargslist_list','varargslist',2,'p_varargslist9','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3695),
  ('varargslist -> fpdef varargslist_list COMMA','varargslist',3,'p_varargslist10','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3704),
  ('varargslist -> fpdef EQUAL test COMMA STAR NAME','varargslist',6,'p_varargslist11','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3713),
  ('varargslist -> fpdef EQUAL test COMMA STAR NAME COMMA DOUBLESTAR NAME','varargslist',9,'p_varargslist12','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3720),
  ('varargslist -> fpdef EQUAL test COMMA DOUBLESTAR NAME','varargslist',6,'p_varargslist13','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3727),
  ('varargslist -> fpdef EQUAL test','varargslist',3,'p_varargslist14','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3734),
  ('varargslist -> fpdef EQUAL test COMMA','varargslist',4,'p_varargslist15','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3741),
  ('varargslist -> fpdef EQUAL test varargslist_list COMMA STAR NAME','varargslist',7,'p_varargslist16','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3748),
  ('varargslist -> fpdef EQUAL test varargslist_list COMMA STAR NAME COMMA DOUBLESTAR NAME','varargslist',10,'p_varargslist17','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3761),
  ('varargslist -> fpdef EQUAL test varargslist_list COMMA DOUBLESTAR NAME','varargslist',7,'p_varargslist18','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3774),
  ('varargslist -> fpdef EQUAL test varargslist_list','varargslist',4,'p_varargslist19','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3787),
  ('varargslist -> fpdef EQUAL test varargslist_list COMMA','varargslist',5,'p_varargslist20','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3800),
  ('varargslist -> STAR NAME','varargslist',2,'p_varargslist21','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3813),
  ('varargslist -> STAR NAME COMMA DOUBLESTAR NAME','varargslist',5,'p_varargslist22','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3819),
  ('varargslist -> DOUBLESTAR NAME','varargslist',2,'p_varargslist23','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3825),
  ('varargslist_list -> COMMA fpdef','varargslist_list',2,'p_varargslist_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3832),
  ('varargslist_list -> COMMA fpdef EQUAL test','varargslist_list',4,'p_varargslist_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3837),
  ('varargslist_list -> varargslist_list COMMA fpdef','varargslist_list',3,'p_varargslist_list3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3842),
  ('varargslist_list -> varargslist_list COMMA fpdef EQUAL test','varargslist_list',5,'p_varargslist_list4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3853),
  ('fpdef -> NAME','fpdef',1,'p_fpdef1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3861),
  ('fpdef -> LPAR fplist RPAR','fpdef',3,'p_fpdef2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3866),
  ('fplist -> fpdef','fplist',1,'p_fplist1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3873),
  ('fplist -> fpdef COMMA','fplist',2,'p_fplist2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3878),
  ('fplist -> fpdef fplist_list','fplist',2,'p_fplist3','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3886),
  ('fplist -> fpdef fplist_list COMMA','fplist',3,'p_fplist4','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3895),
  ('fplist_list -> COMMA fpdef','fplist_list',2,'p_fplist_list1','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3904),
  ('fplist_list -> fplist_list COMMA fpdef','fplist_list',3,'p_fplist_list2','c:\\users\\i341972\\development\\enaml\\enaml\\core\\parser.py',3909),
]

########NEW FILE########
__FILENAME__ = pattern
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import List

from .declarative import Declarative


class Pattern(Declarative):
    """ A declarative object that represents a pattern object.

    The Pattern class serves as a base class for other classes such as
    Looper and Conditional, where the compiler nodes for the hierarchy
    are used to modify the standard behavior of creating children.

    Creating a Pattern without a parent is a programming error.

    """
    #: Single to the compiler that this class handles child creation.
    __intercepts_child_nodes__ = True

    #: Storage for the collected pattern nodes. This is used directly
    #: by subclasses and should not be manipulated by user code.
    pattern_nodes = List()

    #--------------------------------------------------------------------------
    # Lifetime API
    #--------------------------------------------------------------------------
    def initialize(self):
        """ A reimplemented initialization method.

        """
        super(Pattern, self).initialize()
        self.refresh_items()
        # The pattern is responsible for initializing new items
        # during the initialization pass. At all other times, the
        # parent declarative object will initialize new children.
        for item in self.pattern_items():
            item.initialize()

    def destroy(self):
        """ A reimplemented destructor.

        The pattern will destroy all of the pattern items unless the
        parent object is in the process of being destroyed.

        """
        parent = self.parent
        destroy_items = parent is None or not parent.is_destroyed
        super(Pattern, self).destroy()
        if destroy_items:
            for item in self.pattern_items():
                if not item.is_destroyed:
                    item.destroy()
        del self.pattern_nodes

    def child_node_intercept(self, nodes, key, f_locals):
        """ Add a child subtree to this pattern.

        This method changes the default behavior of the runtime. It
        stores the child nodes and the locals mapping until the object
        is initialized, at which point the nodes will be called to
        create the pattern items.

        Parameters
        ----------
        nodes : list
            A list of compiler nodes containing the information required
            to instantiate the children.

        key : object
            The scope key for the current local scope.

        f_locals : mapping or None
            A mapping object for the current local scope.

        """
        self.pattern_nodes.append((nodes, key, f_locals))

    #--------------------------------------------------------------------------
    # Abstract API
    #--------------------------------------------------------------------------
    def pattern_items(self):
        """ Get a list of the items created by the pattern.

        This method must be implemented by subclasses to return a flat
        list of Declarative instances created by the subclass.

        Returns
        -------
        result : list
            A new list of Declarative objects owned by the pattern.

        """
        raise NotImplementedError

    def refresh_items(self):
        """ Refresh the items of the pattern.

        This method must be implemented by subclasses to refresh the
        items of the pattern.

        """
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = standard_handlers
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from types import FunctionType

from atom.api import Atom, Typed

from .dynamicscope import DynamicScope
from .expression_engine import ReadHandler, WriteHandler
from .funchelper import call_func
from .standard_inverter import StandardInverter
from .standard_tracer import StandardTracer


class HandlerMixin(Atom):
    """ A mixin class which provides common handler functionality.

    """
    #: The function to invoke to execute the expression. This value is
    #: provided by the standard operators, and will be appropriate for
    #: the given handler type.
    func = Typed(FunctionType)

    #: The key for the local scope in the storage map. This value is
    #: generated by the compiler and provided by the operators.
    scope_key = Typed(object)

    def get_locals(self, owner):
        """ Get a mapping of locals for expression evaluation.

        Parameters
        ----------
        owner : Declarative
            The object on which the handler is executing.

        Returns
        -------
        result : mapping
            A mapping object to use as the local scope.

        """
        return owner._d_storage.get(self.scope_key) or {}


class StandardReadHandler(ReadHandler, HandlerMixin):
    """ An expression read handler for simple read semantics.

    This handler is used in conjuction with the standard '=' operator.

    """
    def __call__(self, owner, name):
        """ Evaluate and return the expression value.

        """
        func = self.func
        f_globals = func.func_globals
        f_builtins = f_globals['__builtins__']
        f_locals = self.get_locals(owner)
        scope = DynamicScope(owner, f_locals, f_globals, f_builtins)
        return call_func(func, (), {}, scope)


class StandardWriteHandler(WriteHandler, HandlerMixin):
    """ An expression write handler for simple write semantics.

    This handler is used in conjuction with the standard '::' operator.

    """
    def __call__(self, owner, name, change):
        """ Write the change to the expression.

        """
        func = self.func
        f_globals = func.func_globals
        f_builtins = f_globals['__builtins__']
        f_locals = self.get_locals(owner)
        scope = DynamicScope(owner, f_locals, f_globals, f_builtins, change)
        call_func(func, (), {}, scope)


class StandardTracedReadHandler(ReadHandler, HandlerMixin):
    """ An expression read handler which traces code execution.

    This handler is used in conjuction with the standard '<<' operator.

    """
    def __call__(self, owner, name):
        """ Evaluate and return the expression value.

        """
        func = self.func
        f_globals = func.func_globals
        f_builtins = f_globals['__builtins__']
        f_locals = self.get_locals(owner)
        tr = StandardTracer(owner, name)
        scope = DynamicScope(owner, f_locals, f_globals, f_builtins, None, tr)
        return call_func(func, (tr,), {}, scope)


class StandardInvertedWriteHandler(WriteHandler, HandlerMixin):
    """ An expression writer which writes an expression value.

    This handler is used in conjuction with the standard '>>' operator.

    """
    def __call__(self, owner, name, change):
        """ Write the change to the expression.

        """
        func = self.func
        f_globals = func.func_globals
        f_builtins = f_globals['__builtins__']
        f_locals = self.get_locals(owner)
        scope = DynamicScope(owner, f_locals, f_globals, f_builtins)
        inverter = StandardInverter(scope)
        call_func(func, (inverter, change['value']), {}, scope)

########NEW FILE########
__FILENAME__ = standard_inverter
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from .code_tracing import CodeInverter


class StandardInverter(CodeInverter):
    """ The standard code inverter for Enaml expressions.

    """
    __slots__ = 'scope'

    def __init__(self, scope):
        """ Initialize a StandardInverter.

        Parameters
        ----------
        scope : DynamicScope
            The dynamic scope for the executing expression.

        """
        self.scope = scope

    #--------------------------------------------------------------------------
    # CodeInverter Interface
    #--------------------------------------------------------------------------
    def load_name(self, name, value):
        """ Called before the LOAD_NAME opcode is executed.

        This method performs STORE_NAME by storing to the nonlocals.
        See also: `CodeInverter.load_name`.

        """
        self.scope['nonlocals'][name] = value

    def load_attr(self, obj, attr, value):
        """ Called before the LOAD_ATTR opcode is executed.

        This method performs STORE_ATTR via the builtin `setattr`.
        See also: `CodeInverter.load_attr`.

        """
        setattr(obj, attr, value)

    def call_function(self, func, argtuple, argspec, value):
        """ Called before the CALL_FUNCTION opcode is executed.

        This method inverts a call to the builtin `getattr` into a call
        to the builtin `setattr`. All other calls will raise.
        See also: `CodeInverter.call_function`.

        """
        nargs = argspec & 0xFF
        nkwargs = (argspec >> 8) & 0xFF
        if (func is getattr and (nargs == 2 or nargs == 3) and nkwargs == 0):
            obj, attr = argtuple[0], argtuple[1]
            setattr(obj, attr, value)
        else:
            self.fail()

    def binary_subscr(self, obj, idx, value):
        """ Called before the BINARY_SUBSCR opcode is executed.

        This method performs a STORE_SUBSCR operation through standard
        setitem semantics. See also: `CodeInverter.binary_subscr`.

        """
        obj[idx] = value

########NEW FILE########
__FILENAME__ = standard_tracer
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, atomref

from .alias import Alias
from .code_tracing import CodeTracer


class SubscriptionObserver(object):
    """ An observer object which manages a tracer subscription.

    """
    __slots__ = ('ref', 'name')

    def __init__(self, owner, name):
        """ Initialize a SubscriptionObserver.

        Parameters
        ----------
        owner : Declarative
            The declarative owner of interest.

        name : string
            The name to which the operator is bound.

        """
        self.ref = atomref(owner)
        self.name = name

    def __nonzero__(self):
        """ The notifier is valid when it has an internal owner.

        The atom observer mechanism will remove the observer when it
        tests boolean False.

        """
        return bool(self.ref)

    def __call__(self, change):
        """ The handler for the change notification.

        This will be invoked by the Atom observer mechanism when the
        item which is being observed changes.

        """
        if self.ref:
            owner = self.ref()
            engine = owner._d_engine
            if engine is not None:
                engine.update(owner, self.name)


class StandardTracer(CodeTracer):
    """ A CodeTracer for tracing expressions which use Atom.

    This tracer maintains a running set of `traced_items` which are the
    (obj, name) pairs of atom items discovered during tracing.

    """
    __slots__ = ('owner', 'name', 'items')

    def __init__(self, owner, name):
        """ Initialize a StandardTracer.

        """
        self.owner = owner
        self.name = name
        self.items = set()

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def trace_atom(self, obj, name):
        """ Add the atom object and name pair to the traced items.

        Parameters
        ----------
        obj : Atom
            The atom object owning the attribute.

        name : string
            The member name for which to bind a handler.

        """
        if obj.get_member(name) is not None:
            self.items.add((obj, name))
        else:
            alias = getattr(type(obj), name, None)
            if isinstance(alias, Alias):
                alias_obj, alias_attr = alias.resolve(obj)
                if alias_attr:
                    self.trace_atom(alias_obj, alias_attr)

    def finalize(self):
        """ Finalize the tracing process.

        This method will discard the old observer and attach a new
        observer to the traced dependencies.

        """
        owner = self.owner
        name = self.name
        key = '_[%s|trace]' % name
        storage = owner._d_storage

        # invalidate the old observer so that it can be collected
        old_observer = storage.get(key)
        if old_observer is not None:
            old_observer.ref = None

        # create a new observer and subscribe it to the dependencies
        if self.items:
            observer = SubscriptionObserver(owner, name)
            storage[key] = observer
            for obj, d_name in self.items:
                obj.observe(d_name, observer)

    #--------------------------------------------------------------------------
    # AbstractScopeListener Interface
    #--------------------------------------------------------------------------
    def dynamic_load(self, obj, attr, value):
        """ Called when an object attribute is dynamically loaded.

        This will trace the object if it is an Atom instance.
        See also: `AbstractScopeListener.dynamic_load`.

        """
        if isinstance(obj, Atom):
            self.trace_atom(obj, attr)

    #--------------------------------------------------------------------------
    # CodeTracer Interface
    #--------------------------------------------------------------------------
    def load_attr(self, obj, attr):
        """ Called before the LOAD_ATTR opcode is executed.

        This will trace the object if it is an Atom instance.
        See also: `CodeTracer.load_attr`.

        """
        if isinstance(obj, Atom):
            self.trace_atom(obj, attr)

    def call_function(self, func, argtuple, argspec):
        """ Called before the CALL_FUNCTION opcode is executed.

        This will trace the func if it is the builtin `getattr` and the
        object is an Atom instance. See also: `CodeTracer.call_function`

        """
        nargs = argspec & 0xFF
        nkwargs = (argspec >> 8) & 0xFF
        if (func is getattr and (nargs == 2 or nargs == 3) and nkwargs == 0):
            obj, attr = argtuple[0], argtuple[1]
            if isinstance(obj, Atom) and isinstance(attr, basestring):
                self.trace_atom(obj, attr)

    def return_value(self, value):
        """ Called before the RETURN_VALUE opcode is executed.

        This handler finalizes the subscription.

        """
        self.finalize()

########NEW FILE########
__FILENAME__ = template
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from types import FunctionType

from atom.api import Atom, List, Str, Tuple, Typed

from .byteplay import CO_VARARGS
from .compiler_nodes import TemplateNode


class TemplateInstance(Atom):
    """ A class representing a template instantiation.

    Instances of this class are created by instances of Template. They
    should not be created directly by user code.

    """
    #: The template node generated by the specialization function.
    node = Typed(TemplateNode)

    def __call__(self, parent=None, **kwargs):
        """ Instantiate the list of items for the template.

        Parameters
        ----------
        parent : Object, optional
            The parent object for the generated objects.

        **kwargs
            Additional keyword arguments to apply to the returned
            items.

        Returns
        -------
        result : list
            The list of objects generated by the template.

        """
        items = self.node(parent)
        if items and kwargs:
            for item in items:
                for key, value in kwargs.iteritems():
                    setattr(item, key, value)
        return items

    def __getattr__(self, name):
        """ Get the named attribute for the template instance.

        This method will retrieve the value from the template scope, if
        present. Otherwise, it will raise an AttributeError.

        """
        try:
            return self.node.scope[name]
        except KeyError:
            msg = "'%s' object has no attribute '%s'"
            raise AttributeError(msg % (type(self).__name__, name))


class Specialization(Atom):
    """ A class which represents the specialization of a template.

    Instances of this class are created by instances of Template.

    """
    #: The function which builds the TemplateNode.
    func = Typed(FunctionType)

    #: The specialized parameter values for the template.
    paramspec = Tuple()


class Template(Atom):
    """ A class representing a 'template' definition.

    """
    #: The name associated with the template.
    name = Str()

    #: The module name in which the template lives.
    module = Str()

    #: The list of specializations associated with the template. This
    #: list is populated by the compiler.
    specializations = List(Specialization)

    #: The cache of template instantiations.
    cache = Typed(dict, ())

    def __repr__(self):
        """ A nice repr for objects created by the `template` keyword.

        """
        return "<template '%s.%s'>" % (self.module, self.name)

    def make_paramspec(self, items):
        """ Convert the given items into a parameter specification.

        Parameters
        ----------
        items : tuple
            A tuple of parameter objects.

        Returns
        -------
        result : tuple
            A tuple of 2-tuples representing the parameter spec. Each
            2-tuple is of the form (bool, value) where the boolean
            indicates whether the value is a type.

        """
        return tuple((isinstance(item, type), item) for item in items)

    def add_specialization(self, params, func):
        """ Add a specialization to the template.

        Parameters
        ----------
        params : tuple
            A tuple specifying the parameter specializations for the
            positional arguments of the template function. A value of
            None indicates that the parameter can be of any type.

        func : FunctionType
            A function which will return a TemplateNode when invoked
            with user arguments.

        """
        paramspec = self.make_paramspec(params)
        for spec in self.specializations:
            if spec.paramspec == paramspec:
                msg = 'ambiguous template specialization for parameters: %s'
                raise TypeError(msg % (params,))
        spec = Specialization()
        spec.func = func
        spec.paramspec = paramspec
        self.specializations.append(spec)

    def get_specialization(self, args):
        """ Get the specialization for the given arguments.

        Parameters
        ----------
        args : tuple
            A tuple of arguments to match against the current template
            specializations.

        Returns
        -------
        result : Specialization or None
            The best matching specialization for the arguments, or None
            if no match could be found.

        """
        matches = []
        n_args = len(args)
        argspec = None

        for spec in self.specializations:
            # Before scoring for a match, rule out incompatible specs
            # based on the number of arguments. To few arguments is no
            # match, and too many is no match unless the specialization
            # accepts variadic arguments.
            n_params = len(spec.paramspec)
            if n_args < n_params:
                continue
            n_total = n_params + len(spec.func.func_defaults or ())
            variadic = spec.func.func_code.co_flags & CO_VARARGS
            if n_args > n_total and not variadic:
                continue

            # Defer creating the argpec until needed
            if argspec is None:
                argspec = self.make_paramspec(args)

            # Scoring a match is done by ranking the arguments using a
            # closeness meausure. If an argument is an exact match to
            # the parameter, it gets a score of 0. If an argument is a
            # subtype of a type parameter, it gets a score equal to the
            # index of the type in the mro of the subtype. If the arg
            # is not an exact match or a subtype, the specialization is
            # not a match. If the parameter has no specialization, the
            # argument gets a score of 1 << 16, which is arbitrary but
            # large enough that it's highly unlikely to be outweighed
            # by any mro type match (1 << 16 subclasses!) and small
            # enough that max_args * (1 << 16) is less that sys.maxint.
            # The default and variadic parameters do not enter into the
            # scoring since the 'add_specialization' method will reject
            # any specialization which is ambiguous. The lowest score
            # wins and a tie will raise an exception.
            score = 0
            items = zip(argspec, spec.paramspec)
            for (a_type, arg), (p_type, param) in items:
                if arg == param:
                    continue
                if param is None:
                    score += 1 << 16
                    continue
                if p_type and a_type and param in arg.__mro__:
                    score += arg.__mro__.index(param)
                    continue
                score = -1
                break
            if score >= 0:
                matches.append((score, spec))

        if matches:
            if len(matches) == 1:
                return matches[0][1]
            matches.sort()
            score_0, match_0 = matches[0]
            score_1, match_1 = matches[1]
            if score_0 == score_1:
                msg = "ambiguous template instantiation for arguments: %s"
                raise TypeError(msg % (args,))
            return match_0

    def __call__(self, *args):
        """ Instantiate the template for the given arguments.

        Parameters
        ----------
        *args
            The arguments to use to instantiate the template.

        Returns
        -------
        result : TemplateInstance
            The instantiated template.

        """
        inst = self.cache.get(args)
        if inst is not None:
            return inst
        spec = self.get_specialization(args)
        if spec is not None:
            inst = TemplateInstance()
            inst.node = spec.func(*args)
            self.cache[args] = inst
            return inst
        msg = 'no matching template specialization for arguments: %s'
        raise TypeError(msg % (args,))

########NEW FILE########
__FILENAME__ = template_
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
""" An alias import module for the `template` module.

This exists because `template` is a keyword in Enaml, and the module
may need to be imported by Enaml code.

"""
from .template import *

########NEW FILE########
__FILENAME__ = template_compiler
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import List, Typed

from . import block_compiler as block
from . import compiler_common as cmn
from .enaml_ast import ConstExpr, Template


def collect_local_names(node):
    """ Collect the compile-time local variable names for the node.

    Parameters
    ----------
    node : Template
        The enaml ast template node of interest.

    Returns
    -------
    result : tuple
        A 2-tuple of (const_names, param_names) lists for the template.

    """
    const_names = []
    param_names = []
    params = node.parameters
    for param in (params.positional + params.keywords):
        param_names.append(param.name)
    if params.starparam:
        param_names.append(params.starparam)
    for item in node.body:
        if isinstance(item, ConstExpr):
            const_names.append(item.name)
    return const_names, param_names


class FirstPassTemplateCompiler(block.FirstPassBlockCompiler):
    """ The first pass template compiler.

    This compiler generates the code which builds the compiler nodes
    for the template definition. The main entry point is the 'compile'
    class method.

    """
    #: The const names collected during traversal.
    const_names = List()

    @classmethod
    def compile(cls, node, args, local_names, filename):
        """ Invoke the compiler for the given node.

        The generated code object expects the SCOPE_KEY to be passed as
        one of the arguments. The code object will return a 2-tuple of
        compiler node list and const expression value tuple.

        Parameters
        ----------
        node : Template
            The enaml ast Template node of interest.

        args : list
            The list of argument names which will be passed to the
            code object when it is invoked.

        local_names : set
            The set of local names which are available to the code
            object. This should be the combination of const expression
            names and template parameter names.

        filename : str
            The filename of the node being compiled.

        Returns
        -------
        result : tuple
            A 2-tuple of (code, index_map) which is the generated code
            object for the first compiler pass, and a mapping of ast
            node to relevant compiler node index.

        """
        compiler = cls()
        compiler.filename = filename
        compiler.local_names = local_names
        cg = compiler.code_generator

        # Setup the block for execution.
        cmn.fetch_helpers(cg)
        cmn.make_node_list(cg, cmn.count_nodes(node))

        # Dispatch the visitors.
        compiler.visit(node)

        # Setup the parameters and generate the code object.
        cg.name = node.name
        cg.firstlineno = node.lineno
        cg.newlocals = True
        cg.args = args
        code = cg.to_code()

        # Union the two index maps for use by the second compiler pass.
        final_index_map = dict(compiler.index_map)
        final_index_map.update(compiler.aux_index_map)

        return (code, final_index_map)

    def visit_Template(self, node):
        # No pragmas are supported yet for template nodes.
        cmn.warn_pragmas(node, self.filename)

        # Claim the index for the compiler node
        index = len(self.index_map)
        self.index_map[node] = index

        # Setup the line number for the template.
        cg = self.code_generator
        cg.set_lineno(node.lineno)

        # Create the template compiler node and store in the node list.
        cmn.load_helper(cg, 'template_node')
        cg.load_fast(cmn.SCOPE_KEY)
        cg.call_function(1)
        cmn.store_node(cg, index)

        # Visit the body of the template.
        for item in node.body:
            self.visit(item)

        # Update the internal node ids for the hierarchy.
        cmn.load_node(cg, 0)
        cg.load_attr('update_id_nodes')
        cg.call_function()
        cg.pop_top()

        # Load the compiler node list for returning.
        cg.load_fast(cmn.NODE_LIST)

        # Load the const names for returning.
        for name in self.const_names:
            cg.load_fast(name)
        cg.build_tuple(len(self.const_names))

        # Create and return the return value tuple.
        cg.build_tuple(2)
        cg.return_value()

    def visit_ConstExpr(self, node):
        # Keep track of the const name for loading for return.
        self.const_names.append(node.name)

        # Setup the line number for the const expr.
        cg = self.code_generator
        cg.set_lineno(node.lineno)

        # Generate the code for the expression.
        names = self.local_names
        cmn.safe_eval_ast(cg, node.expr.ast, node.name, node.lineno, names)

        # Validate the type of the expression value.
        if node.typename:
            with cg.try_squash_raise():
                cg.dup_top()
                cmn.load_helper(cg, 'type_check_expr')
                cg.rot_two()
                cmn.load_name(cg, node.typename, names)
                cg.call_function(2)
                cg.pop_top()

        # Store the result in the fast locals.
        cg.store_fast(node.name)


class SecondPassTemplateCompiler(block.SecondPassBlockCompiler):
    """ The second pass template compiler.

    This compiler generates code which binds the data to the compiler
    nodes for the template definition. The main entry point is the
    'compile' class method.

    """
    #: A mapping of const names to their value index.
    const_indices = Typed(dict, ())

    @classmethod
    def compile(cls, node, args, local_names, index_map, consts, filename):
        """ Invoke the compiler for the given node.

        The generated code object expects NODE_LIST and T_CONSTS to be
        passed as part of the arguments.

        Parameters
        ----------
        node : Template
            The enaml ast Template node of interest.

        args : list
            The list of argument names which will be passed to the
            code object when it is invoked.

        local_names : set
            The set of local names which are available to the code
            object. This should be the combination of const expression
            names and template parameter names.

        index_map : dict
            A mapping of ast node to compiler node index in the node list.

        consts : list
            The list of const expression names for the block.

        filename : str
            The filename of the node being compiled.

        Returns
        -------
        result : CodeType
            The code object which will bind the data for the block.

        """
        compiler = cls()
        compiler.filename = filename
        compiler.local_names = local_names
        compiler.index_map = index_map
        for index, name in enumerate(consts):
            compiler.const_indices[name] = index

        cg = compiler.code_generator

        # Setup the block for execution.
        cmn.fetch_helpers(cg)
        cmn.fetch_globals(cg)

        # Dispatch the visitors.
        compiler.visit(node)

        # Setup the parameters and generate the code object.
        cg.name = node.name
        cg.firstlineno = node.lineno
        cg.newlocals = True
        cg.args = args
        return cg.to_code()

    def visit_Template(self, node):
        # Visit the body of the template.
        for item in node.body:
            self.visit(item)

        # Add the return value for the code.
        cg = self.code_generator
        cg.load_const(None)
        cg.return_value()

    def visit_ConstExpr(self, node):
        # Store the value of the const expr into fast locals.
        cg = self.code_generator
        cg.set_lineno(node.lineno)
        cg.load_fast(cmn.T_CONSTS)
        cg.load_const(self.const_indices[node.name])
        cg.binary_subscr()
        cg.store_fast(node.name)


class TemplateCompiler(cmn.CompilerBase):
    """ A compiler which will compile an Enaml template definition.

    The entry point is the `compile` classmethod which will compile
    the ast into a python code object which will generate a template
    instance compiler node when invoked.

    """
    @classmethod
    def compile(cls, node, filename):
        """ The main entry point to the compiler.

        Parameters
        ----------
        node : Template
            The enaml ast Template node to compile.

        filename : str
            The filename of the node being compiled.

        Returns
        -------
        result : CodeType
            The compiled code object for the node.

        """
        assert isinstance(node, Template), 'invalid node'
        compiler = cls(filename=filename)
        return compiler.visit(node)

    def visit_Template(self, node):
        cg = self.code_generator
        filename = self.filename

        # Collect the data needed for the compiler passes.
        const_names, param_names = collect_local_names(node)
        local_names = set(const_names + param_names)

        # Generate the code for the first pass.
        first_args = [cmn.SCOPE_KEY] + param_names
        first_code, index_map = FirstPassTemplateCompiler.compile(
            node, first_args, local_names, filename
        )

        # Generate the code for the second pass.
        second_args = [cmn.NODE_LIST, cmn.T_CONSTS] + param_names
        second_code = SecondPassTemplateCompiler.compile(
            node, second_args, local_names, index_map, const_names, filename
        )

        # Prepare the code block for execution.
        cmn.fetch_helpers(cg)
        cmn.load_helper(cg, 'make_object')
        cg.call_function()
        cg.store_fast(cmn.SCOPE_KEY)

        # Load and invoke the first pass code object.
        cg.load_const(first_code)
        cg.make_function()
        for arg in first_args:
            cg.load_fast(arg)
        cg.call_function(len(first_args))
        cg.unpack_sequence(2)
        cg.store_fast(cmn.NODE_LIST)
        cg.store_fast(cmn.T_CONSTS)

        # Load and invoke the second pass code object.
        cg.load_const(second_code)
        cg.make_function()
        for arg in second_args:
            cg.load_fast(arg)
        cg.call_function(len(second_args))
        cg.pop_top()

        # Load the root template compiler node.
        cmn.load_node(cg, 0)

        # Add the template scope to the node.
        cg.dup_top()
        cmn.load_helper(cg, 'add_template_scope')
        cg.rot_two()
        cg.load_const(tuple(param_names + const_names))
        for name in param_names:
            cg.load_fast(name)
        cg.build_tuple(len(param_names))
        cg.load_fast(cmn.T_CONSTS)
        cg.binary_add()
        cg.call_function(3)
        cg.pop_top()

        # Return the template node to the caller.
        cg.return_value()

        # Setup the parameters and generate the code object.
        cg.name = node.name
        cg.firstlineno = node.lineno
        cg.newlocals = True
        cg.args = param_names
        cg.docstring = node.docstring
        cg.varargs = bool(node.parameters.starparam)
        return cg.to_code()

########NEW FILE########
__FILENAME__ = fonts
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
""" A utility module for dealing with CSS3 font strings.

"""
from atom.api import Coerced

from .fontext import Font, FontStyle, FontCaps


#: A mapping from CSS font style keyword to style enum
_STYLES = {
    'normal': FontStyle.Normal,
    'italic': FontStyle.Italic,
    'oblique': FontStyle.Oblique,
}


#: A mapping from CSS font variant keyword to caps enum
_VARIANTS = {
    'normal': FontCaps.MixedCase,
    'small-caps':  FontCaps.SmallCaps,
}


#: A mapping from CSS font weight to integer weight. These values are
#: pulled from the Qt stylesheet implementation of font parsing. Enaml
#: does not support the 'bolder' and 'lighter' keywords.
_WEIGHTS = {
    '100': 12,
    '200': 25,
    '300': 37,
    '400': 50,
    '500': 62,
    '600': 75,
    '700': 87,
    '800': 99,
    '900': 99,
    'normal': 50,
    'bold': 75,
}


#: A mapping from CSS font size keywords to font point sizes. These are
#: based on a standard 12 point font size.
_SIZES = {
    'xx-small': 7,
    'x-small': 8,
    'small': 9,
    'medium': 12,
    'large': 14,
    'x-large': 18,
    'xx-large': 24,
}


#: A mapping from CSS font units to functions which convert to points.
_UNITS = {
    'in': lambda size: int(size * 72.0),
    'cm': lambda size: int(size * 72.0 / 2.54),
    'mm': lambda size: int(size * 72.0 / 254.0),
    'pt': lambda size: int(size),
    'pc': lambda size: int(size * 12.0),
    'px': lambda size: int(size * 0.75),
}


def parse_font(font):
    """ Parse a CSS3 shorthand font string into an Enaml Font object.

    Returns
    -------
    result : Font or None
        A font object representing the parsed font. If the string is
        invalid, None will be returned.

    """
    token = []
    tokens = []
    quotechar = None
    for char in font:
        if quotechar is not None:
            if char == quotechar:
                tokens.append(''.join(token))
                token = []
                quotechar = None
            else:
                token.append(char)
        elif char == '"' or char == "'":
            quotechar = char
        elif char in ' \t':
            if token:
                tokens.append(''.join(token))
                token = []
        else:
            token.append(char)

    # Failed to close quoted string.
    if quotechar is not None:
        return

    if token:
        tokens.append(''.join(token))

    sizes = []
    families = []
    optionals = []
    for token in tokens:
        if token in _STYLES or token in _VARIANTS or token in _WEIGHTS:
            if len(sizes) > 0 or len(families) > 0:
                return None
            optionals.append(token)
        elif token in _SIZES or token[-2:] in _UNITS:
            if len(families) > 0:
                return None
            sizes.append(token)
        else:
            families.append(token)

    if len(optionals) > 3:
        return None
    if len(sizes) != 1:
        return None
    if len(families) != 1:
        return None

    style = None
    variant = None
    weight = None

    for opt in optionals:
        if opt == 'normal':
            continue
        elif opt in _STYLES:
            if style is not None:
                return None
            style = opt
        elif opt in _VARIANTS:
            if variant is not None:
                return None
            variant = opt
        elif opt in _WEIGHTS:
            if weight is not None:
                return None
            weight = opt
        else:
            return None

    size = sizes[0]
    if size in _SIZES:
        size = _SIZES[size]
    else:
        sizenum, units = size[:-2], size[-2:]
        try:
            sizenum = float(sizenum)
        except ValueError:
            return None
        size = _UNITS[units](sizenum)

    family = str(families[0])
    weight = _WEIGHTS[weight] if weight else _WEIGHTS['normal']
    style = _STYLES[style] if style else _STYLES['normal']
    variant = _VARIANTS[variant] if variant else _VARIANTS['normal']

    return Font(family, size, weight, style, variant)


def coerce_font(font):
    """ The coercing function for the FontMember.

    """
    if isinstance(font, basestring):
        return parse_font(font)


class FontMember(Coerced):
    """ An Atom member class which coerces a value to a font.

    A font member can be set to a Font, a string, or None. A string
    font will be parsed into a Font object. If the parsing fails,
    the font will be None.

    """
    __slots__ = ()

    def __init__(self, default=None, factory=None):
        """ Initialize a FontMember.

        default : Font, string, or None, optional
            The default font to use for the member.

        factory : callable, optional
            An optional callable which takes no arguments and returns
            the default value for the member. If this is provided, it
            will override any value passed as 'default'.

        Notes
        -----
        When providing a default font value, prefer using a Font object
        directly as this object will be shared among all instances of
        the class. Using a font string will result in a new Font object
        being created for each class instance.

        """
        if factory is None:
            factory = lambda: default
        kind = (Font, type(None))
        sup = super(FontMember, self)
        sup.__init__(kind, factory=factory, coercer=coerce_font)

########NEW FILE########
__FILENAME__ = icon
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, Enum, Typed, List, Value

from .image import Image


class IconImage(Atom):
    """ An object representing an image in an icon.

    Instances of this class are used to populate the 'images' list of
    an 'Icon' instance. Instances of this class should be treated as
    read only once they are created.

    """
    #: The widget mode for which this icon should apply.
    mode = Enum('normal', 'active', 'disabled', 'selected')

    #: The widget state for which this icon should apply.
    state = Enum('off', 'on')

    #: The image to use for this icon image.
    image = Typed(Image)


class Icon(Atom):
    """ An object object representing an icon.

    Once an image is created it should be treated as read only. User
    code should create a new icon object if the parameters need to
    be changed.

    """
    #: The list of icon images which compose this icon.
    images = List(IconImage)

    #: Storage space for use by a toolkit backend to use as needed.
    #: This should not typically be manipulated by user code.
    _tkdata = Value()

########NEW FILE########
__FILENAME__ = image
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, Enum, Str, Value, Coerced

from enaml.layout.geometry import Size


class Image(Atom):
    """ An object representing an image.

    Once an image is created it should be treated as read only. User
    code should create a new image object if the parameters need to
    be changed.

    """
    #: The format of the image. By default, the consumer of the image
    #: will probe the header to automatically infer a type.
    format = Enum(
        'auto',     # Automatically determine the image format
        'png',      # Portable Network Graphics
        'jpg',      # Joint Photographic Experts Group
        'gif',      # Graphics Interchange Format
        'bmp',      # Windows Bitmap
        'xpm',      # X11 Pixmap
        'xbm',      # X11 Bitmap
        'pbm',      # Portable Bitmap
        'pgm',      # Portable Graymap
        'ppm',      # Portable Pixmap
        'tiff',     # Tagged Image File Format
        'argb32',   # Raw data in the 0xAARRGGBB format.
                    # The `raw_size` of the image must be provided.
    )

    #: The (width, height) raw size of the image. This must be provided
    #: for images where the size is not encoded in the data stream.
    raw_size = Coerced(Size, (0, 0))

    #: The (width, height) size of the image. An invalid size indicates
    #: that the size of the image should be automatically inferred. A
    #: valid size indicates that the toolkit image should be scaled to
    #: the specified size.
    size = Coerced(Size, (-1, -1))

    #: The aspect ratio mode to use when the toolkit scales the image.
    aspect_ratio_mode = Enum('ignore', 'keep', 'keep_by_expanding')

    #: The transform mode to use when the toolkit scales the image.
    transform_mode = Enum('smooth', 'fast')

    # XXX this needs to be augmented to support arrays.
    #: The bytestring holding the data for the image.
    data = Str()

    #: Storage space for use by a toolkit backend to use as needed.
    #: This should not typically be manipulated by user code.
    _tkdata = Value()

########NEW FILE########
__FILENAME__ = api
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from .dock_layout import (
    ItemLayout, TabLayout, SplitLayout, HSplitLayout, VSplitLayout,
    DockBarLayout, AreaLayout, DockLayout, DockLayoutWarning,
    InsertItem, InsertBorderItem, InsertDockBarItem, InsertTab,
    FloatItem, FloatArea, RemoveItem, ExtendItem, RetractItem
)
from .layout_helpers import (
    align, hbox, vbox, horizontal, vertical, factory, grid, spacer,
)
from .geometry import Box, BoxF, Pos, PosF, Rect, RectF, Size, SizeF

########NEW FILE########
__FILENAME__ = box_helper
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from .constrainable import ContentsConstrainable, ConstrainableMixin
from .constraint_helper import ConstraintHelper


BOUNDARY_ATTRS = (
    'top',
    'bottom',
    'left',
    'right',
)


CONTENT_BOUNDARY_ATTRS = (
    'contents_top',
    'contents_bottom',
    'contents_left',
    'contents_right',
)


class BoxHelper(ConstraintHelper, ConstrainableMixin):
    """ A constraint helper for creating a box layouts.

    Instances of BoxHelper are Constrainable and can be nested in other
    box helpers to build up complex layouts. This is a base class which
    should be subclassed to implement the desired functionality.

    """
    def box_constraints(self, component):
        """ Generate the boundary constraints for the box.

        """
        cns = []
        if component is not None:
            a_attrs = b_attrs = BOUNDARY_ATTRS
            if isinstance(component, ContentsConstrainable):
                b_attrs = CONTENT_BOUNDARY_ATTRS
            f = lambda (a, b): getattr(self, a) == getattr(component, b)
            cns.extend(f(z) for z in zip(a_attrs, b_attrs))
        return cns

########NEW FILE########
__FILENAME__ = constrainable
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from abc import ABCMeta

from atom.api import Atom, Constant, DefaultValue, Enum

import kiwisolver as kiwi


class Constrainable(object):
    """ An abstract base class for defining constrainable objects.

    Implementations must provide `top`, `bottom`, `left`, `right`,
    `width`, `height`, `v_center` and `h_center` attributes which
    are instances of 'LinearSymbolic'.

    It must also provide 'hug_width', 'hug_height', 'resist_width',
    'resist_height', 'limit_width', and 'limit_height' attributes
    which are valid PolicyEnum values.

    """
    __metaclass__ = ABCMeta


class ContentsConstrainable(Constrainable):
    """ An abstract base class for contents constrainable objects.

    A contents constrainable object has additional linear symbolic
    attributes with the prefix 'contents_' for all of the symbolic
    attributes defined by Constrainable.

    """
    pass


class ConstraintMember(Constant):
    """ A custom Constant member that generates a kiwi Variable.

    """
    __slots__ = ()

    def __init__(self):
        super(ConstraintMember, self).__init__()
        mode = DefaultValue.MemberMethod_Object
        self.set_default_value_mode(mode, 'default')

    def default(self, owner):
        return kiwi.Variable(self.name)


#: An atom enum which defines the allowable constraints strengths.
#: Clones will be made by selecting a new default via 'select'.
PolicyEnum = Enum('ignore', 'weak', 'medium', 'strong', 'required')


class ConstrainableMixin(Atom):
    """ An atom mixin class which defines constraint members.

    This class implements the Constrainable interface.

    """
    #: The symbolic left boundary of the constrainable.
    left = ConstraintMember()

    #: The symbolic top boundary of the constrainable.
    top = ConstraintMember()

    #: The symbolic width of the constrainable.
    width = ConstraintMember()

    #: The symbolic height of the constrainable.
    height = ConstraintMember()

    #: A symbolic expression representing the top boundary.
    right = Constant()

    #: A symbolic expression representing the bottom boundary.
    bottom = Constant()

    #: A symbolic expression representing the horizontal center.
    h_center = Constant()

    #: A symbolic expression representing the vertical center.
    v_center = Constant()

    #: How strongly a widget hugs it's width hint. This is equivalent
    #: to the constraint:
    #:      (width == hint) | hug_width
    hug_width = PolicyEnum('strong')

    #: How strongly a widget hugs it's height hint. This is equivalent
    #: to the constraint:
    #:      (height == hint) | hug_height
    hug_height = PolicyEnum('strong')

    #: How strongly a widget resists clipping its width hint. This is
    #: equivalent to the constraint:
    #:      (width >= hint) | resist_width
    resist_width = PolicyEnum('strong')

    #: How strongly a widget resists clipping its height hint. This is
    #: iequivalent to the constraint:
    #:      (height >= hint) | resist_height
    resist_height = PolicyEnum('strong')

    #: How strongly a widget resists expanding its width hint. This is
    #: equivalent to the constraint:
    #:      (width <= hint) | limit_width
    limit_width = PolicyEnum('ignore')

    #: How strongly a widget resists expanding its height hint. This is
    #: equivalent to the constraint:
    #:      (height <= hint) | limit_height
    limit_height = PolicyEnum('ignore')

    def _default_right(self):
        return self.left + self.width

    def _default_bottom(self):
        return self.top + self.height

    def _default_h_center(self):
        return self.left + 0.5 * self.width

    def _default_v_center(self):
        return self.top + 0.5 * self.height


Constrainable.register(ConstrainableMixin)


class ContentsConstrainableMixin(ConstrainableMixin):
    """ An atom mixin class which defines contents constraint members.

    This class implements the ContentsConstrainable interface.

    """
    #: The symbolic left contents boundary of the constrainable.
    contents_left = ConstraintMember()

    #: The symbolic right contents boundary of the constrainable.
    contents_right = ConstraintMember()

    #: The symbolic top contents boundary of the constrainable.
    contents_top = ConstraintMember()

    #: The symbolic bottom contents boundary of the constrainable.
    contents_bottom = ConstraintMember()

    #: A symbolic expression representing the content width.
    contents_width = Constant()

    #: A symbolic expression representing the content height.
    contents_height = Constant()

    #: A symbolic expression representing the content horizontal center.
    contents_h_center = Constant()

    #: A symbolic expression representing the content vertical center.
    contents_v_center = Constant()

    def _default_contents_width(self):
        return self.contents_right - self.contents_left

    def _default_contents_height(self):
        return self.contents_bottom - self.contents_top

    def _default_contents_h_center(self):
        return self.contents_left + 0.5 * self.contents_width

    def _default_contents_v_center(self):
        return self.contents_top + 0.5 * self.contents_height


ContentsConstrainable.register(ContentsConstrainableMixin)

########NEW FILE########
__FILENAME__ = constraint_helper
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom

from .strength_member import StrengthMember


class ConstraintHelper(Atom):
    """ A base class for defining constraint helper objects.

    """
    #: An optional strength to apply to the generated constraints.
    strength = StrengthMember()

    def __or__(self, strength):
        """ Override the strength of the generated constraints.

        Parameters
        ----------
        strength : strength-like
            The strength to apply to the generated constraints.

        Returns
        -------
        result : self
            The current helper instance.

        """
        self.strength = strength
        return self

    def when(self, switch):
        """ A simple switch method to toggle a helper.

        Parameters
        ----------
        switch : bool
            Whether or not the helper should be active.

        Returns
        -------
        result : self or None
            The current instance if the switch is True, None otherwise.

        """
        return self if switch else None

    def create_constraints(self, component):
        """ Called to generate the constraints for the component.

        Parameters
        ----------
        component : Constrainable or None
            The constrainable object which represents the conceptual
            owner of the generated constraints. This will typically
            be a Container or some other constrainable object which
            represents the boundaries of the generated constraints.
            None will be passed when no outer component is available.

        Returns
        -------
        result : list
            The list of Constraint objects for the given component.

        """
        cns = self.constraints(component)
        strength = self.strength
        if strength is not None:
            cns = [cn | strength for cn in cns]
        return cns

    def constraints(self, component):
        """ Generate the constraints for the given component.

        This abstract method which must be implemented by subclasses.

        Parameters
        ----------
        component : Constrainable or None
            The constrainable object which represents the conceptual
            owner of the generated constraints. This will typically
            be a Container or some other constrainable object which
            represents the boundaries of the generated constraints.
            None will be passed when no outer component is available.

        Returns
        -------
        result : list
            The list of Constraint objects for the given component.

        """
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = dock_layout
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from collections import deque
import sys
import warnings

from atom.api import Atom, Int, Bool, Coerced, Enum, List, Unicode

from enaml.nodevisitor import NodeVisitor

from .geometry import Rect


def _coerce_rect(value):
    """ Coerce a value to a Rect object.

    This function is a private implementation detail.

    """
    if isinstance(value, (list, tuple)):
        return Rect(*value)
    msg = "cannot coerce '%s' to a 'Rect'"
    raise TypeError(msg % type(value).__name__)


class LayoutNode(Atom):
    """ A base class for defining layout nodes.

    This class provides basic traversal functionality.

    """
    def children(self):
        """ Get the children of the node.

        Returns
        -------
        result : list
            The list of LayoutNode children of the node. The default
            implementation returns an empty list.

        """
        return []

    def traverse(self, depth_first=False):
        """ Yield all of the nodes in the layout, from this node down.

        Parameters
        ----------
        depth_first : bool, optional
            If True, yield the nodes in depth first order. If False,
            yield the nodes in breadth first order. Defaults to False.

        Returns
        -------
        result : generator
            A generator which yields 2-tuples of (parent, node) for all
            nodes in the layout.

        """
        if depth_first:
            stack = [(None, self)]
            stack_pop = stack.pop
            stack_extend = stack.extend
        else:
            stack = deque([(None, self)])
            stack_pop = stack.popleft
            stack_extend = stack.extend
        while stack:
            parent, node = stack_pop()
            yield parent, node
            stack_extend((node, child) for child in node.children())

    def find(self, kind):
        """ Find the first layout node of the given kind.

        Parameters
        ----------
        kind : type or tuple of types
            The type of the layout node to find.

        Returns
        -------
        result : LayoutNode or None
            The first layout node of the given type in the tree. The
            search is performed breadth-first.

        """
        for parent, node in self.traverse():
            if isinstance(node, kind):
                return node

    def find_all(self, kind):
        """ Find the layout nodes of the given kind.

        Parameters
        ----------
        kind : type or tuple of types
            The type of the layout nodes to find.

        Returns
        -------
        result : list
            The list of the layout nodes in the tree which are of the
            request type. They are ordered breadth-first.

        """
        res = []
        for parent, node in self.traverse():
            if isinstance(node, kind):
                res.append(node)
        return res


class ItemLayout(LayoutNode):
    """ A layout object for defining an item layout.

    """
    #: The name of the DockItem to which this layout item applies.
    name = Unicode()

    #: Whether or not the item is floating. An ItemLayout defined as
    #: a toplevel item in a DockLayout should be marked as floating.
    floating = Bool(False)

    #: The geometry to apply to the item. This is expressed in desktop
    #: coordinates and only applies if the item is floating.
    geometry = Coerced(Rect, (-1, -1, -1, -1), coercer=_coerce_rect)

    #: Whether or not the item is linked with its floating neighbors.
    #: This value will only have an effect if the item is floating.
    linked = Bool(False)

    #: Whether or not the item is maximized. This value will only have
    #: effect if the item is floating or docked in a SplitLayout.
    maximized = Bool(False)

    def __init__(self, name, **kwargs):
        super(ItemLayout, self).__init__(name=name, **kwargs)


class TabLayout(LayoutNode):
    """ A layout object for defining tabbed dock layouts.

    """
    #: The position of the tabs in the tab layout.
    tab_position = Enum('top', 'bottom', 'left', 'right')

    #: The index of the currently selected tab.
    index = Int(0)

    #: The list of item layouts to include in the tab layout.
    items = List(Coerced(ItemLayout))

    def __init__(self, *items, **kwargs):
        super(TabLayout, self).__init__(items=list(items), **kwargs)

    def children(self):
        """ Get the list of children of the tab layout.

        """
        return self.items[:]


class _SplitLayoutItem(object):
    """ A private class which performs type checking for split layouts.

    """
    class __metaclass__(type):

        def __instancecheck__(cls, instance):
            return isinstance(instance, (ItemLayout, TabLayout, SplitLayout))

        def __call__(cls, item):
            if isinstance(item, basestring):
                return ItemLayout(item)
            msg = "cannot coerce '%s' to a 'SplitLayout' item"
            raise TypeError(msg % type(item).__name__)


class SplitLayout(LayoutNode):
    """ A layout object for defining split dock layouts.

    """
    #: The orientation of the split layout.
    orientation = Enum('horizontal', 'vertical')

    #: The default sizes to apply to the items in the splitter. If
    #: provided, the length must be equal to the number of items.
    sizes = List(Int())

    #: This list of split layout items to include in the split layout.
    items = List(Coerced(_SplitLayoutItem))

    def __init__(self, *items, **kwargs):
        super(SplitLayout, self).__init__(items=list(items), **kwargs)

    def children(self):
        """ Get the list of children of the split layout.

        """
        return self.items[:]


class HSplitLayout(SplitLayout):
    """ A split layout which defaults to 'horizonal' orientation.

    """
    def __init__(self, *items, **kwargs):
        kwargs['orientation'] = 'horizontal'
        super(HSplitLayout, self).__init__(*items, **kwargs)


class VSplitLayout(SplitLayout):
    """ A split layout which defaults to 'vertical' orientation.

    """
    def __init__(self, *items, **kwargs):
        kwargs['orientation'] = 'vertical'
        super(VSplitLayout, self).__init__(*items, **kwargs)


class DockBarLayout(LayoutNode):
    """ A layout object for defining a dock bar layout.

    """
    #: The position of the tool bar in its area. Only one tool bar may
    #: occupy a given position at any one time.
    position = Enum('top', 'right', 'bottom', 'left')

    #: The list of item layouts to include in the tab layout.
    items = List(Coerced(ItemLayout))

    def __init__(self, *items, **kwargs):
        super(DockBarLayout, self).__init__(items=list(items), **kwargs)

    def children(self):
        """ Get the list of children of the dock bar layout.

        """
        return self.items[:]


class _AreaLayoutItem(object):
    """ A private class which performs type checking for area layouts.

    """
    class __metaclass__(type):

        def __instancecheck__(cls, instance):
            allowed = (type(None), ItemLayout, TabLayout, SplitLayout)
            return isinstance(instance, allowed)

        def __call__(cls, item):
            if isinstance(item, basestring):
                return ItemLayout(item)
            msg = "cannot coerce '%s' to an 'AreaLayout' item"
            raise TypeError(msg % type(item).__name__)


class AreaLayout(LayoutNode):
    """ A layout object for defining a dock area layout.

    """
    #: The main layout item to include in the area layout.
    item = Coerced(_AreaLayoutItem)

    #: The dock bar layouts to include in the area layout.
    dock_bars = List(DockBarLayout)

    #: Whether or not the area is floating. A DockLayout should have
    #: at most one non-floating area layout.
    floating = Bool(False)

    #: The geometry to apply to the area. This is expressed in desktop
    #: coordinates and only applies if the area is floating.
    geometry = Coerced(Rect, (-1, -1, -1, -1), coercer=_coerce_rect)

    #: Whether or not the area is linked with its floating neighbors.
    #: This only has an effect if the area is a floating.
    linked = Bool(False)

    #: Whether or not the area is maximized. This only has an effect if
    #: the area is a floating.
    maximized = Bool(False)

    def __init__(self, item=None, **kwargs):
        super(AreaLayout, self).__init__(item=item, **kwargs)

    def children(self):
        """ Get the list of children of the area layout.

        """
        item = self.item
        base = [item] if item is not None else []
        return base + self.dock_bars


class _DockLayoutItem(object):
    """ A private class which performs type checking for dock layouts.

    """
    class __metaclass__(type):

        def __instancecheck__(cls, instance):
            return isinstance(instance, (ItemLayout, AreaLayout))

        def __call__(cls, item):
            if isinstance(item, basestring):
                return ItemLayout(item)
            if isinstance(item, (SplitLayout, TabLayout)):
                return AreaLayout(item)
            msg = "cannot coerce '%s' to a 'DockLayout' item"
            raise TypeError(msg % type(item).__name__)


class DockLayout(LayoutNode):
    """ The layout object for defining toplevel dock layouts.

    """
    #: The layout items to include in the dock layout.
    items = List(Coerced(_DockLayoutItem))

    def __init__(self, *items, **kwargs):
        super(DockLayout, self).__init__(items=list(items), **kwargs)

    def children(self):
        """ Get the list of children of the dock layout.

        """
        return self.items[:]


class DockLayoutWarning(UserWarning):
    """ A custom user warning for use with dock layouts.

    """
    pass


class DockLayoutValidator(NodeVisitor):
    """ A node visitor which validates a layout.

    If an irregularity or invalid condition is found in the layout, a
    warning is emitted. Such conditions can result in undefined layout
    behavior.

    """
    def __init__(self, available):
        """ Initialize a DockLayoutValidator.

        Parameters
        ----------
        available : iterable
            An iterable of strings which represent the available dock
            item names onto which the layout will be applied. These are
            used to validate the set of visited ItemLayout instances.

        """
        self._available = set(available)

    def warn(self, message):
        """ Emit a dock layout warning with the given message.

        """
        f_globals = self._caller.f_globals
        f_lineno = self._caller.f_lineno
        f_mod = f_globals.get('__name__', '<string>')
        f_name = f_globals.get('__file__')
        if f_name:
            if f_name.lower().endswith((".pyc", ".pyo")):
                f_name = f_name[:-1]
        else:
            if f_mod == "__main__":
                f_name = sys.argv[0]
            if not f_name:
                f_name = f_mod
        warnings.warn_explicit(
            message, DockLayoutWarning, f_name, f_lineno, f_mod, f_globals
        )

    def setup(self, node):
        """ Setup the dock layout validator.

        """
        self._caller = sys._getframe(2)
        self._seen_items = set()
        self._cant_maximize = {}

    def teardown(self, node):
        """ Teardown the dock layout validator.

        """
        for name in self._available - self._seen_items:
            msg = "item '%s' is not referenced by the layout"
            self.warn(msg % name)
        for name in self._seen_items - self._available:
            msg = "item '%s' is not an available layout item"
            self.warn(msg % name)
        del self._caller
        del self._seen_items
        del self._cant_maximize

    def visit_ItemLayout(self, node):
        """ The visitor method for an ItemLayout node.

        """
        if node.name in self._seen_items:
            self.warn("duplicate use of ItemLayout name '%s'" % node.name)
        self._seen_items.add(node.name)
        if not node.floating:
            if -1 not in node.geometry:
                self.warn("non-floating ItemLayout with specific geometry")
            if node.linked:
                self.warn("non-floating ItemLayout marked as linked")
            if node.maximized and node in self._cant_maximize:
                msg = "ItemLayout contained in %s marked as maximized"
                self.warn(msg % self._cant_maximize[node])

    def visit_TabLayout(self, node):
        """ The visitor method for a TabLayout node.

        """
        for item in node.items:
            self._cant_maximize[item] = 'TabLayout'
            self.visit(item)

    def visit_SplitLayout(self, node):
        """ The visitor method for a SplitLayout node.

        """
        if len(node.sizes) > 0:
            if len(node.sizes) != len(node.items):
                self.warn("SplitLayout sizes length != items length")
        for item in node.items:
            if isinstance(item, SplitLayout):
                if item.orientation == node.orientation:
                    msg = "child SplitLayout has same orientation as parent"
                    self.warn(msg)
            self.visit(item)

    def visit_DockBarLayout(self, node):
        """ The visitor method for a DockBarLayout node.

        """
        for item in node.items:
            self._cant_maximize[item] = 'DockBarLayout'
            self.visit(item)

    def visit_AreaLayout(self, node):
        """ The visitor method for an AreaLayout node.

        """
        if not node.floating:
            if -1 not in node.geometry:
                self.warn("non-floating AreaLayout with specific geometry")
            if node.linked:
                self.warn("non-floating AreaLayout marked as linked")
            if node.maximized:
                self.warn("non-floating AreaLayout marked as maximized")
        if node.item is not None:
            self.visit(node.item)
        seen_positions = set()
        for bar in node.dock_bars:
            if bar.position in seen_positions:
                msg = "multiple DockBarLayout items in '%s' position"
                self.warn(msg % bar.position)
            seen_positions.add(bar.position)
            self.visit(bar)

    def visit_DockLayout(self, node):
        """ The visitor method for a DockLayout node.

        """
        has_non_floating_area = False
        for item in node.items:
            if isinstance(item, ItemLayout):
                if not item.floating:
                    self.warn("non-floating toplevel ItemLayout")
            else:  # must be an AreaLayout
                if not item.floating:
                    if has_non_floating_area:
                        self.warn("multiple non-floating AreaLayout items")
                    has_non_floating_area = True
            self.visit(item)


#------------------------------------------------------------------------------
# Dock Layout Operations
#------------------------------------------------------------------------------
class DockLayoutOp(Atom):
    """ A sentinel base class for defining dock layout operations.

    """
    pass


class InsertItem(DockLayoutOp):
    """ A layout operation which inserts an item into a layout.

    This operation will remove an item from the current layout and
    insert it next to a target item. If the item does not exist, the
    operation is a no-op.

    If the target -

    - is a normally docked item
        The item will be inserted as a new split item.

    - is docked in a tab group
        The item will be inserted as a neighbor of the tab group.

    - is docked in a dock bar
        The item will be appended to the dock bar.

    - is a floating dock item
        A new dock area will be created and the item will be inserted
        as a new split item.

    - does not exist
        The item is inserted into the border of the primary dock area.

    """
    #: The name of the dock item to insert into the layout.
    item = Unicode()

    #: The name of the dock item to use as the target location.
    target = Unicode()

    #: The position relative to the target at which to insert the item.
    position = Enum('left', 'top', 'right', 'bottom')


class InsertBorderItem(DockLayoutOp):
    """ A layout operation which inserts an item into an area border.

    This operation will remove an item from the current layout and
    insert it into the border of a dock area. If the item does not
    exist, the operation is a no-op.

    If the target -

    - is a normally docked item
        The item is inserted into the border of the dock area containing
        the target.

    - is docked in a tab group
        The item is inserted into the border of the dock area containing
        the tab group.

    - is docked in a dock bar
        The item is inserted into the border of the dock area containing
        the dock bar.

    - is a floating dock item
        A new dock area will be created and the item will be inserted
        into the border of the new dock area.

    - does not exist
        The item is inserted into the border of the primary dock area.

    """
    #: The name of the dock item to insert into the layout.
    item = Unicode()

    #: The name of the dock item to use as the target location.
    target = Unicode()

    #: The border position at which to insert the item.
    position = Enum('left', 'top', 'right', 'bottom')


class InsertDockBarItem(DockLayoutOp):
    """ A layout operation which inserts an item into a dock bar.

    This operation will remove an item from the current layout and
    insert it into a dock bar in a dock area. If the item does not
    exist, the operation is a no-op.

    If the target -

    - is a normally docked item
        The item is inserted into the dock bar of the dock area
        containing the target.

    - is docked in a tab group
        The item is inserted into the dock bar of the dock area
        containing the tab group.

    - is docked in a dock bar
        The item is inserted into the dock bar of the dock area
        containing the dock bar.

    - is a floating dock item
        A new dock area will be created and the item will be inserted
        into the dock bar of the new dock area.

    - does not exist
        The item is inserted into the dock bar of the primary dock
        area.

    """
    #: The name of the dock item to insert into the layout.
    item = Unicode()

    #: The name of the dock item to use as the target location.
    target = Unicode()

    #: The dock bar position at which to insert the item.
    position = Enum('right', 'left', 'bottom', 'top')

    #: The index at which to insert the dock bar item.
    index = Int(-1)


class InsertTab(DockLayoutOp):
    """ A layout operation which inserts a tab into a tab group.

    This operation will remove an item from the current layout and
    insert it into a tab group in a dock area. If the item does not
    exist, the operation is a no-op.

    If the target -

    - is a normally docked item
        The target and item will be merged into a new tab group
        using the default tab position.

    - is docked in a tab group
        The item will be inserted into the tab group.

    - is docked in a dock bar
        The item will be appended to the dock bar.

    - is a floating dock item
        A new dock area will be created and the target and item will
        be merged into a new tab group.

    - does not exist
        The item is inserted into the left border of the primary dock
        area.

    """
    #: The name of the dock item to insert into the tab group.
    item = Unicode()

    #: The name of an existing dock item in the tab group of interest.
    target = Unicode()

    #: The index at which to insert the dock item.
    index = Int(-1)

    #: The position of the tabs for a newly created tab group.
    tab_position = Enum('default', 'top', 'bottom', 'left', 'right')


class FloatItem(DockLayoutOp):
    """ A layout operation which creates a floating dock item.

    This operation will remove an item from the current layout and
    insert convert it into a floating item. If the item does not
    exist, the operation is a no-op.

    """
    #: The item layout to use when configuring the floating item.
    item = Coerced(ItemLayout)


class FloatArea(DockLayoutOp):
    """ A layout operation which creates a new floating dock area.

    This layout operation will create a new floating dock area using
    the given area layout specification.

    """
    #: The area layout to use when building the new dock area.
    area = Coerced(AreaLayout)


class RemoveItem(DockLayoutOp):
    """ A layout operation which will remove an item from the layout.

    This layout operation will remove the dock item from the layout
    and hide it. It can be added back to layout later with one of the
    other layout operations.

    """
    #: The name of the dock item to remove from the layout.
    item = Unicode()


class ExtendItem(DockLayoutOp):
    """ A layout operation which extends an item in a dock bar.

    This layout operation will cause the named item to be extended to
    from its dock bar. If the item does not exist in a dock bar, this
    operation is a no-op.

    """
    #: The name of the dock item to extend from its dock bar.
    item = Unicode()


class RetractItem(DockLayoutOp):
    """ A layout operation which retracts an item into a dock bar.

    This layout operation will cause the named item to be retracted
    into its dock bar. If the item does not exist in a dock bar, this
    operation is a no-op.

    """
    #: The name of the dock item to retract into its dock bar.
    item = Unicode()

########NEW FILE########
__FILENAME__ = factory_helper
#------------------------------------------------------------------------------
# Copyright (c) 2014, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Callable, Tuple, Dict

from .constraint_helper import ConstraintHelper


class FactoryHelper(ConstraintHelper):
    """ A constraint helper which delegates to a factory callable.

    """
    #: The callable object which will generate the list of constraints.
    #: It will be passed the constraints widget owner as the first
    #: argument, and should return the list of generated constraints.
    factory = Callable()

    #: Additional positional arguments to pass to the callable.
    args = Tuple()

    #: Additional keyword arguments to pass to the callable.
    kwargs = Dict()

    def __init__(self, factory, *args, **kwargs):
        """ Initialize a FactoryHelper.

        Parameters
        ----------
        factory : callable
            The callable object which generates the constraints.

        *args
            Additional positional arguments to pass to the factory.

        **kwargs
            Additional keyword arguments to pass to the factory.

        """
        self.factory = factory
        self.args = args
        self.kwargs = kwargs

    def constraints(self, component):
        """ Generate the constraints using the underlying factory.

        This method will automatically expand ConstraintHelper objects
        which are generated by the factory.

        """
        factory = self.factory
        if factory is None:
            return []
        cns = []  # inline `expand_constraints`
        for cn in factory(component, *self.args, **self.kwargs):
            if isinstance(cn, ConstraintHelper):
                cns.extend(cn.create_constraints(component))
            elif cn is not None:
                cns.append(cn)
        return cns

########NEW FILE########
__FILENAME__ = geometry
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Rect
#------------------------------------------------------------------------------
class BaseRect(tuple):
    """ A tuple subclass representing an (x, y, width, height)
    bounding box. Subclasses should override the __new__ method
    to enforce any necessary typing.

    """
    __slots__ = ()

    @staticmethod
    def coerce_type(item):
        return item

    def __new__(cls, x=None, y=None, width=None, height=None):
        if isinstance(x, (tuple, BaseRect)):
            return cls(*x)
        c = cls.coerce_type
        x = c(x)
        if y is None:
            y = x
        else:
            y = c(y)
        width = c(width)
        if height is None:
            height = width
        else:
            height = c(height)
        return super(BaseRect, cls).__new__(cls, (x, y, width, height))

    def __getnewargs__(self):
        return tuple(self)

    def __repr__(self):
        template = '%s(x=%s, y=%s, width=%s, height=%s)'
        values = (self.__class__.__name__,) + self
        return template % values

    @property
    def x(self):
        """ The 'x' position component of the rect.

        """
        return self[0]

    @property
    def y(self):
        """ The 'y' position component of the rect.

        """
        return self[1]

    @property
    def width(self):
        """ The 'width' size component of the rect.

        """
        return self[2]

    @property
    def height(self):
        """ The 'height' size component of the rect.

        """
        return self[3]


class Rect(BaseRect):
    """ A BaseRect implementation for integer values.

    """
    __slots__ = ()

    @staticmethod
    def coerce_type(item):
        return 0 if item is None else int(item)

    @property
    def box(self):
        """ The equivalent Box for this rect.

        """
        x, y, width, height = self
        return Box(y, x + width, y + height, x)

    @property
    def pos(self):
        """ The position of the rect as a Pos object.

        """
        return Pos(self.x, self.y)

    @property
    def size(self):
        """ The size of the rect as a Size object.

        """
        return Size(self.width, self.height)


class RectF(BaseRect):
    """ A BaseRect implementation for floating point values.

    """
    __slots__ = ()

    @staticmethod
    def coerce_type(item):
        return 0.0 if item is None else float(item)

    @property
    def box(self):
        """ The equivalent Box for this rect.

        """
        x, y, width, height = self
        return BoxF(y, x + width, y + height, x)

    @property
    def pos(self):
        """ The position of the rect as a Pos object.

        """
        return PosF(self.x, self.y)

    @property
    def size(self):
        """ The size of the rect as a Size object.

        """
        return SizeF(self.width, self.height)


#------------------------------------------------------------------------------
# Box
#------------------------------------------------------------------------------
class BaseBox(tuple):
    """ A tuple subclass representing a (top, right, bottom, left) box.
    Subclasses should override the __new__ method to enforce any typing.

    """
    __slots__ = ()

    @staticmethod
    def coerce_type(item):
        return item

    def __new__(cls, top=None, right=None, bottom=None, left=None):
        if isinstance(top, (tuple, BaseBox)):
            return cls(*top)
        c = cls.coerce_type
        top = c(top)
        if right is None:
            right = top
        else:
            right = c(right)
        if bottom is None:
            bottom = top
        else:
            bottom = c(bottom)
        if left is None:
            left = right
        else:
            left = c(left)
        return super(BaseBox, cls).__new__(cls, (top, right, bottom, left))

    def __getnewargs__(self):
        return tuple(self)

    def __repr__(self):
        template = '%s(top=%s, right=%s, bottom=%s, left=%s)'
        values = (self.__class__.__name__,) + self
        return template % values

    @property
    def top(self):
        """ The 'top' component of the box.

        """
        return self[0]

    @property
    def right(self):
        """ The 'right' component of the box.

        """
        return self[1]

    @property
    def bottom(self):
        """ The 'bottom' component of the box.

        """
        return self[2]

    @property
    def left(self):
        """ The 'left' component of the box.

        """
        return self[3]


class Box(BaseBox):
    """ A BaseBox implementation for integer values.

    """
    __slots__ = ()

    @staticmethod
    def coerce_type(item):
        return 0 if item is None else int(item)

    @property
    def rect(self):
        """ The equivalent Rect for this box.

        """
        top, right, bottom, left = self
        return Rect(left, top, right - left, bottom - top)

    @property
    def size(self):
        """ The Size of this box.

        """
        top, right, bottom, left = self
        return Size(right - left, bottom - top)

    @property
    def pos(self):
        """ The Pos of this box.

        """
        return Pos(self.left, self.top)


class BoxF(BaseBox):
    """ A BaseBox implementation for floating point values.

    """
    __slots__ = ()

    @staticmethod
    def coerce_type(item):
        return 0.0 if item is None else float(item)

    @property
    def rect(self):
        """ The equivalent Rect for this box.

        """
        top, right, bottom, left = self
        return RectF(left, top, right - left, bottom - top)

    @property
    def size(self):
        """ The Size of this box.

        """
        top, right, bottom, left = self
        return SizeF(right - left, bottom - top)

    @property
    def pos(self):
        """ The Pos of this box.

        """
        return PosF(self.left, self.top)


#------------------------------------------------------------------------------
# Pos
#------------------------------------------------------------------------------
class BasePos(tuple):
    """ A tuple subclass representing a (x, y) positions. Subclasses
    should override the __new__ method to enforce any necessary typing.

    """
    __slots__ = ()

    @staticmethod
    def coerce_type(item):
        return item

    def __new__(cls, x=None, y=None):
        if isinstance(x, (tuple, BasePos)):
            return cls(*x)
        c = cls.coerce_type
        x = c(x)
        if y is None:
            y = x
        else:
            y = c(y)
        return super(BasePos, cls).__new__(cls, (x, y))

    def __getnewargs__(self):
        return tuple(self)

    def __repr__(self):
        template = '%s(x=%s, y=%s)'
        values = (self.__class__.__name__,) + self
        return template % values

    @property
    def x(self):
        """ The 'x' component of the position.

        """
        return self[0]

    @property
    def y(self):
        """ The 'y' component of the position.

        """
        return self[1]


class Pos(BasePos):
    """ An implementation of BasePos for integer values.

    """
    __slots__ = ()

    @staticmethod
    def coerce_type(item):
        return 0 if item is None else int(item)


class PosF(BasePos):
    """ An implementation of BasePos of floating point values.

    """
    __slots__ = ()

    @staticmethod
    def coerce_type(item):
        return 0.0 if item is None else float(item)


#------------------------------------------------------------------------------
# Size
#------------------------------------------------------------------------------
class BaseSize(tuple):
    """ A tuple subclass representing a (width, height) size. Subclasses
    should override the __new__ method to enforce any necessary typing.

    """
    __slots__ = ()

    @staticmethod
    def coerce_type(item):
        return item

    def __new__(cls, width=None, height=None):
        if isinstance(width, (tuple, BaseSize)):
            return cls(*width)
        c = cls.coerce_type
        width = c(width)
        if height is None:
            height = width
        else:
            height = c(height)
        return super(BaseSize, cls).__new__(cls, (width, height))

    def __getnewargs__(self):
        return tuple(self)

    def __repr__(self):
        template = '%s(width=%s, height=%s)'
        values = (self.__class__.__name__,) + self
        return template % values

    @property
    def width(self):
        """ The 'width' component of the size.

        """
        return self[0]

    @property
    def height(self):
        """ The 'height' component of the size.

        """
        return self[1]


class Size(BaseSize):
    """ A BaseSize implementation for integer values.

    """
    __slots__ = ()

    @staticmethod
    def coerce_type(item):
        return 0 if item is None else int(item)


class SizeF(BaseSize):
    """ A BaseSize implementation for floating point values.

    """
    __slots__ = ()

    @staticmethod
    def coerce_type(item):
        return 0.0 if item is None else float(item)

########NEW FILE########
__FILENAME__ = grid_helper
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from collections import defaultdict

from atom.api import Atom, Coerced, Int, Range, Str, Tuple, Value

import kiwisolver as kiwi

from .box_helper import BoxHelper
from .constrainable import Constrainable
from .constraint_helper import ConstraintHelper
from .geometry import Box
from .spacers import EqSpacer, FlexSpacer
from .sequence_helper import SequenceHelper


class GridHelper(BoxHelper):
    """ A box helper for creating a traditional grid layout.

    A grid helper is constrainable and can be nested in other grid
    and box helpers to build up complex layouts.

    """
    #: The tuple of row items for the grid.
    rows = Tuple()

    #: The name of constraint variable to align items in a row.
    row_align = Str()

    #: The spacing between consecutive rows in the grid.
    row_spacing = Range(low=0)

    #: The name of constraint variable to align items in a column.
    column_align = Str()

    #: The spacing between consecutive columns in the grid.
    column_spacing = Range(low=0)

    #: The margins to add around boundary of the grid.
    margins = Coerced(Box)

    class _Cell(Atom):
        """ A private class used by a GridHelper to track item cells.

        """
        #: The item contained in the cell.
        item = Value()

        #: The starting row of the cell, inclusive.
        start_row = Int()

        #: The starting column of the cell, inclusive.
        start_column = Int()

        #: The ending row of the cell, inclusive.
        end_row = Int()

        #: The ending column of the cell, inclusive.
        end_column = Int()

        def __init__(self, item, row, column):
            """ Initialize a Cell.

            Parameters
            ----------
            item : object
                The item contained in the cell.

            row : int
                The row index of the cell.

            column : int
                The column index of the cell.

            """
            self.item = item
            self.start_row = row
            self.start_column = column
            self.end_row = row
            self.end_column = column

        def expand_to(self, row, column):
            """ Expand the cell to enclose the given row and column.

            """
            self.start_row = min(row, self.start_row)
            self.end_row = max(row, self.end_row)
            self.start_column = min(column, self.start_column)
            self.end_column = max(column, self.end_column)

    def __init__(self, rows, **config):
        """ Initialize a GridHelper.

        Parameters
        ----------
        rows: iterable of iterable
            The rows to layout in the grid. A row must be composed of
            constrainable objects and None. An item will be expanded
            to span all of the cells in which it appears.

        **config
            Configuration options for how this helper should behave.
            The following options are currently supported:

            row_align
                A string which is the name of a constraint variable on
                an item. If given, it is used to add constraints on the
                alignment of items in a row. The constraints will only
                be applied to items that do not span rows.

            row_spacing
                An integer >= 0 which indicates how many pixels of
                space should be placed between rows in the grid. The
                default value is 10 pixels.

            column_align
                A string which is the name of a constraint variable on
                a item. If given, it is used to add constraints on the
                alignment of items in a column. The constraints will
                only be applied to items that do not span columns.

            column_spacing
                An integer >= 0 which indicates how many pixels of
                space should be placed between columns in the grid.
                The default is the value is 10 pixels.

            margins
                A int, tuple of ints, or Box of ints >= 0 which
                indicate how many pixels of margin to add around
                the bounds of the grid. The default value is 0
                pixels on all sides.

        """
        self.rows = self.validate(rows)
        self.row_align = config.get('row_align', '')
        self.column_align = config.get('col_align', '')  # backwards compat
        self.column_align = config.get('column_align', '')
        self.row_spacing = config.get('row_spacing', 10)
        self.column_spacing = config.get('column_spacing', 10)
        self.margins = config.get('margins', 0)

    @staticmethod
    def validate(rows):
        """ Validate the rows for the grid helper.

        This method asserts that the rows are composed entirely of
        Constrainable objects and None.

        Parameters
        ----------
        rows : iterable of iterable
            The iterable of row items to validate.

        Returns
        -------
        result : tuple of tuple
            The tuple of validated rows.

        """
        valid_rows = []
        for row in rows:
            for item in row:
                if item is not None and not isinstance(item, Constrainable):
                    msg = 'Grid items must be Constrainable or None. '
                    msg += 'Got %r instead.'
                    raise TypeError(msg % item)
            valid_rows.append(tuple(row))
        return tuple(valid_rows)

    def constraints(self, component):
        """ Generate the grid constraints for the given component.

        Parameters
        ----------
        component : Constrainable or None
            The constrainable object which represents the conceptual
            owner of the generated constraints.

        Returns
        -------
        result : list
            The list of Constraint objects for the given component.

        """
        # Create the outer boundary box constraints.
        cns = self.box_constraints(component)

        # Compute the cell spans for the items in the grid.
        cells = []
        cell_map = {}
        num_cols = 0
        num_rows = len(self.rows)
        for row_idx, row in enumerate(self.rows):
            num_cols = max(num_cols, len(row))
            for col_idx, item in enumerate(row):
                if item is None:
                    continue
                elif item in cell_map:
                    cell_map[item].expand_to(row_idx, col_idx)
                else:
                    cell = self._Cell(item, row_idx, col_idx)
                    cell_map[item] = cell
                    cells.append(cell)

        # Create the row and column variables and their default limits.
        row_vars = []
        col_vars = []
        for idx in xrange(num_rows + 1):
            var = kiwi.Variable('row%d' % idx)
            row_vars.append(var)
            cns.append(var >= 0)
        for idx in xrange(num_cols + 1):
            var = kiwi.Variable('col%d' % idx)
            col_vars.append(var)
            cns.append(var >= 0)

        # Add the neighbor constraints for the row and column vars.
        for r1, r2 in zip(row_vars[:-1], row_vars[1:]):
            cns.append(r1 <= r2)
        for c1, c2 in zip(col_vars[:-1], col_vars[1:]):
            cns.append(c1 <= c2)

        # Setup the initial interior bounding box for the grid.
        firsts = (self.top, col_vars[-1], row_vars[-1], self.left)
        seconds = (row_vars[0], self.right, self.bottom, col_vars[0])
        for size, first, second in zip(self.margins, firsts, seconds):
            cns.extend(EqSpacer(size).create_constraints(first, second))

        # Setup the spacer lists for constraining the cell items
        row_spacer = FlexSpacer(self.row_spacing / 2)  # floor division
        col_spacer = FlexSpacer(self.column_spacing / 2)
        rspace = [row_spacer] * len(row_vars)
        cspace = [col_spacer] * len(col_vars)
        rspace[0] = rspace[-1] = cspace[0] = cspace[-1] = 0

        # Create the helpers for each constrainable grid cell item. The
        # helper validation is bypassed since the items are known-valid.
        helpers = []
        for cell in cells:
            sr = cell.start_row
            er = cell.end_row + 1
            sc = cell.start_column
            ec = cell.end_column + 1
            item = cell.item
            ritems = (row_vars[sr], rspace[sr], item, rspace[er], row_vars[er])
            citems = (col_vars[sc], cspace[sc], item, cspace[ec], col_vars[ec])
            rhelper = SequenceHelper('bottom', 'top', ())
            chelper = SequenceHelper('right', 'left', ())
            rhelper.items = ritems
            chelper.items = citems
            helpers.extend((rhelper, chelper))
            if isinstance(item, ConstraintHelper):
                helpers.append(item)

        # Add the row alignment helpers if needed. This will only create
        # the helpers for items which do not span multiple rows.
        anchor = self.row_align
        if anchor:
            row_map = defaultdict(list)
            for cell in cells:
                if cell.start_row == cell.end_row:
                    row_map[cell.start_row].append(cell.item)
            for items in row_map.itervalues():
                if len(items) > 1:
                    helper = SequenceHelper(anchor, anchor, (), 0)
                    helper.items = tuple(items)
                    helpers.append(helper)

        # Add the column alignment helpers if needed. This will only
        # create the helpers for items which do not span multiple rows.
        anchor = self.column_align
        if anchor:
            col_map = defaultdict(list)
            for cell in cells:
                if cell.start_column == cell.end_column:
                    col_map[cell.start_column].append(cell.item)
            for items in col_map.itervalues():
                if len(items) > 1:
                    helper = SequenceHelper(anchor, anchor, (), 0)
                    helper.items = tuple(items)
                    helpers.append(helper)

        # Generate the constraints from the helpers.
        for helper in helpers:
            cns.extend(helper.create_constraints(None))

        return cns

########NEW FILE########
__FILENAME__ = layout_helpers
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from .constraint_helper import ConstraintHelper
from .factory_helper import FactoryHelper
from .grid_helper import GridHelper
from .linear_box_helper import LinearBoxHelper
from .sequence_helper import SequenceHelper
from .spacers import LayoutSpacer


spacer = LayoutSpacer(10)


def horizontal(*items, **config):
    """ Create a left-to-right SequenceHelper object.

    Parameters
    ----------
    *items
        The constraint items to pass to the helper.

    **config
        Additional keyword arguments to pass to the helper.

    """
    return SequenceHelper('right', 'left', items, **config)


def vertical(*items, **config):
    """ Create a top-to-bottom SequenceHelper object.

    Parameters
    ----------
    *items
        The constraint items to pass to the helper.

    **config
        Additional keyword arguments to pass to the helper.

    """
    return SequenceHelper('bottom', 'top', items, **config)


def hbox(*items, **config):
    """ Create a horizontal LinearBoxHelper object.

    Parameters
    ----------
    *items
        The constraint items to pass to the helper.

    **config
        Additional keyword arguments to pass to the helper.

    """
    return LinearBoxHelper('horizontal', items, **config)


def vbox(*items, **config):
    """ Create a vertical LinearBoxHelper object.

    Parameters
    ----------
    *items
        The constraint items to pass to the helper.

    **config
        Additional keyword arguments to pass to the helper.

    """
    return LinearBoxHelper('vertical', items, **config)


def align(anchor, *items, **config):
    """ Create a SequenceHelper with the given anchor object.

    Parameters
    ----------
    anchor : str
        The name of the target anchor on the constrainable object.

    *items
        The constraint items to pass to the helper.

    **config
        Additional keyword arguments to pass to the helper.

    """
    config.setdefault('spacing', 0)
    return SequenceHelper(anchor, anchor, items, **config)


def factory(func, *args, **kwargs):
    """ Create a FactoryHelper with the given factory function.

    Parameters
    ----------
    func : callable
        The callable which will generate the list of constraints.
        The owner widget will be passed as the first argument.

    *args
        Additional positional arguments to pass to the factory.

    **kwargs
        Additional keyword arguments to pass to the factory.

    """
    return FactoryHelper(func, *args, **kwargs)


def grid(*rows, **config):
    """ Create a GridHelper object with the given rows.

    Parameters
    ----------
    *rows


    **config
        Additional keyword arguments to pass to the helper.

    """
    return GridHelper(rows, **config)


def expand_constraints(component, constraints):
    """ A function which expands any ConstraintHelper in the list.

    Parameters
    ----------
    component : Constrainable
        The constrainable component with which the constraints are
        associated. This will be passed to the .create_constraints()
        method of any ConstraintHelper instance.

    constraints : list
        The list of constraints to expand.

    Returns
    -------
    result : list
        The list of expanded constraints.

    """
    cns = []
    for cn in constraints:
        if isinstance(cn, ConstraintHelper):
            cns.extend(cn.create_constraints(component))
        elif cn is not None:
            cns.append(cn)
    return cns

########NEW FILE########
__FILENAME__ = layout_manager
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from contextlib import contextmanager

from atom.api import Atom, List, Typed

import kiwisolver as kiwi

from .layout_helpers import expand_constraints


class LayoutItem(Atom):
    """ A base class used for creating layout items.

    This class is intended to be subclassed by a toolkit backend to
    implement the necessary toolkit specific layout functionality.

    """
    #: The list of cached geometry constraints. This is used for storage
    #: by the layout manager.
    _geometry_cache = List()

    #: The list of cached margin constraints. This is used for storage
    #: by the layout manager.
    _margin_cache = List()

    def __call__(self):
        """ Update the geometry of the underlying toolkit widget.

        This should not be called directly by user code.

        """
        d = self.constrainable()
        x = d.left.value()
        y = d.top.value()
        w = d.width.value()
        h = d.height.value()
        self.set_geometry(x, y, w, h)

    def hard_constraints(self):
        """ Generate a list of hard constraints for the item.

        Returns
        -------
        result : list
            A list of hard constraints for the item.

        """
        d = self.constrainable()
        return [d.left >= 0, d.top >= 0, d.width >= 0, d.height >= 0]

    def margin_constraints(self):
        """ Generate a list of margin constraints for the item.

        Returns
        -------
        result : list
            A list of margin constraints for the item. The list will
            be empty if the item does not support margins.

        """
        margins = self.margins()
        if not margins:
            return []
        top, right, bottom, left = margins
        d = self.constrainable()
        c_t = d.contents_top == (d.top + top)
        c_r = d.contents_right == (d.right - right)
        c_b = d.contents_bottom == (d.bottom - bottom)
        c_l = d.contents_left == (d.left + left)
        return [c_t, c_r, c_b, c_l]

    def geometry_constraints(self):
        """ Generate a list of geometry constraints for the item.

        Returns
        -------
        result : list
            A list of geometry constraints for the item.

        """
        cns = []
        d = self.constrainable()

        width_hint, height_hint = self.size_hint()
        if width_hint >= 0:
            if d.hug_width != 'ignore':
                cns.append((d.width == width_hint) | d.hug_width)
            if d.resist_width != 'ignore':
                cns.append((d.width >= width_hint) | d.resist_width)
            if d.limit_width != 'ignore':
                cns.append((d.width <= width_hint) | d.limit_width)
        if height_hint >= 0:
            if d.hug_height != 'ignore':
                cns.append((d.height == height_hint) | d.hug_height)
            if d.resist_height != 'ignore':
                cns.append((d.height >= height_hint) | d.resist_height)
            if d.limit_height != 'ignore':
                cns.append((d.height <= height_hint) | d.limit_height)

        strength = 0.1 * kiwi.strength.strong

        min_width, min_height = self.min_size()
        if min_width >= 0:
            cns.append((d.width >= min_width) | strength)
        if min_height >= 0:
            cns.append((d.height >= min_height) | strength)

        max_width, max_height = self.max_size()
        if max_width >= 0:
            cns.append((d.width <= max_width) | strength)
        if max_height >= 0:
            cns.append((d.height <= max_height) | strength)

        return cns

    def layout_constraints(self):
        """ Get the list of layout constraints for the item.

        Returns
        -------
        result : list
            The list of layout constraints for the item.

        """
        return expand_constraints(self.constrainable(), self.constraints())

    def constrainable(self):
        """ Get a reference to the underlying constrainable object.

        This abstract method must be implemented by subclasses.

        Returns
        -------
        result : Contrainable or ContentsContrainable
            An object which implements the Constrainable interface.
            If the 'margins' method returns a non-empty tuple, then
            the object must also implement the ContentsConstrainable
            interface.

        """
        raise NotImplementedError

    def constraints(self):
        """ Get the user-defined constraints for the item.

        This abstract method must be implemented by subclasses.

        Returns
        -------
        result : list
            The list of user-defined constraints and constraint helpers.

        """
        raise NotImplementedError

    def margins(self):
        """ Get the margins for the underlying widget.

        This abstract method must be implemented by subclasses.

        Returns
        -------
        result : tuple
            A 4-tuple of numbers representing the margins of the widget
            in the order (top, right, bottom, left). If the widget does
            not support margins, an empty tuple should be returned.

        """
        raise NotImplementedError

    def size_hint(self):
        """ Get the size hint for the underlying widget.

        This abstract method must be implemented by subclasses.

        Returns
        -------
        result : tuple
            A 2-tuple of numbers representing the (width, height)
            size hint of the widget.

        """
        raise NotImplementedError

    def min_size(self):
        """ Get the minimum size for the underlying widget.

        This abstract method must be implemented by subclasses.

        Returns
        -------
        result : tuple
            A 2-tuple of numbers representing the (width, height)
            min size of the widget. If any value is less than zero,
            constraints will not be generated for that dimension.

        """
        raise NotImplementedError

    def max_size(self):
        """ Get the maximum size for the underlying widget.

        This abstract method must be implemented by subclasses.

        Returns
        -------
        result : tuple
            A 2-tuple of numbers representing the (width, height)
            max size of the widget. If any value is less than zero,
            constraints will not be generated for that dimension.

        """
        raise NotImplementedError

    def set_geometry(self, x, y, width, height):
        """ Set the geometry of the underlying widget.

        This abstract method must be implemented by subclasses.

        Parameters
        ----------
        x : float
            The new value for the x-origin of the widget.

        y : float
            The new value for the y-origin of the widget.

        width : float
            The new value for the width of the widget.

        height : float
            The new value for the height of the widget.

        """
        raise NotImplementedError


class LayoutManager(Atom):
    """ A class which manages the layout for a system of items.

    This class is used by the various in-process backends to simplify
    the task of implementing constraint layout management.

    """
    #: The primary layout item which owns the layout.
    _root_item = Typed(LayoutItem)

    #: The solver used by the layout manager.
    _solver = Typed(kiwi.Solver, ())

    #: The stack of edit variables added to the solver.
    _edit_stack = List()

    #: The list of layout items handled by the manager.
    _layout_items = List()

    def __init__(self, item):
        """ Initialize a LayoutManager.

        Parameters
        ----------
        item : LayoutItem
            The layout item which contains the widget which is the
            root of the layout system. This item is the conceptual
            owner of the system. It is not resized by the manager,
            rather the size of this item is used as input to the
            manager via the 'resize' method.

        """
        self._root_item = item

    def set_items(self, items):
        """ Set the layout items for this layout manager.

        This method will reset the internal solver state and build a
        new system of constraints using the new list of items.

        Parameters
        ----------
        items : list
            A list of LayoutItem instances for the system. The root
            item should *not* be included in this list.

        """
        # Reset the state of the solver.
        del self._edit_stack
        del self._layout_items
        solver = self._solver
        solver.reset()

        # Setup the standard edit variables.
        root = self._root_item
        d = root.constrainable()
        strength = kiwi.strength.medium
        pairs = ((d.width, strength), (d.height, strength))
        self._push_edit_vars(pairs)

        # Generate the constraints for the layout system. The size hint
        # and bounds of the root item are ignored since the input to the
        # solver is the suggested size of the root item and the output
        # of the solver is used to compute the bounds of the item.
        cns = []
        hc = root.hard_constraints()
        mc = root.margin_constraints()
        lc = root.layout_constraints()
        root._margin_cache = mc
        cns.extend(hc)
        cns.extend(mc)
        cns.extend(lc)
        for child in items:
            hc = child.hard_constraints()
            gc = child.geometry_constraints()
            mc = child.margin_constraints()
            lc = child.layout_constraints()
            child._geometry_cache = gc
            child._margin_cache = mc
            cns.extend(hc)
            cns.extend(gc)
            cns.extend(mc)
            cns.extend(lc)

        # Add the new constraints to the solver.
        for cn in cns:
            solver.addConstraint(cn)

        # Store the layout items for resize updates.
        self._layout_items = items

    def clear_items(self):
        """ Clear the child layout items in the layout.

        """
        del self._layout_items

    def resize(self, width, height):
        """ Update the size of target size of the layout.

        This method will update the solver and make a pass over
        the layout table to update the item layout geometries.

        Parameters
        ----------
        width : number
            The desired width of the layout owner.

        height : number
            The desired height of the layout owner.

        """
        solver = self._solver
        d = self._root_item.constrainable()
        solver.suggestValue(d.width, width)
        solver.suggestValue(d.height, height)
        solver.updateVariables()
        for item in self._layout_items:
            item()

    def best_size(self):
        """ Get the best size for the layout owner.

        The best size is computed by invoking the solver with a zero
        size suggestion at a strength of 0.1 * weak. The resulting
        values for width and height are taken as the best size.

        Returns
        -------
        result : tuple
            The 2-tuple of (width, height) best size values.

        """
        d = self._root_item.constrainable()
        width = d.width
        height = d.height
        solver = self._solver
        strength = 0.1 * kiwi.strength.weak
        pairs = ((width, strength), (height, strength))
        with self._edit_context(pairs):
            solver.suggestValue(width, 0.0)
            solver.suggestValue(height, 0.0)
            solver.updateVariables()
            result = (width.value(), height.value())
        return result

    def min_size(self):
        """ Compute the minimum size for the layout owner.

        The minimum size is computed by invoking the solver with a
        zero size suggestion at a strength of medium. The resulting
        values for width and height are taken as the minimum size.

        Returns
        -------
        result : tuple
            The 2-tuple of (width, height) min size values.

        """
        d = self._root_item.constrainable()
        width = d.width
        height = d.height
        solver = self._solver
        solver.suggestValue(width, 0.0)
        solver.suggestValue(height, 0.0)
        solver.updateVariables()
        return (width.value(), height.value())

    def max_size(self):
        """ Compute the maximum size for the container.

        The maximum size is computed by invoking the solver with a
        max size suggestion at a strength of medium. The resulting
        values for width and height are taken as the maximum size.

        Returns
        -------
        result : tuple
            The 2-tuple of (width, height) max size values.

        """
        d = self._root_item.constrainable()
        width = d.width
        height = d.height
        solver = self._solver
        solver.suggestValue(width, 16777215.0)  # max allowed by Qt
        solver.suggestValue(height, 16777215.0)
        solver.updateVariables()
        return (width.value(), height.value())

    def update_geometry(self, index):
        """ Update the geometry for the given layout item.

        The solver will be updated to reflect the item's new geometry.
        This may change the computed min/max/best size of the system.

        Parameters
        ----------
        index : int
            The index of the item in the list of layout items which
            was provided in the call to 'set_items'.

        """
        item = self._layout_items[index]
        old = item._geometry_cache
        new = item.geometry_constraints()
        item._geometry_cache = new
        self._replace(old, new)

    def update_margins(self, index):
        """ Update the margins for the given layout item.

        The solver will be updated to reflect the item's new margins.
        This may change the computed min/max/best size of the system.

        Parameters
        ----------
        index : int
            The index of the item in the list of layout items which
            was provided in the call to 'set_items'. A value of -1
            can be given to indicate the root item.

        """
        item = self._root_item if index < 0 else self._layout_items[index]
        old = item._margin_cache
        new = item.margin_constraints()
        item._margin_cache = new
        self._replace(old, new)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _replace(self, old, new):
        """ Replace constraints in the solver.

        Parameters
        ----------
        old : list
            The list of constraints to remove from the solver.

        new : list
            The list of constraints to add to the solver.

        """
        solver = self._solver
        for cn in old:
            solver.removeConstraint(cn)
        for cn in new:
            solver.addConstraint(cn)

    def _push_edit_vars(self, pairs):
        """ Push edit variables into the solver.

        The current edit variables will be removed and the new edit
        variables will be added.

        Parameters
        ----------
        pairs : sequence
            A sequence of 2-tuples of (var, strength) which should be
            added as edit variables to the solver.

        """
        solver = self._solver
        stack = self._edit_stack
        if stack:
            for v, strength in stack[-1]:
                solver.removeEditVariable(v)
        stack.append(pairs)
        for v, strength in pairs:
            solver.addEditVariable(v, strength)

    def _pop_edit_vars(self):
        """ Restore the previous edit variables in the solver.

        The current edit variables will be removed and the previous
        edit variables will be re-added.

        """
        solver = self._solver
        stack = self._edit_stack
        for v, strength in stack.pop():
            solver.removeEditVariable(v)
        if stack:
            for v, strength in stack[-1]:
                solver.addEditVariable(v, strength)

    @contextmanager
    def _edit_context(self, pairs):
        """ A context manager for temporary solver edits.

        This manager will push the edit vars into the solver and pop
        them when the context exits.

        Parameters
        ----------
        pairs : list
            A list of 2-tuple of (var, strength) which should be added
            as temporary edit variables to the solver.

        """
        self._push_edit_vars(pairs)
        yield
        self._pop_edit_vars()

########NEW FILE########
__FILENAME__ = linear_box_helper
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Coerced, Enum, Range, Tuple

from .box_helper import BoxHelper
from .constrainable import Constrainable
from .constraint_helper import ConstraintHelper
from .geometry import Box
from .linear_symbolic import LinearSymbolic
from .sequence_helper import SequenceHelper
from .spacers import Spacer, EqSpacer, FlexSpacer


ORIENT_MAP = {
    'horizontal': ('left', 'right'),
    'vertical': ('top', 'bottom'),
}


ORTHO_MAP = {
    'horizontal': 'vertical',
    'vertical': 'horizontal',
}


class LinearBoxHelper(BoxHelper):
    """ A box helper for creating traditional linear box layouts.

    """
    #: The layout orientation of the items in the box.
    orientation = Enum('vertical', 'horizontal')

    #: The tuple of items which will be used to generate the constraints.
    items = Tuple()

    #: The spacing to use between items if not explicitly provided.
    spacing = Range(low=0)

    #: The margins to use around the edges of the box.
    margins = Coerced(Box)

    def __init__(self, orientation, items, spacing=10, margins=0):
        """ Initialize a LinearBoxHelper.

        Parameters
        ----------
        orientation : str
            The orientation of the layout box, either 'horizontal'
            or 'vertical'.

        items : iterable
            The iterable of items which should be constrained.

        spacing : int, optional
            The spacing to use between items if not specifically given
            in the sequence of items. The default value is 10 pixels.

        margins : int, tuple, or Box, optional
            The margins to use around the edges of the box. The default
            value is 0 pixels on all sides.

        """
        self.orientation = orientation
        self.items = self.validate(items)
        self.spacing = spacing
        self.margins = margins

    @staticmethod
    def validate(items):
        """ Validate an iterable of constrainable box items.

        This method asserts that a sequence of items is appropriate for
        generating box constraints. The following conditions are verified
        of the sequence of items after they are filtered for None:

        * All of the items in the sequence are instances of Spacer, int,
          LinearSymbolic, Constrainable.

        * There are never two adjacent ints or spacers.

        Parameters
        ----------
        items : iterable
            The iterable of constrainable items to validate.

        Returns
        -------
        result : tuple
            A tuple of validated items, with any None values removed.

        """
        items = tuple(item for item in items if item is not None)

        if len(items) == 0:
            return items

        was_spacer = False
        spacers = (int, Spacer)
        types = (LinearSymbolic, Constrainable, Spacer, int)
        for item in items:
            if not isinstance(item, types):
                msg = 'The allowed item types for a constraint sequence are '
                msg += 'LinearSymbolic, Constrainable, Spacer, and int. '
                msg += 'Got %s instead.'
                raise TypeError(msg % type(item).__name__)
            is_spacer = isinstance(item, spacers)
            if is_spacer and was_spacer:
                msg = 'Expected LinearSymbolic or Constrainable after a '
                msg += 'spacer. Got %s instead.'
                raise TypeError(msg % type(item).__name__)
            was_spacer = is_spacer

        return items

    def constraints(self, component):
        """ Generate the box constraints for the given component.

        Parameters
        ----------
        component : Constrainable or None
            The constrainable object which represents the conceptual
            owner of the generated constraints.

        Returns
        -------
        result : list
            The list of Constraint objects for the given component.

        """
        items = self.items
        if len(items) == 0:
            return []

        # Create the outer boundary box constraints.
        cns = self.box_constraints(component)

        first, last = ORIENT_MAP[self.orientation]
        first_ortho, last_ortho = ORIENT_MAP[ORTHO_MAP[self.orientation]]
        first_boundary = getattr(self, first)
        last_boundary = getattr(self, last)
        first_ortho_boundary = getattr(self, first_ortho)
        last_ortho_boundary = getattr(self, last_ortho)

        # Create the margin spacers that will be used.
        margins = self.margins
        if self.orientation == 'vertical':
            first_spacer = EqSpacer(margins.top)
            last_spacer = EqSpacer(margins.bottom)
            first_ortho_spacer = FlexSpacer(margins.left)
            last_ortho_spacer = FlexSpacer(margins.right)
        else:
            first_spacer = EqSpacer(margins.left)
            last_spacer = EqSpacer(margins.right)
            first_ortho_spacer = FlexSpacer(margins.top)
            last_ortho_spacer = FlexSpacer(margins.bottom)

        # Add a pre and post padding spacer if the user hasn't specified
        # their own spacer as the first/last element of the box items.
        spacer_types = (Spacer, int)
        if not isinstance(items[0], spacer_types):
            pre_items = (first_boundary, first_spacer)
        else:
            pre_items = (first_boundary,)
        if not isinstance(items[-1], spacer_types):
            post_items = (last_spacer, last_boundary)
        else:
            post_items = (last_boundary,)

        # Create the helper for the primary orientation. The helper
        # validation is bypassed since the sequence is known-valid.
        spacing = self.spacing
        helper = SequenceHelper(last, first, (), spacing)
        helper.items = pre_items + items + post_items
        helpers = [helper]

        # Add the ortho orientation and nested helpers. The helper
        # validation is bypassed since the sequence is known-valid.
        for item in items:
            if isinstance(item, Constrainable):
                helper = SequenceHelper(last_ortho, first_ortho, (), spacing)
                helper.items = (first_ortho_boundary, first_ortho_spacer,
                                item, last_ortho_spacer, last_ortho_boundary)
                helpers.append(helper)
            if isinstance(item, ConstraintHelper):
                helpers.append(item)

        # Add in the helper constraints.
        for helper in helpers:
            cns.extend(helper.create_constraints(None))

        return cns

########NEW FILE########
__FILENAME__ = linear_symbolic
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from abc import ABCMeta

import kiwisolver as kiwi


class LinearSymbolic(object):
    """ An abstract base class for testing linear symbolic interfaces.

    """
    __metaclass__ = ABCMeta


LinearSymbolic.register(kiwi.Variable)
LinearSymbolic.register(kiwi.Term)
LinearSymbolic.register(kiwi.Expression)

########NEW FILE########
__FILENAME__ = sequence_helper
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Range, Str, Tuple

from .constrainable import Constrainable
from .constraint_helper import ConstraintHelper
from .linear_symbolic import LinearSymbolic
from .spacers import Spacer, EqSpacer


class SequenceHelper(ConstraintHelper):
    """ A constraint helper for constraining sequences of items.

    """
    #: The name of the anchor on the first item of a constraint pair.
    first_name = Str()

    #: The name of the anchor on the second item of a constraint pair.
    second_name = Str()

    #: The tuple of items which will be used to generate the constraints.
    items = Tuple()

    #: The spacing to use between items if not explicitly provided.
    spacing = Range(low=0)

    def __init__(self, first_name, second_name, items, spacing=10):
        """ Initialize a SequenceHelper.

        Parameters
        ----------
        first_name : str
            The name of the constraint anchor attribute of the first
            item of a constraint pair, if that item is Constrainable.

        second_name : str
            The name of the constraint anchor attribute of the second
            item of a constraint pair, if that item is Constrainable.

        items : iterable
            The iterable of items which should be constrained.

        spacing : int, optional
            The spacing to use between items if not specifically given
            in the sequence of items. The default value is 10 pixels.

        """
        self.first_name = first_name
        self.second_name = second_name
        self.items = self.validate(items)
        self.spacing = spacing

    @staticmethod
    def validate(items):
        """ Validate an iterable of constrainable items.

        This method asserts that a sequence of items is appropriate for
        generating a sequence of constraints. The following conditions
        are verified of the sequence of items after they are filtered
        for None:

        * The first and last items are instances of LinearSymbolic or
          Constrainable.

        * All of the items in the sequence are instances of Spacer, int,
          LinearSymbolic, Constrainable.

        * There are never two adjacent ints or spacers.

        Parameters
        ----------
        items : iterable
            The iterable of constrainable items to validate.

        Returns
        -------
        result : tuple
            A tuple of validated items, with any None values removed.

        """
        items = tuple(item for item in items if item is not None)
        if len(items) < 2:
            return items

        types = (LinearSymbolic, Constrainable)
        for item in (items[0], items[-1]):
            if not isinstance(item, types):
                msg = 'The first and last item of a constraint sequence must '
                msg += 'be LinearSymbolic or Constrainable. Got %s instead.'
                raise TypeError(msg % type(item).__name__)

        was_spacer = False
        spacers = (int, Spacer)
        types = (LinearSymbolic, Constrainable, Spacer, int)
        for item in items:
            if not isinstance(item, types):
                msg = 'The allowed item types for a constraint sequence are '
                msg += 'LinearSymbolic, Constrainable, Spacer, and int. '
                msg += 'Got %s instead.'
                raise TypeError(msg % type(item).__name__)
            is_spacer = isinstance(item, spacers)
            if is_spacer and was_spacer:
                msg = 'Expected LinearSymbolic or Constrainable after a '
                msg += 'spacer. Got %s instead.'
                raise TypeError(msg % type(item).__name__)
            was_spacer = is_spacer

        return items

    def constraints(self, component):
        """ Generate the constraints for the sequence.

        The component parameter is ignored for sequence constraints.

        Returns
        -------
        result : list
            The list of Constraint objects for the sequence.

        """
        cns = []

        # If there are less than 2 items in the sequence, it is not
        # possible to generate meaningful constraints. However, it
        # should not raise an error so that constructs such as
        # align('h_center', foo, bar.when(bar.visible)) will work.
        if len(self.items) < 2:
            return cns

        # The list of items is treated as a stack. So a reversed copy
        # is made before items are pushed and popped.
        items = list(self.items[::-1])
        first_name = self.first_name
        second_name = self.second_name

        while items:
            # `first_item` will be a Constrainable or a LinearSymbolic.
            # For the first iteration, this is enforced by 'validate'.
            # For subsequent iterations, this condition is enforced by
            # the fact that only those types are pushed onto the stack.
            first_item = items.pop()
            if isinstance(first_item, Constrainable):
                first_anchor = getattr(first_item, first_name)
            else:  # LinearSymbolic
                first_anchor = first_item

            # Grab the next item off the stack. It will be an instance
            # of Constrainable, LinearSymbolic, Spacer, or int (this is
            # enforced by 'validate'). If it can't provide an anchor,
            # grab the one after it which can. If no space is given, use
            # the default spacing.
            next_item = items.pop()
            if isinstance(next_item, Spacer):
                spacer = next_item
                second_item = items.pop()
            elif isinstance(next_item, int):
                spacer = EqSpacer(next_item)
                second_item = items.pop()
            else:  # Constrainable or LinearSymbolic
                spacer = EqSpacer(self.spacing)
                second_item = next_item

            # Grab the anchor for the second item in the pair.
            if isinstance(second_item, Constrainable):
                second_anchor = getattr(second_item, second_name)
            else:  # LinearSymbolic
                second_anchor = second_item

            # Use the spacer to generate the constraint for the pair.
            cns.extend(spacer.create_constraints(first_anchor, second_anchor))

            # If the stack is not empty, the second_item will be used as
            # the first_item in the next iteration.
            if items:
                items.append(second_item)

        return cns

########NEW FILE########
__FILENAME__ = spacers
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, Range

import kiwisolver as kiwi

from .strength_member import StrengthMember


class Spacer(Atom):
    """ A base class for creating constraint spacers.

    """
    #: The amount of space to apply for this spacer, in pixels.
    size = Range(low=0)

    #: The optional strength to apply to the spacer constraints.
    strength = StrengthMember()

    def __init__(self, size, strength=None):
        """ Initialize a Spacer.

        Parameters
        ----------
        size : int
            The basic size of the spacer, in pixels >= 0.

        strength : strength-like, optional
            A strength to apply to the generated spacer constraints.

        """
        self.size = size
        self.strength = strength

    def __or__(self, strength):
        """ Override the strength of the generated constraints.

        Parameters
        ----------
        strength : strength-like
            The strength to apply to the generated constraints.

        Returns
        -------
        result : self
            The current spacer instance.

        """
        self.strength = strength
        return self

    def when(self, switch):
        """ A simple switch method to toggle a spacer.

        Parameters
        ----------
        switch : bool
            Whether or not the spacer should be active.

        Returns
        -------
        result : self or None
            The current instance if the switch is True, None otherwise.

        """
        return self if switch else None

    def create_constraints(self, first, second):
        """ Generate the spacer constraints for the given anchors.

        Parameters
        ----------
        first : LinearSymbolic
            A linear symbolic representing the first constraint anchor.

        second : LinearSymbolic
            A linear symbolic representing the second constraint anchor.

        Returns
        -------
        result : list
            The list of constraints for the spacer.

        """
        cns = self.constraints(first, second)
        strength = self.strength
        if strength is not None:
            cns = [cn | strength for cn in cns]
        return cns

    def constraints(self, first, second):
        """ Generate the spacer constraints for the given anchors.

        This abstract method which must be implemented by subclasses.

        Parameters
        ----------
        first : LinearSymbolic
            A linear symbolic representing the first constraint anchor.

        second : LinearSymbolic
            A linear symbolic representing the second constraint anchor.

        Returns
        -------
        result : list
            The list of constraints for the spacer.

        """
        raise NotImplementedError


class EqSpacer(Spacer):
    """ A spacer which represents a fixed amount of space.

    """
    def constraints(self, first, second):
        """ A constraint of the form: (second - first) == size

        """
        return [(second - first) == self.size]


class LeSpacer(Spacer):
    """ A spacer which represents a flexible space with a maximum value.

    """
    def constraints(self, first, second):
        """ A constraint of the form: (second - first) <= size

        A second constraint is applied to prevent negative space:
        (second - first) >= 0

        """
        return [(second - first) <= self.size, (second - first) >= 0]


class GeSpacer(Spacer):
    """ A spacer which represents a flexible space with a minimum value.

    """
    def constraints(self, first, second):
        """ A constraint of the form: (second - first) >= size

        """
        return [(second - first) >= self.size]


class FlexSpacer(Spacer):
    """ A spacer with a hard minimum and a preference for that minimum.

    """
    #: The strength for the minimum space constraint.
    min_strength = StrengthMember(kiwi.strength.required)

    #: The strength for the equality space constraint.
    eq_strength = StrengthMember(kiwi.strength.medium * 1.25)

    def __init__(self, size, min_strength=None, eq_strength=None):
        """ Initialize a FlexSpacer.

        Parameters
        ----------
        size : int
            The basic size of the spacer, in pixels >= 0.

        min_strength : strength-like, optional
            The strength to apply to the minimum spacer size. The
            default is kiwi.strength.required.

        eq_strength : strength-like, optional
            The strength to apply to preferred spacer size. The
            default is 1.25 * kiwi.strength.medium.

        """
        self.size = size
        if min_strength is not None:
            self.min_strength = min_strength
        if eq_strength is not None:
            self.eq_strength = eq_strength

    def constraints(self, first, second):
        """ Generate the constraints for the spacer.

        """
        min_cn = ((second - first) >= self.size) | self.min_strength
        eq_cn = ((second - first) == self.size) | self.eq_strength
        return [min_cn, eq_cn]


class LayoutSpacer(Spacer):
    """ A factory-like Spacer with convenient symbolic methods.

    """
    def __call__(self, *args, **kwargs):
        """ Create a new LayoutSpacer from the given arguments.

        """
        return type(self)(*args, **kwargs)

    def __or__(self, strength):
        """ Create a new LayoutSpacer with the given strength.

        """
        return type(self)(self.size, strength)

    def __eq__(self, size):
        """ Create an EqSpacer with the given size.

        """
        return EqSpacer(size, self.strength)

    def __le__(self, size):
        """ Create an LeSpacer with the given size.

        """
        return LeSpacer(size, self.strength)

    def __ge__(self, size):
        """ Create a GeSpacer withe the given size.

        """
        return GeSpacer(size, self.strength)

    def flex(self, **kwargs):
        """ Create a FlexSpacer with the given configuration.

        """
        return FlexSpacer(self.size, **kwargs)

    def constraints(self, first, second):
        """ Create the constraints for >= spacer constraint.

        """
        return GeSpacer(self.size, self.strength).constraints(first, second)

########NEW FILE########
__FILENAME__ = strength_member
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Validate, Value


class StrengthMember(Value):
    """ A custom Atom member class that validates a strength.

    The strength can be None, a number, or one of the strength strings:
    'weak', 'medium', 'strong', or 'required'.

    """
    __slots__ = ()

    def __init__(self, default=None, factory=None):
        super(StrengthMember, self).__init__(default, factory)
        self.set_validate_mode(Validate.MemberMethod_ObjectOldNew, 'validate')

    def validate(self, owner, old, new):
        if new is not None:
            if not isinstance(new, (float, int, long)):
                if new not in ('weak', 'medium', 'strong', 'required'):
                    msg = "A strength must be a number or 'weak', 'medium' "
                    msg += "'strong', or 'required'. Got %r instead." % new
                    raise TypeError(msg)
        return new

########NEW FILE########
__FILENAME__ = nodevisitor
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
class NodeVisitor(object):
    """ A base class for implementing node visitors.

    Subclasses should implement visitor methods using the naming scheme
    'visit_<name>' where `<name>` is the type name of a given node.

    """
    def __call__(self, node):
        """ The main entry point of the visitor class.

        This method should be called to execute the visitor. It will
        call the setup and teardown methods before and after invoking
        the visit method on the node.

        Parameters
        ----------
        node : object
            The toplevel node of interest.

        Returns
        -------
        result : object
            The return value from the result() method.

        """
        self.setup(node)
        self.visit(node)
        result = self.result(node)
        self.teardown(node)
        return result

    def setup(self, node):
        """ Perform any necessary setup before running the visitor.

        This method is invoked before the visitor is executed over
        a particular node. The default implementation does nothing.

        Parameters
        ----------
        node : object
            The node passed to the visitor.

        """
        pass

    def result(self, node):
        """ Get the results for the visitor.

        This method is invoked after the visitor is executed over a
        particular node and the result() method has been called. The
        default implementation returns None.

        Parameters
        ----------
        node : object
            The node passed to the visitor.

        Returns
        -------
        result : object
            The results of the visitor.

        """
        return None

    def teardown(self, node):
        """ Perform any necessary cleanup when the visitor is finished.

        This method is invoked after the visitor is executed over a
        particular node and the result() method has been called. The
        default implementation does nothing.

        Parameters
        ----------
        node : object
            The node passed to visitor.

        """
        pass

    def visit(self, node):
        """ The main visitor dispatch method.

        Parameters
        ----------
        node : object
            A node from the tree.

        """
        for cls in type(node).mro():
            visitor_name = 'visit_' + cls.__name__
            visitor = getattr(self, visitor_name, None)
            if visitor is not None:
                visitor(node)
                return
        self.default_visit(node)

    def default_visit(self, node):
        """ The default node visitor method.

        This method is invoked when no named visitor method is found
        for a given node. This default behavior raises an exception for
        the missing handler. Subclasses may reimplement this method for
        custom default behavior.

        """
        msg = "no visitor found for node of type `%s`"
        raise TypeError(msg % type(node).__name__)

########NEW FILE########
__FILENAME__ = objectdict
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
class ObjectDict(dict):
    """ A dict subclass which allows access by named attribute.

    """
    __slots__ = ()

    def __getattr__(self, attr):
        if attr in self:
            return self[attr]
        msg = "'%s' object has no attribute '%s'"
        raise AttributeError(msg % (type(self).__name__, attr))

########NEW FILE########
__FILENAME__ = guide_render
""" An extremely hack script that was used to render the dock guide icons.

"""
from enaml.qt.QtCore import *
from enaml.qt.QtGui import *


class GuidePad(object):

    LeftPosition = 0

    TopPosition = 1

    RightPosition = 2

    BottomPosition = 3

    CenterTop = 4

    SplitLeft = 5

    SplitTop = 6

    SplitRight = 7

    SplitBottom = 8

    SplitHorizontal = 9

    SplitVertical = 10

    CenterLeft = 11

    CenterRight = 12

    CenterBottom = 13

    @staticmethod
    def makePath(size):
        path = QPainterPath()
        rect = QRectF(0, 0, size.width(), size.height())
        path.addRoundedRect(rect, 2.0, 2.0)
        return path

    @staticmethod
    def makeTriPath():
        path = QPainterPath()
        path.moveTo(0.0, 0.0)
        path.lineTo(9.0, 0.0)
        path.lineTo(5.0, 4.0)
        path.lineTo(4.0, 4.0)
        path.lineTo(0.0, 0.0)
        return path

    def __init__(self, rect, position=None):
        self._rect = rect
        self._position = position
        self._opacity = 0.8
        self._path = GuidePad.makePath(rect.size())
        self._tri_path = GuidePad.makeTriPath()
        grad = QLinearGradient(0.0, 0.0, 0.0, 1.0)
        grad.setCoordinateMode(QGradient.ObjectBoundingMode)
        grad.setColorAt(0.0, QColor(0xF5, 0xF8, 0xFB))
        grad.setColorAt(0.33, QColor(0xF0, 0xF3, 0xF6))
        grad.setColorAt(0.66, QColor(0xE5, 0xE8, 0xEE))
        grad.setColorAt(1.0, QColor(0xDE, 0xE2, 0xE9))
        self._brush = QBrush(grad)
        grad = QLinearGradient(0.0, 0.0, 0.0, 1.0)
        grad.setCoordinateMode(QGradient.ObjectBoundingMode)
        grad.setColorAt(0.0, QColor(0xFC, 0xEC, 0xBE))
        grad.setColorAt(1.0, QColor(0xF7, 0xC7, 0x73))
        self._fill_brush = QBrush(grad)
        self._pen = QPen(QColor(0x8A, 0x91, 0x9C))

    def rect(self):
        return self._rect

    def setRect(self, rect):
        old = self._rect
        self._rect = rect
        if rect.isValid():
            if self._path is None or old.size() != rect.size():
                self._path = GuidePad.makePath(rect.size())
        else:
            self._path = None

    def contains(self, pos):
        return self._rect.contains(pos)

    def intersects(self, rect):
        return self._rect.intersects(rect)

    def guidePosition(self):
        return self._guide_pos

    def setGuidePosition(self, position):
        self._position = position

    def brush(self):
        return self._brush

    def setBrush(self, brush):
        self._brush = brush

    def pen(self):
        return self._pen

    def setPen(self, pen):
        self._pen = pen

    def opacity(self):
        return self._opacity

    def setOpacity(self, opacity):
        self._opacity = opacity

    def paint(self, painter):
        rect = self._rect
        if not rect.isValid():
            return
        painter.save()
        painter.translate(rect.x(), rect.y())

        # Draw the background
        painter.setOpacity(1.0)#self._opacity)
        painter.fillPath(self._path, self._brush)
        painter.setPen(self._pen)
        painter.drawPath(self._path)

        color = QColor(0x44, 0x58, 0x79)
        fill_brush = self._fill_brush
        painter.setPen(color)
        position = self._position
        if position == self.TopPosition:
            width = rect.width() - 8
            height = rect.height() / 2 - 4
            painter.drawRect(QRect(4, 4, width, height))
            painter.fillRect(QRect(5, 5, width - 1, 3), color)
            painter.fillRect(QRect(5, 8, width - 1, height - 4), fill_brush)
            painter.setRenderHint(QPainter.Antialiasing)
            w = rect.width() / 2 + 5
            h = rect.height() - 5
            painter.translate(w, h)
            painter.rotate(180)
            painter.fillPath(self._tri_path, color)
        elif position == self.BottomPosition:
            width = rect.width() - 8
            height = rect.height() / 2 - 4
            painter.drawRect(QRect(4, height + 4, width, height))
            painter.fillRect(QRect(5, height + 5, width - 1, 3), color)
            painter.fillRect(QRect(5, height + 8, width - 1, height - 4), fill_brush)
            painter.setRenderHint(QPainter.Antialiasing)
            w = rect.width() / 2 - 4
            painter.translate(w, 6)
            painter.fillPath(self._tri_path, color)
        elif position == self.LeftPosition:
            width = rect.width() / 2 - 4
            height = rect.height() - 8
            painter.drawRect(QRect(4, 4, width, height))
            painter.fillRect(QRect(5, 5, width - 1, 3), color)
            painter.fillRect(QRect(5, 8, width - 1, height - 4), fill_brush)
            painter.setRenderHint(QPainter.Antialiasing)
            w = rect.width() - 5
            h = rect.height() / 2 - 4
            painter.translate(w, h)
            painter.rotate(90)
            painter.fillPath(self._tri_path, color)
        elif position == self.RightPosition:
            width = rect.width() / 2 - 4
            height = rect.height() - 8
            painter.drawRect(QRect(width + 4, 4, width, height))
            painter.fillRect(QRect(width + 5, 5, width - 1, 3), color)
            painter.fillRect(QRect(width + 5, 8, width - 1, height - 4), fill_brush)
            painter.setRenderHint(QPainter.Antialiasing)
            h = rect.height() / 2 + 5
            painter.translate(6, h)
            painter.rotate(-90)
            painter.fillPath(self._tri_path, color)
        elif position == self.CenterTop:
            width = rect.width() - 8
            height = rect.height() - 8
            painter.drawRect(QRect(4, 4, width, height))
            painter.fillRect(QRect(5, 5, width - 1, 3), color)
            painter.fillRect(QRect(5, 8, width - 1, height - 4), fill_brush)
        elif position == self.CenterBottom:
            width = rect.width() - 8
            height = rect.height() - 8
            painter.drawRect(QRect(4, 4, width, height))
            painter.fillRect(QRect(5, 5 + height - 4, width - 1, 3), color)
            painter.fillRect(QRect(5, 5, width - 1, height - 4), fill_brush)
        elif position == self.CenterLeft:
            width = rect.width() - 8
            height = rect.height() - 8
            painter.drawRect(QRect(4, 4, width, height))
            painter.fillRect(QRect(5, 5, 3, height), color)
            painter.fillRect(QRect(8, 5, width - 4, height - 1), fill_brush)
        elif position == self.CenterRight:
            width = rect.width() - 8
            height = rect.height() - 8
            painter.drawRect(QRect(4, 4, width, height))
            painter.fillRect(QRect(width + 1, 5, 3, height - 1), color)
            painter.fillRect(QRect(5, 5, width - 4, height - 1), fill_brush)
        elif position == self.SplitTop:
            width = rect.width() - 8
            height = rect.height() - 8
            painter.drawRect(QRect(4, 4, width, height))
            painter.fillRect(QRect(5, 5, width - 1, 3), color)
            painter.fillRect(QRect(5, 8, width - 1, height / 2 - 2), fill_brush)
            pen = QPen(color, 0, Qt.DotLine)
            pen.setDashPattern([1, 1])
            painter.setPen(pen)
            painter.drawLine(5, 8 + height / 2 - 3, 5 + width - 1, 8 + height / 2 - 3)
        elif position == self.SplitBottom:
            width = rect.width() - 8
            height = rect.height() - 8
            painter.drawRect(QRect(4, 4, width, height))
            painter.fillRect(QRect(5, 5, width - 1, 3), color)
            h = height / 2 - 2
            painter.fillRect(QRect(5, 8 + h, width - 1, h), fill_brush)
            pen = QPen(color, 0, Qt.DotLine)
            pen.setDashPattern([1, 1])
            painter.setPen(pen)
            painter.drawLine(5, 8 + height / 2 - 2, 5 + width - 1, 8 + height / 2 - 2)
        elif position == self.SplitLeft:
            width = rect.width() - 8
            height = rect.height() - 8
            painter.drawRect(QRect(4, 4, width, height))
            painter.fillRect(QRect(5, 5, width - 1, 3), color)
            w = width / 2
            h = height - 4
            painter.fillRect(QRect(5, 8, w - 1, h), fill_brush)
            pen = QPen(color, 0, Qt.DotLine)
            pen.setDashPattern([1, 1])
            pen.setDashOffset(1)
            painter.setPen(pen)
            painter.drawLine(3 + w, 8, 3 + w, 8 + h)
        elif position == self.SplitRight:
            width = rect.width() - 8
            height = rect.height() - 8
            painter.drawRect(QRect(4, 4, width, height))
            painter.fillRect(QRect(5, 5, width - 1, 3), color)
            w = width / 2
            h = height - 4
            painter.fillRect(QRect(5 + w, 8, w - 1, h), fill_brush)
            pen = QPen(color, 0, Qt.DotLine)
            pen.setDashPattern([1, 1])
            pen.setDashOffset(1)
            painter.setPen(pen)
            painter.drawLine(5 + w, 8, 5 + w, 8 + h)
        elif position == self.SplitHorizontal:
            width = rect.width() - 8
            height = rect.height() - 8
            painter.drawRect(QRect(4, 4, width, height))
            painter.fillRect(QRect(5, 5, width - 1, 3), color)
            w = width / 4
            h = height - 4
            painter.fillRect(QRect(6 + w, 8, 2 * w - 1, h), fill_brush)
            pen = QPen(color, 0, Qt.DotLine)
            pen.setDashPattern([1, 1])
            pen.setDashOffset(1)
            painter.setPen(pen)
            painter.drawLine(6 + w, 8, 6 + w, 8 + h)
            painter.drawLine(4 + 3 * w, 8, 4 + 3 * w, 8 + h)
        elif position == self.SplitVertical:
            width = rect.width() - 8
            height = rect.height() - 8
            painter.drawRect(QRect(4, 4, width, height))
            painter.fillRect(QRect(5, 5, width - 1, 3), color)
            h = height / 4
            painter.fillRect(QRect(5, 8 + h, width - 1, 2 * h - 2), fill_brush)
            pen = QPen(color, 0, Qt.DotLine)
            pen.setDashPattern([1, 1])
            painter.setPen(pen)
            painter.drawLine(5, 8 + h, 4 + width, 8 + h)
            painter.drawLine(5, 10 + 2 * h, 4 + width, 10 + 2 * h)
        # Draw the indicator
        painter.restore()


def render_cross(painter):
    path = QPainterPath()
    path.moveTo(35.0, 0)
    path.lineTo(75.0, 0)
    path.lineTo(75.0, 25.0)
    path.lineTo(85.0, 35.0)
    path.lineTo(110.0, 35.0)
    path.lineTo(110.0, 75.0)
    path.lineTo(85.0, 75.0)
    path.lineTo(75.0, 85.0)
    path.lineTo(75.0, 110.0)
    path.lineTo(35.0, 110.0)
    path.lineTo(35.0, 85.0)
    path.lineTo(25.0, 75.0)
    path.lineTo(0.0, 75.0)
    path.lineTo(0.0, 35.0)
    path.lineTo(25.0, 35.0)
    path.lineTo(35.0, 25.0)
    path.lineTo(35.0, 0.0)
    painter.fillPath(path, QColor(0xFF, 0xFF, 0xFF, 0x99))
    painter.setPen(QPen(QColor(0x77, 0x77, 0x77), 1.0))
    painter.drawPath(path)


def render_cross_ex(painter):
    path = QPainterPath()
    path.moveTo(49.0, 0)
    path.lineTo(89.0, 0)
    path.lineTo(89.0, 39.0)
    path.lineTo(99.0, 49.0)
    path.lineTo(138.0, 49.0)
    path.lineTo(138.0, 89.0)
    path.lineTo(99.0, 89.0)
    path.lineTo(89.0, 99.0)
    path.lineTo(89.0, 138.0)
    path.lineTo(49.0, 138.0)
    path.lineTo(49.0, 99.0)
    path.lineTo(39.0, 89.0)
    path.lineTo(0.0, 89.0)
    path.lineTo(0.0, 49.0)
    path.lineTo(39.0, 49.0)
    path.lineTo(49.0, 39.0)
    path.lineTo(49.0, 0.0)
    painter.fillPath(path, QColor(0xFF, 0xFF, 0xFF, 0x99))
    painter.setPen(QPen(QColor(0x77, 0x77, 0x77), 1.0))
    painter.drawPath(path)


def render_north_cross(painter):
    path = QPainterPath()
    path.moveTo(35.0, 0)
    path.lineTo(75.0, 0)
    path.lineTo(75.0, 25.0)
    path.lineTo(85.0, 35.0)
    path.lineTo(110.0, 35.0)
    path.lineTo(110.0, 75.0)
    path.lineTo(85.0, 75.0)
    path.lineTo(75.0, 85.0)
    path.lineTo(75.0, 110.0)
    path.lineTo(35.0, 110.0)
    path.lineTo(35.0, 85.0)
    path.lineTo(25.0, 75.0)
    path.lineTo(0.0, 75.0)
    path.lineTo(0.0, 35.0)
    path.lineTo(25.0, 35.0)
    path.lineTo(35.0, 25.0)
    path.lineTo(35.0, 0.0)
    painter.fillPath(path, QColor(0xFF, 0xFF, 0xFF, 0x99))
    painter.setPen(QPen(QColor(0x77, 0x77, 0x77), 1.0))
    painter.drawPath(path)


def render_box(painter):
    path = QPainterPath()
    path.moveTo(0.0, 0.0)
    path.lineTo(40.0, 0.0)
    path.lineTo(40.0, 40.0)
    path.lineTo(0.0, 40.0)
    path.lineTo(0.0, 0.0)
    painter.fillPath(path, QColor(0xFF, 0xFF, 0xFF, 0x99))
    painter.setPen(QPen(QColor(0x77, 0x77, 0x77), 1.0))
    painter.drawPath(path)


def render_vbar(painter):
    path = QPainterPath()
    rect = QRectF(0, 0, 9, 30)
    path.addRoundedRect(rect, 2.0, 2.0)
    grad = QLinearGradient(0.0, 0.0, 0.0, 1.0)
    grad.setCoordinateMode(QGradient.ObjectBoundingMode)
    grad.setColorAt(0.0, QColor(0xF5, 0xF8, 0xFB))
    grad.setColorAt(0.33, QColor(0xF0, 0xF3, 0xF6))
    grad.setColorAt(0.66, QColor(0xE5, 0xE8, 0xEE))
    grad.setColorAt(1.0, QColor(0xDE, 0xE2, 0xE9))
    brush = QBrush(grad)
    pen = QPen(QColor(0x8A, 0x91, 0x9C))

    painter.fillPath(path, brush)
    painter.setPen(pen)
    painter.drawPath(path)

    color = QColor(0x44, 0x58, 0x79)
    painter.fillRect(QRect(4, 4, 2, 23), color)


def render_hbar(painter):
    path = QPainterPath()
    rect = QRectF(0, 0, 30, 9)
    path.addRoundedRect(rect, 2.0, 2.0)
    grad = QLinearGradient(0.0, 0.0, 0.0, 1.0)
    grad.setCoordinateMode(QGradient.ObjectBoundingMode)
    grad.setColorAt(0.0, QColor(0xF5, 0xF8, 0xFB))
    grad.setColorAt(0.33, QColor(0xF0, 0xF3, 0xF6))
    grad.setColorAt(0.66, QColor(0xE5, 0xE8, 0xEE))
    grad.setColorAt(1.0, QColor(0xDE, 0xE2, 0xE9))
    brush = QBrush(grad)
    pen = QPen(QColor(0x8A, 0x91, 0x9C))

    painter.fillPath(path, brush)
    painter.setPen(pen)
    painter.drawPath(path)

    color = QColor(0x44, 0x58, 0x79)
    painter.setPen(color)
    painter.fillRect(QRect(4, 4, 23, 2), color)


def render_background(painter):
    brush = QBrush(QColor(0x00, 0x00, 0x00, 0x10), Qt.Dense6Pattern)
    painter.fillRect(QRect(0, 0, 129, 129), brush)
    brush = QBrush(QColor(0xFF, 0xFF, 0xFF, 0x10), Qt.Dense6Pattern)
    painter.translate(0, 1)
    painter.fillRect(QRect(0, 0, 129, 129), brush)


app = QApplication([])
image = QImage(QSize(128, 128), QImage.Format_ARGB32_Premultiplied)
image.fill(0)
painter = QPainter(image)
#render_box(painter)
#render_cross(painter)
#render_cross_ex(painter)
#render_vbar(painter)
#render_hbar(painter)
render_background(painter)
#pad = GuidePad(QRect(0, 0, 30, 30), GuidePad.CenterQuads)
#pad.paint(painter)
painter.end()

import os
path = os.path.join(os.path.dirname(__file__), 'background.png')
image.save(path)

########NEW FILE########
__FILENAME__ = dock_manager
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, Int, Typed, List, atomref

from enaml.layout.dock_layout import DockLayout, DockLayoutValidator

from enaml.qt.QtCore import Qt, QPoint, QRect, QObject
from enaml.qt.QtGui import QApplication

from .dock_overlay import DockOverlay
from .layout_handling import layout_hit_test, plug_frame, iter_containers
from .layout_builder import LayoutBuilder
from .layout_saver import LayoutSaver
from .proximity_handler import ProximityHandler
from .q_dock_area import QDockArea
from .q_dock_container import QDockContainer
from .q_dock_window import QDockWindow
from .q_guide_rose import QGuideRose


class DockContainerMonitor(QObject):
    """ A QObject class which monitors dock container toplevel changes.

    """
    def __init__(self, manager):
        """ Initialize a DockContainerMonitor.

        Parameters
        ----------
        mananger : DockManager
            The manager which owns this monitor. Only an atomref will
            be maintained to the manager.

        """
        super(DockContainerMonitor, self).__init__()
        self._manager = atomref(manager)

    def onTopLevelChanged(self, toplevel):
        """ Handle the 'topLevelChanged' signal from a dock container.

        """
        if self._manager:
            handler = self._manager()._proximity_handler
            container = self.sender()
            if toplevel:
                handler.addFrame(container)
            else:
                handler.removeFrame(container)


class DockManager(Atom):
    """ A class which manages the docking behavior of a dock area.

    """
    #: The handler which holds the primary dock area.
    _dock_area = Typed(QDockArea)

    #: The overlay used when hovering over a dock area.
    _overlay = Typed(DockOverlay, ())

    #: The list of QDockFrame instances maintained by the manager. The
    #: QDockFrame class maintains this list in proper Z-order.
    _dock_frames = List()

    #: The set of QDockItem instances added to the manager.
    _dock_items = Typed(set, ())

    #: The distance to use for snapping floating dock frames.
    _snap_dist = Int(factory=lambda: QApplication.startDragDistance() * 2)

    #: A proximity handler which manages proximal floating frames.
    _proximity_handler = Typed(ProximityHandler, ())

    #: A container monitor which tracks toplevel container changes.
    _container_monitor = Typed(DockContainerMonitor)

    def _default__container_monitor(self):
        return DockContainerMonitor(self)

    def __init__(self, dock_area):
        """ Initialize a DockingManager.

        Parameters
        ----------
        dock_area : QDockArea
            The primary dock area to be managed. Docking will be
            restricted to this area and to windows spawned by the
            area.

        """
        assert dock_area is not None
        self._dock_area = dock_area
        self._overlay = DockOverlay(dock_area)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def dock_area(self):
        """ Get the dock area to which the manager is attached.

        Returns
        -------
        result : QDockArea
            The dock area to which the manager is attached.

        """
        return self._dock_area

    def add_item(self, item):
        """ Add a dock item to the dock manager.

        If the item has already been added, this is a no-op.

        Parameters
        ----------
        items : QDockItem
            The item to be managed by this dock manager. It will be
            reparented to a dock container and made available to the
            the layout system.

        """
        if item in self._dock_items:
            return
        self._dock_items.add(item)
        item._manager = self
        container = QDockContainer(self, self._dock_area)
        container.setDockItem(item)
        container.setObjectName(item.objectName())
        monitor = self._container_monitor
        container.topLevelChanged.connect(monitor.onTopLevelChanged)
        self._dock_frames.append(container)

    def remove_item(self, item):
        """ Remove a dock item from the dock manager.

        If the item has not been added to the manager, this is a no-op.

        Parameters
        ----------
        items : QDockItem
            The item to remove from the dock manager. It will be hidden
            and unparented, but not destroyed.

        """
        if item not in self._dock_items:
            return
        item._manager = None
        for container in self.dock_containers():
            if container.dockItem() is item:
                if not container.isWindow():
                    container.unplug()
                container.hide()
                self._free_container(container)
                break

    def save_layout(self):
        """ Get the current layout of the dock area.

        Returns
        -------
        result : docklayout
            A docklayout instance which represents the current layout
            state.

        """
        items = [self._dock_area] + self.floating_frames()
        return DockLayout(*map(LayoutSaver(), items))

    def apply_layout(self, layout):
        """ Apply a layout to the dock area.

        Parameters
        ----------
        layout : DockLayout
            The dock layout to apply to the managed area.

        """
        available = (i.objectName() for i in self._dock_items)
        DockLayoutValidator(available)(layout)
        LayoutBuilder(self)(layout)

    def update_layout(self, ops):
        """ Update the layout for a list of layout operations.

        Parameters
        ----------
        ops : list
            A list of LayoutOp objects to use for updating the layout.

        """
        builder = LayoutBuilder(self)
        for op in ops:
            builder(op)

    def destroy(self):
        """ Destroy the dock manager.

        This method will free all of the resources held by the dock
        manager. The primary dock area and dock items will not be
        destroyed. After the method is called, the dock manager is
        invalid and should no longer be used.

        """
        for frame in self._dock_frames:
            if isinstance(frame, QDockContainer):
                frame.setDockItem(None)
                frame.setParent(None, Qt.Widget)
                frame.hide()
        for frame in self._dock_frames:
            if isinstance(frame, QDockWindow):
                frame.setParent(None, Qt.Widget)
                frame.hide()
        for item in self._dock_items:
            item._manager = None
        self._dock_area.setCentralWidget(None)
        self._dock_area.setMaximizedWidget(None)
        del self._dock_area
        del self._dock_frames
        del self._dock_items
        del self._proximity_handler
        del self._container_monitor
        del self._overlay

    #--------------------------------------------------------------------------
    # Framework API
    #--------------------------------------------------------------------------
    def dock_containers(self):
        """ Get an iterable of QDockContainer instances.

        This method is called by the framework at the appropriate times
        and should not be called directly by user code.

        Returns
        -------
        result : list
            A list of QDockContainer instances owned by this dock
            manager.

        """
        f = lambda w: isinstance(w, QDockContainer)
        return filter(f, self._dock_frames)

    def dock_windows(self):
        """ Get an iterable of QDockWindow instances.

        This method is called by the framework at the appropriate times
        and should not be called directly by user code.

        Returns
        -------
        result : list
            A list of QDockWindow instances owned by this dock manager.

        """
        f = lambda w: isinstance(w, QDockWindow)
        return filter(f, self._dock_frames)

    def floating_frames(self):
        """ Get an iterable of floating dock frames.

        This method is called by the framework at the appropriate times
        and should not be called directly by user code.

        Returns
        -------
        result : list
            A list toplevel QDockFrame instances.

        """
        f = lambda w: w.isWindow()
        return filter(f, self._dock_frames)

    def add_window(self, window):
        """ Add a floating QDockWindow to the dock manager.

        This method is called by the framework at the appropriate times
        and should not be called directly by user code.

        Parameters
        ----------
        window : QDockWindow
            A newly created dock window which should be tracked by
            the dock manager.

        """
        self._dock_frames.append(window)
        self._proximity_handler.addFrame(window)

    def close_container(self, container, event):
        """ Handle a close request for a QDockContainer.

        This method is called by the framework at the appropriate times
        and should not be called directly by user code.

        Parameters
        ----------
        window : QDockContainer
            The dock container to close.

        event : QCloseEvent
            The close event passed to the event handler.

        """
        item = container.dockItem()
        if item is None or item.close():
            if not container.isWindow():
                container.unplug()
            self._free_container(container)
        else:
            event.ignore()

    def close_window(self, window, event):
        """ Handle a close request for a QDockWindow.

        This method is called by the framework at the appropriate times
        and should not be called directly by user code.

        Parameters
        ----------
        window : QDockWindow
            The dock window to close.

        event : QCloseEvent
            The close event passed to the event handler.

        """
        area = window.dockArea()
        if area is not None:
            containers = list(iter_containers(area))
            geometries = {}
            for container in containers:
                pos = container.mapToGlobal(QPoint(0, 0))
                size = container.size()
                geometries[container] = QRect(pos, size)
            for container, ignored in area.dockBarContainers():
                containers.append(container)
                size = container.sizeHint()
                geometries[container] = QRect(window.pos(), size)
            for container in containers:
                if not container.close():
                    container.unplug()
                    container.float()
                    container.setGeometry(geometries[container])
                    container.show()
        self._free_window(window)

    def raise_frame(self, frame):
        """ Raise a frame to the top of the Z-order.

        This method is called by the framework at the appropriate times
        and should not be called directly by user code.

        Parameters
        ----------
        frame : QDockFrame
            The frame to raise to the top of the Z-order.

        """
        frames = self._dock_frames
        handler = self._proximity_handler
        if handler.hasLinkedFrames(frame):
            linked = set(handler.linkedFrames(frame))
            ordered = [f for f in frames if f in linked]
            for other in ordered:
                frames.remove(other)
                frames.append(other)
                other.raise_()
            frame.raise_()
        frames.remove(frame)
        frames.append(frame)

    def frame_resized(self, frame):
        """ Handle the post-processing for a resized floating frame.

        This method is called by the framework at the appropriate times
        and should not be called directly by user code.

        Parameters
        ----------
        frame : QDockFrame
            The frame which has been resized.

        """
        # If the frame is linked, the resize may have changed the frame
        # geometry such that the existing links are no longer valid.
        # The links are refreshed and the link button state is updated.
        if frame.isLinked():
            handler = self._proximity_handler
            handler.updateLinks(frame)
            if not handler.hasLinkedFrames(frame):
                frame.setLinked(False)

    def drag_move_frame(self, frame, target_pos, mouse_pos):
        """ Move the floating frame to the target position.

        This method is called by a floating frame in response to a user
        moving it by dragging on it's title bar. It takes into account
        neighboring windows and will snap the frame edge to another
        window if it comes close to the boundary. It also ensures that
        the guide overlays are shown at the proper position. This method
        should not be called by user code.

        Parameters
        ----------
        frame : QDockFrame
            The floating QDockFrame which should be moved.

        target_pos : QPoint
            The global position which is the target of the move.

        mouse_pos : QPoint
            The global mouse position.

        """
        # If the frame is linked, it and any of its linked frames are
        # moved the same amount with no snapping. An unlinked window
        # is free to move and will snap to any other floating window
        # that has an opposite edge lying within the snap distance.
        # The overlay is hidden when the frame has proximal frames
        # since such a frame is not allowed to be docked.
        show_drag_overlay = True
        handler = self._proximity_handler
        if frame.isLinked():
            delta = target_pos - frame.pos()
            frame.move(target_pos)
            if handler.hasLinkedFrames(frame):
                show_drag_overlay = False
                for other in handler.linkedFrames(frame):
                    other.move(other.pos() + delta)
        else:
            f_size = frame.frameGeometry().size()
            f_rect = QRect(target_pos, f_size)
            f_x = target_pos.x()
            f_y = target_pos.y()
            f_w = f_size.width()
            f_h = f_size.height()
            dist = self._snap_dist
            filt = lambda n: -dist < n < dist
            for other in handler.proximalFrames(f_rect, dist):
                if other is not frame:
                    o_geo = other.frameGeometry()
                    o_x = o_geo.left()
                    o_y = o_geo.top()
                    o_right = o_x + o_geo.width()
                    o_bottom = o_y + o_geo.height()
                    dx = filter(filt, (
                        o_x - f_x,
                        o_x - (f_x + f_w),
                        o_right - f_x,
                        o_right - (f_x + f_w),
                    ))
                    if dx:
                        f_x += min(dx)
                    dy = filter(filt, (
                        o_y - f_y,
                        o_y - (f_y + f_h),
                        o_bottom - f_y,
                        o_bottom - (f_y + f_h),
                    ))
                    if dy:
                        f_y += min(dy)
            frame.move(f_x, f_y)
        if show_drag_overlay:
            self._update_drag_overlay(frame, mouse_pos)
        else:
            self._overlay.hide()

    def drag_release_frame(self, frame, pos):
        """ Handle the dock frame being released by the user.

        This method is called by the framework at the appropriate times
        and should not be called directly by user code. It will redock
        a floating dock item if it is released over a dock guide.

        Parameters
        ----------
        frame : QDockFrame
            The dock frame being dragged by the user.

        pos : QPoint
            The global coordinates of the mouse position.

        """
        # Docking is disallowed for frames which have linked proximal
        # frames, or if the target dock area has a maximized widget.
        # This prevents a situation where the docking logic would be
        # non-sensical and maintains a consistent user experience.
        overlay = self._overlay
        overlay.hide()
        guide = overlay.guide_at(pos)
        if guide == QGuideRose.Guide.NoGuide:
            return
        if self._proximity_handler.hasLinkedFrames(frame):
            return
        builder = LayoutBuilder(self)
        target = self._dock_target(frame, pos)
        if isinstance(target, QDockArea):
            if target.maximizedWidget() is not None:
                return
            with builder.drop_frame(frame):
                local = target.mapFromGlobal(pos)
                widget = layout_hit_test(target, local)
                plug_frame(target, widget, frame, guide)
        elif isinstance(target, QDockContainer):
            with builder.dock_context(target):
                with builder.drop_frame(frame):
                    area = target.parentDockArea()
                    if area is not None:
                        plug_frame(area, target, frame, guide)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _free_container(self, container):
        """ Free the resources attached to the container.

        Parameters
        ----------
        container : QDockContainer
            The container which should be cleaned up. It should be
            unplugged from any layout before being passed to this
            method.

        """
        item = container.dockItem()
        container.setParent(None)
        container.setDockItem(None)
        container._manager = None
        self._dock_items.discard(item)
        self._dock_frames.remove(container)
        self._proximity_handler.removeFrame(container)

    def _free_window(self, window):
        """ Free the resources attached to the window.

        Parameters
        ----------
        window : QDockWindow
            The Window which should be cleaned up.

        """
        window.setParent(None)
        window.setDockArea(None)
        window._manager = None
        self._dock_frames.remove(window)
        self._proximity_handler.removeFrame(window)

    def _iter_dock_targets(self, frame):
        """ Get an iterable of potential dock targets.

        Parameters
        ----------
        frame : QDockFrame
            The frame which is being docked, and therefore excluded
            from the target search.

        Returns
        -------
        result : generator
            A generator which yields the dock container and dock area
            instances which are potential dock targets.

        """
        for target in reversed(self._dock_frames):
            if target is not frame and target.isWindow():
                if isinstance(target, QDockContainer):
                    yield target
                elif isinstance(target, QDockWindow):
                    yield target.dockArea()
        yield self._dock_area

    def _dock_target(self, frame, pos):
        """ Get the dock target for the given frame and position.

        Parameters
        ----------
        frame : QDockFrame
            The dock frame which should be docked.

        pos : QPoint
            The global mouse position.

        Returns
        -------
        result : QDockArea, QDockContainer, or None
            The potential dock target for the frame and position.

        """
        for target in self._iter_dock_targets(frame):
            # Hit test the central pane instead of the entire dock area
            # so that mouse movement over the dock bars is ignored.
            if isinstance(target, QDockArea):
                pane = target.centralPane()
                local = pane.mapFromGlobal(pos)
                if pane.rect().contains(local):
                    return target
            else:
                local = target.mapFromGlobal(pos)
                if target.rect().contains(local):
                    return target

    def _update_drag_overlay(self, frame, pos):
        """ Update the overlay for a dragged frame.

        Parameters
        ----------
        frame : QDockFrame
            The dock frame being dragged by the user.

        pos : QPoint
            The global coordinates of the mouse position.

        """
        overlay = self._overlay
        target = self._dock_target(frame, pos)
        if isinstance(target, QDockContainer):
            local = target.mapFromGlobal(pos)
            overlay.mouse_over_widget(target, local)
        elif isinstance(target, QDockArea):
            # Disallow docking onto an area with a maximized widget.
            # This prevents a non-intuitive user experience.
            if target.maximizedWidget() is not None:
                overlay.hide()
                return
            local = target.mapFromGlobal(pos)
            widget = layout_hit_test(target, local)
            overlay.mouse_over_area(target, widget, local)
        else:
            overlay.hide()

########NEW FILE########
__FILENAME__ = dock_overlay
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, Bool, Int, Float, Typed

from enaml.qt import QT_API
from enaml.qt.QtCore import Qt, QPoint, QRect, QTimer, QPropertyAnimation
from enaml.qt.QtGui import QWidget, QStyle, QStyleOption, QPainter

from .q_guide_rose import QGuideRose
from .q_dock_bar import QDockBar
from .q_dock_container import QDockContainer
from .q_dock_splitter import QDockSplitterHandle
from .q_dock_tab_widget import QDockTabWidget


class QDockRubberBand(QWidget):
    """ A custom rubber band widget for use with the dock overlay.

    This class is stylable from Qt style sheets.

    """
    def __init__(self, parent=None):
        """ Initialize a QDockRubberBand.

        Parameters
        ----------
        parent : QWidget, optional
            The parent of the dock rubber band.

        """
        super(QDockRubberBand, self).__init__(parent)
        self.setWindowFlags(Qt.ToolTip | Qt.FramelessWindowHint)
        self.setAttribute(Qt.WA_TranslucentBackground)

    def paintEvent(self, event):
        """ Handle the paint event for the dock rubber band.

        """
        painter = QPainter(self)
        opt = QStyleOption()
        opt.initFrom(self)
        self.style().drawPrimitive(QStyle.PE_Widget, opt, painter, self)


class DockOverlay(Atom):
    """ An object which manages the overlays for dock widgets.

    This manager handles the state transitions for the overlays. The
    transitions are performed on a slightly-delayed timer to provide
    a more fluid user interaction experience.

    """
    # PySide requires weakrefs for using bound methods as slots
    if QT_API == 'pyside':
        __slots__ = '__weakref__'

    #: The size of the rubber band when docking on the border, in px.
    border_size = Int(60)

    #: The delay to use when triggering the rose timer, in ms.
    rose_delay = Int(30)

    #: The delay to use when triggering the band timer, in ms.
    band_delay = Int(50)

    #: The target opacity to use when making the band visible.
    band_target_opacity = Float(1.0)

    #: The duration of the band visibilty animation, in ms.
    band_vis_duration = Int(100)

    #: the duration of the band geometry animation, in ms.
    band_geo_duration = Int(100)

    #: The overlayed guide rose.
    _rose = Typed(QGuideRose, ())

    #: The overlayed rubber band.
    _band = Typed(QDockRubberBand, ())

    #: The property animator for the rubber band geometry.
    _geo_animator = Typed(QPropertyAnimation)

    #: The property animator for the rubber band visibility.
    _vis_animator = Typed(QPropertyAnimation)

    #: The target mode to apply to the rose on timeout.
    _target_rose_mode = Int(QGuideRose.Mode.NoMode)

    #: The target geometry to apply to rubber band on timeout.
    _target_band_geo = Typed(QRect, factory=lambda: QRect())

    #: The value of the last guide which was hit in the rose.
    _last_guide = Int(-1)

    #: A flag indicating whether it is safe to show the band.
    _show_band = Bool(False)

    #: The hover position of the mouse to use for state changes.
    _hover_pos = Typed(QPoint, factory=lambda: QPoint())

    #: The timer for changing the state of the rose.
    _rose_timer = Typed(QTimer)

    #: The timer for changing the state of the band.
    _band_timer = Typed(QTimer)

    def __init__(self, parent=None):
        """ Initialize a DockOverlay.

        Parameters
        ----------
        parent : QWidget, optional
            The parent of the overlay. This will be used as the parent
            widget for the dock rubber band. The overlay guides do not
            have a parent.

        """
        self._band = QDockRubberBand(parent)

    #--------------------------------------------------------------------------
    # Default Value Methods
    #--------------------------------------------------------------------------
    def _default__rose_timer(self):
        """ Create the default timer for the rose state changes.

        """
        timer = QTimer()
        timer.setSingleShot(True)
        timer.timeout.connect(self._on_rose_timer)
        return timer

    def _default__band_timer(self):
        """ Create the default timer for the band state changes.

        """
        timer = QTimer()
        timer.setSingleShot(True)
        timer.timeout.connect(self._on_band_timer)
        return timer

    def _default__geo_animator(self):
        """ Create the default property animator for the rubber band.

        """
        p = QPropertyAnimation(self._band, 'geometry')
        p.setDuration(self.band_geo_duration)
        return p

    def _default__vis_animator(self):
        """ Create the default property animator for the rubber band.

        """
        p = QPropertyAnimation(self._band, 'windowOpacity')
        p.setDuration(self.band_vis_duration)
        p.finished.connect(self._on_vis_finished)
        return p

    #--------------------------------------------------------------------------
    # Timer Handlers
    #--------------------------------------------------------------------------
    def _on_rose_timer(self):
        """ Handle the timeout event for the internal rose timer.

        This handler transitions the rose to its new state and updates
        the position of the rubber band.

        """
        rose = self._rose
        rose.setMode(self._target_rose_mode)
        rose.mouseOver(self._hover_pos)
        self._show_band = True
        self._update_band_state()

    def _on_band_timer(self):
        """ Handle the timeout event for the internal band timer.

        This handler updates the position of the rubber band.

        """
        self._update_band_state()

    #--------------------------------------------------------------------------
    # Animation Handlers
    #--------------------------------------------------------------------------
    def _on_vis_finished(self):
        """ Handle the 'finished' signal from the visibility animator.

        This handle will hide the rubber band when its opacity is 0.

        """
        band = self._band
        if band.windowOpacity() == 0.0:
            band.hide()

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _update_band_state(self):
        """ Refresh the geometry and visible state of the rubber band.

        The state will be updated using animated properties to provide
        a nice fluid user experience.

        """
        # A valid geometry indicates that the rubber should be shown on
        # the screen. An invalid geometry means it should be hidden. If
        # the validity is changed during animation, the animators are
        # restarted using the current state as their starting point.
        band = self._band
        geo = self._target_band_geo
        if geo.isValid() and self._show_band:
            # If the band is already hidden, the geometry animation can
            # be bypassed since the band can be located anywhere.
            if band.isHidden():
                band.setGeometry(geo)
                self._start_vis_animator(self.band_target_opacity)
                self._rose.raise_()
            else:
                self._start_vis_animator(self.band_target_opacity)
                self._start_geo_animator(geo)
        else:
            self._start_vis_animator(0.0)

    def _start_vis_animator(self, opacity):
        """ (Re)start the visibility animator.

        Parameters
        ----------
        opacity : float
            The target opacity of the target object.

        """
        animator = self._vis_animator
        if animator.state() == animator.Running:
            animator.stop()
        target = animator.targetObject()
        if target.isHidden() and opacity != 0.0:
            target.setWindowOpacity(0.0)
            target.show()
        animator.setStartValue(target.windowOpacity())
        animator.setEndValue(opacity)
        animator.start()

    def _start_geo_animator(self, geo):
        """ (Re)start the visibility animator.

        Parameters
        ----------
        geo : QRect
            The target geometry for the target object.

        """
        animator = self._geo_animator
        if animator.state() == animator.Running:
            animator.stop()
        target = animator.targetObject()
        animator.setStartValue(target.geometry())
        animator.setEndValue(geo)
        animator.start()

    def _band_geometry(self, widget, guide):
        """ Compute the geometry for an overlay rubber band.

        Parameters
        ----------
        widget : QWidget
            The widget to which the band geometry should be fit.

        guide : Guide
            The rose guide under the mouse. This determines how the
            geometry of the band will be fit to the widget.

        """
        Guide = QGuideRose.Guide
        if guide == Guide.NoGuide:
            return QRect()

        # border hits
        border_size = self.border_size
        rect = widget.contentsRect()
        if guide == Guide.BorderNorth:
            rect.setHeight(border_size)
        elif guide == Guide.BorderEast:
            rect.setLeft(rect.right() + 1 - border_size)
        elif guide == Guide.BorderSouth:
            rect.setTop(rect.bottom() + 1 - border_size)
        elif guide == Guide.BorderWest:
            rect.setWidth(border_size)
        # For the next 4 conditions `widget` will be a QDockArea
        elif guide == Guide.BorderExNorth:
            bar_rect = widget.dockBarGeometry(QDockBar.North)
            if bar_rect.isValid():
                rect = bar_rect
            else:
                rect.setHeight(border_size / 2)
        elif guide == Guide.BorderExEast:
            bar_rect = widget.dockBarGeometry(QDockBar.East)
            if bar_rect.isValid():
                rect = bar_rect
            else:
                rect.setLeft(rect.right() + 1 - border_size / 2)
        elif guide == Guide.BorderExSouth:
            bar_rect = widget.dockBarGeometry(QDockBar.South)
            if bar_rect.isValid():
                rect = bar_rect
            else:
                rect.setTop(rect.bottom() + 1 - border_size / 2)
        elif guide == Guide.BorderExWest:
            bar_rect = widget.dockBarGeometry(QDockBar.West)
            if bar_rect.isValid():
                rect = bar_rect
            else:
                rect.setWidth(border_size / 2)

        # compass hits
        elif guide == Guide.CompassNorth:
            rect.setHeight(rect.height() / 3)
        elif guide == Guide.CompassEast:
            rect.setLeft(2 * rect.width() / 3)
        elif guide == Guide.CompassSouth:
            rect.setTop(2 * rect.height() / 3)
        elif guide == Guide.CompassWest:
            rect.setWidth(rect.width() / 3)
        elif guide == Guide.CompassCenter:
            pass  # nothing to do
        elif guide == Guide.CompassExNorth:
            pass  # nothing to do
        elif guide == Guide.CompassExEast:
            pass  # nothing to do
        elif guide == Guide.CompassExSouth:
            pass  # nothing to do
        elif guide == Guide.CompassExWest:
            pass  # nothing to do

        # splitter handle hits
        elif guide == Guide.SplitHorizontal:
            wo, r = divmod(border_size - rect.width(), 2)
            rect.setWidth(2 * (wo + r) + rect.width())
            rect.moveLeft(rect.x() - (wo + r))
        elif guide == Guide.SplitVertical:
            ho, r = divmod(border_size - widget.height(), 2)
            rect.setHeight(2 * (ho + r) + rect.height())
            rect.moveTop(rect.y() - (ho + r))

        # single center
        elif guide == Guide.AreaCenter:
            pass  # nothing to do

        # default no-op
        else:
            return QRect()

        pt = widget.mapToGlobal(rect.topLeft())
        return QRect(pt, rect.size())

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def guide_at(self, pos):
        """ Get the dock guide for a given position.

        Parameters
        ----------
        pos : QPoint
            The position of interest, expressed in global coordinates.

        Returns
        -------
        result : Guide
            The guide enum which lies under the given point.

        """
        rose = self._rose
        pos = rose.mapFromGlobal(pos)
        return rose.guideAt(pos)

    def hide(self):
        """ Hide the overlay.

        This method will stop the timers and set the visibility of the
        guide rose and the rubber band to False.

        """
        self._rose_timer.stop()
        self._band_timer.stop()
        self._rose.hide()
        self._band.hide()

    def mouse_over_widget(self, widget, pos, empty=False):
        """ Update the overlays based on the mouse position.

        This handler should be invoked when the mouse hovers over a
        single widget (such as a floating dock container) as opposed to
        an area of docked widgets. The guide rose will be displayed in
        the center of the widget with no border guides.

        Parameters
        ----------
        widget : QWidget
            The widget under the mouse.

        pos : QPoint
            The hover position, expressed in the local coordinates of
            the widget.

        empty : bool, optional
            Whether the widget represents an empty widget. If this is
            True, a single center guide will be shown instead of the
            guide rose.

        """
        Mode = QGuideRose.Mode
        rose = self._rose
        target_mode = Mode.AreaCenter if empty else Mode.CompassEx
        self._target_rose_mode = target_mode
        if rose.mode() != target_mode:
            rose.setMode(Mode.NoMode)
            self._rose_timer.start(self.rose_delay)
            self._band_timer.start(self.band_delay)
        origin = widget.mapToGlobal(QPoint(0, 0))
        geo = QRect(origin, widget.size())
        dirty = rose.geometry() != geo
        if dirty:
            rose.hide()
            rose.setMode(Mode.NoMode)
            rose.setGeometry(geo)
        guide = rose.guideAt(pos, target_mode)
        if dirty or guide != self._last_guide:
            self._last_guide = guide
            self._target_band_geo = self._band_geometry(widget, guide)
            self._band_timer.start(self.band_delay)
        rose.setCenterPoint(QPoint(geo.width() / 2, geo.height() / 2))
        rose.mouseOver(pos)
        rose.show()

    def mouse_over_area(self, area, widget, pos):
        """ Update the overlays based on the mouse position.

        Parameters
        ----------
        area : QDockArea
            The dock area which contains the dock items onto which
            the overlay will be displayed.

        widget : QWidget
            The dock widget in the area which is under the mouse, or
            None if there is no relevant widget.

        pos : QPoint
            The hover position, expressed in the local coordinates of
            the overlayed dock area.

        """
        Mode = QGuideRose.Mode
        Guide = QGuideRose.Guide
        pane = area.centralPane()
        pos = pane.mapFrom(area, pos)

        if widget is None:
            if area.centralWidget() is None:
                self.mouse_over_widget(pane, pos, empty=True)
            return

        # Compute the target mode for the guide rose based on the dock
        # widget which lies under the mouse position.
        target_mode = Mode.Border
        if isinstance(widget, QDockContainer):
            target_mode |= Mode.CompassEx
        elif isinstance(widget, QDockTabWidget):
            target_mode |= Mode.Compass
        elif isinstance(widget, QDockSplitterHandle):
            if widget.orientation() == Qt.Horizontal:
                target_mode |= Mode.SplitHorizontal
            else:
                target_mode |= Mode.SplitVertical

        # Get the local area coordinates for the center of the widget.
        center = widget.mapTo(pane, QPoint(0, 0))
        center += QPoint(widget.width() / 2, widget.height() / 2)

        # Update the state of the rose. If it is to be hidden, it is
        # done so immediately. If the target mode is different from
        # the current mode, the rose is hidden and the state changes
        # are collapsed on a timer.
        rose = self._rose
        self._hover_pos = pos
        self._show_band = True
        self._target_rose_mode = target_mode
        if target_mode != rose.mode():
            rose.setMode(Mode.Border)
            self._rose_timer.start(self.rose_delay)
            self._show_band = False

        # Update the geometry of the rose if needed. This ensures that
        # the rose does not change geometry while visible.
        origin = pane.mapToGlobal(QPoint(0, 0))
        geo = QRect(origin, pane.size())
        dirty = rose.geometry() != geo
        if dirty:
            rose.hide()
            rose.setMode(Mode.NoMode)
            rose.setGeometry(geo)

        # Hit test the rose and update the target geometry for the
        # rubber band if the target guide has changed.
        rose.setCenterPoint(center)
        guide = rose.guideAt(pos, target_mode)
        if dirty or guide != self._last_guide:
            self._last_guide = guide
            if guide >= Guide.BorderNorth and guide <= Guide.BorderWest:
                band_geo = self._band_geometry(pane, guide)
            elif guide >= Guide.BorderExNorth and guide <= Guide.BorderExWest:
                band_geo = self._band_geometry(area, guide)
            else:
                band_geo = self._band_geometry(widget, guide)
            self._target_band_geo = band_geo
            self._band_timer.start(self.band_delay)

        # Finally, make the rose visible and issue a mouseover command
        # so that the guides are highlighted.
        rose.mouseOver(pos)
        rose.show()

########NEW FILE########
__FILENAME__ = dock_resources
# -*- coding: utf-8 -*-

# Resource object code
#
# Created: Tue Jul 2 13:23:21 2013
#      by: The Resource Compiler for PyQt (Qt v4.8.3)
#
# WARNING! All changes made in this file will be lost!

# this line manually edited
from enaml.qt import QtCore

qt_resource_data = "\
\x00\x00\x02\x61\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x6f\x00\x00\x00\x6f\x08\x06\x00\x00\x00\xe2\xc5\x9e\x60\
\x00\x00\x00\x04\x73\x42\x49\x54\x08\x08\x08\x08\x7c\x08\x64\x88\
\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x0e\xc4\x00\x00\x0e\xc4\
\x01\x95\x2b\x0e\x1b\x00\x00\x02\x03\x49\x44\x41\x54\x78\x9c\xed\
\xdc\xc1\x49\xc5\x40\x14\x46\xe1\xff\xe9\x2b\x2d\xb5\xd8\x42\xb2\
\x75\xf7\xd2\x82\x6d\x58\x43\x96\xf6\x93\x9d\x2e\x64\xe0\x21\x88\
\x20\x38\x77\xce\x78\x4e\x03\x73\xc9\x47\x36\x21\x73\x2f\x19\xa8\
\x75\x5d\xdf\xab\x67\xf8\xa9\x7d\xdf\x2f\xd5\x33\xb4\xae\xd5\x03\
\x7c\xed\x76\xbb\xbd\x54\xcf\xf0\x5d\xdb\xb6\x3d\x55\xcf\x70\xdf\
\x43\xf5\x00\xf6\xfb\xc4\x03\x27\x1e\x38\xf1\xc0\x89\x07\x4e\x3c\
\x70\xe2\x81\x13\x0f\x9c\x78\xe0\xc4\x03\x27\x1e\x38\xf1\xc0\x89\
\x07\x4e\x3c\x70\xe2\x81\x13\x0f\x9c\x78\xe0\xc4\x03\x27\x1e\x38\
\xf1\xc0\x89\x07\x4e\x3c\x70\xe2\x81\x13\x0f\xdc\x63\xf5\x00\xad\
\x75\x5d\xdf\x47\xfe\xe1\x36\x49\x96\x65\x79\x3b\xcf\xf3\xf5\x38\
\x8e\xe7\xea\x59\x92\x41\xf0\x08\x70\xad\x91\x00\xcb\xf1\x48\x70\
\xad\x51\x00\x4b\xf1\x88\x70\xad\x11\x00\xcb\xf0\xc8\x70\xad\x6a\
\xc0\x12\xbc\x19\xe0\x5a\x95\x80\xdd\xf1\x66\x82\x6b\x55\x01\x76\
\xc5\x9b\x11\xae\x55\x01\xd8\x0d\x6f\x66\xb8\x56\x6f\xc0\x4b\xaf\
\xab\xc4\xb3\xc3\xdd\xd7\xeb\x06\xed\xe5\x3f\xbc\x11\x33\xb6\x6d\
\xdb\x93\xdf\x36\xc1\x89\x07\x4e\x3c\x70\xe2\x81\x13\x0f\x9c\x78\
\xe0\xc4\x03\x27\x1e\x38\xf1\xc0\x89\x07\x4e\x3c\x70\xe2\x81\x13\
\x0f\x9c\x78\xe0\xc4\x03\x27\x1e\x38\xf1\xc0\x89\x07\x4e\x3c\x70\
\xe2\x81\x13\x0f\x9c\x78\xe0\xc4\x03\x27\x1e\x38\xf1\xc0\x89\x07\
\x4e\x3c\x70\xe2\x81\x13\x0f\x9c\x78\xe0\xc4\x03\x27\x1e\x38\xf1\
\xc0\x89\x07\x4e\x3c\x70\xe2\x81\x13\x0f\x9c\x78\xe0\xdc\xc3\xf2\
\x07\x75\xdb\xc3\xd2\xe3\x90\xe4\x7f\x6c\x40\x4a\x3e\xe1\xf6\x7d\
\xef\xf2\x5c\xbb\xad\xaf\x3a\x8e\xe3\xf9\x3c\xcf\xd7\x65\x59\xde\
\x7a\x9d\xd9\xbb\x9e\x70\x49\xe7\xc5\x71\x33\x03\xf6\x86\x4b\x0a\
\x56\x36\xce\x08\x58\x01\x97\x14\x2d\x4b\x9d\x09\xb0\x0a\x2e\x29\
\x5c\x53\x3c\x03\x60\x25\x5c\x52\xbc\x20\x9c\x0c\x58\x0d\x97\x0c\
\xb0\x9a\x9f\x08\x38\x02\x5c\x32\x00\x5e\xc2\x02\x1c\x05\x2e\x19\
\x04\x2f\x61\x00\x8e\x04\x97\xf8\x6d\x13\x9d\x78\xe0\xc4\x03\x27\
\x1e\x38\xf1\xc0\x89\x07\x4e\x3c\x70\xe2\x81\x13\x0f\x9c\x78\xe0\
\xc4\x03\x27\x1e\x38\xf1\xc0\x89\x07\x4e\x3c\x70\xe2\x81\x13\x0f\
\x9c\x78\xe0\xc4\x03\x27\x1e\x38\xf1\xc0\x89\x07\x4e\x3c\x70\xe2\
\x81\xbb\x56\x0f\xf0\xb5\x5e\x57\x82\x67\xe8\x03\xdb\xf1\xfe\x32\
\xdf\x7a\xb4\x66\x00\x00\x00\x00\x49\x45\x4e\x44\xae\x42\x60\x82\
\
\x00\x00\x01\xda\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x1f\x00\x00\x00\x1f\x08\x02\x00\x00\x00\x90\xcc\x81\x6e\
\x00\x00\x00\x01\x73\x52\x47\x42\x00\xae\xce\x1c\xe9\x00\x00\x00\
\x04\x67\x41\x4d\x41\x00\x00\xb1\x8f\x0b\xfc\x61\x05\x00\x00\x00\
\x09\x70\x48\x59\x73\x00\x00\x0e\xc3\x00\x00\x0e\xc3\x01\xc7\x6f\
\xa8\x64\x00\x00\x00\x1a\x74\x45\x58\x74\x53\x6f\x66\x74\x77\x61\
\x72\x65\x00\x50\x61\x69\x6e\x74\x2e\x4e\x45\x54\x20\x76\x33\x2e\
\x35\x2e\x31\x30\x30\xf4\x72\xa1\x00\x00\x01\x49\x49\x44\x41\x54\
\x48\x4b\xbd\xcc\xbd\x4a\x03\x51\x10\x86\x61\x2f\xce\x8b\xf0\x46\
\x2c\x2c\x2c\x2c\x2c\x14\x2c\x62\x61\x21\xc1\xc6\xc2\xc2\xc2\xc2\
\xc2\xc2\x1b\x10\x11\x11\x91\x20\x22\x31\x6e\xf6\xf7\xec\x6e\xf6\
\x37\xd9\x24\x36\xce\x30\x73\xa6\x90\x54\x0e\x67\xe1\xed\xbe\x8f\
\x67\xeb\x78\x30\x74\x17\xea\x6d\xb7\x76\x11\xeb\xcd\x62\xe5\xa2\
\x5e\xf4\x7a\xbe\xa4\xb6\x77\xf6\xf4\x89\xd6\x8b\x5e\xb5\x1d\xf5\
\xe7\xf7\xbf\x44\xeb\x45\x2f\x9b\x05\x05\xdb\x8f\xb9\xd7\x04\x82\
\x68\x9b\xf4\xf8\x4e\xd3\x06\xbd\xa8\xe7\x14\xea\xe1\xad\x26\x10\
\x44\x63\x7d\x56\xb5\x14\xea\xfe\x8d\x26\x10\x44\x63\x3d\x2f\x1b\
\x0a\xb6\xb5\x77\xad\x09\x04\xd1\x58\xcf\x8a\x86\x42\x7d\x72\xa5\
\x09\x04\xd1\x58\x37\x79\x4d\xa1\x3e\xbe\xd4\x04\x82\x68\xac\x27\
\x59\x45\xc1\xb6\xfa\xbc\xd0\x04\x82\x68\xac\xc7\x69\x49\xa1\xfe\
\x71\xae\x09\x04\xd1\x58\x8f\x4c\x41\xa1\xfe\x7e\xa6\x09\x04\xd1\
\x58\x0f\x93\x82\x42\x7d\x74\xaa\x09\x04\xd1\x58\x0f\xe2\x19\x05\
\xdb\xf2\xed\x44\x13\x08\xa2\xb1\xee\x47\x39\x85\xfa\xeb\x91\x26\
\x10\x44\x63\x7d\x1a\xe5\x14\xea\x2f\x87\x9a\x40\x10\xcd\xea\x61\
\x46\xc1\xd6\x3d\x1f\x68\x42\xdd\x6a\xac\x7b\x41\x46\xa1\xfe\xb4\
\xaf\x09\x04\xd1\x58\xff\x0e\x52\x0a\xf5\x47\x55\x20\x88\x66\x75\
\x3f\xa5\x50\x7f\xd8\xd5\x84\xba\xd5\x58\x9f\xf8\x86\x82\x4d\x9f\
\x68\xac\x7f\x4d\x8d\x8b\xac\xee\x25\x2e\x62\x7d\xec\x25\x2e\x62\
\xdd\x55\x83\xe1\x2f\x82\x32\x64\x70\x80\xdc\x0e\xed\x00\x00\x00\
\x00\x49\x45\x4e\x44\xae\x42\x60\x82\
\x00\x00\x02\xcb\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x8b\x00\x00\x00\x8b\x08\x06\x00\x00\x00\x51\x19\x6a\xff\
\x00\x00\x00\x04\x73\x42\x49\x54\x08\x08\x08\x08\x7c\x08\x64\x88\
\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x0e\xc4\x00\x00\x0e\xc4\
\x01\x95\x2b\x0e\x1b\x00\x00\x02\x6d\x49\x44\x41\x54\x78\x9c\xed\
\xdd\xb1\x6d\xdc\x50\x10\x45\xd1\x59\x5b\xa5\xb1\x16\xb5\x40\xa6\
\xca\x96\x2d\xb8\x0d\xd5\xc0\x50\xfd\x30\x93\x23\x02\x4e\x0c\x3d\
\x63\xd7\x20\xe7\xeb\x9c\x0a\x1e\xb0\x77\x23\x02\xf3\x6f\x35\x80\
\x79\x9e\x3f\xcf\xde\xf0\x95\x75\x5d\x6f\x67\x6f\x78\xd4\xcb\xd9\
\x03\x9e\xe5\x7e\xbf\xff\x3a\x7b\xc3\xdf\x2c\xcb\xf2\x7a\xf6\x86\
\x67\xf8\x71\xf6\x00\xfa\x10\x0b\x31\xb1\x10\x13\x0b\x31\xb1\x10\
\x13\x0b\x31\xb1\x10\x13\x0b\x31\xb1\x10\x13\x0b\x31\xb1\x10\x13\
\x0b\x31\xb1\x10\x13\x0b\x31\xb1\x10\x13\x0b\x31\xb1\x10\x13\x0b\
\x31\xb1\x10\x13\x0b\x31\xb1\x10\x13\x0b\x31\xb1\x10\x13\x0b\x31\
\xb1\x10\x13\x0b\x31\xb1\x10\x13\x0b\x31\xb1\x10\x13\x0b\x31\xb1\
\x10\x13\x0b\x31\xb1\x10\x13\x0b\x31\xb1\x10\x13\x0b\x31\xb1\x10\
\x13\x0b\xb1\x9f\x67\x0f\x78\xd4\x3c\xcf\x9f\x57\x3e\x6b\x5a\x55\
\x35\x4d\xd3\xc7\xbe\xef\xef\xdb\xb6\xbd\x9d\xbd\xe5\x11\xad\x63\
\xe9\x10\xca\x61\x84\x60\xda\xc6\xd2\x29\x94\x43\xf7\x60\x5a\xc6\
\xd2\x31\x94\x43\xe7\x60\xda\xc5\xd2\x39\x94\x43\xd7\x60\x5a\xc5\
\x32\x42\x28\x87\x8e\xc1\xb4\x89\x65\xa4\x50\x0e\xdd\x82\x69\x11\
\xcb\x88\xa1\x1c\x3a\x05\x73\xf9\x58\x46\x0e\xe5\xd0\x25\x98\xdb\
\xd5\x1f\x76\x1a\x3d\x94\x3f\x5d\xfd\x5d\xa2\xdb\x77\xf8\xe7\xf2\
\xb8\x65\x59\x5e\x7d\x1b\x22\x26\x16\x62\x62\x21\x26\x16\x62\x62\
\x21\x26\x16\x62\x62\x21\x26\x16\x62\x62\x21\x26\x16\x62\x62\x21\
\x26\x16\x62\x62\x21\x26\x16\x62\x62\x21\x26\x16\x62\x62\x21\x26\
\x16\x62\x62\x21\x26\x16\x62\x62\x21\x26\x16\x62\x62\x21\x26\x16\
\x62\x62\x21\x26\x16\x62\x62\x21\x26\x16\x62\x62\x21\x26\x16\x62\
\x62\x21\x26\x16\x62\x62\x21\x26\x16\x62\x62\x21\x26\x16\x62\x62\
\x21\x26\x16\x62\xee\xe0\x5e\xc8\xe5\xef\xe0\x9e\x3d\xe0\x2b\xdf\
\xe5\x4e\xef\xb2\x2c\xaf\xeb\xba\x5e\xfa\xf7\xb8\xfc\x39\xf6\x6d\
\xdb\xde\xf6\x7d\x7f\x9f\xa6\xe9\xe3\xec\x2d\xff\x4b\x87\x50\xaa\
\x1a\xc4\x52\x35\x76\x30\x5d\x42\xa9\x6a\x12\x4b\xd5\x98\xc1\x74\
\x0a\xa5\xaa\x51\x2c\x55\x63\x05\xd3\x2d\x94\xaa\x66\xb1\x54\x8d\
\x11\x4c\xc7\x50\xaa\x1a\xc6\x52\xd5\x3b\x98\xae\xa1\x54\x35\x8d\
\xa5\xaa\x67\x30\x9d\x43\xa9\x6a\x1c\x4b\x55\xaf\x60\xba\x87\x52\
\xd5\x3c\x96\xaa\x1e\xc1\x8c\x10\x4a\x95\x6f\x43\xfc\x03\xb1\x10\
\x13\x0b\x31\xb1\x10\x13\x0b\x31\xb1\x10\x13\x0b\x31\xb1\x10\x13\
\x0b\x31\xb1\x10\x13\x0b\x31\xb1\x10\x13\x0b\x31\xb1\x10\x13\x0b\
\x31\xb1\x10\x13\x0b\x31\xb1\x10\x13\x0b\x31\xb1\x10\x13\x0b\x31\
\xb1\x10\x13\x0b\x31\xb1\x10\x13\x0b\x31\xb1\x10\x13\x0b\x31\xb1\
\x10\x13\x0b\x31\xb1\x10\x13\x0b\x31\xb1\x10\x13\x0b\x31\xb1\x10\
\x13\x0b\x31\xb1\x10\x13\x0b\x31\xb1\x10\x7b\x39\x7b\xc0\xb3\x5c\
\xfd\x61\xa7\x11\xfc\x06\x85\xf5\xfe\x6a\xa4\x26\xa3\xb0\x00\x00\
\x00\x00\x49\x45\x4e\x44\xae\x42\x60\x82\
\x00\x00\x01\xe1\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x13\x00\x00\x00\x1f\x08\x02\x00\x00\x00\x8a\xf0\x61\xe0\
\x00\x00\x00\x01\x73\x52\x47\x42\x00\xae\xce\x1c\xe9\x00\x00\x00\
\x04\x67\x41\x4d\x41\x00\x00\xb1\x8f\x0b\xfc\x61\x05\x00\x00\x00\
\x09\x70\x48\x59\x73\x00\x00\x0e\xc3\x00\x00\x0e\xc3\x01\xc7\x6f\
\xa8\x64\x00\x00\x00\x1a\x74\x45\x58\x74\x53\x6f\x66\x74\x77\x61\
\x72\x65\x00\x50\x61\x69\x6e\x74\x2e\x4e\x45\x54\x20\x76\x33\x2e\
\x35\x2e\x31\x30\x30\xf4\x72\xa1\x00\x00\x01\x50\x49\x44\x41\x54\
\x48\x4b\xa5\x95\x39\x4a\x04\x61\x10\x46\xe7\x70\x1e\xc2\x8b\x18\
\x18\x18\x18\x18\x28\x18\x68\x60\x20\x62\x62\x60\x60\x60\x60\x60\
\xe0\x05\x44\x44\x44\x64\x10\x91\x59\x7a\x5f\xa7\xd7\x99\x9e\x25\
\xb1\x6a\xaa\xfe\x02\xc1\x1a\xe9\x16\x5e\xf6\xbe\x47\x85\xd5\x3b\
\x3a\xb9\xe8\x46\x0f\xb2\xba\x59\xb6\x05\x2a\x2c\xab\xd9\xa2\x2d\
\xff\x2e\xcb\xe9\x9c\xd8\xda\xde\xdd\x8c\x2c\xf9\x66\xf7\xb2\xa8\
\x1b\xe2\xcf\x9b\xb2\xe4\x9b\xdd\xcb\xbc\x9a\x11\x70\x73\x15\x3d\
\x68\x80\x95\x25\xdf\xfc\x51\x06\xf7\x2b\x85\x5f\xca\xac\x9c\x12\
\x78\xd3\xbb\xd3\x00\x2b\x4b\xbe\x39\x29\x6a\x02\x4b\xe7\x56\x03\
\xac\x2c\xb9\x4c\xf3\x8a\x00\xb7\xb4\x6e\x34\xc0\xca\x92\xcb\x24\
\xab\x08\x2c\x47\xd7\x1a\x60\x65\xc9\x65\x94\x96\x04\x96\x83\x2b\
\x0d\xb0\xb2\xe4\x32\x4c\x0a\x02\xdc\xe2\xeb\x52\x03\xac\x2c\xb9\
\x0c\xe2\x9c\xc0\xf2\xf3\x5c\x03\xac\x2c\xb9\xf4\xa3\x8c\xc0\xf2\
\xe3\x4c\x03\xac\x2c\xb9\xf4\xc2\x8c\xc0\xb2\x7f\xaa\x01\x56\x96\
\x5c\xba\xc1\x84\x00\x37\x7f\x3f\xd6\x00\x2b\x4b\x2e\x1d\x3f\x25\
\xb0\x7c\x3b\xd4\x00\x2b\x4b\x2e\x6d\x3f\x25\xb0\x7c\x3d\xd0\x00\
\x2b\x4b\x53\x7a\x89\xbd\x06\x5c\xf3\xb2\xaf\x81\xa5\x59\x72\x69\
\xb9\x09\x81\xe5\xf3\x9e\x06\x58\x59\x72\x39\x76\x63\x02\xcb\x27\
\x15\xb0\xb2\x34\xa5\x13\x8f\xd7\x60\xf9\xb8\xa3\x81\xa5\x59\x72\
\x39\x72\x22\x02\xdc\x66\x64\xc9\xe5\xd0\x8e\xda\x62\x4a\x2b\x1c\
\xb6\x84\xcb\x81\x15\xb6\x85\xcb\x6e\xbf\xec\x1b\xdd\xce\x28\xdf\
\xf5\x17\x62\x31\x00\x00\x00\x00\x49\x45\x4e\x44\xae\x42\x60\x82\
\
\x00\x00\x01\xb8\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x1f\x00\x00\x00\x1f\x08\x02\x00\x00\x00\x90\xcc\x81\x6e\
\x00\x00\x00\x01\x73\x52\x47\x42\x00\xae\xce\x1c\xe9\x00\x00\x00\
\x04\x67\x41\x4d\x41\x00\x00\xb1\x8f\x0b\xfc\x61\x05\x00\x00\x00\
\x09\x70\x48\x59\x73\x00\x00\x0e\xc3\x00\x00\x0e\xc3\x01\xc7\x6f\
\xa8\x64\x00\x00\x00\x1a\x74\x45\x58\x74\x53\x6f\x66\x74\x77\x61\
\x72\x65\x00\x50\x61\x69\x6e\x74\x2e\x4e\x45\x54\x20\x76\x33\x2e\
\x35\x2e\x31\x30\x30\xf4\x72\xa1\x00\x00\x01\x27\x49\x44\x41\x54\
\x48\x4b\xbd\xd2\x3d\x4e\xc3\x40\x10\x86\x61\x0e\xc7\x21\x38\x0a\
\xd4\x74\x48\x29\x42\x1a\x8a\xc8\x14\xd4\x34\x49\xc3\x15\x68\xa8\
\x68\x68\x02\x38\x76\x9c\xf5\x4f\xfc\x9b\x38\x09\x0d\x63\xcd\xe7\
\x45\x5a\x27\x01\xb1\x1a\x4b\xaf\xb6\xd8\x19\x3d\xdb\xec\xd9\xcd\
\x70\x2c\x57\xa3\x57\xf5\x5e\x22\xe8\xe5\x66\x27\x51\x2f\x7a\xb1\
\xde\x72\xe7\x17\x57\xf6\x69\xad\x17\x3d\xaf\x6a\xce\xd8\xfb\x5f\
\x5a\xeb\x45\xcf\xca\x0d\x47\xb3\x2f\xf5\x64\x13\x09\x5a\x3b\xa0\
\xef\xbd\x47\x9b\x0e\xe8\x69\xb1\xe6\x1a\x7d\xf6\x60\x13\x09\x5a\
\x83\xbe\xca\x2b\x8e\x66\xbb\xb7\x3b\x9b\x48\xd0\x1a\xf4\x24\x2b\
\x39\x9a\x6d\x5f\x07\x36\x91\xa0\x35\xe8\x71\x5a\x72\x8d\xfe\x72\
\x6d\x13\x09\x5a\x83\x1e\x26\x05\x47\xb3\xfa\xf9\xd2\x26\x12\xb4\
\x06\x5d\xc5\x39\x47\x33\xfb\xb4\x06\x7d\x19\x65\x12\x41\x0f\xc2\
\x54\x22\xe8\x0b\x95\x4a\x04\xdd\x5f\xae\x24\x82\xee\x05\x89\x44\
\xd0\xe7\x41\xf2\x97\x46\xf7\x53\xfa\x12\x74\x1a\xf7\xc7\x6a\xf5\
\x45\xfc\x6b\x4c\x73\xcd\x03\x9d\x85\x6e\xd0\x5d\x3f\x3e\xdd\xc8\
\xf9\xa1\xf1\x80\x33\x35\x76\xba\x41\xff\xf4\xa3\x13\xdd\x3a\x13\
\x83\xe6\xe8\xde\xd8\x34\x6a\x75\x2f\x92\x08\xfa\x87\x17\x4a\x04\
\xfd\x7d\x1e\x4a\xd4\xea\xae\x92\x08\xfa\xcc\x55\x12\x41\x97\x6a\
\x38\xfe\x06\xe0\x80\xad\xee\xa3\x69\x89\x6f\x00\x00\x00\x00\x49\
\x45\x4e\x44\xae\x42\x60\x82\
\x00\x00\x00\xc2\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x29\x00\x00\x00\x29\x08\x06\x00\x00\x00\xa8\x60\x00\xf6\
\x00\x00\x00\x04\x73\x42\x49\x54\x08\x08\x08\x08\x7c\x08\x64\x88\
\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x0e\xc4\x00\x00\x0e\xc4\
\x01\x95\x2b\x0e\x1b\x00\x00\x00\x64\x49\x44\x41\x54\x58\x85\xed\
\xd9\xc1\x0d\x80\x30\x0c\xc0\xc0\x14\x31\x2b\x2b\x24\x23\x64\x06\
\x96\x85\x09\x90\x78\x58\x6a\x2b\xd9\x13\xdc\xdf\x23\x33\x9f\x58\
\xbc\x33\x22\xa2\xbb\xef\xd9\x90\xaf\xaa\xea\x3a\x66\x23\xfe\x24\
\x92\x4a\x24\x95\x48\x2a\x91\x54\x22\xa9\x44\x52\x89\xa4\x12\x49\
\x25\x92\x4a\x24\x95\x48\x2a\x91\x54\x22\xa9\x44\x52\x89\xa4\x12\
\x49\x25\x92\x4a\x24\xd5\x16\xc8\xb1\xc3\xc7\x79\x01\x28\xc6\x09\
\x1b\x33\x94\xbf\xef\x00\x00\x00\x00\x49\x45\x4e\x44\xae\x42\x60\
\x82\
\x00\x00\x01\xc2\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x1f\x00\x00\x00\x1f\x08\x02\x00\x00\x00\x90\xcc\x81\x6e\
\x00\x00\x00\x01\x73\x52\x47\x42\x00\xae\xce\x1c\xe9\x00\x00\x00\
\x04\x67\x41\x4d\x41\x00\x00\xb1\x8f\x0b\xfc\x61\x05\x00\x00\x00\
\x09\x70\x48\x59\x73\x00\x00\x0e\xc3\x00\x00\x0e\xc3\x01\xc7\x6f\
\xa8\x64\x00\x00\x00\x1a\x74\x45\x58\x74\x53\x6f\x66\x74\x77\x61\
\x72\x65\x00\x50\x61\x69\x6e\x74\x2e\x4e\x45\x54\x20\x76\x33\x2e\
\x35\x2e\x31\x30\x30\xf4\x72\xa1\x00\x00\x01\x31\x49\x44\x41\x54\
\x48\x4b\xbd\xcd\xbb\x4e\xc3\x40\x10\x85\x61\x1e\x8e\x87\xe0\x4d\
\x10\x25\x6d\xba\x88\x36\xb4\xb4\xd4\x3c\x02\x05\x0d\x0d\x05\x12\
\x04\xc7\x8e\xb3\xbe\xc4\xd7\xc4\x49\x68\x38\xab\x99\x1d\xad\x28\
\x67\xb5\x96\x7e\x59\x23\x9d\xd5\xe7\xab\xc5\x72\x15\x2f\xab\x8f\
\xd3\x25\x46\xac\x0f\xc7\x73\x8c\x66\xd1\xfb\xc3\x89\xba\xbe\xb9\
\x0b\x4f\xb4\x59\xf4\x6e\x9c\xa8\x7f\xef\x74\x89\x36\x8b\xde\x0e\
\x47\x0a\x9b\xdc\xba\x7c\x61\x16\xbd\xe9\x0f\x14\x36\xb9\x75\xf9\
\x02\xeb\xfb\x6e\xa4\xb0\xc9\xad\xcb\x17\x58\xaf\xdb\x81\xc2\x26\
\xb7\x2e\x5f\x60\xbd\x6a\x06\x0a\x1b\xfa\x35\x2f\xea\x2f\x12\x8d\
\xf5\xa2\xee\x29\xfb\x28\x7b\x0e\x09\x82\x68\xac\x9b\xaa\xa3\xb0\
\x5d\xd6\x4f\x21\x41\x10\x8d\xf5\x5d\xd9\x52\xd8\xce\x9f\x8f\x21\
\x41\x10\x8d\xf5\xbc\x68\x28\xab\x7f\x3c\x84\x04\x41\x34\xd6\xb7\
\xa6\xa1\xb0\x9d\xde\x17\x21\x41\x10\x8d\xf5\x6c\xb7\xa7\xb0\x4d\
\x6f\xf7\x21\x41\x10\x8d\xf5\x34\xaf\x29\x6c\xf6\x07\xaf\xb7\xea\
\x2f\x12\x8d\xf5\x4d\x5e\x53\xd8\xe4\xd6\xe5\x0b\x4e\xdf\x56\x94\
\xdd\xdc\xad\xcb\x17\x58\x4f\xb2\x8a\xc2\x26\xb7\x2e\x5f\x60\xfd\
\x27\x2b\x29\x6c\x72\xeb\xf2\x05\xa7\xa7\x25\x65\x37\x77\xeb\xf2\
\x05\xd6\xd7\x69\x41\x61\x0b\x4f\x34\xd6\xbf\x37\x45\x8c\x9c\x9e\
\x98\x18\xb1\xfe\x95\x98\x18\xb1\x1e\xab\xe5\xea\x0f\x0e\x98\x91\
\x35\xc6\xa1\x36\xaa\x00\x00\x00\x00\x49\x45\x4e\x44\xae\x42\x60\
\x82\
\x00\x00\x01\x4e\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x0a\x00\x00\x00\x1f\x08\x02\x00\x00\x00\x51\x4b\xcb\xc2\
\x00\x00\x00\x01\x73\x52\x47\x42\x00\xae\xce\x1c\xe9\x00\x00\x00\
\x04\x67\x41\x4d\x41\x00\x00\xb1\x8f\x0b\xfc\x61\x05\x00\x00\x00\
\x09\x70\x48\x59\x73\x00\x00\x0b\x12\x00\x00\x0b\x12\x01\xd2\xdd\
\x7e\xfc\x00\x00\x00\x1a\x74\x45\x58\x74\x53\x6f\x66\x74\x77\x61\
\x72\x65\x00\x50\x61\x69\x6e\x74\x2e\x4e\x45\x54\x20\x76\x33\x2e\
\x35\x2e\x31\x30\x30\xf4\x72\xa1\x00\x00\x00\xbd\x49\x44\x41\x54\
\x38\x4f\x8d\xc9\xc9\x8d\xc2\x50\x00\x04\x51\x82\x23\x08\x52\x21\
\x05\x6e\xdc\x89\x6d\x00\x63\x63\xbc\xe1\x95\x65\xe6\x34\xa0\xea\
\xdf\xa7\x0f\xb2\x54\x97\xd2\x5b\x6c\xb6\xbb\x2f\xbd\x79\x7a\xfc\
\x45\x13\x8f\xf7\xdf\x68\xf3\x78\xb8\x3d\x69\xb9\x5a\xbf\xf2\xce\
\xe3\x7e\x7a\x10\xec\x9d\xc7\xdd\x78\x27\xd8\x3b\x8f\xdb\xe1\x46\
\xb0\x57\x7c\xed\x27\x82\xbd\xe2\xa6\x1b\x09\xf6\x8a\xeb\x76\x24\
\xd8\x2b\x2e\x9b\x81\x60\xaf\xb8\xa8\x7b\x82\xbd\xe2\x4b\xd5\x11\
\xec\x15\xe7\x65\x4b\xb0\x57\x7c\x2e\x5a\x82\xbd\xe2\xec\x72\x25\
\xd8\x2b\x4e\xf3\x86\x60\xaf\xf8\x94\x37\x04\x7b\x03\x9f\x6b\x12\
\x87\x15\x27\x59\x4d\xb0\x57\x7c\xcc\x2a\x82\xbd\x81\xd3\x8a\xc4\
\x61\xc5\x87\xb4\x24\xd8\x2b\xde\x9f\xca\x68\x81\x93\x22\x9a\xf8\
\x27\x29\xa2\x89\x3f\xb6\xdd\xfd\x03\xaf\x34\xbc\x27\xb0\x9e\x89\
\xd7\x00\x00\x00\x00\x49\x45\x4e\x44\xae\x42\x60\x82\
\x00\x00\x02\x22\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x1f\x00\x00\x00\x1f\x08\x02\x00\x00\x00\x90\xcc\x81\x6e\
\x00\x00\x00\x01\x73\x52\x47\x42\x00\xae\xce\x1c\xe9\x00\x00\x00\
\x04\x67\x41\x4d\x41\x00\x00\xb1\x8f\x0b\xfc\x61\x05\x00\x00\x00\
\x09\x70\x48\x59\x73\x00\x00\x0e\xc3\x00\x00\x0e\xc3\x01\xc7\x6f\
\xa8\x64\x00\x00\x00\x1a\x74\x45\x58\x74\x53\x6f\x66\x74\x77\x61\
\x72\x65\x00\x50\x61\x69\x6e\x74\x2e\x4e\x45\x54\x20\x76\x33\x2e\
\x35\x2e\x31\x30\x30\xf4\x72\xa1\x00\x00\x01\x91\x49\x44\x41\x54\
\x48\x4b\xbd\xcd\xcb\x4a\xc3\x50\x10\xc6\x71\x1f\xce\x87\xf0\x45\
\x5c\xb8\x70\xe1\xc2\x85\x82\x8b\x8a\xd6\x0b\x45\x5a\x5b\x70\xe1\
\xc2\x85\xb5\x5d\xf8\x02\x22\x22\x22\x22\x22\x52\x6b\x9a\x5e\x92\
\x26\x4d\xdb\xf4\xee\xc6\x19\x32\x19\x0e\xa7\x65\x7a\x10\x52\xf8\
\xad\x26\xdf\xf9\x67\x6d\x3f\x95\x49\x0e\xd6\x07\xe3\x59\x12\xa8\
\x1e\x8e\xa6\x49\x58\x49\xbd\x3f\x9c\x18\x5a\xdf\xd8\x5a\x8a\xc7\
\x2b\xa9\xf7\x06\x63\x43\x5a\x68\x21\x1e\xaf\xa4\xde\x0d\x47\x86\
\xe0\xf1\xaf\x7b\x2f\x80\x01\x8f\xff\x55\x6f\x95\x05\x0b\xea\x41\
\x7f\x68\x08\xeb\x8d\x5b\x01\x0c\x78\x4c\xf5\x4e\x6f\xa0\x3a\x2b\
\x94\xb5\x0b\xc3\xba\x7d\x23\x80\x01\x8f\xa9\xee\x77\x43\x15\x2c\
\x4e\x0b\x25\xed\x18\x81\x4f\x33\xeb\x5a\x00\x03\x1e\x53\xdd\x0b\
\x42\x15\x2c\xf0\x07\xf9\x92\x76\x07\x58\xaf\x5e\x09\x60\xc0\x63\
\xaa\xbb\x7e\x5f\x15\xd5\xc1\xc9\x65\x69\xfe\xd3\xac\x92\x17\xc0\
\x80\xc7\x54\x77\xbc\x9e\x8a\xeb\x60\xfe\xd3\xf4\xeb\x42\xa0\x3e\
\xa1\x7a\xab\xdd\x55\x71\x3a\x9d\xbb\x9b\xff\x34\xfd\x3c\x17\xc0\
\x80\xc7\x54\x6f\xba\x81\x2a\x4a\x1f\xe7\x8a\xda\x1d\x60\xfd\x23\
\x2d\x80\x01\x8f\xa9\xde\x70\x02\x15\xa6\xb3\x45\xed\x18\xc1\xfa\
\xfb\xa1\x00\x06\x3c\xa6\x7a\xbd\xd5\x51\x1d\x65\x8b\xda\x85\xc1\
\xe3\xc9\xdb\x81\x00\x06\x3c\xa6\xba\xdd\xf4\x0d\x61\xfd\x75\x4f\
\x00\x03\x1e\x53\xbd\xd6\xf4\x0d\x61\xfd\x65\x57\x00\x03\x1e\xc7\
\xf5\x86\x67\x08\x1e\x8f\x9f\x77\x04\x58\x8f\xc7\x54\xb7\xea\x9e\
\x21\xac\x3f\x6d\x0b\x60\xc0\x63\xaa\xff\xd4\xdb\x86\xb0\xfe\x28\
\x81\x01\x8f\xe3\xba\xdd\x36\x84\xf5\x87\x4d\x01\xd6\xe3\x31\xd5\
\xab\xb6\x6b\x08\x1e\x2f\xc5\x63\xaa\x7f\xd7\xdc\x24\xc4\x75\xcb\
\x49\x02\xd5\x2b\x96\x93\x04\xaa\x27\x25\x95\xf9\x03\x6c\x41\xe7\
\xb2\x07\xe6\xaf\xd1\x00\x00\x00\x00\x49\x45\x4e\x44\xae\x42\x60\
\x82\
\x00\x00\x02\x24\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x1f\x00\x00\x00\x1f\x08\x02\x00\x00\x00\x90\xcc\x81\x6e\
\x00\x00\x00\x01\x73\x52\x47\x42\x00\xae\xce\x1c\xe9\x00\x00\x00\
\x04\x67\x41\x4d\x41\x00\x00\xb1\x8f\x0b\xfc\x61\x05\x00\x00\x00\
\x09\x70\x48\x59\x73\x00\x00\x0e\xc3\x00\x00\x0e\xc3\x01\xc7\x6f\
\xa8\x64\x00\x00\x00\x1a\x74\x45\x58\x74\x53\x6f\x66\x74\x77\x61\
\x72\x65\x00\x50\x61\x69\x6e\x74\x2e\x4e\x45\x54\x20\x76\x33\x2e\
\x35\x2e\x31\x30\x30\xf4\x72\xa1\x00\x00\x01\x93\x49\x44\x41\x54\
\x48\x4b\xbd\xcc\xbb\x4a\x03\x61\x10\x05\x60\x1f\xce\x87\xf0\x45\
\x2c\x52\x58\x58\x58\x28\x58\xc4\xc2\x42\x82\x8d\x85\x85\x85\x85\
\x85\x85\x2f\x20\x22\x22\x22\x22\x22\x31\xe6\x9e\xcd\xfd\xe6\x66\
\xb3\x8d\x27\xcc\xec\xe1\xe7\xff\x19\x10\xc3\x06\xbe\xe2\x30\x73\
\x38\x5b\x47\xc5\x52\x7e\x56\xeb\xb3\x78\x99\x07\x5d\x9f\xfe\x24\
\x79\xd8\xc8\xfa\x64\xbe\x10\xdb\x3b\x85\xf5\x71\x6d\x23\xeb\xe3\
\x59\x2c\xbc\xde\xff\x70\x6d\x23\xeb\xa3\xe9\x8f\xc0\x8f\x99\xd2\
\xe8\xce\xe2\x35\xc1\x5d\xf8\xd3\x3a\x8e\x69\xfb\x36\x64\x95\x99\
\x75\x7d\x38\x99\x0b\xfc\x98\x29\x6d\xde\x58\xbc\x26\xb8\x0b\xba\
\x3e\x18\xcf\x04\x7e\xcc\x84\x63\x5a\xbf\x0e\x59\x65\x66\x5d\xef\
\x8f\xa6\x02\x3f\x66\x5a\x56\xaf\x2c\x5e\x13\xdc\x05\x5d\xef\x0d\
\xa7\x02\x3f\x66\xc2\x71\x59\xb9\x0c\x59\x65\x66\x5d\x8f\xfa\x13\
\x81\x1f\x33\x2d\xcb\x17\x16\xaf\x09\xee\x82\xae\x77\x7a\x63\x81\
\x1f\x33\xe1\x98\x7c\x9e\x87\xac\x32\xb3\xae\xb7\xbb\x23\x81\x1f\
\x33\x25\x1f\x67\x16\xaf\x09\xee\x82\xae\xb7\xa2\xa1\xc0\x8f\x99\
\x70\x4c\xde\x4f\x43\x56\x99\x59\xd7\x9b\x9d\xa1\xc0\x8f\x99\x92\
\xb7\x13\x8b\xd7\x04\x77\x41\xd7\x1b\xed\x81\xc0\x8f\x99\x70\x5c\
\xbc\x1e\x87\xac\x32\xb3\xae\xd7\x5b\x7d\x81\x1f\x33\x2d\x5e\x0e\
\x2d\x5e\x13\xdc\x05\x5d\xaf\xb5\xfa\x02\x3f\x66\xc2\x71\xf1\x7c\
\x10\xb2\xca\xcc\xd9\x7a\xb3\x27\x56\xbf\x2c\x53\xfc\xb4\x6f\xf1\
\x9a\xe0\x2e\xe8\x7a\xb5\xd1\x13\xf8\x31\x13\x8e\xf1\xe3\x5e\xc8\
\x2a\x33\xeb\xfa\x77\xa3\x2b\xf0\x63\xa6\xf8\xa1\x60\xf1\x9a\xe0\
\x2e\x64\xeb\xf5\xae\x58\xfd\xb2\x4c\x38\xc6\xf7\xbb\x21\xab\xcc\
\xac\xeb\x95\x7a\x24\xf0\x5b\x1f\xd7\x74\xfd\xab\x16\xe5\x21\x5b\
\xaf\x76\xf2\xa0\xeb\xe5\x6a\x27\x0f\xba\x9e\x97\x62\xe9\x17\xda\
\xb5\x98\x10\x31\x42\x5d\xab\x00\x00\x00\x00\x49\x45\x4e\x44\xae\
\x42\x60\x82\
\x00\x00\x00\xed\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x1f\x00\x00\x00\x0a\x08\x02\x00\x00\x00\xc3\xd7\x12\x46\
\x00\x00\x00\x01\x73\x52\x47\x42\x00\xae\xce\x1c\xe9\x00\x00\x00\
\x04\x67\x41\x4d\x41\x00\x00\xb1\x8f\x0b\xfc\x61\x05\x00\x00\x00\
\x09\x70\x48\x59\x73\x00\x00\x0b\x12\x00\x00\x0b\x12\x01\xd2\xdd\
\x7e\xfc\x00\x00\x00\x1a\x74\x45\x58\x74\x53\x6f\x66\x74\x77\x61\
\x72\x65\x00\x50\x61\x69\x6e\x74\x2e\x4e\x45\x54\x20\x76\x33\x2e\
\x35\x2e\x31\x30\x30\xf4\x72\xa1\x00\x00\x00\x5c\x49\x44\x41\x54\
\x38\x4f\x63\xe8\x9a\x38\x87\x76\x08\x64\xfa\xa7\xaf\x3f\x68\x81\
\xa0\xa6\x7f\xf8\xfc\x8d\x16\x08\x6a\xfa\xbb\x8f\x5f\x68\x81\xa0\
\xa6\xbf\x7a\xfb\x11\x82\x5c\x22\x2a\x29\x47\x70\xd3\xa0\xa6\x3f\
\x7b\xf9\x1e\x82\xd0\xd4\x91\x87\xe0\xa6\x41\x4d\x7f\xfc\xec\x2d\
\x2d\x10\xd4\xf4\x87\x4f\x5e\xd3\x02\x41\x4d\xbf\xff\xe8\x25\x2d\
\x10\xd4\x74\x5a\xa1\x89\x73\x00\xf8\x06\xba\x5a\xe8\x93\x6f\x68\
\x00\x00\x00\x00\x49\x45\x4e\x44\xae\x42\x60\x82\
\x00\x00\x01\x3f\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x1f\x00\x00\x00\x13\x08\x02\x00\x00\x00\xe7\x0e\x41\x15\
\x00\x00\x00\x04\x67\x41\x4d\x41\x00\x00\xb1\x8f\x0b\xfc\x61\x05\
\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x0e\xc2\x00\x00\x0e\xc2\
\x01\x15\x28\x4a\x80\x00\x00\x00\x1a\x74\x45\x58\x74\x53\x6f\x66\
\x74\x77\x61\x72\x65\x00\x50\x61\x69\x6e\x74\x2e\x4e\x45\x54\x20\
\x76\x33\x2e\x35\x2e\x31\x30\x30\xf4\x72\xa1\x00\x00\x00\xbb\x49\
\x44\x41\x54\x38\x4f\xbd\xd5\x2b\x0e\xc2\x50\x10\x85\xe1\x2e\x8e\
\x45\xb0\x15\x34\x8e\x04\x81\x43\xe0\xd0\x78\x56\x81\xc2\xd4\xa0\
\x48\xa0\xa5\xa5\xbd\x8f\x3e\x31\x9c\x66\x26\x13\x04\x6e\x18\x92\
\xdf\x4d\xf2\xdd\x23\x9a\x34\x59\x6d\x76\x76\x25\xa0\x63\x37\x5a\
\x04\x79\xd2\x43\x3b\x58\xf4\x17\xdd\x37\x3d\x35\x9b\x2f\xf4\x89\
\xc6\xdb\x6d\x75\x17\x3b\x4a\x3f\x1c\x82\x68\xbc\xdd\x56\xaf\x43\
\x4b\xe1\xe5\x57\x76\xd4\x04\x41\x34\xde\xfe\xa9\x8f\xd7\x83\xa6\
\x2f\x7a\xe5\x1b\x0a\xb7\xf1\xb2\xd7\x04\x41\x34\xde\xfe\x74\x91\
\xc2\x6d\x48\xb7\x9a\x20\x88\xc6\x7a\x59\x07\x0a\xb7\xfe\xbc\xd6\
\x04\x41\x34\xd6\x8b\x2a\x50\x93\x7e\x5a\x6a\x82\x20\x1a\xeb\x79\
\xe9\xa9\x9f\x7c\xef\xa2\xb1\x9e\x15\xce\x22\xd6\xef\x8f\xda\x22\
\xd6\x6f\x79\x65\x11\xeb\x76\xff\xa6\x37\x06\x80\x09\x57\x1d\xbe\
\x2e\x15\x00\x00\x00\x00\x49\x45\x4e\x44\xae\x42\x60\x82\
\x00\x00\x02\x26\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x1f\x00\x00\x00\x1f\x08\x02\x00\x00\x00\x90\xcc\x81\x6e\
\x00\x00\x00\x01\x73\x52\x47\x42\x00\xae\xce\x1c\xe9\x00\x00\x00\
\x04\x67\x41\x4d\x41\x00\x00\xb1\x8f\x0b\xfc\x61\x05\x00\x00\x00\
\x09\x70\x48\x59\x73\x00\x00\x0e\xc3\x00\x00\x0e\xc3\x01\xc7\x6f\
\xa8\x64\x00\x00\x00\x1a\x74\x45\x58\x74\x53\x6f\x66\x74\x77\x61\
\x72\x65\x00\x50\x61\x69\x6e\x74\x2e\x4e\x45\x54\x20\x76\x33\x2e\
\x35\x2e\x31\x30\x30\xf4\x72\xa1\x00\x00\x01\x95\x49\x44\x41\x54\
\x48\x4b\xbd\xcd\xbb\x4a\x03\x51\x10\xc6\x71\x1f\xce\x87\xf0\x45\
\x2c\x2c\x2c\x2c\x2c\x14\x2c\x22\x1a\xa3\x04\x49\x4c\xc0\xc2\xc2\
\xc2\x68\x0a\x5f\x40\x44\x44\x44\x44\x44\x62\xdc\x5c\x77\xb3\x9b\
\xcd\xfd\x66\xe3\x0c\x33\x3b\x84\x93\x30\x07\x84\x0d\xfc\xaa\x73\
\xbe\xf3\x3f\x6b\xfb\x89\x74\x7c\xb0\x3e\x18\xcf\xe2\xc0\xf5\xfe\
\x68\x1a\x87\x95\xd4\x7b\xc3\x09\x59\xdf\xd8\xb2\x92\xb1\xd5\x4a\
\xea\xdd\xc1\x98\x18\xa1\xa5\x64\x6c\xb5\x92\x7a\xa7\x3f\x22\xf0\
\xf8\xd7\xbb\x57\xc0\x40\xc6\x56\xcb\xea\xcd\xa2\xe2\x3f\xf5\xb0\
\x37\x24\x58\xaf\xdf\x28\x60\x20\x63\x2b\xae\xb7\xbb\x03\x82\xf5\
\xea\xb5\x02\x06\x32\x36\x9c\xe6\x8b\xc6\x09\xd7\x83\x4e\x9f\xc0\
\xe3\x99\x73\xa5\x80\x81\x8c\xe7\xa5\xf2\x77\x8b\x57\x5c\xf7\xc3\
\x3e\xc1\x7a\xf9\x52\x01\x03\x19\x8b\x54\x0e\xd3\x8b\x57\x5c\xf7\
\x82\x1e\xc1\x7a\x29\xa7\x80\x81\x8c\xc9\xc9\x05\xa7\x17\xaf\xb8\
\xee\xfa\x5d\x02\x8b\xe9\xd7\xb9\x02\x06\x32\x96\x27\xc2\xb8\xe2\
\x7a\xb3\xd5\x21\xb0\x98\x7e\x9e\x29\x60\x20\x63\x92\xcc\xde\x4a\
\xdd\xb8\xe2\x7a\xc3\x0b\x09\xd6\x3f\x92\x0a\x18\xc8\x58\x1c\x67\
\x0b\x54\x37\xce\xb9\x5e\x77\x43\x82\xf5\xf7\x43\x05\x0c\x64\x3c\
\xef\x38\x83\x1f\x18\x87\x5c\xaf\x35\xdb\x04\x16\x93\xb7\x03\x05\
\x0c\x64\x6c\x38\xca\x14\x8c\x13\xae\x57\x1b\x01\xc1\xfa\xeb\x9e\
\x02\x06\x32\xb6\xe2\x7a\xa5\x11\x10\xac\xbf\xec\x2a\x60\x20\x63\
\xab\xa8\x5e\xf7\x09\x3c\x1e\x3f\xef\x28\xb0\x1e\x8d\xad\xb8\xee\
\xd4\x7c\x82\xf5\xa7\x6d\x05\x0c\x64\x6c\xc5\xf5\x9f\x5a\x8b\x60\
\xfd\x51\x03\x03\x19\x5b\x45\xf5\x6a\x8b\x60\xfd\x61\x53\x81\xf5\
\x68\x6c\xc5\xf5\x72\xd5\x23\xf0\xd8\x4a\xc6\x56\x5c\xff\xae\x78\
\x71\x88\xea\x8e\x1b\x07\xae\x97\x1c\x37\x0e\x5c\x8f\x4b\x22\xfd\
\x07\x5d\xb2\xe7\xb2\x6f\xdb\xf3\x18\x00\x00\x00\x00\x49\x45\x4e\
\x44\xae\x42\x60\x82\
\x00\x00\x01\xbb\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x1f\x00\x00\x00\x1f\x08\x02\x00\x00\x00\x90\xcc\x81\x6e\
\x00\x00\x00\x01\x73\x52\x47\x42\x00\xae\xce\x1c\xe9\x00\x00\x00\
\x04\x67\x41\x4d\x41\x00\x00\xb1\x8f\x0b\xfc\x61\x05\x00\x00\x00\
\x09\x70\x48\x59\x73\x00\x00\x0e\xc3\x00\x00\x0e\xc3\x01\xc7\x6f\
\xa8\x64\x00\x00\x00\x1a\x74\x45\x58\x74\x53\x6f\x66\x74\x77\x61\
\x72\x65\x00\x50\x61\x69\x6e\x74\x2e\x4e\x45\x54\x20\x76\x33\x2e\
\x35\x2e\x31\x30\x30\xf4\x72\xa1\x00\x00\x01\x2a\x49\x44\x41\x54\
\x48\x4b\xbd\xd2\xbd\x4e\x02\x51\x10\x86\x61\x2f\xce\x8b\xf0\x52\
\xb0\xb6\x33\xb1\xa0\x33\x84\xce\x68\x67\xcf\x2d\xd8\x50\xd9\xd8\
\xa0\x2e\xbb\x2c\xfb\xc7\xfe\xc2\x02\x36\xce\xc9\x7c\x3b\x26\x07\
\x23\xb8\x27\x43\xf2\x16\x84\x6f\xf2\x9c\x66\x2f\x6e\x87\x63\xbd\
\x8c\xde\xb4\x7b\x8d\xa0\xd7\x9b\x9d\x46\x67\xd1\xab\xf5\x56\xa3\
\xb3\xe8\x65\xd3\xfe\xd1\xe8\x69\x72\x79\x75\x7d\x18\xfd\x6f\x5d\
\x5a\x9d\xa4\x53\x87\x0f\x1c\xa5\x29\xe8\x45\xbd\x39\xda\xe8\xf1\
\xe7\x01\xfa\x6d\xad\xbf\xf6\x0f\x9d\xe2\x07\x4e\xa4\x29\xe8\x79\
\xb5\xd6\x08\xfa\xaa\x6c\x34\x82\x9e\x15\xb5\x46\xd0\xd3\xbc\xd6\
\x08\x7a\x9c\x55\x1a\x41\x8f\xd2\x92\x93\x6f\xce\x25\xd1\xa0\x2f\
\x93\x82\xb3\xee\xfa\x25\x1a\xf4\x30\xce\x39\xeb\xae\x5f\xa2\x41\
\x5f\x44\x39\x67\xdd\xf5\x4b\x34\xe8\xc1\x72\xc5\xd1\xf6\x15\x4d\
\x5c\x22\x41\x34\xe8\x7e\x98\x71\xb4\xed\xfd\x67\x97\x48\x10\x0d\
\xfa\x3c\xcc\x38\xa3\xcf\x1e\x5c\x22\x41\xb4\x4e\x5f\xa4\x1c\x6d\
\xbb\xb7\x7b\x97\x8c\xde\x69\xd0\xbd\x20\xe5\x68\xdb\xbe\xde\xb9\
\x44\x82\x68\xd0\x3f\x83\x84\x33\xfa\xf4\xc6\x25\x12\x44\xeb\x74\
\x3f\xe1\x68\x6b\x5f\x06\x2e\x19\xbd\xd3\xa0\x7f\xf8\x31\x47\x9b\
\x7b\xa2\x41\x7f\x9f\xc7\x1a\x75\xba\x17\x69\x04\x7d\xe6\x45\x1a\
\x41\xd7\x6a\x38\xfe\x06\x3c\xec\xc9\x88\xb5\xd8\x55\x59\x00\x00\
\x00\x00\x49\x45\x4e\x44\xae\x42\x60\x82\
\x00\x00\x02\x62\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x80\x00\x00\x00\x80\x08\x06\x00\x00\x00\xc3\x3e\x61\xcb\
\x00\x00\x00\x04\x73\x42\x49\x54\x08\x08\x08\x08\x7c\x08\x64\x88\
\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x0e\xc4\x00\x00\x0e\xc4\
\x01\x95\x2b\x0e\x1b\x00\x00\x02\x04\x49\x44\x41\x54\x78\x9c\xed\
\xd6\xb1\x0d\x03\x01\x0c\x03\x31\x21\x13\x64\xff\x65\x3f\x6d\xbc\
\x80\x2d\xe0\xa9\x8e\xfd\x15\x4a\xe6\xbe\xfc\x2e\x7f\xfe\xf5\x3c\
\x4f\xf8\x9d\x3e\x2f\x91\x6f\xfc\x49\xba\x4a\xe4\x7d\xff\xaf\xa6\
\x4c\xde\xb1\x0f\xc0\x49\x0a\x4a\xe4\x1b\xfb\x00\x3c\x56\x53\x26\
\xef\xd8\x07\xe0\x24\x05\x25\xf2\x8d\x7d\x00\x1e\xab\x29\x93\x77\
\xec\x03\x70\x92\x82\x12\xf9\xc6\x3e\x00\x8f\xd5\x94\xc9\x3b\xf6\
\x01\x38\x49\x41\x89\x7c\x63\x1f\x80\xc7\x6a\xca\xe4\x1d\xfb\x00\
\x9c\xa4\xa0\x44\xbe\xb1\x0f\xc0\x63\x35\x65\xf2\x8e\x7d\x00\x4e\
\x52\x50\x22\xdf\xd8\x07\xe0\xb1\x9a\x32\x79\xc7\x3e\x00\x27\x29\
\x28\x91\x6f\xec\x03\xf0\x58\x4d\x99\xbc\x63\x1f\x80\x93\x14\x94\
\xc8\x37\xf6\x01\x78\xac\xa6\x4c\xde\xb1\x0f\xc0\x49\x0a\x4a\xe4\
\x1b\xfb\x00\x3c\x56\x53\x26\xef\xd8\x07\xe0\x24\x05\x25\xf2\x8d\
\x7d\x00\x1e\xab\x29\x93\x77\xec\x03\x70\x92\x82\x12\xf9\xc6\x3e\
\x00\x8f\xd5\x94\xc9\x3b\xf6\x01\x38\x49\x41\x89\x7c\x63\x1f\x80\
\xc7\x6a\xca\xe4\x1d\xfb\x00\x9c\xa4\xa0\x44\xbe\xb1\x0f\xc0\x63\
\x35\x65\xf2\x8e\x7d\x00\x4e\x52\x50\x22\xdf\xd8\x07\xe0\xb1\x9a\
\x32\x79\xc7\x3e\x00\x27\x29\x28\x91\x6f\xec\x03\xf0\x58\x4d\x99\
\xbc\x63\x1f\x80\x93\x14\x94\xc8\x37\xf6\x01\x78\xac\xa6\x4c\xde\
\xb1\x0f\xc0\x49\x0a\x4a\xe4\x1b\xfb\x00\x3c\x56\x53\x26\xef\xd8\
\x07\xe0\x24\x05\x25\xf2\x8d\x7d\x00\x1e\xab\x29\x93\x77\xec\x03\
\x70\x92\x82\x12\xf9\xc6\x3e\x00\x8f\xd5\x94\xc9\x3b\xf6\x01\x38\
\x49\x41\x89\x7c\x63\x1f\x80\xc7\x6a\xca\xe4\x1d\xfb\x00\x9c\xa4\
\xa0\x44\xbe\xb1\x0f\xc0\x63\x35\x65\xf2\x8e\x7d\x00\x4e\x52\x50\
\x22\xdf\xd8\x07\xe0\xb1\x9a\x32\x79\xc7\x3e\x00\x27\x29\x28\x91\
\x6f\xec\x03\xf0\x58\x4d\x99\xbc\x63\x1f\x80\x93\x14\x94\xc8\x37\
\xf6\x01\x78\xac\xa6\x4c\xde\xb1\x0f\xc0\x49\x0a\x4a\xe4\x1b\xfb\
\x00\x3c\x56\x53\x26\xef\xd8\x07\xe0\x24\x05\x25\xf2\x8d\x7d\x00\
\x1e\xab\x29\x93\x77\xec\x03\x70\x92\x82\x12\xf9\xc6\x3e\x00\x8f\
\xd5\x94\xc9\x3b\xf6\x01\x38\x49\x41\x89\x7c\x63\x1f\x80\xc7\x6a\
\xca\xe4\x1d\xfb\x00\x9c\xa4\xa0\x44\xbe\xb1\x0f\xc0\x63\x35\x65\
\xf2\x8e\x7d\x00\x4e\x52\x50\x22\xdf\xd8\x07\xe0\xb1\x9a\x32\x79\
\xc7\x3e\x00\x27\x29\x28\x91\x6f\xec\x03\xbc\xdc\x3f\xe4\x79\x69\
\xe9\x67\xab\xcf\x62\x00\x00\x00\x00\x49\x45\x4e\x44\xae\x42\x60\
\x82\
"

qt_resource_name = "\
\x00\x0b\
\x05\x55\xc9\xe3\
\x00\x64\
\x00\x6f\x00\x63\x00\x6b\x00\x5f\x00\x69\x00\x6d\x00\x61\x00\x67\x00\x65\x00\x73\
\x00\x0d\
\x0c\x46\x04\x47\
\x00\x63\
\x00\x72\x00\x6f\x00\x73\x00\x73\x00\x5f\x00\x62\x00\x6f\x00\x78\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x0a\
\x0a\xc8\x6f\xe7\
\x00\x63\
\x00\x65\x00\x6e\x00\x74\x00\x65\x00\x72\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x10\
\x0c\x5a\x16\x47\
\x00\x63\
\x00\x72\x00\x6f\x00\x73\x00\x73\x00\x5f\x00\x65\x00\x78\x00\x5f\x00\x62\x00\x6f\x00\x78\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x11\
\x05\x0d\xa3\xa7\
\x00\x74\
\x00\x68\x00\x69\x00\x6e\x00\x5f\x00\x76\x00\x65\x00\x72\x00\x74\x00\x69\x00\x63\x00\x61\x00\x6c\x00\x2e\x00\x70\x00\x6e\x00\x67\
\
\x00\x0f\
\x0b\x70\x3f\xe7\
\x00\x61\
\x00\x72\x00\x72\x00\x6f\x00\x77\x00\x5f\x00\x6e\x00\x6f\x00\x72\x00\x74\x00\x68\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x0d\
\x04\x14\x00\x47\
\x00\x67\
\x00\x75\x00\x69\x00\x64\x00\x65\x00\x5f\x00\x62\x00\x6f\x00\x78\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x12\
\x0a\x7a\xa0\x07\
\x00\x73\
\x00\x70\x00\x6c\x00\x69\x00\x74\x00\x5f\x00\x76\x00\x65\x00\x72\x00\x74\x00\x69\x00\x63\x00\x61\x00\x6c\x00\x2e\x00\x70\x00\x6e\
\x00\x67\
\x00\x10\
\x04\xfc\x40\xa7\
\x00\x62\
\x00\x61\x00\x72\x00\x5f\x00\x76\x00\x65\x00\x72\x00\x74\x00\x69\x00\x63\x00\x61\x00\x6c\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x0e\
\x0b\x8a\xe6\x07\
\x00\x61\
\x00\x72\x00\x72\x00\x6f\x00\x77\x00\x5f\x00\x65\x00\x61\x00\x73\x00\x74\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x14\
\x0b\x9f\xd1\x07\
\x00\x73\
\x00\x70\x00\x6c\x00\x69\x00\x74\x00\x5f\x00\x68\x00\x6f\x00\x72\x00\x69\x00\x7a\x00\x6f\x00\x6e\x00\x74\x00\x61\x00\x6c\x00\x2e\
\x00\x70\x00\x6e\x00\x67\
\x00\x12\
\x0d\x7f\x14\x07\
\x00\x62\
\x00\x61\x00\x72\x00\x5f\x00\x68\x00\x6f\x00\x72\x00\x69\x00\x7a\x00\x6f\x00\x6e\x00\x74\x00\x61\x00\x6c\x00\x2e\x00\x70\x00\x6e\
\x00\x67\
\x00\x13\
\x0c\x9c\x17\xe7\
\x00\x74\
\x00\x68\x00\x69\x00\x6e\x00\x5f\x00\x68\x00\x6f\x00\x72\x00\x69\x00\x7a\x00\x6f\x00\x6e\x00\x74\x00\x61\x00\x6c\x00\x2e\x00\x70\
\x00\x6e\x00\x67\
\x00\x0e\
\x0f\x8a\xe0\xc7\
\x00\x61\
\x00\x72\x00\x72\x00\x6f\x00\x77\x00\x5f\x00\x77\x00\x65\x00\x73\x00\x74\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x0f\
\x0e\x70\x21\xe7\
\x00\x61\
\x00\x72\x00\x72\x00\x6f\x00\x77\x00\x5f\x00\x73\x00\x6f\x00\x75\x00\x74\x00\x68\x00\x2e\x00\x70\x00\x6e\x00\x67\
\x00\x0e\
\x07\x04\x9f\x87\
\x00\x62\
\x00\x61\x00\x63\x00\x6b\x00\x67\x00\x72\x00\x6f\x00\x75\x00\x6e\x00\x64\x00\x2e\x00\x70\x00\x6e\x00\x67\
"

qt_resource_struct = "\
\x00\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x01\
\x00\x00\x00\x00\x00\x02\x00\x00\x00\x0f\x00\x00\x00\x02\
\x00\x00\x00\xc8\x00\x00\x00\x00\x00\x01\x00\x00\x0a\xb3\
\x00\x00\x01\x12\x00\x00\x00\x00\x00\x01\x00\x00\x0d\x3f\
\x00\x00\x00\x7c\x00\x00\x00\x00\x00\x01\x00\x00\x07\x12\
\x00\x00\x02\x24\x00\x00\x00\x00\x00\x01\x00\x00\x18\xfc\
\x00\x00\x00\xe8\x00\x00\x00\x00\x00\x01\x00\x00\x0b\x79\
\x00\x00\x00\x3c\x00\x00\x00\x00\x00\x01\x00\x00\x02\x65\
\x00\x00\x00\xa4\x00\x00\x00\x00\x00\x01\x00\x00\x08\xf7\
\x00\x00\x01\x38\x00\x00\x00\x00\x00\x01\x00\x00\x0e\x91\
\x00\x00\x01\x5a\x00\x00\x00\x00\x00\x01\x00\x00\x10\xb7\
\x00\x00\x00\x1c\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\
\x00\x00\x00\x56\x00\x00\x00\x00\x00\x01\x00\x00\x04\x43\
\x00\x00\x01\xb2\x00\x00\x00\x00\x00\x01\x00\x00\x13\xd0\
\x00\x00\x01\x88\x00\x00\x00\x00\x00\x01\x00\x00\x12\xdf\
\x00\x00\x02\x00\x00\x00\x00\x00\x00\x01\x00\x00\x17\x3d\
\x00\x00\x01\xde\x00\x00\x00\x00\x00\x01\x00\x00\x15\x13\
"

def qInitResources():
    QtCore.qRegisterResourceData(0x01, qt_resource_struct, qt_resource_name, qt_resource_data)

def qCleanupResources():
    QtCore.qUnregisterResourceData(0x01, qt_resource_struct, qt_resource_name, qt_resource_data)

qInitResources()

########NEW FILE########
__FILENAME__ = event_types
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from enaml.qt.QtCore import QEvent


#: An event type which indicates the contents of a dock area changed.
DockAreaContentsChanged = QEvent.Type(QEvent.registerEventType())


#: An event type which indicates the dock item was docked.
DockItemDocked = QEvent.Type(QEvent.registerEventType())


#: An event type which indicates the dock item was undock.
DockItemUndocked = QEvent.Type(QEvent.registerEventType())


#: An event type which indicates the dock item was extended.
DockItemExtended = QEvent.Type(QEvent.registerEventType())


#: An event type which indicates the dock item was retracted.
DockItemRetracted = QEvent.Type(QEvent.registerEventType())


#: An event type which indicates the dock item was shown.
DockItemShown = QEvent.Type(QEvent.registerEventType())


#: An event type which indicates the dock item was hidden.
DockItemHidden = QEvent.Type(QEvent.registerEventType())


#: An event type which indicates the dock item was closed.
DockItemClosed = QEvent.Type(QEvent.registerEventType())


#: An event type which indicates a dock tab was selected.
DockTabSelected = QEvent.Type(QEvent.registerEventType())


class QDockItemEvent(QEvent):
    """ An event class for defining QDockItem events.

    """
    def __init__(self, type, name):
        """ Initialize a QDockItemEvent.

        Parameters
        ----------
        type : QEvent.Type
            The event type for the event.

        name : unicode
            The object name of the dock item of interest.

        """
        super(QDockItemEvent, self).__init__(type)
        self._name = name

    def name(self):
        """ Get the object name of the dock item of the event.

        Returns
        -------
        result : unicode
            The object name of the dock item for the event.

        """
        return self._name

########NEW FILE########
__FILENAME__ = layout_builder
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from contextlib import contextmanager
import warnings

from enaml.nodevisitor import NodeVisitor

from enaml.qt.QtCore import Qt, QRect
from enaml.qt.QtGui import QApplication

from enaml.layout.dock_layout import ItemLayout, AreaLayout

from .event_types import QDockItemEvent, DockItemDocked
from .layout_handling import plug_frame
from .q_dock_bar import QDockBar
from .q_dock_splitter import QDockSplitter
from .q_dock_tab_widget import QDockTabWidget
from .q_dock_window import QDockWindow
from .q_guide_rose import QGuideRose


def ensure_on_screen(rect):
    """ Ensure that the given rect is contained on screen.

    If the origin of the rect is not contained within the closest
    desktop screen, the rect will be moved so that it is fully on the
    closest screen. If the rect is larger than the closest screen, the
    origin will never be less than the screen origin.

    Parameters
    ----------
    rect : QRect
        The geometry rect of interest.

    Returns
    -------
    result : QRect
        The potentially adjusted QRect which fits on the screen.

    """
    d = QApplication.desktop()
    pos = rect.topLeft()
    drect = d.screenGeometry(pos)
    if not drect.contains(pos):
        x = pos.x()
        if x < drect.x() or x > drect.right():
            dw = drect.width() - rect.width()
            x = max(drect.x(), drect.x() + dw)
        y = pos.y()
        if x < drect.top() or y > drect.bottom():
            dh = drect.height() - rect.height()
            y = max(drect.y(), drect.y() + dh)
        rect = QRect(x, y, rect.width(), rect.height())
    return rect


class LayoutBuilder(NodeVisitor):
    """ A NodeVisitor which builds and updates a dock manager layout.

    Instances of this class should be used once and discarded.

    """
    BAR_POSITIONS = {
        'top': QDockBar.North,
        'right': QDockBar.East,
        'bottom': QDockBar.South,
        'left': QDockBar.West,
    }

    BORDER_GUIDES = {
        'top': QGuideRose.Guide.BorderNorth,
        'right': QGuideRose.Guide.BorderEast,
        'bottom': QGuideRose.Guide.BorderSouth,
        'left': QGuideRose.Guide.BorderWest,
    }

    ITEM_GUIDES = {
        'top': QGuideRose.Guide.CompassNorth,
        'right': QGuideRose.Guide.CompassEast,
        'bottom': QGuideRose.Guide.CompassSouth,
        'left': QGuideRose.Guide.CompassWest,
    }

    TAB_GUIDES = {
        'default': QGuideRose.Guide.CompassCenter,
        'top': QGuideRose.Guide.CompassExNorth,
        'right': QGuideRose.Guide.CompassExEast,
        'bottom': QGuideRose.Guide.CompassExSouth,
        'left': QGuideRose.Guide.CompassExWest,
    }

    TAB_POSITION = {
        'top': QDockTabWidget.North,
        'bottom': QDockTabWidget.South,
        'left': QDockTabWidget.West,
        'right': QDockTabWidget.East,
    }

    ORIENTATION = {
        'horizontal': Qt.Horizontal,
        'vertical': Qt.Vertical,
    }

    def __init__(self, manager):
        """ Initialize a LayoutBuilder.

        Parameters
        ----------
        manager : DockManager
            The dock manager for which work is being performed.

        """
        self.manager = manager
        self._containers = None

    def setup(self, node):
        """ Setup the layout updater.

        """
        self.stack = []

    def teardown(self, node):
        """ Teardown the updater.

        """
        del self.stack

    def default_visit(self, node):
        """ The default visitor method.

        The default visitor emits a warning for unhandled layout nodes.

        """
        msg = "unhandled layout node '%s'" % type(node).__name__
        warnings.warn(msg)

    @property
    def containers(self):
        """ Get a dictionary of available dock containers.

        """
        containers = self._containers
        if containers is None:
            c_list = self.manager.dock_containers()
            containers = dict((c.objectName(), c) for c in c_list)
            self._containers = containers
        return containers

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def init_dock_area(self, area, layout):
        """ Initialize and populate a dock area.

        This initializer populates the dock area with it children and
        dock bars, and sets the maximized item if appropriate.

        Parameters
        ----------
        area : QDockArea
            The dock area which should be populated with children.

        layout : AreaLayout
            The area layout node which describes the children to
            build for the area.

        """
        containers = self.containers
        if layout.item is not None:
            self.visit(layout.item)
            area.setCentralWidget(self.stack.pop())
        for bar_layout in layout.dock_bars:
            position = self.BAR_POSITIONS[bar_layout.position]
            for item in bar_layout.items:
                container = containers.get(item.name)
                if container is not None:
                    area.addToDockBar(container, position)
        for item in layout.find_all(ItemLayout):
            if item.maximized:
                container = containers.get(item.name)
                if container is not None:
                    container.showMaximized()
                    break

    def init_floating_frame(self, frame, layout):
        """ Initialize a floating frame.

        This initializer sets up the geometry, maximized state, and
        linked state for the floating frame.

        Parameters
        ----------
        frame : QDockFrame
            The floating dock frame of interest.

        layout : ItemLayout or AreaLayout
            The layout describing the floating state of the frame.

        """
        rect = QRect(*layout.geometry)
        if rect.isValid():
            rect = ensure_on_screen(rect)
            frame.setGeometry(rect)
        frame.show()
        if layout.linked:
            frame.setLinked(True)
        if layout.maximized:
            frame.showMaximized()

    @contextmanager
    def dock_context(self, container):
        """ Setup a context for docking onto a QDockContainer target.

        This context manager will setup a QDockWindow for a floating
        dock container, which ensures that a new dock area will be
        available for docking.

        Parameters
        ----------
        container : QDockContainer
            The container dock target of the operation.

        """
        is_window = container.isWindow()
        if is_window:
            is_maxed = container.isMaximized()
            if is_maxed:
                container.showNormal()
            manager = self.manager
            window = QDockWindow(manager, manager.dock_area())
            manager.add_window(window)
            window.setGeometry(container.geometry())
            win_area = window.dockArea()
            plug_frame(win_area, None, container, QGuideRose.Guide.AreaCenter)
            self.post_docked_event(container)
        yield
        if is_window:
            window.show()
            if is_maxed:
                window.showMaximized()

    @contextmanager
    def drop_frame(self, frame):
        """ Setup a drop context for a QDockFrame.

        This context manager prepares a QDockFrame to be dropped onto
        a dock area or dock container. It ensures that a dock window is
        cleaned up after the docking operation and that the appropriate
        event is emitted on the object.

        Parameters
        ----------
        window : QDockFrame
            The dock frame of interest.

        """
        if isinstance(frame, QDockWindow):
            win_area = frame.dockArea()
            maxed = win_area.maximizedWidget()
            if maxed is not None:
                container = self.containers.get(maxed.objectName())
                if container is not None:
                    container.showNormal()
        yield
        if isinstance(frame, QDockWindow) and frame.dockArea() is None:
            frame.close()
        elif not frame.isWindow():  # QDockContainer was docked.
            self.post_docked_event(frame)

    def post_docked_event(self, container):
        """ Post the docked event for the given container.

        Parameters
        ----------
        container : QDockContainer
            The dock container which was undocked.

        """
        root_area = container.manager().dock_area()
        if root_area.dockEventsEnabled():
            event = QDockItemEvent(DockItemDocked, container.objectName())
            QApplication.postEvent(root_area, event)

    #--------------------------------------------------------------------------
    # LayoutNode Visitors
    #--------------------------------------------------------------------------
    def visit_ItemLayout(self, node):
        """ Visit an ItemLayout node.

        This visitor pushes the named container onto the stack. If the
        name is not valid, None is pushed instead.

        """
        self.stack.append(self.containers.get(node.name))

    def visit_TabLayout(self, node):
        """ Visit a TabLayout node.

        This visitor visits its children, pops them from the stack, and
        adds them to a tab widget. The completed tab widget is pushed
        onto the stack as the return value. If there are no children,
        None is pushed. If there is a single child, it is pushed.

        """
        children = []
        for item in node.items:
            self.visit(item)
            children.append(self.stack.pop())
        children = filter(None, children)
        if len(children) == 0:
            self.stack.append(None)
            return
        if len(children) == 1:
            self.stack.append(children[0])
            return
        tab_widget = QDockTabWidget()
        tab_widget.setTabPosition(self.TAB_POSITION[node.tab_position])
        for child in children:
            child.hideTitleBar()
            tab_widget.addTab(child, child.icon(), child.title())
        tab_widget.setCurrentIndex(node.index)
        self.stack.append(tab_widget)

    def visit_SplitLayout(self, node):
        """ Visit a SplitLayout node.

        This visitor visits its children, pops them from the stack, and
        adds them to a split widget. The completed tab widget is pushed
        onto the stack as the return value. If there are no children,
        None is pushed. If there is a single child, it is pushed.

        """
        children = []
        for item in node.items:
            self.visit(item)
            children.append(self.stack.pop())
        children = filter(None, children)
        if len(children) == 0:
            self.stack.append(None)
            return
        if len(children) == 1:
            self.stack.append(children[0])
            return
        splitter = QDockSplitter(self.ORIENTATION[node.orientation])
        for child in children:
            splitter.addWidget(child)
        if len(node.sizes) >= splitter.count():
            splitter.setSizes(node.sizes)
        self.stack.append(splitter)

    def visit_DockLayout(self, node):
        """ Visit a DockLayout node.

        This visitor assemble a new layout from scratch for the dock
        manager. It is only invoked from the 'apply_layout' method of
        the dock manager when a completely new layout is being applied.

        """
        # Reset everything before applying a completely new layout.
        manager = self.manager
        for container in manager.dock_containers():
            container.reset()
        for window in manager.dock_windows():
            window.close()
        dock_area = manager.dock_area()
        dock_area.clearDockBars()
        dock_area.setCentralWidget(None)

        has_primary = False
        for item in node.items:
            if isinstance(item, AreaLayout):
                if not item.floating and not has_primary:
                    self.init_dock_area(dock_area, item)
                    has_primary = True
                else:
                    frame = QDockWindow(manager, dock_area)
                    self.init_dock_area(frame.dockArea(), item)
                    manager.add_window(frame)
                    self.init_floating_frame(frame, item)
            else:
                frame = self.containers.get(item.name)
                if frame is not None:
                    frame.float()
                    self.init_floating_frame(frame, item)

    #--------------------------------------------------------------------------
    # DockLayoutOp Visitors
    #--------------------------------------------------------------------------
    def visit_InsertItem(self, op):
        """ Handle the InsertItem dock layout operation.

        This visitor inserts the dock item into the layout according to
        the data specified in the operation.

        """
        item = self.containers.get(op.item)
        if item is None:
            return
        target = self.containers.get(op.target)
        if target is None:
            self.visit_InsertBorderItem(op)  # duck type to InsertBorderItem
            return

        if not item.isWindow():
            item.unplug()

        area = target.parentDockArea()
        bar_position = area.dockBarPosition(target)
        if bar_position is not None:
            if item.isWindow():
                item.unfloat()
            item.showTitleBar()
            area.addToDockBar(item, bar_position)
            return

        with self.dock_context(target):
            area = target.parentDockArea()
            widget = target.parentDockTabWidget() or target
            plug_frame(area, widget, item, self.ITEM_GUIDES[op.position])

    def visit_InsertBorderItem(self, op):
        """ Handle the InsertBorderItem dock layout operation.

        This visitor inserts the dock item into the dock area border
        according to the data specified in the operation.

        """
        item = self.containers.get(op.item)
        if item is None:
            return

        if not item.isWindow():
            item.unplug()

        guide = self.BORDER_GUIDES[op.position]
        target = self.containers.get(op.target)
        if target is None:
            area = self.manager.dock_area()
            if area.centralWidget() is None:
                guide = QGuideRose.Guide.AreaCenter
            plug_frame(area, None, item, guide)
        else:
            with self.dock_context(target):
                area = target.parentDockArea()
                if area.centralWidget() is None:
                    guide = QGuideRose.Guide.AreaCenter
                plug_frame(area, None, item, guide)

    def visit_InsertDockBarItem(self, op):
        """ Handle the InsertDockBarItem dock layout operation.

        This visitor inserts the dock item into the dock area's dock
        bar according to the data specified in the operation.

        """
        item = self.containers.get(op.item)
        if item is None:
            return

        if item.isWindow():
            item.unfloat()
        else:
            item.unplug()
        item.showTitleBar()

        position = self.BAR_POSITIONS[op.position]
        target = self.containers.get(op.target)
        if target is None:
            area = self.manager.dock_area()
            area.addToDockBar(item, position, op.index)
        else:
            with self.dock_context(target):
                area = target.parentDockArea()
                area.addToDockBar(item, position, op.index)

    def visit_InsertTab(self, op):
        """ Handle the InsertTab dock layout operation.

        This visitor inserts the dock item as a tab in the layout
        according to the data specified in the operation.

        """
        item = self.containers.get(op.item)
        if item is None:
            return

        if not item.isWindow():
            item.unplug()

        target = self.containers.get(op.target)
        if target is None:
            area = self.manager.dock_area()
            if area.centralWidget() is None:
                guide = QGuideRose.Guide.AreaCenter
            else:
                guide = QGuideRose.Guide.BorderWest
            plug_frame(area, None, item, guide)
            return

        area = target.parentDockArea()
        bar_position = area.dockBarPosition(target)
        if bar_position is not None:
            if item.isWindow():
                item.unfloat()
            item.showTitleBar()
            area.addToDockBar(item, bar_position)
            return

        with self.dock_context(target):
            area = target.parentDockArea()
            widget = target.parentDockTabWidget()
            if widget is None:
                widget = target
                guide = self.TAB_GUIDES[op.tab_position]
            else:
                guide = QGuideRose.Guide.CompassCenter
            plug_frame(area, widget, item, guide)

        tabs = target.parentDockTabWidget()
        if tabs is not None:
            index = tabs.indexOf(item)
            tabs.tabBar().moveTab(index, op.index)

    def visit_FloatItem(self, op):
        """ Handle the FloatItem dock layout op.

        This visitor converts the item into a floating dock item.

        """
        layout = op.item
        container = self.containers.get(layout.name)
        if container is None:
            return
        if not container.isWindow():
            container.unplug()
            container.float()
        self.init_floating_frame(container, layout)

    def visit_FloatArea(self, op):
        """ Handle the FloatArea dock layout op.

        This visitor creates a new floating dock area window.

        """
        # Reset the relevant containers before creating the new area.
        containers = self.containers
        for item in op.area.find_all(ItemLayout):
            container = containers.get(item.name)
            if container is not None:
                if not container.isWindow():
                    container.unplug()
                container.reset()
        manager = self.manager
        frame = QDockWindow(manager, manager.dock_area())
        self.init_dock_area(frame.dockArea(), op.area)
        manager.add_window(frame)
        self.init_floating_frame(frame, op.area)

    def visit_RemoveItem(self, op):
        """ Handle the RemoveItem dock layout op.

        This visitor removes the item from the layout and hides it.

        """
        container = self.containers.get(op.item)
        if container is None:
            return
        if container.isWindow():
            container.unfloat()
        else:
            container.unplug()
        container.hide()

    def visit_ExtendItem(self, op):
        """ Handle the ExtendItem dock layout op.

        This visitor will extend the item provided it lives in a
        dock bar.

        """
        container = self.containers.get(op.item)
        if container is None:
            return
        area = container.parentDockArea()
        if area is not None:
            area.extendFromDockBar(container)

    def visit_RetractItem(self, op):
        """ Handle the RetractItem dock layout op.

        This visitor will retract the item provided it lives in a
        dock bar.

        """
        container = self.containers.get(op.item)
        if container is None:
            return
        area = container.parentDockArea()
        if area is not None:
            area.retractToDockBar(container)

########NEW FILE########
__FILENAME__ = layout_handling
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from enaml.qt.QtCore import Qt, QEvent
from enaml.qt.QtGui import QApplication

from .event_types import DockAreaContentsChanged
from .q_dock_bar import QDockBar
from .q_dock_container import QDockContainer
from .q_dock_splitter import QDockSplitter, QDockSplitterHandle
from .q_dock_tab_widget import QDockTabWidget
from .q_dock_window import QDockWindow


#------------------------------------------------------------------------------
# Public API
#------------------------------------------------------------------------------
def unplug_container(area, container):
    """ Unplug a container from a dock area.

    Parameters
    ----------
    area : QDockArea
        The dock area in which the container lives.

    container : QDockContainer
        The container to remove from the dock area.

    Returns
    -------
    result : bool
        True on success, False otherwise.

    """
    root = area.centralWidget()
    if root is None:
        return False
    if root is container:
        root.hide()
        root.setParent(None)
        area.setCentralWidget(None)
        QApplication.sendEvent(area, QEvent(DockAreaContentsChanged))
        return True
    success, replace = _unplug(root, container)
    if not success:
        return False
    if replace is not None:
        area.setCentralWidget(replace)
    QApplication.sendEvent(area, QEvent(DockAreaContentsChanged))
    return True


def plug_frame(area, widget, frame, guide):
    """ Plug a dock frame into a dock area.

    Parameters
    ----------
    area : QDockArea
        The dock area which owns the layout into which the
        container is being plugged.

    widget : QWidget
        The widget under the mouse. This should be one of
        QDockSplitterHandle, QDockTabWidget, or QDockContainer.

    frame : QDockContainer or QDockWindow
        The dock container or window to be plugged into the area.
        This should already be unplugged from any other layout.

    guide : QGuideRose.Guide
        The guide rose guide which indicates how to perform
        the plugging.

    Returns
    -------
    result : bool
        True if the plugging was successful, False otherwise.

    """
    if not isinstance(frame, (QDockContainer, QDockWindow)):
        return False
    res = _PLUG_HANDLERS[guide](area, widget, frame, guide)
    if res:
        QApplication.sendEvent(area, QEvent(DockAreaContentsChanged))
    return res


def iter_handles(area):
    """ Iterate the splitter handles in a dock layout.

    Parameters
    ----------
    area : QDockArea
        The dock area containing the dock layout of interest.

    Returns
    -------
    result : generator
        A generator which yields the QDockSplitterHandle instances
        contained within the dock area layout.

    """
    stack = [area.centralWidget()]
    while stack:
        widget = stack.pop()
        if isinstance(widget, QDockSplitter):
            for index in xrange(1, widget.count()):
                yield widget.handle(index)
            for index in xrange(widget.count()):
                stack.append(widget.widget(index))


def iter_tabs(area):
    """ Iterate the tab widgets in a dock layout.

    Parameters
    ----------
    area : QDockArea
        The dock area containing the dock layout of interest.

    Returns
    -------
    result : generator
        A generator which yields the QDockTabWidget instances contained
        within the dock area layout.

    """
    stack = [area.centralWidget()]
    while stack:
        widget = stack.pop()
        if isinstance(widget, QDockTabWidget):
            yield widget
        elif isinstance(widget, QDockSplitter):
            for index in xrange(widget.count()):
                stack.append(widget.widget(index))


def iter_containers(area):
    """ Iterate the dock containers in a dock layout.

    Parameters
    ----------
    area : QDockArea
        The dock area containing the dock layout of interest.

    Returns
    -------
    result : generator
        A generator which yields the QDockContainer instances
        contained within the dock area layout.

    """
    stack = [area.centralWidget()]
    while stack:
        widget = stack.pop()
        if isinstance(widget, QDockContainer):
            yield widget
        elif isinstance(widget, (QDockSplitter, QDockTabWidget)):
            for index in xrange(widget.count()):
                stack.append(widget.widget(index))


def layout_hit_test(area, pos):
    """ Hit test a dock area for a relevant dock target.

    Parameters
    ----------
    area : QDockArea
        The dock area of interest.

    pos : QPoint
        The point of interest expressed in local area coordinates.

    Returns
    -------
    result : QWidget or None
        The relevant dock target under the position. This will be
        a QDockContainer, QDockTabWidget, or QDockSplitterHandle.

    """
    # Splitter handles have priority. Their active area is smaller
    # and overlaps that of other widgets. Giving dock containers
    # priority would make it difficult to hit a splitter reliably.
    # In certain configurations, there may be more than one handle
    # in the hit box, in which case the one closest to center wins.
    hits = []
    for handle in iter_handles(area):
        pt = handle.mapFrom(area, pos)
        rect = handle.rect().adjusted(-20, -20, 20, 20)
        if rect.contains(pt):
            dist = (rect.center() - pt).manhattanLength()
            hits.append((dist, handle))
    if len(hits) > 0:
        hits.sort()
        return hits[0][1]

    # Check for tab widgets next. A tab widget has dock containers,
    # but should have priority over the dock containers themselves.
    for tab_widget in iter_tabs(area):
        pt = tab_widget.mapFrom(area, pos)
        if tab_widget.rect().contains(pt):
            return tab_widget

    # Check for QDockContainers last. The are the most common case,
    # but also have the least precedence compared to the others.
    for dock_container in iter_containers(area):
        pt = dock_container.mapFrom(area, pos)
        if dock_container.rect().contains(pt):
            if not dock_container.isHidden():  # hidden tab
                return dock_container


#------------------------------------------------------------------------------
# Layout Unplugging
#------------------------------------------------------------------------------
def _unplug(widget, container):
    """ The main unplug dispatch method.

    This method dispatches to the widget-specific handlers.

    """
    if isinstance(widget, QDockContainer):
        return _unplug_container(widget, container)
    if isinstance(widget, QDockTabWidget):
        return _unplug_tab_widget(widget, container)
    if isinstance(widget, QDockSplitter):
        return _unplug_splitter(widget, container)
    raise TypeError("unhandled layout widget '%s'" % type(widget).__name__)


def _unplug_splitter(widget, container):
    """ The handler for a QDockSplitter widget.

    This method will dispatch to the child handlers, and then clean
    up the splitter if there is only a single child remaining.

    """
    sizes = widget.sizes()
    for index in xrange(widget.count()):
        success, replace = _unplug(widget.widget(index), container)
        if success:
            if replace is not None:
                widget.insertWidget(index, replace)
                replace.show()
                widget.setSizes(sizes)
            replace = None
            if widget.count() == 1:
                replace = widget.widget(0)
                replace.hide()
                replace.setParent(None)
                widget.hide()
                widget.setParent(None)
            return True, replace
    return False, None


def _unplug_tab_widget(widget, container):
    """ The handler for a QDockTabWidget widget.

    This method will dispatch to the child handlers, and then clean
    up the tab widget if there is only a single child remaining.

    """
    for index in xrange(widget.count()):
        success, replace = _unplug(widget.widget(index), container)
        if success:
            assert replace is None  # tabs never hold replaceable items
            if widget.count() == 1:
                replace = widget.widget(0)
                replace.hide()
                replace.setParent(None)
                replace.showTitleBar()
                widget.hide()
                widget.setParent(None)
            return True, replace
    return False, None


def _unplug_container(widget, container):
    """ The handler for a QDockContainer widget.

    If the widget matches the container, this handler will hide and
    unparent the container.

    """
    if widget is container:
        widget.hide()
        widget.showTitleBar()
        widget.setParent(None)
        return True, None
    return False, None


#------------------------------------------------------------------------------
# Layout Plugging
#------------------------------------------------------------------------------
def _merge_dock_bars(first, second):
    """ Merge the dock bars from the second area into the first.

    """
    for container, position in second.dockBarContainers():
        container.unplug()
        first.addToDockBar(container, position)


def _merge_splitter(first, index, second):
    """ Merge one splitter into another at a given index.

    """
    if first.orientation() != second.orientation():
        first.insertWidget(index, second)
        second.show()
    else:
        items = [second.widget(i) for i in xrange(second.count())]
        for item in reversed(items):
            first.insertWidget(index, item)
            item.show()


def _splitter_insert_frame(area, splitter, index, frame):
    """ Insert a frame into a splitter at a given index.

    """
    if isinstance(frame, QDockWindow):
        temp_area = frame.dockArea()
        frame.setDockArea(None)
        _merge_dock_bars(area, temp_area)
        widget = temp_area.centralWidget()
        if isinstance(widget, QDockSplitter):
            _merge_splitter(splitter, index, widget)
        elif widget is not None:
            splitter.insertWidget(index, widget)
            widget.show()
    else:
        if frame.isWindow():
            frame.unfloat()
        splitter.insertWidget(index, frame)
        frame.show()


def _split_root_helper(area, orientation, frame, append):
    """ Split the root layout widget according the orientation.

    """
    widget = area.centralWidget()
    is_splitter = isinstance(widget, QDockSplitter)
    if not is_splitter or widget.orientation() != orientation:
        new = QDockSplitter(orientation)
        area.setCentralWidget(new)
        new.inheritOpaqueResize()
        new.addWidget(widget)
        widget.show()
        widget = new
    index = widget.count() if append else 0
    _splitter_insert_frame(area, widget, index, frame)
    return True


def _plug_border_north(area, widget, frame, guide):
    """ Plug the frame to the north border of the area.

    """
    return _split_root_helper(area, Qt.Vertical, frame, False)


def _plug_border_east(area, widget, frame, guide):
    """ Plug the frame to the east border of the area.

    """
    return _split_root_helper(area, Qt.Horizontal, frame, True)


def _plug_border_south(area, widget, frame, guide):
    """ Plug the frame to the south border of the area.

    """
    return _split_root_helper(area, Qt.Vertical, frame, True)


def _plug_border_west(area, widget, frame, guide):
    """ Plug the frame to the west border of the area.

    """
    return _split_root_helper(area, Qt.Horizontal, frame, False)


def _split_widget_helper(area, orientation, widget, frame, append):
    """ Split the widget according the orientation.

    """
    splitter = widget.parent()
    if not isinstance(splitter, QDockSplitter):
        return False
    index = splitter.indexOf(widget)
    if splitter.orientation() == orientation:
        index += 1 if append else 0
        _splitter_insert_frame(area, splitter, index, frame)
        return True
    sizes = splitter.sizes()
    new = QDockSplitter(orientation)
    new.addWidget(widget)
    splitter.insertWidget(index, new)
    new.inheritOpaqueResize()
    index = new.count() if append else 0
    _splitter_insert_frame(area, new, index, frame)
    splitter.setSizes(sizes)
    return True


def _plug_compass_north(area, widget, frame, guide):
    """ Plug the frame to the north of the widget.

    """
    root = area.centralWidget()
    if widget is root:
        return _split_root_helper(area, Qt.Vertical, frame, False)
    return _split_widget_helper(area, Qt.Vertical, widget, frame, False)


def _plug_compass_east(area, widget, frame, guide):
    """ Plug the frame to the east of the widget.

    """
    root = area.centralWidget()
    if widget is root:
        return _split_root_helper(area, Qt.Horizontal, frame, True)
    return _split_widget_helper(area, Qt.Horizontal, widget, frame, True)


def _plug_compass_south(area, widget, frame, guide):
    """ Plug the frame to the south of the widget.

    """
    root = area.centralWidget()
    if widget is root:
        return _split_root_helper(area, Qt.Vertical, frame, True)
    return _split_widget_helper(area, Qt.Vertical, widget, frame, True)


def _plug_compass_west(area, widget, frame, guide):
    """ Plug the frame to the west of the widget.

    """
    root = area.centralWidget()
    if widget is root:
        return _split_root_helper(area, Qt.Horizontal, frame, False)
    return _split_widget_helper(area, Qt.Horizontal, widget, frame, False)


def _tabs_add_frame(area, tabs, frame):
    """ Add a frame to a dock tab widget.

    """
    containers = []
    if isinstance(frame, QDockWindow):
        temp_area = frame.dockArea()
        frame.setDockArea(None)
        _merge_dock_bars(area, temp_area)
        containers.extend(iter_containers(temp_area))
    else:
        containers.append(frame)
    for container in containers:
        if container.isWindow():
            container.unfloat()
        container.hideTitleBar()
        tabs.addTab(container, container.icon(), container.title())
        container.show()
    tabs.setCurrentIndex(tabs.count() - 1)


def _tabify_helper(area, widget, frame, tab_pos):
    """ Create a tab widget from the widget and frame.

    """
    if isinstance(widget, QDockTabWidget):
        if widget.tabPosition() != tab_pos:
            return False
        _tabs_add_frame(area, widget, frame)
        return True
    if not isinstance(widget, QDockContainer):
        return False
    root = area.centralWidget()
    if widget is not root:
        if not isinstance(widget.parent(), QDockSplitter):
            return False
    tabs = QDockTabWidget()
    tabs.setTabPosition(tab_pos)
    if widget is root:
        area.setCentralWidget(tabs)
        _tabs_add_frame(area, tabs, widget)
        _tabs_add_frame(area, tabs, frame)
    else:
        splitter = widget.parent()
        sizes = splitter.sizes()
        index = splitter.indexOf(widget)
        splitter.insertWidget(index, tabs)
        _tabs_add_frame(area, tabs, widget)
        _tabs_add_frame(area, tabs, frame)
        splitter.setSizes(sizes)
    return True


def _plug_compass_center(area, widget, frame, guide):
    """ Create a tab widget from the widget and frame.

    """
    default = widget if isinstance(widget, QDockTabWidget) else area
    position = default.tabPosition()
    return _tabify_helper(area, widget, frame, position)


def _plug_compass_ex_north(area, widget, frame, guide):
    """ Create a north tab widget from the widget and frame.

    """
    return _tabify_helper(area, widget, frame, QDockTabWidget.North)


def _plug_compass_ex_east(area, widget, frame, guide):
    """ Create a east tab widget from the widget and frame.

    """
    return _tabify_helper(area, widget, frame, QDockTabWidget.East)


def _plug_compass_ex_south(area, widget, frame, guide):
    """ Create a south tab widget from the widget and frame.

    """
    return _tabify_helper(area, widget, frame, QDockTabWidget.South)


def _plug_compass_ex_west(area, widget, frame, guide):
    """ Create a west tab widget from the widget and frame.

    """
    return _tabify_helper(area, widget, frame, QDockTabWidget.West)


def _split_handle_helper(area, handle, frame):
    """ Split the splitter handle with the given frame.

    """
    splitter = handle.parent()
    for index in xrange(1, splitter.count()):
        if splitter.handle(index) is handle:
            _splitter_insert_frame(area, splitter, index, frame)
            return True
    return False


def _plug_split_vertical(area, widget, frame, guide):
    """ Plug a frame onto a vertical split handle.

    """
    if not isinstance(widget, QDockSplitterHandle):
        return False
    if widget.orientation() != Qt.Vertical:
        return False
    return _split_handle_helper(area, widget, frame)


def _plug_split_horizontal(area, widget, frame, guide):
    """ Plug a frame onto a horizontal split handle.

    """
    if not isinstance(widget, QDockSplitterHandle):
        return False
    if widget.orientation() != Qt.Horizontal:
        return False
    return _split_handle_helper(area, widget, frame)


def _plug_area_center(area, widget, frame, guide):
    """ Plug the frame as the area center.

    """
    if widget is not None:
        return False
    if isinstance(frame, QDockWindow):
        temp_area = frame.dockArea()
        frame.setDockArea(None)
        _merge_dock_bars(area, temp_area)
        area.setCentralWidget(temp_area.centralWidget())
    else:
        if frame.isWindow():
            frame.unfloat()
        area.setCentralWidget(frame)
    return True


def _plug_border_ex(area, frame, dock_bar_pos):
    """ Plug the frame into the specified dock bar.

    """
    containers = []
    if isinstance(frame, QDockWindow):
        temp_area = frame.dockArea()
        frame.setDockArea(None)
        _merge_dock_bars(area, temp_area)
        containers.extend(iter_containers(temp_area))
    else:
        containers.append(frame)
    for container in containers:
        if container.isWindow():
            container.unfloat()
        container.showTitleBar()
        area.addToDockBar(container, dock_bar_pos)
    return True


def _plug_border_ex_north(area, widget, frame, guide):
    """ Plug the frame into the north dock bar.

    """
    return _plug_border_ex(area, frame, QDockBar.North)


def _plug_border_ex_east(area, widget, frame, guide):
    """ Plug the frame into the east dock bar.

    """
    return _plug_border_ex(area, frame, QDockBar.East)


def _plug_border_ex_south(area, widget, frame, guide):
    """ Plug the frame into the south dock bar.

    """
    return _plug_border_ex(area, frame, QDockBar.South)


def _plug_border_ex_west(area, widget, frame, guide):
    """ Plug the frame into the west dock bar.

    """
    return _plug_border_ex(area, frame, QDockBar.West)


_PLUG_HANDLERS = [
    lambda a, w, f, g: False,   # Guide.NoGuide
    _plug_border_north,         # Guide.BorderNorth
    _plug_border_east,          # Guide.BorderEast
    _plug_border_south,         # Guide.BorderSouth
    _plug_border_west,          # Guide.BorderWest
    _plug_compass_north,        # Guide.CompassNorth
    _plug_compass_east,         # Guide.CompassEast
    _plug_compass_south,        # Guide.CompassSouth
    _plug_compass_west,         # Guide.CompassWest
    _plug_compass_center,       # Guide.CompassCenter
    _plug_compass_ex_north,     # Guide.CompassExNorth
    _plug_compass_ex_east,      # Guide.CompassExEast
    _plug_compass_ex_south,     # Guide.CompassExSouth
    _plug_compass_ex_west,      # Guide.CompassExWest
    _plug_split_vertical,       # Guide.SplitVertical
    _plug_split_horizontal,     # Guide.SplitHorizontal
    _plug_area_center,          # Guide.AreaCenter
    _plug_border_ex_north,      # Guide.BorderExNorth
    _plug_border_ex_east,       # Guide.BorderExEast
    _plug_border_ex_south,      # Guide.BorderExSouth
    _plug_border_ex_west,       # Guide.BorderExWest
]

########NEW FILE########
__FILENAME__ = layout_saver
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from collections import defaultdict

from enaml.layout.dock_layout import (
    ItemLayout, SplitLayout, TabLayout, DockBarLayout, AreaLayout
)
from enaml.nodevisitor import NodeVisitor

from enaml.qt.QtCore import Qt

from .q_dock_bar import QDockBar
from .q_dock_tab_widget import QDockTabWidget


class LayoutSaver(NodeVisitor):
    """ A node visitor which saves the layout for a dock widget.

    Instances of this class can be reused to build multiple layouts.

    """
    BAR_POSITIONS = {
        QDockBar.North: 'top',
        QDockBar.East: 'right',
        QDockBar.South: 'bottom',
        QDockBar.West: 'left',
    }

    TAB_POSITION = {
        QDockTabWidget.North: 'top',
        QDockTabWidget.South: 'bottom',
        QDockTabWidget.West: 'left',
        QDockTabWidget.East: 'right',
    }

    ORIENTATION = {
        Qt.Horizontal: 'horizontal',
        Qt.Vertical: 'vertical',
    }

    def setup(self, node):
        """ Setup the the layout saver.

        """
        self.stack = []

    def result(self, node):
        """ Get the results of the visitor.

        This returns the last item pushed onto the stack.

        """
        return self.stack[-1]

    def teardown(self, node):
        """ Teardown the layout builder.

        """
        del self.stack

    def init_floating_node(self, node, frame):
        """ Initialize a floating node for the given frame.

        Parameters
        ----------
        node : ItemLayout or AreaLayout
            The layout node for the given floating frame.

        frame : QDockFrame
            The floating dock frame.

        """
        node.floating = True
        node.linked = frame.isLinked()
        node.maximized = frame.isMaximized()
        if frame.isMaximized():
            geo = frame.normalGeometry()
        else:
            geo = frame.geometry()
        node.geometry = (geo.x(), geo.y(), geo.width(), geo.height())

    def visit_QDockContainer(self, container):
        """ Visit a QDockContainer node.

        This visitor generates an ItemLayout for the container and
        pushes it onto the stack.

        """
        layout = ItemLayout(container.objectName())
        if container.isWindow():
            self.init_floating_node(layout, container)
        self.stack.append(layout)

    def visit_QDockTabWidget(self, tabs):
        """ Visit a QDockTabWidget node.

        This visitor generates a TabLayout for the tab widget and
        pushes it onto the stack.

        """
        children = []
        for index in xrange(tabs.count()):
            self.visit(tabs.widget(index))
            children.append(self.stack.pop())
        layout = TabLayout(*children)
        layout.index = tabs.currentIndex()
        layout.tab_position = self.TAB_POSITION[tabs.tabPosition()]
        self.stack.append(layout)

    def visit_QDockSplitter(self, splitter):
        """ Visit a QDockSplitter node.

        This visitor generates a SplitLayout for the splitter and
        pushes it onto the stack.

        """
        children = []
        for index in xrange(splitter.count()):
            self.visit(splitter.widget(index))
            children.append(self.stack.pop())
        layout = SplitLayout(*children)
        layout.orientation = self.ORIENTATION[splitter.orientation()]
        layout.sizes = splitter.sizes()
        self.stack.append(layout)

    def visit_QDockArea(self, area):
        """ Visit a QDockArea node.

        This visitor generates an AreaLayout for the area and pushes
        it onto the stack.

        """
        central = area.centralWidget()
        if central is None:
            layout = AreaLayout()
        else:
            self.visit(central)
            layout = AreaLayout(self.stack.pop())
        bar_data = defaultdict(list)
        for container, position in area.dockBarContainers():
            bar_data[position].append(container.objectName())
        for bar_pos, names in bar_data.iteritems():
            bar = DockBarLayout(*names, position=self.BAR_POSITIONS[bar_pos])
            layout.dock_bars.append(bar)
        maxed = area.maximizedWidget()
        if maxed is not None:
            name = maxed.objectName()
            for item in layout.find_all(ItemLayout):
                if item.name == name:
                    item.maximized = True
                    break
        self.stack.append(layout)

    def visit_QDockWindow(self, window):
        """ Visit a QDockWindow node.

        This visitor generates an AreaLayout for the window and pushes
        it onto the stack.

        """
        self.visit(window.dockArea())
        layout = self.stack.pop()
        self.init_floating_node(layout, window)
        self.stack.append(layout)

########NEW FILE########
__FILENAME__ = proximity_handler
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, Typed, Value

from enaml.qt.QtCore import QObject

from .q_dock_frame import QDockFrame


class ProximityHandler(QObject):
    """ A class which manages movement of free floating dock frames.

    This class handles the movement of frames, taking into account the
    state of their link button and their proximity to other frames.

    """
    class GraphNode(Atom):
        """ An internal graph node class for the proximity handler.

        """
        #: The dock frame associated with the node.
        frame = Typed(QDockFrame)

        #: The set of bi-direction vertices linked to this node.
        vertices = Typed(set, ())

        #: The tag value used for marking a node during a traversal.
        tag = Value()

        def link(self, node):
            """ Link this node with another vertex.

            Parameters
            ----------
            node : GraphNode
                The node to link with this vertex.

            """
            if node is not self:
                self.vertices.add(node)
                node.vertices.add(self)

        def unlink(self):
            """ Unlink this node from the connected vertices.

            """
            for vertex in self.vertices:
                vertex.vertices.discard(self)
            del self.vertices

    def __init__(self):
        """ Initialize a ProximityHandler.

        """
        super(ProximityHandler, self).__init__()
        self._nodes = {}

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _onLinkToggled(self):
        """ Handle the 'linkButtonToggled' signal on a dock frame.

        """
        self.updateLinks(self.sender())

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def addFrame(self, frame):
        """ Add a dock frame to the proximity handler.

        Parameters
        ----------
        frame : QDockFrame
            The frame to add to the handler. If the frame has already
            been added, this is a no-op.

        """
        nodes = self._nodes
        if frame in nodes:
            return
        nodes[frame] = self.GraphNode(frame=frame)
        frame.linkButtonToggled.connect(self._onLinkToggled)

    def removeFrame(self, frame):
        """ Remove a dock frame from the proximity handler.

        Parameters
        ----------
        frame : QDockFrame
            The frame to remove from the handler. If the frame does not
            exist in the handler, this is a no-op.

        """
        nodes = self._nodes
        if frame not in nodes:
            return
        nodes.pop(frame).unlink()
        frame.linkButtonToggled.disconnect(self._onLinkToggled)

    def hasLinkedFrames(self, frame):
        """ Get whether or not the frame has linked proximal frames.

        Parameters
        ----------
        frame : QDockFrame
            The frame of interest.

        Returns
        -------
        result : bool
            True if the frame has linked proximal frames, False
            otherwise.

        """
        nodes = self._nodes
        if frame in nodes:
            return len(nodes[frame].vertices) > 0
        return False

    def linkedFrames(self, frame):
        """ Get an iterable of linked proximal frames.

        Parameters
        ----------
        frame : QDockFrame
            The frame of interest.

        Returns
        -------
        result : generator
            A generator which yields the linked proximal frames.

        """
        nodes = self._nodes
        if frame in nodes:
            node = nodes[frame]
            vertices = node.vertices
            if len(vertices) > 0:
                tag = object()
                node.tag = tag
                stack = list(vertices)
                while stack:
                    node = stack.pop()
                    if node.tag is tag:
                        continue
                    node.tag = tag
                    yield node.frame
                    stack.extend(node.vertices)

    def updateLinks(self, frame):
        """ Update the proximal linked frames for the given frame.

        Parameters
        ----------
        frame : QDockFrame
            The frame of interest.

        """
        nodes = self._nodes
        if frame in nodes:
            node = nodes[frame]
            node.unlink()
            if frame.isLinked():
                rect = frame.frameGeometry()
                for proximal in self.proximalFrames(rect, 1):
                    if proximal is not frame and proximal.isLinked():
                        node.link(nodes[proximal])

    def proximalFrames(self, rect, distance):
        """ Get an iterable of proximal frames for a gap distance.

        Parameters
        ----------
        rect : QRect
            The rectangle of interest.

        distance : int
            The gap distance to consider a frame proximal. This
            should be greater than or equal to zero.

        Returns
        -------
        result : generator
            A generator which yields the frames in proximity to
            the given rect.

        """
        d = max(0, distance)
        for frame in self._nodes:
            f_rect = frame.frameGeometry().adjusted(-d, -d, d, d)
            if rect.intersects(f_rect):
                yield frame

########NEW FILE########
__FILENAME__ = q_bitmap_button
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from enaml.qt.QtCore import QPoint, QRect, QEvent
from enaml.qt.QtGui import (
    QAbstractButton, QColor, QPainter, QStyle, QStyleOption, QToolTip
)


class QBitmapButton(QAbstractButton):
    """ A button widget which renders a bitmap.

    This class is used to render the various maximize, restore, and
    close buttons in the docking framework. Bitmap images are chosen
    for rendering so that the button can be fully styled using Qt
    style sheets.

    """
    _bitmap = None

    def bitmap(self):
        """ Get the bitmap associated with the button.

        """
        return self._bitmap

    def setBitmap(self, bitmap):
        """ Set the bitmap associate with the button.

        """
        self._bitmap = bitmap
        self.update()

    def sizeHint(self):
        """ Get the size hint for the bitmap button.

        The size hint of the button is equal to it's icon size.

        """
        return self.minimumSizeHint()

    def minimumSizeHint(self):
        """ Get the minimum size hint for the bitmap button.

        The minimum size hint of the button is equal to it's icon size.

        """
        return self.iconSize()

    def enterEvent(self, event):
        """ Handle the enter event for the button.

        """
        if self.isEnabled():
            self.update()
        super(QBitmapButton, self).enterEvent(event)

    def leaveEvent(self, event):
        """ Handle the leave event for the button.

        """
        if self.isEnabled():
            self.update()
        super(QBitmapButton, self).leaveEvent(event)

    def styleOption(self):
        """ Get a filled style option for the button.

        Returns
        -------
        result : QStyleOption
            A style option initialized for the current button state.

        """
        opt = QStyleOption()
        opt.initFrom(self)
        opt.state |= QStyle.State_AutoRaise
        is_down = self.isDown()
        is_enabled = self.isEnabled()
        is_checked = self.isChecked()
        under_mouse = self.underMouse()
        if is_enabled and under_mouse and not is_checked and not is_down:
            opt.state |= QStyle.State_Raised
        if is_checked:
            opt.state |= QStyle.State_On
        if is_down:
            opt.state |= QStyle.State_Sunken
        return opt

    def drawBitmap(self, bmp, opt, painter):
        """ Draw the bitmap for the button.

        The bitmap will be drawn with the foreground color set by
        the style sheet and the style option.

        Parameters
        ----------
        bmp : QBitmap
            The bitmap to draw.

        opt : QStyleOption
            The style option to use for drawing.

        painter : QPainter
            The painter to use for drawing.

        """
        # hack to get the current stylesheet foreground color
        hint = QStyle.SH_GroupBox_TextLabelColor
        fg = self.style().styleHint(hint, opt, self)
        # mask signed to unsigned which 'fromRgba' requires
        painter.setPen(QColor.fromRgba(0xffffffff & fg))
        size = self.size()
        im_size = bmp.size()
        x = size.width() / 2 - im_size.width() / 2
        y = size.height() / 2 - im_size.height() / 2
        source = QRect(QPoint(0, 0), im_size)
        dest = QRect(QPoint(x, y), im_size)
        painter.drawPixmap(dest, bmp, source)

    def paintEvent(self, event):
        """ Handle the paint event for the button.

        """
        painter = QPainter(self)
        opt = self.styleOption()
        self.style().drawPrimitive(QStyle.PE_Widget, opt, painter, self)
        bmp = self._bitmap
        if bmp is not None:
            self.drawBitmap(bmp, opt, painter)


class QCheckedBitmapButton(QBitmapButton):
    """ A bitmap button subclass which supports a checked bitmap.

    """
    _tool_tip = u''
    _checked_tool_tip = u''
    _checked_bitmap = None

    def __init__(self, parent=None):
        """ Initialize a QCheckedBitmapButton.

        Parameters
        ----------
        parent : QWidget or None
            The parent widget of the button.

        """
        super(QCheckedBitmapButton, self).__init__(parent)
        self.setCheckable(True)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _effectiveToolTip(self):
        """ Get the current effective tool tip for the button.

        """
        if self.isChecked():
            tool_tip = self._checked_tool_tip or self._tool_tip
        else:
            tool_tip = self._tool_tip
        return tool_tip

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def toolTip(self):
        """ Get the tool tip for the button.

        """
        return self._tool_tip

    def setToolTip(self, tool_tip):
        """ Set the tool tip for the button.

        """
        self._tool_tip = tool_tip

    def checkedToolTip(self):
        """ Get the checked tool tip for the button.

        """
        return self._checked_tool_tip

    def setCheckedToolTip(self, tool_tip):
        """ Set the checked tool tip for the button.

        """
        self._checked_tool_tip = tool_tip

    def checkedBitmap(self):
        """ Get the bitmap associated with the button checked state.

        """
        return self._checked_bitmap

    def setCheckedBitmap(self, bitmap):
        """ Set the bitmap associate with the button checked state.

        """
        self._checked_bitmap = bitmap
        self.update()

    def event(self, event):
        """ A generic event handler for the button.

        This handler shows the effective tool tip on a tool tip event.

        """
        if event.type() == QEvent.ToolTip:
            tool_tip = self._effectiveToolTip()
            if tool_tip:
                QToolTip.showText(event.globalPos(), tool_tip, self)
            return True
        return super(QCheckedBitmapButton, self).event(event)

    def paintEvent(self, event):
        """ Handle the paint event for the button.

        """
        painter = QPainter(self)
        opt = self.styleOption()
        self.style().drawPrimitive(QStyle.PE_Widget, opt, painter, self)
        if self.isChecked():
            bmp = self._checked_bitmap or self._bitmap
        else:
            bmp = self._bitmap
        if bmp is not None:
            self.drawBitmap(bmp, opt, painter)

########NEW FILE########
__FILENAME__ = q_dock_area
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from enaml.qt.QtCore import QMargins, QSize, QEvent
from enaml.qt.QtGui import (
    QFrame, QLayout, QTabWidget, QGridLayout, QStackedLayout, QVBoxLayout,
    QWidget, QStyle, QStyleOption
)

from .q_dock_bar import QDockBarManager


class QDockAreaLayout(QStackedLayout):
    """ A custom stacked layout for the QDockArea.

    This stacked layout reports its size hints according to the widget
    which is currently visible, as opposed to aggregated hints which is
    the default.

    """
    def sizeHint(self):
        """ Get the size hint for the layout.

        """
        widget = self.currentWidget()
        if widget is not None:
            return widget.sizeHint()
        return QSize(256, 192)

    def minimumSize(self):
        """ Get the minimum size for the layout.

        """
        widget = self.currentWidget()
        if widget is not None:
            return widget.minimumSizeHint()
        return QSize(256, 192)


class QDockArea(QFrame):
    """ A custom QFrame which provides an area for docking QDockItems.

    A dock area is used by creating QDockItem instances using the dock
    area as the parent. A DockLayout instance can then be created and
    applied to the dock area with the 'setDockLayout' method. The names
    in the DockLayoutItem objects are used to find the matching dock
    item widget child.

    """
    def __init__(self, parent=None):
        """ Initialize a QDockArea.

        Parameters
        ----------
        parent : QWidget
            The parent of the dock area.

        """
        super(QDockArea, self).__init__(parent)
        self._dock_bar_manager = QDockBarManager(self)
        self._primary_pane = primary_pane = QWidget(self)
        self._central_pane = central_pane = QWidget(primary_pane)
        self._dock_events_enabled = False
        self._opaque_resize = None
        self._tab_position = None

        central_layout = QVBoxLayout()
        central_layout.setContentsMargins(QMargins(0, 0, 0, 0))
        central_layout.setSizeConstraint(QLayout.SetMinimumSize)
        central_pane.setLayout(central_layout)

        grid_layout = QGridLayout()
        grid_layout.setRowStretch(0, 0)
        grid_layout.setRowStretch(1, 1)
        grid_layout.setRowStretch(2, 0)
        grid_layout.setColumnStretch(0, 0)
        grid_layout.setColumnStretch(1, 1)
        grid_layout.setColumnStretch(2, 0)
        grid_layout.setContentsMargins(QMargins(0, 0, 0, 0))
        grid_layout.setSizeConstraint(QLayout.SetMinimumSize)
        grid_layout.addWidget(central_pane, 1, 1)
        primary_pane.setLayout(grid_layout)

        area_layout = QDockAreaLayout()
        area_layout.setContentsMargins(QMargins(0, 0, 0, 0))
        area_layout.setSizeConstraint(QLayout.SetMinimumSize)
        area_layout.insertWidget(0, primary_pane)
        self.setLayout(area_layout)
        self.updateSpacing()

    #--------------------------------------------------------------------------
    # Protected API
    #--------------------------------------------------------------------------
    def event(self, event):
        """ A generic event handler for the dock area.

        """
        if event.type() == QEvent.StyleChange:
            self.updateSpacing()
        return super(QDockArea, self).event(event)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def updateSpacing(self):
        """ Update the primary layout spacing for the dock area.

        This method will extract spacing value defined in the style
        sheet for the dock area and apply it to the spacing between
        the dock bars and the central widget.

        """
        opt = QStyleOption()
        opt.initFrom(self)
        style = self.style()
        # hack to get the style sheet 'spacing' property.
        spacing = style.pixelMetric(QStyle.PM_ToolBarItemSpacing, opt, self)
        grid_layout = self._primary_pane.layout()
        grid_layout.setVerticalSpacing(spacing)
        grid_layout.setHorizontalSpacing(spacing)

    def centralPane(self):
        """ Get the central pane for the dock area.

        This method is used the dock bar manager to access the central
        layout pane. It should not normally be called by user code.

        Returns
        -------
        result : QWidget
            The central pane for the dock area.

        """
        return self._central_pane

    def primaryPane(self):
        """ Get the primary pane for the dock area.

        This method is used the dock bar manager to access the primary
        layout pane. It should not normally be called by user code.

        Returns
        -------
        result : QWidget
            The primary pane for the dock area.

        """
        return self._primary_pane

    def centralWidget(self):
        """ Get the central dock widget for the area.

        This method is called by the dock manager which handles the
        dock area. It should not normally be called by user code.

        Returns
        -------
        result : QWidget or None
            The central dock widget for the area, or None if no widget
            is installed.

        """
        item = self._central_pane.layout().itemAt(0)
        if item is not None:
            return item.widget()

    def setCentralWidget(self, widget):
        """ Set the central widget for the dock area.

        This method is called by the dock manager which handles the
        dock area. It should not normally be called by user code.

        Parameters
        ----------
        widget : QWidget
            The central widget for the dock area.

        """
        layout = self._central_pane.layout()
        item = layout.itemAt(0)
        if item is not None:
            old = item.widget()
            if old is widget:
                return
            old.hide()
            old.setParent(None)
        if widget is not None:
            layout.addWidget(widget)
            # lower the widget to keep it stacked behind any pinned
            # containers which are in the slide-out position.
            widget.lower()
            widget.show()

    def maximizedWidget(self):
        """ Get the widget to that is set as the maximized widget.

        Returns
        -------
        result : QWidget or None
            The widget which is maximized over the dock area.

        """
        return self.layout().widget(1)

    def setMaximizedWidget(self, widget):
        """ Set the widget to maximize over the dock area.

        Returns
        -------
        result : QWidget or None
            The widget to maximize over the dock area.

        """
        old = self.maximizedWidget()
        if old is not None:
            if old is widget:
                return
            old.hide()
            old.setParent(None)
        if widget is not None:
            layout = self.layout()
            layout.insertWidget(1, widget)
            layout.setCurrentIndex(1)
            widget.show()

    def addToDockBar(self, container, position, index=-1):
        """ Add a container to the dock bar at the given position.

        Parameters
        ----------
        container : QDockContainer
            The dock container to add to the dock bar. The container
            should be unplugged from any other layout before calling
            this method.

        position : QDockBar.Position
            The enum value specifying the dock bar to which the
            container should be added.

        index : int, optional
            The index at which to insert the item. The default is -1
            and will append the item to the dock bar.

        """
        self._dock_bar_manager.addContainer(container, position, index)

    def removeFromDockBar(self, container):
        """ Remove a container previously added to a dock bar.

        Parameters
        ----------
        container : QDockContainer
            The dock container to remove from the dock bar.

        """
        self._dock_bar_manager.removeContainer(container)

    def dockBarGeometry(self, position):
        """ Get the geometry of the dock bar at the given position.

        Parameters
        ----------
        position : QDockBar.Position
            The enum value specifying the dock bar of interest.

        Returns
        -------
        result : QRect
            The geometry of the given dock bar expressed in area
            coordinates. If no dock bar exists at the given position,
            an invalid QRect will be returned.

        """
        return self._dock_bar_manager.dockBarGeometry(position)

    def dockBarContainers(self):
        """ Get the containers held in the dock bars.

        Returns
        -------
        result : list
            A list of tuples of the form (container, position).

        """
        return self._dock_bar_manager.dockBarContainers()

    def dockBarPosition(self, container):
        """ Get the dock bar position of the given container.

        Parameters
        ----------
        container : QDockContainer
            The dock container of interest.

        Returns
        -------
        result : QDockBar.Position or None
            The position of the container, or None if the container
            does not exist in the manager.

        """
        return self._dock_bar_manager.dockBarPosition(container)

    def extendFromDockBar(self, container):
        """ Extend the given container from its dock bar.

        If the container does not exist in a dock bar, this is a no-op.

        Parameters
        ----------
        container : QDockContainer
            The dock container of interest.

        """
        self._dock_bar_manager.extendContainer(container)

    def retractToDockBar(self, container):
        """ Retract the given container into it's dock bar.

        If the container does not exist in a dock bar, this is a no-op.

        Parameters
        ----------
        container : QDockContainer
            The dock container of interest.

        """
        self._dock_bar_manager.retractContainer(container)

    def clearDockBars(self):
        """ Clear the dock bars from the dock area.

        This method is called by the dock manager when the dock area
        is reset. It should not be called directly by user code.

        """
        self._dock_bar_manager.clearDockBars()

    def isEmpty(self):
        """ Get whether or not the dock area is empty.

        Returns
        -------
        result : bool
            True if the dock area is empty, False otherwise.

        """
        if self.centralWidget() is not None:
            return False
        if self.maximizedWidget() is not None:
            return False
        return self._dock_bar_manager.isEmpty()

    def tabPosition(self):
        """ Get the default position for newly created tab widgets.

        The tab position is inherited from an ancestor dock area unless
        it is explicitly set by the user.

        Returns
        -------
        result : QTabWidget.TabPosition
            The position for dock area tabs. If the value has not been
            set by the user and there is no ancestor dock area, the
            default is QTabWidget.North.

        """
        pos = self._tab_position
        if pos is not None:
            return pos
        p = self.parent()
        while p is not None:
            if isinstance(p, QDockArea):
                return p.tabPosition()
            p = p.parent()
        return QTabWidget.North

    def setTabPosition(self, position):
        """ Set the default position for newly created tab widget.

        Parameters
        ----------
        position : QTabWidget.TabPosition
            The position for the tabs of newly created tab widgets.

        """
        self._tab_position = position

    def dockEventsEnabled(self):
        """ Get whether dock events are enabled for the area.

        Returns
        -------
        result : bool
            True if dock events are enabled, False otherwise.

        """
        return self._dock_events_enabled

    def setDockEventsEnabled(self, enabled):
        """ Set whether dock events are enabled for the area.

        If events are enabled, then the various widgets involved with
        the dock area will post events to the *root* dock area when the
        various states have changed. If events are disabled, no such
        events will be posted.

        Parameters
        ----------
        enabled : bool
            True if dock events should be enabled, False otherwise.

        """
        self._dock_events_enabled = enabled

    def opaqueItemResize(self):
        """ Get whether opaque item resize is enabled.

        The tab position is inherited from an ancestor dock area unless
        it is explicitly set by the user.

        Returns
        -------
        result : bool
            True if item resizing is opaque, False otherwise. If the
            value has not been set by the user and there is no ancestor
            dock area, the default is True.

        """
        opaque = self._opaque_resize
        if opaque is not None:
            return opaque
        p = self.parent()
        while p is not None:
            if isinstance(p, QDockArea):
                return p.opaqueItemResize()
            p = p.parent()
        return True

    def setOpaqueItemResize(self, opaque):
        """ Set whether opaque item resize is enabled.

        Parameters
        ----------
        opaque : bool
            True if item resizing should be opaque, False otherwise.

        """
        is_different = opaque != self.opaqueItemResize()
        self._opaque_resize = opaque
        if is_different:
            # Avoid a circular import
            from .q_dock_splitter import QDockSplitter
            for sp in self.findChildren(QDockSplitter):
                sp.inheritOpaqueResize()

########NEW FILE########
__FILENAME__ = q_dock_bar
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import IntEnum

from enaml.qt.QtCore import (
    Qt, QSize, QPoint, QRect, QMargins, QEvent, QObject, QPropertyAnimation,
    Signal
)
from enaml.qt.QtGui import (
    QBoxLayout, QSizePolicy, QFrame, QPushButton, QStyle, QStyleOption,
    QStylePainter, QStyleOptionButton, QApplication, QVBoxLayout, QHBoxLayout,
    QLayout
)

from .event_types import (
    QDockItemEvent, DockItemExtended, DockItemRetracted,
    DockAreaContentsChanged
)
from .utils import repolish


class QDockBar(QFrame):
    """ A QFrame which acts as a container for QDockBarButtons.

    """
    class Position(IntEnum):
        """ An int enum defining the position for a dock bar.

        """
        #: The north pin position.
        North = 0

        #: The east pin position.
        East = 1

        #: The south pin position.
        South = 2

        #: The west pin position.
        West = 3

    #: Proxy the Position values as if it were an anonymous enum.
    North = Position.North
    East = Position.East
    South = Position.South
    West = Position.West

    #: A mapping from Position to layout direction.
    LayoutPositions = [
        QBoxLayout.LeftToRight,  # PinPosition.North
        QBoxLayout.TopToBottom,  # PinPosition.East
        QBoxLayout.LeftToRight,  # PinPosition.South
        QBoxLayout.TopToBottom,  # PinPosition.West
    ]

    def __init__(self, parent=None, position=Position.North):
        """ Initialize a QDockBar.

        Parameters
        ----------
        parent : QWidget, optional
            The parent widget of the dock bar.

        position : QDockBar.Position, optional
            The position enum value for the dock bar. This dictates the
            layout and orientation of the contained dock buttons. The
            default position is QDockBar.North.

        """
        super(QDockBar, self).__init__(parent)
        assert isinstance(position, QDockBar.Position)
        self.setProperty('position', int(position))
        layout = QBoxLayout(self.LayoutPositions[position])
        layout.setContentsMargins(QMargins(0, 0, 0, 0))
        layout.addStretch(1)
        self.setLayout(layout)
        self.updateSpacing()

    #--------------------------------------------------------------------------
    # Protected API
    #--------------------------------------------------------------------------
    def event(self, event):
        """ A generic event handler for the dock bar.

        """
        if event.type() == QEvent.StyleChange:
            self.updateSpacing()
        return super(QDockBar, self).event(event)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def updateSpacing(self):
        """ Update the layout spacing for the dock bar.

        This method will extract spacing value defined in the style
        sheet for the dock area and apply it to the spacing between
        the dock bars and the central widget.

        """
        opt = QStyleOption()
        opt.initFrom(self)
        style = self.style()
        # hack to get the style sheet 'spacing' property.
        spacing = style.pixelMetric(QStyle.PM_ToolBarItemSpacing, opt, self)
        self.layout().setSpacing(spacing)

    def position(self):
        """ Get the position of the dock bar.

        Returns
        -------
        result : QDockBar.Position
            The position enum value for the dock bar.

        """
        return QDockBar.Position(self.property('position'))

    def isEmpty(self):
        """ Get whether or not the dock bar is empty.

        Returns
        -------
        result : bool
            True if the dock bar has dock buttons, False otherwise.

        """
        layout = self.layout()
        for index in xrange(layout.count()):
            item = layout.itemAt(index)
            if item.widget() is not None:
                return False
        return True

    def addButton(self, button):
        """ Add a dock button to the dock bar.

        Parameters
        ----------
        button : QDockBarButton
            The dock button to add to the dock bar.

        """
        return self.insertButton(-1, button)

    def insertButton(self, index, button):
        """ Insert a dock button into the dock bar.

        Parameters
        ----------
        index : int
            The index at which to insert the button.

        button : QDockBarButton
            The dock button to insert into the dock bar.

        """
        assert isinstance(button, QDockBarButton)
        layout = self.layout()
        if index < 0:
            index = layout.count()
        if index == layout.count():
            index = max(0, index - 1)
        layout.insertWidget(index, button)


class QDockBarButton(QPushButton):
    """ A custom QPushButton for use in a QDockBar.

    """
    def __init__(self, parent=None):
        """ Initialize a QDockBarButton.

        Parameters
        ----------
        parent : QWidget, optional
            The parent widget of the dock bar button.

        """
        super(QDockBarButton, self).__init__(parent)
        self.setSizePolicy(QSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed))
        self.setCheckable(True)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def position(self):
        """ Get the position for the dock bar button.

        Returns
        -------
        result : QDockBar.Position
            The position of the dock bar in which this button resides.

        """
        parent = self.parent()
        if isinstance(parent, QDockBar):
            return parent.position()
        return QDockBar.North

    def onAlerted(self, level):
        """ A slot which can be connected to an 'alerted' signal.

        """
        self.setProperty(u'alert', level or None)
        repolish(self)

    #--------------------------------------------------------------------------
    # Reimplementations
    #--------------------------------------------------------------------------
    def sizeHint(self):
        """ Get the size hint for the button.

        """
        hint = super(QDockBarButton, self).sizeHint()
        p = self.position()
        if p == QDockBar.East or p == QDockBar.West:
            hint.transpose()
        return hint

    def paintEvent(self, event):
        """ Handle the paint event for the button.

        """
        painter = QStylePainter(self)
        opt = QStyleOptionButton()
        self.initStyleOption(opt)
        opt.state &= ~QStyle.State_HasFocus  # don't draw the focus rect
        p = self.position()
        if p == QDockBar.East:
            size = opt.rect.size()
            size.transpose()
            opt.rect.setSize(size)
            painter.rotate(90)
            painter.translate(0, -size.height())
        elif p == QDockBar.West:
            size = opt.rect.size()
            size.transpose()
            opt.rect.setSize(size)
            painter.rotate(-90)
            painter.translate(-size.width(), 0)
        painter.drawControl(QStyle.CE_PushButton, opt)


class QDockBarItemHandle(QFrame):
    """ A frame which provides a resize border for a QDockBarItem.

    """
    #: A signal emitted when the handle is moved. The payload is a
    #: QPoint which represents the delta drag distance.
    handleMoved = Signal(QPoint)

    def __init__(self, parent=None):
        """ Initialize a QDockBarItemHandle.

        Parameters
        ----------
        parent : QWidget, optional
            The parent widget of the handle.

        """
        super(QDockBarItemHandle, self).__init__(parent)
        policy = QSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)
        self.setSizePolicy(policy)
        self._press_pos = QPoint()
        self._size_hint = QSize(5, 5)

    def sizeHint(self):
        """ Get the size hint for the widget.

        """
        return self._size_hint

    def mousePressEvent(self, event):
        """ Handle the mouse press event for the widget.

        """
        event.ignore()
        if event.button() == Qt.LeftButton:
            self._press_pos = event.pos()
            event.accept()

    def mouseReleaseEvent(self, event):
        """ Handle the mouse release event for the widget.

        """
        event.ignore()
        if event.button() == Qt.LeftButton:
            self._press_pos = QPoint()
            event.accept()

    def mouseMoveEvent(self, event):
        """ Handle the mouse move event for the widget.

        """
        event.ignore()
        if not self._press_pos.isNull():
            self.handleMoved.emit(event.pos() - self._press_pos)
            event.accept()


class QDockBarItem(QFrame):
    """ A QFrame which holds an item for a QDockBar.

    This class serves as a container which holds the dock widget of
    interest and a resize handle which permits resizing of the item.

    """
    def __init__(self, parent=None, position=QDockBar.North):
        """ Initialize a QDockBarItem.

        Parameters
        ----------
        parent : QWidget, optional
            The parent of the dock bar item.

        position : QDockBar.Position, optional
            The position of the dock bar for the item.

        """
        super(QDockBarItem, self).__init__(parent)
        assert isinstance(position, QDockBar.Position)
        self.setProperty('position', int(position))
        self._user_size = QSize()
        self._animation = None
        self._widget = None
        handle = QDockBarItemHandle()
        handle.handleMoved.connect(self._onHandleMoved)
        if position == QDockBar.North or position == QDockBar.South:
            layout = QVBoxLayout()
            handle.setCursor(Qt.SizeVerCursor)
        else:
            layout = QHBoxLayout()
            handle.setCursor(Qt.SizeHorCursor)
        layout.addWidget(handle, 0)
        layout.setSpacing(0)
        layout.setContentsMargins(QMargins(0, 0, 0, 0))
        layout.setSizeConstraint(QLayout.SetMinimumSize)
        self.setLayout(layout)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def _onHandleMoved(self, delta):
        """ Handle the 'handleMoved' signal on the item handle.

        This handler resizes the item by the delta and then updates
        the internal user size. The resize is bounded by the limits
        of the widget and the parent dock area size.

        Resizing is disabled if an animation is running.

        """
        animation = self._animation
        if animation and animation.state() == animation.Running:
            return
        p = self.position()
        if p == QDockBar.North:
            delta = QSize(0, delta.y())
        elif p == QDockBar.East:
            delta = QSize(-delta.x(), 0)
        elif p == QDockBar.South:
            delta = QSize(0, -delta.y())
        else:
            delta = QSize(delta.x(), 0)
        user_size = self.size() + delta
        user_size = user_size.expandedTo(self.minimumSize())
        parent = self.parent()
        if parent is not None:
            user_size = user_size.boundedTo(parent.size())
        self._user_size = user_size
        if p == QDockBar.East or p == QDockBar.South:
            d = user_size - self.size()
            p = self.pos() - QPoint(d.width(), d.height())
            self.setGeometry(QRect(p, user_size))
        else:
            self.resize(user_size)

    def widget(self):
        """ Get the primary widget for the dock bar item.

        Returns
        -------
        result : QWidget or None
            The primary dock widget installed on the item.

        """
        return self._widget

    def setWidget(self, widget):
        """ Set the primary widget for the dock bar item.

        Parameters
        ----------
        widget : QWidget or None
            The primary dock widget to install on the item. Any old
            widget will be unparented, but not destroyed.

        """
        old = self._widget
        if old is not None:
            old.setParent(None)
        self._widget = widget
        if widget is not None:
            index = (0, 1, 1, 0)[self.position()]
            layout = self.layout()
            layout.insertWidget(index, widget, 1)

    def position(self):
        """ Get the position of the dock bar item.

        Returns
        -------
        result : QDockBar.Position
            The position of the dock bar item.

        """
        return QDockBar.Position(self.property('position'))

    def animation(self):
        """ Get the animation object associated with the item.

        Returns
        -------
        result : QPropertyAnimation or None
            The property animation installed on the item.

        """
        return self._animation

    def setAnimation(self, animation):
        """ Set the animation object associated with the item.

        Parameters
        ----------
        animation : QPropertyAnimation or None
            The animation object to associate with this item.

        """
        self._animation = animation

    def sizeHint(self):
        """ Get the size hint for the item.

        """
        user = self._user_size
        if user.isValid():
            return user
        return super(QDockBarItem, self).sizeHint()


class QDockBarManager(QObject):
    """ An object which manages the dock bars for a QDockArea.

    """
    def __init__(self, parent):
        """ Initialize a QDockBarManager.

        Parameters
        ----------
        parent : QDockArea
            The parent dock area on which this manager should operate.

        """
        super(QDockBarManager, self).__init__(parent)
        self._dock_bars = [None, None, None, None]
        self._active_items = {}
        self._widgets = {}

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    #: A static mapping of dock position to grid layout coordinates.
    _layout_coords = [
        (0, 1, 1, 1),  # QDockBar.North
        (1, 2, 1, 1),  # QDockBar.East
        (2, 1, 1, 1),  # QDockBar.South
        (1, 0, 1, 1),  # QDockBar.West
    ]

    @staticmethod
    def _prepareAnimation(item):
        """ Prepare the animation object for a dock container.

        Parameters
        ----------
        item : QDockBarItem
            The item which should have an animation prepared.

        """
        animation = item.animation()
        if animation is not None:
            animation.stop()
            animation.finished.disconnect()
        else:
            animation = QPropertyAnimation(item, 'geometry')
            item.setAnimation(animation)
        return animation

    def _getDockBar(self, position, create=True):
        """ Get the dock bar for a given position.

        Parameters
        ----------
        position : QDockBar.Position
            The dock position of interest.

        create : bool, optional
            Whether to force create the bar if one does not exist. The
            default is True.

        Returns
        -------
        result : QDockBar or None
            The dock bar instance for the given position. If no dock
            bar exists, and `create` is False None will be returned.

        """
        dock_bar = self._dock_bars[position]
        if dock_bar is not None:
            return dock_bar
        if create:
            dock_bar = self._dock_bars[position] = QDockBar(position=position)
            coords = self._layout_coords[position]
            layout = self.parent().primaryPane().layout()
            layout.addWidget(dock_bar, *coords)
            return dock_bar

    def _trackForResize(self, item, slide_out):
        """ Track the given container for resize events on the pane.

        Parameters
        ----------
        item : QDockBarItem
            The dock bar item which should track pane resizes.

        slide_out : bool
            Whether the item is in the slide out position.

        """
        active = self._active_items
        install = len(active) == 0
        active[item] = slide_out
        if install:
            self.parent().centralPane().installEventFilter(self)

    def _untrackForResize(self, item):
        """ Untrack the given item for resize events on the pane.

        Parameters
        ----------
        item : QDockBarItem
            The dock bar item which should untrack pane resizes.

        """
        active = self._active_items
        active.pop(item, None)
        if len(active) == 0:
            self.parent().centralPane().removeEventFilter(self)

    def _slideOut(self, item):
        """ Animate the slide out for the given item.

        Parameters
        ----------
        item : QDockBarItem
            The dock bar item which should be slid out.

        """
        self._trackForResize(item, True)
        animation = self._prepareAnimation(item)
        animation.finished.connect(self._onSlideOutFinished)
        start_geo, end_geo = self._animationGeo(item)
        if item.isVisible():
            start_geo = item.geometry()
        else:
            item.setGeometry(start_geo)
            item.show()
        item.raise_()
        animation.setStartValue(start_geo)
        animation.setEndValue(end_geo)
        animation.start()

    def _slideIn(self, item):
        """ Animate the slide in for the given item.

        Parameters
        ----------
        item : QDockBarItem
            The dock bar item which should be slide in.

        """
        if not item.isVisible():
            return
        self._trackForResize(item, False)
        animation = self._prepareAnimation(item)
        animation.finished.connect(self._onSlideInFinished)
        start_geo = item.geometry()
        end_geo, ignored = self._animationGeo(item)
        animation.setStartValue(start_geo)
        animation.setEndValue(end_geo)
        animation.start()

    def _animationGeo(self, item):
        """ Get the animation geometry for the given item.

        Parameters
        ----------
        item : QDockBarItem
            The dock bar item to be animated.

        Returns
        -------
        result : tuple
            A 2-tuple of QRect objects representing the start and end
            geometries for the animation assuming a slide out effect.

        """
        pane = self.parent().centralPane()
        hint = item.sizeHint().boundedTo(pane.size())
        position = item.position()
        if position == QDockBar.North:
            start_pos = QPoint(0, -hint.height())
            end_pos = QPoint(0, 0)
            size = QSize(pane.width(), hint.height())
        elif position == QDockBar.East:
            start_pos = QPoint(pane.width(), 0)
            end_pos = QPoint(pane.width() - hint.width(), 0)
            size = QSize(hint.width(), pane.height())
        elif position == QDockBar.South:
            start_pos = QPoint(0, pane.height())
            end_pos = QPoint(0, pane.height() - hint.height())
            size = QSize(pane.width(), hint.height())
        else:
            start_pos = QPoint(-hint.width(), 0)
            end_pos = QPoint(0, 0)
            size = QSize(hint.width(), pane.height())
        start_geo = QRect(start_pos, size)
        end_geo = QRect(end_pos, size)
        return start_geo, end_geo

    def _toggleCheckedButtons(self, allowed):
        """ Toggle off the checked buttons.

        Parameters
        ----------
        allowed : QDockBarButton
            The dock button which should be allowed to remain checked.

        """
        for key in self._widgets:
            if isinstance(key, QDockBarButton):
                if key is not allowed and key.isChecked():
                    key.setChecked(False)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def _onButtonToggled(self, checked):
        """ Handle the 'toggled' signal from a QDockBarButton.

        """
        button = self.sender()
        if checked:
            self._toggleCheckedButtons(button)
        item = self._widgets.get(button)
        if item is not None:
            if checked:
                self._slideOut(item)
            else:
                self._slideIn(item)

    def _onSlideOutFinished(self):
        """ Handle the 'finished' signal from a slide out animation.

        """
        item = self.sender().targetObject()
        item.setAnimation(None)
        container = item.widget()
        area = container.manager().dock_area()
        if area.dockEventsEnabled():
            event = QDockItemEvent(DockItemExtended, container.objectName())
            QApplication.postEvent(area, event)

    def _onSlideInFinished(self):
        """ Handle the 'finished' signal from a slide in animation.

        """
        item = self.sender().targetObject()
        item.setAnimation(None)
        item.hide()
        self._untrackForResize(item)
        container = item.widget()
        area = container.manager().dock_area()
        if area.dockEventsEnabled():
            event = QDockItemEvent(DockItemRetracted, container.objectName())
            QApplication.postEvent(area, event)

    def _onButtonPressed(self):
        """ Handle the 'pressed' signal from a dock bar button.

        """
        button = self.sender()
        container = self._widgets[button].widget()
        container.dockItem().clearAlert()  # likey a no-op, but just in case

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def addContainer(self, container, position, index=-1):
        """ Add a container to the specified dock bar.

        Parameters
        ----------
        container : QDockContainer
            The container to add to the dock bar. It should already be
            unplugged from a layout or other dock manager before being
            added to this manager.

        position : QDockBar.Position
            The position of the dock bar to which the container should
            be added.

        index : int, optional
            The index at which to insert the item. The default is -1
            and will append the item to the dock bar.

        """
        assert isinstance(position, QDockBar.Position)
        self.removeContainer(container)
        container.setPinned(True, quiet=True)
        container.frame_state.in_dock_bar = True

        button = QDockBarButton()
        button.setText(container.title())
        button.setIcon(container.icon())
        button.toggled.connect(self._onButtonToggled)
        button.pressed.connect(self._onButtonPressed)
        container.alerted.connect(button.onAlerted)

        dock_bar = self._getDockBar(position)
        dock_bar.insertButton(index, button)

        item = QDockBarItem(self.parent().centralPane(), position=position)
        item.hide()
        item.setWidget(container)
        container.show()

        self._widgets[button] = item
        self._widgets[container] = button

        event = QEvent(DockAreaContentsChanged)
        QApplication.sendEvent(self.parent(), event)

    def removeContainer(self, container):
        """ Remove a container from its dock bar.

        Parameters
        ----------
        container : QDockContainer
            The container to remove from the dock bars.

        """
        button = self._widgets.pop(container, None)
        if button is not None:
            container.setParent(None)
            container.setPinned(False, quiet=True)
            container.frame_state.in_dock_bar = False
            container.alerted.disconnect(button.onAlerted)

            item = self._widgets.pop(button)
            item.setParent(None)
            self._untrackForResize(item)

            dock_bar = self._getDockBar(button.position())
            button.toggled.disconnect(self._onButtonToggled)
            button.setParent(None)
            if dock_bar.isEmpty():
                self._dock_bars[dock_bar.position()] = None
                dock_bar.setParent(None)

            event = QEvent(DockAreaContentsChanged)
            QApplication.sendEvent(self.parent(), event)

    def dockBarGeometry(self, position):
        """ Get the geometry of the dock bar at the given position.

        Parameters
        ----------
        position : QDockBar.Position
            The enum value specifying the dock bar of interest.

        Returns
        -------
        result : QRect
            The geometry of the given dock bar expressed in area
            coordinates. If no dock bar exists at the given position,
            an invalid QRect will be returned.

        """
        bar = self._getDockBar(position, create=False)
        if bar is None:
            return QRect()
        pos = bar.mapTo(self.parent(), QPoint(0, 0))
        return QRect(pos, bar.size())

    def dockBarContainers(self):
        """ Get the containers held in the dock bars.

        Returns
        -------
        result : list
            A list of tuples of the form (container, position).

        """
        res = []
        for value in self._widgets.itervalues():
            if isinstance(value, QDockBarItem):
                res.append((value.widget(), value.position()))
        return res

    def dockBarPosition(self, container):
        """ Get the dock bar position of the given container.

        Parameters
        ----------
        container : QDockContainer
            The dock container of interest.

        Returns
        -------
        result : QDockBar.Position or None
            The position of the container, or None if the container
            does not exist in the manager.

        """
        button = self._widgets.get(container)
        if button is not None:
            return button.position()

    def clearDockBars(self):
        """ Clear all of the items from the dock bars.

        This method can be called to unconditionally remove all of the
        dock bars and reset the internal state of the manager. It is
        used by the framework and should not be called by user code.

        """
        for bar in self._dock_bars:
            if bar is not None:
                bar.setParent(None)
        self._dock_bars = [None, None, None, None]
        self._active_items = {}
        self._widgets = {}

    def isEmpty(self):
        """ Get whether or not the dock bars are empty.

        Returns
        -------
        result : bool
            True if the dock bars are empty, False otherwise.

        """
        return len(self._widgets) == 0

    def extendContainer(self, container):
        """ Extend the specified container.

        Parameters
        ----------
        container : QDockContainer
            The container to put in the extended position. If the
            container does not exist in the manager, this method is
            a no-op.

        """
        button = self._widgets.get(container)
        if button is not None:
            button.setChecked(True)

    def retractContainer(self, container):
        """ Retract the specified container.

        Parameters
        ----------
        container : QDockContainer
            The container to put in the retracted position. If the
            container does not exist in the manager, this method is
            a no-op.

        """
        button = self._widgets.get(container)
        if button is not None:
            button.setChecked(False)

    #--------------------------------------------------------------------------
    # Protected API
    #--------------------------------------------------------------------------
    def eventFilter(self, obj, event):
        """ Filter the events on the central pane.

        This event filter will resize the active containers in response
        to a resize of the central pane. This event filter is installed
        only when there are active containers for resizing.

        """
        if event.type() == QEvent.Resize:
            active = self._active_items
            for item, slide_out in active.iteritems():
                start, end = self._animationGeo(item)
                animation = item.animation()
                if slide_out:
                    if animation is None:
                        item.setGeometry(end)
                    else:
                        animation.pause()
                        animation.setStartValue(start)
                        animation.setEndValue(end)
                        animation.resume()
                elif animation is not None:
                    animation.pause()
                    animation.setStartValue(end)
                    animation.setEndValue(start)
                    animation.resume()
        return False

########NEW FILE########
__FILENAME__ = q_dock_container
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed, Bool

from enaml.qt.QtCore import Qt, QMargins, QPoint, QRect, QEvent, Signal
from enaml.qt.QtGui import QApplication, QLayout, QIcon, QCursor

from .event_types import QDockItemEvent, DockItemUndocked
from .q_dock_area import QDockArea
from .q_dock_bar import QDockBar
from .q_dock_frame import QDockFrame
from .q_dock_frame_layout import QDockFrameLayout
from .q_dock_tab_widget import QDockTabWidget
from .q_guide_rose import QGuideRose
from .utils import repolish


class QDockContainerLayout(QDockFrameLayout):
    """ A QDockFrameLayout subclass which works with a QDockContainer.

    """
    def invalidate(self):
        """ Invalidate the cached layout data.

        """
        super(QDockContainerLayout, self).invalidate()
        widget = self.getWidget()
        if widget is not None:
            self.parentWidget().setSizePolicy(widget.sizePolicy())


def _computePressPos(container, coeff):
    """ Compute the press position for a title bar.

    Parameters
    ----------
    container : QDockContainer
        The dock container which owns the title bar of interest.

    coeff : float
        A floating point value between 0.0 and 1.0 which is the
        proportional x-offset of the mouse press in the title bar.

    """
    margins = container.layout().contentsMargins()
    button_width = 50  # general approximation
    max_x = container.width() - margins.right() - button_width
    test_x = int(coeff * container.width())
    new_x = max(margins.left() + 5, min(test_x, max_x))
    title_bar = container.dockItem().titleBarWidget()
    title_height = title_bar.height() / 2
    mid_title = title_bar.mapTo(container, QPoint(0, title_height))
    return QPoint(new_x, mid_title.y())


def _closestDockBar(container):
    """ Get the closest dock bar position for the container.

    This function computes the closest dock bar position by ranking
    the edges of the container by their distance to the respective
    dock area edge. Ties are broken first by relative edge weight and
    then by an ordered heuristic of East, West, South, then North.

    Returns
    -------
    result : QDockBar.Position
        The closet dock bar position.

    """
    area = container.parentDockArea()
    if area is None:
        return QDockBar.North

    pane = area.centralPane()
    c_width = container.width()
    c_height = container.height()
    p_width = pane.width()
    p_height = pane.height()

    p1 = container.mapTo(pane, QPoint(0, 0))
    p2 = container.mapTo(pane, QPoint(c_width, c_height))
    edge_ranks = (p1.y(), p_width - p2.x(), p_height - p2.y(), p1.x())

    f_width = 1.0 - float(c_width) / p_width
    f_height = 1.0 - float(c_height) / p_height
    edge_weights = (f_width, f_height) * 2

    tie_breakers = (3, 0, 2, 1)
    borders = (QDockBar.North, QDockBar.East, QDockBar.South, QDockBar.West)
    values = zip(edge_ranks, edge_weights, tie_breakers, borders)
    return sorted(values)[0][3]


class QDockContainer(QDockFrame):
    """ A QDockFrame which holds a QDockItem instance.

    A QDockContainer has a dynamic boolean property 'floating' which
    can be used to apply custom stylesheet styling when the container
    is a floating top level window versus docked in a dock area.

    """
    #: A signal emitted when the container changes its toplevel state.
    topLevelChanged = Signal(bool)

    #: A signal emitted when the container is alerted.
    alerted = Signal(unicode)

    class FrameState(QDockFrame.FrameState):
        """ A private class for managing container drag state.

        """
        #: The original title bar press position.
        press_pos = Typed(QPoint)

        #: The position of the frame when first moved.
        start_pos = Typed(QPoint)

        #: Whether or not the dock item is being dragged.
        dragging = Bool(False)

        #: Whether the frame was maximized before moving.
        frame_was_maximized = Bool(False)

        #: Whether the dock item is maximized in the dock area.
        item_is_maximized = Bool(False)

        #: Whether or not the container is stored in a dock bar. This
        #: value is manipulated directly by the QDockBarManager.
        in_dock_bar = Bool(False)

    def __init__(self, manager, parent=None):
        """ Initialize a QDockContainer.

        Parameters
        ----------
        manager : DockManager
            The manager which owns the container.

        parent : QWidget or None
            The parent of the QDockContainer.

        """
        super(QDockContainer, self).__init__(manager, parent)
        layout = QDockContainerLayout()
        layout.setSizeConstraint(QLayout.SetMinAndMaxSize)
        self.setLayout(layout)
        self.setProperty('floating', False)
        self.alerted.connect(self.onAlerted)
        self._dock_item = None

    def titleBarGeometry(self):
        """ Get the geometry rect for the title bar.

        Returns
        -------
        result : QRect
            The geometry rect for the title bar, expressed in frame
            coordinates. An invalid rect is returned if title bar
            should not be active.

        """
        title_bar = self.dockItem().titleBarWidget()
        if title_bar.isHidden():
            return QRect()
        pt = title_bar.mapTo(self, QPoint(0, 0))
        return QRect(pt, title_bar.size())

    def resizeMargins(self):
        """ Get the margins to use for resizing the container.

        Returns
        -------
        result : QMargins
            The margins to use for container resizing when the container
            is a top-level window.

        """
        if self.isMaximized():
            return QMargins()
        return self.layout().contentsMargins()

    def showMaximized(self):
        """ Handle the show maximized request for the dock container.

        """
        def update_buttons(bar, link=False, pin=False):
            buttons = bar.buttons()
            buttons |= bar.RestoreButton
            buttons &= ~bar.MaximizeButton
            if link:
                buttons &= ~bar.LinkButton
            if pin:
                buttons &= ~bar.PinButton
            bar.setButtons(buttons)
        if self.isWindow():
            super(QDockContainer, self).showMaximized()
            self.setLinked(False)
            update_buttons(self.dockItem().titleBarWidget(), link=True)
        else:
            area = self.parentDockArea()
            if area is not None:
                item = self.dockItem()
                update_buttons(item.titleBarWidget(), pin=True)
                area.setMaximizedWidget(item)
                self.frame_state.item_is_maximized = True
                item.installEventFilter(self)

    def showNormal(self):
        """ Handle the show normal request for the dock container.

        """
        def update_buttons(bar, link=False, pin=False):
            buttons = bar.buttons()
            buttons |= bar.MaximizeButton
            buttons &= ~bar.RestoreButton
            if link:
                buttons |= bar.LinkButton
            if pin:
                buttons |= bar.PinButton
            bar.setButtons(buttons)
        if self.isWindow():
            super(QDockContainer, self).showNormal()
            self.setLinked(False)
            update_buttons(self.dockItem().titleBarWidget(), link=True)
        elif self.frame_state.item_is_maximized:
            item = self.dockItem()
            update_buttons(item.titleBarWidget(), pin=True)
            self.layout().setWidget(item)
            self.frame_state.item_is_maximized = False
            item.removeEventFilter(self)

    #--------------------------------------------------------------------------
    # Framework API
    #--------------------------------------------------------------------------
    def dockItem(self):
        """ Get the dock item installed on the container.

        Returns
        -------
        result : QDockItem or None
            The dock item installed in the container, or None.

        """
        return self._dock_item

    def setDockItem(self, dock_item):
        """ Set the dock item for the container.

        Parameters
        ----------
        dock_item : QDockItem
            The dock item to use in the container.

        """
        layout = self.layout()
        old = layout.getWidget()
        if old is not None:
            old.maximizeButtonClicked.disconnect(self.showMaximized)
            old.restoreButtonClicked.disconnect(self.showNormal)
            old.closeButtonClicked.disconnect(self.close)
            old.linkButtonToggled.disconnect(self.linkButtonToggled)
            old.pinButtonToggled.disconnect(self.onPinButtonToggled)
            old.titleBarLeftDoubleClicked.disconnect(self.toggleMaximized)
            old.alerted.disconnect(self.alerted)
        if dock_item is not None:
            dock_item.maximizeButtonClicked.connect(self.showMaximized)
            dock_item.restoreButtonClicked.connect(self.showNormal)
            dock_item.closeButtonClicked.connect(self.close)
            dock_item.linkButtonToggled.connect(self.linkButtonToggled)
            dock_item.pinButtonToggled.connect(self.onPinButtonToggled)
            dock_item.titleBarLeftDoubleClicked.connect(self.toggleMaximized)
            dock_item.alerted.connect(self.alerted)
        layout.setWidget(dock_item)
        self._dock_item = dock_item

    def title(self):
        """ Get the title for the container.

        This proxies the call to the underlying dock item.

        """
        item = self.dockItem()
        if item is not None:
            return item.title()
        return u''

    def icon(self):
        """ Get the icon for the container.

        This proxies the call to the underlying dock item.

        """
        item = self.dockItem()
        if item is not None:
            return item.icon()
        return QIcon()

    def closable(self):
        """ Get whether or not the container is closable.

        This proxies the call to the underlying dock item.

        """
        item = self.dockItem()
        if item is not None:
            return item.closable()
        return True

    def isLinked(self):
        """ Get whether or not the container is linked.

        This proxies the call to the underlying dock item.

        """
        item = self.dockItem()
        if item is not None:
            return item.isLinked()
        return False

    def setLinked(self, linked):
        """ Set whether or not the container should be linked.

        This proxies the call to the underlying dock item.

        """
        item = self.dockItem()
        if item is not None:
            item.setLinked(linked)

    def isPinned(self):
        """ Get whether or not the container is pinned.

        This proxies the call to the underlying dock item.

        """
        item = self.dockItem()
        if item is not None:
            return item.isPinned()
        return False

    def setPinned(self, pinned, quiet=False):
        """ Set whether or not the container should be pinned.

        This proxies the call to the underlying dock item.

        """
        item = self.dockItem()
        if item is not None:
            item.setPinned(pinned, quiet)

    def showTitleBar(self):
        """ Show the title bar for the container.

        This proxies the call to the underlying dock item.

        """
        item = self.dockItem()
        if item is not None:
            item.titleBarWidget().show()

    def hideTitleBar(self):
        """ Hide the title bar for the container.

        This proxies the call to the underlying dock item.

        """
        item = self.dockItem()
        if item is not None:
            item.titleBarWidget().hide()

    def showLinkButton(self):
        """ Show the link button on the title bar.

        """
        item = self.dockItem()
        if item is not None:
            bar = item.titleBarWidget()
            bar.setButtons(bar.buttons() | bar.LinkButton)

    def hideLinkButton(self):
        """ Hide the link button on the title bar.

        """
        item = self.dockItem()
        if item is not None:
            bar = item.titleBarWidget()
            bar.setButtons(bar.buttons() & ~bar.LinkButton)

    def showPinButton(self):
        """ Show the pin button on the title bar.

        """
        item = self.dockItem()
        if item is not None:
            bar = item.titleBarWidget()
            bar.setButtons(bar.buttons() | bar.PinButton)

    def hidePinButton(self):
        """ Hide the pin button on the title bar.

        """
        item = self.dockItem()
        if item is not None:
            bar = item.titleBarWidget()
            bar.setButtons(bar.buttons() & ~bar.PinButton)

    def toggleMaximized(self):
        """ Toggle the maximized state of the container.

        """
        is_win = self.isWindow()
        is_maxed = self.isMaximized()
        item_maxed = self.frame_state.item_is_maximized
        if is_win and is_maxed or item_maxed:
            self.showNormal()
        else:
            self.showMaximized()

    def reset(self):
        """ Reset the container to the initial pre-docked state.

        """
        state = self.frame_state
        state.dragging = False
        state.press_pos = None
        state.start_pos = None
        state.frame_was_maximized = False
        state.in_dock_bar = False
        self.showNormal()
        self.unfloat()
        self.hideLinkButton()
        self.setLinked(False)
        self.showTitleBar()
        self.setAttribute(Qt.WA_WState_ExplicitShowHide, False)
        self.setAttribute(Qt.WA_WState_Hidden, False)

    def float(self):
        """ Set the window state to be a toplevel floating window.

        """
        self.hide()
        self.setAttribute(Qt.WA_Hover, True)
        flags = Qt.Tool | Qt.FramelessWindowHint
        self.setParent(self.manager().dock_area(), flags)
        self.layout().setContentsMargins(QMargins(5, 5, 5, 5))
        self.setProperty('floating', True)
        self.setLinked(False)
        self.showLinkButton()
        self.hidePinButton()
        repolish(self)
        self.topLevelChanged.emit(True)

    def unfloat(self):
        """ Set the window state to be non-floating window.

        """
        self.hide()
        self.setAttribute(Qt.WA_Hover, False)
        self.setParent(self.manager().dock_area(), Qt.Widget)
        self.layout().setContentsMargins(QMargins(0, 0, 0, 0))
        self.unsetCursor()
        self.setProperty('floating', False)
        self.setLinked(False)
        self.hideLinkButton()
        self.showPinButton()
        repolish(self)
        self.topLevelChanged.emit(False)

    def parentDockArea(self):
        """ Get the parent dock area of the container.

        Returns
        -------
        result : QDockArea or None
            The nearest ancestor which is an instance of QDockArea, or
            None if no such ancestor exists.

        """
        parent = self.parent()
        while parent is not None:
            if isinstance(parent, QDockArea):
                return parent
            parent = parent.parent()

    def parentDockTabWidget(self):
        """ Get the parent dock area of the container.

        Returns
        -------
        result : QDockTabWidget or None
            The nearest ancestor which is an instance of QDockTabWidget,
            or None if no such ancestor exists.

        """
        parent = self.parent()
        while parent is not None:
            if isinstance(parent, QDockTabWidget):
                return parent
            parent = parent.parent()

    def unplug(self):
        """ Unplug the container from its containing dock area.

        This method is invoked by the framework when appropriate. It
        should not need to be called by user code.

        Returns
        -------
        result : bool
            True if the container was unplugged, False otherwise.

        """
        dock_area = self.parentDockArea()
        if dock_area is None:
            return False
        if self.frame_state.in_dock_bar:
            dock_area.removeFromDockBar(self)
            return True
        # avoid a circular import
        from .layout_handling import unplug_container
        return unplug_container(dock_area, self)

    def untab(self, pos):
        """ Unplug the container from a tab control.

        This method is invoked by the QDockTabBar when the container
        should be torn out. It synthesizes the appropriate internal
        state so that the item can continue to be dock dragged. This
        method should not be called by user code.

        Parameters
        ----------
        pos : QPoint
            The global mouse position.

        Returns
        -------
        result : bool
            True on success, False otherwise.

        """
        if not self.unplug():
            return
        self.postUndockedEvent()
        state = self.frame_state
        state.mouse_title = True
        state.dragging = True
        state.frame_was_maximized = False
        self.float()
        self.raiseFrame()
        title_bar = self.dockItem().titleBarWidget()
        title_pos = QPoint(title_bar.width() / 2, title_bar.height() / 2)
        margins = self.layout().contentsMargins()
        offset = QPoint(margins.left(), margins.top())
        state.press_pos = title_bar.mapTo(self, title_pos) + offset
        state.start_pos = pos - state.press_pos
        self.move(state.start_pos)
        self.show()
        self.grabMouse()
        self.activateWindow()
        self.raise_()

    def postUndockedEvent(self):
        """ Post a DockItemUndocked event to the root dock area.

        """
        root_area = self.manager().dock_area()
        if root_area.dockEventsEnabled():
            event = QDockItemEvent(DockItemUndocked, self.objectName())
            QApplication.postEvent(root_area, event)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def onPinButtonToggled(self, pinned):
        """ The signal handler for the 'pinButtonToggled' signal.

        This handler will pin or unpin the container in response to the
        user toggling the pin button.

        """
        area = self.parentDockArea()
        if area is not None:
            if pinned:
                if not self.frame_state.in_dock_bar:
                    position = _closestDockBar(self)
                    self.unplug()
                    area.addToDockBar(self, position)
            else:
                position = area.dockBarPosition(self)
                if position is not None:
                    # avoid a circular import
                    from .layout_handling import plug_frame
                    area.removeFromDockBar(self)
                    if area.centralWidget() is None:
                        guide = QGuideRose.Guide.AreaCenter
                    else:
                        guide = (
                            QGuideRose.Guide.BorderNorth,
                            QGuideRose.Guide.BorderEast,
                            QGuideRose.Guide.BorderSouth,
                            QGuideRose.Guide.BorderWest
                        )[position]
                    plug_frame(area, None, self, guide)

    def onAlerted(self, level):
        """ A signal handler for the 'alerted' signal.

        """
        self.setProperty('alert', level or None)
        repolish(self)

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def eventFilter(self, obj, event):
        """ Filter the events for the dock item.

        This filter will proxy out the mouse events for the dock item.
        This event filter will only be activated when the dock item is
        set to maximzed mode.

        """
        if obj is not self._dock_item:
            return False
        if event.type() == QEvent.MouseButtonPress:
            if event.button() == Qt.LeftButton:
                self._dock_item.clearAlert()  # likely a no-op, but just in case
            return self.filteredMousePressEvent(event)
        elif event.type() == QEvent.MouseMove:
            return self.filteredMouseMoveEvent(event)
        elif event.type() == QEvent.MouseButtonRelease:
            return self.filteredMouseReleaseEvent(event)
        return False

    def filteredMousePressEvent(self, event):
        """ Handle the filtered mouse press event for the dock item.

        """
        bar = self.dockItem().titleBarWidget()
        if bar.isVisible() and bar.geometry().contains(event.pos()):
            self.frame_state.mouse_title = True
            return self.titleBarMousePressEvent(event)
        return False

    def filteredMouseMoveEvent(self, event):
        """ Handle the filtered mouse move event for the dock item.

        """
        if self.frame_state.mouse_title:
            return self.titleBarMouseMoveEvent(event)
        return False

    def filteredMouseReleaseEvent(self, event):
        """ Handle the filtered mouse release event for the dock item.

        """
        if self.frame_state.mouse_title:
            self.frame_state.mouse_title = False
            return self.titleBarMouseReleaseEvent(event)
        return False

    def closeEvent(self, event):
        """ Handle the close event for the dock container.

        """
        self.manager().close_container(self, event)

    def keyPressEvent(self, event):
        """ Handle the key press event for the dock container.

        If the Escape key is pressed while dragging a floating
        container, the container will be released. If it is not
        released over a dock target, it will be moved back to its
        starting position.

        """
        super(QDockContainer, self).keyPressEvent(event)
        state = self.frame_state
        if state.dragging and event.key() == Qt.Key_Escape:
            pos = state.start_pos
            self._releaseFrame();
            if self.isWindow() and pos is not None:
                self.move(pos)
                if state.frame_was_maximized:
                    self.showMaximized()

    def titleBarMousePressEvent(self, event):
        """ Handle a mouse press event on the title bar.

        Returns
        -------
        result : bool
            True if the event is handled, False otherwise.

        """
        if event.button() == Qt.LeftButton:
            state = self.frame_state
            if state.press_pos is None:
                state.press_pos = event.pos()
                state.start_pos = self.pos()
                return True
        return False

    def titleBarMouseMoveEvent(self, event):
        """ Handle a mouse move event on the title bar.

        Returns
        -------
        result : bool
            True if the event is handled, False otherwise.

        """
        state = self.frame_state
        if state.press_pos is None:
            return False

        # If dragging and floating, move the container's position and
        # notify the manager of that the container was mouse moved. If
        # the container is maximized, it is first restored before.
        global_pos = event.globalPos()
        if state.dragging:
            if self.isWindow():
                target_pos = global_pos - state.press_pos
                self.manager().drag_move_frame(self, target_pos, global_pos)
            return True

        # Ensure the drag has crossed the app drag threshold.
        dist = (event.pos() - state.press_pos).manhattanLength()
        if dist <= QApplication.startDragDistance():
            return True

        # If the container is already floating, ensure that it is shown
        # normal size. The next move event will move the window.
        state.dragging = True
        if self.isWindow():
            state.frame_was_maximized = self.isMaximized();
            if state.frame_was_maximized:
                coeff = state.press_pos.x() / float(self.width())
                self.showNormal()
                state.press_pos = _computePressPos(self, coeff)
            return True

        # Restore a maximized dock item before unplugging.
        if state.item_is_maximized:
            bar = self.dockItem().titleBarWidget()
            coeff = state.press_pos.x() / float(bar.width())
            self.showNormal()
            state.press_pos = _computePressPos(self, coeff)

        # Unplug the container from the layout before floating so
        # that layout widgets can clean themselves up when empty.
        if not self.unplug():
            return False
        self.postUndockedEvent()

        # Make the container a toplevel frame, update it's Z-order,
        # and grab the mouse to continue processing drag events.
        self.float()
        self.raiseFrame()
        margins = self.layout().contentsMargins()
        state.press_pos += QPoint(0, margins.top())
        state.start_pos = global_pos - state.press_pos
        self.move(state.start_pos)
        self.show()
        self.grabMouse()
        self.activateWindow()
        self.raise_()
        return True

    def _releaseFrame(self):
        """ A helper method which releases the frame grab.

        Returns
        -------
        result : bool
            True if the frame was released, False otherwise.

        """
        state = self.frame_state
        if state.press_pos is not None:
            self.releaseMouse()
            if self.isWindow():
                self.manager().drag_release_frame(self, QCursor.pos())
            state.dragging = False
            state.press_pos = None
            state.start_pos = None
            return True
        return False

    def titleBarMouseReleaseEvent(self, event):
        """ Handle a mouse release event on the title bar.

        Returns
        -------
        result : bool
            True if the event is handled, False otherwise.

        """
        if event.button() == Qt.LeftButton:
            return self._releaseFrame()
        return False

########NEW FILE########
__FILENAME__ = q_dock_frame
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, Bool, Int, Typed

from enaml.qt.QtCore import Qt, QEvent, QRect, QSize, QPoint, QMargins, Signal
from enaml.qt.QtGui import QApplication, QFrame


class QDockFrame(QFrame):
    """ A QFrame base class for creating dock frames.

    """
    #: No resize border.
    NoBorder = 0

    #: Resize the window vertically from the north edge.
    NorthBorder = 1

    #: Resize the window horizontally from the east edge.
    EastBorder = 2

    #: Resize the window vertically from the south edge.
    SouthBorder = 3

    #: Resize the window horizontally from the west edge.
    WestBorder = 4

    #: Resize the window diagonally from the northeast edge.
    NorthEastBorder = 5

    #: Resize the window diagonally from the northwest edge.
    NorthWestBorder = 6

    #: Resize the window diagonally from the southeast edge.
    SouthEastBorder = 7

    #: Resize the window diagonally from the southwest edge.
    SouthWestBorder = 8

    #: The cursors to use for a given resize border.
    ResizeCursors = {
        NorthBorder: Qt.SizeVerCursor,
        SouthBorder: Qt.SizeVerCursor,
        EastBorder: Qt.SizeHorCursor,
        WestBorder: Qt.SizeHorCursor,
        NorthEastBorder: Qt.SizeBDiagCursor,
        SouthWestBorder: Qt.SizeBDiagCursor,
        NorthWestBorder: Qt.SizeFDiagCursor,
        SouthEastBorder: Qt.SizeFDiagCursor,
    }

    #: The handlers to use for resizing the frame.
    ResizeHandlers = {
        NorthBorder: '_resizeNorth',
        SouthBorder: '_resizeSouth',
        EastBorder: '_resizeEast',
        WestBorder: '_resizeWest',
        NorthEastBorder: '_resizeNortheast',
        SouthWestBorder: '_resizeSouthwest',
        NorthWestBorder: '_resizeNorthwest',
        SouthEastBorder: '_resizeSoutheast',
    }

    #: The size of the extra space for hit testing a resize corner.
    ResizeCornerExtra = 8

    #: A signal emitted when the linked button is toggled. This should
    #: be emitted at the appropriate times by a subclass.
    linkButtonToggled = Signal(bool)

    class FrameState(Atom):
        """ A private class for tracking dock frame state.

        """
        #: Whether the title bar is consuming the mouse events.
        mouse_title = Bool(False)

        #: The resize border based on the mouse hover position.
        resize_border = Int(0)

        #: The last size of the frame before a resize.
        last_size = Typed(QSize)

        #: The offset point of the cursor during a resize press.
        resize_offset = Typed(QPoint)

    def __init__(self, manager, parent=None):
        """ Initialize a QDockFrame.

        Parameters
        ----------
        manager : DockManager
            The manager which owns the frame.

        parent : QWidget or None
            The parent of the QDockFrame.

        """
        super(QDockFrame, self).__init__(parent)
        self.frame_state = self.FrameState()
        self._manager = manager

    def manager(self):
        """ Get a reference to the manager which owns the frame.

        Returns
        -------
        result : DockManager
            The dock manager which owns this dock frame.

        """
        return self._manager

    def raiseFrame(self):
        """ Raise this frame to the top of the dock manager Z-order.

        """
        manager = self._manager
        if manager is not None:
            manager.raise_frame(self)

    def titleBarGeometry(self):
        """ Get the geometry rect for the title bar.

        Returns
        -------
        result : QRect
            The geometry rect for the title bar, expressed in frame
            coordinates. An invalid rect should be returned if title
            bar should not be active.

        """
        return QRect()

    def resizeMargins(self):
        """ Get the margins to use for resizing the frame.

        Returns
        -------
        result : QMargins
            The margins to use for frame resizing when the frame is
            a top-level window.

        """
        return QMargins()

    def isLinked(self):
        """ Get whether or not the frame is linked.

        This method should be reimplemented by a subclass.

        Returns
        -------
        result : bool
            True if the frame is considered linked, False otherwise.

        """
        return False

    def setLinked(self, linked):
        """ Set whether or not the frame is linked.

        This method should be reimplemented by a subclass.

        Parameters
        ----------
        linked : bool
            True if the frame is considered linked, False otherwise.

        """
        pass

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def event(self, event):
        """ Handle the generic events for the frame.

        This handler maintains proper Z-order of the frames within the
        manager's frame list and exposes some custom event handlers
        appropriate for dock frames.

        """
        if event.type() == QEvent.HoverMove:
            self.hoverMoveEvent(event)
            return event.isAccepted()
        if event.type() == QEvent.WindowActivate and self.isWindow():
            self.raiseFrame()
        return super(QDockFrame, self).event(event)

    def mousePressEvent(self, event):
        """ Handle the mouse press event for the dock frame.

        """
        event.ignore()
        state = self.frame_state
        geo = self.titleBarGeometry()
        if geo.isValid() and geo.contains(event.pos()):
            if self.titleBarMousePressEvent(event):
                if self.isWindow():
                    self.activateWindow()
                    self.raise_()
                event.accept()
                state.mouse_title = True
                return
        if self.isWindow() and event.button() == Qt.LeftButton:
            border, offset = self._resizeBorderTest(event.pos())
            if border != self.NoBorder:
                state.resize_border = border
                state.resize_offset = offset
                state.last_size = self.size()
                event.accept()

    def mouseMoveEvent(self, event):
        """ Handle the mouse move event for the dock frame.

        """
        event.ignore()
        state = self.frame_state
        if state.mouse_title:
            if self.titleBarMouseMoveEvent(event):
                event.accept()
                return
        if self.isWindow() and state.resize_border != self.NoBorder:
            border = state.resize_border
            handler = getattr(self, self.ResizeHandlers[border])
            handler(event.pos(), state.resize_offset)
            event.accept()

    def mouseReleaseEvent(self, event):
        """ Handle the mouse release event for the dock frame.

        """
        event.ignore()
        state = self.frame_state
        self._refreshCursor(event.pos())
        if state.mouse_title:
            if self.titleBarMouseReleaseEvent(event):
                event.accept()
                state.mouse_title = False
                return
        if self.isWindow() and event.button() == Qt.LeftButton:
            state.resize_border = self.NoBorder
            state.resize_offset = None
            if state.last_size is not None:
                if state.last_size != self.size():
                    self.manager().frame_resized(self)
                del state.last_size
            event.accept()

    def hoverMoveEvent(self, event):
        """ Handle the hover move event for the frame.

        """
        event.ignore()
        if not self.isWindow() or self.isMaximized():
            return
        if QApplication.mouseButtons() != Qt.NoButton:
            return
        state = self.frame_state
        if state.mouse_title:
            return
        if state.resize_border != self.NoBorder:
            return
        self._refreshCursor(event.pos())
        event.accept()

    def titleBarMousePressEvent(self, event):
        """ Handle a mouse press event on the title bar.

        Returns
        -------
        result : bool
            True if the event is handled, False otherwise.

        """
        return False

    def titleBarMouseMoveEvent(self, event):
        """ Handle a mouse move event on the title bar.

        Returns
        -------
        result : bool
            True if the event is handled, False otherwise.

        """
        return False

    def titleBarMouseReleaseEvent(self, event):
        """ Handle a mouse release event on the title bar.

        Returns
        -------
        result : bool
            True if the event is handled, False otherwise.

        """
        return False

    #--------------------------------------------------------------------------
    # Resize Handling
    #--------------------------------------------------------------------------
    def _refreshCursor(self, pos):
        """ Refresh the resize cursor for the given position.

        Parameters
        ----------
        pos : QPoint
            The point of interest, expressed in local coordinates.

        """
        border, ignored = self._resizeBorderTest(pos)
        cursor = self.ResizeCursors.get(border)
        if cursor is None:
            self.unsetCursor()
        else:
            self.setCursor(cursor)

    def _resizeBorderTest(self, pos):
        """ Hit test the frame for resizing.

        Parameters
        ----------
        pos : QPoint
            The point of interest, expressed in local coordinates.

        Returns
        -------
        result : tuple
            A 2-tuple of (int, QPoint) representing the resize border
            and offset for the border.

        """
        rect = self.rect()
        if not rect.contains(pos):
            return (self.NoBorder, QPoint())
        x = pos.x()
        y = pos.y()
        width = rect.width()
        height = rect.height()
        margins = self.resizeMargins()
        extra = self.ResizeCornerExtra
        if x < margins.left():
            if y < margins.top() + extra:
                mode = self.NorthWestBorder
                offset = QPoint(x, y)
            elif y > height - (margins.bottom() + extra):
                mode = self.SouthWestBorder
                offset = QPoint(x, height - y)
            else:
                mode = self.WestBorder
                offset = QPoint(x, 0)
        elif y < margins.top():
            if x < margins.left() + extra:
                mode = self.NorthWestBorder
                offset = QPoint(x, y)
            elif x > width - (margins.right() + extra):
                mode = self.NorthEastBorder
                offset = QPoint(width - x, y)
            else:
                mode = self.NorthBorder
                offset = QPoint(0, y)
        elif x > width - margins.right():
            if y < margins.top() + extra:
                mode = self.NorthEastBorder
                offset = QPoint(width - x, y)
            elif y > height - (margins.bottom() + extra):
                mode = self.SouthEastBorder
                offset = QPoint(width - x, height - y)
            else:
                mode = self.EastBorder
                offset = QPoint(width - x, 0)
        elif y > height - margins.bottom():
            if x < margins.left() + extra:
                mode = self.SouthWestBorder
                offset = QPoint(x, height - y)
            elif x > width - (margins.right() + extra):
                mode = self.SouthEastBorder
                offset = QPoint(width - x, height - y)
            else:
                mode = self.SouthBorder
                offset = QPoint(0, height - y)
        else:
            mode = self.NoBorder
            offset = QPoint()
        return mode, offset

    def _resizeNorth(self, pos, offset):
        """ A resize handler for north resizing.

        """
        dh = pos.y() - offset.y()
        height = self.height()
        min_height = self.minimumSizeHint().height()
        if height - dh < min_height:
            dh = height - min_height
        rect = self.geometry()
        rect.setY(rect.y() + dh)
        self.setGeometry(rect)

    def _resizeSouth(self, pos, offset):
        """ A resize handler for south resizing.

        """
        dh = pos.y() - self.height() + offset.y()
        size = self.size()
        size.setHeight(size.height() + dh)
        self.resize(size)

    def _resizeEast(self, pos, offset):
        """ A resize handler for east resizing.

        """
        dw = pos.x() - self.width() + offset.x()
        size = self.size()
        size.setWidth(size.width() + dw)
        self.resize(size)

    def _resizeWest(self, pos, offset):
        """ A resize handler for west resizing.

        """
        dw = pos.x() - offset.x()
        width = self.width()
        min_width = self.minimumSizeHint().width()
        if width - dw < min_width:
            dw = width - min_width
        rect = self.geometry()
        rect.setX(rect.x() + dw)
        self.setGeometry(rect)

    def _resizeNortheast(self, pos, offset):
        """ A resize handler for northeast resizing.

        """
        dw = pos.x() - self.width() + offset.x()
        dh = pos.y() - offset.y()
        size = self.size()
        min_size = self.minimumSizeHint()
        if size.height() - dh < min_size.height():
            dh = size.height() - min_size.height()
        rect = self.geometry()
        rect.setWidth(rect.width() + dw)
        rect.setY(rect.y() + dh)
        self.setGeometry(rect)

    def _resizeNorthwest(self, pos, offset):
        """ A resize handler for northwest resizing.

        """
        dw = pos.x() - offset.x()
        dh = pos.y() - offset.y()
        size = self.size()
        min_size = self.minimumSizeHint()
        if size.width() - dw < min_size.width():
            dw = size.width() - min_size.width()
        if size.height() - dh < min_size.height():
            dh = size.height() - min_size.height()
        rect = self.geometry()
        rect.setX(rect.x() + dw)
        rect.setY(rect.y() + dh)
        self.setGeometry(rect)

    def _resizeSouthwest(self, pos, offset):
        """ A resize handler for southwest resizing.

        """
        dw = pos.x() - offset.x()
        dh = pos.y() - self.height() + offset.y()
        size = self.size()
        min_size = self.minimumSizeHint()
        if size.width() - dw < min_size.width():
            dw = size.width() - min_size.width()
        rect = self.geometry()
        rect.setX(rect.x() + dw)
        rect.setHeight(rect.height() + dh)
        self.setGeometry(rect)

    def _resizeSoutheast(self, pos, offset):
        """ A resize handler for southeast resizing.

        """
        dw = pos.x() - self.width() + offset.x()
        dh = pos.y() - self.height() + offset.y()
        size = self.size()
        size.setWidth(size.width() + dw)
        size.setHeight(size.height() + dh)
        self.resize(size)

########NEW FILE########
__FILENAME__ = q_dock_frame_layout
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from enaml.qt.QtCore import QSize
from enaml.qt.q_single_widget_layout import QSingleWidgetLayout


class QDockFrameLayout(QSingleWidgetLayout):
    """ A single widget layout for dock frames.

    This class is used by the docking framework and is not intended for
    direct use by user code.

    """
    def __init__(self, parent=None):
        """ Initialize a QDockFrameLayout.

        Parameters
        ----------
        parent : QWidget or None
            The parent widget owner of the layout.

        """
        super(QDockFrameLayout, self).__init__(parent)
        self._size_hint = QSize()
        self._min_size = QSize()
        self._max_size = QSize()

    #--------------------------------------------------------------------------
    # QLayout API
    #--------------------------------------------------------------------------
    def invalidate(self):
        """ Invalidate the cached layout data.

        """
        super(QDockFrameLayout, self).invalidate()
        self._size_hint = QSize()
        self._min_size = QSize()
        self._max_size = QSize()

    def sizeHint(self):
        """ Get the size hint for the layout.

        """
        hint = self._size_hint
        if hint.isValid():
            return hint
        hint = super(QDockFrameLayout, self).sizeHint()
        if not hint.isValid():
            hint = QSize(256, 192)
        self._size_hint = hint
        return hint

    def minimumSize(self):
        """ Get the minimum size for the layout.

        """
        size = self._min_size
        if size.isValid():
            return size
        size = super(QDockFrameLayout, self).minimumSize()
        if not size.isValid():
            size = QSize(256, 192)
        self._min_size = size
        return size

    def maximumSize(self):
        """ Get the maximum size for the layout.

        """
        size = self._max_size
        if size.isValid():
            return size
        size = super(QDockFrameLayout, self).maximumSize()
        self._max_size = size
        return size

########NEW FILE########
__FILENAME__ = q_dock_item
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from enaml.qt.QtCore import Qt, QRect, QSize, QPoint, QTimer, Signal
from enaml.qt.QtGui import QApplication, QFrame, QLayout

from .event_types import (
    QDockItemEvent, DockItemShown, DockItemHidden, DockItemClosed
)
from .q_dock_tab_widget import QDockTabWidget
from .q_dock_title_bar import QDockTitleBar
from .utils import repolish


class _AlertData(object):
    """ A private class which stores the data needed for item alerts.

    """
    def __init__(self, timer, level, on, off, repeat, persist):
        self.timer = timer
        self.level = level
        self.on = on
        self.off = off
        self.repeat = repeat
        self.persist = persist
        self.remaining = repeat
        self.active = False


class QDockItemLayout(QLayout):
    """ A QLayout subclass for laying out a dock item.

    """
    def __init__(self, parent=None):
        """ Initialize a QDockAreaLayout.

        Parameters
        ----------
        parent : QWidget or None
            The parent widget owner of the layout.

        """
        super(QDockItemLayout, self).__init__(parent)
        self._size_hint = QSize()
        self._min_size = QSize()
        self._max_size = QSize()
        self._title_bar = None
        self._dock_widget = None

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def titleBarWidget(self):
        """ Get the title bar widget set for the layout.

        Returns
        -------
        result : IDockItemTitleBar or None
            The title bar widget for the layout, or None if no widget
            is applied.

        """
        return self._title_bar

    def setTitleBarWidget(self, title_bar):
        """ Set the title bar widget for the layout.

        The old widget will be hidden and unparented, but not destroyed.

        Parameters
        ----------
        title_bar : IDockItemTitleBar or None
            A concrete implementor of the title bar interface, or None.

        """
        old_bar = self._title_bar
        if old_bar is not None:
            old_bar.hide()
            old_bar.setParent(None)
        self._title_bar = title_bar
        if title_bar is not None:
            title_bar.setParent(self.parentWidget())
        self.invalidate()

    def dockWidget(self):
        """ Get the dock widget set for the layout.

        Returns
        -------
        result : QWidget
            The primary widget set in the dock item layout.

        """
        return self._dock_widget

    def setDockWidget(self, widget):
        """ Set the dock widget for the layout.

        The old widget will be hidden and unparented, but not destroyed.

        Parameters
        ----------
        widget : QWidget
            The widget to use as the primary content in the layout.

        """
        old_widget = self._dock_widget
        if widget is old_widget:
            return
        if old_widget is not None:
            old_widget.hide()
            old_widget.setParent(None)
        self._dock_widget = widget
        if widget is not None:
            widget.setParent(self.parentWidget())
        self.invalidate()

    #--------------------------------------------------------------------------
    # QLayout API
    #--------------------------------------------------------------------------
    def invalidate(self):
        """ Invalidate the layout.

        """
        super(QDockItemLayout, self).invalidate()
        self._size_hint = QSize()
        self._min_size = QSize()
        self._max_size = QSize()

    def setGeometry(self, rect):
        """ Set the geometry for the items in the layout.

        """
        super(QDockItemLayout, self).setGeometry(rect)
        title = self._title_bar
        widget = self._dock_widget
        title_rect = QRect(rect)
        widget_rect = QRect(rect)
        if title is not None and not title.isHidden():
            msh = title.minimumSizeHint()
            title_rect.setHeight(msh.height())
            widget_rect.setTop(title_rect.bottom() + 1)
            title.setGeometry(title_rect)
        if widget is not None and not widget.isHidden():
            widget.setGeometry(widget_rect)

    def sizeHint(self):
        """ Get the size hint for the layout.

        """
        sh = self._size_hint
        if not sh.isValid():
            width = height = 0
            title = self._title_bar
            widget = self._dock_widget
            if title is not None and not title.isHidden():
                hint = title.sizeHint()
                width += hint.width()
                height += hint.height()
            if widget is not None and not widget.isHidden():
                hint = widget.sizeHint()
                width = max(width, hint.width())
                height += hint.height()
            sh = self._size_hint = QSize(width, height)
        return sh

    def minimumSize(self):
        """ Get the minimum size for the layout.

        """
        ms = self._min_size
        if not ms.isValid():
            width = height = 0
            title = self._title_bar
            widget = self._dock_widget
            if title is not None and not title.isHidden():
                hint = title.minimumSizeHint()
                width += hint.width()
                height += hint.height()
            if widget is not None and not widget.isHidden():
                hint = widget.minimumSizeHint()
                width = max(width, hint.width())
                height += hint.height()
            ms = self._min_size = QSize(width, height)
        return ms

    def maximumSize(self):
        """ Get the maximum size for the layout.

        """
        ms = self._max_size
        if not ms.isValid():
            widget = self._dock_widget
            parent = self.parentWidget()
            if widget is not None and parent.isFloating():
                ms = widget.maximumSize()
                title = self._title_bar
                if title is not None and not title.isHidden():
                    height = ms.height() + title.minimumSizeHint().height()
                    ms.setHeight(min(16777215, height))
            else:
                ms = QSize(16777215, 16777215)
            self._max_size = ms
        return ms

    #--------------------------------------------------------------------------
    # QLayout Abstract API
    #--------------------------------------------------------------------------
    def addItem(self, item):
        """ A required virtual method implementation.

        """
        msg = 'Use `setTitleBarWidget | setDockWidget` instead.'
        raise NotImplementedError(msg)

    def count(self):
        """ A required virtual method implementation.

        This method should not be used and returns a constant value.

        """
        return 0

    def itemAt(self, idx):
        """ A virtual method implementation which returns None.

        """
        return None

    def takeAt(self, idx):
        """ A virtual method implementation which does nothing.

        """
        return None


class QDockItem(QFrame):
    """ A QFrame subclass which acts as an item QDockArea.

    """
    #: A signal emitted when the maximize button is clicked. This
    #: signal is proxied from the current dock item title bar.
    maximizeButtonClicked = Signal(bool)

    #: A signal emitted when the restore button is clicked. This
    #: signal is proxied from the current dock item title bar.
    restoreButtonClicked = Signal(bool)

    #: A signal emitted when the close button is clicked. This
    #: signal is proxied from the current dock item title bar.
    closeButtonClicked = Signal(bool)

    #: A signal emitted when the link button is toggled. This
    #: signal is proxied from the current dock item title bar.
    linkButtonToggled = Signal(bool)

    #: A signal emitted when the pin button is toggled. This
    #: signal is proxied from the current dock item title bar.
    pinButtonToggled = Signal(bool)

    #: A signal emitted when the title is edited by the user. This
    #: signal is proxied from the current dock item title bar.
    titleEdited = Signal(unicode)

    #: A signal emitted when the empty area is left double clicked.
    #: This signal is proxied from the current dock item title bar.
    titleBarLeftDoubleClicked = Signal(QPoint)

    #: A signal emitted when the empty area is right clicked. This
    #: signal is proxied from the current dock item title bar.
    titleBarRightClicked = Signal(QPoint)

    #: A signal emitted when the item is alerted. The payload is the
    #: new alert level. An empty string indicates no alert.
    alerted = Signal(unicode)

    def __init__(self, parent=None):
        """ Initialize a QDockItem.

        Parameters
        ----------
        parent : QWidget, optional
            The parent of the dock item.

        """
        super(QDockItem, self).__init__(parent)
        layout = QDockItemLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSizeConstraint(QLayout.SetMinAndMaxSize)
        self.setLayout(layout)
        self.setTitleBarWidget(QDockTitleBar())
        self.alerted.connect(self._onAlerted)
        self._manager = None  # Set and cleared by the DockManager
        self._alert_data = None
        self._vis_changed = None
        self._closable = True
        self._closing = False

    #--------------------------------------------------------------------------
    # Reimplementations
    #--------------------------------------------------------------------------
    def close(self):
        """ Handle the close request for the dock item.

        """
        self._closing = True
        try:
            super(QDockItem, self).close()
        finally:
            self._closing = False

    def closeEvent(self, event):
        """ Handle the close event for the dock item.

        This handler will reject the event if the item is not closable.

        """
        event.ignore()
        if self._closable:
            event.accept()
            area = self.rootDockArea()
            if area is not None and area.dockEventsEnabled():
                event = QDockItemEvent(DockItemClosed, self.objectName())
                QApplication.postEvent(area, event)

    def showEvent(self, event):
        """ Handle the show event for the container.

        This handler posts a visibility change event.

        """
        super(QDockItem, self).showEvent(event)
        self._postVisibilityChange(True)

    def hideEvent(self, event):
        """ Handle the hide event for the container.

        This handler posts a visibility change event.

        """
        super(QDockItem, self).hideEvent(event)
        # Don't post when closing; A closed event is posted instead.
        if not self._closing:
            self._postVisibilityChange(False)

    def mousePressEvent(self, event):
        """ Handle the mouse press event for the dock item.

        This handler will clear any alert level on a left click.

        """
        if event.button() == Qt.LeftButton:
            self.clearAlert()
        super(QDockItem, self).mousePressEvent(event)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def manager(self):
        """ Get the dock manager for this dock item.

        Returns
        -------
        result : DockManager or None
            The dock manager which is managing this item.

        """
        return self._manager

    def rootDockArea(self):
        """ Get the root dock area for this dock item.

        Returns
        -------
        result : QDockArea or None
            The root dock area for this dock item.

        """
        manager = self._manager
        if manager is not None:
            return manager.dock_area()

    def title(self):
        """ Get the title for the dock item.

        Returns
        -------
        result : unicode
            The unicode title for the dock item.

        """
        return self.titleBarWidget().title()

    def setTitle(self, title):
        """ Set the title for the dock item.

        Parameters
        ----------
        title : unicode
            The unicode title to use for the dock item.

        """
        self.titleBarWidget().setTitle(title)
        # A concession to practicality: walk the ancestry and update
        # the tab title if this item lives in a dock tab.
        container = self.parent()
        if container is not None:
            stacked = container.parent()
            if stacked is not None:
                tabs = stacked.parent()
                if isinstance(tabs, QDockTabWidget):
                    index = tabs.indexOf(container)
                    tabs.setTabText(index, title)

    def icon(self):
        """ Get the icon for the dock item.

        Returns
        -------
        result : QIcon
            The icon in use for the dock item.

        """
        return self.titleBarWidget().icon()

    def setIcon(self, icon):
        """ Set the icon for the dock item.

        Parameters
        ----------
        icon : QIcon
            The icon to use for the dock item.

        """
        self.titleBarWidget().setIcon(icon)
        # A concession to practicality: walk the ancestry and update
        # the tab icon if this item lives in a dock tab.
        container = self.parent()
        if container is not None:
            stacked = container.parent()
            if stacked is not None:
                tabs = stacked.parent()
                if isinstance(tabs, QDockTabWidget):
                    index = tabs.indexOf(container)
                    tabs.setTabIcon(index, icon)

    def iconSize(self):
        """ Get the icon size for the title bar.

        Returns
        -------
        result : QSize
            The size to use for the icons in the title bar.

        """
        return self.titleBarWidget().iconSize()

    def setIconSize(self, size):
        """ Set the icon size for the title bar.

        Parameters
        ----------
        icon : QSize
            The icon size to use for the title bar. Icons smaller than
            this size will not be scaled up.

        """
        self.titleBarWidget().setIconSize(size)

    def isLinked(self):
        """ Get whether or not this dock item is linked.

        Returns
        -------
        result : bool
            True if the item is linked, False otherwise.

        """
        return self.titleBarWidget().isLinked()

    def setLinked(self, linked):
        """ Set whether or not the dock item is linked.

        Parameters
        ----------
        linked : bool
            True if the dock item should be linked, False otherwise.

        """
        self.titleBarWidget().setLinked(linked)

    def isPinned(self):
        """ Get whether or not this dock item is pinned.

        Returns
        -------
        result : bool
            True if the item is pinned, False otherwise.

        """
        return self.titleBarWidget().isPinned()

    def setPinned(self, pinned, quiet=False):
        """ Set whether or not the dock item is pinned.

        Parameters
        ----------
        pinned : bool
            True if the dock item should be pinned, False otherwise.

        quiet : bool, optional
            True if the state should be set without emitted the toggled
            signal. The default is False.

        """
        self.titleBarWidget().setPinned(pinned, quiet)

    def isFloating(self):
        """ Get whether the dock item is free floating.

        """
        container = self.parent()
        if container is not None:
            return container.isWindow()
        return self.isWindow()

    def titleEditable(self):
        """ Get whether the title is user editable.

        Returns
        -------
        result : bool
            True if the title is user editable, False otherwise.

        """
        return self.titleBarWidget().isEditable()

    def setTitleEditable(self, editable):
        """ Set whether or not the title is user editable.

        Parameters
        ----------
        editable : bool
            True if the title is user editable, False otherwise.

        """
        self.titleBarWidget().setEditable(editable)

    def titleBarForceHidden(self):
        """ Get whether or not the title bar is force hidden.

        Returns
        -------
        result : bool
            Whether or not the title bar is force hidden.

        """
        return self.titleBarWidget().isForceHidden()

    def setTitleBarForceHidden(self, hidden):
        """ Set the force hidden state of the title bar.

        Parameters
        ----------
        hidden : bool
            True if the title bar should be hidden, False otherwise.

        """
        self.titleBarWidget().setForceHidden(hidden)

    def closable(self):
        """ Get whether or not the dock item is closable.

        Returns
        -------
        result : bool
            True if the dock item is closable, False otherwise.

        """
        return self._closable

    def setClosable(self, closable):
        """ Set whether or not the dock item is closable.

        Parameters
        ----------
        closable : bool
            True if the dock item is closable, False otherwise.

        """
        if closable != self._closable:
            self._closable = closable
            bar = self.titleBarWidget()
            buttons = bar.buttons()
            if closable:
                buttons |= bar.CloseButton
            else:
                buttons &= ~bar.CloseButton
            bar.setButtons(buttons)
            # A concession to practicality: walk the ancestry and update
            # the tab close button if this item lives in a dock tab.
            container = self.parent()
            if container is not None:
                stacked = container.parent()
                if stacked is not None:
                    tabs = stacked.parent()
                    if isinstance(tabs, QDockTabWidget):
                        index = tabs.indexOf(container)
                        tabs.setCloseButtonVisible(index, closable)

    def titleBarWidget(self):
        """ Get the title bar widget for the dock item.

        If a custom title bar has not been assigned, a default title
        bar will be returned. To prevent showing a title bar, set the
        visibility on the returned title bar to False.

        Returns
        -------
        result : IDockItemTitleBar
            An implementation of IDockItemTitleBar. This will never be
            None.

        """
        layout = self.layout()
        bar = layout.titleBarWidget()
        if bar is None:
            bar = QDockTitleBar()
            self.setTitleBarWidget(bar)
        return bar

    def setTitleBarWidget(self, title_bar):
        """ Set the title bar widget for the dock item.

        Parameters
        ----------
        title_bar : IDockItemTitleBar or None
            A custom implementation of IDockItemTitleBar, or None. If
            None, then the default title bar will be restored.

        """
        layout = self.layout()
        old = layout.titleBarWidget()
        if old is not None:
            old.maximizeButtonClicked.disconnect(self.maximizeButtonClicked)
            old.restoreButtonClicked.disconnect(self.restoreButtonClicked)
            old.closeButtonClicked.disconnect(self.closeButtonClicked)
            old.linkButtonToggled.disconnect(self.linkButtonToggled)
            old.pinButtonToggled.disconnect(self.pinButtonToggled)
            old.titleEdited.disconnect(self.titleEdited)
            old.leftDoubleClicked.disconnect(self.titleBarLeftDoubleClicked)
            old.rightClicked.disconnect(self.titleBarRightClicked)
        title_bar = title_bar or QDockTitleBar()
        title_bar.maximizeButtonClicked.connect(self.maximizeButtonClicked)
        title_bar.restoreButtonClicked.connect(self.restoreButtonClicked)
        title_bar.closeButtonClicked.connect(self.closeButtonClicked)
        title_bar.linkButtonToggled.connect(self.linkButtonToggled)
        title_bar.pinButtonToggled.connect(self.pinButtonToggled)
        title_bar.titleEdited.connect(self.titleEdited)
        title_bar.leftDoubleClicked.connect(self.titleBarLeftDoubleClicked)
        title_bar.rightClicked.connect(self.titleBarRightClicked)
        layout.setTitleBarWidget(title_bar)

    def dockWidget(self):
        """ Get the dock widget for this dock item.

        Returns
        -------
        result : QWidget or None
            The dock widget being managed by this item.

        """
        return self.layout().dockWidget()

    def setDockWidget(self, widget):
        """ Set the dock widget for this dock item.

        Parameters
        ----------
        widget : QWidget
            The QWidget to use as the dock widget in this item.

        """
        self.layout().setDockWidget(widget)

    def alert(self, level, on=250, off=250, repeat=4, persist=False):
        """ Set the alert level on the dock item.

        This will override any currently applied alert level.

        Parameters
        ----------
        level : unicode
            The alert level token to apply to the dock item.

        on : int
            The duration of the 'on' cycle, in ms. A value of -1 means
            always on.

        off : int
            The duration of the 'off' cycle, in ms. If 'on' is -1, this
            value is ignored.

        repeat : int
            The number of times to repeat the on-off cycle. If 'on' is
            -1, this value is ignored.

        persist : bool
            Whether to leave the alert in the 'on' state when the cycles
            finish. If 'on' is -1, this value is ignored.

        """
        if self._alert_data is not None:
            self.clearAlert()
        app = QApplication.instance()
        app.focusChanged.connect(self._onAppFocusChanged)
        timer = QTimer()
        timer.setSingleShot(True)
        timer.timeout.connect(self._onAlertTimer)
        on, off, repeat = max(-1, on), max(0, off), max(1, repeat)
        self._alert_data = _AlertData(timer, level, on, off, repeat, persist)
        if on < 0:
            self.alerted.emit(level)
        else:
            self._onAlertTimer()

    def clearAlert(self):
        """ Clear the current alert level, if any.

        """
        if self._alert_data is not None:
            self._alert_data.timer.stop()
            self._alert_data = None
            app = QApplication.instance()
            app.focusChanged.disconnect(self._onAppFocusChanged)
            self.alerted.emit(u'')

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _onAlertTimer(self):
        """ Handle the alert data timer timeout.

        This handler will refresh the alert level for the current tick,
        or clear|persist the alert level if the ticks have expired.

        """
        data = self._alert_data
        if data is not None:
            if not data.active:
                data.active = True
                data.timer.start(data.on)
                self.alerted.emit(data.level)
            else:
                data.active = False
                data.remaining -= 1
                if data.remaining > 0:
                    data.timer.start(data.off)
                    self.alerted.emit(u'')
                elif data.persist:
                    data.timer.stop()
                    self.alerted.emit(data.level)
                else:
                    self.clearAlert()

    def _onAlerted(self, level):
        """ A signal handler for the 'alerted' signal.

        This handler will set the 'alert' dynamic property on the
        dock item, the title bar, and the title bar label, and then
        repolish all three items.

        """
        level = level or None
        title_bar = self.titleBarWidget()
        label = title_bar.label()
        self.setProperty(u'alert', level)
        title_bar.setProperty(u'alert', level)
        label.setProperty(u'alert', level)
        repolish(label)
        repolish(title_bar)
        repolish(self)

    def _onAppFocusChanged(self, old, new):
        """ A signal handler for the 'focusChanged' app signal

        This handler will clear the alert if one of the descendant
        widgets or the item itself gains focus.

        """
        while new is not None:
            if new is self:
                self.clearAlert()
                break
            new = new.parent()

    def _onVisibilityTimer(self):
        """ Handle the visibility timer timeout.

        This handler will post the dock item visibility event to the
        root dock area.

        """
        area = self.rootDockArea()
        if area is not None and area.dockEventsEnabled():
            timer, visible = self._vis_changed
            evt_type = DockItemShown if visible else DockItemHidden
            event = QDockItemEvent(evt_type, self.objectName())
            QApplication.postEvent(area, event)
            self._vis_changed = None

    def _postVisibilityChange(self, visible):
        """ Post a visibility changed event for the dock item.

        This method collapses the post on a timer and will not emit
        the event when the visibility temporarily toggles bettwen
        states.

        Parameters
        ----------
        visible : bool
            True if the item was show, False if the item was hidden.

        """
        area = self.rootDockArea()
        if area is not None and area.dockEventsEnabled():
            vis_changed = self._vis_changed
            if vis_changed is None:
                timer = QTimer()
                timer.setSingleShot(True)
                timer.timeout.connect(self._onVisibilityTimer)
                self._vis_changed = (timer, visible)
                timer.start()
            else:
                timer, old_visible = vis_changed
                if old_visible != visible:
                    self._vis_changed = None
                    timer.stop()

########NEW FILE########
__FILENAME__ = q_dock_splitter
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from enaml.qt.QtCore import Qt
from enaml.qt.QtGui import QSplitter, QSplitterHandle

from .q_dock_area import QDockArea


class QDockSplitterHandle(QSplitterHandle):
    """ A subclass for dock splitter handles.

    This subclass sets the hover flag on the splitter handle so that
    the hover rules in a style sheet work correctly.

    """
    def __init__(self, orientation, parent):
        super(QDockSplitterHandle, self).__init__(orientation, parent)
        self.setAttribute(Qt.WA_Hover)


class QDockSplitter(QSplitter):
    """ A splitter subclass for distinguishing dock splitters.

    This subclass allows selecting the dock splitter in a stylesheet
    and otherwise distinguishing dock splitters from standard QSplitter
    instances used elsewhere in the application.

    """
    def createHandle(self):
        """ Create a sentinel dock splitter handle.

        """
        return QDockSplitterHandle(self.orientation(), self)

    def inheritOpaqueResize(self):
        """ Inherit the opaque resize state.

        This method traverses the ancestor hierarchy and updates its
        opaque resize state based on the first QDockArea it finds. If
        no such ancestor exists, the setting is unchanged. This method
        is called by the framework at the appropriate times.

        """
        p = self.parent()
        while p is not None:
            if isinstance(p, QDockArea):
                self.setOpaqueResize(p.opaqueItemResize())
                return
            p = p.parent()

########NEW FILE########
__FILENAME__ = q_dock_tab_widget
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from weakref import ref

from enaml.qt.QtCore import Qt, QPoint, QSize, QMetaObject, QEvent
from enaml.qt.QtGui import (
    QApplication, QTabBar, QTabWidget, QMouseEvent, QResizeEvent, QStyle,
    QCursor, QStylePainter, QStyleOptionTabV3, QPixmap, QPainter
)

from .event_types import QDockItemEvent, DockTabSelected
from .q_bitmap_button import QBitmapButton
from .utils import repolish
from .xbms import CLOSE_BUTTON


class QDockTabCloseButton(QBitmapButton):
    """ A bitmap button subclass used as a dock tab close button.

    """
    def styleOption(self):
        """ Get a filled style option for the button.

        Returns
        -------
        result : QStyleOption
            A style option initialized for the current button state.

        """
        opt = super(QDockTabCloseButton, self).styleOption()
        parent = self.parent()
        if isinstance(parent, QDockTabBar):
            index = parent.currentIndex()
            if parent.tabButton(index, QTabBar.RightSide) is self:
                opt.state |= QStyle.State_Selected
        return opt


class _TabData(object):
    """ A private class which holds data about a tab in a tab bar.

    """
    __slots__ = ('ref', 'normal', 'selected', 'alerted')

    def __init__(self, container):
        self.ref = ref(container)
        self.normal = None
        self.selected = None
        self.alerted = False

    @property
    def container(self):
        return self.ref()


class QDockTabBar(QTabBar):
    """ A custom QTabBar that manages safetly undocking a tab.

    The user can undock a tab by holding Shift before dragging the tab.
    This tab bar assumes that its parent is a QTabWidget and that the
    tabs in the tab widget are QDockItem instances.

    """
    def __init__(self, parent=None):
        """ Initialize a QDockTabBar.

        Parameters
        ----------
        parent : QWidget or None
            The parent widget for the tab bar.

        """
        super(QDockTabBar, self).__init__(parent)
        self.setSelectionBehaviorOnRemove(QTabBar.SelectPreviousTab)
        self.tabMoved.connect(self._onTabMoved)
        self._has_alerts = False
        self._has_mouse = False
        self._tab_data = []

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def setCloseButtonVisible(self, index, visible):
        """ Set the close button visibility for the given tab index.

        Parameters
        ----------
        index : int
            The index of the tab to set the close button visibility.

        visible : bool
            Whether or not the close button should be visible.

        """
        if index < 0 or index >= self.count():
            return
        button = self.tabButton(index, QTabBar.RightSide)
        if button is not None:
            if button.isVisibleTo(self) != visible:
                # The public QTabBar api does not provide a way to
                # trigger the 'layoutTabs' method of QTabBarPrivate
                # and there are certain operations (such as modifying
                # a tab close button) which need to have that happen.
                # A workaround is to send a dummy resize event.
                button.setVisible(visible)
                if not visible:
                    button.resize(0, 0)
                else:
                    button.resize(button.sizeHint())
                size = self.size()
                event = QResizeEvent(size, size)
                QApplication.sendEvent(self, event)
                self.update()

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _onTabMoved(self, from_index, to_index):
        """ A handler for the 'tabMoved' signal.

        This handler synchronizes the internal tab data structures for
        the new positions of the tabs.

        """
        data = self._tab_data.pop(from_index)
        self._tab_data.insert(to_index, data)

    def _onCloseButtonClicked(self):
        """ Handle the 'clicked' signal on the tab close buttons.

        This handler will find the tab index for the clicked button
        and emit the 'tabCloseRequested' signal with that index.

        """
        button = self.sender()
        for index in xrange(self.count()):
            if self.tabButton(index, QTabBar.RightSide) is button:
                self.tabCloseRequested.emit(index)

    def _onAlerted(self, level):
        """ A signal handler for the 'alerted' signal on a container.

        This handler will re-snap the pixmaps for the alerted tab
        and trigger a repaint of the tab bar.

        """
        container = self.sender()
        index = self.parent().indexOf(container)
        if index != -1:
            if level:
                self._snapAlertPixmaps(index, level)
            else:
                self._clearAlertPixmaps(index)
            self.update()

    def _snapAlertPixmaps(self, index, level):
        """ Snap the alert pixmaps for the specified tab.

        Parameters
        ----------
        index : int
            The index of the tab of interest.

        level : unicode
            The alert level for which to snap the pixmaps.

        """
        # Force an internal update of the stylesheet rules
        self.setProperty(u'alert', level)
        repolish(self)

        # Setup the style option for the control
        opt = QStyleOptionTabV3()
        self.initStyleOption(opt, index)
        opt.rect.moveTo(0, 0)

        # Snap the normal pixmap
        opt.state &= ~QStyle.State_Selected
        normal = QPixmap(opt.rect.size())
        normal.fill(Qt.transparent)
        painter = QStylePainter(normal, self)
        painter.initFrom(self)
        painter.drawControl(QStyle.CE_TabBarTab, opt)

        # Snap the selected pixmap
        opt.state |= QStyle.State_Selected
        selected = QPixmap(opt.rect.size())
        selected.fill(Qt.transparent)
        painter = QStylePainter(selected, self)
        painter.initFrom(self)
        painter.drawControl(QStyle.CE_TabBarTab, opt)

        # Reset the internal stylesheet style
        self.setProperty(u'alert', None)
        repolish(self)

        # Update the internal tab data
        data = self._tab_data[index]
        data.normal = normal
        data.selected = selected
        data.alerted = True

        # Flip the alert flag so the pixmaps are painted
        self._has_alerts = True

    def _clearAlertPixmaps(self, index):
        """ Clear the alert pixmaps for the specified tab.

        Parameters
        ----------
        index : int
            The index of the tab of interest.

        """
        data = self._tab_data[index]
        data.normal = None
        data.selected = None
        data.alerted = False

        # Turn off alert painting if there are no more alerts
        self._has_alerts = any(d.alerted for d in self._tab_data)

    #--------------------------------------------------------------------------
    # Reimplementations
    #--------------------------------------------------------------------------
    def tabInserted(self, index):
        """ Handle a tab insertion in the tab bar.

        This handler will create the close button for the tab and then
        update its visibilty depending on whether or not the dock item
        is closable. It will also build the internal tab data structure
        for the new tab. This method assumes that this tab bar is
        parented by a QDockTabWidget.

        """
        button = QDockTabCloseButton(self)
        button.setObjectName('docktab-close-button')
        button.setBitmap(CLOSE_BUTTON.toBitmap())
        button.setIconSize(QSize(14, 13))
        button.clicked.connect(self._onCloseButtonClicked)
        self.setTabButton(index, QTabBar.LeftSide, None)
        self.setTabButton(index, QTabBar.RightSide, button)
        container = self.parent().widget(index)
        container.alerted.connect(self._onAlerted)
        self.setCloseButtonVisible(index, container.closable())
        self._tab_data.insert(index, _TabData(container))

    def tabRemoved(self, index):
        """ Handle a tab removal from the tab bar.

        This will remove the internal tab data structure and disconnect
        the relevant signals.

        """
        data = self._tab_data.pop(index)
        container = data.container
        if container is not None:
            container.alerted.disconnect(self._onAlerted)

    def mousePressEvent(self, event):
        """ Handle the mouse press event for the tab bar.

        This handler will set the internal '_has_mouse' flag if the
        left mouse button is pressed on a tab.

        """
        super(QDockTabBar, self).mousePressEvent(event)
        self._has_mouse = False
        if event.button() == Qt.LeftButton:
            index = self.tabAt(event.pos())
            if index != -1:
                self._has_mouse = True
                data = self._tab_data[index]
                container = data.container
                if container is not None:
                    # likey a no-op, but just in case
                    container.dockItem().clearAlert()
        elif event.button() == Qt.RightButton:
            index = self.tabAt(event.pos())
            if index != -1:
                button = self.tabButton(index, QTabBar.RightSide)
                if button.geometry().contains(event.pos()):
                    return
                item = self.parent().widget(index).dockItem()
                item.titleBarRightClicked.emit(event.globalPos())
                # Emitting the clicked signal may have caused a popup
                # menu to open, which will have grabbed the mouse. When
                # this happens, the hover leave event is not sent and
                # the tab bar will be stuck in the hovered paint state.
                # Manual checking as 'underMouse' yields False negatives.
                p = self.mapFromGlobal(QCursor.pos())
                if not self.rect().contains(p):
                    QApplication.sendEvent(self, QEvent(QEvent.HoverLeave))

    def mouseMoveEvent(self, event):
        """ Handle the mouse move event for the tab bar.

        This handler will undock the tab if the mouse is held and the
        drag leaves the boundary of the container by the application
        drag distance amount.

        """
        super(QDockTabBar, self).mouseMoveEvent(event)
        if not self._has_mouse:
            return
        pos = event.pos()
        if self.rect().contains(pos):
            return
        x = max(0, min(pos.x(), self.width()))
        y = max(0, min(pos.y(), self.height()))
        dist = (QPoint(x, y) - pos).manhattanLength()
        if dist > QApplication.startDragDistance():
            # Fake a mouse release event so that the tab resets its
            # internal state and finalizes the animation for the tab.
            # The button must be Qt.LeftButton, not event.button().
            btn = Qt.LeftButton
            mod = event.modifiers()
            evt = QMouseEvent(QEvent.MouseButtonRelease, pos, btn, btn, mod)
            QApplication.sendEvent(self, evt)
            container = self.parent().widget(self.currentIndex())
            container.untab(event.globalPos())
            self._has_mouse = False

    def mouseReleaseEvent(self, event):
        """ Handle the mouse release event for the tab bar.

        This handler will reset the internal '_has_mouse' flag when the
        left mouse button is released.

        """
        super(QDockTabBar, self).mouseReleaseEvent(event)
        if event.button() == Qt.LeftButton:
            self._has_mouse = False

    def paintEvent(self, event):
        """ A custom paint event for the tab bar.

        This paint event will blit the pixmaps for the alerted tabs as
        necessary, after the superclass paint event handler is run.

        """
        super(QDockTabBar, self).paintEvent(event)
        if self._has_alerts:
            painter = QPainter(self)
            current = self.currentIndex()
            for index, data in enumerate(self._tab_data):
                if data.alerted:
                    rect = self.tabRect(index)
                    pm = data.selected if index == current else data.normal
                    painter.drawPixmap(rect, pm)


class QDockTabWidget(QTabWidget):
    """ A custom tab widget for use in the dock area.

    This custom widget ensures that the proper dock tab bar is used. It
    also allows distinguishing dock tab widgets from standard QTabWidget
    instances used elsewhere in the application.

    """
    def __init__(self, parent=None):
        """ Initialize a QDockTabWidget.

        Parameters
        ----------
        parent : QWidget, optional
            The parent widget of the tab widget.

        """
        super(QDockTabWidget, self).__init__(parent)
        self.setTabBar(QDockTabBar())
        self.setElideMode(Qt.ElideRight)
        self.setUsesScrollButtons(True)
        self.setTabsClosable(True)
        self.setDocumentMode(True)
        self.setMovable(True)
        self.tabBar().setDrawBase(False)
        self.tabCloseRequested.connect(self._onTabCloseRequested)
        self.currentChanged.connect(self._onCurrentChanged)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _onTabCloseRequested(self, index):
        """ Handle the close request for the given tab index.

        """
        # Invoke the close slot later to allow the signal to return.
        container = self.widget(index)
        QMetaObject.invokeMethod(container, 'close', Qt.QueuedConnection)

    def _onCurrentChanged(self, index):
        """ Handle the 'currentChanged' signal for the tab widget.

        """
        # These checks protect against the signal firing during close.
        container = self.widget(index)
        if container is None:
            return
        manager = container.manager()
        if manager is None:
            return
        area = manager.dock_area()
        if area is None:
            return
        if area.dockEventsEnabled():
            event = QDockItemEvent(DockTabSelected, container.objectName())
            QApplication.postEvent(area, event)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def setCloseButtonVisible(self, index, visible):
        """ Set the close button visibility for the given tab index.

        Parameters
        ----------
        index : int
            The index of the tab to set the close button visibility.

        visible : bool
            Whether or not the close button should be visible.

        """
        self.tabBar().setCloseButtonVisible(index, visible)

########NEW FILE########
__FILENAME__ = q_dock_title_bar
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from enaml.qt.QtCore import Qt, QSize, QPoint, QMargins, Signal
from enaml.qt.QtGui import QWidget, QFrame, QLineEdit, QHBoxLayout, QSizePolicy

from .q_bitmap_button import QBitmapButton, QCheckedBitmapButton
from .q_icon_widget import QIconWidget
from .q_text_label import QTextLabel
from .xbms import (
    CLOSE_BUTTON, MAXIMIZE_BUTTON, RESTORE_BUTTON, LINKED_BUTTON,
    UNLINKED_BUTTON, PIN_BUTTON, UNPIN_BUTTON
)


class IDockTitleBar(QWidget):
    """ An interface class for defining a title bar.

    """
    #: A signal emitted when the maximize button is clicked.
    maximizeButtonClicked = Signal(bool)

    #: A signal emitted when the restore button is clicked.
    restoreButtonClicked = Signal(bool)

    #: A signal emitted when the close button is clicked.
    closeButtonClicked = Signal(bool)

    #: A signal emitted when the link button is toggled.
    linkButtonToggled = Signal(bool)

    #: A signal emitted when the pin button is toggled.
    pinButtonToggled = Signal(bool)

    #: A signal emitted when the title is edited by the user.
    titleEdited = Signal(unicode)

    #: A signal emitted when the title bar is left double clicked.
    leftDoubleClicked = Signal(QPoint)

    #: A signal emitted when the title bar is right clicked.
    rightClicked = Signal(QPoint)

    #: Do not show any buttons in the title bar.
    NoButtons = 0x0

    #: Show the maximize button in the title bar.
    MaximizeButton = 0x1

    #: Show the restore button in the title bar.
    RestoreButton = 0x2

    #: Show the close button in the title bar.
    CloseButton = 0x4

    #: Show the link button in the title bar.
    LinkButton = 0x8

    #: Show the pin button in the title bar.
    PinButton = 0x10

    def buttons(self):
        """ Get the buttons to show in the title bar.

        Returns
        -------
        result : int
            An or'd combination of the buttons to show.

        """
        raise NotImplementedError

    def setButtons(self, buttons):
        """ Set the buttons to show in the title bar.

        Parameters
        ----------
        buttons : int
            An or'd combination of the buttons to show.

        """
        raise NotImplementedError

    def title(self):
        """ Get the title string of the title bar.

        Returns
        -------
        result : unicode
            The unicode title string for the title bar.

        """
        raise NotImplementedError

    def setTitle(self, title):
        """ Set the title string of the title bar.

        Parameters
        ----------
        title : unicode
            The unicode string to use for the title bar.

        """
        raise NotImplementedError

    def label(self):
        """ Get the label for the title bar.

        Returns
        -------
        result : QTextLabel
            The label for the title bar.

        """
        raise NotImplementedError

    def icon(self):
        """ Get the icon for the title bar.

        Returns
        -------
        result : QIcon
            The icon set for the title bar.

        """
        raise NotImplementedError

    def setIcon(self, icon):
        """ Set the icon for the title bar.

        Parameters
        ----------
        icon : QIcon
            The icon to use for the title bar.

        """
        raise NotImplementedError

    def iconSize(self):
        """ Get the icon size for the title bar.

        Returns
        -------
        result : QSize
            The size to use for the icons in the title bar.

        """
        raise NotImplementedError

    def setIconSize(self, size):
        """ Set the icon size for the title bar.

        Parameters
        ----------
        icon : QSize
            The icon size to use for the title bar. Icons smaller than
            this size will not be scaled up.

        """
        raise NotImplementedError

    def isLinked(self):
        """ Get whether the link button is checked.

        Returns
        -------
        result : bool
            True if the link button is checked, False otherwise.

        """
        raise NotImplementedError

    def setLinked(self, linked):
        """ Set whether or not the link button is checked.

        Parameters
        ----------
        linked : bool
            True if the link button should be checked, False otherwise.

        """
        raise NotImplementedError

    def isPinned(self):
        """ Get whether the pin button is checked.

        Returns
        -------
        result : bool
            True if the pin button is checked, False otherwise.

        """
        raise NotImplementedError

    def setPinned(self, pinned, quiet=False):
        """ Set whether or not the pin button is checked.

        Parameters
        ----------
        pinned : bool
            True if the pin button should be checked, False otherwise.

        quiet : bool, optional
            True if the state should be set without emitted the toggled
            signal. The default is False.

        """
        raise NotImplementedError

    def isEditable(self):
        """ Get whether the title is user editable.

        Returns
        -------
        result : bool
            True if the title is user editable, False otherwise.

        """
        raise NotImplementedError

    def setEditable(self, editable):
        """ Set whether or not the title is user editable.

        Parameters
        ----------
        editable : bool
            True if the title is user editable, False otherwise.

        """
        raise NotImplementedError

    def isForceHidden(self):
        """ Get whether or not the title bar is force hidden.

        Returns
        -------
        result : bool
            Whether or not the title bar is force hidden.

        """
        raise NotImplementedError

    def setForceHidden(self, hidden):
        """ Set the force hidden state of the title bar.

        Parameters
        ----------
        hidden : bool
            True if the title bar should be hidden, False otherwise.

        """
        raise NotImplementedError


class QDockTitleBar(QFrame, IDockTitleBar):
    """ A concrete implementation of IDockTitleBar.

    This class serves as the default title bar for a QDockItem.

    """
    #: A signal emitted when the maximize button is clicked.
    maximizeButtonClicked = Signal(bool)

    #: A signal emitted when the restore button is clicked.
    restoreButtonClicked = Signal(bool)

    #: A signal emitted when the close button is clicked.
    closeButtonClicked = Signal(bool)

    #: A signal emitted when the link button is toggled.
    linkButtonToggled = Signal(bool)

    #: A signal emitted when the pin button is toggled.
    pinButtonToggled = Signal(bool)

    #: A signal emitted when the title is edited by the user.
    titleEdited = Signal(unicode)

    #: A signal emitted when the empty area is left double clicked.
    leftDoubleClicked = Signal(QPoint)

    #: A signal emitted when the empty area is right clicked.
    rightClicked = Signal(QPoint)

    def __init__(self, parent=None):
        """ Initialize a QDockTitleBar.

        Parameters
        ----------
        parent : QWidget or None
            The parent of the title bar.

        """
        super(QDockTitleBar, self).__init__(parent)
        self._buttons = self.CloseButton | self.MaximizeButton | self.PinButton
        self._is_editable = False
        self._force_hidden = False
        self._last_visible = True
        self._line_edit = None

        title_icon = self._title_icon = QIconWidget(self)
        title_icon.setVisible(False)

        title_label = self._title_label = QTextLabel(self)

        spacer = self._spacer = QWidget(self)
        policy = spacer.sizePolicy()
        policy.setHorizontalPolicy(QSizePolicy.Expanding)
        spacer.setSizePolicy(policy)

        btn_size = QSize(14, 13)

        max_button = self._max_button = QBitmapButton(self)
        max_button.setObjectName('docktitlebar-maximize-button')
        max_button.setBitmap(MAXIMIZE_BUTTON.toBitmap())
        max_button.setIconSize(btn_size)
        max_button.setVisible(self._buttons & self.MaximizeButton)
        max_button.setToolTip('Maximize')

        restore_button = self._restore_button = QBitmapButton(self)
        restore_button.setObjectName('docktitlebar-restore-button')
        restore_button.setBitmap(RESTORE_BUTTON.toBitmap())
        restore_button.setIconSize(btn_size)
        restore_button.setVisible(self._buttons & self.RestoreButton)
        restore_button.setToolTip('Restore Down')

        close_button = self._close_button = QBitmapButton(self)
        close_button.setObjectName('docktitlebar-close-button')
        close_button.setBitmap(CLOSE_BUTTON.toBitmap())
        close_button.setIconSize(btn_size)
        close_button.setVisible(self._buttons & self.CloseButton)
        close_button.setToolTip('Close')

        link_button = self._link_button = QCheckedBitmapButton(self)
        link_button.setObjectName('docktitlebar-link-button')
        link_button.setBitmap(UNLINKED_BUTTON.toBitmap())
        link_button.setCheckedBitmap(LINKED_BUTTON.toBitmap())
        link_button.setIconSize(btn_size)
        link_button.setVisible(self._buttons & self.LinkButton)
        link_button.setToolTip('Link Window')
        link_button.setCheckedToolTip('Unlink Window')

        pin_button = self._pin_button = QCheckedBitmapButton(self)
        pin_button.setObjectName('docktitlebar-pin-button')
        pin_button.setBitmap(PIN_BUTTON.toBitmap())
        pin_button.setCheckedBitmap(UNPIN_BUTTON.toBitmap())
        pin_button.setIconSize(QSize(13, 13))
        pin_button.setVisible(self._buttons & self.PinButton)
        pin_button.setToolTip('Pin Window')
        pin_button.setCheckedToolTip('Unpin Window')

        layout = QHBoxLayout()
        layout.setContentsMargins(QMargins(5, 2, 5, 2))
        layout.setSpacing(1)
        layout.addWidget(title_icon)
        layout.addSpacing(0)
        layout.addWidget(title_label)
        layout.addWidget(spacer)
        layout.addSpacing(4)
        layout.addWidget(pin_button)
        layout.addWidget(link_button)
        layout.addWidget(max_button)
        layout.addWidget(restore_button)
        layout.addWidget(close_button)

        self.setLayout(layout)

        max_button.clicked.connect(self.maximizeButtonClicked)
        restore_button.clicked.connect(self.restoreButtonClicked)
        close_button.clicked.connect(self.closeButtonClicked)
        link_button.toggled.connect(self.linkButtonToggled)
        pin_button.toggled.connect(self.pinButtonToggled)

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def mouseDoubleClickEvent(self, event):
        """ Handle the mouse double click event for the title bar.

        """
        event.ignore()
        if event.button() == Qt.LeftButton:
            pos = event.pos()
            is_editable = self._is_editable
            if self._adjustedLabelGeometry().contains(pos) and is_editable:
                self._showTitleLineEdit()
                event.accept()
                return
            if self._clickableGeometry().contains(pos):
                self.leftDoubleClicked.emit(event.globalPos())
                event.accept()
                return

    def mousePressEvent(self, event):
        """ Handle the mouse press event for the title bar.

        """
        event.ignore()
        if event.button() == Qt.RightButton:
            if self._clickableGeometry().contains(event.pos()):
                self.rightClicked.emit(event.globalPos())
                event.accept()
                return

    #--------------------------------------------------------------------------
    # Overrides
    #--------------------------------------------------------------------------
    def setVisible(self, visible):
        """ An overridden virtual visibility setter.

        This handler enforces the force-hidden setting.

        """
        self._last_visible = visible
        if visible and self._force_hidden:
            return
        super(QDockTitleBar, self).setVisible(visible)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _adjustedLabelGeometry(self):
        """ Get the adjust label geometry.

        Returns
        -------
        result : QRect
            A rectangle representing the label geometry which has been
            adjusted for potentially empty text. This rect can be used
            for a usable hit-testing rect for the label text.

        """
        label = self._title_label
        label_geo = label.geometry()
        if not label.text():
            label_geo = label_geo.adjusted(0, 0, 10, 0)
        return label_geo

    def _clickableGeometry(self):
        """ Get the geometry rect which represents clickable area.

        Returns
        -------
        result : QRect
            A rectangle adjusted for the clickable geometry.

        """
        rect = self.rect().adjusted(5, 2, -5, -2)
        rect.setRight(self._spacer.geometry().right())
        return rect

    def _showTitleLineEdit(self):
        """ Setup the line edit widget for editing the title.

        """
        old_line_edit = self._line_edit
        if old_line_edit is not None:
            old_line_edit.hide()
            old_line_edit.deleteLater()
        line_edit = self._line_edit = QLineEdit(self)
        line_edit.setFrame(False)
        line_edit.setText(self._title_label.text())
        line_edit.selectAll()
        h = self._title_label.height()
        line_edit.setMinimumHeight(h)
        line_edit.setMaximumHeight(h)
        line_edit.editingFinished.connect(self._onEditingFinished)
        layout = self.layout()
        idx = layout.indexOf(self._spacer)
        layout.insertWidget(idx, line_edit)
        self._spacer.hide()
        self._title_label.hide()
        line_edit.show()
        line_edit.setFocus(Qt.MouseFocusReason)

    def _onEditingFinished(self):
        """ Handle the 'editingFinished' signal for title line edit.

        """
        line_edit = self._line_edit
        if line_edit is not None:
            text = line_edit.text()
            line_edit.hide()
            line_edit.deleteLater()
            self._line_edit = None
            changed = self._title_label.text() != text
            if changed:
                self._title_label.setText(text)
            self._title_label.show()
            self._spacer.show()
            if changed:
                self.titleEdited.emit(text)

    #--------------------------------------------------------------------------
    # IDockItemTitleBar API
    #--------------------------------------------------------------------------
    def buttons(self):
        """ Get the buttons to show in the title bar.

        Returns
        -------
        result : int
            An or'd combination of the buttons to show.

        """
        return self._buttons

    def setButtons(self, buttons):
        """ Set the buttons to show in the title bar.

        Parameters
        ----------
        buttons : int
            An or'd combination of the buttons to show.

        """
        self._buttons = buttons
        self._max_button.setVisible(buttons & self.MaximizeButton)
        self._restore_button.setVisible(buttons & self.RestoreButton)
        self._close_button.setVisible(buttons & self.CloseButton)
        self._link_button.setVisible(buttons & self.LinkButton)
        self._pin_button.setVisible(buttons & self.PinButton)

    def title(self):
        """ Get the title string of the title bar.

        Returns
        -------
        result : unicode
            The unicode title string for the title bar.

        """
        return self._title_label.text()

    def setTitle(self, title):
        """ Set the title string of the title bar.

        Parameters
        ----------
        title : unicode
            The unicode string to use for the title bar.

        """
        self._title_label.setText(title)

    def label(self):
        """ Get the label which holds the title string.

        Returns
        -------
        result : QTextLabel
            The label widget which holds the title string.

        """
        return self._title_label

    def icon(self):
        """ Get the icon for the title bar.

        Returns
        -------
        result : QIcon
            The icon set for the title bar.

        """
        return self._title_icon.icon()

    def setIcon(self, icon):
        """ Set the icon for the title bar.

        Parameters
        ----------
        icon : QIcon
            The icon to use for the title bar.

        """
        visible, spacing = (False, 0) if icon.isNull() else (True, 4)
        title_icon = self._title_icon
        title_icon.setIcon(icon)
        title_icon.setVisible(visible)
        layout = self.layout()
        layout.takeAt(1)
        layout.insertSpacing(1, spacing)

    def iconSize(self):
        """ Get the icon size for the title bar.

        Returns
        -------
        result : QSize
            The size to use for the icons in the title bar.

        """
        return self._title_icon.iconSize()

    def setIconSize(self, size):
        """ Set the icon size for the title bar.

        Parameters
        ----------
        icon : QSize
            The icon size to use for the title bar. Icons smaller than
            this size will not be scaled up.

        """
        self._title_icon.setIconSize(size)

    def isLinked(self):
        """ Get whether the link button is checked.

        Returns
        -------
        result : bool
            True if the link button is checked, False otherwise.

        """
        return self._link_button.isChecked()

    def setLinked(self, linked):
        """ Set whether or not the link button is checked.

        Parameters
        ----------
        linked : bool
            True if the link button should be checked, False otherwise.

        """
        self._link_button.setChecked(linked)

    def isPinned(self):
        """ Get whether the pin button is checked.

        Returns
        -------
        result : bool
            True if the pin button is checked, False otherwise.

        """
        return self._pin_button.isChecked()

    def setPinned(self, pinned, quiet=False):
        """ Set whether or not the pin button is checked.

        Parameters
        ----------
        pinned : bool
            True if the pin button should be checked, False otherwise.

        quiet : bool, optional
            True if the state should be set without emitted the toggled
            signal. The default is False.

        """
        old = self._pin_button.blockSignals(quiet)
        self._pin_button.setChecked(pinned)
        self._pin_button.blockSignals(old)

    def isEditable(self):
        """ Get whether the title is user editable.

        Returns
        -------
        result : bool
            True if the title is user editable, False otherwise.

        """
        return self._is_editable

    def setEditable(self, editable):
        """ Set whether or not the title is user editable.

        Parameters
        ----------
        editable : bool
            True if the title is user editable, False otherwise.

        """
        self._is_editable = editable

    def isForceHidden(self):
        """ Get whether or not the title bar is force hidden.

        Returns
        -------
        result : bool
            Whether or not the title bar is always hidden.

        """
        return self._force_hidden

    def setForceHidden(self, hidden):
        """ Set the force hidden state of the title bar.

        Parameters
        ----------
        hidden : bool
            True if the title bar should be hidden, False otherwise.

        """
        self._force_hidden = hidden
        if not hidden and self._last_visible:
            super(QDockTitleBar, self).setVisible(True)
        elif hidden:
            super(QDockTitleBar, self).setVisible(False)

########NEW FILE########
__FILENAME__ = q_dock_window
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Typed

from enaml.qt.QtCore import (
    Qt, QMetaObject, QMargins, QPoint, QRect, QSize, Signal
)
from enaml.qt.QtGui import QFrame, QHBoxLayout, QLayout

from .event_types import DockAreaContentsChanged
from .q_bitmap_button import QBitmapButton, QCheckedBitmapButton
from .q_dock_area import QDockArea
from .q_dock_frame import QDockFrame
from .q_dock_frame_layout import QDockFrameLayout
from .xbms import (
    CLOSE_BUTTON, MAXIMIZE_BUTTON, RESTORE_BUTTON, LINKED_BUTTON,
    UNLINKED_BUTTON
)


class QDockWindowButtons(QFrame):
    """ A custom QFrame which provides the buttons for a QDockWindow.

    """
    #: A signal emitted when the maximize button is clicked.
    maximizeButtonClicked = Signal(bool)

    #: A signal emitted when the restore button is clicked.
    restoreButtonClicked = Signal(bool)

    #: A signal emitted when the close button is closed.
    closeButtonClicked = Signal(bool)

    #: A signal emitted when the link button is toggled.
    linkButtonToggled = Signal(bool)

    #: Do not show any buttons in the widget.
    NoButtons = 0x0

    #: Show the maximize button in the widget.
    MaximizeButton = 0x1

    #: Show the restore button in the widget.
    RestoreButton = 0x2

    #: Show the close button in the widget.
    CloseButton = 0x4

    #: Show the link button in the widget.
    LinkButton = 0x8

    def __init__(self, parent=None):
        """ Initialize a QDockWindowButtons instance.

        Parameters
        ----------
        parent : QWidget, optional
            The parent of the window buttons.

        """
        super(QDockWindowButtons, self).__init__(parent)
        self._buttons = (
            self.CloseButton | self.MaximizeButton | self.LinkButton
        )

        max_button = self._max_button = QBitmapButton(self)
        max_button.setObjectName('dockwindow-maximize-button')
        max_button.setBitmap(MAXIMIZE_BUTTON.toBitmap())
        max_button.setIconSize(QSize(20, 15))
        max_button.setVisible(self._buttons & self.MaximizeButton)
        max_button.setToolTip('Maximize')

        restore_button = self._restore_button = QBitmapButton(self)
        restore_button.setObjectName('dockwindow-restore-button')
        restore_button.setBitmap(RESTORE_BUTTON.toBitmap())
        restore_button.setIconSize(QSize(20, 15))
        restore_button.setVisible(self._buttons & self.RestoreButton)
        restore_button.setToolTip('Restore Down')

        close_button = self._close_button = QBitmapButton(self)
        close_button.setObjectName('dockwindow-close-button')
        close_button.setBitmap(CLOSE_BUTTON.toBitmap())
        close_button.setIconSize(QSize(34, 15))
        close_button.setVisible(self._buttons & self.CloseButton)
        close_button.setToolTip('Close')

        link_button = self._link_button = QCheckedBitmapButton(self)
        link_button.setObjectName('dockwindow-link-button')
        link_button.setBitmap(UNLINKED_BUTTON.toBitmap())
        link_button.setCheckedBitmap(LINKED_BUTTON.toBitmap())
        link_button.setIconSize(QSize(20, 15))
        link_button.setVisible(self._buttons & self.LinkButton)
        link_button.setToolTip('Link Window')
        link_button.setCheckedToolTip('Unlink Window')

        layout = QHBoxLayout()
        layout.setContentsMargins(QMargins(0, 0, 0, 0))
        layout.setSpacing(1)

        layout.addWidget(link_button)
        layout.addWidget(max_button)
        layout.addWidget(restore_button)
        layout.addWidget(close_button)

        self.setLayout(layout)

        max_button.clicked.connect(self.maximizeButtonClicked)
        restore_button.clicked.connect(self.restoreButtonClicked)
        close_button.clicked.connect(self.closeButtonClicked)
        link_button.toggled.connect(self.linkButtonToggled)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def buttons(self):
        """ Get the buttons to show in the title bar.

        Returns
        -------
        result : int
            An or'd combination of the buttons to show.

        """
        return self._buttons

    def setButtons(self, buttons):
        """ Set the buttons to show in the title bar.

        Parameters
        ----------
        buttons : int
            An or'd combination of the buttons to show.

        """
        self._buttons = buttons
        self._max_button.setVisible(buttons & self.MaximizeButton)
        self._restore_button.setVisible(buttons & self.RestoreButton)
        self._close_button.setVisible(buttons & self.CloseButton)
        self._link_button.setVisible(buttons & self.LinkButton)

    def isLinked(self):
        """ Get whether the link button is checked.

        Returns
        -------
        result : bool
            True if the link button is checked, False otherwise.

        """
        return self._link_button.isChecked()

    def setLinked(self, linked):
        """ Set whether or not the link button is checked.

        Parameters
        ----------
        linked : bool
            True if the link button should be checked, False otherwise.

        """
        self._link_button.setChecked(linked)


class QDockWindow(QDockFrame):
    """ A QDockFrame which holds a toplevel dock area.

    """
    #: The static resize margins for the dock window.
    ResizeMargins = QMargins(5, 5, 5, 5)

    #: The static normal contents margins for the dock window.
    NormalMargins = QMargins(5, 20, 5, 5)

    #: The static maximized margins for the dock window.
    MaximizedMargins = QMargins(0, 20, 0, 0)

    #: The minimum offset for the window buttons from the right edge.
    MinButtonOffset = 5

    class FrameState(QDockFrame.FrameState):
        """ A private class for managing window drag state.

        """
        #: The press position in the window title bar.
        press_pos = Typed(QPoint)

        #: Whether or not the window is being dragged by the user.
        dragging = Bool(False)

        #: Whether the window is inside it's close event.
        in_close_event = Bool(False)

    def __init__(self, manager, parent=None):
        """ Initialize a QDockWindow.

        Parameters
        ----------
        manager : DockManager
            The dock manager which owns the dock window.

        parent : QWidget or None
            The parent of the dock window, or None.

        """
        super(QDockWindow, self).__init__(manager, parent)
        self.setWindowFlags(Qt.Tool | Qt.FramelessWindowHint)
        self.setAttribute(Qt.WA_Hover, True)
        self.setMouseTracking(True)
        layout = QDockFrameLayout()
        layout.setSizeConstraint(QLayout.SetMinAndMaxSize)
        layout.setContentsMargins(self.NormalMargins)
        self.setLayout(layout)
        self.setDockArea(QDockArea())
        buttons = self._title_buttons = QDockWindowButtons(self)
        buttons.maximizeButtonClicked.connect(self.showMaximized)
        buttons.restoreButtonClicked.connect(self.showNormal)
        buttons.closeButtonClicked.connect(self.close)
        buttons.linkButtonToggled.connect(self.linkButtonToggled)

    #--------------------------------------------------------------------------
    # Reimplementations
    #--------------------------------------------------------------------------
    def showMaximized(self):
        """ Handle a show maximized request for the window.

        """
        self.layout().setContentsMargins(self.MaximizedMargins)
        super(QDockWindow, self).showMaximized()
        title_buttons = self._title_buttons
        buttons = title_buttons.buttons()
        buttons |= title_buttons.RestoreButton
        buttons &= ~title_buttons.MaximizeButton
        buttons &= ~title_buttons.LinkButton
        title_buttons.setButtons(buttons)
        title_buttons.setLinked(False)
        self._updateButtonGeometry()

    def showNormal(self):
        """ Handle a show normal request for the window.

        """
        super(QDockWindow, self).showNormal()
        self.applyNormalState()
        self._updateButtonGeometry()

    def applyNormalState(self):
        """ Apply the proper state for normal window geometry.

        """
        self.layout().setContentsMargins(self.NormalMargins)
        title_buttons = self._title_buttons
        buttons = title_buttons.buttons()
        buttons |= title_buttons.MaximizeButton
        buttons |= title_buttons.LinkButton
        buttons &= ~title_buttons.RestoreButton
        title_buttons.setButtons(buttons)
        title_buttons.setLinked(False)

    def titleBarGeometry(self):
        """ Get the geometry rect for the title bar.

        Returns
        -------
        result : QRect
            The geometry rect for the title bar, expressed in frame
            coordinates. An invalid rect is returned if title bar
            should not be active.

        """
        cmargins = self.layout().contentsMargins()
        if self.isMaximized():
            return QRect(0, 0, self.width(), cmargins.top())
        rmargins = self.ResizeMargins
        width = self.width() - (cmargins.left() + cmargins.right())
        height = cmargins.top() - rmargins.top()
        return QRect(cmargins.left(), rmargins.top(), width, height)

    def resizeMargins(self):
        """ Get the margins to use for resizing the container.

        Returns
        -------
        result : QMargins
            The margins to use for container resizing when the container
            is a top-level window.

        """
        if self.isMaximized():
            return QMargins()
        return self.ResizeMargins

    #--------------------------------------------------------------------------
    # Framework API
    #--------------------------------------------------------------------------
    def dockArea(self):
        """ Get the dock area installed on the container.

        Returns
        -------
        result : QDockArea or None
            The dock area installed in the container, or None.

        """
        return self.layout().getWidget()

    def setDockArea(self, dock_area):
        """ Set the dock area for the container.

        Parameters
        ----------
        dock_area : QDockArea
            The dock area to use in the container.

        """
        old = self.dockArea()
        if old is not None:
            old.removeEventFilter(self)
        self.layout().setWidget(dock_area)
        if dock_area is not None:
            dock_area.installEventFilter(self)

    def isLinked(self):
        """ Get whether or not the window is linked.

        """
        return self._title_buttons.isLinked()

    def setLinked(self, linked):
        """ Set whether or not the window is linked.

        This method should be reimplemented by a subclass.

        Parameters
        ----------
        linked : bool
            True if the window is considered linked, False otherwise.

        """
        self._title_buttons.setLinked(linked)

    def toggleMaximized(self):
        """ Toggle the maximized state of the window.

        """
        if self.isMaximized():
            self.showNormal()
        else:
            self.showMaximized()

    def eventFilter(self, area, event):
        """ Filter the events on the dock area.

        This filter listens for contents changes on the dock area and
        will close the window when the dock area is empty.

        """
        if event.type() == DockAreaContentsChanged and area.isEmpty():
            # Hide the window so that it doesn't steal events from
            # the floating window when this window is closed.
            self.hide()
            # Close the window later so that the event filter can
            # return before the child dock area is destroyed.
            QMetaObject.invokeMethod(self, 'close', Qt.QueuedConnection)
        return False

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def closeEvent(self, event):
        """ Handle a close event for the window.

        """
        # Protect against reentrency and posted contents events which
        # get delivered after the manager has already been removed.
        state = self.frame_state
        if state.in_close_event:
            return
        manager = self.manager()
        if manager is None:
            return
        state.in_close_event = True
        manager.close_window(self, event)
        state.in_close_event = False

    def resizeEvent(self, event):
        """ Handle the resize event for the dock window.

        """
        super(QDockWindow, self).resizeEvent(event)
        self._updateButtonGeometry()

    def mouseDoubleClickEvent(self, event):
        """ Handle the mouse double click event for the dock window.

        This handler will toggle the maximization of the window if the
        click occurs within the title bar.

        """
        event.ignore()
        if event.button() == Qt.LeftButton:
            geo = self.titleBarGeometry()
            geo.setRight(self._title_buttons.geometry().left())
            if geo.contains(event.pos()):
                self.toggleMaximized()
                event.accept()

    def hoverMoveEvent(self, event):
        """ Handle the hover move event for the dock window.

        This reimplementation unsets the cursor when the mouse hovers
        over the dock window buttons.

        """
        if self._title_buttons.geometry().contains(event.pos()):
            self.unsetCursor()
        else:
            super(QDockWindow, self).hoverMoveEvent(event)

    def titleBarMousePressEvent(self, event):
        """ Handle the mouse press event for the dock window.

        Returns
        -------
        result : bool
            True if the event is handled, False otherwise.

        """
        if event.button() == Qt.LeftButton:
            state = self.frame_state
            if state.press_pos is None:
                state.press_pos = event.pos()
                return True
        return False

    def titleBarMouseMoveEvent(self, event):
        """ Handle the mouse move event for the dock window.

        Returns
        -------
        result : bool
            True if the event is handled, False otherwise.

        """
        state = self.frame_state
        if state.press_pos is not None:
            global_pos = event.globalPos()
            if self.isMaximized():
                coeff = state.press_pos.x() / float(self.width())
                self.showNormal()
                button_width = self._title_buttons.width()
                margins = self.layout().contentsMargins()
                max_x = self.width() - margins.right() - button_width - 5
                test_x = int(coeff * self.width())
                new_x = max(5, min(test_x, max_x))
                state.press_pos.setX(new_x)
                state.press_pos.setY(margins.top() / 2)
            target_pos = global_pos - state.press_pos
            self.manager().drag_move_frame(self, target_pos, global_pos)
            return True
        return False

    def titleBarMouseReleaseEvent(self, event):
        """ Handle the mouse release event for the dock window.

        Returns
        -------
        result : bool
            True if the event is handled, False otherwise.

        """
        if event.button() == Qt.LeftButton:
            state = self.frame_state
            if state.press_pos is not None:
                self.manager().drag_release_frame(self, event.globalPos())
                state.dragging = False
                state.press_pos = None
                return True
        return False

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _updateButtonGeometry(self):
        """ Update the geometry of the window buttons.

        This method will set the geometry of the window buttons
        according to the current window size.

        """
        title_buttons = self._title_buttons
        size = title_buttons.minimumSizeHint()
        margins = self.layout().contentsMargins()
        offset = max(self.MinButtonOffset, margins.right())
        x = self.width() - size.width() - offset
        rect = QRect(x, 1, size.width(), size.height())
        title_buttons.setGeometry(rect)

########NEW FILE########
__FILENAME__ = q_guide_rose
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import sys

from atom.api import Atom, Float, Int, Str, Typed, Value, set_default

from enaml.qt.QtCore import Qt, QRect, QPoint
from enaml.qt.QtGui import QFrame, QImage, QPainter

# Make sure the resources get registered.
from . import dock_resources


class QGuideRose(QFrame):
    """ A custom QFrame which implements a collection of docking guides.

    This widget must always be used as an independent top-level window.
    The dock area which uses the rose should manually set the geometry
    of the widget before showing it.

    """
    class Guide(object):
        """ An enum class for identifying guide locations.

        """
        #: No relevant guide.
        NoGuide = 0

        #: The north border guide.
        BorderNorth = 1

        #: The east border guide.
        BorderEast = 2

        #: The south border guide.
        BorderSouth = 3

        #: The west border guide.
        BorderWest = 4

        #: The north compass guide.
        CompassNorth = 5

        #: The east compass guide.
        CompassEast = 6

        #: The south compass guide.
        CompassSouth = 7

        #: The west compass guide.
        CompassWest = 8

        #: The center compass guide.
        CompassCenter = 9

        #: The extended compass north guide.
        CompassExNorth = 10

        #: The extended compass east guide.
        CompassExEast = 11

        #: The extended compass south guide.
        CompassExSouth = 12

        #: The extended compass west guide.
        CompassExWest = 13

        #: The vertical split guide.
        SplitVertical = 14

        #: The horizontal split guide.
        SplitHorizontal = 15

        #: The area center guide.
        AreaCenter = 16

        #: The extended border north guide.
        BorderExNorth = 17

        #: The extended border east guide.
        BorderExEast = 18

        #: The extended border south guide.
        BorderExSouth = 19

        #: The extended border west guide.
        BorderExWest = 20

    class Mode(object):
        """ An enum class for defining the mode for the guide rose.

        A mode is an or'd combination of flags which dictate which parts
        of the guide rose are active on the screen. The modes related to
        the centerpiece should be considered mutually exclusive.

        """
        #: Nothing will be shown.
        NoMode = 0x0

        #: Show the border guides.
        Border = 0x1

        #: Show the standard compass as the centerpiece.
        Compass = 0x2

        #: Show the extended compass as the centerpiece.
        CompassEx = 0x4

        #: Show the horizontal split guide as the centerpiece.
        SplitHorizontal = 0x8

        #: Show the vertical split guide as the centerpiece.
        SplitVertical = 0x10

        #: Show the vertical area center as the centerpiece.
        AreaCenter = 0x20

    def __init__(self):
        """ Initialize a QGuideRose.

        """
        super(QGuideRose, self).__init__()
        # On Mac, setting the translucent background does not cause the
        # frame shadow to be hidden; it must be explicitly hidden. Mac
        # also requires the window to be a tooltip in order to be raised
        # above the rubber band in the Z-order. On Windows, the tooltip
        # leaves a dropshadow on Qt >= 4.8 whereas tool does not.
        if sys.platform == 'darwin':
            self.setAttribute(Qt.WA_MacNoShadow, True)
            flags = Qt.ToolTip
        else:
            flags = Qt.Tool
        self.setAttribute(Qt.WA_TranslucentBackground, True)
        flags |= Qt.WindowStaysOnTopHint | Qt.FramelessWindowHint
        self.setWindowFlags(flags)
        self._mode = self.Mode.NoMode
        self._center_point = QPoint()
        self._border_guide = BorderGuide()
        self._compass_guide = CompassGuide()
        self._compass_ex_guide = CompassExGuide()
        self._vsplit_guide = SplitVerticalGuide()
        self._hsplit_guide = SplitHorizontalGuide()
        self._area_guide = AreaCenterGuide()

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _layoutGuides(self):
        """ Layout the guides based on the current widget geometry.

        """
        self._border_guide.layout(self.rect())
        self._compass_guide.layout(self._center_point)
        self._compass_ex_guide.layout(self._center_point)
        self._vsplit_guide.layout(self._center_point)
        self._hsplit_guide.layout(self._center_point)
        self._area_guide.layout(self._center_point)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def centerPoint(self):
        """ Get the center point of the guide rose.

        Returns
        -------
        result : QPoint
            The location that will be used as the center of the portion
            of the rose with a configurable location.

        """
        return self._center_point

    def setCenterPoint(self, pos):
        """ Set the center point of the guide rose.

        Parameters
        ----------
        pos : QPoint
            The location that will be used as the center of the portion
            of the rose with a configurable location.

        """
        if pos != self._center_point:
            self._center_point = pos
            self._layoutGuides()
            self.update()

    def mode(self):
        """ Get the mode of the guide rose.

        Returns
        -------
        result : GuideMode
            The guide mode applied to the guide rose.

        """
        return self._mode

    def setMode(self, mode):
        """ Set the mode of the guide rose.

        Parameters
        ----------
        mode : GuideMode
            An or'd combination of mode flags for the guide rose.

        """
        if mode != self._mode:
            self._mode = mode
            self.update()

    def mouseOver(self, pos):
        """ Update the guide pads based on the mouse position.

        This current mode of the guide rose is used to determine which
        of the guide pads to should be updated.

        Parameters
        ----------
        pos : QPoint
            The position of the mouse expressed in local coordinates.

        """
        self._border_guide.mouse_over(pos)
        self._compass_guide.mouse_over(pos)
        self._compass_ex_guide.mouse_over(pos)
        self._vsplit_guide.mouse_over(pos)
        self._hsplit_guide.mouse_over(pos)
        self._area_guide.mouse_over(pos)
        self.update()

    def guideAt(self, pos, mode=None):
        """ Get the guide which lies underneath a given position.

        Parameters
        ----------
        pos : QPoint
            The position of interest, expressed local coordinates.

        mode : QGuideRose.Mode, optional
            The mode to use for hit testing. If not provided, the
            current mode for the guide rose is used.

        Returns
        -------
        result : QGuideRose.Guide
            The enum value for the guide under the mouse position.

        """
        Guide = self.Guide
        Mode = self.Mode
        mode = mode if mode is not None else self._mode
        if mode & Mode.Border:
            g = self._border_guide.guide_at(pos)
            if g != Guide.NoGuide:
                return g
        if mode & Mode.Compass:
            g = self._compass_guide.guide_at(pos)
            if g != Guide.NoGuide:
                return g
        elif mode & Mode.CompassEx:
            g = self._compass_ex_guide.guide_at(pos)
            if g != Guide.NoGuide:
                return g
        elif mode & Mode.SplitHorizontal:
            g = self._hsplit_guide.guide_at(pos)
            if g != Guide.NoGuide:
                return g
        elif mode & Mode.SplitVertical:
            g = self._vsplit_guide.guide_at(pos)
            if g != Guide.NoGuide:
                return g
        elif mode & Mode.AreaCenter:
            g = self._area_guide.guide_at(pos)
            if g != Guide.NoGuide:
                return g
        return Guide.NoGuide

    #--------------------------------------------------------------------------
    # Reimplementations
    #--------------------------------------------------------------------------
    def resizeEvent(self, event):
        """ Handle the resize event for the rose.

        This handler will relayout the guides on a resize.

        """
        self._layoutGuides()

    def paintEvent(self, event):
        """ Handle the paint event for the rose.

        This handler will redraw all of the guides for the rose.

        """
        super(QGuideRose, self).paintEvent(event)
        painter = QPainter(self)
        Mode = self.Mode
        mode = self._mode
        if mode & Mode.Border:
            self._border_guide.paint(painter)
        if mode & Mode.Compass:
            self._compass_guide.paint(painter)
        elif mode & Mode.CompassEx:
            self._compass_ex_guide.paint(painter)
        elif mode & Mode.SplitHorizontal:
            self._hsplit_guide.paint(painter)
        elif mode & Mode.SplitVertical:
            self._vsplit_guide.paint(painter)
        elif mode & Mode.AreaCenter:
            self._area_guide.paint(painter)


class GuideImage(Atom):
    """ A class which manages the painting of a guide image.

    """
    #: The default alpha value for guide transparency.
    TRANSPARENT = 0.60

    #: The default alpha value for no guide transparency.
    OPAQUE = 1.0

    #: The QImage to use when painting the guide.
    image = Typed(QImage, factory=lambda: QImage())

    #: The QRect specifying where to draw the image.
    rect = Typed(QRect, factory=lambda: QRect())

    #: The opacity to use when drawing the image.
    opacity = Float(TRANSPARENT)

    #: A cache of QImage instances for the loaded guide images.
    _images = {}

    @classmethod
    def load_image(cls, name):
        """ Load the guide image for the given name into a QImage.

        This function is hard-coded to return the named .png image from
        the ./dockguides directory located alongside this file. It is not
        a generic image loading routine.

        """
        image = cls._images.get(name)
        if image is None:
            image = QImage(':dock_images/%s.png' % name)
            cls._images[name] = image
        return image

    def __init__(self, name):
        """ Initialize a GuideImage.

        Parameters
        ----------
        name : string
            The name of the image to load for the guide.

        """
        self.image = self.load_image(name)

    def opacify(self):
        """ Make the guide image opaque.

        """
        self.opacity = self.OPAQUE

    def transparentize(self):
        """ Make the guide image transparent.

        """
        self.opacity = self.TRANSPARENT

    def contains(self, point):
        """ Test whether the image contains a point.

        Parameters
        ----------
        rect : QPoint
            The rect to test for containment.

        Returns
        -------
        result : bool
            True if the image contains the point, False otherwise.

        """
        return self.rect.contains(point)

    def paint(self, painter):
        """ Paint the image using the given painter.

        Parameters
        ----------
        painter : QPainter
            An active QPainter to use for drawing the image. If the
            image is a null image, painting will be skipped.

        """
        image = self.image
        if image.isNull():
            return
        painter.save()
        painter.setOpacity(self.opacity)
        painter.drawImage(self.rect, image)
        painter.restore()


class GuideHandler(Atom):
    """ A base class for defining guide handlers.

    """
    #: The last guide hit during a mouseover.
    _last_guide = Typed(GuideImage)

    def iterguides(self):
        """ Iterate the guides managed by this handler.

        Returns
        -------
        result : iterable
            An iterable of (Guide, GuideImage) pairs which are the
            guides managed by the handler.

        """
        raise NotImplementedError

    def iterboxes(self):
        """ Iterate the boxes which lie under the guides.

        Returns
        -------
        result : iterable
            An iterable of GuideImage instances which are the boxes
            to be painted under the guides.

        """
        raise NotImplementedError

    def guide_at(self, pos):
        """ Get the guide under the given mouse position.

        Parameters
        ----------
        pos : QPoint
            The point of interest, expressed in layout coordinates.

        Returns
        -------
        result : Guide
            The enum value for the guide at the given position.

        """
        for enum, guide in self.iterguides():
            if guide.contains(pos):
                return enum
        return QGuideRose.Guide.NoGuide

    def mouse_over(self, pos):
        """ Perform a mouse over of the guides.

        Parameters
        ----------
        pos : QPoint
            The position of interest expressed in layout coordinates.

        """
        for ignored, guide in self.iterguides():
            if guide.contains(pos):
                last = self._last_guide
                if last is not None and last is not guide:
                    last.transparentize()
                guide.opacify()
                self._last_guide = guide
                break
        else:
            if self._last_guide is not None:
                self._last_guide.transparentize()

    def paint(self, painter):
        """ Paint the guides using the supplied painter.

        Parameters
        ----------
        painter : QPainter
            The painter to use to paint the guides.

        """
        for box in self.iterboxes():
            box.paint(painter)
        for ignored, guide in self.iterguides():
            guide.paint(painter)


class BorderGuide(GuideHandler):
    """ A guide handler which manages the border guide.

    """
    _guides = Value(factory=lambda: {
        QGuideRose.Guide.BorderNorth: GuideImage('thin_horizontal'),
        QGuideRose.Guide.BorderExNorth: GuideImage('bar_horizontal'),
        QGuideRose.Guide.BorderEast: GuideImage('thin_vertical'),
        QGuideRose.Guide.BorderExEast: GuideImage('bar_vertical'),
        QGuideRose.Guide.BorderSouth: GuideImage('thin_horizontal'),
        QGuideRose.Guide.BorderExSouth: GuideImage('bar_horizontal'),
        QGuideRose.Guide.BorderWest: GuideImage('thin_vertical'),
        QGuideRose.Guide.BorderExWest: GuideImage('bar_vertical'),
    })

    _boxes = Value(factory=lambda: {
        QGuideRose.Guide.BorderNorth: GuideImage('guide_box'),
        QGuideRose.Guide.BorderEast: GuideImage('guide_box'),
        QGuideRose.Guide.BorderSouth: GuideImage('guide_box'),
        QGuideRose.Guide.BorderWest: GuideImage('guide_box'),
    })

    def iterguides(self):
        """ Iterate the guides managed by the handler.

        Returns
        -------
        result : iterable
            An iterable of (Guide, GuideImage) pairs which are the
            guides managed by the handler.

        """
        return self._guides.iteritems()

    def iterboxes(self):
        """ Iterate the boxes which lie under the guides.

        Returns
        -------
        result : iterable
            An iterable of GuideImage instances which are the boxes
            to be painted under the guides.

        """
        return self._boxes.itervalues()

    def layout(self, rect):
        """ Layout the guides for the given rect.

        Parameters
        ----------
        rect : QRect
            The rectangle in which to layout the border guides.

        """
        boxes = self._boxes
        guides = self._guides
        w = rect.width()
        h = rect.height()
        cx = rect.left() + w / 2
        cy = rect.top() + h / 2
        Guide = QGuideRose.Guide
        guides[Guide.BorderNorth].rect = QRect(cx - 15, 27, 31, 19)
        guides[Guide.BorderExNorth].rect = QRect(cx - 15, 15, 31, 10)
        boxes[Guide.BorderNorth].rect = QRect(cx - 20, 10, 41, 41)
        guides[Guide.BorderEast].rect = QRect(w - 45, cy - 15, 19, 31)
        guides[Guide.BorderExEast].rect = QRect(w - 24, cy - 15, 10, 31)
        boxes[Guide.BorderEast].rect = QRect(w - 50, cy - 20, 41, 41)
        guides[Guide.BorderSouth].rect = QRect(cx - 15, h - 45, 31, 19)
        guides[Guide.BorderExSouth].rect = QRect(cx - 15, h - 24, 31, 10)
        boxes[Guide.BorderSouth].rect = QRect(cx - 20, h - 50, 41, 41)
        guides[Guide.BorderWest].rect = QRect(27, cy - 15, 19, 31)
        guides[Guide.BorderExWest].rect = QRect(15, cy - 15, 10, 31)
        boxes[Guide.BorderWest].rect = QRect(10, cy - 20, 41, 41)


class CompassGuide(GuideHandler):
    """ A guide handler which manages the standard compass guide.

    """
    _guides = Value(factory=lambda: {
        QGuideRose.Guide.CompassNorth: GuideImage('arrow_north'),
        QGuideRose.Guide.CompassEast: GuideImage('arrow_east'),
        QGuideRose.Guide.CompassSouth: GuideImage('arrow_south'),
        QGuideRose.Guide.CompassWest: GuideImage('arrow_west'),
        QGuideRose.Guide.CompassCenter: GuideImage('center'),
    })

    _box = Value(factory=lambda: GuideImage('cross_box'))

    def iterguides(self):
        """ Iterate the guides for the compass.

        Returns
        -------
        result : generator
            A generator which yields 2-tuples of (enum, guide) for
            the relevant guides in the compass.

        """
        return self._guides.iteritems()

    def iterboxes(self):
        """ Iterate the boxes which lie under the guides.

        Returns
        -------
        result : iterable
            An iterable of GuideImage instances which are the boxes
            to be painted under the guides.

        """
        yield self._box

    def layout(self, pos):
        """ Layout the guides for the given position.

        Parameters
        ----------
        pos : QPoint
            The center point of the compass.

        """
        x = pos.x()
        y = pos.y()
        Guide = QGuideRose.Guide
        guides = self._guides
        guides[Guide.CompassNorth].rect = QRect(x - 15, y - 50, 31, 31)
        guides[Guide.CompassEast].rect = QRect(x + 20, y - 15, 31, 31)
        guides[Guide.CompassSouth].rect = QRect(x - 15, y + 20, 31, 31)
        guides[Guide.CompassWest].rect = QRect(x - 50, y - 15, 31, 31)
        guides[Guide.CompassCenter].rect = QRect(x - 15, y - 15, 31, 31)
        self._box.rect = QRect(x - 55, y - 55, 111, 111)


class CompassExGuide(GuideHandler):
    """ A class which renders the extended compass guide.

    """
    _guides = Value(factory=lambda: {
        QGuideRose.Guide.CompassNorth: GuideImage('arrow_north'),
        QGuideRose.Guide.CompassEast: GuideImage('arrow_east'),
        QGuideRose.Guide.CompassSouth: GuideImage('arrow_south'),
        QGuideRose.Guide.CompassWest: GuideImage('arrow_west'),
        QGuideRose.Guide.CompassCenter: GuideImage('center'),
        QGuideRose.Guide.CompassExNorth: GuideImage('bar_horizontal'),
        QGuideRose.Guide.CompassExEast: GuideImage('bar_vertical'),
        QGuideRose.Guide.CompassExSouth: GuideImage('bar_horizontal'),
        QGuideRose.Guide.CompassExWest: GuideImage('bar_vertical'),
    })

    _box = Value(factory=lambda: GuideImage('cross_ex_box'))

    def iterguides(self):
        """ Iterate the guides for the extented compass.

        Returns
        -------
        result : generator
            A generator which yields 2-tuples of (enum, guide) for
            the relevant guides in the compass.

        """
        return self._guides.iteritems()

    def iterboxes(self):
        """ Iterate the boxes which lie under the guides.

        Returns
        -------
        result : iterable
            An iterable of GuideImage instances which are the boxes
            to be painted under the guides.

        """
        yield self._box

    def layout(self, pos):
        """ Layout the guides for the extended compass.

        Parameters
        ----------
        pos : QPoint
            The center point of the compass.

        """
        x = pos.x()
        y = pos.y()
        Guide = QGuideRose.Guide
        guides = self._guides
        guides[Guide.CompassNorth].rect = QRect(x - 15, y - 64, 31, 31)
        guides[Guide.CompassEast].rect = QRect(x + 34, y - 15, 31, 31)
        guides[Guide.CompassSouth].rect = QRect(x - 15, y + 34, 31, 31)
        guides[Guide.CompassWest].rect = QRect(x - 64, y - 15, 31, 31)
        guides[Guide.CompassCenter].rect = QRect(x - 15, y - 15, 31, 31)
        guides[Guide.CompassExNorth].rect = QRect(x - 15, y - 29, 31, 10)
        guides[Guide.CompassExEast].rect = QRect(x + 20, y - 15, 10, 31)
        guides[Guide.CompassExSouth].rect = QRect(x - 15, y + 20, 31, 10)
        guides[Guide.CompassExWest].rect = QRect(x - 29, y - 15, 10, 31)
        self._box.rect = QRect(x - 69, y - 69, 139, 139)


class SingleGuide(GuideHandler):
    """ A base class for defining a single guide.

    """
    guide_enum = Int(QGuideRose.Guide.NoGuide)

    image_name = Str('')

    _box = Value(factory=lambda: GuideImage('guide_box'))

    _guide = Typed(GuideImage)

    def _default__guide(self):
        """ The default value handler for the '_guide' attribute.

        """
        return GuideImage(self.image_name)

    def iterguides(self):
        """ Iterate the guides for the compass.

        Returns
        -------
        result : generator
            A generator which yields 2-tuples of (enum, guide) for
            the relevant guides in the compass.

        """
        yield (self.guide_enum, self._guide)

    def iterboxes(self):
        """ Iterate the boxes which lie under the guides.

        Returns
        -------
        result : iterable
            An iterable of GuideImage instances which are the boxes
            to be painted under the guides.

        """
        yield self._box

    def layout(self, pos):
        """ Layout the guides for the given position.

        Parameters
        ----------
        pos : QPoint
            The center point of the guide.

        """
        x = pos.x()
        y = pos.y()
        self._guide.rect = QRect(x - 15, y - 15, 31, 31)
        self._box.rect = QRect(x - 20, y - 20, 41, 41)


class SplitHorizontalGuide(SingleGuide):
    """ A single guide which uses the horizontal split image.

    """
    guide_enum = set_default(QGuideRose.Guide.SplitHorizontal)

    image_name = set_default('split_horizontal')


class SplitVerticalGuide(SingleGuide):
    """ A single guide which uses the vertical split image.

    """
    guide_enum = set_default(QGuideRose.Guide.SplitVertical)

    image_name = set_default('split_vertical')


class AreaCenterGuide(SingleGuide):
    """ A single guide which uses the area center image.

    """
    guide_enum = set_default(QGuideRose.Guide.AreaCenter)

    image_name = set_default('center')

########NEW FILE########
__FILENAME__ = q_icon_widget
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from enaml.qt.QtCore import QSize
from enaml.qt.QtGui import QFrame, QIcon, QPainter


class QIconWidget(QFrame):
    """ A custom QFrame which paints an icon.

    """
    def __init__(self, parent=None):
        """ Initialize a QIconWidget.

        Parameters
        ----------
        parent : QWidget, optional
            The parent of the icon widget.

        """
        super(QIconWidget, self).__init__(parent)
        self._icon_size = QSize()
        self._icon = QIcon()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def icon(self):
        """ Get the icon for the widget.

        Returns
        -------
        result : QIcon
            The icon installed on the widget.

        """
        return self._icon

    def setIcon(self, icon):
        """ Set the icon for the widget.

        Parameters
        ----------
        icon : QIcon
            The icon to use for the widget.

        """
        self._icon = icon
        self.update()

    def iconSize(self):
        """ Get the icon size for the widget.

        Returns
        -------
        result : QSize
            The size to use for displaying the icon.

        """
        return self._icon_size

    def setIconSize(self, size):
        """ Set the icon size for the widget.

        Parameters
        ----------
        size : QSize
            The icon size to use for the widget.

        """
        self._icon_size = size
        self.updateGeometry()
        self.update()

    #--------------------------------------------------------------------------
    # Reimplementations
    #--------------------------------------------------------------------------
    def sizeHint(self):
        """ Get the size hint for the widget.

        """
        return self.minimumSizeHint()

    def minimumSizeHint(self):
        """ Get the minimum size hint for the widget.

        """
        size = self._icon_size
        if not size.isValid():
            size = QSize(16, 16)
        left, top, right, bottom = self.getContentsMargins()
        return size + QSize(left + right, top + bottom)

    def paintEvent(self, event):
        """ Handle the paint event for the widget.

        """
        super(QIconWidget, self).paintEvent(event)
        icon = self._icon
        if icon.isNull():
            return
        icon.paint(QPainter(self), self.contentsRect())

########NEW FILE########
__FILENAME__ = q_text_label
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from enaml.qt.QtCore import Qt, QSize, QEvent
from enaml.qt.QtGui import QFrame, QPainter


class QTextLabel(QFrame):
    """ A custom QFrame which draws elided text.

    """
    def __init__(self, parent=None):
        """ Initialize a QDockTitleBar.

        Parameters
        ----------
        parent : QWidget or None
            The parent of the title bar.

        """
        super(QTextLabel, self).__init__(parent)
        self._min_text_size = QSize()
        self._text_size = QSize()
        self._text = u''

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    @staticmethod
    def _computeElidedText(text):
        """ Compute the minimum elided text for the tab title.

        """
        # Based on QTabBar::computeElidedText
        if len(text) > 3:
            text = text[:2] + '...'
        return text

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def text(self):
        """ Get the text string of the text label.

        Returns
        -------
        result : unicode
            The unicode text string for the text label.

        """
        return self._text

    def setText(self, text):
        """ Set the text string of the text label.

        Parameters
        ----------
        text : unicode
            The unicode string to use for the text label.

        """
        self._min_text_size = QSize()
        self._text_size = QSize()
        self._text = text
        self.updateGeometry()
        self.update()

    #--------------------------------------------------------------------------
    # Reimplementations
    #--------------------------------------------------------------------------
    def event(self, event):
        """ The generic event handler for the text label.

        This handler ensures the size hint caches are invalidated when
        the widget style changes.

        """
        if event.type() == QEvent.StyleChange:
            self._min_text_size = QSize()
            self._text_size = QSize()
        return super(QTextLabel, self).event(event)

    def sizeHint(self):
        """ Get the size hint for the text label.

        """
        base = self._text_size
        if not base.isValid():
            metrics = self.fontMetrics()
            base = QSize(metrics.width(self._text), metrics.height())
            self._text_size = base
        left, top, right, bottom = self.getContentsMargins()
        return base + QSize(left + right, top + bottom)

    def minimumSizeHint(self):
        """ Get the minimum size hint for the text label.

        """
        base = self._min_text_size
        if not base.isValid():
            metrics = self.fontMetrics()
            text = self._computeElidedText(self._text)
            base = QSize(metrics.width(text), metrics.height())
            self._min_text_size = base
        left, top, right, bottom = self.getContentsMargins()
        return base + QSize(left + right, top + bottom)

    def paintEvent(self, event):
        """ Handle the paint event for the title bar.

        This paint handler draws the title bar text and title buttons.

        """
        super(QTextLabel, self).paintEvent(event)
        rect = self.contentsRect()
        metrics = self.fontMetrics()
        # The +1 is to fix a seeming off-by-one error in elidedText.
        # https://github.com/nucleic/enaml/issues/38
        text = metrics.elidedText(self._text, Qt.ElideRight, rect.width() + 1)
        QPainter(self).drawText(rect, Qt.AlignLeft | Qt.AlignVCenter, text)

########NEW FILE########
__FILENAME__ = style_sheets
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------


#: The global dict of registered stylesheets. This dict should never be
#: modified directly. Use the functions 'register_style_sheet' and
#: 'get_style_sheet' instead.
_style_sheets = {}


def get_style_sheet(name):
    """ This is a deprecated function.

    """
    return _style_sheets.get(name, u'')


def register_style_sheet(name, sheet):
    """ This is a deprecated function.

    """
    import warnings
    msg = "Toolkit specific styling for the DockArea is deprecated "
    msg += "and will be removed in Enaml version 1.0. Use stylesheets "
    msg += "to style the Dock Area instead."
    warnings.warn(msg, FutureWarning, stacklevel=2)

    assert isinstance(sheet, unicode), 'style sheet must a unicode string'
    if name in _style_sheets:
        raise ValueError("'%s' style is already registered" % name)
    _style_sheets[name] = sheet

########NEW FILE########
__FILENAME__ = utils
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------


def repolish(widget):
    """ Repolish a widget when the stylesheet dependencies change.

    Parameters
    ----------
    widget : QWidget
        The widget to repolish.

    """
    style = widget.style()
    style.unpolish(widget)
    style.polish(widget)

########NEW FILE########
__FILENAME__ = xbms
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, Int, Str

from enaml.qt.QtCore import QSize
from enaml.qt.QtGui import QBitmap, QImage


class XBM(Atom):
    """ A simple class representing an XMB image.

    """
    #: The width of the xbm image.
    width = Int()

    #: The height of the xbm image.
    height = Int()

    #: The bytestring of image data.
    data = Str()

    def __init__(self, width, height, data):
        """ Initialize an XBM image.

        Parameters
        ----------
        width : int
            The width of the bitmap.

        height : int
            The height of the bitmap.

        data : list
            A list of 1s and 0s which represent the bitmap data.
            The length must be equal to width * height.

        """
        assert len(data) == (width * height)
        bytes = []
        for row in xrange(height):
            val = 0
            offset = row * width
            for col in xrange(width):
                d = col % 8
                if col > 0 and d == 0:
                    bytes.append(chr(val))
                    val = 0
                v = data[offset + col]
                val |= v << (7 - d)
            bytes.append(chr(val))
        self.width = width
        self.height = height
        self.data = ''.join(bytes)

    def toBitmap(self):
        size = QSize(self.width, self.height)
        return QBitmap.fromData(size, self.data, QImage.Format_Mono)


CLOSE_BUTTON = XBM(8, 7, [
    1, 1, 0, 0, 0, 0, 1, 1,
    0, 1, 1, 0, 0, 1, 1, 0,
    0, 0, 1, 1, 1, 1, 0, 0,
    0, 0, 0, 1, 1, 0, 0, 0,
    0, 0, 1, 1, 1, 1, 0, 0,
    0, 1, 1, 0, 0, 1, 1, 0,
    1, 1, 0, 0, 0, 0, 1, 1,
])


MAXIMIZE_BUTTON = XBM(8, 7, [
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 0, 0, 0, 0, 0, 0, 1,
    1, 0, 0, 0, 0, 0, 0, 1,
    1, 0, 0, 0, 0, 0, 0, 1,
    1, 0, 0, 0, 0, 0, 0, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
])


RESTORE_BUTTON = XBM(10, 9, [
    0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 0, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 0, 1,
    1, 0, 0, 0, 0, 0, 0, 1, 0, 1,
    1, 0, 0, 0, 0, 0, 0, 1, 0, 1,
    1, 0, 0, 0, 0, 0, 0, 1, 0, 1,
    1, 0, 0, 0, 0, 0, 0, 1, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
])


LINKED_BUTTON = XBM(10, 9, [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
    1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
    1, 0, 1, 1, 1, 1, 1, 1, 0, 1,
    1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
    1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
])


UNLINKED_BUTTON = XBM(10, 9, [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
    1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
    1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
    1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
    1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
])


PIN_BUTTON = XBM(9, 9, [
    0, 0, 1, 1, 1, 1, 1, 0, 0,
    0, 0, 1, 0, 0, 1, 1, 0, 0,
    0, 0, 1, 0, 0, 1, 1, 0, 0,
    0, 0, 1, 0, 0, 1, 1, 0, 0,
    0, 0, 1, 0, 0, 1, 1, 0, 0,
    0, 1, 1, 1, 1, 1, 1, 1, 0,
    0, 0, 0, 0, 1, 0, 0, 0, 0,
    0, 0, 0, 0, 1, 0, 0, 0, 0,
    0, 0, 0, 0, 1, 0, 0, 0, 0,
])


UNPIN_BUTTON = XBM(9, 9, [
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 1, 1, 1, 1, 1,
    0, 0, 0, 1, 0, 0, 0, 0, 1,
    1, 1, 1, 1, 0, 0, 0, 0, 1,
    0, 0, 0, 1, 1, 1, 1, 1, 1,
    0, 0, 0, 1, 1, 1, 1, 1, 1,
    0, 0, 0, 1, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
])

########NEW FILE########
__FILENAME__ = focus_registry
#------------------------------------------------------------------------------
# Copyright (c) 2014, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
""" A simple registry module for tracking focus widget mappings.

"""
from .QtGui import QApplication


#: The internal mapping of widget to proxy object.
__registry = {}


def register(widget, proxy):
    """ Register a widget and proxy object with the focus registry.

    Parameters
    ----------
    widget : QWidget
        The widget which should be mapped to the given proxy object.

    proxy : QtWidget
        The proxy object to associate with the given widget.

    """
    __registry[widget] = proxy


def unregister(widget):
    """ Unregister a widget from the focus registry.

    Parameters
    ----------
    widget : QWidget
        The widget which should be removed from the registry.

    """
    __registry.pop(widget, None)


def lookup(widget):
    """ Lookup a proxy object in the focus registry.

    Parameters
    ----------
    widget : QWidget
        The widget associated with the proxy object.

    Returns
    -------
    result : QtWidget or None
        The mapped proxy object, or None if the mapping does not exist.

    """
    return __registry.get(widget)


def focused_proxy():
    """ Get the currently focused proxy object.

    Returns
    -------
    result : QtWidget or None
        The mapped proxy object for the currently focused widget,
        or None if the focus widget does not map to a proxy.

    """
    return lookup(QApplication.focusWidget())


def focused_declaration():
    """ Get the current focused declaration object.

    Returns
    -------
    result : Widget or None
        The declaration for the currently focused proxy, or None if
        the current focus widget does not map to a proxy.

    """
    fp = focused_proxy()
    return fp and fp.declaration

########NEW FILE########
__FILENAME__ = QtCore
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from . import QT_API 


if QT_API == 'pyqt':
    from PyQt4.QtCore import *
    Property = pyqtProperty
    Signal = pyqtSignal
    Slot = pyqtSlot
    QDateTime.toPython = QDateTime.__dict__['toPyDateTime']
    QDate.toPython = QDate.__dict__['toPyDate']
    QTime.toPython = QTime.__dict__['toPyTime']
    __version__ = QT_VERSION_STR
    __version_info__ = tuple(map(int, QT_VERSION_STR.split('.')))
    # Remove the input hook or pdb.set_trace() will infinitely recurse
    pyqtRemoveInputHook()
else:
    from PySide import __version__, __version_info__
    from PySide.QtCore import *

########NEW FILE########
__FILENAME__ = QtGui
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from . import QT_API


if QT_API == 'pyqt':
    from PyQt4.QtGui import *
else:
    from PySide.QtGui import *

########NEW FILE########
__FILENAME__ = QtNetwork
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from . import QT_API


if QT_API == 'pyqt':
    from PyQt4.QtNetwork import *
else:
    from PySide.QtNetwork import *

########NEW FILE########
__FILENAME__ = QtOpenGL
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from . import QT_API


if QT_API == 'pyqt':
    from PyQt4.QtOpenGL import *
else:
    from PySide.QtOpenGL import *

########NEW FILE########
__FILENAME__ = QtScript
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from . import QT_API


if QT_API == 'pyqt':
    from PyQt4.QtScript import *
else:
    from PySide.QtScript import *

########NEW FILE########
__FILENAME__ = QtSvg
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from . import QT_API


if QT_API == 'pyqt':
    from PyQt4.QtSvg import *
else:
    from PySide.QtSvg import *

########NEW FILE########
__FILENAME__ = QtTest
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from . import QT_API


if QT_API == 'pyqt':
    from PyQt4.QtTest import *
else:
    from PySide.QtTest import *

########NEW FILE########
__FILENAME__ = QtWebKit
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from . import QT_API


if QT_API == 'pyqt':
    from PyQt4.QtWebKit import *
else:
    from PySide.QtWebKit import *

########NEW FILE########
__FILENAME__ = qt_abstract_button
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Int, Typed

from enaml.widgets.abstract_button import ProxyAbstractButton

from .QtCore import QSize
from .QtGui import QAbstractButton, QIcon

from .q_resource_helpers import get_cached_qicon
from .qt_control import QtControl


# cyclic notification guard flags
CHECKED_GUARD = 0x1


class QtAbstractButton(QtControl, ProxyAbstractButton):
    """ A Qt implementation of the Enaml ProxyAbstractButton.

    This class can serve as a base class for widgets that implement
    button behavior such as CheckBox, RadioButton and PushButtons.
    It is not meant to be used directly.

    """
    #: A reference to the widget created by the proxy
    widget = Typed(QAbstractButton)

    #: Cyclic notification guard. This a bitfield of multiple guards.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Implement in a subclass to create the widget.

        """
        raise NotImplementedError

    def init_widget(self):
        """ Initialize the button widget.

        """
        super(QtAbstractButton, self).init_widget()
        d = self.declaration
        if d.text:
            self.set_text(d.text)
        if d.icon:
            self.set_icon(d.icon)
        if -1 not in d.icon_size:
            self.set_icon_size(d.icon_size)
        self.set_checkable(d.checkable)
        self.set_checked(d.checked)
        widget = self.widget
        widget.clicked.connect(self.on_clicked)
        widget.toggled.connect(self.on_toggled)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_clicked(self):
        """ The signal handler for the 'clicked' signal.

        """
        # PySide does pass the 'checked' arg to the slot like PyQt, so
        # grab the checked attribute directly, which works on both.
        checked = self.widget.isChecked()
        if not self._guard & CHECKED_GUARD:
            self.declaration.checked = checked
            self.declaration.clicked(checked)

    def on_toggled(self, checked):
        """ The signal handler for the 'toggled' signal.

        """
        if not self._guard & CHECKED_GUARD:
            self.declaration.checked = checked
            self.declaration.toggled(checked)

    #--------------------------------------------------------------------------
    # ProxyAbstractButton API
    #--------------------------------------------------------------------------
    def set_text(self, text):
        """ Sets the widget's text with the provided value.

        """
        with self.geometry_guard():
            self.widget.setText(text)

    def set_icon(self, icon):
        """ Set the icon on the widget.

        """
        if icon:
            qicon = get_cached_qicon(icon)
        else:
            qicon = QIcon()
        with self.geometry_guard():
            self.widget.setIcon(qicon)

    def set_icon_size(self, size):
        """ Sets the widget's icon size.

        """
        with self.geometry_guard():
            self.widget.setIconSize(QSize(*size))

    def set_checkable(self, checkable):
        """ Sets whether or not the widget is checkable.

        """
        self.widget.setCheckable(checkable)

    def set_checked(self, checked):
        """ Sets the widget's checked state with the provided value.

        """
        widget = self.widget
        # This handles the case where, by default, Qt will not allow
        # all of the radio buttons in a group to be disabled. By
        # temporarily turning off auto-exclusivity, we are able to
        # handle that case.
        self._guard |= CHECKED_GUARD
        try:
            if not checked and widget.isChecked() and widget.autoExclusive():
                widget.setAutoExclusive(False)
                widget.setChecked(checked)
                widget.setAutoExclusive(True)
            else:
                widget.setChecked(checked)
        finally:
            self._guard &= ~CHECKED_GUARD

########NEW FILE########
__FILENAME__ = qt_action
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Int, Typed

from enaml.widgets.action import ProxyAction

from .QtGui import QAction, QKeySequence, QIcon

from .q_resource_helpers import get_cached_qicon
from .qt_toolkit_object import QtToolkitObject


# cyclic notification guard flags
CHECKED_GUARD = 0x1


class QtAction(QtToolkitObject, ProxyAction):
    """ A Qt implementation of an Enaml ProxyAction.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QAction)

    #: Cyclic notification guard. This a bitfield of multiple guards.
    _guard = Int(0)

    # FIXME Currently, the checked state of the action is lost when
    # switching from checkable to non-checkable and back again.
    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying QAction object.

        """
        self.widget = QAction(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying control.

        """
        super(QtAction, self).init_widget()
        d = self.declaration
        if d.text:
            self.set_text(d.text)
        if d.tool_tip:
            self.set_tool_tip(d.tool_tip)
        if d.status_tip:
            self.set_status_tip(d.status_tip)
        if d.icon:
            self.set_icon(d.icon)
        self.set_checkable(d.checkable)
        self.set_checked(d.checked)
        self.set_enabled(d.enabled)
        self.set_visible(d.visible)
        self.set_separator(d.separator)
        widget = self.widget
        widget.triggered.connect(self.on_triggered)
        widget.toggled.connect(self.on_toggled)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_triggered(self):
        """ The signal handler for the 'triggered' signal.

        """
        # PySide does pass the 'checked' arg to the slot like PyQt, so
        # grab the checked attribute directly, which works on both.
        checked = self.widget.isChecked()
        if not self._guard & CHECKED_GUARD:
            self.declaration.checked = checked
            self.declaration.triggered(checked)

    def on_toggled(self, checked):
        """ The signal handler for the 'toggled' signal.

        """
        if not self._guard & CHECKED_GUARD:
            self.declaration.checked = checked
            self.declaration.toggled(checked)

    #--------------------------------------------------------------------------
    # ProxyAction API
    #--------------------------------------------------------------------------
    def set_text(self, text):
        """ Set the text on the underlying control.

        """
        widget = self.widget
        widget.setText(text)
        parts = text.split('\t')
        if len(parts) > 1:
            shortcut = QKeySequence(parts[-1])
            widget.setShortcut(shortcut)

    def set_tool_tip(self, tool_tip):
        """ Set the tool tip on the underlying control.

        """
        self.widget.setToolTip(tool_tip)

    def set_status_tip(self, status_tip):
        """ Set the status tip on the underyling control.

        """
        self.widget.setStatusTip(status_tip)

    def set_icon(self, icon):
        """ Set the icon for the action.

        """
        if icon:
            qicon = get_cached_qicon(icon)
        else:
            qicon = QIcon()
        self.widget.setIcon(qicon)

    def set_checkable(self, checkable):
        """ Set the checkable state on the underlying control.

        """
        self.widget.setCheckable(checkable)

    def set_checked(self, checked):
        """ Set the checked state on the underlying control.

        """
        self._guard |= CHECKED_GUARD
        try:
            self.widget.setChecked(checked)
        finally:
            self._guard &= ~CHECKED_GUARD

    def set_enabled(self, enabled):
        """ Set the enabled state on the underlying control.

        """
        self.widget.setEnabled(enabled)

    def set_visible(self, visible):
        """ Set the visible state on the underlying control.

        """
        self.widget.setVisible(visible)

    def set_separator(self, separator):
        """ Set the separator state on the underlying control.

        """
        self.widget.setSeparator(separator)

########NEW FILE########
__FILENAME__ = qt_action_group
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.action_group import ProxyActionGroup

from .QtGui import QActionGroup

from .qt_action import QtAction
from .qt_toolkit_object import QtToolkitObject


class QCustomActionGroup(QActionGroup):
    """ A QActionGroup subclass which fixes some toggling issues.

    When a QActionGroup is set from non-exlusive to exclusive, it
    doesn't uncheck the non-current actions. It also does not keep
    track of the most recently checked widget when in non-exclusive
    mode, so that state is lost. This subclass corrects these issues.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a QCustomActionGroup.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initialize
            a QActionGroup.

        """
        super(QCustomActionGroup, self).__init__(*args, **kwargs)
        self.triggered.connect(self.onTriggered)
        self._last_checked = None

    def onTriggered(self, action):
        """ The signal handler for the 'triggered' signal.

        """
        if action.isCheckable() and action.isChecked():
            if self.isExclusive():
                last = self._last_checked
                if last is not None and last is not action:
                    last.setChecked(False)
            self._last_checked = action

    def setExclusive(self, exclusive):
        """ Set the exclusive state of the action group.

        Parameters
        ----------
        exclusive : bool
            Whether or not the action group is exclusive.

        """
        super(QCustomActionGroup, self).setExclusive(exclusive)
        if exclusive:
            last = self._last_checked
            if last is not None:
                last.setChecked(True)
                for action in self.actions():
                    if action is not last:
                        action.setChecked(False)


class QtActionGroup(QtToolkitObject, ProxyActionGroup):
    """ A Qt implementation of an Enaml ProxyActionGroup.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QCustomActionGroup)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying action group widget.

        """
        self.widget = QCustomActionGroup(self.parent_widget())

    def init_widget(self):
        """ Initialize the control.

        """
        super(QtActionGroup, self).init_widget()
        d = self.declaration
        self.set_exclusive(d.exclusive)
        self.set_enabled(d.enabled)
        self.set_visible(d.visible)

    def init_layout(self):
        """ Initialize the layout for the control.

        """
        super(QtActionGroup, self).init_layout()
        widget = self.widget
        for action in self.actions():
            widget.addAction(action)

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def find_next_action(self, child):
        """ Locate the QAction object which logically follows the child.

        If the given child is last in the list of children, then the
        parent object will be invoked to find the QAction which follows
        this action group.

        Parameters
        ----------
        child : QtToolkitObject
            The child object of interest.

        Returns
        -------
        result : QAction or None
            The QAction which logically follows the position of the
            child in the list of children. None will be returned if
            a relevant QAction is not found.

        """
        found = False
        for dchild in self.children():
            if found and isinstance(dchild, QtAction):
                return dchild.widget
            else:
                found = child is dchild
        parent = self.parent()
        if parent is not None:
            return parent.find_next_action(self)

    def child_added(self, child):
        """ Handle the child added event for a QtActionGroup.

        This handler will also add the widget to the parent widget,
        since a QActionGroup only serves as a management container.

        """
        super(QtActionGroup, self).child_added(child)
        if isinstance(child, QtAction):
            self.widget.addAction(child.widget)
            parent = self.parent()
            if parent is not None:
                before = self.find_next_action(child)
                parent.widget.insertAction(before, child.widget)

    def child_removed(self, child):
        """ Handle the child removed event for a QtActionGroup.

        This handler will also remove the widget to the parent widget,
        since a QActionGroup only serves as a management container.

        """
        super(QtActionGroup, self).child_removed(child)
        if isinstance(child, QtAction) and child.widget is not None:
            self.widget.removeAction(child.widget)
            parent = self.parent()
            if parent is not None:
                parent.widget.removeAction(child.widget)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def actions(self):
        """ Get the QAction children for this action group.

        Returns
        -------
        result : list
            The list of QAction instances which are children of this
            action group. Unlike the list returned by the `actions`
            method of the QActionGroup, the children in this list will
            have the correct order.

        """
        isinst = isinstance
        return [c.widget for c in self.children() if isinst(c, QtAction)]

    #--------------------------------------------------------------------------
    # ProxyActionGroup API
    #--------------------------------------------------------------------------
    def set_exclusive(self, exclusive):
        """ Set the exclusive state of the underlying control.

        """
        self.widget.setExclusive(exclusive)

    def set_enabled(self, enabled):
        """ Set the enabled state of the underlying control.

        """
        self.widget.setEnabled(enabled)

    def set_visible(self, visible):
        """ Set the visible state of the underlying control.

        """
        self.widget.setVisible(visible)

########NEW FILE########
__FILENAME__ = qt_application
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.application import Application, ProxyResolver

from .QtCore import QThread
from .QtGui import QApplication

from .q_deferred_caller import deferredCall, timedCall
from .qt_factories import QT_FACTORIES


class QtApplication(Application):
    """ A Qt implementation of an Enaml application.

    A QtApplication uses the Qt toolkit to implement an Enaml UI that
    runs in the local process.

    """
    #: The private QApplication instance.
    _qapp = Typed(QApplication)

    def __init__(self):
        """ Initialize a QtApplication.

        """
        super(QtApplication, self).__init__()
        self._qapp = QApplication.instance() or QApplication([])
        self.resolver = ProxyResolver(factories=QT_FACTORIES)

    #--------------------------------------------------------------------------
    # Abstract API Implementation
    #--------------------------------------------------------------------------
    def start(self):
        """ Start the application's main event loop.

        """
        app = self._qapp
        if not getattr(app, '_in_event_loop', False):
            app._in_event_loop = True
            app.exec_()
            app._in_event_loop = False

    def stop(self):
        """ Stop the application's main event loop.

        """
        app = self._qapp
        app.exit()
        app._in_event_loop = False

    def deferred_call(self, callback, *args, **kwargs):
        """ Invoke a callable on the next cycle of the main event loop
        thread.

        Parameters
        ----------
        callback : callable
            The callable object to execute at some point in the future.

        *args, **kwargs
            Any additional positional and keyword arguments to pass to
            the callback.

        """
        deferredCall(callback, *args, **kwargs)

    def timed_call(self, ms, callback, *args, **kwargs):
        """ Invoke a callable on the main event loop thread at a
        specified time in the future.

        Parameters
        ----------
        ms : int
            The time to delay, in milliseconds, before executing the
            callable.

        callback : callable
            The callable object to execute at some point in the future.

        *args, **kwargs
            Any additional positional and keyword arguments to pass to
            the callback.

        """
        timedCall(ms, callback, *args, **kwargs)

    def is_main_thread(self):
        """ Indicates whether the caller is on the main gui thread.

        Returns
        -------
        result : bool
            True if called from the main gui thread. False otherwise.

        """
        return QThread.currentThread() == self._qapp.thread()

########NEW FILE########
__FILENAME__ = qt_bounded_date
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Int

from enaml.widgets.bounded_date import ProxyBoundedDate

from .qt_control import QtControl


# cyclic notification guard flags
CHANGED_GUARD = 0x1


class QtBoundedDate(QtControl, ProxyBoundedDate):
    """ A base class for implementing Qt Enaml date widgets.

    """
    #: Cyclic notification guard. This a bitfield of multiple guards.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Implement in a subclass to create the date widget.

        """
        raise NotImplementedError

    def init_widget(self):
        """ Initialize the date widget.

        """
        super(QtBoundedDate, self).init_widget()
        d = self.declaration
        self.set_minimum(d.minimum)
        self.set_maximum(d.maximum)
        self.set_date(d.date)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_date_changed(self):
        """ A signal handler for the date changed signal.

        """
        if not self._guard & CHANGED_GUARD:
            self.declaration.date = self.get_date()

    #--------------------------------------------------------------------------
    # Abstract Methods and ProxyBoundedDate API
    #--------------------------------------------------------------------------
    def get_date(self):
        """ Return the current date in the control.

        Returns
        -------
        result : date
            The current control date as a date object.

        """
        raise NotImplementedError

    def set_minimum(self, date):
        """ Set the widget's minimum date.

        Parameters
        ----------
        date : date
            The date object to use for setting the minimum date.

        """
        raise NotImplementedError

    def set_maximum(self, date):
        """ Set the widget's maximum date.

        Parameters
        ----------
        date : date
            The date object to use for setting the maximum date.

        """
        raise NotImplementedError

    def set_date(self, date):
        """ Set the widget's current date.

        Parameters
        ----------
        date : date
            The date object to use for setting the date.

        """
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = qt_bounded_datetime
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Int

from enaml.widgets.bounded_datetime import ProxyBoundedDatetime

from .qt_control import QtControl


# cyclic notification guard flags
CHANGED_GUARD = 0x1


class QtBoundedDatetime(QtControl, ProxyBoundedDatetime):
    """ A base class for implementing Qt Enaml datetime widgets.

    """
    #: Cyclic notification guard. This a bitfield of multiple guards.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Implement in a subclass to create the datetime widget.

        """
        raise NotImplementedError

    def init_widget(self):
        """ Create and initialize the underlying datetime widget.

        """
        super(QtBoundedDatetime, self).init_widget()
        d = self.declaration
        self.set_minimum(d.minimum)
        self.set_maximum(d.maximum)
        self.set_datetime(d.datetime)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_datetime_changed(self):
        """ A signal handler for the datetime changed signal.

        """
        if not self._guard & CHANGED_GUARD:
            self.declaration.datetime = self.get_datetime()

    #--------------------------------------------------------------------------
    # Abstract Methods and ProxyBoundedDate API
    #--------------------------------------------------------------------------
    def get_datetime(self):
        """ Return the current datetime in the control.

        Returns
        -------
        result : datetime
            The current control datetime as a datetime object.

        """
        raise NotImplementedError

    def set_minimum(self, datetime):
        """ Set the widget's minimum datetime.

        Parameters
        ----------
        datetime : datetime
            The datetime object to use for setting the minimum datetime.

        """
        raise NotImplementedError

    def set_maximum(self, datetime):
        """ Set the widget's maximum datetime.

        Parameters
        ----------
        datetime : datetime
            The datetime object to use for setting the maximum datetime.

        """
        raise NotImplementedError

    def set_datetime(self, datetime):
        """ Set the widget's current datetime.

        Parameters
        ----------
        datetime : datetime
            The datetime object to use for setting the datetime.

        """
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = qt_bounded_time
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Int

from enaml.widgets.bounded_time import ProxyBoundedTime

from .qt_control import QtControl


# cyclic notification guard flags
CHANGED_GUARD = 0x1


class QtBoundedTime(QtControl, ProxyBoundedTime):
    """ A base class for implementing Qt-Enaml time widgets.

    """
    #: Cyclic notification guard. This a bitfield of multiple guards.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Implement in a subclass to create the time widget.

        """
        raise NotImplementedError

    def init_widget(self):
        """ Create and initialize the underlying time widget.

        """
        super(QtBoundedTime, self).init_widget()
        d = self.declaration
        self.set_minimum(d.minimum)
        self.set_maximum(d.maximum)
        self.set_time(d.time)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_time_changed(self):
        """ A signal handler for the time changed signal.

        """
        if not self._guard & CHANGED_GUARD:
            self.declaration.time = self.get_time()

    #--------------------------------------------------------------------------
    # Abstract Methods and ProxyBoundedDate API
    #--------------------------------------------------------------------------
    def get_time(self):
        """ Return the current time in the control.

        Returns
        -------
        result : time
            The current control time as a time object.

        """
        raise NotImplementedError

    def set_minimum(self, time):
        """ Set the widget's minimum time.

        Parameters
        ----------
        time : time
            The time object to use for setting the minimum time.

        """
        raise NotImplementedError

    def set_maximum(self, time):
        """ Set the widget's maximum time.

        Parameters
        ----------
        time : time
            The time object to use for setting the maximum time.

        """
        raise NotImplementedError

    def set_time(self, time):
        """ Set the widget's current time.

        Parameters
        ----------
        time : time
            The time object to use for setting the time.

        """
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = qt_calendar
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.calendar import ProxyCalendar

from .QtGui import QCalendarWidget

from .qt_bounded_date import QtBoundedDate, CHANGED_GUARD


class QtCalendar(QtBoundedDate, ProxyCalendar):
    """ A Qt implementation of an Enaml ProxyCalendar.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QCalendarWidget)

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the calender widget.

        """
        self.widget = QCalendarWidget(self.parent_widget())

    def init_widget(self):
        """ Initialize the widget.

        """
        super(QtCalendar, self).init_widget()
        self.widget.activated.connect(self.on_date_changed)

    #--------------------------------------------------------------------------
    # Abstract API Implementation
    #--------------------------------------------------------------------------
    def get_date(self):
        """ Return the current date in the control.

        Returns
        -------
        result : date
            The current control date as a Python date object.

        """
        return self.widget.selectedDate().toPython()

    def set_minimum(self, date):
        """ Set the widget's minimum date.

        Parameters
        ----------
        date : date
            The date object to use for setting the minimum date.

        """
        self.widget.setMinimumDate(date)

    def set_maximum(self, date):
        """ Set the widget's maximum date.

        Parameters
        ----------
        date : date
            The date object to use for setting the maximum date.

        """
        self.widget.setMaximumDate(date)

    def set_date(self, date):
        """ Set the widget's current date.

        Parameters
        ----------
        date : date
            The date object to use for setting the date.

        """
        self._guard |= CHANGED_GUARD
        try:
            self.widget.setSelectedDate(date)
        finally:
            self._guard &= ~CHANGED_GUARD

########NEW FILE########
__FILENAME__ = qt_check_box
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.check_box import ProxyCheckBox

from .QtGui import QCheckBox

from .qt_abstract_button import QtAbstractButton


class QtCheckBox(QtAbstractButton, ProxyCheckBox):
    """ A Qt implementation of an Enaml ProxyCheckBox.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QCheckBox)

    def create_widget(self):
        """ Create the underlying check box widget.

        """
        self.widget = QCheckBox(self.parent_widget())

########NEW FILE########
__FILENAME__ = qt_color_dialog
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Int, Typed

from enaml.colors import Color
from enaml.widgets.color_dialog import ProxyColorDialog

from .QtCore import Signal
from .QtGui import QColor, QColorDialog

from .qt_toolkit_dialog import QtToolkitDialog


def color_from_qcolor(q):
    """ Convert a QColor into an Enaml Color.

    Parameters
    ----------
    q : QColor
        The Qt color to convert to Enaml Color.

    Returns
    -------
    result : Color or None
        An Enaml Color or None if the QColor is not valid.

    """
    if not q.isValid():
        return None
    return Color(q.red(), q.green(), q.blue(), q.alpha())


# Guard flags
CURRENT_GUARD = 0x1


class QColorDialogEx(QColorDialog):
    """ A custom QColorDialog which emits a custom finished signal.

    """
    #: A signal emitted at the end of the 'done' method. This works
    #: around the standard QColorDialog behavior which emits the
    #: 'colorSelected' signal *after* the 'finished' signal.
    reallyFinished = Signal(int)

    def done(self, result):
        """ A reimplemented done method.

        This method emits the 'reallyFinished' signal on completion.

        """
        super(QColorDialogEx, self).done(result)
        self.reallyFinished.emit(result)


class QtColorDialog(QtToolkitDialog, ProxyColorDialog):
    """ A Qt implementation of an Enaml ProxyColorDialog.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QColorDialogEx)

    #: Cyclic notification guard. This a bitfield of multiple guards.
    _guard = Int(0)

    def create_widget(self):
        """ Create the underlying QColorDialog.

        """
        self.widget = QColorDialogEx(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(QtColorDialog, self).init_widget()
        d = self.declaration
        self.set_current_color(d.current_color)
        self.set_show_alpha(d.show_alpha)
        self.set_show_buttons(d.show_buttons)
        widget = self.widget
        widget.currentColorChanged.connect(self.on_current_color_changed)
        widget.colorSelected.connect(self.on_color_selected)
        # use the custom finished signal instead of the superclass'
        widget.finished.disconnect(self.on_finished)
        widget.reallyFinished.connect(self.on_finished)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def get_default_title(self):
        """ Get the default window title for the color dialog.

        """
        return u'Select Color'

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_current_color_changed(self, qcolor):
        """ Handle the 'currentColorChanged' signal from the widget.

        """
        d = self.declaration
        if d is not None:
            self._guard |= CURRENT_GUARD
            try:
                d.current_color = color_from_qcolor(qcolor)
            finally:
                self._guard &= ~CURRENT_GUARD

    def on_color_selected(self, qcolor):
        """ Handle the 'colorSelected' signal from the widget.

        """
        d = self.declaration
        if d is not None:
            d.selected_color = color_from_qcolor(qcolor)

    #--------------------------------------------------------------------------
    # ProxyColorDialog API
    #--------------------------------------------------------------------------
    @staticmethod
    def custom_count():
        """ Get the number of available custom colors.

        """
        return QColorDialog.customCount()

    @staticmethod
    def custom_color(index):
        """ Get the custom color for the given index.

        """
        qrgb = QColorDialog.customColor(index)
        return color_from_qcolor(QColor.fromRgba(qrgb))

    @staticmethod
    def set_custom_color(index, color):
        """ Set the custom color for the given index.

        """
        QColorDialog.setCustomColor(index, color.argb)

    def set_current_color(self, color):
        """ Set the current color for the underlying widget.

        """
        if not self._guard & CURRENT_GUARD:
            if color is not None:
                qcolor = QColor.fromRgba(color.argb)
            else:
                qcolor = QColor()
            self.widget.setCurrentColor(qcolor)

    def set_show_alpha(self, show):
        """ Set the show alpha option on the underlying widget.

        """
        widget = self.widget
        opt = widget.options()
        if show:
            opt |= QColorDialog.ShowAlphaChannel
        else:
            opt &= ~QColorDialog.ShowAlphaChannel
        widget.setOptions(opt)

    def set_show_buttons(self, show):
        """ Set the show buttons option on the underlying widget.

        """
        widget = self.widget
        opt = widget.options()
        if show:
            opt &= ~QColorDialog.NoButtons
        else:
            opt |= QColorDialog.NoButtons
        widget.setOptions(opt)

########NEW FILE########
__FILENAME__ = qt_combo_box
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Int, Typed

from enaml.widgets.combo_box import ProxyComboBox

from .QtGui import QComboBox

from .qt_control import QtControl


# cyclic notification guard flags
INDEX_GUARD = 0x1


class QtComboBox(QtControl, ProxyComboBox):
    """ A Qt implementation of an Enaml ComboBox.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QComboBox)

    #: Cyclic notification guard. This a bitfield of multiple guards.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the QComboBox widget.

        """
        box = QComboBox(self.parent_widget())
        box.setInsertPolicy(QComboBox.NoInsert)
        self.widget = box

    def init_widget(self):
        """ Create and initialize the underlying widget.

        """
        super(QtComboBox, self).init_widget()
        d = self.declaration
        self.set_items(d.items)
        self.set_index(d.index)
        self.set_editable(d.editable)
        self.widget.currentIndexChanged.connect(self.on_index_changed)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_index_changed(self):
        """ The signal handler for the index changed signal.

        """
        if not self._guard & INDEX_GUARD:
            self.declaration.index = self.widget.currentIndex()

    #--------------------------------------------------------------------------
    # ProxyComboBox API
    #--------------------------------------------------------------------------
    def set_items(self, items):
        """ Set the items of the ComboBox.

        """
        widget = self.widget
        count = widget.count()
        nitems = len(items)
        for idx, item in enumerate(items[:count]):
            widget.setItemText(idx, item)
        if nitems > count:
            for item in items[count:]:
                widget.addItem(item)
        elif nitems < count:
            for idx in reversed(xrange(nitems, count)):
                widget.removeItem(idx)

    def set_index(self, index):
        """ Set the current index of the ComboBox.

        """
        self._guard |= INDEX_GUARD
        try:
            self.widget.setCurrentIndex(index)
        finally:
            self._guard &= ~INDEX_GUARD

    def set_editable(self, editable):
        """ Set whether the combo box is editable.

        """
        # The update is needed to avoid artificats (at least on Windows)
        widget = self.widget
        widget.setEditable(editable)
        widget.update()

########NEW FILE########
__FILENAME__ = qt_constraints_widget
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from contextlib import contextmanager

from atom.api import Int, ForwardTyped

from enaml.widgets.constraints_widget import ProxyConstraintsWidget

from .qt_widget import QtWidget


# keep around for backwards compatibility
def size_hint_guard(obj):
    return obj.geometry_guard()


def QtContainer():
    from .qt_container import QtContainer
    return QtContainer


class QtConstraintsWidget(QtWidget, ProxyConstraintsWidget):
    """ A Qt implementation of an Enaml ProxyConstraintsWidget.

    """
    #: The container which manages the layout for this widget. This
    #: is assigned during the layout building pass.
    layout_container = ForwardTyped(QtContainer)

    #: The layout index for this widget's layout item. This is assigned
    #: during the layout building pass.
    layout_index = Int()

    def destroy(self):
        """ A reimplemented destructor.

        This destructor drops the reference to the layout container.

        """
        del self.layout_container
        super(QtConstraintsWidget, self).destroy()

    #--------------------------------------------------------------------------
    # ProxyConstraintsWidget API
    #--------------------------------------------------------------------------
    def request_relayout(self):
        """ Request a relayout of the proxy widget.

        This method forwards the request to the layout container.

        """
        container = self.layout_container
        if container is not None:
            container.request_relayout()

    def restyle(self):
        """ Restyle the widget with the current style data.

        This reimplementation restyles from within a geometry guard.

        """
        with self.geometry_guard():
            super(QtConstraintsWidget, self).restyle()

    #--------------------------------------------------------------------------
    # Layout API
    #--------------------------------------------------------------------------
    def geometry_updated(self):
        """ Notify the layout system that the geometry has changed.

        This method forwards the update to the layout container.

        """
        container = self.layout_container
        if container is not None:
            container.geometry_updated(self)

    @contextmanager
    def geometry_guard(self):
        """ A context manager for guarding the geometry of the widget.

        If the proxy is fully active, this context manager will call the
        'geometry_updated' method if the size hint, minimum, or maximum
        size of the widget changes during context execution.

        """
        if not self.is_active:
            yield
            return
        widget = self.widget
        old_hint = widget.sizeHint()
        old_min = widget.minimumSize()
        old_max = widget.maximumSize()
        yield
        if (old_hint != widget.sizeHint() or
            old_min != widget.minimumSize() or
            old_max != widget.maximumSize()):
            self.geometry_updated()

    #--------------------------------------------------------------------------
    # Reimplementations
    #--------------------------------------------------------------------------
    def set_font(self, font):
        """ A reimplemented font setter.

        This method sets the font from within a geometry guard.

        """
        with self.geometry_guard():
            super(QtConstraintsWidget, self).set_font(font)

########NEW FILE########
__FILENAME__ = qt_container
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from collections import deque
from contextlib import contextmanager

from atom.api import Atom, Callable, Float, Typed

from enaml.layout.layout_manager import LayoutItem, LayoutManager
from enaml.widgets.constraints_widget import ConstraintsWidget
from enaml.widgets.container import ProxyContainer

from .QtCore import QRect, QSize, QTimer, Signal
from .QtGui import QFrame, QWidgetItem, QSizePolicy

from .qt_constraints_widget import QtConstraintsWidget
from .qt_frame import QtFrame


# Commonly used default sizes
DEFAULT_BEST_SIZE = QSize(-1, -1)
DEFAULT_MIN_SIZE = QSize(0, 0)
DEFAULT_MAX_SIZE = QSize(16777215, 16777215)

# The size policy to apply to containers. This allows the container
# to behave properly when added to standard Qt layouts and widgets.
CONTAINER_POLICY = QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)


class LayoutPoint(Atom):
    """ A class which represents a point in layout space.

    """
    #: The x-coordinate of the point.
    x = Float(0.0)

    #: The y-coordinate of the point.
    y = Float(0.0)


class QtLayoutItem(LayoutItem):
    """ A concrete LayoutItem implementation for a QtConstraintsWidget.

    """
    #: The constraints widget declaration object for the layout item.
    declaration = Typed(ConstraintsWidget)

    #: The widget item used for laying out the underlying widget.
    widget_item = Typed(QWidgetItem)

    #: The layout point which represents the offset of the parent item
    #: from the origin of the root item.
    offset = Typed(LayoutPoint)

    #: The layout point which represents the offset of this item from
    #: the offset of the root item.
    origin = Typed(LayoutPoint)

    def constrainable(self):
        """ Get a reference to the underlying constrainable object.

        Returns
        -------
        result : Constrainable
            An object which implements the Constrainable interface.

        """
        return self.declaration

    def margins(self):
        """ Get the margins for the underlying widget.

        Returns
        -------
        result : tuple
            An empty tuple as constraints widgets do not have margins.

        """
        return ()

    def size_hint(self):
        """ Get the size hint for the underlying widget.

        Returns
        -------
        result : tuple
            A 2-tuple of numbers representing the (width, height)
            size hint of the widget.

        """
        hint = self.widget_item.sizeHint()
        return (hint.width(), hint.height())

    def min_size(self):
        """ Get the minimum size for the underlying widget.

        Returns
        -------
        result : tuple
            A 2-tuple of numbers representing the (width, height)
            min size of the widget. If any value is less than zero,
            constraints will not be generated for that dimension.

        """
        min_size = self.widget_item.widget().minimumSize()
        if min_size != DEFAULT_MIN_SIZE:
            return (min_size.width(), min_size.height())
        return (-1, -1)

    def max_size(self):
        """ Get the maximum size for the underlying widget.

        Returns
        -------
        result : tuple
            A 2-tuple of numbers representing the (width, height)
            max size of the widget. If any value is less than zero,
            constraints will not be generated for that dimension.

        """
        max_size = self.widget_item.widget().maximumSize()
        if max_size != DEFAULT_MAX_SIZE:
            return (max_size.width(), max_size.height())
        return (-1, -1)

    def constraints(self):
        """ Get the user-defined constraints for the item.

        Returns
        -------
        result : list
            The list of user-defined constraints.

        """
        return self.declaration.layout_constraints()

    def set_geometry(self, x, y, width, height):
        """ Set the geometry of the underlying widget.

        Parameters
        ----------
        x : float
            The new value for the x-origin of the widget.

        y : float
            The new value for the y-origin of the widget.

        width : float
            The new value for the width of the widget.

        height : float
            The new value for the height of the widget.

        """
        origin = self.origin
        origin.x = x
        origin.y = y
        offset = self.offset
        x -= offset.x
        y -= offset.y
        self.widget_item.setGeometry(QRect(x, y, width, height))


class QtContainerItem(QtLayoutItem):
    """ A QtLayoutItem subclass which handles container margins.

    """
    #: A callable used to get the container widget margins.
    margins_func = Callable()

    def margins(self):
        """ Get the margins for the underlying widget.

        Returns
        -------
        result : tuple
            A 4-tuple of ints representing the container margins.

        """
        a, b, c, d = self.declaration.padding
        e, f, g, h = self.margins_func(self.widget_item)
        return (a + e, b + f, c + g, d + h)


class QtSharedContainerItem(QtContainerItem):
    """ A QtContainerItem subclass which works for shared containers.

    """
    def size_hint_constraints(self):
        """ Get the size hint constraints for the item.

        A shared container does not generate size hint constraints.

        """
        return []


class QtChildContainerItem(QtLayoutItem):
    """ A QtLayoutItem subclass which works for child containers.

    """
    def constraints(self):
        """ Get the user constraints for the item.

        A child container does not expose its user defined constraints
        to the parent container.

        """
        return []

    def min_size(self):
        """ Get the minimum size for the underlying widget.

        The min size for a child container lives on the proxy object.
        The QWidgetItem limits must be bypassed for child container.

        """
        min_size = self.declaration.proxy.min_size
        if min_size != DEFAULT_MIN_SIZE:
            return (min_size.width(), min_size.height())
        return (-1, -1)

    def max_size(self):
        """ Get the maximum size for the underlying widget.

        The max size for a child container lives on the proxy object.
        The QWidgetItem limits must be bypassed for child container.

        """
        max_size = self.declaration.proxy.max_size
        if max_size != DEFAULT_MAX_SIZE:
            return (max_size.width(), max_size.height())
        return (-1, -1)


class QContainer(QFrame):
    """ A subclass of QFrame which behaves as a container.

    """
    #: A signal which is emitted on a resize event.
    resized = Signal()

    #: The internally cached size hint.
    _size_hint = QSize()

    def resizeEvent(self, event):
        """ Converts a resize event into a signal.

        """
        super(QContainer, self).resizeEvent(event)
        self.resized.emit()

    def sizeHint(self):
        """ Returns the previously set size hint. If that size hint is
        invalid, the superclass' sizeHint will be used.

        """
        hint = self._size_hint
        if not hint.isValid():
            hint = super(QContainer, self).sizeHint()
        return QSize(hint)

    def setSizeHint(self, hint):
        """ Sets the size hint to use for this widget.

        """
        self._size_hint = QSize(hint)

    def minimumSizeHint(self):
        """ Returns the minimum size hint for the widget.

        For a QContainer, the minimum size hint is equivalent to the
        minimum size as computed by the layout manager.

        """
        return self.minimumSize()


class QtContainer(QtFrame, ProxyContainer):
    """ A Qt implementation of an Enaml ProxyContainer.

    """
    #: A reference to the toolkit widget created by the proxy.
    widget = Typed(QContainer)

    #: The minimum size of the container as computed by the layout
    #: manager. This will be updated on every relayout pass and is
    #: used by the QtChildContainerItem to generate size constraints.
    min_size = Typed(QSize)

    #: The maximum size of the container as computed by the layout
    #: manager. This will be updated on every relayout pass and is
    #: used by the QtChildContainerItem to generate size constraints.
    max_size = Typed(QSize)

    #: A timer used to collapse relayout requests. The timer is created
    #: on an as needed basis and destroyed when it is no longer needed.
    _layout_timer = Typed(QTimer)

    #: The layout manager which handles the system of constraints.
    _layout_manager = Typed(LayoutManager)

    def destroy(self):
        """ A reimplemented destructor.

        This destructor clears the layout timer and layout manager
        so that any potential reference cycles are broken.

        """
        del self._layout_timer
        del self._layout_manager
        super(QtContainer, self).destroy()

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Creates the QContainer widget.

        """
        widget = QContainer(self.parent_widget())
        widget.setSizePolicy(CONTAINER_POLICY)
        self.widget = widget

    def init_layout(self):
        """ Initialize the layout of the widget.

        """
        super(QtContainer, self).init_layout()
        self._setup_manager()
        self._update_size_bounds()
        self._update_geometries()
        self.widget.resized.connect(self._update_geometries)

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event.

        This handler will reparent the child if necessary.

        """
        super(QtContainer, self).child_added(child)
        cw = child.widget
        if cw is not None and cw.parent() != self.widget:
            cw.setParent(self.widget)

    #--------------------------------------------------------------------------
    # Layout API
    #--------------------------------------------------------------------------
    def request_relayout(self):
        """ Request a relayout of the container.

        """
        # If this container owns the layout, (re)start the timer. The
        # list of layout items is cleared to prevent an edge case where
        # a parent container layout occurs before the child container,
        # causing the child to resize potentially deleted widgets which
        # still have strong refs in the layout items list.
        manager = self._layout_manager
        if manager is not None:
            if self._layout_timer is None:
                manager.clear_items()
                self.widget.setUpdatesEnabled(False)
                timer = self._layout_timer = QTimer()
                timer.setSingleShot(True)
                timer.timeout.connect(self._on_relayout_timer)
            self._layout_timer.start()
            return

        # If an ancestor container owns the layout, proxy the call.
        container = self.layout_container
        if container is not None:
            container.request_relayout()

    def geometry_updated(self, item=None):
        """ Notify the layout system that the geometry has changed.

        Parameters
        ----------
        item : QtConstraintsWidget, optional
            The constraints widget with the updated geometry. If this
            is None, it indicates that this container's geometry is
            the one which has changed.

        """
        # If this container's geometry has changed and it has an ancestor
        # layout container, notify that container since it cares about
        # this container's geometry. If the layout for this container is
        # shared, the layout item will take care of supplying the proper
        # list geometry constraints.
        container = self.layout_container
        if item is None:
            if container is not None:
                container.geometry_updated(self)
            return

        # If this container owns its layout, update the manager unless
        # a relayout is pending. A pending relayout means the manager
        # has already been reset and the layout indices are invalid.
        manager = self._layout_manager
        if manager is not None:
            if self._layout_timer is None:
                with self.geometry_guard():
                    manager.update_geometry(item.layout_index)
                    self._update_size_bounds()
                    self._update_geometries()
            return

        # If an ancestor container owns the layout, proxy the call.
        if container is not None:
            container.geometry_updated(item)

    @contextmanager
    def geometry_guard(self):
        """ A context manager for guarding the geometry of the widget.

        This is a reimplementation of the superclass method which uses
        the internally computed min and max size of the container.

        """
        old_hint = self.widget.sizeHint()
        old_min = self.min_size
        old_max = self.max_size
        yield
        if (old_hint != self.widget.sizeHint() or
            old_min != self.min_size or
            old_max != self.max_size):
            self.geometry_updated()

    @staticmethod
    def margins_func(widget_item):
        """ Get the margins for the given widget item.

        The container margins are added to the user provided padding
        to determine the final offset from a layout box boundary to
        the corresponding content line. The default container margins
        are zero. This method can be reimplemented by subclasses to
        supply different margins.

        Returns
        -------
        result : tuple
            A 4-tuple of margins (top, right, bottom, left).

        """
        return (0, 0, 0, 0)

    def margins_updated(self, item=None):
        """ Notify the layout system that the margins have changed.

        Parameters
        ----------
        item : QtContainer, optional
            The container widget with the updated margins. If this is
            None, it indicates that this container's margins are the
            ones which have changed.

        """
        # If this container owns its layout, update the manager unless
        # a relayout is pending. A pending relayout means the manager
        # has already been reset and the layout indices are invalid.
        manager = self._layout_manager
        if manager is not None:
            if self._layout_timer is None:
                index = item.layout_index if item else -1
                with self.geometry_guard():
                    manager.update_margins(index)
                    self._update_size_bounds()
                    self._update_geometries()
            return

        # If an ancestor container owns the layout, forward the call.
        container = self.layout_container
        if container is not None:
            container.margins_updated(item or self)

    #--------------------------------------------------------------------------
    # Private Signal Handlers
    #--------------------------------------------------------------------------
    def _on_relayout_timer(self):
        """ Rebuild the layout for the container.

        This method is invoked when the relayout timer is triggered. It
        will reset the manager and update the geometries of the children.

        """
        del self._layout_timer
        with self.geometry_guard():
            self._setup_manager()
            self._update_size_bounds()
            self._update_geometries()
        self.widget.setUpdatesEnabled(True)

    #--------------------------------------------------------------------------
    # Private Layout Handling
    #--------------------------------------------------------------------------
    def _setup_manager(self):
        """ Setup the layout manager.

        This method will create or reset the layout manager and update
        it with a new layout table.

        """
        # Layout ownership can only be transferred *after* the init
        # layout method is called, as layout occurs bottom up. The
        # manager is only created if ownership is unlikely to change.
        share_layout = self.declaration.share_layout
        if share_layout and isinstance(self.parent(), QtContainer):
            del self._layout_timer
            del self._layout_manager
            return

        manager = self._layout_manager
        if manager is None:
            item = QtContainerItem()
            item.declaration = self.declaration
            item.widget_item = QWidgetItem(self.widget)
            item.origin = LayoutPoint()
            item.offset = LayoutPoint()
            item.margins_func = self.margins_func
            manager = self._layout_manager = LayoutManager(item)
        manager.set_items(self._create_layout_items())

    def _update_geometries(self):
        """ Update the geometries of the layout children.

        This method will resize the layout manager to the container size.

        """
        manager = self._layout_manager
        if manager is not None:
            widget = self.widget
            manager.resize(widget.width(), widget.height())

    def _update_size_bounds(self):
        """ Update the sizes of the underlying container.

        This method will update the min, max, and best size of the
        container. It will not automatically trigger a geometry
        notification.

        """
        widget = self.widget
        manager = self._layout_manager
        if manager is None:
            best_size = DEFAULT_BEST_SIZE
            min_size = DEFAULT_MIN_SIZE
            max_size = DEFAULT_MAX_SIZE
        else:
            best_size = QSize(*manager.best_size())
            min_size = QSize(*manager.min_size())
            max_size = QSize(*manager.max_size())

        # Store the computed min and max size, which is used by the
        # QtChildContainerItem to provide min and max size constraints.
        self.min_size = min_size
        self.max_size = max_size

        # If this is a child container, min and max size are not applied
        # to the widget since the ancestor manager must be the ultimate
        # authority on layout size, not QWidgetItem.
        widget.setSizeHint(best_size)
        if isinstance(self.parent(), QtContainer):
            widget.setMinimumSize(DEFAULT_MIN_SIZE)
            widget.setMaximumSize(DEFAULT_MAX_SIZE)
        else:
            widget.setMinimumSize(min_size)
            widget.setMaximumSize(max_size)

    def _create_layout_items(self):
        """ Create a layout items for the container decendants.

        The layout items are created by traversing the decendants in
        breadth-first order and setting up a LayoutItem object for
        each decendant. The layout item is populated with an offset
        point which represents the offset of the widgets parent to
        the origin of the widget which owns the layout solver. This
        point is substracted from the solved origin of the widget.

        Returns
        -------
        result : list
            A list of LayoutItem objects which represent the flat
            layout traversal.

        """
        layout_items = []
        offset = LayoutPoint()
        queue = deque((offset, child) for child in self.children())
        while queue:
            offset, child = queue.popleft()
            if isinstance(child, QtConstraintsWidget):
                child.layout_container = self
                origin = LayoutPoint()
                if isinstance(child, QtContainer):
                    if child.declaration.share_layout:
                        item = QtSharedContainerItem()
                        item.margins_func = child.margins_func
                        for subchild in child.children():
                            queue.append((origin, subchild))
                    else:
                        item = QtChildContainerItem()
                else:
                    item = QtLayoutItem()
                item.declaration = child.declaration
                item.widget_item = QWidgetItem(child.widget)
                item.offset = offset
                item.origin = origin
                child.layout_index = len(layout_items)
                layout_items.append(item)
        return layout_items

########NEW FILE########
__FILENAME__ = qt_control
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from enaml.widgets.control import ProxyControl

from .qt_constraints_widget import QtConstraintsWidget


class QtControl(QtConstraintsWidget, ProxyControl):
    """ A Qt implementation of an Enaml Control.

    """
    # The QtConstraintsWidget superclass is a sufficient implementation.
    pass

########NEW FILE########
__FILENAME__ = qt_datetime_selector
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.datetime_selector import ProxyDatetimeSelector

from .QtGui import QDateTimeEdit

from .qt_bounded_datetime import QtBoundedDatetime, CHANGED_GUARD


class QtDatetimeSelector(QtBoundedDatetime, ProxyDatetimeSelector):
    """ A Qt implementation of an Enaml ProxyDatetimeSelector.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QDateTimeEdit)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the QDateTimeEdit widget.

        """
        self.widget = QDateTimeEdit(self.parent_widget())

    def init_widget(self):
        """ Initialize the widget.

        """
        super(QtDatetimeSelector, self).init_widget()
        d = self.declaration
        self.set_datetime_format(d.datetime_format)
        self.set_calendar_popup(d.calendar_popup)
        self.widget.dateTimeChanged.connect(self.on_datetime_changed)

    #--------------------------------------------------------------------------
    # Abstract API Implementation
    #--------------------------------------------------------------------------
    def get_datetime(self):
        """ Return the current datetime in the control.

        Returns
        -------
        result : datetime
            The current control datetime as a datetime object.

        """
        return self.widget.dateTime().toPython()

    def set_minimum(self, datetime):
        """ Set the widget's minimum datetime.

        Parameters
        ----------
        datetime : datetime
            The datetime object to use for setting the minimum datetime.

        """
        self.widget.setMinimumDateTime(datetime)

    def set_maximum(self, datetime):
        """ Set the widget's maximum datetime.

        Parameters
        ----------
        datetime : datetime
            The datetime object to use for setting the maximum datetime.

        """
        self.widget.setMaximumDateTime(datetime)

    def set_datetime(self, datetime):
        """ Set the widget's current datetime.

        Parameters
        ----------
        datetime : datetime
            The datetime object to use for setting the datetime.

        """
        self._guard |= CHANGED_GUARD
        try:
            self.widget.setDateTime(datetime)
        finally:
            self._guard &= ~CHANGED_GUARD

    def set_datetime_format(self, format):
        """ Set the widget's datetime format.

        Parameters
        ----------
        format : string
            A Python time formatting string.

        """
        # XXX make sure Python's and Qt's format strings are the
        # same, or convert between the two.
        self.widget.setDisplayFormat(format)

    def set_calendar_popup(self, popup):
        """ Set whether a calendar popup is available on the widget.

        Parameters
        ----------
        popup : bool
            Whether the calendar popup is enabled.

        """
        self.widget.setCalendarPopup(popup)

########NEW FILE########
__FILENAME__ = qt_date_selector
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.date_selector import ProxyDateSelector

from .QtGui import QDateEdit

from .qt_bounded_date import QtBoundedDate, CHANGED_GUARD


class QtDateSelector(QtBoundedDate, ProxyDateSelector):
    """ A Qt implementation of an Enaml ProxyDateSelector.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QDateEdit)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the QDateEdit widget.

        """
        self.widget = QDateEdit(self.parent_widget())

    def init_widget(self):
        """ Initialize the widget.

        """
        super(QtDateSelector, self).init_widget()
        d = self.declaration
        self.set_date_format(d.date_format)
        self.set_calendar_popup(d.calendar_popup)
        self.widget.dateChanged.connect(self.on_date_changed)

    #--------------------------------------------------------------------------
    # Abstract API Implementation
    #--------------------------------------------------------------------------
    def get_date(self):
        """ Return the current date in the control.

        Returns
        -------
        result : date
            The current control date as a date object.

        """
        return self.widget.date().toPython()

    def set_minimum(self, date):
        """ Set the widget's minimum date.

        Parameters
        ----------
        date : date
            The date object to use for setting the minimum date.

        """
        self.widget.setMinimumDate(date)

    def set_maximum(self, date):
        """ Set the widget's maximum date.

        Parameters
        ----------
        date : date
            The date object to use for setting the maximum date.

        """
        self.widget.setMaximumDate(date)

    def set_date(self, date):
        """ Set the widget's current date.

        Parameters
        ----------
        date : date
            The date object to use for setting the date.

        """
        self._guard |= CHANGED_GUARD
        try:
            self.widget.setDate(date)
        finally:
            self._guard &= ~CHANGED_GUARD

    def set_date_format(self, format):
        """ Set the widget's date format.

        Parameters
        ----------
        format : string
            A Python time formatting string.

        """
        # XXX make sure Python's and Qt's format strings are the
        # same, or convert between the two.
        self.widget.setDisplayFormat(format)

    def set_calendar_popup(self, popup):
        """ Set whether a calendar popup is available on the widget.

        Parameters
        ----------
        popup : bool
            Whether the calendar popup is enabled.

        """
        self.widget.setCalendarPopup(popup)

########NEW FILE########
__FILENAME__ = qt_dialog
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed, atomref

from enaml.widgets.dialog import ProxyDialog
from enaml.widgets.window import CloseEvent

from .QtCore import Qt
from .QtGui import QDialog

from .q_deferred_caller import deferredCall
from .q_window_base import QWindowBase
from .qt_window import QtWindow, finalize_close


class QWindowDialog(QDialog, QWindowBase):
    """ A window base subclass which implements dialog behavior.

    """
    def __init__(self, proxy, parent=None, flags=Qt.Widget):
        """ Initialize a QWindowDialog.

        Parameters
        ----------
        proxy : QtDialog
            The proxy object which owns this dialog. Only an atomref
            will be maintained to this object.

        parent : QWidget, optional
            The parent of the dialog.

        flags : Qt.WindowFlags, optional
            The window flags to pass to the parent constructor.

        """
        super(QWindowDialog, self).__init__(parent, flags)
        self._proxy_ref = atomref(proxy)

    def closeEvent(self, event):
        """ Handle the close event for the dialog.

        """
        event.accept()
        if not self._proxy_ref:
            return
        proxy = self._proxy_ref()
        d = proxy.declaration
        d_event = CloseEvent()
        d.closing(d_event)
        if d_event.is_accepted():
            super(QWindowDialog, self).closeEvent(event)
        else:
            event.ignore()


class QtDialog(QtWindow, ProxyDialog):
    """ A Qt implementation of an Enaml ProxyDialog.

    """
    widget = Typed(QWindowDialog)

    def create_widget(self):
        """ Create the underlying QFileDialog widget.

        """
        flags = self.creation_flags()
        self.widget = QWindowDialog(self, self.parent_widget(), flags)

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(QtDialog, self).init_widget()
        self.widget.finished.connect(self.on_finished)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_finished(self):
        """ Handle the 'finished' signal on the dialog.

        """
        result = bool(self.widget.result())
        d = self.declaration
        d.result = result
        d.finished(result)
        if result:
            d.accepted()
        else:
            d.rejected()
        deferredCall(finalize_close, d)

    #--------------------------------------------------------------------------
    # ProxyDialog API
    #--------------------------------------------------------------------------
    def exec_(self):
        """ Launch the dialog as a modal window.

        """
        return bool(self.widget.exec_())

    def done(self, result):
        """ Close the dialog and set the result code.

        """
        q_result = QDialog.Accepted if result else QDialog.Rejected
        self.widget.done(q_result)

########NEW FILE########
__FILENAME__ = qt_dock_area
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.styling import StyleCache
from enaml.widgets.dock_area import ProxyDockArea
from enaml.widgets.dock_events import DockItemEvent

from .QtCore import QObject, QEvent, QSize, QTimer
from .QtGui import QTabWidget

from .docking.dock_manager import DockManager
from .docking.event_types import (
    DockItemDocked, DockItemUndocked, DockItemExtended, DockItemRetracted,
    DockItemShown, DockItemHidden, DockItemClosed, DockTabSelected
)
from .docking.q_dock_area import QDockArea
from .docking.style_sheets import get_style_sheet

from .qt_constraints_widget import QtConstraintsWidget
from .qt_dock_item import QtDockItem
from .styleutil import translate_dock_area_style


TAB_POSITIONS = {
    'top': QTabWidget.North,
    'bottom': QTabWidget.South,
    'left': QTabWidget.West,
    'right': QTabWidget.East,
}


EVENT_TYPES = {
    DockItemDocked: DockItemEvent.Docked,
    DockItemUndocked: DockItemEvent.Undocked,
    DockItemExtended: DockItemEvent.Extended,
    DockItemRetracted: DockItemEvent.Retracted,
    DockItemShown: DockItemEvent.Shown,
    DockItemHidden: DockItemEvent.Hidden,
    DockItemClosed: DockItemEvent.Closed,
    DockTabSelected: DockItemEvent.TabSelected,
}


class DockLayoutFilter(QObject):
    """ An event filter used by the QtDockArea.

    This event filter listens for LayoutRequest events on the dock
    area widget, and will send a geometry_updated notification to
    the constraints system when the dock area size hint changes. The
    notifications are collapsed on a single shot timer so that the
    dock area geometry can fully settle before being snapped by the
    constraints layout engine.

    """
    def __init__(self, owner):
        super(DockLayoutFilter, self).__init__()
        self._owner = owner
        self._size_hint = QSize()
        self._pending = False
        self._timer = timer = QTimer()
        timer.setSingleShot(True)
        timer.timeout.connect(self.onNotify)

    def onNotify(self):
        self._owner.geometry_updated()
        self._pending = False

    def eventFilter(self, obj, event):
        if not self._pending and event.type() == QEvent.LayoutRequest:
            hint = obj.sizeHint()
            if hint != self._size_hint:
                self._size_hint = hint
                self._timer.start(0)
                self._pending = True
        return False


class DockEventFilter(QObject):
    """ An event filter used by the QtDockArea.

    This event filter listens for dock events on the dock area widget,
    converts them to front-end events, and posts them to the front-end
    declaration object.

    """
    def __init__(self, owner):
        super(DockEventFilter, self).__init__()
        self._owner = owner

    def eventFilter(self, obj, event):
        e_type = EVENT_TYPES.get(event.type())
        if e_type is not None:
            d = self._owner.declaration
            if d is not None:
                d.dock_event(DockItemEvent(type=e_type, name=event.name()))
        return False


class QtDockArea(QtConstraintsWidget, ProxyDockArea):
    """ A Qt implementation of an Enaml DockArea.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QDockArea)

    #: The docking manager which will drive the dock area.
    manager = Typed(DockManager)

    #: The event filter which listens for layout requests.
    dock_layout_filter = Typed(DockLayoutFilter)

    #: The event filter which listens for dock events.
    dock_event_filter = Typed(DockEventFilter)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying QDockArea widget.

        """
        self.widget = QDockArea(self.parent_widget())
        self.manager = DockManager(self.widget)
        self.dock_event_filter = DockEventFilter(self)
        self.dock_layout_filter = DockLayoutFilter(self)

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(QtDockArea, self).init_widget()
        d = self.declaration
        self.set_tab_position(d.tab_position)
        self.set_live_drag(d.live_drag)
        if d.style:  # TODO remove this in Enaml 1.0
            self.set_style(d.style)
        self.set_dock_events_enabled(d.dock_events_enabled)

    def init_layout(self):
        """ Initialize the layout of the underlying control.

        """
        super(QtDockArea, self).init_layout()
        manager = self.manager
        for item in self.dock_items():
            manager.add_item(item)
        d = self.declaration
        self.apply_layout(d.layout)
        self.widget.installEventFilter(self.dock_layout_filter)

    def destroy(self):
        """ A reimplemented destructor.

        This removes the event filter from the dock area and releases
        the items from the dock manager.

        """
        self.widget.removeEventFilter(self.dock_layout_filter)
        self.widget.removeEventFilter(self.dock_event_filter)
        del self.dock_layout_filter
        del self.dock_event_filter
        self.manager.destroy()
        super(QtDockArea, self).destroy()

    #--------------------------------------------------------------------------
    # Overrides
    #--------------------------------------------------------------------------
    def refresh_style_sheet(self):
        """ A reimplemented styling method.

        The dock area uses custom stylesheet processing.

        """
        # workaround win-7 sizing bug
        parts = [u'QDockTabWidget::pane {}']
        name = self.widget.objectName()
        for style in StyleCache.styles(self.declaration):
            t = translate_dock_area_style(name, style)
            if t:
                parts.append(t)
        if len(parts) > 1:
            stylesheet = u'\n\n'.join(parts)
        else:
            stylesheet = u''
        self.widget.setStyleSheet(stylesheet)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def dock_items(self):
        """ Get an iterable of QDockItem children for this area.

        """
        for d in self.declaration.dock_items():
            w = d.proxy.widget
            if w is not None:
                yield w

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a QtDockArea.

        """
        super(QtDockArea, self).child_added(child)
        if isinstance(child, QtDockItem):
            w = child.widget
            if w is not None:
                self.manager.add_item(w)

    def child_removed(self, child):
        """ Handle the child removed event for a QtDockArea.

        """
        super(QtDockArea, self).child_removed(child)
        if isinstance(child, QtDockItem):
            w = child.widget
            if w is not None:
                self.manager.remove_item(w)

    #--------------------------------------------------------------------------
    # ProxyDockArea API
    #--------------------------------------------------------------------------
    def set_tab_position(self, position):
        """ Set the default tab position on the underyling widget.

        """
        self.widget.setTabPosition(TAB_POSITIONS[position])

    def set_live_drag(self, live_drag):
        """ Set the live drag state for the underlying widget.

        """
        self.widget.setOpaqueItemResize(live_drag)

    def set_style(self, style):
        """ Set the style for the underlying widget.

        """
        # If get_style_sheet returns something, it means the user will
        # have already called register_style_sheet, which will raise
        # a deprecation warning. TODO remove this method in Enaml 1.0.
        sheet = get_style_sheet(style)
        if sheet:
            self.widget.setStyleSheet(sheet)

    def set_dock_events_enabled(self, enabled):
        """ Set whether or not dock events are enabled for the area.

        """
        widget = self.widget
        widget.setDockEventsEnabled(enabled)
        if enabled:
            widget.installEventFilter(self.dock_event_filter)
        else:
            widget.removeEventFilter(self.dock_event_filter)

    def save_layout(self):
        """ Save the current layout on the underlying widget.

        """
        return self.manager.save_layout()

    def apply_layout(self, layout):
        """ Apply a new layout to the underlying widget.

        """
        self.manager.apply_layout(layout)

    def update_layout(self, ops):
        """ Update the layout from a list of layout operations.

        """
        self.manager.update_layout(ops)

########NEW FILE########
__FILENAME__ = qt_dock_item
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Int, Typed

from enaml.styling import StyleCache
from enaml.widgets.dock_item import ProxyDockItem

from .QtCore import Qt, QSize, Signal
from .QtGui import QIcon

from .docking.q_dock_item import QDockItem

from .q_resource_helpers import get_cached_qicon
from .qt_widget import QtWidget
from .styleutil import translate_dock_item_style


class QCustomDockItem(QDockItem):
    """ A custom dock item which converts a close event into a signal.

    """
    #: A signal emitted if the close event is accepted. It it emitted
    #: before the close event handler returns.
    closed = Signal()

    def closeEvent(self, event):
        """ Handle the close event for the dock item.

        """
        super(QCustomDockItem, self).closeEvent(event)
        if event.isAccepted():
            self.closed.emit()


# Guard flags
TITLE_GUARD = 0x1


class QtDockItem(QtWidget, ProxyDockItem):
    """ A Qt implementation of an Enaml ProxyDockItem.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QCustomDockItem)

    #: Cyclic notification guard. This a bitfield of multiple guards.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying QDockItem widget.

        """
        self.widget = QCustomDockItem(self.parent_widget())

    def init_widget(self):
        """ Initialize the state of the underlying widget.

        """
        super(QtDockItem, self).init_widget()
        d = self.declaration
        self.set_title(d.title)
        self.set_title_editable(d.title_editable)
        if not d.title_bar_visible:
            self.set_title_bar_visible(d.title_bar_visible)
        if d.icon is not None:
            self.set_icon(d.icon)
        if -1 not in d.icon_size:
            self.set_icon_size(d.icon_size)
        self.set_stretch(d.stretch)
        self.set_closable(d.closable)

    def init_layout(self):
        """ Initialize the layout for the underyling widget.

        """
        super(QtDockItem, self).init_layout()
        widget = self.widget
        widget.setDockWidget(self.dock_widget())
        # Use a queued connection so the dock manager can finish
        # closing the dock item before the signal handler runs.
        widget.titleEdited.connect(self.on_title_edited)
        widget.titleBarRightClicked.connect(self.on_title_bar_right_clicked)
        widget.closed.connect(self.on_closed, Qt.QueuedConnection)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def dock_widget(self):
        """ Find and return the dock widget child for this widget.

        """
        d = self.declaration.dock_widget()
        if d is not None:
            return d.proxy.widget

    #--------------------------------------------------------------------------
    # Reimplementations
    #--------------------------------------------------------------------------
    def refresh_style_sheet(self):
        """ A reimplemented styling method.

        The dock item uses custom stylesheet processing.

        """
        parts = []
        name = self.widget.objectName()
        for style in StyleCache.styles(self.declaration):
            t = translate_dock_item_style(name, style)
            if t:
                parts.append(t)
        if len(parts) > 0:
            stylesheet = u'\n\n'.join(parts)
        else:
            stylesheet = u''
        self.widget.setStyleSheet(stylesheet)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_title_edited(self, text):
        """ Handle the 'titleEdited' signal on the dock item.

        """
        d = self.declaration
        if d is not None:
            self._guard |= TITLE_GUARD
            try:
                d.title = text
            finally:
                self._guard &= ~TITLE_GUARD

    def on_title_bar_right_clicked(self, pos):
        """ Handle the 'titleBarRightClicked' signal on the dock item.

        """
        d = self.declaration
        if d is not None:
            d.title_bar_right_clicked()

    def on_closed(self):
        """ Handle the closed signal from the dock item.

        """
        d = self.declaration
        if d is not None:
            d._item_closed()

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a QtDockItem.

        """
        super(QtDockItem, self).child_added(child)
        self.widget.setDockWidget(self.dock_widget())

    def child_removed(self, child):
        """ Handle the child added event for a QtDockItem.

        """
        super(QtDockItem, self).child_removed(child)
        self.widget.setDockWidget(self.dock_widget())

    #--------------------------------------------------------------------------
    # ProxyDockItem API
    #--------------------------------------------------------------------------
    def set_title(self, title):
        """ Set the title on the underlying widget.

        """
        if not self._guard & TITLE_GUARD:
            self.widget.setTitle(title)

    def set_title_editable(self, editable):
        """ Set the title editable state on the underlying widget.

        """
        self.widget.setTitleEditable(editable)

    def set_title_bar_visible(self, visible):
        """ Set the visibility of the widget's title bar.

        """
        self.widget.setTitleBarForceHidden(not visible)

    def set_icon(self, icon):
        """ Set the icon on the underlying widget.

        """
        if icon:
            qicon = get_cached_qicon(icon)
        else:
            qicon = QIcon()
        self.widget.setIcon(qicon)

    def set_icon_size(self, size):
        """ Set the icon size on the underlying widget.

        """
        self.widget.setIconSize(QSize(*size))

    def set_stretch(self, stretch):
        """ Set the stretch factor for the underlyling widget.

        """
        sp = self.widget.sizePolicy()
        sp.setHorizontalStretch(stretch)
        sp.setVerticalStretch(stretch)
        self.widget.setSizePolicy(sp)

    def set_closable(self, closable):
        """ Set the closable flag for the underlying widget.

        """
        self.widget.setClosable(closable)

    def alert(self, level, on, off, repeat, persist):
        """ Set the alert level on the underlying widget.

        """
        self.widget.alert(level, on, off, repeat, persist)

########NEW FILE########
__FILENAME__ = qt_dock_pane
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Int, Typed

from enaml.widgets.dock_pane import ProxyDockPane

from .QtCore import Qt, Signal 
from .QtGui import QDockWidget, QWidget

from .qt_container import QtContainer
from .qt_widget import QtWidget


#: A mapping from Enaml dock areas to Qt dock areas.
_DOCK_AREA_MAP = {
    'top': Qt.TopDockWidgetArea,
    'right': Qt.RightDockWidgetArea,
    'bottom': Qt.BottomDockWidgetArea,
    'left': Qt.LeftDockWidgetArea,
    'all': Qt.AllDockWidgetAreas,
}


#: A mapping from Qt dock areas to Enaml dock areas.
_DOCK_AREA_INV_MAP = {
    Qt.TopDockWidgetArea: 'top',
    Qt.RightDockWidgetArea: 'right',
    Qt.BottomDockWidgetArea: 'bottom',
    Qt.LeftDockWidgetArea: 'left',
    Qt.AllDockWidgetAreas: 'all',
}


class QCustomDockWidget(QDockWidget):
    """ A custom QDockWidget which adds some Enaml specific features.

    """
    #: A signal emitted when the dock widget is closed by the user.
    closed = Signal()

    #: A signal emitted when the dock widget is floated.
    floated = Signal()

    #: A signal emitted when the dock widget is docked. The payload
    #: will be the new dock area.
    docked = Signal(object)

    def __init__(self, parent=None):
        """ Initialize a QCustomDockWidget.

        """
        super(QCustomDockWidget, self).__init__(parent)
        self._title_bar_visible = True
        self._dock_area = Qt.LeftDockWidgetArea
        self.topLevelChanged.connect(self._onTopLevelChanged)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _onTopLevelChanged(self, top_level):
        """ The signal handler for the the 'topLevelChanged' signal.

        """
        # Hiding the title bar on a floating dock widget causes the
        # frame to be hidden. We need to make sure its shown when
        # floating, and hidden again upon docking if needed.
        if top_level:
            self._showTitleBar()
            self.floated.emit()
        else:
            if not self._title_bar_visible:
                self._hideTitleBar()
            parent = self.parent()
            if parent is not None:
                self._dock_area = parent.dockWidgetArea(self)
            self.docked.emit(self._dock_area)

    def _showTitleBar(self):
        """ Shows the title bar for the widget.

        """
        if self.titleBarWidget() is not None:
            self.setTitleBarWidget(None)

    def _hideTitleBar(self):
        """ Hides the title bar for the widget.

        """
        if self.titleBarWidget() is None:
            self.setTitleBarWidget(QWidget())

    def closeEvent(self, event):
        """ A close event handler which emits the 'closed' signal.

        """
        super(QCustomDockWidget, self).closeEvent(event)
        self.closed.emit()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def dockArea(self):
        """ Get the current dock area for the dock widget.

        Returns
        -------
        result : QDockWidgetArea
            The dock widget area where this dock widget resides.

        """
        return self._dock_area

    def setDockArea(self, area):
        """ Set the current dock area for the dock widget.

        Parameters
        ----------
        area : QDockWidgetArea
            The dock widget area where this dock widget should reside.

        """
        self._dock_area = area
        parent = self.parent()
        if parent is not None:
            parent.setDockWidgetArea(area, self)

    def titleBarVisible(self):
        """ Get whether or not the title bar is visible.

        Returns
        -------
        result : bool
            Whether or not the title bar is visible.

        """
        return self._title_bar_visible

    def setTitleBarVisible(self, visible):
        """ Set whether or not the title bar is visible.

        Parameters
        ----------
        visible : bool
            Whether or not the title bar is visible.

        """
        self._title_bar_visible = visible
        if visible:
            self._showTitleBar()
        else:
            if not self.isFloating():
                self._hideTitleBar()


# cyclic notification guard flags
FLOATED_GUARD = 0x1


class QtDockPane(QtWidget, ProxyDockPane):
    """ A Qt implementation of an Enaml ProxyDockPane.

    """
    #: A reference tot he widget created by the proxy.
    widget = Typed(QCustomDockWidget)

    #: Cyclic notification guard. This a bitfield of multiple guards.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the QCustomDockWidget widget.

        """
        self.widget = QCustomDockWidget(self.parent_widget())

    def init_widget(self):
        """ Initialize the dock pane control.

        """
        super(QtDockPane, self).init_widget()
        d = self.declaration
        self.set_title(d.title)
        self.set_title_bar_visible(d.title_bar_visible)
        self.set_title_bar_orientation(d.title_bar_orientation)
        self.set_closable(d.closable)
        self.set_movable(d.movable)
        self.set_floatable(d.floatable)
        self.set_floating(d.floating)
        self.set_dock_area(d.dock_area)
        self.set_allowed_dock_areas(d.allowed_dock_areas)
        widget = self.widget
        widget.closed.connect(self.on_closed)
        widget.floated.connect(self.on_floated)
        widget.docked.connect(self.on_docked)

    def init_layout(self):
        """ Handle the layout initialization for the dock pane.

        """
        super(QtDockPane, self).init_layout()
        self.widget.setWidget(self.dock_widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def dock_widget(self):
        """ Find and return the dock widget child for this widget.

        Returns
        -------
        result : QWidget or None
            The dock widget defined for this widget, or None if one is
            not defined.

        """
        d = self.declaration.dock_widget()
        if d is not None:
            return d.proxy.widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a QtDockPane.

        """
        super(QtDockPane, self).child_added(child)
        if isinstance(child, QtContainer):
            self.widget.setWidget(self.dock_widget())

    def child_removed(self, child):
        """ Handle the child removed event for a QtDockPane.

        """
        super(QtDockPane, self).child_removed(child)
        if isinstance(child, QtContainer):
            self.widget.setWidget(self.dock_widget())

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_closed(self):
        """ The signal handler for the 'closed' signal.

        """
        # The closed signal is only emitted when the widget is closed
        # by the user, so there is no need for a loopback guard.
        self.declaration.visible = False
        self.declaration.closed()

    def on_floated(self):
        """ The signal handler for the 'floated' signal.

        """
        if not self._guard & FLOATED_GUARD:
            self._guard |= FLOATED_GUARD
            try:
                self.declaration.floating = True
            finally:
                self._guard &= ~FLOATED_GUARD

    def on_docked(self, area):
        """ The signal handler for the 'docked' signal.

        """
        if not self._guard & FLOATED_GUARD:
            self._guard |= FLOATED_GUARD
            try:
                self.declaration.floating = False
                self.declaration.dock_area = _DOCK_AREA_INV_MAP[area]
            finally:
                self._guard &= ~FLOATED_GUARD

    #--------------------------------------------------------------------------
    # ProxyDockPane API
    #--------------------------------------------------------------------------
    def set_title(self, title):
        """ Set the title on the underlying widget.

        """
        self.widget.setWindowTitle(title)

    def set_title_bar_visible(self, visible):
        """ Set the title bar visibility of the underlying widget.

        """
        self.widget.setTitleBarVisible(visible)

    def set_title_bar_orientation(self, orientation):
        """ Set the title bar orientation of the underyling widget.

        """
        widget = self.widget
        features = widget.features()
        if orientation == 'vertical':
            features |= QDockWidget.DockWidgetVerticalTitleBar
        else:
            features &= ~QDockWidget.DockWidgetVerticalTitleBar
        widget.setFeatures(features)

    def set_closable(self, closable):
        """ Set the closable state on the underlying widget.

        """
        widget = self.widget
        features = widget.features()
        if closable:
            features |= QDockWidget.DockWidgetClosable
        else:
            features &= ~QDockWidget.DockWidgetClosable
        widget.setFeatures(features)

    def set_movable(self, movable):
        """ Set the movable state on the underlying widget.

        """
        widget = self.widget
        features = widget.features()
        if movable:
            features |= QDockWidget.DockWidgetMovable
        else:
            features &= ~QDockWidget.DockWidgetMovable
        widget.setFeatures(features)

    def set_floatable(self, floatable):
        """ Set the floatable state on the underlying widget.

        """
        widget = self.widget
        features = widget.features()
        if floatable:
            features |= QDockWidget.DockWidgetFloatable
        else:
            features &= ~QDockWidget.DockWidgetFloatable
        widget.setFeatures(features)

    def set_floating(self, floating):
        """ Set the floating staet on the underlying widget.

        """
        if not self._guard & FLOATED_GUARD:
            self._guard |= FLOATED_GUARD
            try:
                self.widget.setFloating(floating)
            finally:
                self._guard &= ~FLOATED_GUARD

    def set_dock_area(self, dock_area):
        """ Set the dock area on the underlying widget.

        """
        self.widget.setDockArea(_DOCK_AREA_MAP[dock_area])

    def set_allowed_dock_areas(self, dock_areas):
        """ Set the allowed dock areas on the underlying widget.

        """
        qt_areas = Qt.NoDockWidgetArea
        for area in dock_areas:
            qt_areas |= _DOCK_AREA_MAP[area]
        self.widget.setAllowedAreas(qt_areas)

########NEW FILE########
__FILENAME__ = qt_dual_slider
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Int, Typed

from enaml.widgets.dual_slider import ProxyDualSlider

from .QtCore import Qt, Signal
from .QtGui import QSlider, QStyle, QStyleOptionSlider, QPainter

from .qt_control import QtControl


#: A map from Enaml constants to QSlider TickPosition values.
TICK_POSITION = {
    'no_ticks': QSlider.NoTicks,
    'left': QSlider.TicksLeft,
    'right': QSlider.TicksRight,
    'top': QSlider.TicksAbove,
    'bottom': QSlider.TicksBelow,
    'both': QSlider.TicksBothSides
}


#: A map from Enaml enums to Qt constants for horizontal or vertical
#: orientation.
ORIENTATION = {
    'horizontal': Qt.Horizontal,
    'vertical': Qt.Vertical
}


#: A cyclic guard flag
LOW_VALUE_FLAG = 0x1
HIGH_VALUE_FLAG = 0x2


class QDualSlider(QSlider):
    """ A Qt implementation of a dual slider.

    Dragging on the slider track will cause both the low and high values
    to move equally (i.e. the difference between them stays constant).

    TODO: Add support for tracking.

    """
    #: A signal emitted when the low value of the slider changes.
    lowValueChanged = Signal(int)

    #: A signal emitted when the high value of the slider changes.
    highValueChanged = Signal(int)

    #: Enums identifier the active slider thumb.
    BothThumbs = -1
    LowThumb = 0
    HighThumb = 1

    def __init__(self, parent=None):
        """ Initialize a QDualSlider.

        Parameters
        ----------
        parent : QWidget, optional
            The parent widget for the dual slider, or None.

        """
        super(QDualSlider, self).__init__(parent)
        self._low = self.minimum()
        self._high = self.maximum()
        self._active_thumb = self.LowThumb
        self._pressed_control = QStyle.SC_None
        self._click_offset = 0

    def lowValue(self):
        """ Get the low value of the dual slider.

        """
        return self._low

    def setLowValue(self, low):
        """ Set the low value of the dual slider.

        """
        self._low = low
        if low > self._high:
            self._high = low
        self.update()

    def highValue(self):
        """ Get the high value of the dual slider.

        """
        return self._high

    def setHighValue(self, high):
        """ Set the high value of the dual slider.

        """
        self._high = high
        if high < self._low:
            self._low = high
        self.update()

    def paintEvent(self, event):
        """ Override the paint event to draw both slider handles.

        """
        # based on the paintEvent for QSlider:
        # http://qt.gitorious.org/qt/qt/blobs/master/src/gui/widgets/qslider.cpp
        painter = QPainter(self)
        style = self.style()
        low, high = self._low, self._high

        # Draw the low handle along with the groove and ticks.
        opt = QStyleOptionSlider()
        self.initStyleOption(opt)
        opt.subControls = QStyle.SC_SliderGroove | QStyle.SC_SliderHandle
        if self.tickPosition() != self.NoTicks:
            opt.subControls |= QStyle.SC_SliderTickmarks
        if (self._pressed_control and
            self._active_thumb == self.LowThumb or
            self._active_thumb == self.BothThumbs):
            opt.activeSubControls = self._pressed_control
            opt.state |= QStyle.State_Sunken
        else:
            opt.activeSubControls = QStyle.SC_None
        opt.sliderPosition = low
        opt.sliderValue = low
        style.drawComplexControl(QStyle.CC_Slider, opt, painter, self)

        # Draw high handle. The groove and ticks do not need repainting.
        opt = QStyleOptionSlider()
        self.initStyleOption(opt)
        opt.subControls = QStyle.SC_SliderHandle
        if (self._pressed_control and
            self._active_thumb == self.HighThumb or
            self._active_thumb == self.BothThumbs):
            opt.activeSubControls = self._pressed_control
            opt.state |= QStyle.State_Sunken
        else:
            opt.activeSubControls = QStyle.SC_None
        opt.sliderPosition = high
        opt.sliderValue = high
        style.drawComplexControl(QStyle.CC_Slider, opt, painter, self)

    def mousePressEvent(self, event):
        """ Handle the mouse press event for the control.

        In a typical slider control, when the user clicks on a point in
        the slider's total range but not on the thumbtrack, the control
        would jump to the value of the click location. For this control,
        clicks which are not direct hits will activate both slider
        handles for synchronized moving.

        """
        if event.button() != Qt.LeftButton:
            event.ignore()
            return

        event.accept()
        style = self.style()
        pos = event.pos()
        opt = QStyleOptionSlider()
        self.initStyleOption(opt)
        low, high = self._low, self._high

        # hit-test the high handle
        opt.sliderPosition = high
        high_rect = style.subControlRect(
            style.CC_Slider, opt, style.SC_SliderHandle, self
        )
        high_test = high_rect.contains(pos)

        # hit-test the low handle if needed.
        if high_test:
            low_test = False
        else:
            opt.sliderPosition = low
            low_rect = style.subControlRect(
                style.CC_Slider, opt, style.SC_SliderHandle, self
            )
            low_test = low_rect.contains(pos)

        # Set the internal state for painting and request an update.
        # The click offsets when clicking a thumbtrack are stored in
        # units of pixels. The offset for a click in the empty slider
        # area is stored in units of value.
        self._pressed_control = style.SC_SliderHandle
        if high_test:
            self._active_thumb = self.HighThumb
            self._click_offset = self._pick(pos - high_rect.topLeft())
        elif low_test:
            self._active_thumb = self.LowThumb
            self._click_offset = self._pick(pos - low_rect.topLeft())
        else:
            self._active_thumb = self.BothThumbs
            offset = self._pixelPosToRangeValue(self._pick(pos), opt)
            self._click_offset = offset
        self.setSliderDown(True)
        self.update()

    def mouseMoveEvent(self, event):
        """ Handle the mouse move event for the control.

        If the user has previously pressed the control, this will move
        the slider(s) to the appropriate position and request an update.

        """
        if self._pressed_control != QStyle.SC_SliderHandle:
            event.ignore()
            return

        event.accept()
        opt = QStyleOptionSlider()
        self.initStyleOption(opt)
        point = self._pick(event.pos())
        click_offset = self._click_offset

        thumb = self._active_thumb
        if thumb == self.BothThumbs:
            new_pos = self._pixelPosToRangeValue(point, opt)
            offset = new_pos - click_offset
            self._high += offset
            self._low += offset
            if self._low < self.minimum():
                diff = self.minimum() - self._low
                self._low += diff
                self._high += diff
            if self._high > self.maximum():
                diff = self.maximum() - self._high
                self._low += diff
                self._high += diff
            self._click_offset = new_pos
            self.lowValueChanged.emit(new_pos)
            self.highValueChanged.emit(new_pos)
        elif thumb == self.LowThumb:
            new_pos = self._pixelPosToRangeValue(point - click_offset, opt)
            if new_pos >= self._high:
                new_pos = self._high - 1
            self._low = new_pos
            self.lowValueChanged.emit(new_pos)
        elif thumb == self.HighThumb:
            new_pos = self._pixelPosToRangeValue(point - click_offset, opt)
            if new_pos <= self._low:
                new_pos = self._low + 1
            self._high = new_pos
            self.highValueChanged.emit(new_pos)
        else:
            raise ValueError('Invalid thumb enum value.')
        self.update()

    def mouseReleaseEvent(self, event):
        """ Handle the mouse release event.

        This will update the internal state of the control and request
        an update.

        """
        if self._pressed_control == QStyle.SC_None:
            event.ignore()
            return
        event.accept()
        self._pressed_control = QStyle.SC_None
        self.setSliderDown(False)
        self.update()

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _pick(self, pt):
        """ Pick the x or y coordinate of a point for the orientation.

        """
        return pt.x() if self.orientation() == Qt.Horizontal else pt.y()

    def _pixelPosToRangeValue(self, pos, opt):
        """ Map the pos argument to a value in the slider range

        """
        style = self.style()
        groove_rect = style.subControlRect(
            style.CC_Slider, opt, style.SC_SliderGroove, self
        )
        thumb_rect = style.subControlRect(
            style.CC_Slider, opt, style.SC_SliderHandle, self
        )
        if self.orientation() == Qt.Horizontal:
            thumb_width = thumb_rect.width()
            slider_min = groove_rect.x()
            slider_max = groove_rect.right() - thumb_width + 1
        else:
            thumb_height = thumb_rect.height()
            slider_min = groove_rect.y()
            slider_max = groove_rect.bottom() - thumb_height + 1
        value = style.sliderValueFromPosition(
            self.minimum(), self.maximum(), pos - slider_min,
            slider_max - slider_min, opt.upsideDown
        )
        return value


class QtDualSlider(QtControl, ProxyDualSlider):
    """ A Qt implementation of an Enaml ProxyDualSlider.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QDualSlider)

    #: Cyclic notification guard flags.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying QDualSlider widget.

        """
        self.widget = QDualSlider(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(QtDualSlider, self).init_widget()
        d = self.declaration
        self.set_minimum(d.minimum)
        self.set_maximum(d.maximum)
        self.set_low_value(d.low_value)
        self.set_high_value(d.high_value)
        self.set_orientation(d.orientation)
        self.set_tick_interval(d.tick_interval)
        self.set_tick_position(d.tick_position)
        #self.set_tracking(d.tracking)
        self.widget.lowValueChanged.connect(self.on_low_value_changed)
        self.widget.highValueChanged.connect(self.on_high_value_changed)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_low_value_changed(self):
        """ Send the 'low_value_changed' action to the Enaml widget when the
        slider's low value has changed.

        """
        if not self._guard & LOW_VALUE_FLAG:
            self._guard |= LOW_VALUE_FLAG
            try:
                self.declaration.low_value = self.widget.lowValue()
            finally:
                self._guard &= ~LOW_VALUE_FLAG

    def on_high_value_changed(self):
        """ Send the 'high_value_changed' action to the Enaml widget when the
        slider's high value has changed.

        """
        if not self._guard & HIGH_VALUE_FLAG:
            self._guard |= HIGH_VALUE_FLAG
            try:
                self.declaration.high_value = self.widget.highValue()
            finally:
                self._guard &= ~HIGH_VALUE_FLAG

    #--------------------------------------------------------------------------
    # ProxySlider API
    #--------------------------------------------------------------------------
    def set_maximum(self, maximum):
        """ Set the maximum value of the underlying widget.

        """
        self.widget.setMaximum(maximum)

    def set_minimum(self, minimum):
        """ Set the minimum value of the underlying widget.

        """
        self.widget.setMinimum(minimum)

    def set_low_value(self, value):
        """ Set the value of the underlying widget.

        """
        if not self._guard & LOW_VALUE_FLAG:
            self._guard |= LOW_VALUE_FLAG
            try:
                self.widget.setLowValue(value)
            finally:
                self._guard &= ~LOW_VALUE_FLAG

    def set_high_value(self, value):
        """ Set the value of the underlying widget.

        """
        if not self._guard & HIGH_VALUE_FLAG:
            self._guard |= HIGH_VALUE_FLAG
            try:
                self.widget.setHighValue(value)
            finally:
                self._guard &= ~HIGH_VALUE_FLAG

    def set_tick_interval(self, interval):
        """ Set the tick interval of the underlying widget.

        """
        self.widget.setTickInterval(interval)

    def set_tick_position(self, tick_position):
        """ Set the tick position of the underlying widget.

        """
        self.widget.setTickPosition(TICK_POSITION[tick_position])

    def set_orientation(self, orientation):
        """ Set the orientation of the underlying widget.

        """
        self.widget.setOrientation(ORIENTATION[orientation])

    # def set_tracking(self, tracking):
    #     """ Set the tracking of the underlying widget.

    #     """
    #     self.widget.setTracking(tracking)

########NEW FILE########
__FILENAME__ = qt_factories
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
def action_factory():
    from .qt_action import QtAction
    return QtAction


def action_group_factory():
    from .qt_action_group import QtActionGroup
    return QtActionGroup


def calendar_factory():
    from .qt_calendar import QtCalendar
    return QtCalendar


def check_box_factory():
    from .qt_check_box import QtCheckBox
    return QtCheckBox


def color_dialog_factory():
    from .qt_color_dialog import QtColorDialog
    return QtColorDialog


def combo_box_factory():
    from .qt_combo_box import QtComboBox
    return QtComboBox


def container_factory():
    from .qt_container import QtContainer
    return QtContainer


def control_factory():
    from .qt_control import QtControl
    return QtControl


def date_selector_factory():
    from .qt_date_selector import QtDateSelector
    return QtDateSelector


def datetime_selector_factory():
    from .qt_datetime_selector import QtDatetimeSelector
    return QtDatetimeSelector


def dialog_factory():
    from .qt_dialog import QtDialog
    return QtDialog


def dock_area_factory():
    from .qt_dock_area import QtDockArea
    return QtDockArea


def dock_item_factory():
    from .qt_dock_item import QtDockItem
    return QtDockItem


def dock_pane_factory():
    from .qt_dock_pane import QtDockPane
    return QtDockPane


def dual_slider_factory():
    from .qt_dual_slider import QtDualSlider
    return QtDualSlider


def field_factory():
    from .qt_field import QtField
    return QtField


def file_dialog_factory():
    from .qt_file_dialog import QtFileDialog
    return QtFileDialog


def file_dialog_ex_factory():
    from .qt_file_dialog_ex import QtFileDialogEx
    return QtFileDialogEx


def flow_area_factory():
    from .qt_flow_area import QtFlowArea
    return QtFlowArea


def flow_item_factory():
    from .qt_flow_item import QtFlowItem
    return QtFlowItem


def focus_tracker_factory():
    from .qt_focus_tracker import QtFocusTracker
    return QtFocusTracker


def group_box_factory():
    from .qt_group_box import QtGroupBox
    return QtGroupBox


def html_factory():
    from .qt_html import QtHtml
    return QtHtml


def image_view_factory():
    from .qt_image_view import QtImageView
    return QtImageView


def ipython_console_factory():
    from .qt_ipython_console import QtIPythonConsole
    return QtIPythonConsole


def label_factory():
    from .qt_label import QtLabel
    return QtLabel


def main_window_factory():
    from .qt_main_window import QtMainWindow
    return QtMainWindow


def mdi_area_factory():
    from .qt_mdi_area import QtMdiArea
    return QtMdiArea


def mdi_window_factory():
    from .qt_mdi_window import QtMdiWindow
    return QtMdiWindow


def menu_factory():
    from .qt_menu import QtMenu
    return QtMenu


def menu_bar_factory():
    from .qt_menu_bar import QtMenuBar
    return QtMenuBar


def mpl_canvas_factory():
    from .qt_mpl_canvas import QtMPLCanvas
    return QtMPLCanvas


def multiline_field_factory():
    from .qt_multiline_field import QtMultilineField
    return QtMultilineField


def notebook_factory():
    from .qt_notebook import QtNotebook
    return QtNotebook


def object_combo_factory():
    from .qt_object_combo import QtObjectCombo
    return QtObjectCombo


def page_factory():
    from .qt_page import QtPage
    return QtPage


def popup_view_factory():
    from .qt_popup_view import QtPopupView
    return QtPopupView


def push_button_factory():
    from .qt_push_button import QtPushButton
    return QtPushButton


def progress_bar_factory():
    from .qt_progress_bar import QtProgressBar
    return QtProgressBar


def radio_button_factory():
    from .qt_radio_button import QtRadioButton
    return QtRadioButton


def raw_widget_factory():
    from .qt_raw_widget import QtRawWidget
    return QtRawWidget


def scintilla_factory():
    from .qt_scintilla import QtScintilla
    return QtScintilla


def scroll_area_factory():
    from .qt_scroll_area import QtScrollArea
    return QtScrollArea


def separator_factory():
    from .qt_separator import QtSeparator
    return QtSeparator


def slider_factory():
    from .qt_slider import QtSlider
    return QtSlider


def spin_box_factory():
    from .qt_spin_box import QtSpinBox
    return QtSpinBox


def split_item_factory():
    from .qt_split_item import QtSplitItem
    return QtSplitItem


def splitter_factory():
    from .qt_splitter import QtSplitter
    return QtSplitter


def stack_factory():
    from .qt_stack import QtStack
    return QtStack


def stack_item_factory():
    from .qt_stack_item import QtStackItem
    return QtStackItem


def status_bar_factory():
    from .qt_status_bar import QtStatusBar
    return QtStatusBar


def status_item_factory():
    from .qt_status_item import QtStatusItem
    return QtStatusItem


def time_selector_factory():
    from .qt_time_selector import QtTimeSelector
    return QtTimeSelector


def timer_factory():
    from .qt_timer import QtTimer
    return QtTimer


def tool_bar_factory():
    from .qt_tool_bar import QtToolBar
    return QtToolBar


def tool_button_factory():
    from .qt_tool_button import QtToolButton
    return QtToolButton


def vtk_canvas_factory():
    from .qt_vtk_canvas import QtVTKCanvas
    return QtVTKCanvas


def web_view_factory():
    from .qt_web_view import QtWebView
    return QtWebView


def window_factory():
    from .qt_window import QtWindow
    return QtWindow


QT_FACTORIES = {
    'Action': action_factory,
    'ActionGroup': action_group_factory,
    'Calendar': calendar_factory,
    'CheckBox': check_box_factory,
    'ColorDialog': color_dialog_factory,
    'ComboBox': combo_box_factory,
    'Container': container_factory,
    'DateSelector': date_selector_factory,
    'DatetimeSelector': datetime_selector_factory,
    'Dialog': dialog_factory,
    'DockArea': dock_area_factory,
    'DockItem': dock_item_factory,
    'DockPane': dock_pane_factory,
    'DualSlider': dual_slider_factory,
    'Field': field_factory,
    'FileDialog': file_dialog_factory,
    'FileDialogEx': file_dialog_ex_factory,
    'FlowArea': flow_area_factory,
    'FlowItem': flow_item_factory,
    'FocusTracker': focus_tracker_factory,
    'GroupBox': group_box_factory,
    'Html': html_factory,
    'ImageView': image_view_factory,
    'IPythonConsole': ipython_console_factory,
    'Label': label_factory,
    'MainWindow': main_window_factory,
    'MdiArea': mdi_area_factory,
    'MdiWindow': mdi_window_factory,
    'Menu': menu_factory,
    'MenuBar': menu_bar_factory,
    'MPLCanvas': mpl_canvas_factory,
    'MultilineField': multiline_field_factory,
    'Notebook': notebook_factory,
    'ObjectCombo': object_combo_factory,
    'Page': page_factory,
    'PopupView': popup_view_factory,
    'PushButton': push_button_factory,
    'ProgressBar': progress_bar_factory,
    'RadioButton': radio_button_factory,
    'RawWidget': raw_widget_factory,
    'Scintilla': scintilla_factory,
    'ScrollArea': scroll_area_factory,
    'Separator': separator_factory,
    'Slider': slider_factory,
    'SpinBox': spin_box_factory,
    'SplitItem': split_item_factory,
    'Splitter': splitter_factory,
    'Stack': stack_factory,
    'StackItem': stack_item_factory,
    'StatusBar': status_bar_factory,
    'StatusItem': status_item_factory,
    'TimeSelector': time_selector_factory,
    'Timer': timer_factory,
    'ToolBar': tool_bar_factory,
    'ToolButton': tool_button_factory,
    'VTKCanvas': vtk_canvas_factory,
    'WebView': web_view_factory,
    'Window': window_factory,
}

########NEW FILE########
__FILENAME__ = qt_field
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Int, Typed

from enaml.widgets.field import ProxyField

from .QtCore import QTimer, Signal
from .QtGui import QLineEdit

from .qt_control import QtControl


ECHO_MODES = {
    'normal': QLineEdit.Normal,
    'password': QLineEdit.Password,
    'silent': QLineEdit.NoEcho
}


class QFocusLineEdit(QLineEdit):
    """ A QLineEdit which converts a lost focus event into a signal.

    """
    lostFocus = Signal()

    def focusOutEvent(self, event):
        self.lostFocus.emit()
        return super(QFocusLineEdit, self).focusOutEvent(event)


# Guard flags
TEXT_GUARD = 0x1
ERROR_FLAG = 0x2


class QtField(QtControl, ProxyField):
    """ A Qt4 implementation of an Enaml ProxyField.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QFocusLineEdit)

    #: A collapsing timer for auto sync text.
    _text_timer = Typed(QTimer)

    #: Cyclic notification guard. This a bitfield of multiple guards.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Creates the underlying QFocusLineEdit widget.

        """
        self.widget = QFocusLineEdit(self.parent_widget())

    def init_widget(self):
        """ Create and initialize the underlying widget.

        """
        super(QtField, self).init_widget()
        d = self.declaration
        if d.text:
            self.set_text(d.text)
        if d.mask:
            self.set_mask(d.mask)
        if d.placeholder:
            self.set_placeholder(d.placeholder)
        self.set_echo_mode(d.echo_mode)
        self.set_max_length(d.max_length)
        self.set_read_only(d.read_only)
        self.set_submit_triggers(d.submit_triggers)
        self.widget.textEdited.connect(self.on_text_edited)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _validate_and_apply(self):
        """ Validate and apply the text in the control.

        """
        d = self.declaration
        v = d.validator

        text = self.widget.text()
        if v and not v.validate(text):
            text = v.fixup(text)
            if not v.validate(text):
                return

        if text != self.widget.text():
            self.widget.setText(text)

        self._clear_error_state()
        d.text = text

    def _set_error_state(self):
        """ Set the error state of the widget.

        """
        # A temporary hack until styles are implemented
        if not self._guard & ERROR_FLAG:
            self._guard |= ERROR_FLAG
            s = u'QLineEdit { border: 2px solid red; background: rgb(255, 220, 220); }'
            self.widget.setStyleSheet(s)
            v = self.declaration.validator
            self.widget.setToolTip(v and v.message or u'')

    def _clear_error_state(self):
        """ Clear the error state of the widget.

        """
        # A temporary hack until styles are implemented
        if self._guard & ERROR_FLAG:
            self._guard &= ~ERROR_FLAG
            self.widget.setStyleSheet(u'')
            self.widget.setToolTip(u'')

    def _maybe_valid(self, text):
        """ Get whether the text is valid or can be valid.

        Returns
        -------
        result : bool
            True if the text is valid, or can be made to be valid,
            False otherwise.

        """
        v = self.declaration.validator
        return v is None or v.validate(text) or v.validate(v.fixup(text))

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_submit_text(self):
        """ The signal handler for the text submit triggers.

        """
        self._guard |= TEXT_GUARD
        try:
            self._validate_and_apply()
        finally:
            self._guard &= ~TEXT_GUARD

    def on_text_edited(self):
        """ The signal handler for the 'textEdited' signal.

        """
        if not self._maybe_valid(self.widget.text()):
            self._set_error_state()
        else:
            self._clear_error_state()

        if self._text_timer is not None:
            self._text_timer.start()

    #--------------------------------------------------------------------------
    # ProxyField API
    #--------------------------------------------------------------------------
    def set_text(self, text):
        """ Set the text in the widget.

        """
        if not self._guard & TEXT_GUARD:
            self.widget.setText(text)
            self._clear_error_state()

    def set_mask(self, mask):
        """ Set the make for the widget.

        """
        self.widget.setInputMask(mask)

    def set_submit_triggers(self, triggers):
        """ Set the submit triggers for the widget.

        """
        widget = self.widget
        handler = self.on_submit_text
        try:
            widget.lostFocus.disconnect()
        except (TypeError, RuntimeError):  # was never connected
            pass
        try:
            widget.returnPressed.disconnect()
        except (TypeError, RuntimeError):  # was never connected
            pass
        if 'lost_focus' in triggers:
            widget.lostFocus.connect(handler)
        if 'return_pressed' in triggers:
            widget.returnPressed.connect(handler)
        if 'auto_sync' in triggers:
            if self._text_timer is None:
                timer = self._text_timer = QTimer()
                timer.setSingleShot(True)
                timer.setInterval(300)
                timer.timeout.connect(handler)
        else:
            if self._text_timer is not None:
                self._text_timer.stop()
                self._text_timer = None

    def set_placeholder(self, text):
        """ Set the placeholder text of the widget.

        """
        self.widget.setPlaceholderText(text)

    def set_echo_mode(self, mode):
        """ Set the echo mode of the widget.

        """
        self.widget.setEchoMode(ECHO_MODES[mode])

    def set_max_length(self, length):
        """ Set the maximum text length in the widget.

        """
        if length <= 0 or length > 32767:
            length = 32767
        self.widget.setMaxLength(length)

    def set_read_only(self, read_only):
        """ Set whether or not the widget is read only.

        """
        self.widget.setReadOnly(read_only)

    def field_text(self):
        """ Get the text stored in the widget.

        """
        return self.widget.text()

########NEW FILE########
__FILENAME__ = qt_file_dialog
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from enaml.widgets.file_dialog import ProxyFileDialog

from .q_deferred_caller import deferredCall
from .q_file_dialog_helper import get_file_dialog_exec_func
from .qt_toolkit_object import QtToolkitObject


class QtFileDialog(QtToolkitObject, ProxyFileDialog):
    """ A Qt implementation of an Enaml ProxyFileDialog.

    """
    def exec_dialog(self):
        """ Exec a native file dialog for the declaration state.

        """
        d = self.declaration
        path = d.path
        caption = d.title
        filters = ';;'.join(d.filters)
        selected_filter = d.selected_filter
        exec_func = get_file_dialog_exec_func(d.mode)
        if d.mode == 'open_file':
            path, selected_filter = exec_func(
                self.parent_widget(), caption, path, filters, selected_filter
            )
            paths = [path] if path else []
        elif d.mode == 'open_files':
            paths, selected_filter = exec_func(
                self.parent_widget(), caption, path, filters, selected_filter
            )
        elif d.mode == 'save_file':
            path, selected_filter = exec_func(
                self.parent_widget(), caption, path, filters, selected_filter
            )
            paths = [path] if path else []
        else:
            path = exec_func(self.parent_widget(), caption, path)
            paths = [path] if path else []
        result = 'accepted' if paths else 'rejected'
        d._handle_close(result, paths, selected_filter)

    #--------------------------------------------------------------------------
    # ProxyFileDialog API
    #--------------------------------------------------------------------------
    def open(self):
        """ Run the dialog in a non-blocking fashion.

        This call will return immediately.

        """
        deferredCall(self.exec_dialog)

    def exec_(self):
        """ Run the dialog in a blocking fashion.

        This call will block until the user closes the dialog.

        """
        self.exec_dialog()

########NEW FILE########
__FILENAME__ = qt_file_dialog_ex
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Int, Typed

from enaml.widgets.file_dialog_ex import ProxyFileDialogEx

from .QtGui import QFileDialog

from .q_file_dialog_helper import get_file_dialog_exec_func
from .qt_toolkit_dialog import QtToolkitDialog


ACCEPT_MODE = {
    'open': QFileDialog.AcceptOpen,
    'save': QFileDialog.AcceptSave,
}


FILE_MODE = {
    'any_file': QFileDialog.AnyFile,
    'existing_file': QFileDialog.ExistingFile,
    'existing_files': QFileDialog.ExistingFiles,
    'directory': QFileDialog.Directory,
}


# Guard flags
PATH_GUARD = 0x1
FILTER_GUARD = 0x2


class QtFileDialogEx(QtToolkitDialog, ProxyFileDialogEx):
    """ A Qt implementation of an Enaml ProxyFileDialogEx.

    """
    widget = Typed(QFileDialog)

    #: Cyclic notification guard. This a bitfield of multiple guards.
    _guard = Int(0)

    def create_widget(self):
        """ Create the underlying QFileDialog widget.

        """
        self.widget = QFileDialog(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(QtFileDialogEx, self).init_widget()
        d = self.declaration
        self.set_accept_mode(d.accept_mode)
        self.set_file_mode(d.file_mode)
        self.set_show_dirs_only(d.show_dirs_only)
        self.set_current_path(d.current_path)
        self.set_name_filters(d.name_filters)
        self.set_selected_name_filter(d.selected_name_filter)
        widget = self.widget
        widget.currentChanged.connect(self.on_current_changed)
        widget.filesSelected.connect(self.on_files_selected)
        widget.filterSelected.connect(self.on_filter_selected)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def get_default_title(self):
        """ Get the default window title for the file dialog.

        """
        widget = self.widget
        if widget.acceptMode() == QFileDialog.AcceptOpen:
            if widget.fileMode() == QFileDialog.Directory:
                return 'Find Directory'
            return 'Open'
        return 'Save As'

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_current_changed(self, path):
        """ Handle the 'currentChanged' signal from the dialog.

        """
        d = self.declaration
        if d is not None:
            self._guard |= PATH_GUARD
            try:
                d.current_path = path
            finally:
                self._guard &= ~PATH_GUARD

    def on_files_selected(self, paths):
        """ Handle the 'filesSelected' signal from the dialog.

        """
        d = self.declaration
        if d is not None:
            d.selected_paths = paths

    def on_filter_selected(self, selected):
        """ Handle the 'filterSelected' signal from the dialog.

        """
        d = self.declaration
        if d is not None:
            self._guard |= FILTER_GUARD
            try:
                d.selected_name_filter = selected
            finally:
                self._guard &= ~FILTER_GUARD

    #--------------------------------------------------------------------------
    # ProxyFileDialogEx API
    #--------------------------------------------------------------------------
    def set_accept_mode(self, mode):
        """ Set the accept mode of the underlying widget.

        """
        self.widget.setAcceptMode(ACCEPT_MODE[mode])

    def set_file_mode(self, mode):
        """ Set the file mode of the underlying widget.

        """
        self.widget.setFileMode(FILE_MODE[mode])

    def set_show_dirs_only(self, show):
        """ Set the show dirs only state of the underlying widget.

        """
        self.widget.setOption(QFileDialog.ShowDirsOnly, show)

    def set_current_path(self, path):
        """ Set the current path for the underlying widget.

        """
        if not self._guard & PATH_GUARD:
            self.widget.selectFile(path)

    def set_name_filters(self, filters):
        """ Set the name filters on the underlying widget.

        """
        self.widget.setNameFilters(filters)

    def set_selected_name_filter(self, selected):
        """ Set the selected name filter on the underlying widget.

        """
        if not self._guard & FILTER_GUARD:
            self.widget.selectNameFilter(selected)

    def exec_native(self):
        """ Exec a native file dialog for the declaration state.

        """
        d = self.declaration
        path = d.current_path
        caption = d.title
        filters = ';;'.join(d.name_filters)
        selected_filter = d.selected_name_filter
        parent = self.parent_widget()
        if d.file_mode == 'directory':
            exec_func = get_file_dialog_exec_func('directory')
            path = exec_func(parent, caption, path)
            paths = [path] if path else []
        elif d.accept_mode == 'save':
            exec_func = get_file_dialog_exec_func('save_file')
            path, selected_filter = exec_func(
                parent, caption, path, filters, selected_filter
            )
            paths = [path] if path else []
        elif d.file_mode == 'existing_files':
            exec_func = get_file_dialog_exec_func('open_files')
            paths, selected_filter = exec_func(
                parent, caption, path, filters, selected_filter
            )
        else:
            exec_func = get_file_dialog_exec_func('open_file')
            path, selected_filter = exec_func(
                parent, caption, path, filters, selected_filter
            )
            paths = [path] if path else []
        if paths:
            self.on_current_changed(paths[0])
            self.on_filter_selected(selected_filter)
            self.on_files_selected(paths)
        d._proxy_finished(bool(paths))

########NEW FILE########
__FILENAME__ = qt_flow_area
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.flow_area import ProxyFlowArea

from .QtCore import QEvent, QPoint, QRect
from .QtGui import QScrollArea, QWidget, QPainter, QPalette, QApplication

from .qt_frame import QtFrame
from .qt_flow_item import QtFlowItem
from .q_flow_layout import QFlowLayout


_DIRECTION_MAP = {
    'left_to_right': QFlowLayout.LeftToRight,
    'right_to_left': QFlowLayout.RightToLeft,
    'top_to_bottom': QFlowLayout.TopToBottom,
    'bottom_to_top': QFlowLayout.BottomToTop,
}


_ALIGN_MAP = {
    'leading': QFlowLayout.AlignLeading,
    'trailing': QFlowLayout.AlignTrailing,
    'center': QFlowLayout.AlignCenter,
    'justify': QFlowLayout.AlignJustify,
}


class QFlowArea(QScrollArea):
    """ A custom QScrollArea which implements a flowing layout.

    """
    def __init__(self, parent=None):
        """ Initialize a QFlowArea.

        Parameters
        ----------
        parent : QWidget, optional
            The parent widget of this widget.

        """
        super(QFlowArea, self).__init__(parent)
        self._widget = QWidget(self)
        self._layout = QFlowLayout()
        self._widget.setLayout(self._layout)
        self.setWidgetResizable(True)
        self.setWidget(self._widget)
        # setWidget sets autoFillBackground to True
        self._widget.setAutoFillBackground(False)

    def event(self, event):
        """ A custom event handler for the flow area.

        This handler paints the empty corner between the scroll bars.

        """
        res = super(QFlowArea, self).event(event)
        if event.type() == QEvent.Paint:
            # Fill in the empty corner area with the app window color.
            color = QApplication.palette().color(QPalette.Window)
            tl = self.viewport().geometry().bottomRight()
            fw = self.frameWidth()
            br = self.rect().bottomRight() - QPoint(fw, fw)
            QPainter(self).fillRect(QRect(tl, br), color)
        return res

    def layout(self):
        """ Get the layout for this flow area.

        The majority of interaction for a QFlowArea takes place through
        its layout, rather than through the widget itself.

        Returns
        -------
        result : QFlowLayout
            The flow layout for this flow area.

        """
        return self._layout

    def setLayout(self, layout):
        """ A reimplemented method. Setting the layout on a QFlowArea
        is not supported.

        """
        raise TypeError("Cannot set layout on a QFlowArea.")


class QtFlowArea(QtFrame, ProxyFlowArea):
    """ A Qt implementation of an Enaml ProxyFlowArea.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QFlowArea)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying widget.

        """
        self.widget = QFlowArea(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying control.

        """
        super(QtFlowArea, self).init_widget()
        d = self.declaration
        self.set_direction(d.direction)
        self.set_align(d.align)
        self.set_horizontal_spacing(d.horizontal_spacing)
        self.set_vertical_spacing(d.vertical_spacing)
        self.set_margins(d.margins)

    def init_layout(self):
        """ Initialize the layout for the underlying control.

        """
        super(QtFlowArea, self).init_layout()
        layout = self.widget.layout()
        for child in self.children():
            if isinstance(child, QtFlowItem):
                layout.addWidget(child.widget)

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a QtMdiArea.

        """
        super(QtFlowArea, self).child_added(child)
        if isinstance(child, QtFlowItem):
            for index, dchild in enumerate(self.children()):
                if dchild is child:
                    self.widget.layout().insertWidget(index, child.widget)

    def child_removed(self, child):
        """ Handle the child removed event for a QtMdiArea.

        """
        super(QtFlowArea, self).child_removed(child)
        if isinstance(child, QtFlowItem) and child.widget is not None:
            self.widget.layout().removeWidget(child.widget)

    #--------------------------------------------------------------------------
    # ProxyFlowArea API
    #--------------------------------------------------------------------------
    def set_direction(self, direction):
        """ Set the direction for the underlying control.

        """
        self.widget.layout().setDirection(_DIRECTION_MAP[direction])

    def set_align(self, align):
        """ Set the alignment for the underlying control.

        """
        self.widget.layout().setAlignment(_ALIGN_MAP[align])

    def set_horizontal_spacing(self, spacing):
        """ Set the horizontal spacing of the underyling control.

        """
        self.widget.layout().setHorizontalSpacing(spacing)

    def set_vertical_spacing(self, spacing):
        """ Set the vertical spacing of the underlying control.

        """
        self.widget.layout().setVerticalSpacing(spacing)

    def set_margins(self, margins):
        """ Set the margins of the underlying control.

        """
        top, right, bottom, left = margins
        self.widget.layout().setContentsMargins(left, top, right, bottom)

    #--------------------------------------------------------------------------
    # Overrides
    #--------------------------------------------------------------------------
    def replace_constraints(self, old_cns, new_cns):
        """ A reimplemented QtConstraintsWidget layout method.

        Constraints layout may not cross the boundary of a FlowArea,
        so this method is no-op which stops the layout propagation.

        """
        pass

########NEW FILE########
__FILENAME__ = qt_flow_item
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.flow_item import ProxyFlowItem

from .QtCore import QSize, QEvent
from .QtGui import QFrame, QLayout

from .q_flow_layout import QFlowLayout, AbstractFlowWidget, FlowLayoutData
from .q_single_widget_layout import QSingleWidgetLayout
from .qt_container import QtContainer
from .qt_widget import QtWidget


_ALIGN_MAP = {
    'leading': QFlowLayout.AlignLeading,
    'trailing': QFlowLayout.AlignTrailing,
    'center': QFlowLayout.AlignCenter,
}


class QFlowItem(QFrame):
    """ A QFrame subclass which acts as an item in a QFlowArea.

    """
    def __init__(self, parent=None):
        """ Initialize a QFlowItem.

        Parameters
        ----------
        parent : QWidget, optional
            The parent of the flow item.

        """
        super(QFlowItem, self).__init__(parent)
        self._flow_widget = None
        self._layout_data = FlowLayoutData()
        self.setLayout(QSingleWidgetLayout())
        self.layout().setSizeConstraint(QLayout.SetMinAndMaxSize)

    def layoutData(self):
        """ Get the layout data associate with this flow item.

        This method implements the AbstractFlowWidget interface.

        Returns
        -------
        result : FlowLayoutData
            The layout data for this flow item.

        """
        return self._layout_data

    def preferredSize(self):
        """ Get the preferred size for this widget.

        Returns
        -------
        result : QSize
            The preferred size of this flow item.

        """
        return self._layout_data.preferred_size

    def setPreferredSize(self, size):
        """ Set the preferred size for this flow item.

        This will trigger an invalidation of the layout data.

        Parameters
        ----------
        size : QSize
            The preferred size for the flow item.

        """
        d = self._layout_data
        d.preferred_size = size
        d.dirty = True
        self.updateGeometry()

    def alignment(self):
        """ Get the alignment for the flow item.

        Returns
        -------
        result : QFlowLayout alignment
            The alignment for the flow item in the layout.

        """
        return self._layout_data.alignment

    def setAlignment(self, alignment):
        """ Set the alignment for the flot item.

        This will trigger an invalidation of the layout data.

        Parameters
        ----------
        alignment : QFlowLayout alignment
            The alignment for the flow item in the layout.

        """
        d = self._layout_data
        d.alignment = alignment
        d.dirty = True
        self.updateGeometry()

    def stretch(self):
        """ Get the stretch factor for the flow item.

        Returns
        -------
        result : int
            The stretch factor for the flow item in the direction of
            the layout flow.

        """
        return self._layout_data.stretch

    def setStretch(self, stretch):
        """ Set the stretch factor for the flow item.

        This will trigger an invalidation of the layout data.

        Parameters
        ----------
        stretch : int
            The stretch factor for the flow item in the direction of
            the layout flow.

        """
        d = self._layout_data
        d.stretch = stretch
        d.dirty = True
        self.updateGeometry()

    def orthoStretch(self):
        """ Get the ortho stretch factor for the flow item.

        Returns
        -------
        result : int
            The stretch factor for the flow item in the direction
            orthogonal to the layout flow.

        """
        return self._layout_data.stretch

    def setOrthoStretch(self, stretch):
        """ Set the ortho stretch factor for the flow item.

        This will trigger an invalidation of the layout data.

        Parameters
        ----------
        stretch : int
            The stretch factor for the flow item in the direction
            orthogonal to the layout flow.

        """
        d = self._layout_data
        d.ortho_stretch = stretch
        d.dirty = True
        self.updateGeometry()

    def flowWidget(self):
        """ Get the flow widget for this flow item.

        Returns
        -------
        result : QWidget or None
            The flow widget being managed by this item.

        """
        return self._flow_widget

    def setFlowWidget(self, widget):
        """ Set the flow widget for this flow item.

        Parameters
        ----------
        widget : QWidget
            The QWidget to use as the flow widget in this item.

        """
        self._flow_widget = widget
        self.layout().setWidget(widget)

    def event(self, event):
        """ A custom event handler which handles LayoutRequest events.

        When a LayoutRequest event is posted to this widget, it will
        emit the `layoutRequested` signal. This allows an external
        consumer of this widget to update their external layout.

        """
        if event.type() == QEvent.LayoutRequest:
            self._layout_data.dirty = True
        return super(QFlowItem, self).event(event)


AbstractFlowWidget.register(QFlowItem)


class QtFlowItem(QtWidget, ProxyFlowItem):
    """ A Qt implementation of an Enaml ProxyFlowItem.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QFlowItem)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying QFlowItem widget.

        """
        self.widget = QFlowItem(self.parent_widget())

    def init_widget(self):
        """ Iitialize the underlying control.

        """
        super(QtFlowItem, self).init_widget()
        d = self.declaration
        self.set_preferred_size(d.preferred_size)
        self.set_align(d.align)
        self.set_stretch(d.stretch)
        self.set_ortho_stretch(d.ortho_stretch)

    def init_layout(self):
        """ Initialize the layout for the underyling widget.

        """
        super(QtFlowItem, self).init_layout()
        self.widget.setFlowWidget(self.flow_widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def flow_widget(self):
        """ Find and return the flow widget child for this widget.

        Returns
        -------
        result : QWidget or None
            The flow widget defined for this widget, or None if one is
            not defined.

        """
        d = self.declaration.flow_widget()
        if d is not None:
            return d.proxy.widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a QtFlowItem.

        """
        super(QtFlowItem, self).child_added(child)
        if isinstance(child, QtContainer):
            self.widget.setFlowWidget(self.flow_widget())

    def child_removed(self, child):
        """ Handle the child added event for a QtFlowItem.

        """
        super(QtFlowItem, self).child_removed(child)
        if isinstance(child, QtContainer):
            self.widget.setFlowWidget(self.flow_widget())

    #--------------------------------------------------------------------------
    # ProxyFlowItem API
    #--------------------------------------------------------------------------
    def set_preferred_size(self, size):
        """ Set the preferred size of the underlying widget.

        """
        self.widget.setPreferredSize(QSize(*size))

    def set_align(self, align):
        """ Set the alignment of the underlying widget.

        """
        self.widget.setAlignment(_ALIGN_MAP[align])

    def set_stretch(self, stretch):
        """ Set the stretch factor of the underlying widget.

        """
        self.widget.setStretch(stretch)

    def set_ortho_stretch(self, stretch):
        """ Set the ortho stretch factor of the underling widget.

        """
        self.widget.setOrthoStretch(stretch)

########NEW FILE########
__FILENAME__ = qt_focus_tracker
#------------------------------------------------------------------------------
# Copyright (c) 2014, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from enaml.widgets.focus_tracker import ProxyFocusTracker

from .QtGui import QApplication

from . import focus_registry
from .qt_toolkit_object import QtToolkitObject


class QtFocusTracker(QtToolkitObject, ProxyFocusTracker):
    """ A Qt implementation of an Enaml ProxyFocusTracker.

    """
    def create_widget(self):
        """ Create the underlying widget.

        """
        # A focus tracker does not have a widget representation.
        self.widget = None

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(QtFocusTracker, self).init_widget()
        app = QApplication.instance()
        app.focusChanged.connect(self._on_focus_changed)
        self._update_focus_widget()

    def destroy(self):
        """ A reimplemented destructor.

        """
        app = QApplication.instance()
        app.focusChanged.disconnect(self._on_focus_changed)
        super(QtFocusTracker, self).destroy()

    def _on_focus_changed(self, old, new):
        """ Handle the application 'focusChanged' signal.

        """
        self._update_focus_widget()

    def _update_focus_widget(self):
        """ Update the tracker with currently focused widget.

        """
        fd = focus_registry.focused_declaration()
        self.declaration.focused_widget = fd

########NEW FILE########
__FILENAME__ = qt_frame
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.frame import ProxyFrame

from .QtGui import QFrame

from .qt_constraints_widget import QtConstraintsWidget


STYLE = {
    'box': QFrame.Box,
    'panel': QFrame.Panel,
    'styled_panel': QFrame.StyledPanel,
}


LINE_STYLE = {
    'plain': QFrame.Plain,
    'sunken': QFrame.Sunken,
    'raised': QFrame.Raised,
}


class QtFrame(QtConstraintsWidget, ProxyFrame):
    """ A Qt implementation of an Enaml ProxyFrame.

    """
    #: A reference to the toolkit widget created by the proxy.
    widget = Typed(QFrame)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Creates the QContainer widget.

        """
        self.widget = QFrame(self.parent_widget())

    def init_widget(self):
        """ Initialize the widget.

        """
        super(QtFrame, self).init_widget()
        self.set_border(self.declaration.border)

    #--------------------------------------------------------------------------
    # ProxyFrame API
    #--------------------------------------------------------------------------
    def set_border(self, border):
        """ Set the border for the widget.

        """
        widget = self.widget
        if border is None:
            widget.setFrameShape(QFrame.NoFrame)
            return
        widget.setFrameShape(STYLE[border.style])
        widget.setFrameShadow(LINE_STYLE[border.line_style])
        widget.setLineWidth(border.line_width)
        widget.setMidLineWidth(border.midline_width)

########NEW FILE########
__FILENAME__ = qt_group_box
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import sys

from atom.api import Typed

from enaml.widgets.group_box import ProxyGroupBox

from .QtCore import Qt, QSize, Signal
from .QtGui import QGroupBox

from .qt_container import QtContainer


QT_ALIGNMENTS = {
    'left': Qt.AlignLeft,
    'right': Qt.AlignRight,
    'center': Qt.AlignHCenter,
}


class QResizingGroupBox(QGroupBox):
    """ A subclass of QGroupBox which behaves like a container.

    """
    #: A signal which is emitted on a resize event.
    resized = Signal()

    #: The internally cached size hint.
    _size_hint = QSize()

    def resizeEvent(self, event):
        """ Converts a resize event into a signal.

        """
        super(QResizingGroupBox, self).resizeEvent(event)
        self.resized.emit()

    def sizeHint(self):
        """ Returns the previously set size hint. If that size hint is
        invalid, the superclass' sizeHint will be used.

        """
        hint = self._size_hint
        if not hint.isValid():
            return super(QResizingGroupBox, self).sizeHint()
        return QSize(hint)

    def setSizeHint(self, hint):
        """ Sets the size hint to use for this widget.

        """
        self._size_hint = QSize(hint)

    def minimumSizeHint(self):
        """ Returns the minimum size hint of the widget.

        The minimum size hint for a QResizingGroupBox is conceptually
        the same as its size hint, so we just return that value.

        """
        return self.sizeHint()


class QtGroupBox(QtContainer, ProxyGroupBox):
    """ A Qt implementation of an Enaml ProxyGroupBox.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QResizingGroupBox)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Creates the underlying QGroupBox control.

        """
        widget = QResizingGroupBox(self.parent_widget())
        if sys.platform == 'darwin':
            # On OSX, the widget item layout rect is too small.
            # Setting this attribute forces the widget item to
            # use the widget rect for layout.
            widget.setAttribute(Qt.WA_LayoutUsesWidgetRect, True)
        self.widget = widget

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(QtGroupBox, self).init_widget()
        d = self.declaration
        self.set_title(d.title, cm_update=False)
        self.set_flat(d.flat)
        self.set_title_align(d.title_align)

    #--------------------------------------------------------------------------
    # Layout Handling
    #--------------------------------------------------------------------------
    @staticmethod
    def margins_func(widget_item):
        """ Get the margins for the given widget item.

        """
        m = widget_item.widget().contentsMargins()
        return (m.top(), m.right(), m.bottom(), m.left())

    #--------------------------------------------------------------------------
    # ProxyGroupBox API
    #--------------------------------------------------------------------------
    def set_title(self, title, cm_update=True):
        """ Updates the title of group box.

        """
        if not cm_update:
            self.widget.setTitle(title)
            return
        widget = self.widget
        old_margins = widget.contentsMargins()
        widget.setTitle(title)
        new_margins = widget.contentsMargins()
        if old_margins != new_margins:
            self.margins_updated()

    def set_flat(self, flat):
        """ Updates the flattened appearance of the group box.

        """
        self.widget.setFlat(flat)

    def set_title_align(self, align):
        """ Updates the alignment of the title of the group box.

        """
        qt_align = QT_ALIGNMENTS[align]
        self.widget.setAlignment(qt_align)

    #--------------------------------------------------------------------------
    # Overrides
    #--------------------------------------------------------------------------
    def set_border(self, border):
        """ An overridden parent class method.

        Borders are not supported on a group box, so this method is a
        no-op.

        """
        pass

########NEW FILE########
__FILENAME__ = qt_html
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.html import ProxyHtml

from .QtGui import QTextEdit

from .qt_control import QtControl


class QtHtml(QtControl, ProxyHtml):
    """ A Qt implementation of an Enaml ProxyHtml widget.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QTextEdit)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying html widget.

        """
        widget = QTextEdit(self.parent_widget())
        widget.setReadOnly(True)
        self.widget = widget

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(QtHtml, self).init_widget()
        self.set_source(self.declaration.source)

    #--------------------------------------------------------------------------
    # ProxyHtml API
    #--------------------------------------------------------------------------
    def set_source(self, source):
        """ Set the source of the html widget

        """
        self.widget.setHtml(source)

########NEW FILE########
__FILENAME__ = qt_image_view
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.image_view import ProxyImageView

from .QtGui import QFrame, QPainter, QPixmap

from .q_resource_helpers import get_cached_qimage
from .qt_control import QtControl


class QImageView(QFrame):
    """ A custom QFrame that will paint a QPixmap as an image. The
    api is similar to QLabel, but with a few more options to control
    how the image scales.

    """
    def __init__(self, parent=None):
        """ Initialize a QImageView.

        Parameters
        ----------
        parent : QWidget or None, optional
            The parent widget of this image viewer.

        """
        super(QImageView, self).__init__(parent)
        self._pixmap = None
        self._scaled_contents = False
        self._allow_upscaling = False
        self._preserve_aspect_ratio = False

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def paintEvent(self, event):
        """ A custom paint event handler which draws the image according
        to the current size constraints.

        """
        pixmap = self._pixmap
        if pixmap is None:
            return

        pm_size = pixmap.size()
        pm_width = pm_size.width()
        pm_height = pm_size.height()
        if pm_width == 0 or pm_height == 0:
            return

        # Use the widget rect instead of the event rect so the image
        # paints properly in a scroll area where it may be clipped.
        evt_rect = self.rect()
        evt_x = evt_rect.x()
        evt_y = evt_rect.y()
        evt_width = evt_rect.width()
        evt_height = evt_rect.height()

        if not self._scaled_contents:
            # If the image isn't scaled, it is centered if possible.
            # Otherwise, it's painted at the origin and clipped.
            paint_x = max(0, int((evt_width / 2. - pm_width / 2.) + evt_x))
            paint_y = max(0, int((evt_height / 2. - pm_height / 2.) + evt_y))
            paint_width = pm_width
            paint_height = pm_height
        else:
            # If the image *is* scaled, it's scaled size depends on the
            # size of the paint area as well as the other scaling flags.
            if self._preserve_aspect_ratio:
                pm_ratio = float(pm_width) / pm_height
                evt_ratio = float(evt_width) / evt_height
                if evt_ratio >= pm_ratio:
                    if self._allow_upscaling:
                        paint_height = evt_height
                    else:
                        paint_height = min(pm_height, evt_height)
                    paint_width = int(paint_height * pm_ratio)
                else:
                    if self._allow_upscaling:
                        paint_width = evt_width
                    else:
                        paint_width = min(pm_width, evt_width)
                    paint_height = int(paint_width / pm_ratio)
            else:
                if self._allow_upscaling:
                    paint_height = evt_height
                    paint_width = evt_width
                else:
                    paint_height = min(pm_height, evt_height)
                    paint_width = min(pm_width, evt_width)
            # In all cases of scaling, we know that the scaled image is
            # no larger than the paint area, and can thus be centered.
            paint_x = int((evt_width / 2. - paint_width / 2.) + evt_x)
            paint_y = int((evt_height / 2. - paint_height / 2.) + evt_y)

        # Finally, draw the pixmap into the calculated rect.
        painter = QPainter(self)
        painter.setRenderHint(QPainter.SmoothPixmapTransform)
        painter.drawPixmap(paint_x, paint_y, paint_width, paint_height, pixmap)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def sizeHint(self):
        """ Returns a appropriate size hint for the image based on the
        underlying QPixmap.

        """
        pixmap = self._pixmap
        if pixmap is not None:
            return pixmap.size()
        return super(QImageView, self).sizeHint()

    def pixmap(self):
        """ Returns the underlying pixmap for the image view.

        """
        return self._pixmap

    def setPixmap(self, pixmap):
        """ Set the pixmap to use as the image in the widget.

        Parameters
        ----------
        pixamp : QPixmap
            The QPixmap to use as the image in the widget.

        """
        self._pixmap = pixmap
        self.update()

    def scaledContents(self):
        """ Returns whether or not the contents scale with the widget
        size.

        """
        return self._scaled_contents

    def setScaledContents(self, scaled):
        """ Set whether the contents scale with the widget size.

        Parameters
        ----------
        scaled : bool
            If True, the image will be scaled to fit the widget size,
            subject to the other sizing constraints in place. If False,
            the image will not scale and will be clipped as required.

        """
        self._scaled_contents = scaled
        self.update()

    def allowUpscaling(self):
        """ Returns whether or not the image can be scaled greater than
        its natural size.

        """
        return self._allow_upscaling

    def setAllowUpscaling(self, allow):
        """ Set whether or not to allow the image to be scaled beyond
        its natural size.

        Parameters
        ----------
        allow : bool
            If True, then the image may be scaled larger than its
            natural if it is scaled to fit. If False, the image will
            never be scaled larger than its natural size. In either
            case, the image may be scaled smaller.

        """
        self._allow_upscaling = allow
        self.update()

    def preserveAspectRatio(self):
        """ Returns whether or not the aspect ratio of the image is
        maintained during a resize.

        """
        return self._preserve_aspect_ratio

    def setPreserveAspectRatio(self, preserve):
        """ Set whether or not to preserve the image aspect ratio.

        Parameters
        ----------
        preserve : bool
            If True then the aspect ratio of the image will be preserved
            if it is scaled to fit. Otherwise, the aspect ratio will be
            ignored.

        """
        self._preserve_aspect_ratio = preserve
        self.update()


class QtImageView(QtControl, ProxyImageView):
    """ A Qt implementation of an Enaml ProxyImageView.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QImageView)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying QImageView widget.

        """
        self.widget = QImageView(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying control.

        """
        super(QtImageView, self).init_widget()
        d = self.declaration
        self.set_image(d.image)
        self.set_scale_to_fit(d.scale_to_fit)
        self.set_allow_upscaling(d.allow_upscaling)
        self.set_preserve_aspect_ratio(d.preserve_aspect_ratio)

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_image(self, image):
        """ Set the image on the underlying widget.

        """
        qpixmap = None
        if image:
            qimage = get_cached_qimage(image)
            qpixmap = QPixmap.fromImage(qimage)
        with self.geometry_guard():
            self.widget.setPixmap(qpixmap)

    def set_scale_to_fit(self, scale):
        """ Sets whether or not the image scales with the underlying
        control.

        """
        self.widget.setScaledContents(scale)

    def set_allow_upscaling(self, allow):
        """ Sets whether or not the image will scale beyond its natural
        size.

        """
        self.widget.setAllowUpscaling(allow)

    def set_preserve_aspect_ratio(self, preserve):
        """ Sets whether or not to preserve the aspect ratio of the
        image when scaling.

        """
        self.widget.setPreserveAspectRatio(preserve)

########NEW FILE########
__FILENAME__ = qt_ipython_console
#------------------------------------------------------------------------------
# Copyright (c) 2014, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.ipython_console import ProxyIPythonConsole

from IPython.qt.console.rich_ipython_widget import RichIPythonWidget
from IPython.qt.inprocess import QtInProcessKernelManager

from .QtGui import QFrame, QVBoxLayout

from . import focus_registry
from .q_deferred_caller import deferredCall
from .qt_control import QtControl


class QtIPythonConsole(QtControl, ProxyIPythonConsole):
    """ A Qt4 implementation of an Enaml IPythonConsole.

    """
    #: The wrapper widget created by the proxy. A wrapper is necessary
    #: since the IPython widget overrides critical Qt API methods which
    #: renders the widget incompatible with the ancestor hierarchy.
    widget = Typed(QFrame)

    #: The internal IPython console widget.
    ipy_widget = Typed(RichIPythonWidget)

    #--------------------------------------------------------------------------
    # Lifecycle API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying widget.

        """
        self.widget = QFrame(self.parent_widget())
        self.ipy_widget = RichIPythonWidget()
        assert self.page_control is not None  # always use paging

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(QtIPythonConsole, self).init_widget()
        self._setup_kernel()
        focus_registry.register(self.text_control, self)
        focus_registry.register(self.page_control, self)
        self.update_ns(self.declaration.initial_ns)
        self.ipy_widget.exit_requested.connect(self._on_exit_requested)

    def init_layout(self):
        """ Initialize the underlying widget layout.

        """
        super(QtIPythonConsole, self).init_layout()
        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        layout.addWidget(self.ipy_widget)
        self.widget.setLayout(layout)

    def destroy(self):
        """ Destroy the underlying widget.

        """
        self._teardown_kernel()
        focus_registry.unregister(self.text_control)
        focus_registry.unregister(self.page_control)
        super(QtIPythonConsole, self).destroy()

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _setup_kernel(self):
        """ Setup the kernel for the widget.

        """
        kernel_manager = QtInProcessKernelManager()
        kernel_manager.start_kernel()
        kernel_client = kernel_manager.client()
        kernel_client.start_channels()
        ipy_widget = self.ipy_widget
        ipy_widget.kernel_manager = kernel_manager
        ipy_widget.kernel_client = kernel_client

    def _teardown_kernel(self):
        """ Teardown the kernel for the widget.

        """
        ipy_widget = self.ipy_widget
        ipy_widget.kernel_client.stop_channels()
        ipy_widget.kernel_manager.shutdown_kernel()

    def _on_exit_requested(self, obj):
        """ Handle the 'exit_requested' signal on the widget.

        """
        deferredCall(self.declaration.exit_requested)

    #--------------------------------------------------------------------------
    # Protected API
    #--------------------------------------------------------------------------
    def focus_target(self):
        """ Returns the current focus target for the widget.

        """
        page = self.page_control
        if page.isVisibleTo(self.widget):
            return page
        return self.text_control

    def hook_focus_events(self):
        """ Hook the focus events for the underlyling widget.

        """
        text = self.text_control
        text.focusInEvent = self.textFocusInEvent
        text.focusOutEvent = self.textFocusOutEvent
        page = self.page_control
        page.focusInEvent = self.pageFocusInEvent
        page.focusOutEvent = self.pageFocusOutEvent

    def unhook_focus_events(self):
        """ Unhook the focus events for the underling widget.

        """
        text = self.text_control
        del text.focusInEvent
        del text.focusOutEvent
        page = self.page_control
        del page.focusInEvent
        del page.focusOutEvent

    def textFocusInEvent(self, event):
        """ Handle the focusInEvent for the text widget.

        """
        self.handleFocusInEvent(self.text_control, event)

    def textFocusOutEvent(self, event):
        """ Handle the focusOutEvent for the text widget.

        """
        self.handleFocusOutEvent(self.text_control, event)

    def pageFocusInEvent(self, event):
        """ Handle the focusInEvent for the page widget.

        """
        self.handleFocusInEvent(self.page_control, event)

    def pageFocusOutEvent(self, event):
        """ Handle the focusOutEvent for the page widget.

        """
        self.handleFocusOutEvent(self.page_control, event)

    def handleFocusInEvent(self, widget, event):
        """ Handle the focusInEvent for the given widget.

        """
        type(widget).focusInEvent(widget, event)
        self.declaration.focus_gained()

    def handleFocusOutEvent(self, widget, event):
        """ Handle the focusOutEvent for the given widget.

        """
        type(widget).focusOutEvent(widget, event)
        self.declaration.focus_lost()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    @property
    def text_control(self):
        """ Return the text control for the IPython widget.

        Returns
        -------
        result : QTextEdit
            The text control for the IPython widget.

        """
        return self.ipy_widget._control

    @property
    def page_control(self):
        """ Return the page control for the IPython widget.

        Returns
        -------
        result : QTextEdit
            The page control for the IPython widget.

        """
        return self.ipy_widget._page_control

    #--------------------------------------------------------------------------
    # ProxyIPythonConsole API
    #--------------------------------------------------------------------------
    def get_var(self, name, default):
        """ Get a variable from the console namespace.

        """
        kernel = self.ipy_widget.kernel_manager.kernel
        return kernel.shell.user_ns.get(name, default)

    def update_ns(self, ns):
        """ Update the namespace of the underlying console.

        """
        if len(ns) > 0:
            kernel = self.ipy_widget.kernel_manager.kernel
            kernel.shell.push(ns)

########NEW FILE########
__FILENAME__ = qt_label
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.label import ProxyLabel

from .QtCore import Qt
from .QtGui import QLabel

from .qt_control import QtControl


ALIGN_MAP = {
    'left': Qt.AlignLeft,
    'right': Qt.AlignRight,
    'center': Qt.AlignHCenter,
    'justify': Qt.AlignJustify,
}


VERTICAL_ALIGN_MAP = {
    'top': Qt.AlignTop,
    'bottom': Qt.AlignBottom,
    'center': Qt.AlignVCenter,
}


class QtLabel(QtControl, ProxyLabel):
    """ A Qt implementation of an Enaml ProxyLabel.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QLabel)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying label widget.

        """
        self.widget = QLabel(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(QtLabel, self).init_widget()
        d = self.declaration
        self.set_text(d.text)
        self.set_align(d.align)
        self.set_vertical_align(d.vertical_align)
        self.widget.linkActivated.connect(self.on_link_activated)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_link_activated(self, link):
        """ Handle the link activated signal.

        """
        self.declaration.link_activated(link)

    #--------------------------------------------------------------------------
    # ProxyLabel API
    #--------------------------------------------------------------------------
    def set_text(self, text):
        """ Set the text in the widget.

        """
        with self.geometry_guard():
            self.widget.setText(text)

    def set_align(self, align):
        """ Set the alignment of the text in the widget.

        """
        widget = self.widget
        alignment = widget.alignment()
        alignment &= ~Qt.AlignHorizontal_Mask
        alignment |= ALIGN_MAP[align]
        widget.setAlignment(alignment)

    def set_vertical_align(self, align):
        """ Set the vertical alignment of the text in the widget.

        """
        widget = self.widget
        alignment = widget.alignment()
        alignment &= ~Qt.AlignVertical_Mask
        alignment |= VERTICAL_ALIGN_MAP[align]
        widget.setAlignment(alignment)

########NEW FILE########
__FILENAME__ = qt_main_window
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import sys

from atom.api import Typed, atomref

from enaml.widgets.main_window import ProxyMainWindow
from enaml.widgets.window import CloseEvent

from .QtCore import Qt
from .QtGui import QMainWindow

from .q_deferred_caller import deferredCall
from .qt_container import QtContainer
from .qt_dock_pane import QtDockPane
from .qt_menu_bar import QtMenuBar
from .qt_status_bar import QtStatusBar
from .qt_tool_bar import QtToolBar
from .qt_window import QtWindow, finalize_close


class QCustomMainWindow(QMainWindow):
    """ A custom QMainWindow which adds some Enaml specific features.

    """
    def __init__(self, proxy, parent=None, flags=Qt.Widget):
        """ Initialize a QCustomMainWindow.

        Parameters
        ----------
        proxy : QtMainWindow
            The proxy object which owns this window. Only an atomref
            will be maintained to this object.

        parent : QWidget, optional
            The parent of the window.

        flags : Qt.WindowFlags, optional
            The window flags to pass to the parent constructor.

        """
        super(QCustomMainWindow, self).__init__(parent, Qt.Window | flags)
        self._proxy_ref = atomref(proxy)

    def closeEvent(self, event):
        """ Handle the close event for the window.

        """
        event.accept()
        if not self._proxy_ref:
            return
        proxy = self._proxy_ref()
        d = proxy.declaration
        d_event = CloseEvent()
        d.closing(d_event)
        if d_event.is_accepted():
            deferredCall(finalize_close, d)
        else:
            event.ignore()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def setDockWidgetArea(self, area, dock_widget):
        """ Set the dock area for the given dock widget.

        If the dock widget has not been added to the main window, this
        method is a no-op.

        Parameters
        ----------
        area : QDockWidgetArea
            The dock area to use for the widget.

        dock_widget : QDockWidget
            The dock widget to move to the given area.

        """
        curr = self.dockWidgetArea(dock_widget)
        if curr != Qt.NoDockWidgetArea:
            if curr != area:
                visible = dock_widget.isVisible()
                self.removeDockWidget(dock_widget)
                self.addDockWidget(area, dock_widget)
                dock_widget.setVisible(visible)

    def setToolBarArea(self, area, tool_bar):
        """ Set the tool bar area for the given tool bar.

        If the tool bar has not been added to the main window, this
        method is a no-op.

        Parameters
        ----------
        area : QToolBarArea
            The tool bar area to use for the widget.

        tool_bar : QToolBar
            The tool bar to move to the given area.

        """
        curr = self.toolBarArea(tool_bar)
        if curr != Qt.NoToolBarArea:
            if curr != area:
                visible = tool_bar.isVisible()
                floating = tool_bar.isFloating()
                tool_bar.setVisible(False)
                self.removeToolBar(tool_bar)
                self.addToolBar(area, tool_bar)
                tool_bar.resize(tool_bar.sizeHint())
                tool_bar.setFloating(floating)
                tool_bar.setVisible(visible)


class QtMainWindow(QtWindow, ProxyMainWindow):
    """ A Qt implementation of an Enaml MainWindow.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QCustomMainWindow)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying widget QMainWindow widget.

        """
        flags = self.creation_flags()
        widget = QCustomMainWindow(self, self.parent_widget(), flags)
        widget.setDocumentMode(True)
        widget.setDockNestingEnabled(True)
        self.widget = widget

    def init_layout(self):
        """ Initialize the layout for the underlying widget.

        """
        # The superclass' init_layout() method is explicitly not called
        # since the layout initialization for Window is not appropriate
        # for MainWindow.
        widget = self.widget
        widget.setMenuBar(self.menu_bar())
        widget.setCentralWidget(self.central_widget())
        widget.setStatusBar(self.status_bar())
        for d in self.dock_panes():
            widget.addDockWidget(d.dockArea(), d)
        for d in self.tool_bars():
            # XXX slight hack. When adding the toolbar to the main
            # window, it is forcibly unfloated. In order for the
            # initial floating state to be maintained, it must be
            # re-floating after being added. We do the refloating
            # in the future, so that the main window shows up first.
            floating = d.isFloating()
            widget.addToolBar(d.toolBarArea(), d)
            if floating:
                deferredCall(d.setFloating, True)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def menu_bar(self):
        """ Get the QMenuBar widget defined for the main window.

        """
        d = self.declaration.menu_bar()
        if d is not None:
            return d.proxy.widget

    def dock_panes(self):
        """ Get the QDockWidget widgets defined for the main window.

        """
        for d in self.declaration.dock_panes():
            w = d.proxy.widget
            if w is not None:
                yield w

    def status_bar(self):
        """ Get the status bar widget defined for the main window.

        """
        d = self.declaration.status_bar()
        if d is not None:
            return d.proxy.widget

    def tool_bars(self):
        """ Get the QToolBar widgets defined for the main window.

        """
        for d in self.declaration.tool_bars():
            w = d.proxy.widget
            if w is not None:
                yield w

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a QtMainWindow.

        """
        if isinstance(child, QtMenuBar):
            self.widget.setMenuBar(self.menu_bar())
        elif isinstance(child, QtContainer):
            self.widget.setCentralWidget(self.central_widget())
        elif isinstance(child, QtDockPane):
            dock_widget = child.widget
            self.widget.addDockWidget(dock_widget.dockArea(), dock_widget)
        elif isinstance(child, QtStatusBar):
            # FIXME Qt will delete the old status bar
            self.widget.setStatusBar(self.status_bar())
        elif isinstance(child, QtToolBar):
            # There are two hacks involved in adding a tool bar. The
            # first is the same hack that is perfomed in the layout
            # method for a floating tool bar. The second is specific
            # to OSX. On that platform, adding a tool bar to main
            # window which is already visible but does not have any
            # current tool bars will cause the main window to be hidden.
            # This will only occur the *first* time a tool bar is added
            # to the window. The hack below is workaround which should
            # be sufficient for most use cases. A bug should really be
            # filed against Qt for this one, since it's reproducible
            # outside of Enaml.
            bar_widget = child.widget
            floating = bar_widget.isFloating()
            self.widget.addToolBar(bar_widget.toolBarArea(), bar_widget)
            if floating:
                deferredCall(bar_widget.setFloating, True)
            if sys.platform == 'darwin':
                self.widget.setVisible(True)
        else:
            super(QtMainWindow, self).child_added(child)

    def child_removed(self, child):
        """ Handle the child removed event for a QtMainWindow.

        """
        if isinstance(child, QtDockPane) and child.widget is not None:
            self.widget.removeDockWidget(child.widget)
        elif isinstance(child, QtToolBar) and child.widget is not None:
            self.widget.removeToolBar(child.widget)
        elif isinstance(child, QtContainer):
            self.widget.setCentralWidget(self.central_widget())
        elif isinstance(child, QtMenuBar):
            self.widget.setMenuBar(self.menu_bar())
        elif isinstance(child, QtStatusBar):
            # FIXME Qt will delete the old status bar
            self.widget.setStatusBar(self.status_bar())
        else:
            super(QtMainWindow, self).child_removed(child)

########NEW FILE########
__FILENAME__ = qt_mdi_area
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.mdi_area import ProxyMdiArea

from .QtGui import QMdiArea

from .qt_constraints_widget import QtConstraintsWidget
from .qt_mdi_window import QtMdiWindow


class QtMdiArea(QtConstraintsWidget, ProxyMdiArea):
    """ A Qt implementation of an Enaml ProxyMdiArea.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QMdiArea)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying QMdiArea widget.

        """
        self.widget = QMdiArea(self.parent_widget())

    def init_layout(self):
        """ Initialize the layout for the underlying control.

        """
        super(QtMdiArea, self).init_layout()
        widget = self.widget
        for window in self.mdi_windows():
            widget.addSubWindow(window)
        widget.subWindowActivated.connect(self.on_subwindow_activated)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def mdi_windows(self):
        """ Get the mdi windows defined for the area.

        """
        for window in self.declaration.mdi_windows():
            widget = window.proxy.widget
            if widget:
                yield widget

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_subwindow_activated(self, window):
        """ The handler for the 'subWindowActivated' signal.

        """
        # On OSX there is painting bug where a subwindow is not repainted
        # properly when it is activated. This handler ensures an update.
        if window:
            window.update()

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a QtMdiArea.

        """
        # The size hint of a QMdiArea is typically quite large and the
        # size hint constraints are usually ignored. There is no need
        # to notify of a change in size hint here.
        super(QtMdiArea, self).child_added(child)
        if isinstance(child, QtMdiWindow):
            self.widget.addSubWindow(child.widget)

    def child_removed(self, child):
        """ Handle the child removed event for a QtMdiArea.

        """
        if isinstance(child, QtMdiWindow):
            self.widget.removeSubWindow(child.widget)
        else:
            super(QtMdiArea, self).child_removed(child)

########NEW FILE########
__FILENAME__ = qt_mdi_window
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.mdi_window import ProxyMdiWindow

from .QtGui import QMdiSubWindow, QLayout, QIcon

from .q_resource_helpers import get_cached_qicon
from .qt_widget import QtWidget


class QtMdiWindow(QtWidget, ProxyMdiWindow):
    """ A Qt implementation of an Enaml ProxyMdiWindow.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QMdiSubWindow)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying QMdiSubWindow widget.

        """
        # We don't parent the subwindow immediately. It will be added
        # explicitly by the parent QMdiArea during its layout pass.
        # If we set the parent here, Qt will spit out warnings when
        # it's set added to the area later on. We *could* parent it
        # here, and simply not add it explicitly to the mdi area, but
        # this way is more explicit and consistent with the rest of
        # the framework.
        widget = QMdiSubWindow()
        widget.layout().setSizeConstraint(QLayout.SetMinAndMaxSize)
        self.widget = widget

    def init_widget(self):
        """ Initialize the widget.

        """
        super(QtMdiWindow, self).init_widget()
        d = self.declaration
        if d.title:
            self.set_title(d.title)
        if d.icon:
            self.set_icon(d.icon)

    def init_layout(self):
        """ Initialize the layout for the underlying control.

        """
        super(QtMdiWindow, self).init_layout()
        self._set_window_widget(self.mdi_widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def mdi_widget(self):
        """ Find and return the mdi widget child for this widget.

        """
        w = self.declaration.mdi_widget()
        if w:
            return w.proxy.widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a QtMdiWindow.

        """
        super(QtMdiWindow, self).child_added(child)
        if isinstance(child, QtWidget):
            self._set_window_widget(self.mdi_widget())

    def child_removed(self, child):
        """ Handle the child removed event for a QtMdiWindow.

        """
        super(QtMdiWindow, self).child_added(child)
        if isinstance(child, QtWidget):
            self._set_window_widget(self.mdi_widget())

    #--------------------------------------------------------------------------
    # ProxyMdiWindow API
    #--------------------------------------------------------------------------
    def set_icon(self, icon):
        """ Set the mdi window icon.

        """
        if icon:
            qicon = get_cached_qicon(icon)
        else:
            qicon = QIcon()
        self.widget.setWindowIcon(qicon)

    def set_title(self, title):
        """ Set the title of the mdi window.

        """
        self.widget.setWindowTitle(title)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _set_window_widget(self, mdi_widget):
        """ A private method which set the child widget on the window.

        Parameters
        ----------
        mdi_widget : QWidget
            The child widget to use in the mdi window.

        """
        # We need to first set the window widget to None, or Qt will
        # complain if a widget is already set on the window.
        widget = self.widget
        widget.setWidget(None)
        if mdi_widget is None:
            return
        # We need to unparent the underlying widget before adding
        # it to the subwindow. Otherwise, children like QMainWindow
        # will persist as top-level non-mdi widgets.
        mdi_widget.setParent(None)
        widget.setWidget(mdi_widget)
        # On OSX, the resize gripper will be obscured unless we
        # lower the widget in the window's stacking order.
        mdi_widget.lower()

########NEW FILE########
__FILENAME__ = qt_menu
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.menu import ProxyMenu

from .QtCore import Qt
from .QtGui import QMenu, QCursor

from .qt_action import QtAction
from .qt_action_group import QtActionGroup
from .qt_toolkit_object import QtToolkitObject
from .qt_widget import QtWidget


class QCustomMenu(QMenu):
    """ A custom subclass of QMenu which adds some convenience apis.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a QCustomMenu.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initialize
            a QMenu.

        """
        super(QCustomMenu, self).__init__(*args, **kwargs)
        self._is_context_menu = False

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _onShowContextMenu(self, pos):
        """ A private signal handler for displaying the context menu.

        This handler is connected to the context menu requested signal
        on the parent widget when this menu is marked as a context
        menu.

        """
        parent = self.parentWidget()
        if parent is not None:
            global_pos = parent.mapToGlobal(pos)
            self.exec_(global_pos)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def isContextMenu(self):
        """ Whether this menu acts as a context menu for its parent.

        Returns
        -------
        result : bool
            True if this menu acts as a context menu, False otherwise.

        """
        return self._is_context_menu

    def setContextMenu(self, context):
        """ Set whether this menu acts as a context menu for its parent.

        Parameters
        ----------
        context : bool
            True if this menu should act as a context menu, False
            otherwise.

        """
        old_context = self._is_context_menu
        self._is_context_menu = context
        if old_context != context:
            parent = self.parentWidget()
            if parent is not None:
                handler = self._onShowContextMenu
                if context:
                    parent.setContextMenuPolicy(Qt.CustomContextMenu)
                    parent.customContextMenuRequested.connect(handler)
                else:
                    parent.setContextMenuPolicy(Qt.DefaultContextMenu)
                    parent.customContextMenuRequested.disconnect(handler)

    def removeActions(self, actions):
        """ Remove the given actions from the menu.

        Parameters
        ----------
        actions : iterable
            An iterable of QActions to remove from the menu.

        """
        remove = self.removeAction
        for action in actions:
            remove(action)


class QtMenu(QtToolkitObject, ProxyMenu):
    """ A Qt implementation of an Enaml ProxyMenu.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QCustomMenu)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying menu widget.

        """
        self.widget = QCustomMenu(self.parent_widget())

    def init_widget(self):
        """ Initialize the widget.

        """
        super(QtMenu, self).init_widget()
        d = self.declaration
        self.set_title(d.title)
        self.set_enabled(d.enabled)
        self.set_visible(d.visible)
        self.set_context_menu(d.context_menu)

    def init_layout(self):
        """ Initialize the layout of the widget.

        """
        super(QtMenu, self).init_layout()
        widget = self.widget
        for child in self.children():
            if isinstance(child, QtMenu):
                widget.addMenu(child.widget)
            elif isinstance(child, QtAction):
                widget.addAction(child.widget)
            elif isinstance(child, QtActionGroup):
                widget.addActions(child.actions())
            elif isinstance(child, QtWidget):
                widget.addAction(child.get_action(True))

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def find_next_action(self, child):
        """ Get the QAction instance which follows the child.

        Parameters
        ----------
        child : QtToolkitObject
            The child of interest.

        Returns
        -------
        result : QAction or None
            The QAction which comes immediately after the actions of the
            given child, or None if no actions follow the child.

        """
        found = False
        for dchild in self.children():
            if found:
                if isinstance(dchild, QtMenu):
                    return dchild.widget.menuAction()
                elif isinstance(dchild, QtAction):
                    return dchild.widget
                elif isinstance(dchild, QtActionGroup):
                    acts = dchild.actions()
                    if len(acts) > 0:
                        return acts[0]
                elif isinstance(dchild, QtWidget):
                    action = dchild.get_action(False)
                    if action is not None:
                        return action
            else:
                found = dchild is child

    def child_added(self, child):
        """ Handle the child added event for a QtMenu.

        """
        super(QtMenu, self).child_added(child)
        if isinstance(child, QtMenu):
            before = self.find_next_action(child)
            self.widget.insertMenu(before, child.widget)
        elif isinstance(child, QtAction):
            before = self.find_next_action(child)
            self.widget.insertAction(before, child.widget)
        elif isinstance(child, QtActionGroup):
            before = self.find_next_action(child)
            self.widget.insertActions(before, child.actions())
        elif isinstance(child, QtWidget):
            before = self.find_next_action(child)
            self.widget.insertAction(before, child.get_action(True))

    def child_removed(self, child):
        """  Handle the child removed event for a QtMenu.

        """
        super(QtMenu, self).child_removed(child)
        if isinstance(child, QtMenu):
            self.widget.removeAction(child.widget.menuAction())
        elif isinstance(child, QtAction):
            self.widget.removeAction(child.widget)
        elif isinstance(child, QtActionGroup):
            self.widget.removeActions(child.actions())
        elif isinstance(child, QtWidget):
            self.widget.removeAction(child.get_action(False))

    #--------------------------------------------------------------------------
    # ProxyMenu API
    #--------------------------------------------------------------------------
    def set_title(self, title):
        """ Set the title of the underlying widget.

        """
        self.widget.setTitle(title)

    def set_visible(self, visible):
        """ Set the visibility on the underlying widget.

        """
        self.widget.menuAction().setVisible(visible)

    def set_enabled(self, enabled):
        """ Set the enabled state of the widget.

        """
        self.widget.setEnabled(enabled)

    def set_context_menu(self, context):
        """ Set whether or not the menu is a context menu.

        """
        self.widget.setContextMenu(context)

    def popup(self):
        """ Popup the menu over the current mouse location.

        """
        self.widget.exec_(QCursor.pos())

    def close(self):
        """ Close the underlying menu.

        """
        self.widget.close()

########NEW FILE########
__FILENAME__ = qt_menu_bar
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import sys

from atom.api import Typed

from enaml.widgets.menu_bar import ProxyMenuBar

from .QtGui import QMainWindow, QMenuBar

from .qt_menu import QtMenu
from .qt_toolkit_object import QtToolkitObject


class QtMenuBar(QtToolkitObject, ProxyMenuBar):
    """ A Qt implementation of an Enaml ProxyMenuBar.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QMenuBar)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying menu bar widget.

        """
        # Qt behaves better when creating the menu bar without a parent.
        self.widget = QMenuBar()

    def init_layout(self):
        """ Initialize the layout for the menu bar.

        """
        super(QtMenuBar, self).init_layout()
        widget = self.widget
        for child in self.children():
            if isinstance(child, QtMenu):
                widget.addMenu(child.widget)

    def destroy(self):
        """ A reimplemented destructor.

        Qt takes ownership of the menubar, so the destructor does not
        attempt to unparent the menubar. The child_removed handler on
        the main window will reset the menu bar.

        """
        del self.declaration

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def find_next_action(self, child):
        """ Get the QAction instance which follows the child.

        Parameters
        ----------
        child : QtMenu
            The child menu of interest.

        Returns
        -------
        result : QAction or None
            The QAction which comes immediately after the actions of the
            given child, or None if no actions follow the child.

        """
        found = False
        for dchild in self.children():
            if found:
                if isinstance(dchild, QtMenu):
                    return dchild.widget.menuAction()
            else:
                found = dchild is child

    def child_added(self, child):
        """ Handle the child added event for a QtMenuBar.

        """
        super(QtMenuBar, self).child_added(child)
        if isinstance(child, QtMenu):
            before = self.find_next_action(child)
            self.widget.insertMenu(before, child.widget)

    def child_removed(self, child):
        """ Handle the child removed event for a QtMenuBar.

        """
        super(QtMenuBar, self).child_removed(child)
        if isinstance(child, QtMenu):
            self.widget.removeAction(child.widget.menuAction())

########NEW FILE########
__FILENAME__ = qt_mpl_canvas
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.mpl_canvas import ProxyMPLCanvas

from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg
from matplotlib.backends.backend_qt4agg import NavigationToolbar2QTAgg

from .QtCore import Qt
from .QtGui import QFrame, QVBoxLayout

from .qt_control import QtControl


class QtMPLCanvas(QtControl, ProxyMPLCanvas):
    """ A Qt implementation of an Enaml ProxyMPLCanvas.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QFrame)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying widget.

        """
        widget = QFrame(self.parent_widget())
        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        widget.setLayout(layout)
        self.widget = widget

    def init_layout(self):
        """ Initialize the layout of the underlying widget.

        """
        super(QtMPLCanvas, self).init_layout()
        self._refresh_mpl_widget()

    #--------------------------------------------------------------------------
    # ProxyMPLCanvas API
    #--------------------------------------------------------------------------
    def set_figure(self, figure):
        """ Set the MPL figure for the widget.

        """
        with self.geometry_guard():
            self._refresh_mpl_widget()

    def set_toolbar_visible(self, visible):
        """ Set the toolbar visibility for the widget.

        """
        layout = self.widget.layout()
        if layout.count() == 2:
            with self.geometry_guard():
                toolbar = layout.itemAt(0).widget()
                toolbar.setVisible(visible)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _refresh_mpl_widget(self):
        """ Create the mpl widget and update the underlying control.

        """
        # Delete the old widgets in the layout, it's just shenanigans
        # to try to reuse the old widgets when the figure changes.
        widget = self.widget
        layout = widget.layout()
        while layout.count():
            layout_item = layout.takeAt(0)
            layout_item.widget().deleteLater()

        # Create the new figure and toolbar widgets. It seems that key
        # events will not be processed without an mpl figure manager.
        # However, a figure manager will create a new toplevel window,
        # which is certainly not desired in this case. This appears to
        # be a limitation of matplotlib. The canvas is manually set to
        # visible, or QVBoxLayout will ignore it for size hinting.
        figure = self.declaration.figure
        if figure:
            canvas = FigureCanvasQTAgg(figure)
            canvas.setParent(widget)
            canvas.setFocusPolicy(Qt.ClickFocus)
            canvas.setVisible(True)
            toolbar = NavigationToolbar2QTAgg(canvas, widget)
            toolbar.setVisible(self.declaration.toolbar_visible)
            layout.addWidget(toolbar)
            layout.addWidget(canvas)

########NEW FILE########
__FILENAME__ = qt_multiline_field
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Int, Typed

from enaml.widgets.multiline_field import ProxyMultilineField

from .QtCore import QTimer, Signal
from .QtGui import QTextEdit

from .qt_control import QtControl


class QMultilineEdit(QTextEdit):
    """ A QTextEdit which notifies on a collapsing timer.

    """
    #: A signal emitted on a collapsing timer. Delayed text must be
    #: enabled for this signal to be fired.
    delayedTextChanged = Signal()

    #: Internal storage for the timer object.
    _dtimer = None

    def delayedTextEnabled(self):
        """ Get when the delayedTextChanged signal is enabled.

        """
        return self._dtimer is not None

    def setDelayedTextEnabled(self, enabled):
        """ Set whether the delayedTextChanged signal is enabled.

        """
        if enabled:
            if not self._dtimer:
                self._dtimer = timer = QTimer()
                timer.setInterval(300)
                timer.setSingleShot(True)
                timer.timeout.connect(self.delayedTextChanged)
                self.textChanged.connect(timer.start)
        else:
            if self._dtimer:
                self.textChanged.disconnect(self._dtimer.start)
                self._dtimer.timeout.disconnect(self.delayedTextChanged)
                self._dtimer = None


#: cyclic notification guard flag
TEXT_GUARD = 0x1


class QtMultilineField(QtControl, ProxyMultilineField):
    """ A Qt4 implementation of an Enaml ProxyMultilineField.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QMultilineEdit)

    #: A bitfield of guard flags.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Creates the underlying QFocusMultiLineEdit widget.

        """
        self.widget = QMultilineEdit(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(QtMultilineField, self).init_widget()
        d = self.declaration
        self.set_text(d.text)
        self.set_read_only(d.read_only)
        self.set_auto_sync_text(d.auto_sync_text)
        self.widget.delayedTextChanged.connect(self.on_delayed_text_changed)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_delayed_text_changed(self):
        """ The signal handler for 'delayedTextChanged' signal.

        This handler will only be invoked if auto sync is enabled on the
        declaration.

        """
        self.sync_text()

    #--------------------------------------------------------------------------
    # ProxyMultilineField API
    #--------------------------------------------------------------------------
    def set_text(self, text):
        """ Set the text in the underlying widget.

        """
        if not self._guard & TEXT_GUARD:
            self._guard |= TEXT_GUARD
            try:
                self.widget.setText(text)
            finally:
                self._guard &= ~TEXT_GUARD

    def set_read_only(self, read_only):
        """ Set whether or not the widget is read only.

        """
        self.widget.setReadOnly(read_only)

    def set_auto_sync_text(self, sync):
        """ Set the auto sync text behavior on the widget.

        """
        self.widget.setDelayedTextEnabled(sync)

    def sync_text(self):
        """ Force syncronize the text.

        """
        if not self._guard & TEXT_GUARD:
            self._guard |= TEXT_GUARD
            try:
                self.declaration.text = self.widget.toPlainText()
            finally:
                self._guard &= ~TEXT_GUARD

    def field_text(self):
        """ Get the text in the field.

        """
        return self.widget.toPlainText()

########NEW FILE########
__FILENAME__ = qt_notebook
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import sys
from weakref import WeakKeyDictionary

from atom.api import Int, IntEnum, Typed

from enaml.widgets.notebook import ProxyNotebook

from .QtCore import Qt, QEvent, QSize, Signal
from .QtGui import (
    QTabWidget, QTabBar, QResizeEvent, QApplication, QStackedWidget
)

from .qt_constraints_widget import QtConstraintsWidget
from .qt_page import QtPage


TAB_POSITIONS = {
    'top': QTabWidget.North,
    'bottom': QTabWidget.South,
    'left': QTabWidget.West,
    'right': QTabWidget.East,
}


DOCUMENT_MODES = {
    'document': True,
    'preferences': False,
}


class QNotebook(QTabWidget):
    """ A custom QTabWidget which handles children of type QPage.

    """
    class SizeHintMode(IntEnum):
        """ An int enum defining the size hint modes of the notebook.

        """
        #: The size hint is the union of all tabs.
        Union = 0

        #: The size hint is the size hint of the current tab.
        Current = 1

    #: Proxy the SizeHintMode values as if it were an anonymous enum.
    Union = SizeHintMode.Union
    Current = SizeHintMode.Current

    #: A signal emitted when a LayoutRequest event is posted to the
    #: notebook widget. This will typically occur when the size hint
    #: of the notebook is no longer valid.
    layoutRequested = Signal()

    def __init__(self, *args, **kwargs):
        """ Initialize a QNotebook.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to create
            a QTabWidget.

        """
        super(QNotebook, self).__init__(*args, **kwargs)
        self.tabCloseRequested.connect(self.onTabCloseRequested)
        self._hidden_pages = WeakKeyDictionary()
        self._size_hint = QSize()
        self._min_size_hint = QSize()
        self._size_hint_mode = QNotebook.Union

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _refreshTabBar(self):
        """ Trigger an immediate relayout and refresh of the tab bar.

        """
        # The public QTabBar api does not provide a way to trigger the
        # 'layoutTabs' method of QTabBarPrivate and there are certain
        # operations (such as modifying a tab close button) which need
        # to have that happen. This method provides a workaround by
        # sending a dummy resize event to the tab bar, followed by one
        # to the tab widget.
        app = QApplication.instance()
        if app is not None:
            bar = self.tabBar()
            size = bar.size()
            event = QResizeEvent(size, size)
            app.sendEvent(bar, event)
            size = self.size()
            event = QResizeEvent(size, size)
            app.sendEvent(self, event)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def onTabCloseRequested(self, index):
        """ The handler for the 'tabCloseRequested' signal.

        """
        self.widget(index).requestClose()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def event(self, event):
        """ A custom event handler which handles LayoutRequest events.

        When a LayoutRequest event is posted to this widget, it will
        emit the `layoutRequested` signal. This allows an external
        consumer of this widget to update their external layout.

        """
        res = super(QNotebook, self).event(event)
        if event.type() == QEvent.LayoutRequest:
            self._size_hint = QSize()
            self._min_size_hint = QSize()
            self.layoutRequested.emit()
        return res

    def sizeHint(self):
        """ A reimplemented size hint handler.

        """
        # Cached for performance. Invalidated on a layout request.
        hint = self._size_hint
        if hint.isValid():
            return hint
        # QTabWidget does not allow assigning a custom QStackedWidget,
        # so the default sizeHint is computed, and the effects of the
        # stack size hint are replaced by the current tab's size hint.
        hint = super(QNotebook, self).sizeHint()
        if self._size_hint_mode == QNotebook.Current:
            stack = self.findChild(QStackedWidget)
            if stack is not None:
                curr = stack.currentWidget()
                if curr is not None:
                    hint -= stack.sizeHint()
                    hint += curr.sizeHint()
        self._size_hint = hint
        return hint

    def minimumSizeHint(self):
        """ A reimplemented minimum size hint handler.

        """
        # Cached for performance. Invalidated on a layout request.
        hint = self._size_hint
        if hint.isValid():
            return hint
        # QTabWidget does not allow assigning a custom QStackedWidget,
        # so the default minimumSizeHint is computed, and the effects
        # of the stack size hint are replaced by the current tab's
        # minimum size hint.
        hint = super(QNotebook, self).minimumSizeHint()
        if self._size_hint_mode == QNotebook.Current:
            stack = self.findChild(QStackedWidget)
            if stack is not None:
                curr = stack.currentWidget()
                if curr is not None:
                    hint -= stack.minimumSizeHint()
                    hint += curr.minimumSizeHint()
        self._size_hint = hint
        return hint

    def sizeHintMode(self):
        """ Get the size hint mode of the notebook.

        Returns
        -------
        result : QNotebook.SizeHintMode
            The size hint mode enum value for the notebook.

        """
        return self._size_hint_mode

    def setSizeHintMode(self, mode):
        """ Set the size hint mode of the notebook.

        Parameters
        ----------
        mode : QNotebook.SizeHintMode
            The size hint mode for the notebook.

        """
        assert isinstance(mode, QNotebook.SizeHintMode)
        self._size_hint = QSize()
        self._min_size_hint = QSize()
        self._size_hint_mode = mode

    def showPage(self, page):
        """ Show a hidden QPage instance in the notebook.

        If the page is not owned by the notebook, this is a no-op.

        Parameters
        ----------
        page : QPage
            The hidden QPage instance to show in the notebook.

        """
        index = self.indexOf(page)
        if index == -1:
            index = self._hidden_pages.pop(page, -1)
            if index != -1:
                self.insertPage(index, page)

    def hidePage(self, page):
        """ Hide the given QPage instance in the notebook.

        If the page is not owned by the notebook, this is a no-op.

        Parameters
        ----------
        page : QPage
            The QPage instance to hide in the notebook.

        """
        index = self.indexOf(page)
        if index != -1:
            self.removeTab(index)
            page.hide()
            self._hidden_pages[page] = index

    def addPage(self, page):
        """ Add a QPage instance to the notebook.

        This method should be used in favor of the 'addTab' method.

        Parameters
        ----------
        page : QPage
            The QPage instance to add to the notebook.

        """
        self.insertPage(self.count(), page)

    def insertPage(self, index, page):
        """ Insert a QPage instance into the notebook.

        This should be used in favor of the 'insertTab' method.

        Parameters
        ----------
        index : int
            The index at which to insert the page.

        page : QPage
            The QPage instance to add to the notebook.

        """
        if page.isOpen():
            index = min(index, self.count())
            self.insertTab(index, page, page.title())
            self.setTabIcon(index, page.icon())
            self.setTabToolTip(index, page.toolTip())
            self.setTabEnabled(index, page.isTabEnabled())
            self.setTabCloseButtonVisible(index, page.isClosable())
        else:
            page.hide()
            self._hidden_pages[page] = index

    def removePage(self, page):
        """ Remove a QPage instance from the notebook.

        If the page does not exist in the notebook, this is a no-op.

        Parameters
        ----------
        page : QPage
            The QPage instance to remove from the notebook.

        """
        index = self.indexOf(page)
        if index != -1:
            self.removeTab(index)
            page.hide()

    def setTabCloseButtonVisible(self, index, visible, refresh=True):
        """ Set whether the close button for the given tab is visible.

        The 'tabsClosable' property must be set to True for this to
        have effect.

        Parameters
        ----------
        index : int
            The index of the target page.

        visible : bool
            Whether or not the close button for the tab should be
            visible.

        refresh : bool, optional
            Whether or not to refresh the tab bar at the end of the
            operation. The default is True.

        """
        # When changing the visibility of a button, we also change its
        # size so that the tab can layout properly.
        if index >= 0 and index < self.count():
            tabBar = self.tabBar()
            btn1 = tabBar.tabButton(index, QTabBar.LeftSide)
            btn2 = tabBar.tabButton(index, QTabBar.RightSide)
            if btn1 is not None:
                btn1.setVisible(visible)
                if not visible:
                    btn1.resize(0, 0)
                else:
                    btn1.resize(btn1.sizeHint())
            if btn2 is not None:
                btn2.setVisible(visible)
                if not visible:
                    btn2.resize(0, 0)
                else:
                    btn2.resize(btn2.sizeHint())
            if refresh:
                self._refreshTabBar()

    def setTabsClosable(self, closable):
        """ Set the tab closable state for the widget.

        This is an overridden parent class method which extends the
        logic to account for the closable state on the individual
        pages.

        Parameters
        ----------
        closable : bool
            Whether or not the tabs should be closable.

        """
        super(QNotebook, self).setTabsClosable(closable)
        # When setting tabs closable to False, the default logic of
        # QTabBar is to delete the close button on the tab. When the
        # closable flag is set to True a new close button is created
        # for every tab, unless one has already been provided. This
        # means we need to make an extra pass over each tab to sync
        # the state of the buttons when the flag is set to True.
        if closable:
            setVisible = self.setTabCloseButtonVisible
            for index in xrange(self.count()):
                page = self.widget(index)
                setVisible(index, page.isClosable(), refresh=False)
        self._refreshTabBar()


#: A mapping Enaml -> Qt size hint modes.
SIZE_HINT_MODE = {
    'union': QNotebook.Union,
    'current': QNotebook.Current,
}


#: A guard flag for the tab change
CHANGE_GUARD = 0x01


class QtNotebook(QtConstraintsWidget, ProxyNotebook):
    """ A Qt implementation of an Enaml ProxyNotebook.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QNotebook)

    #: A bitfield of guard flags for the object.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying notebook widget.

        """
        widget = QNotebook(self.parent_widget())
        if sys.platform == 'darwin':
            # On OSX, the widget item layout rect is too small.
            # Setting this attribute forces the widget item to
            # use the widget rect for layout.
            widget.setAttribute(Qt.WA_LayoutUsesWidgetRect, True)
        self.widget = widget

    def init_widget(self):
        """ Initialize the underyling widget.

        """
        super(QtNotebook, self).init_widget()
        d = self.declaration
        self.set_tab_style(d.tab_style)
        self.set_tab_position(d.tab_position)
        self.set_tabs_closable(d.tabs_closable)
        self.set_tabs_movable(d.tabs_movable)
        self.set_size_hint_mode(d.size_hint_mode, update=False)
        # the selected tab is synchronized during init_layout

    def init_layout(self):
        """ Handle the layout initialization for the notebook.

        """
        super(QtNotebook, self).init_layout()
        widget = self.widget
        for page in self.pages():
            widget.addPage(page)
        self.init_selected_tab()
        widget.layoutRequested.connect(self.on_layout_requested)
        widget.currentChanged.connect(self.on_current_changed)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def pages(self):
        """ Get the pages defined for the notebook.

        """
        for p in self.declaration.pages():
            w = p.proxy.widget
            if w is not None:
                yield w

    def find_page(self, name):
        """ Find the page with the given name.

        Parameters
        ----------
        name : unicode
            The object name for the page of interest.

        Returns
        -------
        result : QPage or None
            The target page or None if one is not found.

        """
        for page in self.pages():
            if page.objectName() == name:
                return page

    def init_selected_tab(self):
        """ Initialize the selected tab.

        This should be called only during widget initialization.

        """
        d = self.declaration
        if d.selected_tab:
            self.set_selected_tab(d.selected_tab)
        else:
            current = self.widget.currentWidget()
            name = current.objectName() if current is not None else u''
            self._guard |= CHANGE_GUARD
            try:
                d.selected_tab = name
            finally:
                self._guard &= ~CHANGE_GUARD

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a QtNotebook.

        """
        super(QtNotebook, self).child_added(child)
        if isinstance(child, QtPage):
            for index, dchild in enumerate(self.children()):
                if child is dchild:
                    self.widget.insertPage(index, child.widget)

    def child_removed(self, child):
        """ Handle the child removed event for a QtNotebook.

        """
        super(QtNotebook, self).child_removed(child)
        if isinstance(child, QtPage):
            self.widget.removePage(child.widget)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_layout_requested(self):
        """ Handle the `layoutRequested` signal from the QNotebook.

        """
        self.geometry_updated()

    def on_current_changed(self):
        """ Handle the 'currentChanged' signal from the QNotebook.

        """
        if not self._guard & CHANGE_GUARD:
            self._guard |= CHANGE_GUARD
            try:
                page = self.widget.currentWidget()
                name = page.objectName() if page is not None else u''
                self.declaration.selected_tab = name
            finally:
                self._guard &= ~CHANGE_GUARD

    #--------------------------------------------------------------------------
    # ProxyNotebook API
    #--------------------------------------------------------------------------
    def set_tab_style(self, style):
        """ Set the tab style for the tab bar in the widget.

        """
        self.widget.setDocumentMode(DOCUMENT_MODES[style])

    def set_tab_position(self, position):
        """ Set the position of the tab bar in the widget.

        """
        self.widget.setTabPosition(TAB_POSITIONS[position])

    def set_tabs_closable(self, closable):
        """ Set whether or not the tabs are closable.

        """
        self.widget.setTabsClosable(closable)

    def set_tabs_movable(self, movable):
        """ Set whether or not the tabs are movable.

        """
        self.widget.setMovable(movable)

    def set_selected_tab(self, name):
        """ Set the selected tab of the widget.

        """
        if not self._guard & CHANGE_GUARD:
            page = self.find_page(name)
            if page is None:
                import warnings
                msg = "cannot select tab '%s' - tab not found"
                warnings.warn(msg % name, UserWarning)
                return
            self._guard |= CHANGE_GUARD
            try:
                self.widget.setCurrentWidget(page)
            finally:
                self._guard &= ~CHANGE_GUARD

    def set_size_hint_mode(self, mode, update=True):
        """ Set the size hint mode for the widget.

        """
        self.widget.setSizeHintMode(SIZE_HINT_MODE[mode])
        if update:
            self.geometry_updated()

########NEW FILE########
__FILENAME__ = qt_object_combo
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Int, Typed

from enaml.widgets.object_combo import ProxyObjectCombo

from .QtCore import QTimer
from .QtGui import QComboBox

from .q_resource_helpers import get_cached_qicon
from .qt_control import QtControl


# cyclic notification guard flags
SELECTED_GUARD = 0x1


class ComboRefreshTimer(QTimer):
    """ A QTimer used for collapsing items refresh requests.

    This is a single shot timer which automatically cleans itself up
    when its timer event is triggered.

    """
    def __init__(self, owner):
        """ Initialize a ComboRefreshTimer.

        Parameters
        ----------
        owner : QtObjectCombo
            The object combo which owns the timer.

        """
        super(ComboRefreshTimer, self).__init__()
        self.setSingleShot(True)
        self.owner = owner

    def timerEvent(self, event):
        """ Handle the timer event for the timer.

        This handler will call the 'refresh_items' method on the owner
        and then release all references to itself and the owner.

        """
        super(ComboRefreshTimer, self).timerEvent(event)
        owner = self.owner
        if owner is not None:
            del owner.refresh_timer
            self.owner = None
            owner.refresh_items()


class QtObjectCombo(QtControl, ProxyObjectCombo):
    """ A Qt implementation of an Enaml ProxyObjectCombo.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QComboBox)

    #: A single shot refresh timer for queing combo refreshes.
    refresh_timer = Typed(ComboRefreshTimer)

    #: Cyclic notification guard. This a bitfield of multiple guards.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Default Value Handlers
    #--------------------------------------------------------------------------
    def _default_refresh_timer(self):
        """ Get a refresh timer for the object combo box.

        """
        return ComboRefreshTimer(self)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the QComboBox widget.

        """
        self.widget = QComboBox(self.parent_widget())
        self.widget.setInsertPolicy(QComboBox.NoInsert)

    def init_widget(self):
        """ Create and initialize the underlying widget.

        """
        super(QtObjectCombo, self).init_widget()
        self.refresh_items()
        self.widget.currentIndexChanged.connect(self.on_index_changed)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_index_changed(self, index):
        """ The signal handler for the index changed signal.

        """
        if not self._guard & SELECTED_GUARD:
            self._guard |= SELECTED_GUARD
            try:
                item = self.declaration.items[index]
                self.declaration.selected = item
            finally:
                self._guard &= ~SELECTED_GUARD

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def refresh_items(self):
        """ Refresh the items in the combo box.

        """
        d = self.declaration
        selected = d.selected
        to_string = d.to_string
        to_icon = d.to_icon
        widget = self.widget
        self._guard |= SELECTED_GUARD
        try:
            widget.clear()
            target_index = -1
            for index, item in enumerate(d.items):
                text = to_string(item)
                icon = to_icon(item)
                if icon is None:
                    qicon = None
                else:
                    qicon = get_cached_qicon(icon)
                if qicon is None:
                    widget.addItem(text)
                else:
                    widget.addItem(qicon, text)
                if item == selected:
                    target_index = index
            widget.setCurrentIndex(target_index)
        finally:
            self._guard &= ~SELECTED_GUARD

    #--------------------------------------------------------------------------
    # ProxyObjectCombo API
    #--------------------------------------------------------------------------
    def set_selected(self, selected):
        """ Set the selected object in the combo box.

        """
        if not self._guard & SELECTED_GUARD:
            self._guard |= SELECTED_GUARD
            try:
                d = self.declaration
                try:
                    index = d.items.index(selected)
                except ValueError:
                    index = -1
                self.widget.setCurrentIndex(index)
            finally:
                self._guard &= ~SELECTED_GUARD

    def set_editable(self, editable):
        """ Set whether the combo box is editable.

        """
        # The update is needed to avoid artificats (at least on Windows)
        widget = self.widget
        widget.setEditable(editable)
        widget.update()

    def request_items_refresh(self):
        """ Request a refresh of the combo box items.

        """
        self.refresh_timer.start()

########NEW FILE########
__FILENAME__ = qt_page
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.page import ProxyPage

from .QtCore import Signal
from .QtGui import QFrame, QIcon

from .q_resource_helpers import get_cached_qicon
from .q_single_widget_layout import QSingleWidgetLayout
from .qt_container import QtContainer
from .qt_widget import QtWidget


class QPage(QFrame):
    """ A QFrame subclass which acts as a page in a QNotebook.

    """
    #: A signal emitted when the page has been closed by the user.
    pageClosed = Signal()

    def __init__(self, *args, **kwargs):
        """ Initialize a QPage.

        Parameters
        ----------
        *args, **kwargs
            The position and keyword arguments required to initialize
            a QWidget.

        """
        super(QPage, self).__init__(*args, **kwargs)
        self._title = u''
        self._tool_tip = u''
        self._icon = QIcon()
        self._closable = True
        self._is_enabled = True
        self._is_open = True
        self._page_widget = None
        self.setLayout(QSingleWidgetLayout())

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _findNotebook(self):
        """ Get the parent QNotebook for this page.

        Returns
        -------
        result : QNotebook or None
            The parent QNotebook for this page, or None if one cannot
            be found.

        """
        # Avoid a circular import with the qt_notebook module
        from .qt_notebook import QNotebook
        # Depending on where we are during initialization, the notebook
        # will be either our parent or grandparent because of how the
        # QTabWidget reparents things internally.
        parent = self.parent()
        if isinstance(parent, QNotebook):
            return parent
        if parent is not None:
            parent = parent.parent()
            if isinstance(parent, QNotebook):
                return parent

    def _pageIndexOperation(self, closure):
        """ A private method which will run the given closure if there
        is a valid index for this page.

        """
        notebook = self._findNotebook()
        if notebook is not None:
            index = notebook.indexOf(self)
            if index != -1:
                closure(notebook, index)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def requestClose(self):
        """ A method called by the parent notebook when the user has
        requested that this page be closed.

        If the page is marked as closable, then it will be closed and
        the 'pageClosed' signal will be emitted.

        """
        if self.isClosable():
            self.close()
            self.pageClosed.emit()

    def pageWidget(self):
        """ Get the page widget for this page.

        Returns
        -------
        result : QWidget or None
            The page widget being managed by this page.

        """
        return self._page_widget

    def setPageWidget(self, widget):
        """ Set the page widget for this page.

        Parameters
        ----------
        widget : QWudget
            The Qt widget to use as the page widget in this page.

        """
        self._page_widget = widget
        self.layout().setWidget(widget)

    def isOpen(self):
        """ Get whether or not the page is open.

        Returns
        -------
        result : bool
            True if the page is open, False otherwise.

        """
        return self._is_open

    def show(self):
        """ Show the page in the notebook.

        """
        self._is_open = True
        notebook = self._findNotebook()
        if notebook is not None:
            notebook.showPage(self)

    def hide(self):
        """ Hide the page in the notebook.

        """
        self._is_open = False
        notebook = self._findNotebook()
        if notebook is not None:
            notebook.hidePage(self)

    def isTabEnabled(self):
        """ Return whether or not the tab for this page is enabled.

        This method should be used in favor of isEnabled.

        Returns
        -------
        result : bool
            True if the tab for this page is enabled, False otherwise.

        """
        return self._is_enabled

    def setTabEnabled(self, enabled):
        """ Set whether the tab for this page is enabled.

        This method should be used in favor of isEnabled.

        Parameters
        ----------
        enabled : bool
            True if the tab should be enabled, False otherwise.

        """
        self._is_enabled = enabled
        def closure(nb, index):
            nb.setTabEnabled(index, enabled)
        self._pageIndexOperation(closure)

    def title(self):
        """ Returns the tab title for this page.

        Returns
        -------
        result : unicode
            The title string for the page's tab.

        """
        return self._title

    def setTitle(self, title):
        """ Set the title for the tab for this page.

        Parameters
        ----------
        title : unicode
            The string to use for this page's tab title.

        """
        self._title = title
        def closure(nb, index):
            nb.setTabText(index, title)
        self._pageIndexOperation(closure)

    def isClosable(self):
        """ Returns whether or not the tab for this page is closable.

        Returns
        -------
        result : bool
            True if this page's tab is closable, False otherwise.

        """
        return self._closable

    def setClosable(self, closable):
        """ Set whether the tab for this page is closable.

        Parameters
        ----------
        closable : bool
            True if the tab should be closable, False otherwise.

        """
        self._closable = closable
        def closure(nb, index):
            nb.setTabCloseButtonVisible(index, closable)
        self._pageIndexOperation(closure)

    def toolTip(self):
        """ Returns the tool tip for the tab for this page.

        Returns
        -------
        result : unicode
            The tool tip string for the page's tab.

        """
        return self._tool_tip

    def setToolTip(self, tool_tip):
        """ Set the tool tip for the tab for this page.

        This overrides the default implementation to set the tool tip
        on the notebook tab.

        Parameters
        ----------
        title : unicode
            The string to use for this page's tab tool tip.

        """
        self._tool_tip = tool_tip
        def closure(nb, index):
            nb.setTabToolTip(index, tool_tip)
        self._pageIndexOperation(closure)

    def icon(self):
        """ Get the icon for the page.

        Returns
        -------
        result : QIcon
            The icon for the page.

        """
        return self._icon

    def setIcon(self, icon):
        """ Set the icon for the page.

        Parameters
        ----------
        icon : QIcon
            The icon for the page.

        """
        self._icon = icon
        def closure(nb, index):
            nb.setTabIcon(index, icon)
        self._pageIndexOperation(closure)


class QtPage(QtWidget, ProxyPage):
    """ A Qt implementation of an Enaml ProxyPage.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QPage)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying page widget.

        """
        self.widget = QPage(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(QtPage, self).init_widget()
        d = self.declaration
        self.set_title(d.title)
        self.set_closable(d.closable)
        if d.icon:
            self.set_icon(d.icon)
        self.widget.pageClosed.connect(self.on_page_closed)

    def init_layout(self):
        """ Initialize the layout for the underyling widget.

        """
        super(QtPage, self).init_layout()
        self.widget.setPageWidget(self.page_widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def page_widget(self):
        """ Find and return the page widget child for this widget.

        """
        p = self.declaration.page_widget()
        if p is not None:
            return p.proxy.widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a QtPage.

        """
        super(QtPage, self).child_removed(child)
        if isinstance(child, QtContainer):
            self.widget.setPageWidget(self.page_widget())

    def child_removed(self, child):
        """ Handle the child removed event for a QtPage.

        """
        super(QtPage, self).child_removed(child)
        if isinstance(child, QtContainer):
            self.widget.setPageWidget(self.page_widget())

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_page_closed(self):
        """ The signal handler for the 'pageClosed' signal.

        """
        self.declaration._handle_close()

    #--------------------------------------------------------------------------
    # ProxyPage API
    #--------------------------------------------------------------------------
    def set_visible(self, visible):
        """ An overridden visibility setter which to opens|closes the
        notebook page.

        """
        if visible:
            self.widget.show()
        else:
            self.widget.hide()

    def ensure_visible(self):
        """ An overridden visibility setter which to opens|closes the
        notebook page.

        """
        self.set_visible(True)

    def ensure_hidden(self):
        """ An overridden visibility setter which to opens|closes the
        notebook page.

        """
        self.set_visible(False)

    def set_enabled(self, enabled):
        """ An overridden enabled setter which sets the tab enabled
        state.

        """
        self.widget.setTabEnabled(enabled)

    def set_title(self, title):
        """ Set the title of the tab for this page.

        """
        self.widget.setTitle(title)

    def set_icon(self, icon):
        """ Sets the widget's icon to the provided image.

        """
        if icon:
            qicon = get_cached_qicon(icon)
        else:
            qicon = QIcon()
        self.widget.setIcon(qicon)

    def set_closable(self, closable):
        """ Set whether or not this page is closable.

        """
        self.widget.setClosable(closable)

########NEW FILE########
__FILENAME__ = qt_popup_view
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.popup_view import ProxyPopupView

from .QtCore import Qt, QPointF, QPoint

from .q_popup_view import QPopupView, ArrowEdge, AnchorMode
from .qt_widget import QtWidget


EDGES = {
    'left': ArrowEdge.Left,
    'right': ArrowEdge.Right,
    'top': ArrowEdge.Top,
    'bottom': ArrowEdge.Bottom,
}


WINDOW_TYPES = {
    'popup': Qt.Popup,
    'tool_tip': Qt.ToolTip,
    'window': Qt.Window,
}


ANCHOR_MODE = {
    'parent': AnchorMode.Parent,
    'cursor': AnchorMode.Cursor,
}


class QtPopupView(QtWidget, ProxyPopupView):
    """ A Qt implementation of an Enaml ProxyPopupView.

    """
    #: A reference to the toolkit widget created by the proxy.
    widget = Typed(QPopupView)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the QPopupView widget.

        """
        d = self.declaration
        flags = WINDOW_TYPES[d.window_type]
        self.widget = QPopupView(self.parent_widget(), flags)
        if d.translucent_background:
            self.widget.setAttribute(Qt.WA_TranslucentBackground)

    def init_widget(self):
        """ Initialize the widget.

        """
        super(QtPopupView, self).init_widget()
        d = self.declaration
        self.set_anchor(d.anchor)
        self.set_anchor_mode(d.anchor_mode)
        self.set_parent_anchor(d.parent_anchor)
        self.set_arrow_size(d.arrow_size)
        self.set_arrow_edge(d.arrow_edge)
        self.set_offset(d.offset)
        self.set_timeout(d.timeout)
        self.set_fade_in_duration(d.fade_in_duration)
        self.set_fade_out_duration(d.fade_out_duration)
        self.set_close_on_click(d.close_on_click)
        self.widget.closed.connect(self.on_closed)

    def init_layout(self):
        """ Initialize the widget layout.

        """
        super(QtPopupView, self).init_layout()
        self.widget.setCentralWidget(self.central_widget())

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def central_widget(self):
        """ Find and return the central widget child for this widget.

        Returns
        -------
        result : QWidget or None
            The central widget defined for this widget, or None if one
            is not defined.

        """
        d = self.declaration.central_widget()
        if d is not None:
            return d.proxy.widget

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_closed(self):
        """ The signal handler for the 'closed' signal.

        This handler will notify the declaration object that the popup
        view has closed.

        """
        d = self.declaration
        if d is not None:
            d._popup_closed()

    #--------------------------------------------------------------------------
    # ProxyBubbleView API
    #--------------------------------------------------------------------------
    def set_anchor(self, anchor):
        """ Set the anchor location on the underlying widget.

        """
        self.widget.setAnchor(QPointF(*anchor))

    def set_anchor_mode(self, mode):
        """ Set the anchor mode on the underlying widget.

        """
        self.widget.setAnchorMode(ANCHOR_MODE[mode])

    def set_parent_anchor(self, anchor):
        """ Set the parent anchor location on the underlying widget.

        """
        self.widget.setParentAnchor(QPointF(*anchor))

    def set_arrow_size(self, size):
        """ Set the size of the arrow on the underlying widget.

        """
        self.widget.setArrowSize(size)

    def set_arrow_edge(self, edge):
        """ Set the arrow edge on the underlying widget.

        """
        self.widget.setArrowEdge(EDGES[edge])

    def set_offset(self, offset):
        """ Set the offset of the underlying widget.

        """
        self.widget.setOffset(QPoint(*offset))

    def set_timeout(self, timeout):
        """ Set the timeout for the underlying widget.

        """
        self.widget.setTimeout(timeout)

    def set_fade_in_duration(self, duration):
        """ Set the fade in duration for the underlying widget.

        """
        self.widget.setFadeInDuration(duration)

    def set_fade_out_duration(self, duration):
        """ Set the fade out duration for the underlying widget.

        """
        self.widget.setFadeOutDuration(duration)

    def set_close_on_click(self, enable):
        """ Set the close on click flag for the underlying widget.

        """
        self.widget.setCloseOnClick(enable)

    def close(self):
        """ Close the underlying popup widget.

        """
        self.widget.close()

########NEW FILE########
__FILENAME__ = qt_progress_bar
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.progress_bar import ProxyProgressBar

from .QtGui import QProgressBar

from .qt_control import QtControl


class QtProgressBar(QtControl, ProxyProgressBar):
    """ A Qt implementation of an Enaml ProxyProgressBar.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QProgressBar)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying progress bar widget.

        """
        self.widget = QProgressBar(self.parent_widget())

    def init_widget(self):
        """ Create and initialize the underlying widget.

        """
        super(QtProgressBar, self).init_widget()
        d = self.declaration
        self.set_minimum(d.minimum)
        self.set_maximum(d.maximum)
        self.set_value(d.value)
        self.set_text_visible(d.text_visible)

    #--------------------------------------------------------------------------
    # ProxyProgressBar API
    #--------------------------------------------------------------------------
    def set_minimum(self, value):
        """ Set the minimum value of the widget.

        """
        self.widget.setMinimum(value)

    def set_maximum(self, value):
        """ Set the maximum value of the widget.

        """
        self.widget.setMaximum(value)

    def set_value(self, value):
        """ Set the value of the widget.

        """
        self.widget.setValue(value)

    def set_text_visible(self, visible):
        """ Set the text visibility on the widget.

        """
        self.widget.setTextVisible(visible)

########NEW FILE########
__FILENAME__ = qt_push_button
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.push_button import ProxyPushButton

from .QtGui import QPushButton

from .qt_abstract_button import QtAbstractButton
from .qt_menu import QtMenu


class QtPushButton(QtAbstractButton, ProxyPushButton):
    """ A Qt implementation of an Enaml ProxyPushButton.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QPushButton)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying QPushButton widget.

        """
        self.widget = QPushButton(self.parent_widget())

    def init_widget(self):
        """ Initialize the state of the widget.

        """
        super(QtPushButton, self).init_widget()
        self.set_default(self.declaration.default)

    def init_layout(self):
        """ Handle layout initialization for the push button.

        """
        super(QtPushButton, self).init_layout()
        self.widget.setMenu(self.menu())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def menu(self):
        """ Find and return the menu child for this widget.

        Returns
        -------
        result : QMenu or None
            The menu defined for this widget, or None if not defined.

        """
        m = self.declaration.menu()
        if m is not None:
            return m.proxy.widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a QtPushButton.

        """
        super(QtPushButton, self).child_added(child)
        if isinstance(child, QtMenu):
            self.widget.setMenu(self.menu())

    def child_removed(self, child):
        """ Handle the child removed event for a QtPushButton.

        """
        super(QtPushButton, self).child_removed(child)
        if isinstance(child, QtMenu):
            self.widget.setMenu(self.menu())

    #--------------------------------------------------------------------------
    # ProxyPushButton API
    #--------------------------------------------------------------------------
    def set_default(self, default):
        """ Set the default button behavior for the widget.

        """
        self.widget.setDefault(default)
        if default:
            self.widget.setFocus()

########NEW FILE########
__FILENAME__ = qt_radio_button
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.radio_button import ProxyRadioButton

from .QtGui import QRadioButton

from .qt_abstract_button import QtAbstractButton


class QtRadioButton(QtAbstractButton, ProxyRadioButton):
    """ A Qt implementation of an Enaml RadioButton.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QRadioButton)

    def create_widget(self):
        """ Create the underlying radio button widget.

        """
        self.widget = QRadioButton(self.parent_widget())

########NEW FILE########
__FILENAME__ = qt_raw_widget
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from enaml.widgets.raw_widget import ProxyRawWidget

from .qt_control import QtControl


class QtRawWidget(QtControl, ProxyRawWidget):
    """ A Qt implementation of an Enaml ProxyRawWidget.

    """
    def create_widget(self):
        """ Create the underlying widget for the control.

        """
        self.widget = self.declaration.create_widget(self.parent_widget())

    #--------------------------------------------------------------------------
    # ProxyRawWidget API
    #--------------------------------------------------------------------------
    def get_widget(self):
        """ Retrieve the underlying toolkit widget.

        """
        return self.widget

########NEW FILE########
__FILENAME__ = qt_scintilla
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from . import QT_API
if QT_API != 'pyqt':
    msg = 'the Qt Scintilla widget is only available when using PyQt'
    raise ImportError(msg)

import logging
import sys
import weakref

from atom.api import Typed

from enaml.colors import parse_color
from enaml.fonts import parse_font
from enaml.scintilla.scintilla import ProxyScintilla

from PyQt4 import Qsci

from .QtGui import QColor, QFont

from .q_resource_helpers import QColor_from_Color, QFont_from_Font
from .qt_control import QtControl
from .scintilla_lexers import LEXERS, LEXERS_INV
from .scintilla_tokens import TOKENS


#: The module-level logger
logger = logging.getLogger(__name__)


Base = Qsci.QsciScintillaBase


if sys.platform == 'win32':
    DEFAULT_EOL = 'crlf'
elif sys.platform == 'darwin':
    DEFAULT_EOL = 'cr'
else:
    DEFAULT_EOL = 'lf'


EOL_MODE = {
    'crlf': Base.SC_EOL_CRLF,
    'cr': Base.SC_EOL_CR,
    'lf': Base.SC_EOL_LF,
}


EDGE_MODE = {
    'none': Base.EDGE_NONE,
    'line': Base.EDGE_LINE,
    'background': Base.EDGE_BACKGROUND,
}


INDENTATION_GUIDES = {
    'none': Base.SC_IV_NONE,
    'real': Base.SC_IV_REAL,
    'look_forward': Base.SC_IV_LOOKFORWARD,
    'look_both': Base.SC_IV_LOOKBOTH,
}


WHITE_SPACE = {
    'visible_always': Base.SCWS_VISIBLEALWAYS,
    'visible_after_indent': Base.SCWS_VISIBLEAFTERINDENT,
    'invisible': Base.SCWS_INVISIBLE,
}


def _make_color(color_str):
    """ A function which converts a color string into a QColor.

    """
    color = parse_color(color_str)
    if color is not None:
        return QColor_from_Color(color)
    return QColor()


def _make_font(font_str):
    """ A function which converts a font string into a QColor.

    """
    font = parse_font(font_str)
    if font is not None:
        return QFont_from_Font(font)
    return QFont()


class QtScintilla(QtControl, ProxyScintilla):
    """ A Qt implementation of an Enaml ProxyScintilla.

    """
    #: A weak cache which maps uuid -> QsciDocument.
    qsci_doc_cache = weakref.WeakValueDictionary()

    #: A reference to the widget created by the proxy.
    widget = Typed(Qsci.QsciScintilla)

    #: A strong reference to the QsciDocument handle.
    qsci_doc = Typed(Qsci.QsciDocument)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying label widget.

        """
        self.widget = Qsci.QsciScintilla(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(QtScintilla, self).init_widget()
        d = self.declaration
        self.set_document(d.document)
        self.set_syntax(d.syntax, refresh_style=False)
        self.set_settings(d.settings)
        self.set_zoom(d.zoom)
        self.refresh_style()
        self.widget.textChanged.connect(self.on_text_changed)

    def destroy(self):
        """ A reimplemented destructor.

        This destructor decrefs its document handle before calling the
        superclass destructor. This prevents a segfault in PyQt.

        """
        # Clear the strong reference to the document. It must be freed
        # *before* the last widget using it is freed or PyQt segfaults.
        del self.qsci_doc
        super(QtScintilla, self).destroy()

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_text_changed(self):
        """ Handle the 'textChanged' signal on the widget.

        """
        d = self.declaration
        if d is not None:
            d.text_changed()

    #--------------------------------------------------------------------------
    # Helper Methods
    #--------------------------------------------------------------------------
    def refresh_style(self):
        """ Refresh the theme styling for the widget.

        This method will style the widget and the lexer using the
        current theme that was provided by the declaration object.

        """
        colorcache = {}
        fontcache = {}

        def get_color(color_str):
            if color_str in colorcache:
                return colorcache[color_str]
            color = colorcache[color_str] = _make_color(color_str)
            return color

        def get_font(font_str):
            if font_str in fontcache:
                return fontcache[font_str]
            font = fontcache[font_str] = _make_font(font_str)
            return font

        def pull_color(dct, key, default):
            color = dct.get(key)
            if color is None:
                return default
            return get_color(color)

        def pull_font(dct, key, default):
            font = dct.get(key)
            if font is None:
                return default
            return get_font(font)

        # Setup the various defaults.
        caret_color = QColor(0, 0, 0)
        default_color = QColor(0, 0, 0)
        default_paper = QColor(255, 255, 255)
        default_font = QFont()

        # Update the defaults from the theme's root 'settings' object.
        theme = self.declaration.theme
        settings = theme.get('settings')
        if settings is not None:
            caret_color = pull_color(settings, 'caret', caret_color)
            default_color = pull_color(settings, 'color', default_color)
            default_paper = pull_color(settings, 'paper', default_paper)
            default_font = pull_font(settings, 'font', default_font)

        # Apply the default styling for the widget.
        widget = self.widget
        widget.setCaretForegroundColor(caret_color)
        widget.setColor(default_color)
        widget.setPaper(default_paper)
        widget.setFont(default_font)

        # Ensure the lexer and syntax tokens exist before continuing.
        lexer = widget.lexer()
        if lexer is None:
            return
        syntax = LEXERS_INV.get(type(lexer))
        if syntax is None:
            return

        # Resolve the default parameters and apply them for all lexer
        # styles. More specifc rules will override these defaults.
        syntax_rules = theme.get(syntax, {})
        syntax_tokens = TOKENS.get(syntax, {})
        syntax_default = syntax_rules.get('default', {})
        default_color = pull_color(syntax_default, 'color', default_color)
        default_paper = pull_color(syntax_default, 'paper', default_paper)
        default_font = pull_font(syntax_default, 'font', default_font)
        lexer.setColor(default_color)
        lexer.setPaper(default_paper)
        lexer.setFont(default_font)

        # Override the defaults with more specific syntax rules.
        for token, rule in syntax_rules.iteritems():
            if token == 'default':
                continue
            qtoken = getattr(lexer, syntax_tokens.get(token, ''), None)
            if qtoken is not None:
                color = pull_color(rule, 'color', default_color)
                paper = pull_color(rule, 'paper', default_paper)
                font = pull_font(rule, 'font', default_font)
                lexer.setColor(color, qtoken)
                lexer.setPaper(paper, qtoken)
                lexer.setFont(font, qtoken)
            else:
                msg = "unknown token '%s' given for the '%s' syntax"
                logger.warn(msg % (token, syntax))

    #--------------------------------------------------------------------------
    # ProxyScintilla API
    #--------------------------------------------------------------------------
    def set_document(self, document):
        """ Set the document on the underlying widget.

        """
        qdoc = self.qsci_doc_cache.get(document.uuid)
        if qdoc is None:
            qdoc = self.qsci_doc_cache[document.uuid] = Qsci.QsciDocument()
        self.qsci_doc = qdoc  # take a strong ref since PyQt doesn't
        self.widget.setDocument(qdoc)

    def set_syntax(self, syntax, refresh_style=True):
        """ Set the syntax on the underlying widget.

        """
        # The old lexer will remain as a child unless deleted.
        old = self.widget.lexer()
        if old is not None:
            old.deleteLater()
        lexer_cls = LEXERS.get(syntax) or (lambda w: None)
        self.widget.setLexer(lexer_cls(self.widget))
        if refresh_style:
            self.refresh_style()

    def set_theme(self, theme):
        """ Set the styling theme for the widget.

        """
        self.refresh_style()

    def set_settings(self, settings):
        """ Set the settings for the widget.

        """
        w = self.widget
        send = w.SendScintilla
        get = settings.get

        def pull(kind, name, default):
            value = get(name, default)
            if not isinstance(value, kind):
                msg = 'invalid value "%s" for "%s" setting'
                logger.warn(msg % (value, name))
                value = default
            return value

        pull_int = lambda name, default: pull(int, name, default)
        pull_bool = lambda name, default: pull(bool, name, default)
        pull_str = lambda name, default: pull(str, name, default)

        def pull_enum(options, name, default):
            value = pull_str(name, default)
            if value in options:
                return options[value]
            message = 'invalid value "%s" for "%s" setting'
            logger.warn(message % (value, name))
            return options[default]

        def pull_color(name, default):
            color = pull_str(name, default)
            return _make_color(color)

        # Line Endings
        send(w.SCI_SETEOLMODE, pull_enum(EOL_MODE, 'eol_mode', DEFAULT_EOL))
        send(w.SCI_SETVIEWEOL, pull_bool('view_eol', False))

        # Long Lines
        send(w.SCI_SETEDGEMODE, pull_enum(EDGE_MODE, 'edge_mode', 'none'))
        send(w.SCI_SETEDGECOLUMN, pull_int('edge_column', 79))
        send(w.SCI_SETEDGECOLOUR, pull_color('edge_color', ''))

        # Tabs and Indentation
        send(w.SCI_SETTABWIDTH, pull_int('tab_width', 8))
        send(w.SCI_SETUSETABS, pull_bool('use_tabs', True))
        send(w.SCI_SETINDENT, pull_int('indent', 0))
        send(w.SCI_SETTABINDENTS, pull_bool('tab_indents', False))
        send(w.SCI_SETBACKSPACEUNINDENTS,
            pull_bool('backspace_unindents', False))
        send(w.SCI_SETINDENTATIONGUIDES,
            pull_enum(INDENTATION_GUIDES, 'indentation_guides', 'none'))

        # White Space
        send(w.SCI_SETVIEWWS, pull_enum(WHITE_SPACE, 'view_ws', 'invisible'))
        send(w.SCI_SETWHITESPACESIZE, pull_int('white_space_size', 1))
        send(w.SCI_SETEXTRAASCENT, pull_int('extra_ascent', 0))
        send(w.SCI_SETEXTRADESCENT, pull_int('extra_descent', 0))

    def set_zoom(self, zoom):
        """ Set the zoom factor on the widget.

        """
        self.widget.zoomTo(zoom)

    def get_text(self):
        """ Get the text in the document.

        """
        return self.widget.text()

    def set_text(self, text):
        """ Set the text in the document.

        """
        self.widget.setText(text)

    #--------------------------------------------------------------------------
    # Reimplementations
    #--------------------------------------------------------------------------
    def set_foreground(self, foreground):
        """ Set the foreground color of the widget.

        This reimplementation ignores the foreground setting. The
        foreground color is set by the theme.

        """
        pass

    def set_background(self, background):
        """ Set the background color of the widget.

        This reimplementation ignores the background setting. The
        background color is set by the theme.

        """
        pass

    def set_font(self, font):
        """ Set the font of the widget.

        This reimplementation ignores the font setting. The font is
        set by the theme.

        """
        pass

########NEW FILE########
__FILENAME__ = qt_scroll_area
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed, Value

from enaml.widgets.scroll_area import ProxyScrollArea

from .QtCore import Qt, QEvent, QSize, QRect, QPoint, Signal
from .QtGui import QApplication, QScrollArea, QPainter, QPalette

from .qt_container import QtContainer
from .qt_frame import QtFrame


POLICIES = {
    'as_needed': Qt.ScrollBarAsNeeded,
    'always_off': Qt.ScrollBarAlwaysOff,
    'always_on': Qt.ScrollBarAlwaysOn
}


class QCustomScrollArea(QScrollArea):
    """ A custom QScrollArea for use with the QtScrollArea.

    This subclass fixes some bugs related to size hints.

    """
    #: A signal emitted when a LayoutRequest event is posted to the
    #: scroll area. This will typically occur when the size hint of
    #: the scroll area is no longer valid.
    layoutRequested = Signal()

    #: A private internally cached size hint.
    _size_hint = QSize()

    def event(self, event):
        """ A custom event handler for the scroll area.

        This handler dispatches layout requests and paints the empty
        corner between the scroll bars.

        """
        res = super(QCustomScrollArea, self).event(event)
        event_t = event.type()
        if event_t == QEvent.Paint:
            # Fill in the empty corner area with the app window color.
            color = QApplication.palette().color(QPalette.Window)
            tl = self.viewport().geometry().bottomRight()
            fw = self.frameWidth()
            br = self.rect().bottomRight() - QPoint(fw, fw)
            QPainter(self).fillRect(QRect(tl, br), color)
        elif event_t == QEvent.LayoutRequest:
            self._size_hint = QSize()
            self.layoutRequested.emit()
        return res

    def setWidget(self, widget):
        """ Set the widget for this scroll area.

        This is a reimplemented parent class method which invalidates
        the cached size hint before setting the widget.

        """
        self._size_hint = QSize()
        self.takeWidget()  # Let Python keep ownership of the old widget
        super(QCustomScrollArea, self).setWidget(widget)

    def sizeHint(self):
        """ Get the size hint for the scroll area.

        This reimplemented method fixes a Qt bug where the size hint
        is not updated after the scroll widget is first shown. The
        bug is documented on the Qt bug tracker:
        https://bugreports.qt-project.org/browse/QTBUG-10545

        """
        # This code is ported directly from QScrollArea.cpp but instead
        # of caching the size hint of the scroll widget, it caches the
        # size hint for the entire scroll area, and invalidates it when
        # the widget is changed or it receives a LayoutRequest event.
        hint = self._size_hint
        if hint.isValid():
            return QSize(hint)
        fw = 2 * self.frameWidth()
        hint = QSize(fw, fw)
        font_height = self.fontMetrics().height()
        widget = self.widget()
        if widget is not None:
            if self.widgetResizable():
                hint += widget.sizeHint()
            else:
                hint += widget.size()
        else:
            hint += QSize(12 * font_height, 8 * font_height)
        if self.verticalScrollBarPolicy() == Qt.ScrollBarAlwaysOn:
            vbar = self.verticalScrollBar()
            hint.setWidth(hint.width() + vbar.sizeHint().width())
        if self.horizontalScrollBarPolicy() == Qt.ScrollBarAlwaysOn:
            hbar = self.horizontalScrollBar()
            hint.setHeight(hint.height() + hbar.sizeHint().height())
        hint = hint.boundedTo(QSize(36 * font_height, 24 * font_height))
        self._size_hint = hint
        return QSize(hint)


class QtScrollArea(QtFrame, ProxyScrollArea):
    """ A Qt implementation of an Enaml ProxyScrollArea.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QCustomScrollArea)

    #: A private cache of the old size hint for the scroll area.
    _old_hint = Value()

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying QScrollArea widget.

        """
        self.widget = QCustomScrollArea(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(QtScrollArea, self).init_widget()
        d = self.declaration
        self.set_horizontal_policy(d.horizontal_policy)
        self.set_vertical_policy(d.vertical_policy)
        self.set_widget_resizable(d.widget_resizable)

    def init_layout(self):
        """ Initialize the layout of the underlying widget.

        """
        super(QtScrollArea, self).init_layout()
        widget = self.widget
        widget.setWidget(self.scroll_widget())
        widget.layoutRequested.connect(self.on_layout_requested)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def scroll_widget(self):
        """ Find and return the scroll widget child for this widget.

        """
        w = self.declaration.scroll_widget()
        if w is not None:
            return w.proxy.widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a QtScrollArea.

        """
        super(QtScrollArea, self).child_added(child)
        if isinstance(child, QtContainer):
            self.widget.setWidget(self.scroll_widget())

    def child_removed(self, child):
        """ Handle the child removed event for a QtScrollArea.

        """
        super(QtScrollArea, self).child_removed(child)
        if isinstance(child, QtContainer):
            self.widget.setWidget(self.scroll_widget())

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_layout_requested(self):
        """ Handle the `layoutRequested` signal from the QScrollArea.

        """
        new_hint = self.widget.sizeHint()
        if new_hint != self._old_hint:
            self._old_hint = new_hint
            self.geometry_updated()

    #--------------------------------------------------------------------------
    # Overrides
    #--------------------------------------------------------------------------
    def replace_constraints(self, old_cns, new_cns):
        """ A reimplemented QtConstraintsWidget layout method.

        Constraints layout may not cross the boundary of a ScrollArea,
        so this method is no-op which stops the layout propagation.

        """
        pass

    #--------------------------------------------------------------------------
    # ProxyScrollArea API
    #--------------------------------------------------------------------------
    def set_horizontal_policy(self, policy):
        """ Set the horizontal scrollbar policy of the widget.

        """
        self.widget.setHorizontalScrollBarPolicy(POLICIES[policy])

    def set_vertical_policy(self, policy):
        """ Set the vertical scrollbar policy of the widget.

        """
        self.widget.setVerticalScrollBarPolicy(POLICIES[policy])

    def set_widget_resizable(self, resizable):
        """ Set whether or not the scroll widget is resizable.

        """
        self.widget.setWidgetResizable(resizable)

########NEW FILE########
__FILENAME__ = qt_separator
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.separator import ProxySeparator

from .QtCore import QSize
from .QtGui import QFrame

from .qt_control import QtControl


# A mapping from Enaml orientation to frame shape enum.
LINE_SHAPES = {
    'horizontal': QFrame.HLine,
    'vertical': QFrame.VLine,
}


# A mapping from Enaml line style to frame shadow enum.
LINE_STYLES = {
    'sunken': QFrame.Sunken,
    'raised': QFrame.Raised,
    'plain': QFrame.Plain
}


class QSeparator(QFrame):
    """ A QFrame subclass which acts as a separator.

    This subclass reimplements the sizeHint method to compute a hint
    which is appropriate for a frame being used as a vertical or
    horizontal separator line.

    """
    def sizeHint(self):
        # The default sizeHint method returns (-1, 3) or (3, -1) when
        # the frame is used as a separator, regardless of the computed
        # frame width. This override corrects that behavior.
        hint = super(QSeparator, self).sizeHint()
        if self.frameShadow() in (QFrame.Raised, QFrame.Sunken):
            shape = self.frameShape()
            if shape == QFrame.HLine:
                hint = QSize(hint.width(), max(3, self.frameWidth() * 2))
            elif shape == QFrame.VLine:
                hint = QSize(max(3, self.frameWidth() * 2), hint.height())
        return hint


class QtSeparator(QtControl, ProxySeparator):
    """ A Qt implementation of an Enaml ProxySeparator.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QSeparator)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create underlying QSeparator control.

        """
        self.widget = QSeparator(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(QtSeparator, self).init_widget()
        d = self.declaration
        self.set_orientation(d.orientation)
        self.set_line_style(d.line_style)
        self.set_line_width(d.line_width)
        self.set_midline_width(d.midline_width)

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_orientation(self, orientation):
        """ Set the orientation of the underlying widget.

        """
        with self.geometry_guard():
            self.widget.setFrameShape(LINE_SHAPES[orientation])

    def set_line_style(self, style):
        """ Set the line style of the underlying widget.

        """
        with self.geometry_guard():
            self.widget.setFrameShadow(LINE_STYLES[style])

    def set_line_width(self, width):
        """ Set the line width of the underlying widget.

        """
        with self.geometry_guard():
            self.widget.setLineWidth(width)
        self.widget.update()

    def set_midline_width(self, width):
        """ Set the midline width of the underlying widget.

        """
        with self.geometry_guard():
            self.widget.setMidLineWidth(width)
        self.widget.update()

########NEW FILE########
__FILENAME__ = qt_slider
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Int, Typed

from enaml.widgets.slider import ProxySlider

from .QtCore import Qt
from .QtGui import QSlider

from .qt_control import QtControl


#: A map from Enaml constants to QSlider TickPosition values.
TICK_POSITION = {
    'no_ticks': QSlider.NoTicks,
    'left': QSlider.TicksLeft,
    'right': QSlider.TicksRight,
    'top': QSlider.TicksAbove,
    'bottom': QSlider.TicksBelow,
    'both': QSlider.TicksBothSides
}


#: A map from Enaml enums to Qt constants for horizontal or vertical
#: orientation.
ORIENTATION = {
    'horizontal': Qt.Horizontal,
    'vertical': Qt.Vertical
}


#: A cyclic guard flag
VALUE_FLAG = 0x1


class QtSlider(QtControl, ProxySlider):
    """ A Qt implementation of an Enaml ProxySlider.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QSlider)

    #: Cyclic notification guard flags.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying QSlider widget.

        """
        self.widget = QSlider(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(QtSlider, self).init_widget()
        d = self.declaration
        self.set_minimum(d.minimum)
        self.set_maximum(d.maximum)
        self.set_value(d.value)
        self.set_orientation(d.orientation)
        self.set_page_step(d.page_step)
        self.set_single_step(d.single_step)
        self.set_tick_interval(d.tick_interval)
        self.set_tick_position(d.tick_position)
        self.set_tracking(d.tracking)
        self.widget.valueChanged.connect(self.on_value_changed)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_value_changed(self):
        """ Send the 'value_changed' action to the Enaml widget when the
        slider value has changed.

        """
        if not self._guard & VALUE_FLAG:
            self._guard |= VALUE_FLAG
            try:
                self.declaration.value = self.widget.value()
            finally:
                self._guard &= ~VALUE_FLAG

    #--------------------------------------------------------------------------
    # ProxySlider API
    #--------------------------------------------------------------------------
    def set_maximum(self, maximum):
        """ Set the maximum value of the underlying widget.

        """
        self.widget.setMaximum(maximum)

    def set_minimum(self, minimum):
        """ Set the minimum value of the underlying widget.

        """
        self.widget.setMinimum(minimum)

    def set_value(self, value):
        """ Set the value of the underlying widget.

        """
        if not self._guard & VALUE_FLAG:
            self._guard |= VALUE_FLAG
            try:
                self.widget.setValue(value)
            finally:
                self._guard &= ~VALUE_FLAG

    def set_page_step(self, page_step):
        """ Set the page step of the underlying widget.

        """
        self.widget.setPageStep(page_step)

    def set_single_step(self, single_step):
        """ Set the single step of the underlying widget.

        """
        self.widget.setSingleStep(single_step)

    def set_tick_interval(self, interval):
        """ Set the tick interval of the underlying widget.

        """
        self.widget.setTickInterval(interval)

    def set_tick_position(self, tick_position):
        """ Set the tick position of the underlying widget.

        """
        self.widget.setTickPosition(TICK_POSITION[tick_position])

    def set_orientation(self, orientation):
        """ Set the orientation of the underlying widget.

        """
        self.widget.setOrientation(ORIENTATION[orientation])

    def set_tracking(self, tracking):
        """ Set the tracking of the underlying widget.

        """
        self.widget.setTracking(tracking)

########NEW FILE########
__FILENAME__ = qt_spin_box
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Int, Typed

from enaml.widgets.spin_box import ProxySpinBox

from .QtGui import QSpinBox

from .qt_control import QtControl


#: Cyclic guard flag
VALUE_FLAG = 0x1


class QtSpinBox(QtControl, ProxySpinBox):
    """ A Qt implementation of an Enaml SpinBox.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QSpinBox)

    #: Cyclic guard flags
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying QSpinBox widget.

        """
        widget = QSpinBox(self.parent_widget())
        widget.setKeyboardTracking(False)
        self.widget = widget

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(QtSpinBox, self).init_widget()
        d = self.declaration
        self.set_maximum(d.maximum)
        self.set_minimum(d.minimum)
        self.set_value(d.value)
        self.set_prefix(d.prefix)
        self.set_suffix(d.suffix)
        self.set_special_value_text(d.special_value_text)
        self.set_single_step(d.single_step)
        self.set_read_only(d.read_only)
        self.set_wrapping(d.wrapping)
        self.widget.valueChanged.connect(self.on_value_changed)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_value_changed(self):
        """ The signal handler for the 'valueChanged' signal.

        """
        if not self._guard & VALUE_FLAG:
            self._guard |= VALUE_FLAG
            try:
                self.declaration.value = self.widget.value()
            finally:
                self._guard &= ~VALUE_FLAG

    #--------------------------------------------------------------------------
    # ProxySpinBox API
    #--------------------------------------------------------------------------
    def set_maximum(self, maximum):
        """ Set the widget's maximum value.

        """
        self.widget.setMaximum(maximum)

    def set_minimum(self, minimum):
        """ Set the widget's minimum value.

        """
        self.widget.setMinimum(minimum)

    def set_value(self, value):
        """ Set the spin box's value.

        """
        if not self._guard & VALUE_FLAG:
            self._guard |= VALUE_FLAG
            try:
                self.widget.setValue(value)
            finally:
                self._guard &= ~VALUE_FLAG

    def set_prefix(self, prefix):
        """ Set the prefix for the spin box.

        """
        self.widget.setPrefix(prefix)

    def set_suffix(self, suffix):
        """ Set the suffix for the spin box.

        """
        self.widget.setSuffix(suffix)

    def set_special_value_text(self, text):
        """ Set the special value text for the spin box.

        """
        self.widget.setSpecialValueText(text)

    def set_single_step(self, step):
        """ Set the widget's single step value.

        """
        self.widget.setSingleStep(step)

    def set_read_only(self, read_only):
        """ Set the widget's read only flag.

        """
        self.widget.setReadOnly(read_only)

    def set_wrapping(self, wrapping):
        """ Set the widget's wrapping flag.

        """
        self.widget.setWrapping(wrapping)

########NEW FILE########
__FILENAME__ = qt_splitter
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import sys

from atom.api import Typed

from enaml.widgets.splitter import ProxySplitter

from .QtCore import Qt, QEvent, Signal
from .QtGui import (
    QSplitter, QSplitterHandle, QVBoxLayout, QFrame, QApplication
)

from .qt_constraints_widget import QtConstraintsWidget
from .qt_split_item import QtSplitItem


ORIENTATION = {
    'horizontal': Qt.Horizontal,
    'vertical': Qt.Vertical,
}


class QWinSplitterHandle(QSplitterHandle):
    """ A custom QSplitterHandle which is used on win32 platforms.

    The native Windows style draws the splitter handle the same color as
    the widget background, which makes it invisible for most cases. This
    subclass overlays a raised line on the splitter to provide a little
    bit of visual feedback.

    """
    def __init__(self, orientation, parent=None):
        super(QWinSplitterHandle, self).__init__(orientation, parent)
        self._frame = frame = QFrame(self)
        l = QVBoxLayout()
        l.addWidget(frame)
        l.setSpacing(0)
        l.setContentsMargins(0, 0, 0, 0)
        self.setLayout(l)
        self.updateFrame()

    def updateFrame(self):
        """ Update the internal frame style for the current orientation.

        """
        orientation = self.orientation()
        s = QFrame.VLine if orientation == Qt.Horizontal else QFrame.HLine
        self._frame.setFrameStyle(s | QFrame.Raised)


class QCustomSplitter(QSplitter):
    """ A custom QSplitter which handles children of type QSplitItem.

    """
    #: A signal emitted when a LayoutRequest event is posted to the
    #: splitter widget. This will typically occur when the size hint
    #: of the splitter is no longer valid.
    layoutRequested = Signal()

    def createHandle(self):
        """ A reimplemented virtual method to create splitter handles.

        On win32 platforms, this will return a custom QSplitterHandle
        which works around an issue with handle not drawing nicely. On
        all other platforms, a normal QSplitterHandler widget.

        """
        if sys.platform == 'win32':
            return QWinSplitterHandle(self.orientation(), self)
        return QSplitterHandle(self.orientation(), self)

    def setOrientation(self, orientation):
        """ Set the orientation of the splitter.

        This overriden method will call the `updateFrame` method of the
        splitter handles when running on win32 platforms. On any other
        platform, this method simply calls the superclass method.

        """
        old = self.orientation()
        if old != orientation:
            super(QCustomSplitter, self).setOrientation(orientation)
            if sys.platform == 'win32':
                for idx in xrange(self.count()):
                    handle = self.handle(idx)
                    handle.updateFrame()

    def event(self, event):
        """ A custom event handler which handles LayoutRequest events.

        When a LayoutRequest event is posted to this widget, it will
        emit the `layoutRequested` signal. This allows an external
        consumer of this widget to update their external layout.

        """
        res = super(QCustomSplitter, self).event(event)
        if event.type() == QEvent.LayoutRequest:
            self.layoutRequested.emit()
        return res


class QtSplitter(QtConstraintsWidget, ProxySplitter):
    """ A Qt implementation of an Enaml ProxySplitter.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QCustomSplitter)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Creates the underlying QSplitter control.

        """
        self.widget = QCustomSplitter(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying control.

        """
        super(QtSplitter, self).init_widget()
        d = self.declaration
        self.set_orientation(d.orientation)
        self.set_live_drag(d.live_drag)

    def init_layout(self):
        """ Handle the layout initialization for the splitter.

        """
        super(QtSplitter, self).init_layout()
        widget = self.widget
        for item in self.split_items():
            widget.addWidget(item)
        widget.layoutRequested.connect(self.on_layout_requested)

        # On Windows, messages are consumed from three different queues,
        # each with a different priority. The lowest priority is the
        # queue which holds WM_PAINT messages. Dragging the splitter bar
        # generates WM_MOUSEMOVE messages which have a higher priority.
        # These messages (dragging the bar) generate size events in Qt
        # which are delivered immediately. This means that if handling
        # the resize event from the drag takes too long (> ~800us) then
        # another size event will arrive before the paint event, since
        # the new WM_MOUSEMOVE will be processed before the WM_PAINT.
        # So on Windows, the `splitterMoved` signal, which is emitted
        # on every drag, is connected to a handler which will force a
        # repaint if opaque resize is turned on. Since paint event are
        # collapsed, the effect of this is to restore the order of event
        # processing.
        if sys.platform == 'win32':
            widget.splitterMoved.connect(self.on_win32_splitter_moved)

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a QtSplitter.

        """
        super(QtSplitter, self).child_added(child)
        if isinstance(child, QtSplitItem):
            for index, dchild in enumerate(self.children()):
                if child is dchild:
                    self.widget.insertWidget(index, child.widget)

    # QSplitter automatically removes a widget when it's reparented. The
    # base child_removed event handler will set the parent to None, and
    # that is all that is needed.

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def split_items(self):
        """ Get the split items defined for the widget.

        """
        for d in self.declaration.split_items():
            w = d.proxy.widget
            if w is not None:
                yield w

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_layout_requested(self):
        """ Handle the `layoutRequested` signal from the QSplitter.

        """
        self.geometry_updated()

    def on_win32_splitter_moved(self):
        """ Handle the 'splitterMoved' signal from the QSplitter.

        This handler is only connected when running on Windows and it
        serves to make sure paint events get processed during heavy
        resize events when opaque resizing is turned on.

        """
        if self.widget.opaqueResize():
            QApplication.sendPostedEvents()

    #--------------------------------------------------------------------------
    # ProxySplitter API
    #--------------------------------------------------------------------------
    def set_orientation(self, orientation):
        """ Update the orientation of the QSplitter.

        """
        with self.geometry_guard():
            self.widget.setOrientation(ORIENTATION[orientation])

    def set_live_drag(self, live_drag):
        """ Update the dragging mode of the QSplitter.

        """
        self.widget.setOpaqueResize(live_drag)

########NEW FILE########
__FILENAME__ = qt_split_item
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.split_item import ProxySplitItem

from .QtGui import QFrame, QSplitter, QLayout

from .q_single_widget_layout import QSingleWidgetLayout
from .qt_container import QtContainer
from .qt_widget import QtWidget


class QSplitItem(QFrame):
    """ A QFrame subclass which acts as an item in a QSplitter.

    """
    def __init__(self, parent=None):
        """ Initialize a QSplitItem.

        Parameters
        ----------
        parent : QWidget, optional
            The parent widget of the split item, or None if it has no
            parent.

        """
        super(QSplitItem, self).__init__(parent)
        self._split_widget = None
        self.setLayout(QSingleWidgetLayout())
        self.layout().setSizeConstraint(QLayout.SetMinAndMaxSize)

    def splitWidget(self):
        """ Get the split widget for this split item.

        Returns
        -------
        result : QWidget or None
            The split widget being managed by this item.

        """
        return self._split_widget

    def setSplitWidget(self, widget):
        """ Set the split widget for this split item.

        Parameters
        ----------
        widget : QWidget
            The QWidget to use as the split widget in this item.

        """
        self._split_widget = widget
        self.layout().setWidget(widget)

    def stretch(self):
        """ Get the stretch factor for this split item.

        Returns
        -------
        result : int
            The stretch factor for this split item.

        """
        # horizontal and vertical stretch are set to be the same,
        # so which one is returned here is irrelevant.
        return self.sizePolicy().horizontalStretch()

    def setStretch(self, stretch):
        """ Set the stretch factor for this split item.

        Parameters
        ----------
        stretch : int
            The stretch factor to use for this split item.

        """
        stretch = max(0, stretch)
        policy = self.sizePolicy()
        policy.setHorizontalStretch(stretch)
        policy.setVerticalStretch(stretch)
        self.setSizePolicy(policy)

    def collapsible(self):
        """ Get whether or not this widget is collapsible.

        Returns
        -------
        result : bool
            Whether or not this item can be collapsed to zero size.

        """
        parent = self.parentWidget()
        if isinstance(parent, QSplitter):
            return parent.isCollapsible(parent.indexOf(self))
        return False

    def setCollapsible(self, collapsible):
        """ Set whether or not this widget is collapsible.

        Parameters
        ----------
        collapsible : bool
            Whether or not this item can be collapsed to zero size.
            This holds regardless of the minimum size of the item.

        """
        parent = self.parentWidget()
        if isinstance(parent, QSplitter):
            return parent.setCollapsible(parent.indexOf(self), collapsible)


class QtSplitItem(QtWidget, ProxySplitItem):
    """ A Qt implementation of an Enaml ProxySplitItem.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QSplitItem)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying QStackItem widget.

        """
        self.widget = QSplitItem(self.parent_widget())

    def init_widget(self):
        """ Initialize the underyling widget.

        """
        super(QtSplitItem, self).init_widget()
        d = self.declaration
        self.set_stretch(d.stretch)
        self.set_collapsible(d.collapsible)

    def init_layout(self):
        """ Initialize the layout for the underyling widget.

        """
        super(QtSplitItem, self).init_layout()
        self.widget.setSplitWidget(self.split_widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def split_widget(self):
        """ Find and return the split widget child for this widget.

        """
        d = self.declaration.split_widget()
        if d is not None:
            return d.proxy.widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a QtSplitItem.

        """
        super(QtSplitItem, self).child_added(child)
        if isinstance(child, QtContainer):
            self.widget.setSplitWidget(self.split_widget())

    def child_removed(self, child):
        """ Handle the child removed event for a QtSplitItem.

        """
        super(QtSplitItem, self).child_removed(child)
        if isinstance(child, QtContainer):
            self.widget.setSplitWidget(self.split_widget())

    #--------------------------------------------------------------------------
    # ProxySplitItem API
    #--------------------------------------------------------------------------
    def set_stretch(self, stretch):
        """ Set the stretch factor for the underlying widget.

        """
        self.widget.setStretch(stretch)

    def set_collapsible(self, collapsible):
        """ Set the collapsible flag for the underlying widget.

        """
        self.widget.setCollapsible(collapsible)

########NEW FILE########
__FILENAME__ = qt_stack
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Int, IntEnum, Typed

from enaml.widgets.stack import ProxyStack

from .QtCore import QTimer, QEvent, Signal
from .QtGui import QStackedWidget, QPixmap

from .q_pixmap_painter import QPixmapPainter
from .q_pixmap_transition import (
    QDirectedTransition, QSlideTransition, QWipeTransition, QIrisTransition,
    QFadeTransition, QCrossFadeTransition
)
from .qt_constraints_widget import QtConstraintsWidget
from .qt_stack_item import QtStackItem


TRANSITION_TYPE = {
    'slide': QSlideTransition,
    'wipe': QWipeTransition,
    'iris': QIrisTransition,
    'fade': QFadeTransition,
    'crossfade': QCrossFadeTransition,
}


TRANSITION_DIRECTION = {
    'left_to_right': QDirectedTransition.LeftToRight,
    'right_to_left': QDirectedTransition.RightToLeft,
    'top_to_bottom': QDirectedTransition.TopToBottom,
    'bottom_to_top': QDirectedTransition.BottomToTop,
}


def make_transition(transition):
    """ Make a QPixmapTransition from an Enaml Transition.

    Parameters
    ----------
    transition : Transition
        The Enaml Transition object.

    Returns
    -------
    result : QPixmapTransition
        A QPixmapTransition to use as the transition.

    """
    qtransition = TRANSITION_TYPE[transition.type]()
    qtransition.setDuration(transition.duration)
    if isinstance(qtransition, QDirectedTransition):
        qtransition.setDirection(TRANSITION_DIRECTION[transition.direction])
    return qtransition


class QStack(QStackedWidget):
    """ A QStackedWidget subclass which adds support for transitions.

    """
    class SizeHintMode(IntEnum):
        """ An int enum defining the size hint modes of the stack.

        """
        #: The size hint is the union of all stack items.
        Union = 0

        #: The size hint is the size hint of the current stack item.
        Current = 1

    #: Proxy the SizeHintMode values as if it were an anonymous enum.
    Union = SizeHintMode.Union
    Current = SizeHintMode.Current

    #: A signal emitted when a LayoutRequest event is posted to the
    #: stack widget. This will typically occur when the size hint of
    #: the stack is no longer valid.
    layoutRequested = Signal()

    def __init__(self, *args, **kwargs):
        """ Initialize a QStack.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initalize
            a QStackedWidget.

        """
        super(QStack, self).__init__(*args, **kwargs)
        self._painter = None
        self._transition = None
        self._transition_index = 0
        self._size_hint_mode = QStack.Union

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _onTransitionFinished(self):
        """ A signal handler for the `finished` signal of the transition.

        This method resets the internal painter and triggers the normal
        index change for the stacked widget.

        """
        painter = self._painter
        if painter is not None:
            painter.setTargetWidget(None)
        self._painter = None
        self.setCurrentIndex(self._transition_index)
        # This final show() makes sure the underlyling widget is visible.
        # If transitions are being fired rapidly, it's possible that the
        # current index and the transition index will be the same when
        # the call above is invoked. In such cases, Qt short circuits the
        # evaluation and the current widget is not shown.
        self.currentWidget().show()

    def _runTransition(self):
        """ A private method which runs the transition effect.

        The `_transition_index` attribute should be set before calling
        this method. If no transition object exists for this widget,
        then it is equivalent to calling `setCurrentIndex`. If the new
        index is not different from the current index the transition
        will not be performed.

        """
        from_index = self.currentIndex()
        to_index = self._transition_index

        # If the index hasn't changed, there is nothing to update.
        if from_index == to_index:
            return

        # If there is no transition applied, just change the index.
        transition = self._transition
        if transition is None:
            self.setCurrentIndex(to_index)
            return

        # Otherwise, grab the pixmaps for the start and ending states
        # and set them on the transtion. The widgets are resized to the
        # current size so that the pixmaps are grabbed in a good state.
        src_widget = self.widget(from_index)
        dst_widget = self.widget(to_index)
        size = self.size()
        src_widget.resize(size)
        dst_widget.resize(size)
        src_pixmap = QPixmap.grabWidget(src_widget)
        dst_pixmap = QPixmap.grabWidget(dst_widget)
        out_pixmap = QPixmap(size)
        transition.setPixmaps(src_pixmap, dst_pixmap, out_pixmap)

        # Hide both of the constituent widgets so that the painter has
        # a clean widget on which to draw.
        src_widget.setVisible(False)
        dst_widget.setVisible(False)

        # Hookup the pixmap painter and start the transition.
        painter = self._painter = QPixmapPainter()
        painter.setTargetWidget(self)
        transition.pixmapUpdated.connect(painter.drawPixmap)
        transition.start()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def event(self, event):
        """ A custom event handler which handles LayoutRequest events.

        When a LayoutRequest event is posted to this widget, it will
        emit the `layoutRequested` signal. This allows an external
        consumer of this widget to update their external layout.

        """
        res = super(QStack, self).event(event)
        if event.type() == QEvent.LayoutRequest:
            self.layoutRequested.emit()
        return res

    def sizeHint(self):
        """ A reimplemented size hint handler.

        This method will compute the size hint based on the size hint
        of the current tab, instead of the default behavior which is
        the maximum of all the size hints of the tabs.

        """
        if self._size_hint_mode == QStack.Current:
            curr = self.currentWidget()
            if curr is not None:
                return curr.sizeHint()
        return super(QStack, self).sizeHint()

    def minimumSizeHint(self):
        """ A reimplemented minimum size hint handler.

        This method will compute the size hint based on the size hint
        of the current tab, instead of the default behavior which is
        the maximum of all the minimum size hints of the tabs.

        """
        if self._size_hint_mode == QStack.Current:
            curr = self.currentWidget()
            if curr is not None:
                return curr.minimumSizeHint()
        return super(QStack, self).minimumSizeHint()

    def sizeHintMode(self):
        """ Get the size hint mode of the stack.

        Returns
        -------
        result : QStack.SizeHintMode
            The size hint mode enum value for the stack.

        """
        return self._size_hint_mode

    def setSizeHintMode(self, mode):
        """ Set the size hint mode of the stack.

        Parameters
        ----------
        mode : QStack.SizeHintMode
            The size hint mode for the stack.

        """
        assert isinstance(mode, QStack.SizeHintMode)
        self._size_hint_mode = mode

    def transition(self):
        """ Get the transition installed on this widget.

        Returns
        -------
        result : QPixmapTransition or None
            The pixmap transition installed on this widget, or None if
            no transition is being used.

        """
        return self._transition

    def setTransition(self, transition):
        """ Set the transition to be used by this widget.

        Parameters
        ----------
        transition : QPixmapTransition or None
            The transition to use when changing between widgets on this
            stack or None if no transition should be used.

        """
        old = self._transition
        if old is not None:
            old.finished.disconnect(self._onTransitionFinished)
        self._transition = transition
        if transition is not None:
            transition.finished.connect(self._onTransitionFinished)

    def transitionTo(self, index):
        """ Transition the stack widget to the given index.

        If there is no transition object is installed on the widget
        this is equivalent to calling `setCurrentIndex`. Otherwise,
        the change will be animated using the installed transition.

        Parameters
        ----------
        index : int
            The index of the target transition widget.

        """
        if index < 0 or index >= self.count():
            return
        self._transition_index = index
        if self.transition() is not None:
            QTimer.singleShot(0, self._runTransition)
        else:
            self.setCurrentIndex(index)


#: A mapping Enaml -> Qt size hint modes.
SIZE_HINT_MODE = {
    'union': QStack.Union,
    'current': QStack.Current,
}


#: Cyclic notification guard
INDEX_FLAG = 0x1


class QtStack(QtConstraintsWidget, ProxyStack):
    """ A Qt implementation of an Enaml Stack.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QStack)

    #: Cyclic notification guards
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying QStack widget.

        """
        self.widget = QStack(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying control.

        """
        super(QtStack, self).init_widget()
        d = self.declaration
        self.set_transition(d.transition)
        self.set_size_hint_mode(d.size_hint_mode, update=False)

    def init_layout(self):
        """ Initialize the layout of the underlying control.

        """
        super(QtStack, self).init_layout()
        widget = self.widget
        for item in self.stack_items():
            widget.addWidget(item)
        # Bypass the transition effect during initialization.
        widget.setCurrentIndex(self.declaration.index)
        widget.layoutRequested.connect(self.on_layout_requested)
        widget.currentChanged.connect(self.on_current_changed)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def stack_items(self):
        """ Get the stack items defined on the control.

        """
        for d in self.declaration.stack_items():
            w = d.proxy.widget
            if w is not None:
                yield w

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a QtStack.

        """
        super(QtStack, self).child_added(child)
        if isinstance(child, QtStackItem):
            for index, dchild in enumerate(self.children()):
                if child is dchild:
                    self.widget.insertWidget(index, child.widget)

    def child_removed(self, child):
        """ Handle the child removed event for a QtStack.

        """
        super(QtStack, self).child_removed(child)
        if isinstance(child, QtStackItem):
            self.widget.removeWidget(child.widget)

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_layout_requested(self):
        """ Handle the `layoutRequested` signal from the QStack.

        """
        self.geometry_updated()

    def on_current_changed(self):
        """ Handle the `currentChanged` signal from the QStack.

        """
        if not self._guard & INDEX_FLAG:
            self._guard |= INDEX_FLAG
            try:
                self.declaration.index = self.widget.currentIndex()
            finally:
                self._guard &= ~INDEX_FLAG

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_index(self, index):
        """ Set the current index of the underlying widget.

        """
        if not self._guard & INDEX_FLAG:
            self._guard |= INDEX_FLAG
            try:
                self.widget.transitionTo(index)
            finally:
                self._guard &= ~INDEX_FLAG

    def set_transition(self, transition):
        """ Set the transition on the underlying widget.

        """
        if transition:
            self.widget.setTransition(make_transition(transition))
        else:
            self.widget.setTransition(None)

    def set_size_hint_mode(self, mode, update=True):
        """ Set the size hint mode for the widget.

        """
        self.widget.setSizeHintMode(SIZE_HINT_MODE[mode])
        if update:
            self.geometry_updated()

########NEW FILE########
__FILENAME__ = qt_stack_item
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.stack_item import ProxyStackItem

from .QtGui import QFrame

from .q_single_widget_layout import QSingleWidgetLayout
from .qt_container import QtContainer
from .qt_widget import QtWidget


class QStackItem(QFrame):
    """ A QFrame subclass which acts as an item QStack.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a QStackItem.

        Parameters
        ----------
        *args, **kwargs
            The position and keyword arguments required to initialize
            a QWidget.

        """
        super(QStackItem, self).__init__(*args, **kwargs)
        self._stack_widget = None
        self.setLayout(QSingleWidgetLayout())

    def stackWidget(self):
        """ Get the stack widget for this stack item.

        Returns
        -------
        result : QWidget or None
            The stack widget being managed by this item.

        """
        return self._stack_widget

    def setStackWidget(self, widget):
        """ Set the stack widget for this stack item.

        Parameters
        ----------
        widget : QWidget
            The QWidget to use as the stack widget in this item.

        """
        self._stack_widget = widget
        self.layout().setWidget(widget)


class QtStackItem(QtWidget, ProxyStackItem):
    """ A Qt implementation of an Enaml ProxyStackItem.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QStackItem)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying QStackItem widget.

        """
        self.widget = QStackItem(self.parent_widget())

    def init_layout(self):
        """ Initialize the layout for the underyling widget.

        """
        super(QtStackItem, self).init_layout()
        self.widget.setStackWidget(self.stack_widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def stack_widget(self):
        """ Find and return the stack widget child for this widget.

        """
        d = self.declaration.stack_widget()
        if d is not None:
            return d.proxy.widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a QtStackItem.

        """
        super(QtStackItem, self).child_added(child)
        if isinstance(child, QtContainer):
            self.widget.setStackWidget(self.stack_widget())

    def child_removed(self, child):
        """ Handle the child added event for a QtStackItem.

        """
        super(QtStackItem, self).child_removed(child)
        if isinstance(child, QtContainer):
            self.widget.setStackWidget(self.stack_widget())

    #--------------------------------------------------------------------------
    # Widget Update Methods
    #--------------------------------------------------------------------------
    def set_visible(self, visible):
        """ An overridden visibility setter.

        This setter disables changing visibility on the widget since
        the visibility is controlled entirely by the parent stack.

        """
        pass

########NEW FILE########
__FILENAME__ = qt_status_bar
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.status_bar import ProxyStatusBar

from .QtGui import QStatusBar

from .qt_status_item import QtStatusItem
from .qt_widget import QtWidget


class QtStatusBar(QtWidget, ProxyStatusBar):
    """ A Qt implementation of an Enaml ProxyStatusBar.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QStatusBar)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the QStatusBar widget.

        """
        self.widget = QStatusBar(self.parent_widget())

    def init_widget(self):
        """ Initialize the widget.

        """
        super(QtStatusBar, self).init_widget()
        self.set_size_grip_enabled(self.declaration.size_grip_enabled)

    def init_layout(self):
        """ Initialize the layout for the widget.

        """
        super(QtStatusBar, self).init_layout()
        widget = self.widget
        for child in self.children():
            if isinstance(child, QtStatusItem):
                s_widget = child.status_widget()
                if s_widget is not None:
                    stretch = child.stretch()
                    if child.is_permanent():
                        widget.addPermanentWidget(s_widget, stretch)
                    else:
                        widget.addWidget(s_widget, stretch)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def refresh_item(self, item):
        """ A method invoked by a child status item.

        This method can be called when the widget for the item should
        be refreshed in the status bar.

        """
        w = self.widget
        s = item.status_widget()
        if s is not None:
            w.removeWidget(s)
            for index, child in enumerate(self.children()):
                if child is item:
                    stretch = item.stretch()
                    if item.is_permanent():
                        w.insertPermanentWidget(index, s, stretch)
                    else:
                        w.insertWidget(index, s, stretch)
                    s.show()
                    break

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a QtStatusBar.

        """
        super(QtStatusBar, self).child_added(child)
        if isinstance(child, QtStatusItem):
            w = self.widget
            s = child.status_widget()
            if s is not None:
                for index, item in enumerate(self.children()):
                    if child is item:
                        stretch = item.stretch()
                        if item.is_permanent():
                            w.insertPermanentWidget(index, s, stretch)
                        else:
                            w.insertWidget(index, s, stretch)
                        break

    def child_removed(self, child):
        """ Handle the child removed event for a QtStatusBar.

        """
        if isinstance(child, QtStatusItem):
            s = child.status_widget()
            if s is not None:
                self.widget.removeWidget(s)

    #--------------------------------------------------------------------------
    # ProxyStatusBar API
    #--------------------------------------------------------------------------
    def set_size_grip_enabled(self, enabled):
        """ Set the size grip enabled on the underlying widget.

        """
        self.widget.setSizeGripEnabled(enabled)

    def show_message(self, message, timeout=0):
        """ Show a temporary message in the status bar.

        """
        self.widget.showMessage(message, timeout)

    def clear_message(self):
        """ Clear any temporary message shown in the status bar.

        """
        self.widget.clearMessage()

########NEW FILE########
__FILENAME__ = qt_status_item
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Constant

from enaml.widgets.status_item import ProxyStatusItem

from .qt_toolkit_object import QtToolkitObject


class QtStatusItem(QtToolkitObject, ProxyStatusItem):
    """ A Qt implementation of an Enaml ProxyStatusItem.

    """
    #: The status has no widget representation. All child widgets will
    #: be reparented by the status bar during the layout pass.
    widget = Constant(None)

    def create_widget(self):
        """ A reimplemented parent class method.

        """
        pass

    def destroy(self):
        """ A reimplemented parent class destructor.

        """
        del self.declaration

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def status_widget(self):
        """ Get the status widget defined for this item.

        """
        d = self.declaration.status_widget()
        if d is not None:
            return d.proxy.widget

    def is_permanent(self):
        """ Get whether this status item should be permanent.

        """
        return self.declaration.mode == 'permanent'

    def stretch(self):
        """ Get the stretch factor to apply to the item.

        """
        return self.declaration.stretch

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for the status item.

        """
        parent = self.parent()
        if parent is not None:
            parent.refresh_item(self)

    def child_removed(self, child):
        """ Handle the child removed event for the status item.

        """
        parent = self.parent()
        if parent is not None:
            parent.refresh_item(self)

    #--------------------------------------------------------------------------
    # ProxyStatusItem API
    #--------------------------------------------------------------------------
    def set_mode(self, mode):
        """ Set the mode of the status item.

        """
        parent = self.parent()
        if parent is not None:
            parent.refresh_item(self)

    def set_stretch(self, stretch):
        """ Set the stretch factor of the status item.

        """
        parent = self.parent()
        if parent is not None:
            parent.refresh_item(self)

########NEW FILE########
__FILENAME__ = qt_timer
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.timer import ProxyTimer

from .QtCore import QTimer

from .qt_toolkit_object import QtToolkitObject


class QtTimer(QtToolkitObject, ProxyTimer):
    """ A Qt implementation of an Enaml ProxyTimer.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QTimer)

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying timer object.

        """
        self.widget = QTimer()

    def init_widget(self):
        """ Initialize the widget.

        """
        super(QtTimer, self).init_widget()
        d = self.declaration
        self.set_interval(d.interval)
        self.set_single_shot(d.single_shot)
        self.widget.timeout.connect(self.on_timeout)

    def destroy(self):
        """ A reimplemented destructor.

        This stops the timer before invoking the superclass destructor.

        """
        self.widget.stop()
        super(QtTimer, self).destroy()

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_timeout(self):
        """ Handle the timeout signal for the timer.

        """
        d = self.declaration
        if d is not None:
            d.timeout()

    #--------------------------------------------------------------------------
    # ProxyTimer API
    #--------------------------------------------------------------------------
    def set_interval(self, interval):
        """ Set the interval on the timer.

        """
        self.widget.setInterval(interval)

    def set_single_shot(self, single_shot):
        """ Set the single shot flag on the timer.

        """
        self.widget.setSingleShot(single_shot)

    def start(self):
        """ Start or restart the timer.

        """
        self.widget.start()

    def stop(self):
        """ Stop the timer.

        """
        self.widget.stop()

    def is_running(self):
        """ Get whether or not the timer is running.

        """
        return self.widget.isActive()

########NEW FILE########
__FILENAME__ = qt_time_selector
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.time_selector import ProxyTimeSelector

from .QtGui import QTimeEdit

from .qt_bounded_time import QtBoundedTime, CHANGED_GUARD


class QtTimeSelector(QtBoundedTime, ProxyTimeSelector):
    """ A Qt implementation of an Enaml ProxyTimeSelector.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QTimeEdit)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the QTimeEdit widget.

        """
        self.widget = QTimeEdit(self.parent_widget())

    def init_widget(self):
        """ Initialize the widget.

        """
        super(QtTimeSelector, self).init_widget()
        d = self.declaration
        self.set_time_format(d.time_format)
        self.widget.timeChanged.connect(self.on_time_changed)

    #--------------------------------------------------------------------------
    # Abstract API Implementation
    #--------------------------------------------------------------------------
    def get_time(self):
        """ Return the current time in the control.

        Returns
        -------
        result : time
            The current control time as a time object.

        """
        return self.widget.time().toPython()

    def set_minimum(self, time):
        """ Set the widget's minimum time.

        Parameters
        ----------
        time : time
            The time object to use for setting the minimum time.

        """
        self.widget.setMinimumTime(time)

    def set_maximum(self, time):
        """ Set the widget's maximum time.

        Parameters
        ----------
        time : time
            The time object to use for setting the maximum time.

        """
        self.widget.setMaximumTime(time)

    def set_time(self, time):
        """ Set the widget's current time.

        Parameters
        ----------
        time : time
            The time object to use for setting the date.

        """
        self._guard |= CHANGED_GUARD
        try:
            self.widget.setTime(time)
        finally:
            self._guard &= ~CHANGED_GUARD

    def set_time_format(self, format):
        """ Set the widget's time format.

        Parameters
        ----------
        format : string
            A Python time formatting string.

        """
        # XXX make sure Python's and Qt's format strings are the
        # same, or convert between the two.
        self.widget.setDisplayFormat(format)

########NEW FILE########
__FILENAME__ = qt_toolkit_dialog
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.toolkit_dialog import ProxyToolkitDialog

from .QtGui import QDialog

from .qt_toolkit_object import QtToolkitObject


class QtToolkitDialog(QtToolkitObject, ProxyToolkitDialog):
    """ A Qt implementation of an Enaml ProxyToolkitDialog.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QDialog)

    def create_widget(self):
        """ Create the underlying QColorDialog.

        """
        self.widget = QDialog(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(QtToolkitDialog, self).init_widget()
        self.set_title(self.declaration.title)
        self.widget.finished.connect(self.on_finished)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def get_default_title(self):
        """ Get the default window title for the dialog.

        This can be reimplemented by subclass to provide a default
        window title. The base implementation returns an empty string.

        """
        return u''

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_finished(self, result):
        """ Handle the 'finished' signal from the widget.

        """
        d = self.declaration
        if d is not None:
            d._proxy_finished(bool(result))

    #--------------------------------------------------------------------------
    # ProxyToolkitDialog API
    #--------------------------------------------------------------------------
    def set_title(self, title):
        """ Set the window title for the underlying widget.

        """
        self.widget.setWindowTitle(title or self.get_default_title())

    def show(self):
        """ Open the dialog as non modal.

        """
        self.widget.show()

    def open(self):
        """ Open the dialog as window modal.

        """
        self.widget.open()

    def exec_(self):
        """ Open the dialog as application modal.

        """
        self.widget.exec_()

    def accept(self):
        """ Accept the current state and close the dialog.

        """
        self.widget.accept()

    def reject(self):
        """ Reject the current state and close the dialog.

        """
        self.widget.reject()

########NEW FILE########
__FILENAME__ = qt_toolkit_object
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.toolkit_object import ProxyToolkitObject

from .QtCore import QObject


class QtToolkitObject(ProxyToolkitObject):
    """ A Qt implementation of an Enaml ProxyToolkitObject.

    """
    # PySide requires weakrefs for using bound methods as slots.
    # PyQt doesn't, but executes unsafe code if not using weakrefs.
    __slots__ = '__weakref__'

    #: A reference to the toolkit widget created by the proxy.
    widget = Typed(QObject)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the toolkit widget for the proxy object.

        This method is called during the top-down pass, just before the
        'init_widget()' method is called. This method should create the
        toolkit widget and assign it to the 'widget' attribute.

        """
        self.widget = QObject(self.parent_widget())

    def init_widget(self):
        """ Initialize the state of the toolkit widget.

        This method is called during the top-down pass, just after the
        'create_widget()' method is called. This method should init the
        state of the widget. The child widgets will not yet be created.

        """
        widget = self.widget
        if widget is not None:
            # Each Qt object gets a name. If one is not provided by the
            # widget author, one is generated. This is required so that
            # Qt stylesheet cascading can be prevented (Enaml's styling
            # engine applies the cascade itself). Names provided by the
            # widget author are assumed to be unique.
            d = self.declaration
            name = d.name or u'obj-%d' % id(d)
            widget.setObjectName(name)

    def init_layout(self):
        """ Initialize the layout of the toolkit widget.

        This method is called during the bottom-up pass. This method
        should initialize the layout of the widget. The child widgets
        will be fully initialized and layed out when this is called.

        """
        pass

    #--------------------------------------------------------------------------
    # ProxyToolkitObject API
    #--------------------------------------------------------------------------
    def activate_top_down(self):
        """ Activate the proxy for the top-down pass.

        """
        self.create_widget()
        self.init_widget()

    def activate_bottom_up(self):
        """ Activate the proxy tree for the bottom-up pass.

        """
        self.init_layout()

    def destroy(self):
        """ A reimplemented destructor.

        This destructor will clear the reference to the toolkit widget
        and set its parent to None.

        """
        widget = self.widget
        if widget is not None:
            widget.setParent(None)
            del self.widget
        super(QtToolkitObject, self).destroy()

    def child_removed(self, child):
        """ Handle the child removed event from the declaration.

        This handler will unparent the child toolkit widget. Subclasses
        which need more control should reimplement this method.

        """
        super(QtToolkitObject, self).child_removed(child)
        if child.widget is not None:
            child.widget.setParent(None)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def parent_widget(self):
        """ Get the parent toolkit widget for this object.

        Returns
        -------
        result : QObject or None
            The toolkit widget declared on the declaration parent, or
            None if there is no such parent.

        """
        parent = self.parent()
        if parent is not None:
            return parent.widget

    def child_widgets(self):
        """ Get the child toolkit widgets for this object.

        Returns
        -------
        result : iterable of QObject
            The child widgets defined for this object.

        """
        for child in self.children():
            w = child.widget
            if w is not None:
                yield w

########NEW FILE########
__FILENAME__ = qt_tool_bar
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import sys

from atom.api import Int, Typed

from enaml.widgets.tool_bar import ProxyToolBar

from .QtCore import Qt, Signal
from .QtGui import QToolBar, QMainWindow

from .qt_action import QtAction
from .qt_action_group import QtActionGroup
from .qt_constraints_widget import QtConstraintsWidget
from .qt_widget import QtWidget


#: A mapping from Enaml dock area to Qt tool bar areas
DOCK_AREAS = {
    'top': Qt.TopToolBarArea,
    'right': Qt.RightToolBarArea,
    'bottom': Qt.BottomToolBarArea,
    'left': Qt.LeftToolBarArea,
    'all': Qt.AllToolBarAreas,
}


#: A mapping from Qt tool bar areas to Enaml dock areas
DOCK_AREAS_INV = {
    Qt.TopToolBarArea: 'top',
    Qt.RightToolBarArea: 'right',
    Qt.BottomToolBarArea: 'bottom',
    Qt.LeftToolBarArea: 'left',
    Qt.AllToolBarAreas: 'all',
}


#: A mapping from Enaml orientation to Qt Orientation
ORIENTATIONS = {
    'horizontal': Qt.Horizontal,
    'vertical': Qt.Vertical,
}


#: A mapping from Enaml button style to Qt ToolButtonStyle
BUTTON_STYLES = {
    'icon_only': Qt.ToolButtonIconOnly,
    'text_only': Qt.ToolButtonTextOnly,
    'text_beside_icon': Qt.ToolButtonTextBesideIcon,
    'text_under_icon': Qt.ToolButtonTextUnderIcon,
}


class QCustomToolBar(QToolBar):
    """ A custom QToolBar which adds some Enaml specific features.

    """
    #: A signal emitted when the dock widget is floated.
    floated = Signal()

    #: A signal emitted when the dock widget is docked. The payload
    #: will be the new dock area.
    docked = Signal(object)

    def __init__(self, *args, **kwargs):
        """ Initialize a QCustomToolBar.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initialize
            a QToolBar.

        """
        super(QCustomToolBar, self).__init__(*args, **kwargs)
        self._tool_bar_area = Qt.TopToolBarArea
        self.topLevelChanged.connect(self._onTopLevelChanged)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _onTopLevelChanged(self, top_level):
        """ The signal handler for the the 'topLevelChanged' signal.

        """
        if top_level:
            self.floated.emit()
        else:
            parent = self.parent()
            if parent is not None and isinstance(parent, QMainWindow):
                self._tool_bar_area = parent.toolBarArea(self)
            self.docked.emit(self._tool_bar_area)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def removeActions(self, actions):
        """ Remove the given actions from the tool bar.

        Parameters
        ----------
        actions : iterable
            An iterable of QActions to remove from the tool bar.

        """
        remove = self.removeAction
        for action in actions:
            remove(action)

    def toolBarArea(self):
        """ Get the current tool bar area for the tool bar.

        Returns
        -------
        result : QToolBarArea
            The tool bar area where this tool bar resides.

        """
        return self._tool_bar_area

    def setToolBarArea(self, area):
        """ Set the current tool bar area for the tool bar.

        Parameters
        ----------
        area : QToolBarArea
            The tool bar area where this tool bar should reside.

        """
        self._tool_bar_area = area
        parent = self.parent()
        if isinstance(parent, QMainWindow):
            parent.setToolBarArea(area, self)

    def setFloating(self, floating):
        """ Set the floating state of the tool bar.

        Parameters
        ----------
        floating : bool
            Whether or not the tool bar should floating.

        """
        # QToolBar doesn't provide a setFloating() method. This code
        # is taken mostly from QToolBarPrivate::updateWindowFlags.
        parent = self.parent()
        if isinstance(parent, QMainWindow):
            visible = self.isVisibleTo(parent)
            flags = Qt.Tool if floating else Qt.Widget
            flags |= Qt.FramelessWindowHint
            if sys.platform == 'darwin':
                flags |= Qt.WindowStaysOnTopHint
            self.setWindowFlags(flags)
            if visible:
                self.resize(self.sizeHint())
                self.setVisible(True)


# cyclic notification guard flags
FLOATED_GUARD = 0x1


class QtToolBar(QtConstraintsWidget, ProxyToolBar):
    """ A Qt implementation of an Enaml ToolBar.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QCustomToolBar)

    #: Cyclic notification guard. This a bitfield of multiple guards.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the QCustomToolBar widget.

        """
        self.widget = QCustomToolBar(self.parent_widget())

    def init_widget(self):
        """ Initialize the tool bar widget.

        """
        super(QtToolBar, self).init_widget()
        d = self.declaration
        self.set_button_style(d.button_style)
        self.set_movable(d.movable)
        self.set_floatable(d.floatable)
        self.set_floating(d.floating)
        self.set_dock_area(d.dock_area)
        self.set_allowed_dock_areas(d.allowed_dock_areas)
        self.set_orientation(d.orientation)
        widget = self.widget
        widget.floated.connect(self.on_floated)
        widget.docked.connect(self.on_docked)

    def init_layout(self):
        """ Initialize the layout for the toolbar.

        """
        super(QtToolBar, self).init_layout()
        widget = self.widget
        for child in self.children():
            if isinstance(child, QtAction):
                widget.addAction(child.widget)
            elif isinstance(child, QtActionGroup):
                widget.addActions(child.actions())
            elif isinstance(child, QtWidget):
                widget.addAction(child.get_action(True))

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def find_next_action(self, child):
        """ Locate the QAction object which logically follows the child.

        Parameters
        ----------
        child : QtToolkitObject
            The child object of interest.

        Returns
        -------
        result : QAction or None
            The QAction which logically follows the position of the
            child in the list of children. None will be returned if
            a relevant QAction is not found.

        """
        found = False
        for dchild in self.children():
            if found:
                if isinstance(dchild, QtAction):
                    return dchild.widget
                elif isinstance(dchild, QtActionGroup):
                    actions = dchild.actions()
                    if len(actions) > 0:
                        return actions[0]
                elif isinstance(dchild, QtWidget):
                    action = dchild.get_action(False)
                    if action is not None:
                        return action
            else:
                found = dchild is child

    def child_added(self, child):
        """ Handle the child added event for a QtToolBar.

        This handler will scan the children to find the proper point
        at which to insert the action.

        """
        super(QtToolBar, self).child_added(child)
        if isinstance(child, QtAction):
            before = self.find_next_action(child)
            self.widget.insertAction(before, child.widget)
        elif isinstance(child, QtActionGroup):
            before = self.find_next_action(child)
            self.widget.insertActions(before, child.actions())
        elif isinstance(child, QtWidget):
            before = self.find_next_action(child)
            self.widget.insertAction(before, child.get_action(True))

    def child_removed(self, child):
        """  Handle the child removed event for a QtToolBar.

        """
        super(QtToolBar, self).child_removed(child)
        if isinstance(child, QtAction):
            self.widget.removeAction(child.widget)
        elif isinstance(child, QtActionGroup):
            self.widget.removeActions(child.actions())
        elif isinstance(child, QtWidget):
            self.widget.removeAction(child.get_action(False))

    #--------------------------------------------------------------------------
    # Signal Handlers
    #--------------------------------------------------------------------------
    def on_floated(self):
        """ The signal handler for the 'floated' signal.

        """
        if not self._guard & FLOATED_GUARD:
            self._guard |= FLOATED_GUARD
            try:
                self.declaration.floating = True
            finally:
                self._guard &= ~FLOATED_GUARD

    def on_docked(self, area):
        """ The signal handler for the 'docked' signal.

        """
        if not self._guard & FLOATED_GUARD:
            self._guard |= FLOATED_GUARD
            try:
                self.declaration.floating = False
                self.declaration.dock_area = DOCK_AREAS_INV[area]
            finally:
                self._guard &= ~FLOATED_GUARD

    #--------------------------------------------------------------------------
    # ProxyToolBar API
    #--------------------------------------------------------------------------
    def set_button_style(self, style):
        """ Set the button style for the toolbar.

        """
        self.widget.setToolButtonStyle(BUTTON_STYLES[style])

    def set_movable(self, movable):
        """ Set the movable state on the underlying widget.

        """
        self.widget.setMovable(movable)

    def set_floatable(self, floatable):
        """ Set the floatable state on the underlying widget.

        """
        self.widget.setFloatable(floatable)

    def set_floating(self, floating):
        """ Set the floating staet on the underlying widget.

        """
        if not self._guard & FLOATED_GUARD:
            self._guard |= FLOATED_GUARD
            try:
                self.widget.setFloating(floating)
            finally:
                self._guard &= ~FLOATED_GUARD

    def set_dock_area(self, dock_area):
        """ Set the dock area on the underyling widget.

        """
        self.widget.setToolBarArea(DOCK_AREAS[dock_area])

    def set_allowed_dock_areas(self, dock_areas):
        """ Set the allowed dock areas on the underlying widget.

        """
        qt_areas = Qt.NoToolBarArea
        for area in dock_areas:
            qt_areas |= DOCK_AREAS[area]
        self.widget.setAllowedAreas(qt_areas)

    def set_orientation(self, orientation):
        """ Set the orientation of the underlying widget.

        """
        # If the tool bar is a child of a QMainWindow, then that window
        # will take control of setting its orientation and changes to
        # the orientation by the user must be ignored.
        widget = self.widget
        parent = widget.parent()
        if not isinstance(parent, QMainWindow):
            widget.setOrientation(ORIENTATIONS[orientation])

########NEW FILE########
__FILENAME__ = qt_tool_button
#------------------------------------------------------------------------------
# Copyright (c) 2014, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.tool_button import ProxyToolButton

from .QtCore import Qt
from .QtGui import QToolButton, QToolBar, QSizePolicy

from .qt_abstract_button import QtAbstractButton
from .qt_menu import QtMenu


#: A mapping of Enaml popup modes to Qt ToolButtonPopupMode
POPUP_MODES = {
    'button': QToolButton.MenuButtonPopup,
    'instant': QToolButton.InstantPopup,
    'delayed': QToolButton.DelayedPopup,
}


#: A mapping from Enaml button style to Qt ToolButtonStyle
BUTTON_STYLES = {
    'icon_only': Qt.ToolButtonIconOnly,
    'text_only': Qt.ToolButtonTextOnly,
    'text_beside_icon': Qt.ToolButtonTextBesideIcon,
    'text_under_icon': Qt.ToolButtonTextUnderIcon,
}


class QtToolButton(QtAbstractButton, ProxyToolButton):
    """ A Qt implementation of an Enaml ProxyToolButton.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QToolButton)

    def create_widget(self):
        """ Create the underlying widget.

        """
        parent = self.parent_widget()
        widget = QToolButton(parent)
        if not isinstance(parent, QToolBar):
            sp = widget.sizePolicy()
            sp.setHorizontalPolicy(QSizePolicy.Minimum)
            widget.setSizePolicy(sp)
        self.widget = widget

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(QtToolButton, self).init_widget()
        d = self.declaration
        self.set_button_style(d.button_style)
        self.set_auto_raise(d.auto_raise)
        self.set_popup_mode(d.popup_mode)

    def init_layout(self):
        """ Initialize the widget layout.

        """
        super(QtToolButton, self).init_layout()
        for child in self.children():
            if isinstance(child, QtMenu):
                self.widget.setMenu(child.widget)
                break

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for the tool button.

        """
        super(QtToolButton, self).child_added(child)
        if isinstance(child, QtMenu):
            self.widget.setMenu(child.widget)

    def child_removed(self, child):
        """ Handle the child removed event for the tool button.

        """
        super(QtToolButton, self).child_removed(child)
        if isinstance(child, QtMenu):
            if child.widget is self.widget.menu():
                self.widget.setMenu(None)

    #--------------------------------------------------------------------------
    # ProxyToolButton API
    #--------------------------------------------------------------------------
    def set_button_style(self, style):
        """ Set the button style of the widget.

        """
        with self.geometry_guard():
            self.widget.setToolButtonStyle(BUTTON_STYLES[style])

    def set_auto_raise(self, auto):
        """ Set the auto-raise flag on the widget.

        """
        with self.geometry_guard():
            self.widget.setAutoRaise(auto)

    def set_popup_mode(self, mode):
        """ Set the popup mode for the widget menu.

        """
        widget = self.widget
        q_mode = POPUP_MODES[mode]
        if q_mode == widget.popupMode():
            return
        with self.geometry_guard():
            widget.setPopupMode(q_mode)
            widget.setIcon(widget.icon())  # force-resets the internal cache

########NEW FILE########
__FILENAME__ = qt_vtk_canvas
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.vtk_canvas import ProxyVTKCanvas

from vtk.qt4.QVTKRenderWindowInteractor import QVTKRenderWindowInteractor

from .QtGui import QFrame, QVBoxLayout

from .qt_control import QtControl


class QtVTKCanvas(QtControl, ProxyVTKCanvas):
    """ A Qt implementation of an Enaml ProxyVTKCanvas.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QFrame)

    #: A reference to the underlying vtk widget.
    vtk_widget = Typed(QVTKRenderWindowInteractor)

    #: The set of current renderers installed on the window.
    _current_renderers = Typed(set, ())

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying widget.

        """
        # The vtk widget is nested in a QFrame because the Qt render
        # window interactor does not support reparenting.
        widget = QFrame(self.parent_widget())
        vtk_widget = QVTKRenderWindowInteractor(widget)
        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        layout.addWidget(vtk_widget)
        widget.setLayout(layout)
        self.widget = widget
        self.vtk_widget = vtk_widget

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(QtVTKCanvas, self).init_widget()
        self._refresh_renderers()
        self.vtk_widget.Initialize()

    #--------------------------------------------------------------------------
    # ProxyVTKCanvas API
    #--------------------------------------------------------------------------
    def set_renderer(self, renderer):
        """ Set the renderer for the widget.

        """
        self._refresh_renderers()

    def set_renderers(self, renderers):
        """ Set the renderers for the widget.

        """
        self._refresh_renderers()

    def render(self):
        """ Request a render of the underlying scene.

        """
        self.vtk_widget.Render()

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _refresh_renderers(self):
        """ Refresh the renderers installed on the render window.

        """
        d = self.declaration
        old = self._current_renderers
        new = set(filter(None, [d.renderer] + d.renderers))
        to_remove = old.difference(new)
        to_add = new.difference(old)
        window = self.vtk_widget.GetRenderWindow()
        for r in to_remove:
            window.RemoveRenderer(r)
        for r in to_add:
            window.AddRenderer(r)
        self._current_renderers = new

########NEW FILE########
__FILENAME__ = qt_web_view
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.web_view import ProxyWebView

from .QtCore import QUrl
from .QtWebKit import QWebView

from .qt_control import QtControl


class QtWebView(QtControl, ProxyWebView):
    """ A Qt implementation of an Enaml ProxyWebView.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(QWebView)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying QWebView control.

        """
        self.widget = QWebView(self.parent_widget())

    def init_widget(self):
        """ Create and initialize the underlying control.

        """
        super(QtWebView, self).init_widget()
        d = self.declaration
        if d.html:
            self.set_html(d.html)
        elif d.url:
            self.set_url(d.url)

    #--------------------------------------------------------------------------
    # ProxyWebView API
    #--------------------------------------------------------------------------
    def set_url(self, url):
        """ Set the url for the underlying control.

        """
        self.widget.setUrl(QUrl(url))

    def set_html(self, html):
        """ Set the html source for the underlying control.

        """
        self.widget.setHtml(html, QUrl(self.declaration.base_url))

########NEW FILE########
__FILENAME__ = qt_widget
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed, Coerced

from enaml.styling import StyleCache
from enaml.widgets.widget import Feature, ProxyWidget

from .QtCore import Qt, QSize
from .QtGui import QFont, QWidget, QWidgetAction, QApplication

from . import focus_registry
from .q_resource_helpers import get_cached_qcolor, get_cached_qfont
from .qt_toolkit_object import QtToolkitObject
from .styleutil import translate_style


class QtWidget(QtToolkitObject, ProxyWidget):
    """ A Qt implementation of an Enaml ProxyWidget.

    """
    #: A reference to the toolkit widget created by the proxy.
    widget = Typed(QWidget)

    #: A private copy of the declaration features. This ensures that
    #: feature cleanup will proceed correctly in the event that user
    #: code modifies the declaration features value at runtime.
    _features = Coerced(Feature.Flags)

    #: Internal storage for the shared widget action.
    _widget_action = Typed(QWidgetAction)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying QWidget object.

        """
        self.widget = QWidget(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying QWidget object.

        """
        super(QtWidget, self).init_widget()
        widget = self.widget
        focus_registry.register(widget, self)
        self._setup_features()
        d = self.declaration
        if d.background:
            self.set_background(d.background)
        if d.foreground:
            self.set_foreground(d.foreground)
        if d.font:
            self.set_font(d.font)
        if -1 not in d.minimum_size:
            self.set_minimum_size(d.minimum_size)
        if -1 not in d.maximum_size:
            self.set_maximum_size(d.maximum_size)
        if d.tool_tip:
            self.set_tool_tip(d.tool_tip)
        if d.status_tip:
            self.set_status_tip(d.status_tip)
        if not d.enabled:
            self.set_enabled(d.enabled)
        self.refresh_style_sheet()
        # Don't make toplevel widgets visible during init or they will
        # flicker onto the screen. This applies particularly for things
        # like status bar widgets which are created with no parent and
        # then reparented by the status bar. Real top-level widgets must
        # be explicitly shown by calling their .show() method after they
        # are created.
        if widget.parent() or not d.visible:
            self.set_visible(d.visible)

    def destroy(self):
        """ Destroy the underlying QWidget object.

        """
        self._teardown_features()
        focus_registry.unregister(self.widget)
        super(QtWidget, self).destroy()
        # If a QWidgetAction was created for this widget, then it has
        # taken ownership of the widget and the widget will be deleted
        # when the QWidgetAction is garbage collected. This means the
        # superclass destroy() method must run before the reference to
        # the QWidgetAction is dropped.
        del self._widget_action

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _setup_features(self):
        """ Setup the advanced widget feature handlers.

        """
        features = self._features = self.declaration.features
        if not features:
            return
        if features & Feature.FocusTraversal:
            self.hook_focus_traversal()
        if features & Feature.FocusEvents:
            self.hook_focus_events()

    def _teardown_features(self):
        """ Teardowns the advanced widget feature handlers.

        """
        features = self._features
        if not features:
            return
        if features & Feature.FocusTraversal:
            self.unhook_focus_traversal()
        if features & Feature.FocusEvents:
            self.unhook_focus_events()

    #--------------------------------------------------------------------------
    # Protected API
    #--------------------------------------------------------------------------
    def refresh_style_sheet(self):
        """ Refresh the widget style sheet with the current style data.

        """
        parts = []
        name = self.widget.objectName()
        for style in StyleCache.styles(self.declaration):
            t = translate_style(name, style)
            if t:
                parts.append(t)
        if len(parts) > 0:
            stylesheet = u'\n\n'.join(parts)
        else:
            stylesheet = u''
        self.widget.setStyleSheet(stylesheet)

    def tab_focus_request(self, reason):
        """ Handle a custom tab focus request.

        This method is called when focus is being set on the proxy
        as a result of a user-implemented focus traversal handler.
        This can be reimplemented by subclasses as needed.

        Parameters
        ----------
        reason : Qt.FocusReason
            The reason value for the focus request.

        Returns
        -------
        result : bool
            True if focus was set, False otherwise.

        """
        widget = self.focus_target()
        if ((widget.focusPolicy() & Qt.TabFocus) and
            widget.isEnabled() and
            widget.isVisibleTo(widget.window())):
            widget.setFocus(reason)
            return True
        return False

    def focus_target(self):
        """ Return the current focus target for a focus request.

        This can be reimplemented by subclasses as needed. The default
        implementation of this method returns the current proxy widget.

        """
        return self.widget

    def hook_focus_traversal(self):
        """ Install the hooks for focus traversal.

        This method may be overridden by subclasses as needed.

        """
        self.widget.focusNextPrevChild = self.focusNextPrevChild

    def unhook_focus_traversal(self):
        """ Remove the hooks for the next/prev child focusing.

        This method may be overridden by subclasses as needed.

        """
        del self.widget.focusNextPrevChild

    def hook_focus_events(self):
        """ Install the hooks for focus events.

        This method may be overridden by subclasses as needed.

        """
        widget = self.widget
        widget.focusInEvent = self.focusInEvent
        widget.focusOutEvent = self.focusOutEvent

    def unhook_focus_events(self):
        """ Remove the hooks for the focus events.

        This method may be overridden by subclasses as needed.

        """
        widget = self.widget
        del widget.focusInEvent
        del widget.focusOutEvent

    def focusNextPrevChild(self, next_child):
        """ The default 'focusNextPrevChild' implementation.

        """
        fd = focus_registry.focused_declaration()
        if next_child:
            child = self.declaration.next_focus_child(fd)
            reason = Qt.TabFocusReason
        else:
            child = self.declaration.previous_focus_child(fd)
            reason = Qt.BacktabFocusReason
        if child is not None and child.proxy_is_active:
            return child.proxy.tab_focus_request(reason)
        widget = self.widget
        return type(widget).focusNextPrevChild(widget, next_child)

    def focusInEvent(self, event):
        """ The default 'focusInEvent' implementation.

        """
        widget = self.widget
        type(widget).focusInEvent(widget, event)
        self.declaration.focus_gained()

    def focusOutEvent(self, event):
        """ The default 'focusOutEvent' implementation.

        """
        widget = self.widget
        type(widget).focusOutEvent(widget, event)
        self.declaration.focus_lost()

    #--------------------------------------------------------------------------
    # Framework API
    #--------------------------------------------------------------------------
    def get_action(self, create=False):
        """ Get the shared widget action for this widget.

        This API is used to support widgets in tool bars and menus.

        Parameters
        ----------
        create : bool, optional
            Whether to create the action if it doesn't already exist.
            The default is False.

        Returns
        -------
        result : QWidgetAction or None
            The cached widget action or None, depending on arguments.

        """
        action = self._widget_action
        if action is None and create:
            action = self._widget_action = QWidgetAction(None)
            action.setDefaultWidget(self.widget)
        return action

    #--------------------------------------------------------------------------
    # ProxyWidget API
    #--------------------------------------------------------------------------
    def set_minimum_size(self, min_size):
        """ Sets the minimum size of the widget.

        """
        # QWidget uses (0, 0) as the minimum size.
        if -1 in min_size:
            min_size = (0, 0)
        self.widget.setMinimumSize(QSize(*min_size))

    def set_maximum_size(self, max_size):
        """ Sets the maximum size of the widget.

        """
        # QWidget uses 16777215 as the max size
        if -1 in max_size:
            max_size = (16777215, 16777215)
        self.widget.setMaximumSize(QSize(*max_size))

    def set_enabled(self, enabled):
        """ Set the enabled state of the widget.

        """
        self.widget.setEnabled(enabled)
        action = self._widget_action
        if action is not None:
            action.setEnabled(enabled)

    def set_visible(self, visible):
        """ Set the visibility of the widget.

        """
        self.widget.setVisible(visible)
        action = self._widget_action
        if action is not None:
            action.setVisible(visible)

    def set_background(self, background):
        """ Set the background color of the widget.

        """
        widget = self.widget
        role = widget.backgroundRole()
        if background is not None:
            qcolor = get_cached_qcolor(background)
            widget.setAutoFillBackground(True)
        else:
            app_palette = QApplication.instance().palette(widget)
            qcolor = app_palette.color(role)
            widget.setAutoFillBackground(False)
        palette = widget.palette()
        palette.setColor(role, qcolor)
        widget.setPalette(palette)

    def set_foreground(self, foreground):
        """ Set the foreground color of the widget.

        """
        widget = self.widget
        role = widget.foregroundRole()
        if foreground is not None:
            qcolor = get_cached_qcolor(foreground)
        else:
            app_palette = QApplication.instance().palette(widget)
            qcolor = app_palette.color(role)
        palette = widget.palette()
        palette.setColor(role, qcolor)
        widget.setPalette(palette)

    def set_font(self, font):
        """ Set the font of the widget.

        """
        if font is not None:
            self.widget.setFont(get_cached_qfont(font))
        else:
            self.widget.setFont(QFont())

    def set_tool_tip(self, tool_tip):
        """ Set the tool tip for the widget.

        """
        self.widget.setToolTip(tool_tip)

    def set_status_tip(self, status_tip):
        """ Set the status tip for the widget.

        """
        self.widget.setStatusTip(status_tip)

    def ensure_visible(self):
        """ Ensure the widget is visible.

        """
        self.widget.setVisible(True)
        action = self._widget_action
        if action is not None:
            action.setVisible(True)

    def ensure_hidden(self):
        """ Ensure the widget is hidden.

        """
        self.widget.setVisible(False)
        action = self._widget_action
        if action is not None:
            action.setVisible(False)

    def restyle(self):
        """ Restyle the widget with the current style data.

        """
        self.refresh_style_sheet()

    def set_focus(self):
        """ Set the keyboard input focus to this widget.

        """
        self.focus_target().setFocus(Qt.OtherFocusReason)

    def clear_focus(self):
        """ Clear the keyboard input focus from this widget.

        """
        self.focus_target().clearFocus()

    def has_focus(self):
        """ Test whether this widget has input focus.

        """
        return self.focus_target().hasFocus()

    def focus_next_child(self):
        """ Give focus to the next widget in the focus chain.

        """
        self.focus_target().focusNextChild()

    def focus_previous_child(self):
        """ Give focus to the previous widget in the focus chain.

        """
        self.focus_target().focusPreviousChild()

########NEW FILE########
__FILENAME__ = qt_window
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import sys

from atom.api import Typed, atomref

from enaml.layout.geometry import Pos, Rect, Size
from enaml.widgets.window import ProxyWindow, CloseEvent

from .QtCore import Qt, QPoint, QRect, QSize
from .QtGui import QApplication, QIcon

from .q_deferred_caller import deferredCall
from .q_resource_helpers import get_cached_qicon
from .q_window_base import QWindowBase
from .qt_container import QtContainer
from .qt_widget import QtWidget


MODALITY = {
    'non_modal': Qt.NonModal,
    'application_modal': Qt.ApplicationModal,
    'window_modal': Qt.WindowModal,
}


def finalize_close(d):
    """ Finalize the closing of the declaration object.

    This is performed as a deferred call so that the window may fully
    close before the declaration is potentially destroyed.

    """
    d.visible = False
    d.closed()
    if d.destroy_on_close:
        d.destroy()


class QWindow(QWindowBase):
    """ A window base subclass which handles the close event.

    The window layout computes the min/max size of the window based
    on its central widget, unless the user explicitly changes them.

    """
    def __init__(self, proxy, parent=None, flags=Qt.Widget):
        """ Initialize a QWindow.

        Parameters
        ----------
        proxy : QtWindow
            The proxy object which owns this window. Only an atomref
            will be maintained to this object.

        parent : QWidget, optional
            The parent of the window.

        flags : Qt.WindowFlags, optional
            The window flags to pass to the parent constructor.

        """
        super(QWindow, self).__init__(parent, Qt.Window | flags)
        self._proxy_ref = atomref(proxy)

    def closeEvent(self, event):
        """ Handle the close event for the window.

        """
        event.accept()
        if not self._proxy_ref:
            return
        proxy = self._proxy_ref()
        d = proxy.declaration
        d_event = CloseEvent()
        d.closing(d_event)
        if d_event.is_accepted():
            deferredCall(finalize_close, d)
        else:
            event.ignore()


class QtWindow(QtWidget, ProxyWindow):
    """ A Qt implementation of an Enaml ProxyWindow.

    """
    #: A reference to the toolkit widget created by the proxy.
    widget = Typed(QWindow)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def creation_flags(self):
        """ A convenience function for getting the creation flags.

        """
        flags = Qt.Widget
        if self.declaration.always_on_top:
            flags |= Qt.WindowStaysOnTopHint
        return flags

    def create_widget(self):
        """ Create the QWindow widget.

        """
        flags = self.creation_flags()
        self.widget = QWindow(self, self.parent_widget(), flags)

    def init_widget(self):
        """ Initialize the widget.

        """
        super(QtWindow, self).init_widget()
        d = self.declaration
        if d.title:
            self.set_title(d.title)
        if -1 not in d.initial_size:
            self.widget.resize(*d.initial_size)
        if -1 not in d.initial_position:
            self.widget.move(*d.initial_position)
        if d.modality != 'non_modal':
            self.set_modality(d.modality)
        if d.icon:
            self.set_icon(d.icon)

    def init_layout(self):
        """ Initialize the widget layout.

        """
        super(QtWindow, self).init_layout()
        self.widget.setCentralWidget(self.central_widget())

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def central_widget(self):
        """ Find and return the central widget child for this widget.

        Returns
        -------
        result : QWidget or None
            The central widget defined for this widget, or None if one
            is not defined.

        """
        d = self.declaration.central_widget()
        if d is not None:
            return d.proxy.widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a QtWindow.

        """
        super(QtWindow, self).child_added(child)
        if isinstance(child, QtContainer):
            self.widget.setCentralWidget(self.central_widget())

    def child_removed(self, child):
        """ Handle the child added event for a QtWindow.

        """
        super(QtWindow, self).child_removed(child)
        if isinstance(child, QtContainer):
            self.widget.setCentralWidget(self.central_widget())

    #--------------------------------------------------------------------------
    # ProxyWindow API
    #--------------------------------------------------------------------------
    def set_title(self, title):
        """ Set the title of the window.

        """
        self.widget.setWindowTitle(title)

    def set_modality(self, modality):
        """ Set the modality of the window.

        """
        self.widget.setWindowModality(MODALITY[modality])

    def set_icon(self, icon):
        """ Set the window icon.

        """
        if icon:
            qicon = get_cached_qicon(icon)
        else:
            qicon = QIcon()
        self.widget.setWindowIcon(qicon)

    def position(self):
        """ Get the position of the of the window.

        """
        point = self.widget.pos()
        return Pos(point.x(), point.y())

    def set_position(self, pos):
        """ Set the position of the window.

        """
        self.widget.move(*pos)

    def size(self):
        """ Get the size of the window.

        """
        size = self.widget.size()
        return Size(size.width(), size.height())

    def set_size(self, size):
        """ Set the size of the window.

        """
        size = QSize(*size)
        if size.isValid():
            self.widget.resize(size)

    def geometry(self):
        """ Get the geometry of the window.

        """
        rect = self.widget.geometry()
        return Rect(rect.x(), rect.y(), rect.width(), rect.height())

    def set_geometry(self, rect):
        """ Set the geometry of the window.

        """
        rect = QRect(*rect)
        if rect.isValid():
            self.widget.setGeometry(rect)

    def frame_geometry(self):
        """ Get the geometry of the window.

        """
        rect = self.widget.frameGeometry()
        return Rect(rect.x(), rect.y(), rect.width(), rect.height())

    def maximize(self):
        """ Maximize the window.

        """
        self.widget.showMaximized()

    def is_maximized(self):
        """ Get whether the window is maximized.

        """
        return bool(self.widget.windowState() & Qt.WindowMaximized)

    def minimize(self):
        """ Minimize the window.

        """
        self.widget.showMinimized()

    def is_minimized(self):
        """ Get whether the window is minimized.

        """
        return bool(self.widget.windowState() & Qt.WindowMinimized)

    def restore(self):
        """ Restore the window after a minimize or maximize.

        """
        self.widget.showNormal()

    def send_to_front(self):
        """ Move the window to the top of the Z order.

        """
        self.widget.raise_()

    def send_to_back(self):
        """ Move the window to the bottom of the Z order.

        """
        self.widget.lower()

    def activate_window(self):
        """ Activate the underlying window widget.

        """
        self.widget.activateWindow()
        if sys.platform == 'win32':
            # For some reason, this needs to be called twice on Windows
            # in order to get the taskbar entry to flash.
            self.widget.activateWindow()

    def center_on_screen(self):
        """ Center the window on the screen.

        """
        widget = self.widget
        rect = QRect(QPoint(0, 0), widget.frameGeometry().size())
        geo = QApplication.desktop().screenGeometry(widget)
        widget.move(geo.center() - rect.center())

    def center_on_widget(self, other):
        """ Center the window on another widget.

        """
        widget = self.widget
        rect = QRect(QPoint(0, 0), widget.frameGeometry().size())
        other_widget = other.proxy.widget
        if other_widget.isWindow():
            geo = other_widget.frameGeometry()
        else:
            size = other_widget.size()
            point = other_widget.mapToGlobal(QPoint(0, 0))
            geo = QRect(point, size)
        widget.move(geo.center() - rect.center())

    def close(self):
        """ Close the window.

        """
        self.widget.close()

########NEW FILE########
__FILENAME__ = q_deferred_caller
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from .QtCore import QObject, QTimer, QEvent, QThread
from .QtGui import QApplication


class DeferredCallEvent(QEvent):
    """ A custom event type for deferred call events.

    """
    # Explicitly coerce to QEvent.Type for PySide compatibility.
    Type = QEvent.Type(QEvent.registerEventType())

    def __init__(self, callback, args, kwargs):
        super(DeferredCallEvent, self).__init__(self.Type)
        self.callback = callback
        self.args = args
        self.kwargs = kwargs


class DeferredCaller(QObject):
    """ A QObject subclass which handles deferred call events.

    """
    def __init__(self):
        """ Initialize a DeferredCaller.

        """
        super(DeferredCaller, self).__init__()
        self.moveToThread(QApplication.instance().thread())

    def customEvent(self, event):
        """ Handle the custom deferred call events.

        """
        if event.type() == DeferredCallEvent.Type:
            event.callback(*event.args, **event.kwargs)


#: A globally available caller instance. This will be created on demand
#: by the globally available caller functions.
__caller = None


def deferredCall(callback, *args, **kwargs):
    """ Execute the callback on the main gui thread.

    This should only be called after the QApplication is created.

    """
    global __caller
    caller = __caller
    if caller is None:
        caller = __caller = DeferredCaller()
    event = DeferredCallEvent(callback, args, kwargs)
    QApplication.postEvent(caller, event)


def timedCall(ms, callback, *args, **kwargs):
    """ Execute a callback on a timer in the main gui thread.

    This should only be called after the QApplication is created.

    """
    if QThread.currentThread() != QApplication.instance().thread():
        deferredCall(timedCall, ms, callback, *args, **kwargs)
    else:
        QTimer.singleShot(ms, lambda: callback(*args, **kwargs))

########NEW FILE########
__FILENAME__ = q_file_dialog_helper
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from . import QT_API
from .QtGui import QFileDialog


# A mapping from the Enaml dialog modes to the name of the static method
# on QFileDialog which will launch the appropriate native dialog.
if QT_API == 'pyqt':
    _STATIC_METHOD_NAMES = {
        'open_file': 'getOpenFileNameAndFilter',
        'open_files': 'getOpenFileNamesAndFilter',
        'save_file': 'getSaveFileNameAndFilter',
        'directory': 'getExistingDirectory',
    }
else:
    _STATIC_METHOD_NAMES = {
        'open_file': 'getOpenFileName',
        'open_files': 'getOpenFileNames',
        'save_file': 'getSaveFileName',
        'directory': 'getExistingDirectory',
    }


def get_file_dialog_exec_func(mode):
    """ Get the appropriate static method for exec'ing a QFileDialog.

    Parameters
    ----------
    mode : str
        The target dialog mode. Must be one of: 'open_file',
        'open_files', 'save_file', or 'directory'.

    """
    if mode not in _STATIC_METHOD_NAMES:
        raise ValueError("Unknown file dialog mode: '%s'" % mode)
    return getattr(QFileDialog, _STATIC_METHOD_NAMES[mode])

########NEW FILE########
__FILENAME__ = q_flow_layout
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from abc import ABCMeta, abstractmethod

from .QtCore import Qt, QSize, QRect
from .QtGui import QLayout, QWidgetItem


class AbstractFlowWidget(object):
    """ An abstract base class which defines the interface for widgets
    which can be used in a QFlowLayout.

    Users of QFlowLayout must register their custom QWidget classes with
    this class in order to use the QFlowLayout.

    """
    __metaclass__ = ABCMeta

    @abstractmethod
    def layoutData(self):
        """ An abstractmethod which must be implemented by subclasses.

        Returns
        -------
        result : FlowLayoutData
            The FlowLayoutData instance to use for this widget. The
            same data layout data instance should be returned for
            each call to this method.

        """
        raise NotImplementedError


class FlowLayoutData(object):
    """ The layout data object to use with AbstractFlowWidget instances.

    For performance reasons, there are no runtime checks on the limits
    of the values assigned to this class. Users should ensure that the
    values assigned conform to the documented limits. Users must set
    the `dirty` flag to True before calling `updateGeometry` in order
    for changes to have effect.

    """
    #: Whether or not the computed info for the layout item is dirty.
    #: This must be set to True before calling `updateGeometry` on
    #: the owner widget.
    dirty = True

    #: The flow stretch factor of the layout item. This value controls
    #: the amount of space that is taken up by an expandable item in the
    #: direction of the layout flow, relative to the other items in the
    #: line. The minimum is 0 which means the item should not expand.
    #: There is no maximum. The default is 0.
    stretch = 0

    #: The ortho stretch factor of the layout item. This value controls
    #: the amount of space that is taken up by an expandable item in the
    #: direction orthogonal to the layout flow, relative to other items
    #: in the line. The minimum is 0 which means the item should not
    #: expand. There is no maximum. The default is 0.
    ortho_stretch = 0

    #: The alignment of the layout item in the direction orthogonal to
    #: the layout flow. This must be one of the enums Qt.AlignLeading,
    #: Qt.AlignTrailing, or Qt.AlignCenter.
    alignment = Qt.AlignLeading

    #: The preferred size for the layout item. This size will be used
    #: as the size of the layout item to the extent possible. If this
    #: size is invalid in a particular dimension, the sizeHint of the
    #: item in that direction will be used.
    preferred_size = QSize()

    def __init__(self):
        """ Initialize a FlowLayoutData.

        """
        self.preferred_size = QSize()


class QFlowWidgetItem(QWidgetItem):
    """ A custom QWidgetItem for use with the QFlowLayout.

    """
    #: The FlowLayoutData associated with this widget item. It is a
    #: publically accesible attribute for performance reasons.
    data = None

    def __init__(self, widget, data):
        """ Initialize a QFlowWidgetItem.

        Parameters
        ----------
        widget : QWidget
            The widget to manage with this item.

        data : FlowLayoutData
            The layout data struct associated with this item.

        """
        super(QFlowWidgetItem, self).__init__(widget)
        self.data = data
        self._cached_hint = QSize()
        self._cached_max = QSize()
        self._cached_min = QSize()

    def maximumSize(self):
        """ Reimplemented maximum size computation.

        The max size for a flow widget item is cached and recomputed
        only when the widget item is invalidated.

        """
        if not self._cached_max.isValid():
            self._cached_max = super(QFlowWidgetItem, self).maximumSize()
        return self._cached_max

    def minimumSize(self):
        """ Reimplemented minimum size computation.

        The min size for a flow widget item is cached and recomputed
        only when the widget item is invalidated.

        """
        if not self._cached_min.isValid():
            self._cached_min = super(QFlowWidgetItem, self).minimumSize()
        return self._cached_min

    def sizeHint(self):
        """ Reimplemented size hint computation.

        The size hint for a flow widget item is cached and recomputed
        only when the widget item is invalidated. The size hint is the
        valid union of the preferred size, as indicated by the layout
        data, and the size hint of the widget.

        """
        if not self._cached_hint.isValid():
            hint = super(QFlowWidgetItem, self).sizeHint()
            pref = self.data.preferred_size
            smin = self.minimumSize()
            smax = self.maximumSize()
            if pref.width() != -1:
                pw = max(smin.width(), min(pref.width(), smax.width()))
                hint.setWidth(pw)
            if pref.height() != -1:
                ph = max(smin.height(), min(pref.height(), smax.height()))
                hint.setHeight(ph)
            self._cached_hint = hint
        return self._cached_hint

    def setGeometry(self, rect):
        """ Set the rectangle covered by this layout item.

        This reimplemented method ensures that layout always occurs at
        the origin of the given rect. The default QWidgetItem behavior
        is to center the item in the given space.

        Parameters
        ----------
        rect : QRect
            The rectangle that this layout item should cover.

        """
        if self.isEmpty():
            return
        s = rect.size().boundedTo(self.maximumSize())
        self.widget().setGeometry(rect.x(), rect.y(), s.width(), s.height())

    def invalidate(self):
        """ Invalidate the internal cached data for this widget item.

        The invalidation will only have an effect if the layout data
        associate with this item is marked as dirty.

        """
        if self.data.dirty:
            self._cached_hint = QSize()
            self._cached_min = QSize()
            self.data.dirty = False


class _LayoutRow(object):
    """ A private class used by QFlowLayout.

    This class accumulates information about a row of items as the items
    are added to the row. Instances of the this class are created by the
    QFlowLayout during a layout pass. For performance reasons, there are
    several publically accesible attributes. See their documentation for
    restrictions on their use.

    """
    #: The height to use for laying out the row. This attribute is
    #: modified directly by the layout as it distributes the vertical
    #: space amongst the rows.
    layout_height = 0

    #: The minimum height required for the row. This is automatically
    #: updated as items are added to the row. It should be considered
    #: read-only to external users.
    min_height = 0

    #: The minimum width required for the row. This is automatically
    #: updated as items are added to the row. It should be considered
    #: read-only to external users.
    min_width = 0

    #: The desired height for the row. This is automatically updated as
    #: items are added to the row. It should be considered read-only to
    #: external users.
    hint_height = 0

    #: The desired width for the row. This is automatically updated as
    #: items are added to the row. It should be considered read-only to
    #: external users.
    hint_width = 0

    #: The vertical stretch factor for the row. This is automatically
    #: updated as items are added to the row. It should be considered
    #: read-only by external users.
    stretch = 0

    def __init__(self, width, options):
        """ Initialize a layout row.

        Parameters
        ----------
        width : int
            The width of the layout area.

        options : _LayoutOptions
            The options in effect for the layout.

        """
        self._width = width
        self._options = options
        self._items_stretch = 0
        self._items = []

    @property
    def diff_height(self):
        """ A read-only property which computes the difference between
        the desired height and the minimum height.

        """
        return self.hint_height - self.min_height

    def add_item(self, item):
        """ Add an item to the layout row.

        Parameters
        ----------
        item : QFlowWidgetItem
            The flow widget item to add to the layout row.

        Returns
        -------
        result : bool
            True if the items was added. False if the item was not
            added. An item will not be added if the row already
            contains an item and adding another item would cause
            it to overflow.

        """
        min_size = item.minimumSize()
        hint_size = item.sizeHint()
        n = len(self._items)
        s = self._options.h_spacing
        if n > 0 and (self.hint_width + s + hint_size.width()) > self._width:
            return False
        self.min_height = max(self.min_height, min_size.height())
        self.hint_height = max(self.hint_height, hint_size.height())
        self.stretch = max(self.stretch, item.data.ortho_stretch)
        self.min_width += min_size.width()
        self.hint_width += hint_size.width()
        self._items_stretch += item.data.stretch
        if n > 0:
            self.min_width += s
            self.hint_width += s
        self._items.append(item)
        return True

    def layout(self, x, y):
        """ Layout the row using the given starting coordinates.

        Parameters
        ----------
        x : int
            The x coordinate of the row origin.

        y : int
            The y coordinate of the row origin.

        """
        opts = self._options
        layout_width = self._width
        layout_height = self.layout_height
        delta = self._width - self.hint_width
        items = self._items

        # Short circuit the case where there is negative extra space.
        # This means that there must be only a single item in the row,
        # in which case the width may shrink to the minimum if needed.
        if delta < 0:
            assert len(items) == 1
            item = items[0]
            w = max(layout_width, item.minimumSize().width())
            if item.data.ortho_stretch > 0:
                h = min(layout_height, item.maximumSize().height())
            else:
                h = min(layout_height, item.sizeHint().height())
            delta_h = layout_height - h
            if delta_h > 0:
                align = item.data.alignment
                if align == QFlowLayout.AlignTrailing:
                    y += delta_h
                elif align == QFlowLayout.AlignCenter:
                    y += delta_h / 2
            item.setGeometry(QRect(x, y, w, h))
            return

        # Reversing the items reverses the layout direction. All of the
        # computation up to this point has be independent of direction.
        if opts.direction == QFlowLayout.RightToLeft:
            items.reverse()

        # Precompute a map of starting widths for the items. These will
        # be progressively modified as the delta space is distributed.
        widths = {}
        for item in items:
            widths[item] = item.sizeHint().width()

        # If the flow stretch for the row is greater than zero. Then
        # there exists an item or items which have flow stretch. It's
        # not sufficient to simply distribute the delta space according
        # to relative stretch factors, because an item may have a max
        # width which is less than the adjusted width. This causes the
        # rest of the adjustments to be invalid, yielding a potential
        # O(n^2) solution. Instead, the items which can stretch are
        # sorted according to the differences between their desired
        # width and max width. When distributing the delta space in this
        # order, any unused space from an item is added back to the pool
        # and its stretch factor removed from further computation. This
        # gives an O(n log n) solution to the problem. This algorithm
        # iteratively removes space from the delta, so that the alignment
        # pass below operates on the adjusted free space amount.
        items_stretch = self._items_stretch
        if items_stretch > 0:
            diffs = []
            for item in items:
                if item.data.stretch > 0:
                    h = item.sizeHint().width()
                    m = item.maximumSize().width()
                    diffs.append((m - h, item))
            diffs.sort()
            for ignored, item in diffs:
                item_stretch = item.data.stretch
                max_width = item.maximumSize().width()
                d = item_stretch * delta / items_stretch
                items_stretch -= item_stretch
                item_width = widths[item]
                if item_width + d > max_width:
                    widths[item] = max_width
                    delta -= max_width - item_width
                else:
                    widths[item] = item_width + d
                    delta -= d

        # The widths of all items are now computed. Any leftover delta
        # space is used for alignment purposes. This is accomplished by
        # shifting the starting location and, in the case of justify,
        # adding to the horizontal space value.
        start_x = x
        space = opts.h_spacing
        if opts.alignment == QFlowLayout.AlignLeading:
            if opts.direction == QFlowLayout.RightToLeft:
                start_x += delta
        elif opts.alignment == QFlowLayout.AlignTrailing:
            if opts.direction == QFlowLayout.LeftToRight:
                start_x += delta
        elif opts.alignment == QFlowLayout.AlignCenter:
            start_x += delta / 2
        else:
            d = delta / (len(items) + 1)
            space += d
            start_x += d

        # Make a final pass over the items and perform the layout. This
        # pass handles the orthogonal alignment of the item if there is
        # any leftover vertical space for the item.
        curr_x = start_x
        for item in items:
            w = widths[item]
            if item.data.ortho_stretch > 0:
                h = min(layout_height, item.maximumSize().height())
            else:
                h = min(layout_height, item.sizeHint().height())
            delta = layout_height - h
            this_y = y
            if delta > 0:
                align = item.data.alignment
                if align == QFlowLayout.AlignTrailing:
                    this_y = y + delta
                elif align == QFlowLayout.AlignCenter:
                    this_y = y + delta / 2
            item.setGeometry(QRect(curr_x, this_y, w, h))
            curr_x += (w + space)


class _LayoutColumn(object):
    """ A private class used by QFlowLayout.

    This class accumulates information about a column of items as the
    items are added to the column. Instances of the this class are
    created by the QFlowLayout during a layout pass. For performance
    reasons, there are several publically accesible attributes. See
    their documentation for restrictions on their use.

    """
    #: The width to use for laying out the column. This attribute is
    #: modified directly by the layout as it distributes the horizontal
    #: space amongst the columns.
    layout_width = 0

    #: The minimum height required for the column. This is automatically
    #: updated as items are added to the column. It should be considered
    #: read-only to external users.
    min_height = 0

    #: The minimum width required for the column. This is automatically
    #: updated as items are added to the column. It should be considered
    #: read-only to external users.
    min_width = 0

    #: The desired height for the column. This is automatically updated
    #: as items are added to the column. It should be considered
    #: read-only to external users.
    hint_height = 0

    #: The desired width for the column. This is automatically updated
    #: as items are added to the column. It should be considered
    #: read-only to external users.
    hint_width = 0

    #: The vertical stretch factor for the column. This is automatically
    #: updated as items are added to the column. It should be considered
    #: read-only by external users.
    stretch = 0

    def __init__(self, height, options):
        """ Initialize a layout column.

        Parameters
        ----------
        height : int
            The height of the layout area.

        options : _LayoutOptions
            The options in effect for the layout.

        """
        self._height = height
        self._options = options
        self._items_stretch = 0
        self._items = []

    @property
    def diff_width(self):
        """ A read-only property which computes the difference between
        the desired width and the minimum width.

        """
        return self.hint_width - self.min_width

    def add_item(self, item):
        """ Add an item to the layout column.

        Parameters
        ----------
        item : QFlowWidgetItem
            The flow widget item to add to the layout column.

        Returns
        -------
        result : bool
            True if the items was added. False if the item was not
            added. An item will not be added if the column already
            contains an item and adding another item would cause
            it to overflow.

        """
        min_size = item.minimumSize()
        hint_size = item.sizeHint()
        n = len(self._items)
        s = self._options.v_spacing
        if n > 0 and self.hint_height + s + hint_size.height() > self._height:
            return False
        self.min_width = max(self.min_width, min_size.width())
        self.hint_width = max(self.hint_width, hint_size.width())
        self.stretch = max(self.stretch, item.data.ortho_stretch)
        self.min_height += min_size.height()
        self.hint_height += hint_size.height()
        self._items_stretch += item.data.stretch
        if n > 0:
            self.min_height += s
            self.hint_height += s
        self._items.append(item)
        return True

    def layout(self, x, y):
        """ Layout the row using the given starting coordinates.

        Parameters
        ----------
        x : int
            The x coordinate of the column origin.

        y : int
            The y coordinate of the column origin.

        """
        opts = self._options
        layout_height = self._height
        layout_width = self.layout_width
        delta = self._height - self.hint_height
        items = self._items

        # Short circuit the case where there is negative extra space.
        # This means that there must be only a single item in the column,
        # in which case the height may shrink to the minimum if needed.
        if delta < 0:
            assert len(items) == 1
            item = items[0]
            h = max(layout_height, item.minimumSize().height())
            if item.data.ortho_stretch > 0:
                w = min(layout_width, item.maximumSize().width())
            else:
                w = min(layout_width, item.sizeHint().width())
            delta_w = layout_width - w
            if delta_w > 0:
                align = item.data.alignment
                if align == QFlowLayout.AlignTrailing:
                    x += delta_w
                elif align == QFlowLayout.AlignCenter:
                    x += delta_w / 2
            item.setGeometry(QRect(x, y, w, h))
            return

        # Reversing the items reverses the layout direction. All of the
        # computation up to this point has be independent of direction.
        if opts.direction == QFlowLayout.BottomToTop:
            items.reverse()

        # Precompute a map of starting heights for the items. These will
        # be progressively modified as the delta space is distributed.
        heights = {}
        for item in items:
            heights[item] = item.sizeHint().height()

        # See the long comment in _LayoutRow for the explanation about
        # this section of code. This section is simply the transpose.
        items_stretch = self._items_stretch
        if items_stretch > 0:
            diffs = []
            for item in items:
                if item.data.stretch > 0:
                    h = item.sizeHint().height()
                    m = item.maximumSize().height()
                    diffs.append((m - h, item))
            diffs.sort()
            for ignored, item in diffs:
                item_stretch = item.data.stretch
                max_height = item.maximumSize().height()
                d = item_stretch * delta / items_stretch
                items_stretch -= item_stretch
                item_height = heights[item]
                if item_height + d > max_height:
                    heights[item] = max_height
                    delta -= max_height - item_height
                else:
                    heights[item] = item_height + d
                    delta -= d

        # The heights of all items are now computed. Any leftover delta
        # space is used for alignment purposes. This is accomplished by
        # shifting the starting location and, in the case of justify,
        # adding to the vertical space value.
        start_y = y
        space = opts.v_spacing
        if opts.alignment == QFlowLayout.AlignLeading:
            if opts.direction == QFlowLayout.BottomToTop:
                start_y += delta
        elif opts.alignment == QFlowLayout.AlignTrailing:
            if opts.direction == QFlowLayout.TopToBottom:
                start_y += delta
        elif opts.alignment == QFlowLayout.AlignCenter:
            start_y += delta / 2
        else:
            d = delta / (len(items) + 1)
            space += d
            start_y += d

        # Make a final pass over the items and perform the layout. This
        # pass handles the orthogonal alignment of the item if there is
        # any leftover horizontal space for the item.
        curr_y = start_y
        for item in items:
            h = heights[item]
            if item.data.ortho_stretch > 0:
                w = min(layout_width, item.maximumSize().width())
            else:
                w = min(layout_width, item.sizeHint().width())
            delta = layout_width - w
            this_x = x
            if delta > 0:
                align = item.data.alignment
                if align == QFlowLayout.AlignTrailing:
                    this_x = x + delta
                elif align == QFlowLayout.AlignCenter:
                    this_x = x + delta / 2
            item.setGeometry(QRect(this_x, curr_y, w, h))
            curr_y += (h + space)


class QFlowLayout(QLayout):
    """ A custom QLayout which implements a flowing wraparound layout.

    """
    #: Lines are filled from left to right and stacked top to bottom.
    LeftToRight = 0

    #: Lines are filled from right to left and stacked top to bottom.
    RightToLeft = 1

    #: Lines are filled from top to bottom and stacked left to right.
    TopToBottom = 2

    #: Lines are filled from bottom to top and stacked left to right.
    BottomToTop = 3

    #: Lines are aligned to their leading edge.
    AlignLeading = 4

    #: Lines are aligned to their trailing edge.
    AlignTrailing = 5

    #: Lines are aligned centered within any extra space.
    AlignCenter = 6

    #: Lines are aligned justified within any extra space.
    AlignJustify = 7

    def __init__(self):
        """ Initialize a QFlowLayout.

        """
        super(QFlowLayout, self).__init__()
        self._items = []
        self._options = _LayoutOptions()
        self._cached_w = -1
        self._cached_hfw = -1
        self._cached_min = None
        self._cached_hint = None
        self._wfh_size = None

    def addWidget(self, widget):
        """ Add a widget to the end of the flow layout.

        Parameters
        ----------
        widget : AbstractFlowWidget
            The flow widget to add to the layout.

        """
        self.insertWidget(self.count(), widget)

    def insertWidget(self, index, widget):
        """ Insert a widget into the flow layout.

        Parameters
        ----------
        index : int
            The index at which to insert the widget.

        widget : AbstractFlowWidget
            The flow widget to insert into the layout.

        """
        assert isinstance(widget, AbstractFlowWidget), 'invalid widget type'
        self.addChildWidget(widget)
        item = QFlowWidgetItem(widget, widget.layoutData())
        self._items.insert(index, item)
        widget.show()
        self.invalidate()

    def direction(self):
        """ Get the direction of the flow layout.

        Returns
        -------
        result : QFlowLayout direction enum
            The direction of the layout. The default is LeftToRight.

        """
        return self._options.direction

    def setDirection(self, direction):
        """ Set the direction of the flow layout.

        Parameters
        ----------
        direction : QFlowLayout direction enum
            The desired flow direction of the layout.

        """
        self._options.direction = direction
        self.invalidate()

    def alignment(self):
        """ Get the alignment for the lines in the layout.

        Returns
        -------
        result : QFlowLayout alignment enum
            The alignment of the lines in the layout. The default is
            AlignLeading.

        """
        return self._options.alignment

    def setAlignment(self, alignment):
        """ Set the alignment for the lines in the layout.

        Parameters
        ----------
        alignment : QFlowLayout alignment enum
            The desired alignment of the lines in the layout.

        """
        self._options.alignment = alignment
        self.invalidate()

    def horizontalSpacing(self):
        """ Get the horizontal spacing for the layout.

        Returns
        -------
        result : int
            The number of pixels of horizontal space between items in
            the layout. The default is 10px.

        """
        return self._options.h_spacing

    def setHorizontalSpacing(self, spacing):
        """ Set the horizontal spacing for the layout.

        Parameters
        ----------
        spacing : int
            The number of pixels of horizontal space to place between
            items in the layout.

        """
        self._options.h_spacing = spacing
        self.invalidate()

    def verticalSpacing(self):
        """ Get the vertical spacing for the layout.

        Returns
        -------
        result : int
            The number of pixels of vertical space between items in the
            layout. The default is 10px.

        """
        return self._options.v_spacing

    def setVerticalSpacing(self, spacing):
        """ Set the vertical spacing for the layout.

        Parameters
        ----------
        spacing : int
            The number of pixels of vertical space to place between
            items in the layout.

        """
        self._options.v_spacing = spacing
        self.invalidate()

    def hasHeightForWidth(self):
        """ Whether the height of the layout depends on its width.

        Returns
        -------
        result : bool
            True if the flow direction is horizontal, False otherwise.

        """
        return self._options.direction in (self.LeftToRight, self.RightToLeft)

    def heightForWidth(self, width):
        """ Get the height of the layout for the given width.

        This value only applies if `hasHeightForWidth` returns True.

        Parameters
        ----------
        width : int
            The width for which to determine a height.

        """
        if self._cached_w != width:
            left, top, right, bottom = self.getContentsMargins()
            adj_width = width - (left + right)
            height = self._doLayout(QRect(0, 0, adj_width, 0), True)
            self._cached_hfw = height + top + bottom
            self._cached_w = adj_width
        return self._cached_hfw

    def addItem(self, item):
        """ A required virtual method implementation.

        This method should not be used. The methods `addWidget` and
        `insertWidget` should be used instead.

        """
        msg = 'Use `addWidget` and `insertWidget` instead.'
        raise NotImplementedError(msg)

    def invalidate(self):
        """ Invalidate the cached values of the layout.

        """
        self._cached_w = -1
        self._cached_hfw = -1
        self._cached_wfh = -1
        self._cached_min = None
        self._cached_hint = None
        for item in self._items:
            item.invalidate()
        super(QFlowLayout, self).invalidate()

    def count(self):
        """ A virtual method implementation which returns the number of
        items in the layout.

        """
        return len(self._items)

    def itemAt(self, idx):
        """ A virtual method implementation which returns the layout item
        for the given index or None if one does not exist.

        """
        items = self._items
        if idx < len(items):
            return items[idx]

    def takeAt(self, idx):
        """ A virtual method implementation which removes and returns the
        item at the given index or None if one does not exist.

        """
        items = self._items
        if idx < len(items):
            item = items[idx]
            del items[idx]
            item.widget().hide()
            # The creation path of the layout items bypasses the virtual
            # wrapper methods, this means that the ownership of the cpp
            # pointer is never transfered to Qt. If the item is returned
            # here it will be delete by Qt, which doesn't own the pointer.
            # A double free occurs once the Python item falls out of scope.
            # To avoid this, this method always returns None and the item
            # cleanup is performed by Python, which owns the cpp pointer.

    def setGeometry(self, rect):
        """ Sets the geometry of all the items in the layout.

        """
        super(QFlowLayout, self).setGeometry(rect)
        self._doLayout(self.contentsRect())

    def sizeHint(self):
        """ A virtual method implementation which returns the size hint
        for the layout.

        """
        if self._cached_hint is None:
            size = QSize(0, 0)
            for item in self._items:
                size = size.expandedTo(item.sizeHint())
            left, top, right, bottom = self.getContentsMargins()
            size.setWidth(size.width() + left + right)
            size.setHeight(size.height() + top + bottom)
            self._cached_hint = size
        return self._cached_hint

    def minimumSize(self):
        """ A reimplemented method which returns the minimum size hint
        of the layout item widget as the minimum size of the window.

        """
        if self._cached_min is None:
            size = QSize(0, 0)
            for item in self._items:
                size = size.expandedTo(item.minimumSize())
            left, top, right, bottom = self.getContentsMargins()
            size.setWidth(size.width() + left + right)
            size.setHeight(size.height() + top + bottom)
            self._cached_min = size
        # XXX hack! We really need hasWidthForHeight! This doesn't quite
        # work because a QScrollArea internally caches the min size.
        d = self._options.direction
        if d == self.TopToBottom or d == self.BottomToTop:
            m = QSize(self._cached_min)
            if m.width() < self._cached_wfh:
                m.setWidth(self._cached_wfh)
            return m
        return self._cached_min

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _doLayout(self, rect, test=False):
        """ Perform the layout for the given rect.

        Parameters
        ----------
        rect : QRect
            The area to use for performing the layout.

        test : bool, optional
            If True, perform a trial run of the layout without actually
            updating any of the item geometries.

        Returns
        -------
        result : int
            The layout space (width or height) required in the direction
            orthogonal to the layout flow.

        """
        d = self._options.direction
        if d == self.LeftToRight or d == self.RightToLeft:
            res = self._doHorizontalLayout(rect, test)
        else:
            res = self._doVerticalLayout(rect, test)
            # XXX hack! we need hasWidthForHeight
            self._cached_wfh = res + rect.x()
        return res

    def _doHorizontalLayout(self, rect, test):
        """ Perform the layout for a horizontal flow direction.

        The method signature is identical to the `_doLayout` method.

        """
        # Walk over the items and create the layout rows.
        rows = []
        width = rect.width()
        opts = self._options
        for item in self._items:
            if len(rows) == 0:
                row = _LayoutRow(width, opts)
                row.add_item(item)
                rows.append(row)
            else:
                row = rows[-1]
                if not row.add_item(item):
                    row = _LayoutRow(width, opts)
                    row.add_item(item)
                    rows.append(row)

        # After collecting rows all of the rows, compute the metrics. If
        # this is a test run, only the minimum height is required.
        space = opts.v_spacing * (len(rows) - 1)
        if test:
            return sum(row.min_height for row in rows) + space

        min_height = space
        hint_height = space
        total_diff = 0
        stretch = 0
        for row in rows:
            min_height += row.min_height
            hint_height += row.hint_height
            total_diff += row.diff_height
            stretch += row.stretch

        # Make an initial pass to distribute extra space to rows which
        # lie between their minimum height and desired height.
        height = rect.height()
        play_space = max(0, height - min_height)
        diff_space = max(total_diff, 1)  # Guard against divide by zero
        layout_height = 0
        for row in rows:
            d = play_space * row.diff_height / diff_space
            row.layout_height = min(row.min_height + d, row.hint_height)
            layout_height += row.layout_height
        layout_height += space

        # Make a second pass to distribute remaining space to rows
        # which with a stretch factor greater than zero.
        remaining = height - layout_height
        if remaining > 0 and stretch > 0:
            for row in rows:
                if row.stretch > 0:
                    row.layout_height += remaining * row.stretch / stretch

        # Make a final pass to layout the rows, computing the overall
        # final layout height along the way.
        final_height = 0
        x = rect.x()
        curr_y = rect.y()
        v_space = opts.v_spacing
        for row in rows:
            row.layout(x, curr_y)
            d = row.layout_height + v_space
            final_height += d
            curr_y += d

        return final_height

    def _doVerticalLayout(self, rect, test):
        """ Perform the layout for a vertical flow direction.

        The method signature is identical to the `_doLayout` method.

        """
        # Walk over the items and create the layout columns.
        cols = []
        height = rect.height()
        opts = self._options
        for item in self._items:
            if len(cols) == 0:
                col = _LayoutColumn(height, opts)
                col.add_item(item)
                cols.append(col)
            else:
                col = cols[-1]
                if not col.add_item(item):
                    col = _LayoutColumn(height, opts)
                    col.add_item(item)
                    cols.append(col)

        # After collecting rows all of the columns, compute the metrics.
        # If this is a test run, only the minimum width is required.
        space = opts.h_spacing * (len(cols) - 1)
        if test:
            return sum(col.min_width for col in cols) + space

        min_width = space
        hint_width = space
        total_diff = 0
        stretch = 0
        for col in cols:
            min_width += col.min_width
            hint_width += col.hint_width
            total_diff += col.diff_width
            stretch += col.stretch

        # Make an initial pass to distribute extra space to columns
        # which lie between their minimum width and desired width.
        width = rect.width()
        play_space = max(0, width - min_width)
        diff_space = max(total_diff, 1)  # Guard against divide by zero
        layout_width = 0
        for col in cols:
            d = play_space * col.diff_width / diff_space
            col.layout_width = min(col.min_width + d, col.hint_width)
            layout_width += col.layout_width
        layout_width += space

        # Make a second pass to distribute remaining space to columns
        # which with a stretch factor greater than zero.
        remaining = width - layout_width
        if remaining > 0 and stretch > 0:
            for col in cols:
                if col.stretch > 0:
                    col.layout_width += remaining * col.stretch / stretch

        # Make a final pass to layout the columns, computing the overall
        # final layout width along the way.
        final_width = 0
        y = rect.y()
        curr_x = rect.x()
        h_space = opts.h_spacing
        for col in cols:
            col.layout(curr_x, y)
            d = col.layout_width + h_space
            final_width += d
            curr_x += d

        return final_width


class _LayoutOptions(object):
    """ A private class used by QFlowLayout to store layout options.

    """
    #: The flow direction of the layout.
    direction = QFlowLayout.LeftToRight

    #: The alignment of a line in the layout.
    alignment = QFlowLayout.AlignLeading

    #: The horizontal spacing between items or lines in the layout.
    h_spacing = 10

    #: The vertical spacing between items or lines in the layout.
    v_spacing = 10

########NEW FILE########
__FILENAME__ = q_pixmap_painter
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from .QtCore import QObject, QEvent, Slot
from .QtGui import QPainter, QPixmap


class QPixmapPainter(QObject):
    """ A QObject class which will paint a pixmap onto a QWidget.

    """
    def __init__(self):
        """ Initialize a QPixmapPainter.

        """
        super(QPixmapPainter, self).__init__()
        self._target = None
        self._pixmap = None

    #--------------------------------------------------------------------------
    # Slots
    #--------------------------------------------------------------------------
    @Slot(QPixmap)
    def drawPixmap(self, pixmap):
        """ Draw the given pixmap onto the parent widget.

        This method is also a Slot which can be connected to signal that
        emits a QPixmap payload.

        Parameters
        ----------
        pixmap : QPixmap
            The pixmap to draw in on the parent.

        """
        self._pixmap = pixmap
        target = self._target
        if target is not None:
            target.update()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def targetWidget(self):
        """ Get the target widget of this painter.

        Returns
        -------
        result : QWidget or None
            The target widget onto which this painter will paint, or
            None if a widget has not yet been provided.

        """
        return self._target

    def setTargetWidget(self, widget):
        """ Set the target widget for this painter.

        Parameters
        ----------
        widget : QWidget
            The widget onto which this painter will paint incoming
            pixmaps.

        """
        old = self._target
        if old is not None:
            old.removeEventFilter(self)
        if widget is not None:
            widget.installEventFilter(self)
        self._target = widget

    def eventFilter(self, obj, event):
        """ Filter the events for the given object.

        This method will only filter paint events for the target of this
        object. If there is a pixmap available for drawing, then that
        will be drawn onto the target.

        """
        if event.type() == QEvent.Paint:
            if obj is self._target:
                pm = self._pixmap
                if pm is not None:
                    painter = QPainter(obj)
                    painter.drawPixmap(0, 0, pm)
                    return True
        return False

########NEW FILE########
__FILENAME__ = q_pixmap_transition
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from .QtCore import QPoint, QPointF, QRect, QVariantAnimation, Signal
from .QtGui import QPainter, QPixmap, QPainterPath


class QPixmapTransition(QVariantAnimation):
    """ A QVariantAnimation subclass for building transitions between
    two QPixmaps.

    This is an abstract base class which provides common functionality
    for creating concrete transitions.

    """
    #: A signal emmitted when the output pixmap has been updated with
    #: a new frame in the transition animation. The paylod will be the
    #: output pixmap of the transition.
    pixmapUpdated = Signal(QPixmap)

    def __init__(self):
        """ Initialize a QPixmapTransition.

        """
        super(QPixmapTransition, self).__init__()
        self._start_pixmap = None
        self._end_pixmap = None
        self._out_pixmap = None

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def startPixmap(self):
        """ Get the starting pixmap for the transition.

        Returns
        -------
        result : QPixmap or None
            The starting pixmap for the transition or None if it has
            not yet been provided.

        """
        return self._start_pixmap

    def endPixmap(self):
        """ Get the ending pixmap for the transition.

        Returns
        -------
        result : QPixmap or None
            The ending pixmap for the transition or None if it has
            not yet been provided.

        """
        return self._end_pixmap

    def outPixmap(self):
        """ Get the output pixmap for the transition.

        Returns
        -------
        result : QPixmap or None
            The output pixmap for the transition or None if it has
            not yet been provided.

        """
        return self._out_pixmap

    def setPixmaps(self, start, end, out):
        """ Set the pixmaps to use during the transition.

        Parameters
        ----------
        start : QPixmap
            The pixmap for the first frame of the transition.

        end : QPixmap
            The pixmap for the last frame of the transition.

        out : QPixmap
            The pixmap into which the intermediate transition frames
            will be drawn.

        """
        self._start_pixmap = start
        self._end_pixmap = end
        self._out_pixmap = out

    def start(self):
        """ Start the pixmap transition.

        This is an overridden parent class method which provides a
        hook for subclasses to prepare their working pixmaps before
        the animation is started.

        """
        start, end = self.preparePixmap()
        self.setStartValue(start)
        self.setEndValue(end)
        super(QPixmapTransition, self).start()

    def updateCurrentValue(self, value):
        """ Updates the current transition value.

        This method will dispatch to the `updatePixmap` method provided
        that the current animation state is `Running` and then emit
        the `pixmapUpdated` signal.

        Parameters
        ----------
        value : object
            The variant interpolated object value for the current step
            in the animation.

        """
        if self.state() == self.Running:
            self.updatePixmap(value)
            self.pixmapUpdated.emit(self.outPixmap())

    #--------------------------------------------------------------------------
    # Abstract API
    #--------------------------------------------------------------------------
    def preparePixmap(self):
        """ Prepare the underlying pixmap(s) for the transition.

        This method is abstract and must be implemented by subclasses.
        It is called directly before the transition is started. The
        subclass should do any required transition initialization in
        this method.

        Returns
        -------
        result : (start, end)
            The start and end values to use when interpolating the
            transition. The interpolated values will be passed to
            the `updatePixmap` method.

        """
        raise NotImplementedError

    def updatePixmap(self, value):
        """ Update the underlying output pixmap for the transition.

        This method is abstract and must be implemented by subclasses.
        It is called during the transition with an interpolated value
        appopriate for the current transition step.

        Parameters
        ----------
        value : object
            The interpolated value between the values of `start` and
            `end` returned by the `preparePixmap` method.

        """
        raise NotImplementedError


class QDirectedTransition(QPixmapTransition):
    """ A QPixmapTransition which adds a transition direction.

    This is a base class used by several concrete transition classes.
    It is not meant to be used directly.

    """
    #: Transition proceeds from left to right.
    LeftToRight = 0

    #: Transition proceeds from right to left.
    RightToLeft = 1

    #: Transition proceeds from top to bottom.
    TopToBottom = 2

    #: Transition proceeds from bottom to top.
    BottomToTop = 3

    def __init__(self):
        """ Initialize a QDirectedTransition.

        """
        super(QDirectedTransition, self).__init__()
        self._direction = self.RightToLeft

    def direction(self):
        """ Get the direction of the transition.

        Returns
        -------
        result : int
            The direction enum value for the transition.

        """
        return self._direction

    def setDirection(self, direction):
        """ Set the direction of the transition.

        Parameters
        ----------
        direction : int
            The direction enum value for the transition. Must be one
            of `LeftToRight`, `RightToLeft`, `TopToBottom`, or
            `BottomToTop`.

        """
        dirs = (
            self.LeftToRight, self.RightToLeft,
            self.TopToBottom, self.BottomToTop,
        )
        if direction not in dirs:
            raise ValueError('Invalid direction: %s' % direction)
        self._direction = direction


class QSlideTransition(QDirectedTransition):
    """ A QDirectedTransition which animates using a sliding effect.

    """
    def __init__(self):
        """ Initialize a QSlideTransition.

        """
        super(QSlideTransition, self).__init__()
        self._slide_pixmap = None

    def preparePixmap(self):
        """ Prepare the pixmap(s) for the transition.

        This method builds a temporary pixmap containing both the start
        and end pixmaps adjoined. The transition then draws a subrect
        of this pixmap into the output pixmap.

        """
        start = self.startPixmap()
        end = self.endPixmap()
        size = start.size().expandedTo(end.size())
        width = size.width()
        height = size.height()
        direction = self.direction()
        if direction == self.LeftToRight:
            pm = QPixmap(width * 2, height)
            painter = QPainter(pm)
            painter.drawPixmap(0, 0, end)
            painter.drawPixmap(width, 0, start)
            start_rect = QRect(width, 0, width * 2, height)
            end_rect = QRect(0, 0, width, height)
        elif direction == self.RightToLeft:
            pm = QPixmap(width * 2, height)
            painter = QPainter(pm)
            painter.drawPixmap(0, 0, start)
            painter.drawPixmap(width, 0, end)
            start_rect = QRect(0, 0, width, height)
            end_rect = QRect(width, 0, width * 2, height)
        elif direction == self.TopToBottom:
            pm = QPixmap(width, height * 2)
            painter = QPainter(pm)
            painter.drawPixmap(0, 0, end)
            painter.drawPixmap(0, height, start)
            start_rect = QRect(0, height, width, height * 2)
            end_rect = QRect(0, 0, width, height)
        elif direction == self.BottomToTop:
            pm = QPixmap(width, height * 2)
            painter = QPainter(pm)
            painter.drawPixmap(0, 0, start)
            painter.drawPixmap(0, height, end)
            start_rect = QRect(0, 0, width, height)
            end_rect = QRect(0, height, width, height * 2)
        else:
            raise ValueError('Invalid direction: %s' % direction)
        self._slide_pixmap = pm
        return start_rect, end_rect

    def updatePixmap(self, rect):
        """ Update the pixmap for the current transition.

        This method paints the current rect from the internal slide
        pixmap into the output pixmap.

        """
        painter = QPainter(self.outPixmap())
        painter.drawPixmap(QPoint(0, 0), self._slide_pixmap, rect)


class QWipeTransition(QDirectedTransition):
    """ A QDirectedTransition which animates using a wipe effect.

    """
    def preparePixmap(self):
        """ Prepare the pixmap(s) for the transition.

        This method draws the starting pixmap into the output pixmap.
        The transition update then draws over the output with the
        proper portion of the ending pixmap.

        """
        start = self.startPixmap()
        end = self.endPixmap()
        size = start.size().expandedTo(end.size())
        width = size.width()
        height = size.height()
        painter = QPainter(self.outPixmap())
        painter.drawPixmap(0, 0, start)
        direction = self.direction()
        if direction == self.LeftToRight:
            start_rect = QRect(0, 0, 0, height)
        elif direction == self.RightToLeft:
            start_rect = QRect(width, 0, 0, height)
        elif direction == self.TopToBottom:
            start_rect = QRect(0, 0, width, 0)
        elif direction == self.BottomToTop:
            start_rect = QRect(0, height, width, 0)
        else:
            raise ValueError('Invalid direction: %s' % direction)
        end_rect = QRect(0, 0, width, height)
        return start_rect, end_rect

    def updatePixmap(self, rect):
        """ Update the pixmap for the current transition.

        This method paints the current rect from the ending pixmap into
        the proper rect of the output pixmap.

        """
        painter = QPainter(self.outPixmap())
        painter.drawPixmap(rect, self.endPixmap(), rect)


class QIrisTransition(QPixmapTransition):
    """ A QPixmap transition which animates using an iris effect.

    """
    def preparePixmap(self):
        """ Prepare the pixmap(s) for the transition.

        This method draws the starting pixmap into the output pixmap.
        The transition update then sets a circular clipping region on
        the ouput and draws in the ending pixmap.

        """
        start = self.startPixmap()
        end = self.endPixmap()
        painter = QPainter(self.outPixmap())
        painter.drawPixmap(0, 0, start)
        size = start.size().expandedTo(end.size())
        width = size.width()
        height = size.height()
        radius = int((width**2 + height**2) ** 0.5) / 2
        start_rect = QRect(width / 2, height / 2, 0, 0)
        end_rect = QRect(width / 2, height / 2, radius, radius)
        return start_rect, end_rect

    def updatePixmap(self, rect):
        """ Update the pixmap for the current transition.

        This method sets a radial clipping region on the output pixmap
        and draws in the relevant portion of the ending pixamp.

        """
        x = rect.x()
        y = rect.y()
        rx = rect.width()
        ry = rect.height()
        path = QPainterPath()
        path.addEllipse(QPointF(x, y), float(rx), float(ry))
        painter = QPainter(self.outPixmap())
        painter.setClipPath(path)
        painter.drawPixmap(QPoint(0, 0), self.endPixmap())


class QFadeTransition(QPixmapTransition):
    """ A QPixmapTransition which animates using a fade effect.

    """
    def preparePixmap(self):
        """ Prepare the pixmap(s) for the transition.

        This method draws the starting pixmap into the output pixmap.
        The transition updates then draw the relevant pixmaps into
        the output using an appropriate alpha.

        """
        painter = QPainter(self.outPixmap())
        painter.drawPixmap(QPoint(0, 0), self.startPixmap())
        return -1.0, 1.0

    def updatePixmap(self, alpha):
        """ Update the pixmap for the current transition.

        This method first clears the output pixmap. It then draws a
        pixmap using the given alpha value. An alpha value less than
        zero indicates that the starting pixmap should be drawn. A
        value greater than or equal to zero indicates the ending
        pixmap should be drawn.

        """
        out = self.outPixmap()
        painter = QPainter(out)
        painter.eraseRect(0, 0, out.width(), out.height())
        if alpha < 0.0:
            alpha = -1.0 * alpha
            source = self.startPixmap()
        else:
            source = self.endPixmap()
        painter.setOpacity(alpha)
        painter.drawPixmap(QPoint(0, 0), source)


class QCrossFadeTransition(QPixmapTransition):
    """ A QPixmapTransition which animates using a cross fade effect.

    """
    def preparePixmap(self):
        """ Prepare the pixmap(s) for the transition.

        This method draws the starting pixmap into the output pixmap.
        The transition updates then draw the two pixmaps with an
        appropriate alpha blending value.

        """
        painter = QPainter(self.outPixmap())
        painter.drawPixmap(QPoint(0, 0), self.startPixmap())
        return 0.0, 1.0

    def updatePixmap(self, alpha):
        """ Update the pixmap for the current transition.

        This method first clears the output pixmap. It then draws the
        starting pixmap followed by the ending pixmap. Each pixmap is
        drawn with complementary alpha values.

        """
        out = self.outPixmap()
        painter = QPainter(out)
        painter.eraseRect(0, 0, out.width(), out.height())
        painter.setOpacity(1.0 - alpha)
        painter.drawPixmap(QPoint(0, 0), self.startPixmap())
        painter.setOpacity(alpha)
        painter.drawPixmap(QPoint(0, 0), self.endPixmap())

########NEW FILE########
__FILENAME__ = q_popup_view
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, Bool, Typed, Float, Int, IntEnum

from .QtCore import (
    Qt, QPoint, QPointF, QSize, QRect,QMargins, QPropertyAnimation, QTimer,
    QEvent, Signal
)
from .QtGui import (
    QApplication, QWidget, QLayout, QPainter, QPainterPath, QRegion, QPen,
    QCursor
)

from .q_single_widget_layout import QSingleWidgetLayout


class AnchorMode(IntEnum):
    """ An IntEnum defining the various popup anchor modes.

    """
    #: Anchor to the parent widget.
    Parent = 0

    #: Anchor to current snapped mouse position.
    Cursor = 1


class ArrowEdge(IntEnum):
    """ An IntEnum defining the edge location of the popup arrow.

    """
    #: The left edge of the popup view.
    Left = 0

    #: The right edge of the popup view.
    Right = 1

    #: The top edge of the popup view.
    Top = 2

    #: The bottom edge of the popup view.
    Bottom = 3


class PopupState(Atom):
    """ A class which maintains the public state for a popup view.

    """
    #: The mode to use when computing the anchored position.
    anchor_mode = Typed(AnchorMode, factory=lambda: AnchorMode.Parent)

    #: The anchor location on the parent. The default anchors
    #: the top center of the view to the center of the parent.
    parent_anchor = Typed(QPointF, factory=lambda: QPointF(0.5, 0.5))

    #: The anchor location on the view. The default anchors
    #: the top center of the view to the center of the parent.
    anchor = Typed(QPointF, factory=lambda: QPointF(0.5, 0.0))

    #: The offset of the popup view with respect to the anchor.
    offset = Typed(QPoint, factory=lambda: QPoint(0, 0))

    #: The edge location of the arrow for the view.
    arrow_edge = Typed(ArrowEdge, factory=lambda: ArrowEdge.Left)

    #: The size of the arrow for the view.
    arrow_size = Int(0)

    #: The timeout value to use when closing the view, in seconds.
    timeout = Float(0.0)

    #: The duration for the fade in.
    fade_in_duration = Int(100)

    #: The duration for the fade out.
    fade_out_duration = Int(100)

    #: The computed path to use when drawing the view.
    path = Typed(QPainterPath, factory=lambda: QPainterPath())

    #: The animator to use when showing the view.
    fade_in_animator = Typed(QPropertyAnimation, ())

    #: The animator to use when hiding the view.
    fade_out_animator = Typed(QPropertyAnimation, ())

    #: The timeout timer to use for closing the view.
    close_timer = Typed(QTimer, ())

    #: Whether or not the view closes on click.
    close_on_click = Bool(True)

    #: Whether or not the view is currently in a resize event.
    in_resize_event = Bool(False)

    def init(self, widget):
        """ Initialize the state for the owner widget.

        """
        fade_in = self.fade_in_animator
        fade_in.setTargetObject(widget)
        fade_in.setPropertyName('windowOpacity')
        fade_out = self.fade_out_animator
        fade_out.setTargetObject(widget)
        fade_out.setPropertyName('windowOpacity')
        fade_out.finished.connect(widget.close)
        close_timer = self.close_timer
        close_timer.setSingleShot(True)
        close_timer.timeout.connect(widget.close)


def make_path(size, arrow_size, arrow_edge, offset):
    """ Create the painter path for the view with an edge arrow.

    Parameters
    ----------
    size : QSize
        The size of the view.

    arrow_size : int
        The size of the arrow.

    arrow_edge : ArrowEdge
        The edge location of the arrow.

    offset : int
        The offset along the arrow edge to the arrow center.

    Returns
    -------
    result : QPainterPath
        The painter path for the view.

    """
    w = size.width()
    h = size.height()
    path = QPainterPath()
    if arrow_size <= 0:
        path.moveTo(0, 0)
        path.lineTo(w, 0)
        path.lineTo(w, h)
        path.lineTo(0, h)
        path.lineTo(0, 0)
    elif arrow_edge == ArrowEdge.Bottom:
        ledge = h - arrow_size
        path.moveTo(0, 0)
        path.lineTo(w, 0)
        path.lineTo(w, ledge)
        path.lineTo(offset + arrow_size, ledge)
        path.lineTo(offset, h)
        path.lineTo(offset - arrow_size, ledge)
        path.lineTo(0, ledge)
        path.lineTo(0, 0)
    elif arrow_edge == ArrowEdge.Top:
        path.moveTo(0, arrow_size)
        path.lineTo(offset - arrow_size, arrow_size)
        path.lineTo(offset, 0)
        path.lineTo(offset + arrow_size, arrow_size)
        path.lineTo(w, arrow_size)
        path.lineTo(w, h)
        path.lineTo(0, h)
        path.lineTo(0, arrow_size)
    elif arrow_edge == ArrowEdge.Left:
        path.moveTo(arrow_size, 0)
        path.lineTo(w, 0)
        path.lineTo(w, h)
        path.lineTo(arrow_size, h)
        path.lineTo(arrow_size, offset + arrow_size)
        path.lineTo(0, offset)
        path.lineTo(arrow_size, offset - arrow_size)
        path.lineTo(arrow_size, 0)
    else:
        ledge = w - arrow_size
        path.moveTo(0, 0)
        path.lineTo(ledge, 0)
        path.lineTo(ledge, offset - arrow_size)
        path.lineTo(w, offset)
        path.lineTo(ledge, offset + arrow_size)
        path.lineTo(ledge, h)
        path.lineTo(0, h)
        path.lineTo(0, 0)
    return path


def edge_margins(arrow_size, arrow_edge):
    """ Get the contents margins for a given arrow size and edge.

    Parameters
    ----------
    arrow_size : int
        The size of the arrow in pixels.

    arrow_edge : ArrowEdge
        The edge location of the arrow.

    Returns
    -------
    result : QMargins
        The contents margins for the given arrow spec.

    """
    margins = QMargins()
    if arrow_size > 0:
        if arrow_edge == ArrowEdge.Right:
            margins.setRight(arrow_size)
        elif arrow_edge == ArrowEdge.Bottom:
            margins.setBottom(arrow_size)
        elif arrow_edge == ArrowEdge.Left:
            margins.setLeft(arrow_size)
        else:
            margins.setTop(arrow_size)
    return margins


def is_fully_on_screen(rect):
    """ Get whether or not a rect is fully contained on the screen.

    Parameters
    ----------
    rect : QRect
        The rect of interest.

    Returns
    -------
    result : bool
        True if the rect is fully contained on the screen, False
        otherwise.

    """
    desktop = QApplication.desktop()
    desk_geo = desktop.availableGeometry(rect.topLeft())
    if not desk_geo.contains(rect.topLeft()):
        return False
    desk_geo = desktop.availableGeometry(rect.topRight())
    if not desk_geo.contains(rect.topRight()):
        return False
    desk_geo = desktop.availableGeometry(rect.bottomLeft())
    if not desk_geo.contains(rect.bottomLeft()):
        return False
    desk_geo = desktop.availableGeometry(rect.bottomRight())
    if not desk_geo.contains(rect.bottomRight()):
        return False
    return True


def left_screen_edge(desktop, rect):
    """ Get the x-coordinate of the effective left screen edge.

    Parameters
    ----------
    desktop : QDesktopWidget
        The desktop widget for the application.

    rect : QRect
        The rect of interest.

    Returns
    -------
    result : int
        the x-coordinate of the effective left screen edge.

    """
    p1 = rect.topLeft()
    p2 = rect.bottomLeft()
    g1 = desktop.availableGeometry(p1)
    g2 = desktop.availableGeometry(p2)
    return max(p1.x(), g1.left(), g2.left())


def right_screen_edge(desktop, rect):
    """ Get the x-coordinate of the effective right screen edge.

    Parameters
    ----------
    desktop : QDesktopWidget
        The desktop widget for the application.

    rect : QRect
        The rect of interest.

    Returns
    -------
    result : int
        the x-coordinate of the effective right screen edge.

    """
    p1 = rect.topRight()
    p2 = rect.bottomRight()
    g1 = desktop.availableGeometry(p1)
    g2 = desktop.availableGeometry(p2)
    return min(p1.x(), g1.right(), g2.right())


def top_screen_edge(desktop, rect):
    """ Get the y-coordinate of the effective top screen edge.

    Parameters
    ----------
    desktop : QDesktopWidget
        The desktop widget for the application.

    rect : QRect
        The rect of interest.

    Returns
    -------
    result : int
        the y-coordinate of the effective top screen edge.

    """
    p1 = rect.topLeft()
    p2 = rect.topRight()
    g1 = desktop.availableGeometry(p1)
    g2 = desktop.availableGeometry(p2)
    return max(p1.y(), g1.top(), g2.top())


def bottom_screen_edge(desktop, rect):
    """ Get the y-coordinate of the effective bottom screen edge.

    Parameters
    ----------
    desktop : QDesktopWidget
        The desktop widget for the application.

    rect : QRect
        The rect of interest.

    Returns
    -------
    result : int
        the y-coordinate of the effective bottom screen edge.

    """
    p1 = rect.bottomLeft()
    p2 = rect.bottomRight()
    g1 = desktop.availableGeometry(p1)
    g2 = desktop.availableGeometry(p2)
    return min(p1.y(), g1.bottom(), g2.bottom())


def ensure_on_screen(rect):
    """ Ensure that the given rectangle is fully on-screen.

    If the given rectangle does fit on the screen its position will be
    adjusted so that it fits on screen as close as possible to its
    original position. Rects which are bigger than the screen size
    will necessarily still incur clipping.

    Parameters
    ----------
    rect : QRect
        The global geometry rectangle of interest.

    Returns
    -------
    result : QRect
        A potentially adjust rect which best fits on the screen.

    """
    rect = QRect(rect)
    desktop = QApplication.desktop()
    desk_geo = desktop.availableGeometry(rect.topLeft())
    if desk_geo.contains(rect):
        return rect
    bottom_edge = bottom_screen_edge(desktop, rect)
    if rect.bottom() > bottom_edge:
        rect.moveBottom(bottom_edge)
    right_edge = right_screen_edge(desktop, rect)
    if rect.right() > right_edge:
        rect.moveRight(right_edge)
    top_edge = top_screen_edge(desktop, rect)
    if rect.top() < top_edge:
        rect.moveTop(top_edge)
    left_edge = left_screen_edge(desktop, rect)
    if rect.left() < left_edge:
        rect.moveLeft(left_edge)
    return rect


def adjust_arrow_rect(rect, arrow_edge, target_pos, offset):
    """ Adjust an arrow rectangle to fit on the screen.

    Parameters
    ----------
    rect : QRect
        The rect of interest.

    arrow_edge : ArrowEdge
        The edge on which the arrow will be rendered.

    target_pos : QPoint
        The global target position of the parent anchor.

    offset : QPoint
        The offset to apply to the parent anchor.

    Returns
    -------
    result : tuple
        A 4-tuple of (QRect, ArrowEdge, int, int) which represent the
        adjusted rect, the new arrow edge, and x and y deltas to apply
        to the arrow position.

    """
    ax = ay = 0
    rect = QRect(rect)
    desktop = QApplication.desktop()

    if arrow_edge == ArrowEdge.Left:
        bottom_edge = bottom_screen_edge(desktop, rect)
        if rect.bottom() > bottom_edge:
            ay += rect.bottom() - bottom_edge
            rect.moveBottom(bottom_edge)
        top_edge = top_screen_edge(desktop, rect)
        if rect.top() < top_edge:
            ay -= top_edge - rect.top()
            rect.moveTop(top_edge)
        left_edge = left_screen_edge(desktop, rect)
        if rect.left() < left_edge:
            rect.moveLeft(left_edge)
        right_edge = right_screen_edge(desktop, rect)
        if rect.right() > right_edge:
            arrow_edge = ArrowEdge.Right
            right = target_pos.x() - offset.x()
            rect.moveRight(min(right, right_edge))

    elif arrow_edge == ArrowEdge.Top:
        right_edge = right_screen_edge(desktop, rect)
        if rect.right() > right_edge:
            ax += rect.right() - right_edge
            rect.moveRight(right_edge)
        left_edge = left_screen_edge(desktop, rect)
        if rect.left() < left_edge:
            ax -= left_edge - rect.left()
            rect.moveLeft(left_edge)
        top_edge = top_screen_edge(desktop, rect)
        if rect.top() < top_edge:
            rect.moveTop(top_edge)
        bottom_edge = bottom_screen_edge(desktop, rect)
        if rect.bottom() > bottom_edge:
            arrow_edge = ArrowEdge.Bottom
            bottom = target_pos.y() - offset.y()
            rect.moveBottom(min(bottom, bottom_edge))

    elif arrow_edge == ArrowEdge.Right:
        bottom_edge = bottom_screen_edge(desktop, rect)
        if rect.bottom() > bottom_edge:
            ay += rect.bottom() - bottom_edge
            rect.moveBottom(bottom_edge)
        top_edge = top_screen_edge(desktop, rect)
        if rect.top() < top_edge:
            ay -= top_edge - rect.top()
            rect.moveTop(top_edge)
        right_edge = right_screen_edge(desktop, rect)
        if rect.right() > right_edge:
            rect.moveRight(right_edge)
        left_edge = left_screen_edge(desktop, rect)
        if rect.left() < left_edge:
            arrow_edge = ArrowEdge.Left
            left = target_pos.x() - offset.x()
            rect.moveLeft(max(left, left_edge))

    else:  # ArrowEdge.Bottom
        right_edge = right_screen_edge(desktop, rect)
        if rect.right() > right_edge:
            ax += rect.right() - right_edge
            rect.moveRight(right_edge)
        left_edge = left_screen_edge(desktop, rect)
        if rect.left() < left_edge:
            ax -= left_edge - rect.left()
            rect.moveLeft(left_edge)
        bottom_edge = bottom_screen_edge(desktop, rect)
        if rect.bottom() > bottom_edge:
            rect.moveBottom(bottom_edge)
        top_edge = top_screen_edge(desktop, rect)
        if rect.top() < top_edge:
            arrow_edge = ArrowEdge.Top
            top = target_pos.y() - offset.y()
            rect.moveTop(max(top, top_edge))

    return rect, arrow_edge, ax, ay


class QPopupView(QWidget):
    """ A custom QWidget which implements a framless popup widget.

    It is useful for showing transient configuration dialogs as well
    as temporary notification windows.

    """
    #: A signal emitted when the popup is fully closed.
    closed = Signal()

    def __init__(self, parent=None, flags=Qt.Popup):
        """ Initialize a QPopupView.

        Parameters
        ----------
        parent : QWidget, optional
            The parent widget of the popup view.

        flags : Qt.WindowFlags, optional
            Additional window flags to use when creating the view.
            The default is Qt.Popup.

        """
        super(QPopupView, self).__init__(parent)
        self.setWindowFlags(flags | Qt.FramelessWindowHint)
        self.setAttribute(Qt.WA_DeleteOnClose)
        layout = QSingleWidgetLayout()
        layout.setSizeConstraint(QLayout.SetMinAndMaxSize)
        self.setLayout(layout)
        self._state = PopupState()
        self._state.init(self)
        if parent is not None:
            parent.installEventFilter(self)
            if not parent.isWindow():
                parent.window().installEventFilter(self)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def centralWidget(self):
        """ Get the central widget for the popup view.

        Returns
        -------
        result : QWidget or None
            The central widget of the popup, or None if no widget
            was provided.

        """
        return self.layout().getWidget()

    def setCentralWidget(self, widget):
        """ Set the central widget for the popup view.

        Parameters
        ----------
        widget : QWidget or None.
            The widget to use as the content of the popup.

        """
        self.layout().setWidget(widget)

    def parentAnchor(self):
        """ Get the parent anchor position for the popup view.

        Returns
        -------
        result : QPointF
            The parent anchor point for the view.

        """
        return self._state.parent_anchor

    def setParentAnchor(self, anchor):
        """ Set the parent anchor position for the popup view.

        Parameters
        ----------
        anchor : QPointF
            The parent anchor point for the view.

        """
        state = self._state
        if anchor != state.parent_anchor:
            state.parent_anchor = anchor
            self._refreshGeometry()

    def anchor(self):
        """ Get the anchor position for the popup view.

        Returns
        -------
        result : QPointF
            The anchor point for the view.

        """
        return self._state.anchor

    def setAnchor(self, anchor):
        """ Set the anchor position for the popup view.

        Parameters
        ----------
        anchor : QPointF
            The anchor point for the view.

        """
        state = self._state
        if anchor != state.anchor:
            state.anchor = anchor
            self._refreshGeometry()

    def offset(self):
        """ Get the offset of the view from the anchors.

        Returns
        -------
        result : QPoint
            The offset of the view from the anchors.

        """
        return self._state.offset

    def setOffset(self, offset):
        """ Set the offset of the view from the anchors.

        Parameters
        ----------
        offset : QPoint
            The offset of the view from the anchors.

        """
        state = self._state
        if offset != state.offset:
            state.offset = offset
            self._refreshGeometry()

    def anchorMode(self):
        """ Get the anchor mode for the popup view

        Returns
        -------
        result : int
            An enum value describing the anchor mode of the popup.

        """
        return self._state.anchor_mode

    def setAnchorMode(self, mode):
        """ Set the anchor mode for the popup view

        Parameters
        ----------
        mode : int
            The anchor mode (can be AnchorParent or AnchorCursor)

        """
        state = self._state
        if mode != state.anchor_mode:
            state.anchor_mode = mode
            self._refreshGeometry()

    def arrowEdge(self):
        """ Get edge for the popup arrow.

        Returns
        -------
        result : int
            An enum value describing the edge location of the arrow.

        """
        return self._state.arrow_edge

    def setArrowEdge(self, edge):
        """ Set the edge for the popup arrow.

        Parameters
        ----------
        edge : int
            The enum describing the edge location of the arrow.

        """
        state = self._state
        if edge != state.arrow_edge:
            state.arrow_edge = edge
            self._refreshGeometry()

    def arrowSize(self):
        """ Get the size of the popup arrow.

        Returns
        -------
        result : int
            The size of the arrow in pixels.

        """
        return self._arrow_size.height()

    def setArrowSize(self, size):
        """ Set size of the popup arrow.

        Parameters
        ----------
        size : int
            The size of the popup arrow, in pixels. A size of zero
            indicates that no arrow is to be used.

        """
        state = self._state
        if size != state.arrow_size:
            state.arrow_size = size
            self._refreshGeometry()

    def timeout(self):
        """ Get the timeout for the view.

        Returns
        -------
        result : float
            The timeout of the view, in seconds.

        """
        return self._state.timeout

    def setTimeout(self, timeout):
        """ Set the timeout for the view.

        Parameters
        ----------
        timeout : float
            The timeout for the view, in seconds.

        """
        self._state.timeout = timeout

    def fadeInDuration(self):
        """ Get the duration of the fade in for the view.

        Returns
        -------
        result : int
            The duration of the fade in, in milliseconds.

        """
        return self._state.fade_in_duration

    def setFadeInDuration(self, duration):
        """ Set the duration of the fade in for the view.

        Parameters
        ----------
        duration : int
            The duration of the fade in, in milliseconds.

        """
        self._state.fade_in_duration = duration

    def fadeOutDuration(self):
        """ Get the duration of the fade out for the view.

        Returns
        -------
        result : int
            The duration of the fade out, in milliseconds.

        """
        return self._state.fade_out_duration

    def setFadeOutDuration(self, duration):
        """ Set the duration of the fade out for the view.

        Parameters
        ----------
        duration : int
            The duration of the fade out, in milliseconds.

        """
        self._state.fade_out_duration = duration

    def closeOnClick(self):
        """ Get whether or not close on click is enabled.

        Returns
        -------
        result : bool
            True if close on click is enabled, False otherwise. The
            default value is True.

        """
        return self._state.close_on_click

    def setCloseOnClick(self, enable):
        """ Set whether or not close on click is enabled.

        Parameters
        ----------
        enable : bool
            True if close on click should be enabled, False otherwise.

        """
        self._state.close_on_click = enable

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def eventFilter(self, obj, event):
        """ Filter the events from the parent object.

        This handler ensures the position of the popup is updated
        when the parent is resized or moved.

        """
        evt_type = event.type()
        if evt_type == QEvent.Move or evt_type == QEvent.Resize:
            self._refreshGeometry()
        return False

    def mousePressEvent(self, event):
        """ Handle the mouse press event for the popup view.

        This handler ensures that the window is closed in the proper
        cases, when the superclass method doesn't handle it.

        """
        event.ignore()
        state = self._state
        if state.close_on_click:
            path = state.path
            pos = event.pos()
            rect = self.rect()
            win_type = self.windowType()
            if win_type == Qt.Popup:
                if not rect.contains(pos):
                    super(QPopupView, self).mousePressEvent(event)
                else:
                    path = state.path
                    if not path.isEmpty() and not path.contains(pos):
                        event.accept()
                        self.close()
            elif win_type == Qt.ToolTip or win_type == Qt.Window:
                if path.isEmpty() or path.contains(pos):
                    event.accept()
                    self.close()

    def showEvent(self, event):
        """ Handle the show event for the popup view.

        This handler starts the fade in animation and the timer which
        manages the timeout for the popup.

        """
        self._refreshGeometry(force=True)
        state = self._state
        if state.timeout > 0.0:
            state.close_timer.start(int(state.timeout * 1000))
        duration = state.fade_in_duration
        if duration <= 0:
            return
        animator = state.fade_in_animator
        if animator.state() == QPropertyAnimation.Stopped:
            animator.setStartValue(0.0)
            animator.setEndValue(1.0)
            animator.setDuration(duration)
            animator.start()

    def closeEvent(self, event):
        """ Handle the close event for the popup view.

        This handler stops the timeout timer and the fade in animation
        and starts the fade out animation. Once the popup view is fully
        transparent, the close event is accepted.

        """
        event.ignore()
        state = self._state
        state.close_timer.stop()
        state.fade_in_animator.stop()
        duration = state.fade_out_duration
        if duration <= 0:
            event.accept()
            self.closed.emit()
            return
        animator = state.fade_out_animator
        if animator.state() == QPropertyAnimation.Stopped:
            opacity = self.windowOpacity()
            if opacity == 0.0:
                event.accept()
                self.closed.emit()
            else:
                animator.setStartValue(opacity)
                animator.setEndValue(0.0)
                animator.setDuration(duration)
                animator.start()

    def resizeEvent(self, event):
        """ Handle the resize event for the popup view.

        """
        super(QPopupView, self).resizeEvent(event)
        if self._state.in_resize_event:
            return
        self._state.in_resize_event = True
        try:
            self._refreshGeometry()
        finally:
            self._state.in_resize_event = False

    def paintEvent(self, event):
        """ Handle the paint event for the popup view.

        """
        palette = self.palette()
        fill_color = palette.window().color()
        stroke_color = palette.windowText().color()
        painter = QPainter(self)
        painter.setBrush(fill_color)
        painter.setPen(QPen(stroke_color, 2))
        painter.setRenderHint(QPainter.Antialiasing)
        path = self._state.path
        if path.isEmpty():
            painter.drawRect(self.rect())
        else:
            painter.drawPath(path)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _refreshGeometry(self, force=False):
        """ Refresh the geometry for the popup using the current state.

        Parameters
        ----------
        force : bool, optional
            Wether or not to force the computation even if the view is
            not visible. The default is False.

        """
        if not force and not self.isVisible():
            return
        if self._state.arrow_size <= 0:
            self._layoutPlainRect()
        else:
            self._layoutArrowRect()

    def _layoutPlainRect(self):
        """ Layout the widget with no edge arrow.

        """
        self.setContentsMargins(QMargins())
        self.clearMask()
        target_pos = self._targetPos()
        anchor_pos = self._anchorPos()
        offset = self._state.offset
        trial_pos = target_pos + offset - anchor_pos
        trial_geo = QRect(trial_pos, self.size())
        geo = ensure_on_screen(trial_geo)
        self.setGeometry(geo)

    def _layoutArrowRect(self):
        """ Layout the widget with the edge arrow.

        """
        # Setup the initial contents margins.
        state = self._state
        arrow_size = state.arrow_size
        arrow_edge = state.arrow_edge
        margins = edge_margins(arrow_size, arrow_edge)
        self.setContentsMargins(margins)

        # Use the current size to compute the arrow position.
        ax = ay = 0
        size = self.size()
        anchor = state.anchor
        if arrow_edge == ArrowEdge.Left or arrow_edge == ArrowEdge.Right:
            ay = int(anchor.y() * size.height())
            ay = max(arrow_size, min(size.height() - arrow_size, ay))
            if arrow_edge == ArrowEdge.Right:
                ax = size.width()
        else:
            ax = int(anchor.x() * size.width())
            ax = max(arrow_size, min(size.width() - arrow_size, ax))
            if arrow_edge == ArrowEdge.Bottom:
                ay = size.height()

        # Compute the view rect and adjust it if it falls off screen.
        target_pos = self._targetPos()
        pos = target_pos + state.offset - QPoint(ax, ay)
        rect = QRect(pos, size)
        if not is_fully_on_screen(rect):
            rect, new_edge, d_ax, d_ay = adjust_arrow_rect(
                rect, arrow_edge, target_pos, state.offset
            )
            ax = max(arrow_size, min(size.width() - arrow_size, ax + d_ax))
            ay = max(arrow_size, min(size.height() - arrow_size, ay + d_ay))
            if new_edge != arrow_edge:
                arrow_edge = new_edge
                margins = edge_margins(arrow_size, new_edge)
                self.setContentsMargins(margins)

        # Use the final geometry to get the path for the arrow.
        if arrow_edge == ArrowEdge.Left or arrow_edge == ArrowEdge.Right:
            path = make_path(rect.size(), arrow_size, arrow_edge, ay)
        else:
            path = make_path(rect.size(), arrow_size, arrow_edge, ax)

        # Store the path for painting and update the widget mask.
        state.path = path
        mask = QRegion(path.toFillPolygon().toPolygon())
        self.setMask(mask)

        # Set the geometry of the view and update. The update is needed
        # for the case where the only change was the widget mask, which
        # will not generate a paint event. Qt collapses paint events,
        # so the cost of this is minimal.
        self.setGeometry(rect)
        self.update()

    def _targetPos(self):
        """ Get the global position of the parent anchor.

        Returns
        -------
        result : QPoint
            The global coordinates of the target parent anchor.

        """
        state = self._state
        if state.anchor_mode == AnchorMode.Cursor:
            origin = QCursor.pos()
            size = QSize()
        else:
            parent = self.parent()
            if parent is None:
                desktop = QApplication.desktop()
                geo = desktop.availableGeometry()
                origin = geo.topLeft()
                size = geo.size()
            else:
                origin = parent.mapToGlobal(QPoint(0, 0))
                size = parent.size()
        anchor = state.parent_anchor
        px = int(anchor.x() * size.width())
        py = int(anchor.y() * size.height())
        return origin + QPoint(px, py)

    def _anchorPos(self):
        """ Get the position of the anchor in local coordinates.

        Returns
        -------
        result : QPoint
            The anchor position on the view in local coordinates.

        """
        size = self.size()
        anchor = self._state.anchor
        px = int(anchor.x() * size.width())
        py = int(anchor.y() * size.height())
        return QPoint(px, py)

########NEW FILE########
__FILENAME__ = q_resource_helpers
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from enaml.fontext import FontStyle, FontCaps

from .QtCore import Qt, QSize
from .QtGui import QColor, QFont, QImage, QIcon, QPixmap


FONT_STYLES = {
    FontStyle.Normal: QFont.StyleNormal,
    FontStyle.Italic: QFont.StyleItalic,
    FontStyle.Oblique: QFont.StyleOblique,
}


FONT_CAPS = {
    FontCaps.MixedCase: QFont.MixedCase,
    FontCaps.AllUppercase: QFont.AllUppercase,
    FontCaps.AllLowercase: QFont.AllLowercase,
    FontCaps.SmallCaps: QFont.SmallCaps,
    FontCaps.Capitalize: QFont.Capitalize,
}


ASPECT_RATIO_MODE = {
    'ignore': Qt.IgnoreAspectRatio,
    'keep': Qt.KeepAspectRatio,
    'keep_by_expanding': Qt.KeepAspectRatioByExpanding
}


TRANSFORM_MODE = {
    'fast': Qt.FastTransformation,
    'smooth': Qt.SmoothTransformation
}


ICON_MODE = {
    'normal': QIcon.Normal,
    'disabled': QIcon.Disabled,
    'active': QIcon.Active,
    'selected': QIcon.Selected,
}


ICON_STATE = {
    'off': QIcon.Off,
    'on': QIcon.On,
}


def QImage_from_Image(image):
    """ Convert an Enaml Image into a QImage.

    Parameters
    ----------
    image : Image
        The Enaml Image object.

    Returns
    -------
    result : QImage
        The QImage instance for the given Enaml image.

    """
    format = image.format
    if format == 'argb32':
        w, h = image.raw_size
        qimage = QImage(image.data, w, h, QImage.Format_ARGB32)
    else:
        if format == 'auto':
            format = ''
        qimage = QImage.fromData(image.data, format)
    if -1 not in image.size and not qimage.isNull():
        qsize = QSize(*image.size)
        if qsize != qimage.size():
            mode = ASPECT_RATIO_MODE[image.aspect_ratio_mode]
            transform = TRANSFORM_MODE[image.transform_mode]
            qimage = qimage.scaled(qsize, mode, transform)
    return qimage


def get_cached_qimage(image):
    """ Get the cached QImage for the Enaml Image.

    Parameters
    ----------
    image : Image
        The Enaml Image object.

    Returns
    -------
    result : QImage
        The cached QImage for the image. If no cached image exists, one
        will be created.

    """
    qimage = image._tkdata
    if not isinstance(qimage, QImage):
        qimage = image._tkdata = QImage_from_Image(image)
    return qimage


def QIcon_from_Icon(icon):
    """ Convert the given Enaml Icon into a QIcon.

    Parameters
    ----------
    icon : Icon
        The Enaml Icon object.

    Returns
    -------
    result : QIcon
        The QIcon instance for the given Enaml icon.

    """
    qicon = QIcon()
    for icon_image in icon.images:
        image = icon_image.image
        if not image:
            continue
        mode = ICON_MODE[icon_image.mode]
        state = ICON_STATE[icon_image.state]
        qimage = get_cached_qimage(image)
        qpixmap = QPixmap.fromImage(qimage)
        qicon.addPixmap(qpixmap, mode, state)
    return qicon


def get_cached_qicon(icon):
    """ Get the cached QIcon for the Enaml Icon.

    Parameters
    ----------
    icon : Icon
        The Enaml Icon object.

    Returns
    -------
    result : QIcon
        The cached QIcon for the icon. If no cached icon exists, one
        will be created.

    """
    qicon = icon._tkdata
    if not isinstance(qicon, QIcon):
        qicon = icon._tkdata = QIcon_from_Icon(icon)
    return qicon


def QColor_from_Color(color):
    """ Convert the given Enaml Color into a QColor.

    Parameters
    ----------
    color : Color
        The Enaml Color object.

    Returns
    -------
    result : QColor
        The QColor instance for the given Enaml color.

    """
    return QColor.fromRgba(color.argb)


def get_cached_qcolor(color):
    """ Get the cached QColor for the Enaml Color.

    Parameters
    ----------
    color : Color
        The Enaml Color object.

    Returns
    -------
    result : QColor
        The cached QColor for the color. If no cached color exists, one
        will be created.

    """
    qcolor = color._tkdata
    if not isinstance(qcolor, QColor):
        qcolor = color._tkdata = QColor_from_Color(color)
    return qcolor


def QFont_from_Font(font):
    """ Convert the given Enaml Font into a QFont.

    Parameters
    ----------
    font : Font
        The Enaml Font object.

    Returns
    -------
    result : QFont
        The QFont instance for the given Enaml font.

    """
    qfont = QFont(font.family, font.pointsize, font.weight)
    qfont.setStyle(FONT_STYLES[font.style])
    qfont.setCapitalization(FONT_CAPS[font.caps])
    return qfont


def get_cached_qfont(font):
    """ Get the cached QFont for the Enaml Font.

    Parameters
    ----------
    font : Font
        The Enaml Font object.

    Returns
    -------
    result : QFont
        The cached QFont for the font. If no cached font exists, one
        will be created.

    """
    qfont = font._tkdata
    if not isinstance(qfont, QFont):
        qfont = font._tkdata = QFont_from_Font(font)
    return qfont

########NEW FILE########
__FILENAME__ = q_single_widget_layout
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from .QtCore import QSize
from .QtGui import QLayout, QWidgetItem


class QSingleWidgetItem(QWidgetItem):
    """ A QWidgetItem subclass for use with the QSingleWidgetLayout.

    The semantics of this widget item are slightly different from that
    of the standard QWidgetItem; it always aligns its widget with the
    top left of the layout rect. This class is expressly meant for use
    by the QSingleWidgetLayout.

    """
    def setGeometry(self, rect):
        """ Set the rectangle covered by this layout item.

        Parameters
        ----------
        rect : QRect
            The rectangle that this layout item should cover.

        """
        if self.isEmpty():
            return
        s = rect.size().boundedTo(self.maximumSize())
        self.widget().setGeometry(rect.x(), rect.y(), s.width(), s.height())


class QSingleWidgetLayout(QLayout):
    """ A QLayout subclass which can have at most one layout item.

    The layout item is expanded to fit the allowable space; similar to
    how a central widget behaves in a QMainWindow. Unlike QMainWindow,
    this layout respects the maximum size of the widget. The default
    contents margins of this layout is 0px in all directions.

    """
    #: The initial value of the internal widget item.
    _item = None

    def __init__(self, parent=None):
        """ Initialize a QSingleWidgetLayout.

        Parameters
        ----------
        parent : QWidget or None
            The parent widget owner of the layout.

        """
        super(QSingleWidgetLayout, self).__init__(parent)
        self.setContentsMargins(0, 0, 0, 0)

    # Note: do not name this method `widget` since that is a virtual
    # method on QLayoutItem which is a parent class of QLayout.
    def getWidget(self):
        """ Get the widget being managed by this layout.

        Returns
        -------
        result : QWidget or None
            The widget being managed by this layout or None if it does
            not exist.

        """
        item = self._item
        if item is not None:
            return item.widget()

    def setWidget(self, widget):
        """ Set the widget for this layout.

        Parameters
        ----------
        widget : QWidget
            The widget to manage with this layout.

        """
        old = self.getWidget()
        if old is widget:
            return
        if old is not None:
            old.setParent(None)
        if widget is not None:
            self.addChildWidget(widget)
            self._item = QSingleWidgetItem(widget)
            widget.show()
            self.invalidate()

    def addWidget(self, widget):
        """ Overridden parent class method. This method redirects to the
        `setWidget` method. User code should call `setWidget` instead.

        """
        import warnings
        msg = ('`QSingleWidgetLayout.addWidget`: use the '
               '`QSingleWidgetLayout.setWidget` method instead.')
        warnings.warn(msg)
        self.setWidget(widget)

    def addItem(self, item):
        """ A virtual method implementation which sets the layout item
        in the layout. The old item will be overridden.

        This method should not be used. The method `setWidget` should be
        used instead.

        """
        msg = 'Use `setWidget` instead.'
        raise NotImplementedError(msg)

    def count(self):
        """ A virtual method implementation which returns 0 if no layout
        item is supplied, or 1 if there is a current layout item.

        """
        return 0 if self._item is None else 1

    def itemAt(self, idx):
        """ A virtual method implementation which returns the layout item
        for the given index or None if one does not exist.

        """
        if idx == 0:
            return self._item

    def takeAt(self, idx):
        """ A virtual method implementation which removes and returns the
        item at the given index or None if one does not exist.

        """
        if idx == 0:
            item = self._item
            self._item = None
            if item is not None:
                item.widget().hide()
                self.invalidate()
            # The creation path of the layout item bypasses the virtual
            # wrapper methods, this means that the ownership of the cpp
            # pointer is never transfered to Qt. If the item is returned
            # here it will be deleted by Qt, which doesn't own the pointer.
            # A double free occurs once the Python item falls out of scope.
            # To avoid this, this method always returns None and the item
            # cleanup is performed by Python, which owns the cpp pointer.

    def sizeHint(self):
        """ A virtual method implementation which returns the size hint
        for the layout.

        """
        item = self._item
        if item is not None:
            hint = item.sizeHint()
            left, top, right, bottom = self.getContentsMargins()
            hint.setHeight(hint.height() + top + bottom)
            hint.setWidth(hint.width() + left + right)
            return hint
        return QSize()

    def setGeometry(self, rect):
        """ A reimplemented method which sets the geometry of the managed
        widget to fill the given rect.

        """
        super(QSingleWidgetLayout, self).setGeometry(rect)
        item = self._item
        if item is not None:
            item.setGeometry(self.contentsRect())

    def minimumSize(self):
        """ A reimplemented method which returns the minimum size hint
        of the layout item widget as the minimum size of the window.

        """
        item = self._item
        if item is not None:
            s = item.minimumSize()
            left, top, right, bottom = self.getContentsMargins()
            s.setHeight(s.height() + top + bottom)
            s.setWidth(s.width() + left + right)
            return s
        return super(QSingleWidgetLayout, self).minimumSize()

    def maximumSize(self):
        """ A reimplemented method which returns the maximum size hint
        of the layout item widget as the maximum size of the window.

        """
        item = self._item
        if item is not None:
            s = item.maximumSize()
            left, top, right, bottom = self.getContentsMargins()
            s.setHeight(s.height() + top + bottom)
            s.setWidth(s.width() + left + right)
            return s
        return super(QSingleWidgetLayout, self).maximumSize()

########NEW FILE########
__FILENAME__ = q_window_base
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from .QtCore import Qt, QSize
from .QtGui import QWidget, QLayout

from .q_single_widget_layout import QSingleWidgetLayout


class QWindowLayout(QSingleWidgetLayout):
    """ A single widget layout for use with window classes.

    This class extends the single widget layout to add support for
    QWindowBase classes and their use of explicit min and max sizes.

    """
    def minimumSize(self):
        """ The minimum size for the layout area.

        This is a reimplemented method which will return the explicit
        minimum size of the window, if provided.

        """
        parent = self.parentWidget()
        if parent is not None:
            size = parent.explicitMinimumSize()
            if size.isValid():
                return size
        return super(QWindowLayout, self).minimumSize()

    def maximumSize(self):
        """ The maximum size for the layout area.

        This is a reimplemented method which will return the explicit
        maximum size of the window, if provided.

        """
        parent = self.parentWidget()
        if parent is not None:
            size = parent.explicitMaximumSize()
            if size.isValid():
                return size
        return super(QWindowLayout, self).maximumSize()


class QWindowBase(QWidget):
    """ A QWidget which forms the base for derived window classes.

    The window base provides support for a central widget as well as
    explicitly specified min and max sizes which override what would
    normally be computed by the layout.

    """
    def __init__(self, parent=None, flags=Qt.WindowFlags(0)):
        """ Initialize a QWindowBase.

        Parameters
        ----------
        parent : QWidget, optional
            The parent of the window.

        flags : Qt.WindowFlags, optional
            The window flags to pass to the parent constructor.

        """
        super(QWindowBase, self).__init__(parent, flags)
        self._expl_min_size = QSize()
        self._expl_max_size = QSize()
        layout = QWindowLayout()
        layout.setSizeConstraint(QLayout.SetMinAndMaxSize)
        self.setLayout(layout)

    def centralWidget(self):
        """ Get the central widget installed on the window.

        Returns
        -------
        result : QWidget or None
            The central widget of the window, or None if no widget
            was provided.

        """
        return self.layout().getWidget()

    def setCentralWidget(self, widget):
        """ Set the central widget for this window.

        Parameters
        ----------
        widget : QWidget
            The widget to use as the content of the window.

        """
        self.layout().setWidget(widget)

    def explicitMinimumSize(self):
        """ Get the explicit minimum size for this widget.

        Returns
        -------
        result : QSize
            If the user has explitly set the minimum size of the
            widget, that size will be returned. Otherwise, an
            invalid QSize will be returned.

        """
        return self._expl_min_size

    def explicitMaximumSize(self):
        """ Get the explicit maximum size for this widget.

        Returns
        -------
        result : QSize
            If the user has explitly set the maximum size of the
            widget, that size will be returned. Otherwise, an
            invalid QSize will be returned.

        """
        return self._expl_max_size

    def setMinimumSize(self, size):
        """ Set the minimum size for the QWindow.

        This is an overridden parent class method which stores the
        provided size as the explictly set QSize. The explicit
        size can be reset by passing a QSize of (0, 0).

        Parameters
        ----------
        size : QSize
            The minimum size for the QWindow.

        """
        super(QWindowBase, self).setMinimumSize(size)
        if size == QSize(0, 0):
            self._expl_min_size = QSize()
        else:
            self._expl_min_size = size
        self.layout().update()

    def setMaximumSize(self, size):
        """ Set the maximum size for the QWindow.

        This is an overridden parent class method which stores the
        provided size as the explictly set QSize. The explicit
        size can be reset by passing a QSize equal to the maximum
        widget size of QSize(16777215, 16777215).

        Parameters
        ----------
        size : QSize
            The maximum size for the QWindow.

        """
        super(QWindowBase, self).setMaximumSize(size)
        if size == QSize(16777215, 16777215):
            self._expl_max_size = QSize()
        else:
            self._expl_max_size = size
        self.layout().update()

########NEW FILE########
__FILENAME__ = scintilla_lexers
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from . import QT_API
if QT_API != 'pyqt':
    msg = 'the Qt Scintilla widget is only available when using PyQt'
    raise ImportError(msg)

from PyQt4 import Qsci



class PythonLexer(Qsci.QsciLexerPython):
    """ A custom Python lexer which highlights extra identifiers.

    """
    py_kwds = (
        'ArithmeticError AssertionError AttributeError BaseException '
        'BufferError BytesWarning DeprecationWarning EOFErr Ellipsis '
        'EnvironmentError Exception False FloatingPointError FutureWarning '
        'GeneratorExit IOError ImportError ImportWarning IndentationError '
        'IndexError KeyError KeyboardInterrupt LookupError MemoryError '
        'NameError None NotImplemented NotImplementedError OSError '
        'OverflowError PendingDeprecationWarning ReferenceError RuntimeError '
        'RuntimeWarning StandardError StopIteration SyntaxError SyntaxWarning '
        'SystemError SystemExit TabError True TypeError UnboundLocalError '
        'UnicodeDecodeError UnicodeEncodeError UnicodeError '
        'UnicodeTranslateError UnicodeWarning UserWarning ValueError Warning '
        'WindowsError ZeroDivisionError abs all any apply basestring bin bool '
        'buffer bytearray bytes callable chr classmethod cmp coerce compile '
        'complex delattr dict dir divmod enumerate eval execfile file filter'
        'float format frozenset getattr globals hasattr hash help hex id input'
        'int intern isinstance issubclass iter len list locals long map max '
        'memoryview min next object oct open ord pow print property range '
        'raw_input reduce reload repr reversed round set setattr slice sorted'
        'staticmethod str sum super tuple type unichr unicode vars xrange zip'
    )

    def __init__(self, *args):
        super(PythonLexer, self).__init__(*args)
        # This setting is a relatively recent lexer addition.
        setter = getattr(self, 'setHighlightSubidentifiers', None)
        if setter is not None:
            setter(False)

    def keywords(self, kwset):
        if kwset == 2:
            return self.py_kwds
        return super(PythonLexer, self).keywords(kwset)


class EnamlLexer(PythonLexer):
    """ A custom Python lexer which adds Enaml keywords.

    """
    enaml_kwds = " enamldef attr event"

    def keywords(self, kwset):
        kwds = super(EnamlLexer, self).keywords(kwset)
        if kwset == 1:
            kwds += self.enaml_kwds
        return kwds


#: A static mapping of theme language name to lexer class.
LEXERS = {
    'bash': Qsci.QsciLexerBash,
    'batch': Qsci.QsciLexerBatch,
    'cmake': Qsci.QsciLexerCMake,
    'cpp': Qsci.QsciLexerCPP,
    'csharp': Qsci.QsciLexerCSharp,
    'css': Qsci.QsciLexerCSS,
    'd': Qsci.QsciLexerD,
    'diff': Qsci.QsciLexerDiff,
    'enaml': EnamlLexer,
    'fortran': Qsci.QsciLexerFortran,
    'fortran77': Qsci.QsciLexerFortran77,
    'html': Qsci.QsciLexerHTML,
    'idl': Qsci.QsciLexerIDL,
    'java': Qsci.QsciLexerJava,
    'javascript': Qsci.QsciLexerJavaScript,
    'lua': Qsci.QsciLexerLua,
    'makefile': Qsci.QsciLexerMakefile,
    'matlab': Qsci.QsciLexerMatlab,
    'octave': Qsci.QsciLexerOctave,
    'pascal': Qsci.QsciLexerPascal,
    'perl': Qsci.QsciLexerPerl,
    'postscript': Qsci.QsciLexerPostScript,
    'pov': Qsci.QsciLexerPOV,
    'properties': Qsci.QsciLexerProperties,
    'python': PythonLexer,
    'ruby': Qsci.QsciLexerRuby,
    'spice': Qsci.QsciLexerSpice,
    'sql': Qsci.QsciLexerSQL,
    'tcl': Qsci.QsciLexerTCL,
    'tex': Qsci.QsciLexerTeX,
    'verilog': Qsci.QsciLexerVerilog,
    'vhdl': Qsci.QsciLexerVHDL,
    'xml': Qsci.QsciLexerXML,
    'yaml': Qsci.QsciLexerYAML,
}


#: A static mapping of lexer class to theme language name.
LEXERS_INV = {}
for key, value in LEXERS.iteritems():
    LEXERS_INV[value] = key

########NEW FILE########
__FILENAME__ = scintilla_tokens
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
#: A static mapping of language theme token name to lexer attribute name.
TOKENS = {
    "bash": {
        "backticks": "Backticks",
        "comment": "Comment",
        "default": "Default",
        "double_quoted_string": "DoubleQuotedString",
        "error": "Error",
        "here_document_delimiter": "HereDocumentDelimiter",
        "identifier": "Identifier",
        "keyword": "Keyword",
        "number": "Number",
        "operator": "Operator",
        "parameter_expansion": "ParameterExpansion",
        "scalar": "Scalar",
        "single_quoted_here_document": "SingleQuotedHereDocument",
        "single_quoted_string": "SingleQuotedString"
    },
    "batch": {
        "comment": "Comment",
        "default": "Default",
        "external_command": "ExternalCommand",
        "hide_command_char": "HideCommandChar",
        "keyword": "Keyword",
        "label": "Label",
        "operator": "Operator",
        "variable": "Variable"
    },
    "cmake": {
        "block_foreach": "BlockForeach",
        "block_if": "BlockIf",
        "block_macro": "BlockMacro",
        "block_while": "BlockWhile",
        "comment": "Comment",
        "default": "Default",
        "function": "Function",
        "keyword_set3": "KeywordSet3",
        "label": "Label",
        "number": "Number",
        "string": "String",
        "string_left_quote": "StringLeftQuote",
        "string_right_quote": "StringRightQuote",
        "string_variable": "StringVariable",
        "variable": "Variable"
    },
    "cpp": {
        "comment": "Comment",
        "comment_doc": "CommentDoc",
        "comment_doc_keyword": "CommentDocKeyword",
        "comment_doc_keyword_error": "CommentDocKeywordError",
        "comment_line": "CommentLine",
        "comment_line_doc": "CommentLineDoc",
        "default": "Default",
        "double_quoted_string": "DoubleQuotedString",
        "global_class": "GlobalClass",
        "hash_quoted_string": "HashQuotedString",
        "identifier": "Identifier",
        "inactive_comment": "InactiveComment",
        "inactive_comment_doc": "InactiveCommentDoc",
        "inactive_comment_doc_keyword": "InactiveCommentDocKeyword",
        "inactive_comment_doc_keyword_error": "InactiveCommentDocKeywordError",
        "inactive_comment_line": "InactiveCommentLine",
        "inactive_comment_line_doc": "InactiveCommentLineDoc",
        "inactive_default": "InactiveDefault",
        "inactive_double_quoted_string": "InactiveDoubleQuotedString",
        "inactive_global_class": "InactiveGlobalClass",
        "inactive_hash_quoted_string": "InactiveHashQuotedString",
        "inactive_identifier": "InactiveIdentifier",
        "inactive_keyword": "InactiveKeyword",
        "inactive_keyword_set2": "InactiveKeywordSet2",
        "inactive_number": "InactiveNumber",
        "inactive_operator": "InactiveOperator",
        "inactive_pre_processor": "InactivePreProcessor",
        "inactive_pre_processor_comment": "InactivePreProcessorComment",
        "inactive_raw_string": "InactiveRawString",
        "inactive_regex": "InactiveRegex",
        "inactive_single_quoted_string": "InactiveSingleQuotedString",
        "inactive_triple_quoted_verbatim_string": "InactiveTripleQuotedVerbatimString",
        "inactive_unclosed_string": "InactiveUnclosedString",
        "inactive_uuid": "InactiveUUID",
        "inactive_verbatim_string": "InactiveVerbatimString",
        "keyword": "Keyword",
        "keyword_set2": "KeywordSet2",
        "number": "Number",
        "operator": "Operator",
        "pre_processor": "PreProcessor",
        "pre_processor_comment": "PreProcessorComment",
        "raw_string": "RawString",
        "regex": "Regex",
        "single_quoted_string": "SingleQuotedString",
        "triple_quoted_verbatim_string": "TripleQuotedVerbatimString",
        "unclosed_string": "UnclosedString",
        "uuid": "UUID",
        "verbatim_string": "VerbatimString"
    },
    "csharp": {
        # this uses the "cpp" token set
    },
    "css": {
        "at_rule": "AtRule",
        "attribute": "Attribute",
        "class_selector": "ClassSelector",
        "comment": "Comment",
        "css1_property": "CSS1Property",
        "css2_property": "CSS2Property",
        "css3_property": "CSS3Property",
        "default": "Default",
        "double_quoted_string": "DoubleQuotedString",
        "extended_css_property": "ExtendedCSSProperty",
        "extended_pseudo_class": "ExtendedPseudoClass",
        "extended_pseudo_element": "ExtendedPseudoElement",
        "id_selector": "IDSelector",
        "important": "Important",
        "media_rule": "MediaRule",
        "operator": "Operator",
        "pseudo_class": "PseudoClass",
        "pseudo_element": "PseudoElement",
        "single_quoted_string": "SingleQuotedString",
        "tag": "Tag",
        "unknown_property": "UnknownProperty",
        "unknown_pseudo_class": "UnknownPseudoClass",
        "value": "Value",
        "variable": "Variable"
    },
    "d": {
        "backquote_string": "BackquoteString",
        "character": "Character",
        "comment": "Comment",
        "comment_doc": "CommentDoc",
        "comment_doc_keyword": "CommentDocKeyword",
        "comment_doc_keyword_error": "CommentDocKeywordError",
        "comment_line": "CommentLine",
        "comment_line_doc": "CommentLineDoc",
        "comment_nested": "CommentNested",
        "default": "Default",
        "identifier": "Identifier",
        "keyword": "Keyword",
        "keyword_doc": "KeywordDoc",
        "keyword_secondary": "KeywordSecondary",
        "keyword_set5": "KeywordSet5",
        "keyword_set6": "KeywordSet6",
        "keyword_set7": "KeywordSet7",
        "number": "Number",
        "operator": "Operator",
        "raw_string": "RawString",
        "string": "String",
        "typedefs": "Typedefs",
        "unclosed_string": "UnclosedString"
    },
    "diff": {
        "command": "Command",
        "comment": "Comment",
        "default": "Default",
        "header": "Header",
        "line_added": "LineAdded",
        "line_changed": "LineChanged",
        "line_removed": "LineRemoved",
        "position": "Position"
    },
    "enaml": {
        # this uses the "python" token set
    },
    "fortran": {
        # this uses the "fortran77" token set
    },
    "fortran77": {
        "comment": "Comment",
        "continuation": "Continuation",
        "default": "Default",
        "dotted_operator": "DottedOperator",
        "double_quoted_string": "DoubleQuotedString",
        "extended_function": "ExtendedFunction",
        "identifier": "Identifier",
        "intrinsic_function": "IntrinsicFunction",
        "keyword": "Keyword",
        "label": "Label",
        "number": "Number",
        "operator": "Operator",
        "pre_processor": "PreProcessor",
        "single_quoted_string": "SingleQuotedString",
        "unclosed_string": "UnclosedString"
    },
    "html": {
        "asp_at_start": "ASPAtStart",
        "asp_java_script_comment": "ASPJavaScriptComment",
        "asp_java_script_comment_doc": "ASPJavaScriptCommentDoc",
        "asp_java_script_comment_line": "ASPJavaScriptCommentLine",
        "asp_java_script_default": "ASPJavaScriptDefault",
        "asp_java_script_double_quoted_string": "ASPJavaScriptDoubleQuotedString",
        "asp_java_script_keyword": "ASPJavaScriptKeyword",
        "asp_java_script_number": "ASPJavaScriptNumber",
        "asp_java_script_regex": "ASPJavaScriptRegex",
        "asp_java_script_single_quoted_string": "ASPJavaScriptSingleQuotedString",
        "asp_java_script_start": "ASPJavaScriptStart",
        "asp_java_script_symbol": "ASPJavaScriptSymbol",
        "asp_java_script_unclosed_string": "ASPJavaScriptUnclosedString",
        "asp_java_script_word": "ASPJavaScriptWord",
        "asp_python_class_name": "ASPPythonClassName",
        "asp_python_comment": "ASPPythonComment",
        "asp_python_default": "ASPPythonDefault",
        "asp_python_double_quoted_string": "ASPPythonDoubleQuotedString",
        "asp_python_function_method_name": "ASPPythonFunctionMethodName",
        "asp_python_identifier": "ASPPythonIdentifier",
        "asp_python_keyword": "ASPPythonKeyword",
        "asp_python_number": "ASPPythonNumber",
        "asp_python_operator": "ASPPythonOperator",
        "asp_python_single_quoted_string": "ASPPythonSingleQuotedString",
        "asp_python_start": "ASPPythonStart",
        "asp_python_triple_double_quoted_string": "ASPPythonTripleDoubleQuotedString",
        "asp_python_triple_single_quoted_string": "ASPPythonTripleSingleQuotedString",
        "asp_start": "ASPStart",
        "aspvb_script_comment": "ASPVBScriptComment",
        "aspvb_script_default": "ASPVBScriptDefault",
        "aspvb_script_identifier": "ASPVBScriptIdentifier",
        "aspvb_script_keyword": "ASPVBScriptKeyword",
        "aspvb_script_number": "ASPVBScriptNumber",
        "aspvb_script_start": "ASPVBScriptStart",
        "aspvb_script_string": "ASPVBScriptString",
        "aspvb_script_unclosed_string": "ASPVBScriptUnclosedString",
        "aspxc_comment": "ASPXCComment",
        "attribute": "Attribute",
        "cdata": "CDATA",
        "default": "Default",
        "entity": "Entity",
        "html_comment": "HTMLComment",
        "html_double_quoted_string": "HTMLDoubleQuotedString",
        "html_number": "HTMLNumber",
        "html_single_quoted_string": "HTMLSingleQuotedString",
        "html_value": "HTMLValue",
        "java_script_comment": "JavaScriptComment",
        "java_script_comment_doc": "JavaScriptCommentDoc",
        "java_script_comment_line": "JavaScriptCommentLine",
        "java_script_default": "JavaScriptDefault",
        "java_script_double_quoted_string": "JavaScriptDoubleQuotedString",
        "java_script_keyword": "JavaScriptKeyword",
        "java_script_number": "JavaScriptNumber",
        "java_script_regex": "JavaScriptRegex",
        "java_script_single_quoted_string": "JavaScriptSingleQuotedString",
        "java_script_start": "JavaScriptStart",
        "java_script_symbol": "JavaScriptSymbol",
        "java_script_unclosed_string": "JavaScriptUnclosedString",
        "java_script_word": "JavaScriptWord",
        "other_in_tag": "OtherInTag",
        "php_comment": "PHPComment",
        "php_comment_line": "PHPCommentLine",
        "php_default": "PHPDefault",
        "php_double_quoted_string": "PHPDoubleQuotedString",
        "php_double_quoted_variable": "PHPDoubleQuotedVariable",
        "php_keyword": "PHPKeyword",
        "php_number": "PHPNumber",
        "php_operator": "PHPOperator",
        "php_single_quoted_string": "PHPSingleQuotedString",
        "php_start": "PHPStart",
        "php_variable": "PHPVariable",
        "python_class_name": "PythonClassName",
        "python_comment": "PythonComment",
        "python_default": "PythonDefault",
        "python_double_quoted_string": "PythonDoubleQuotedString",
        "python_function_method_name": "PythonFunctionMethodName",
        "python_identifier": "PythonIdentifier",
        "python_keyword": "PythonKeyword",
        "python_number": "PythonNumber",
        "python_operator": "PythonOperator",
        "python_single_quoted_string": "PythonSingleQuotedString",
        "python_start": "PythonStart",
        "python_triple_double_quoted_string": "PythonTripleDoubleQuotedString",
        "python_triple_single_quoted_string": "PythonTripleSingleQuotedString",
        "script": "Script",
        "sgml_block_default": "SGMLBlockDefault",
        "sgml_command": "SGMLCommand",
        "sgml_comment": "SGMLComment",
        "sgml_default": "SGMLDefault",
        "sgml_double_quoted_string": "SGMLDoubleQuotedString",
        "sgml_entity": "SGMLEntity",
        "sgml_error": "SGMLError",
        "sgml_parameter": "SGMLParameter",
        "sgml_parameter_comment": "SGMLParameterComment",
        "sgml_single_quoted_string": "SGMLSingleQuotedString",
        "sgml_special": "SGMLSpecial",
        "tag": "Tag",
        "unknown_attribute": "UnknownAttribute",
        "unknown_tag": "UnknownTag",
        "vb_script_comment": "VBScriptComment",
        "vb_script_default": "VBScriptDefault",
        "vb_script_identifier": "VBScriptIdentifier",
        "vb_script_keyword": "VBScriptKeyword",
        "vb_script_number": "VBScriptNumber",
        "vb_script_start": "VBScriptStart",
        "vb_script_string": "VBScriptString",
        "vb_script_unclosed_string": "VBScriptUnclosedString",
        "xml_end": "XMLEnd",
        "xml_start": "XMLStart",
        "xml_tag_end": "XMLTagEnd"
    },
    "idl": {
        # this uses the "cpp" token set
    },
    "java": {
        # this uses the "cpp" token set
    },
    "javascript": {
        # this uses the "cpp" token set
    },
    "lua": {
        "basic_functions": "BasicFunctions",
        "character": "Character",
        "comment": "Comment",
        "coroutines_io_system_facilities": "CoroutinesIOSystemFacilities",
        "default": "Default",
        "identifier": "Identifier",
        "keyword": "Keyword",
        "keyword_set5": "KeywordSet5",
        "keyword_set6": "KeywordSet6",
        "keyword_set7": "KeywordSet7",
        "keyword_set8": "KeywordSet8",
        "label": "Label",
        "line_comment": "LineComment",
        "literal_string": "LiteralString",
        "number": "Number",
        "operator": "Operator",
        "preprocessor": "Preprocessor",
        "string": "String",
        "string_table_maths_functions": "StringTableMathsFunctions",
        "unclosed_string": "UnclosedString"
    },
    "makefile": {
        "comment": "Comment",
        "default": "Default",
        "error": "Error",
        "operator": "Operator",
        "preprocessor": "Preprocessor",
        "target": "Target",
        "variable": "Variable"
    },
    "matlab": {
        "command": "Command",
        "comment": "Comment",
        "default": "Default",
        "double_quoted_string": "DoubleQuotedString",
        "identifier": "Identifier",
        "keyword": "Keyword",
        "number": "Number",
        "operator": "Operator",
        "single_quoted_string": "SingleQuotedString"
    },
    "octave": {
        # this uses the "matlab" token set
    },
    "pascal": {
        "asm": "Asm",
        "character": "Character",
        "comment": "Comment",
        "comment_line": "CommentLine",
        "comment_parenthesis": "CommentParenthesis",
        "default": "Default",
        "hex_number": "HexNumber",
        "identifier": "Identifier",
        "keyword": "Keyword",
        "number": "Number",
        "operator": "Operator",
        "pre_processor": "PreProcessor",
        "pre_processor_parenthesis": "PreProcessorParenthesis",
        "single_quoted_string": "SingleQuotedString",
        "unclosed_string": "UnclosedString"
    },
    "perl": {
        "array": "Array",
        "backtick_here_document": "BacktickHereDocument",
        "backtick_here_document_var": "BacktickHereDocumentVar",
        "backticks": "Backticks",
        "backticks_var": "BackticksVar",
        "comment": "Comment",
        "data_section": "DataSection",
        "default": "Default",
        "double_quoted_here_document": "DoubleQuotedHereDocument",
        "double_quoted_here_document_var": "DoubleQuotedHereDocumentVar",
        "double_quoted_string": "DoubleQuotedString",
        "double_quoted_string_var": "DoubleQuotedStringVar",
        "error": "Error",
        "format_body": "FormatBody",
        "format_identifier": "FormatIdentifier",
        "hash": "Hash",
        "here_document_delimiter": "HereDocumentDelimiter",
        "identifier": "Identifier",
        "keyword": "Keyword",
        "number": "Number",
        "operator": "Operator",
        "pod": "POD",
        "pod_verbatim": "PODVerbatim",
        "quoted_string_q": "QuotedStringQ",
        "quoted_string_qq": "QuotedStringQQ",
        "quoted_string_qq_var": "QuotedStringQQVar",
        "quoted_string_qr": "QuotedStringQR",
        "quoted_string_qr_var": "QuotedStringQRVar",
        "quoted_string_qw": "QuotedStringQW",
        "quoted_string_qx": "QuotedStringQX",
        "quoted_string_qx_var": "QuotedStringQXVar",
        "regex": "Regex",
        "regex_var": "RegexVar",
        "scalar": "Scalar",
        "single_quoted_here_document": "SingleQuotedHereDocument",
        "single_quoted_string": "SingleQuotedString",
        "subroutine_prototype": "SubroutinePrototype",
        "substitution": "Substitution",
        "substitution_var": "SubstitutionVar",
        "symbol_table": "SymbolTable",
        "translation": "Translation"
    },
    "postscript": {
        "array_parenthesis": "ArrayParenthesis",
        "bad_string_character": "BadStringCharacter",
        "base85_string": "Base85String",
        "comment": "Comment",
        "default": "Default",
        "dictionary_parenthesis": "DictionaryParenthesis",
        "dsc_comment": "DSCComment",
        "dsc_comment_value": "DSCCommentValue",
        "hex_string": "HexString",
        "immediate_eval_literal": "ImmediateEvalLiteral",
        "keyword": "Keyword",
        "literal": "Literal",
        "name": "Name",
        "number": "Number",
        "procedure_parenthesis": "ProcedureParenthesis",
        "text": "Text"
    },
    "pov": {
        "bad_directive": "BadDirective",
        "comment": "Comment",
        "comment_line": "CommentLine",
        "default": "Default",
        "directive": "Directive",
        "identifier": "Identifier",
        "keyword_set6": "KeywordSet6",
        "keyword_set7": "KeywordSet7",
        "keyword_set8": "KeywordSet8",
        "number": "Number",
        "objects_csg_appearance": "ObjectsCSGAppearance",
        "operator": "Operator",
        "predefined_functions": "PredefinedFunctions",
        "predefined_identifiers": "PredefinedIdentifiers",
        "string": "String",
        "types_modifiers_items": "TypesModifiersItems",
        "unclosed_string": "UnclosedString"
    },
    "properties": {
        "assignment": "Assignment",
        "comment": "Comment",
        "default": "Default",
        "default_value": "DefaultValue",
        "key": "Key",
        "section": "Section"
    },
    "python": {
        "class_name": "ClassName",
        "comment": "Comment",
        "comment_block": "CommentBlock",
        "decorator": "Decorator",
        "default": "Default",
        "double_quoted_string": "DoubleQuotedString",
        "function_method_name": "FunctionMethodName",
        "highlighted_identifier": "HighlightedIdentifier",
        "identifier": "Identifier",
        "keyword": "Keyword",
        "number": "Number",
        "operator": "Operator",
        "single_quoted_string": "SingleQuotedString",
        "triple_double_quoted_string": "TripleDoubleQuotedString",
        "triple_single_quoted_string": "TripleSingleQuotedString",
        "unclosed_string": "UnclosedString"
    },
    "ruby": {
        "backticks": "Backticks",
        "class_name": "ClassName",
        "class_variable": "ClassVariable",
        "comment": "Comment",
        "data_section": "DataSection",
        "default": "Default",
        "demoted_keyword": "DemotedKeyword",
        "double_quoted_string": "DoubleQuotedString",
        "error": "Error",
        "function_method_name": "FunctionMethodName",
        "global": "Global",
        "here_document": "HereDocument",
        "here_document_delimiter": "HereDocumentDelimiter",
        "identifier": "Identifier",
        "instance_variable": "InstanceVariable",
        "keyword": "Keyword",
        "module_name": "ModuleName",
        "number": "Number",
        "operator": "Operator",
        "percent_string_q": "PercentStringQ",
        "percent_stringq": "PercentStringq",
        "percent_stringr": "PercentStringr",
        "percent_stringw": "PercentStringw",
        "percent_stringx": "PercentStringx",
        "pod": "POD",
        "regex": "Regex",
        "single_quoted_string": "SingleQuotedString",
        "stderr": "Stderr",
        "stdin": "Stdin",
        "stdout": "Stdout",
        "symbol": "Symbol"
    },
    "spice": {
        "command": "Command",
        "comment": "Comment",
        "default": "Default",
        "delimiter": "Delimiter",
        "function": "Function",
        "identifier": "Identifier",
        "number": "Number",
        "parameter": "Parameter",
        "value": "Value"
    },
    "sql": {
        "comment": "Comment",
        "comment_doc": "CommentDoc",
        "comment_doc_keyword": "CommentDocKeyword",
        "comment_doc_keyword_error": "CommentDocKeywordError",
        "comment_line": "CommentLine",
        "comment_line_hash": "CommentLineHash",
        "default": "Default",
        "double_quoted_string": "DoubleQuotedString",
        "identifier": "Identifier",
        "keyword": "Keyword",
        "keyword_set5": "KeywordSet5",
        "keyword_set6": "KeywordSet6",
        "keyword_set7": "KeywordSet7",
        "keyword_set8": "KeywordSet8",
        "number": "Number",
        "operator": "Operator",
        "plus_comment": "PlusComment",
        "plus_keyword": "PlusKeyword",
        "plus_prompt": "PlusPrompt",
        "quoted_identifier": "QuotedIdentifier",
        "single_quoted_string": "SingleQuotedString"
    },
    "tcl": {
        "comment": "Comment",
        "comment_block": "CommentBlock",
        "comment_box": "CommentBox",
        "comment_line": "CommentLine",
        "default": "Default",
        "expand_keyword": "ExpandKeyword",
        "identifier": "Identifier",
        "itcl_keyword": "ITCLKeyword",
        "keyword_set6": "KeywordSet6",
        "keyword_set7": "KeywordSet7",
        "keyword_set8": "KeywordSet8",
        "keyword_set9": "KeywordSet9",
        "modifier": "Modifier",
        "number": "Number",
        "operator": "Operator",
        "quoted_keyword": "QuotedKeyword",
        "quoted_string": "QuotedString",
        "substitution": "Substitution",
        "substitution_brace": "SubstitutionBrace",
        "tcl_keyword": "TCLKeyword",
        "tk_command": "TkCommand",
        "tk_keyword": "TkKeyword"
    },
    "tex": {
        "command": "Command",
        "default": "Default",
        "group": "Group",
        "special": "Special",
        "symbol": "Symbol",
        "text": "Text"
    },
    "verilog": {
        "comment": "Comment",
        "comment_bang": "CommentBang",
        "comment_line": "CommentLine",
        "default": "Default",
        "identifier": "Identifier",
        "keyword": "Keyword",
        "keyword_set2": "KeywordSet2",
        "number": "Number",
        "operator": "Operator",
        "preprocessor": "Preprocessor",
        "string": "String",
        "system_task": "SystemTask",
        "unclosed_string": "UnclosedString",
        "user_keyword_set": "UserKeywordSet"
    },
    "vhdl": {
        "attribute": "Attribute",
        "comment": "Comment",
        "comment_line": "CommentLine",
        "default": "Default",
        "identifier": "Identifier",
        "keyword": "Keyword",
        "keyword_set7": "KeywordSet7",
        "number": "Number",
        "operator": "Operator",
        "standard_function": "StandardFunction",
        "standard_operator": "StandardOperator",
        "standard_package": "StandardPackage",
        "standard_type": "StandardType",
        "string": "String",
        "unclosed_string": "UnclosedString"
    },
    "xml": {
        # this uses the "html" token set
    },
    "yaml": {
        "comment": "Comment",
        "default": "Default",
        "document_delimiter": "DocumentDelimiter",
        "identifier": "Identifier",
        "keyword": "Keyword",
        "number": "Number",
        "operator": "Operator",
        "reference": "Reference",
        "syntax_error_marker": "SyntaxErrorMarker",
        "text_block_marker": "TextBlockMarker"
    }
}


TOKENS["csharp"] = TOKENS["cpp"]
TOKENS["enaml"] = TOKENS["python"]
TOKENS["fortran"] = TOKENS["fortran77"]
TOKENS["idl"] = TOKENS["cpp"]
TOKENS["java"] = TOKENS["cpp"]
TOKENS["javascript"] = TOKENS["cpp"]
TOKENS["octave"] = TOKENS["matlab"]
TOKENS["xml"] = TOKENS["html"]

########NEW FILE########
__FILENAME__ = styleutil
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import re

from enaml.styling import StyleCache


_grad_re = re.compile(ur'(lineargradient|radialgradient)')

_alert_re = re.compile(ur'alert\((-?[_a-zA-Z][_a-zA-Z0-9-]*)\)')


def _translate_gradient(v):
    return _grad_re.sub(ur'q\1', v)


_KNOWN_FIELDS = set([
    u'alternate-background-color',
    u'background',
    u'background-clip',
    u'background-color',
    u'border',
    u'border-top',
    u'border-right',
    u'border-bottom',
    u'border-left',
    u'border-color',
    u'border-top-color',
    u'border-right-color',
    u'border-bottom-color',
    u'border-left-color',
    u'border-radius',
    u'border-top-left-radius',
    u'border-top-right-radius',
    u'border-bottom-right-radius',
    u'border-bottom-left-radius',
    u'border-style',
    u'border-top-style',
    u'border-right-style',
    u'border-bottom-style',
    u'border-left-style',
    u'border-width',
    u'border-top-width',
    u'border-right-width',
    u'border-bottom-width',
    u'border-left-width',
    u'bottom',
    u'color',
    u'font',
    u'font-family',
    u'font-size',
    u'font-style',
    u'font-weight',
    u'height',
    u'icon-size',
    u'left',
    u'line-edit-password-character',
    u'margin',
    u'margin-top',
    u'margin-right',
    u'margin-bottom',
    u'margin-left',
    u'max-height',
    u'max-width',
    u'min-height',
    u'min-width',
    u'padding',
    u'padding-top',
    u'padding-right',
    u'padding-bottom',
    u'padding-left',
    u'position',
    u'right',
    u'selection-background-color',
    u'selection-color',
    u'spacing',
    u'subcontrol-origin',
    u'subcontrol-position',
    u'text-align',
    u'text-decoration',
    u'top',
    u'width',
])


_MAY_HAVE_GRADIENT = set([
    u'background',
    u'background-color',
    u'border',
    u'border-top',
    u'border-right',
    u'border-bottom',
    u'border-left',
    u'border-color',
    u'border-top-color',
    u'border-right-color',
    u'border-bottom-color',
    u'border-left-color',
    u'color',
    u'selection-background-color',
    u'selection-color',
])


def _translate_setter(setter):
    field = setter.field
    if field in _KNOWN_FIELDS:
        value = setter.value
        if value:
            if field in _MAY_HAVE_GRADIENT:
                value = _translate_gradient(value)
            value = u'    %s: %s;' % (field, value)
            return value


def _translate_style_body(style):
    translated = []
    for setter in style.setters():
        tks = StyleCache.toolkit_setter(setter, _translate_setter)
        if tks is not None:
            translated.append(tks)
    return u'\n'.join(translated)


def translate_style(name, style):
    parts = [u'#%s' % name]
    if style.pseudo_element:
        root = parts.pop()
        for pe in style.pseudo_element.split(u','):
            parts.append(root + u'::%s' % pe.strip())
    if style.pseudo_class:
        these = parts[:]
        parts = []
        for pc in style.pseudo_class.split(u','):
            pc = pc.strip()
            for this in these:
                parts.append(this + u':%s' % pc)
    selector = u','.join(parts)
    body = u'{\n%s\n}' % _translate_style_body(style)
    return u'%s %s' % (selector, body)


#------------------------------------------------------------------------------
# Dock Area Styling
#------------------------------------------------------------------------------
def _basic_pc(root, pc):
    if pc:
        root += u':%s' % pc
    return root


def _base_dock_area(name, pc):
    rest = []
    floating = False
    for part in pc.split(u':'):
        if part == 'floating':
            floating = True
        else:
            rest.append(part)
    if floating:
        root = u'QDockWindow > QDockArea'
    else:
        root = u'QDockArea'
    return _basic_pc(root, u':'.join(rest))


def _dock_bar(name, pc):
    return _basic_pc(u'QDockBar', pc)


def _dock_bar_button(name, pc):
    return _maybe_alert(u'QDockBarButton', name, pc)


_position_map = {'top': '0', 'right': '1', 'bottom': '2', 'left': '3'}
def _dock_bar_handle(name, pc):
    rest = []
    position = None
    for part in pc.split(u':'):
        if part in _position_map:
            position = _position_map[part]
        else:
            rest.append(part)
    if position is not None:
        root = u'QDockBarItem[position="%s"] QDockBarItemHandle' % position
    else:
        root = u'QDockBarItem QDockBarItemHandle'
    return _basic_pc(root, u':'.join(rest))


def _dock_container(name, pc):
    rest = []
    floating = False
    for part in pc.split(u':'):
        if part == 'floating':
            floating = True
        else:
            rest.append(part)
    if floating:
        root = u'QDockContainer[floating="true"]'
    else:
        root = u'QDockContainer'
    return _maybe_alert(root, name, u':'.join(rest))


def _dock_window(name, pc):
    return _basic_pc(u'QDockWindow', pc)


def _dock_window_button(name, pc):
    return _basic_pc(u'QDockWindowButtons QBitmapButton', pc)


def _dock_window_close_button(name, pc):
    return _basic_pc(u'QBitmapButton#dockwindow-close-button', pc)


def _dock_window_link_button(name, pc):
    return _basic_pc(u'QBitmapButton#dockwindow-link-button', pc)


def _dock_window_maximize_button(name, pc):
    return _basic_pc(u'QBitmapButton#dockwindow-maximize-button', pc)


def _dock_window_restore_button(name, pc):
    return _basic_pc(u'QBitmapButton#dockwindow-restore-button', pc)


def _rubber_band(name, pc):
    return _basic_pc(u'QDockRubberBand', pc)


def _splitter_handle(name, pc):
    return _basic_pc(u'QDockSplitter::handle', pc)


def _tab_bar(name, pc):
    return _basic_pc(u'QDockTabBar', pc)


def _tab_bar_tab(name, pc):
    rest = []
    alert = u''
    for part in pc.split(u':'):
        match = _alert_re.match(part)
        if match is not None:
            alert = match.group(1)
        else:
            rest.append(part)
    if alert:
        root = u'QDockTabBar[alert="%s"]::tab' % alert
    else:
        root = u'QDockTabBar::tab'
    return _basic_pc(root, u':'.join(rest))


def _tab_bar_close_button(name, pc):
    return _basic_pc(u'QBitmapButton#docktab-close-button', pc)


def _maybe_alert(root, name, pc):
    rest = []
    alert = u''
    for part in pc.split(u':'):
        match = _alert_re.match(part)
        if match is not None:
            alert = match.group(1)
        else:
            rest.append(part)
    if alert:
        root = u'%s[alert="%s"]' % (root, alert)
    return _basic_pc(root, u':'.join(rest))


def _base_dock_item(name, pc):
    return _maybe_alert(u'QDockItem', name, pc)


def _title_bar(name, pc):
    return _maybe_alert(u'QDockTitleBar', name, pc)


def _title_bar_label(name, pc):
    return _maybe_alert(u'QDockTitleBar > QTextLabel', name, pc)


def _title_bar_button(name, pc):
    return _basic_pc(u'QDockTitleBar > QBitmapButton', pc)


def _title_bar_close_button(name, pc):
    return _basic_pc(u'QBitmapButton#docktitlebar-close-button', pc)


def _title_bar_link_button(name, pc):
    return _basic_pc(u'QBitmapButton#docktitlebar-link-button', pc)


def _title_bar_maximize_button(name, pc):
    return _basic_pc(u'QBitmapButton#docktitlebar-maximize-button', pc)


def _title_bar_pin_button(name, pc):
    return _basic_pc(u'QBitmapButton#docktitlebar-pin-button', pc)


def _title_bar_restore_button(name, pc):
    return _basic_pc(u'QBitmapButton#docktitlebar-restore-button', pc)


_DOCK_AREA_PSEUDO_ELEMENTS = {
    u'': _base_dock_area,
    u'dock-bar': _dock_bar,
    u'dock-bar-button': _dock_bar_button,
    u'dock-bar-handle': _dock_bar_handle,
    u'dock-container': _dock_container,
    u'dock-window': _dock_window,
    u'dock-window-button': _dock_window_button,
    u'dock-window-close-button': _dock_window_close_button,
    u'dock-window-link-button': _dock_window_link_button,
    u'dock-window-maximize-button': _dock_window_maximize_button,
    u'dock-window-restore-button': _dock_window_restore_button,
    u'rubber-band': _rubber_band,
    u'splitter-handle': _splitter_handle,
    u'tab-bar': _tab_bar,
    u'tab-bar-tab': _tab_bar_tab,
    u'tab-bar-close-button': _tab_bar_close_button,
}


_DOCK_ITEM_PSEUDO_ELEMENTS = {
    u'': _base_dock_item,
    u'title-bar': _title_bar,
    u'title-bar-label': _title_bar_label,
    u'title-bar-button': _title_bar_button,
    u'title-bar-close-button': _title_bar_close_button,
    u'title-bar-link-button': _title_bar_link_button,
    u'title-bar-maximize-button': _title_bar_maximize_button,
    u'title-bar-pin-button': _title_bar_pin_button,
    u'title-bar-restore-button': _title_bar_restore_button,
}


def _dock_style_selector(name, style, elements):
    handlers = []
    for pe in style.pseudo_element.split(u','):
        handler = elements.get(pe.strip())
        if handler:
            handlers.append(handler)
    if not handlers:
        return
    parts = []
    for pc in style.pseudo_class.split(u','):
        pc = pc.strip()
        for handler in handlers:
            parts.append(handler(name, pc))
    return u', '.join(parts)


def translate_dock_area_style(name, style):
    selector = _dock_style_selector(name, style, _DOCK_AREA_PSEUDO_ELEMENTS)
    if not selector:
        return
    body = u'{\n%s\n}' % _translate_style_body(style)
    return u'%s %s' % (selector, body)


def translate_dock_item_style(name, style):
    selector = _dock_style_selector(name, style, _DOCK_ITEM_PSEUDO_ELEMENTS)
    if not selector:
        return
    body = u'{\n%s\n}' % _translate_style_body(style)
    return u'%s %s' % (selector, body)

########NEW FILE########
__FILENAME__ = runner
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
""" Command-line tool to run .enaml files.

"""
import optparse
import os
import sys
import types

from enaml import imports
from enaml.core.parser import parse
from enaml.core.enaml_compiler import EnamlCompiler


def main():
    usage = 'usage: %prog [options] enaml_file [script arguments]'
    parser = optparse.OptionParser(usage=usage, description=__doc__)
    parser.allow_interspersed_args = False
    parser.add_option(
        '-c', '--component', default='Main', help='The component to view'
    )

    options, args = parser.parse_args()

    if len(args) == 0:
        print 'No .enaml file specified'
        sys.exit()
    else:
        enaml_file = args[0]
        script_argv = args[1:]

    with open(enaml_file, 'rU') as f:
        enaml_code = f.read()

    # Parse and compile the Enaml source into a code object
    ast = parse(enaml_code, filename=enaml_file)
    code = EnamlCompiler.compile(ast, enaml_file)

    # Create a proper module in which to execute the compiled code so
    # that exceptions get reported with better meaning
    module = types.ModuleType('__main__')
    module.__file__ = os.path.abspath(enaml_file)
    sys.modules['__main__'] = module
    ns = module.__dict__

    # Put the directory of the Enaml file first in the path so relative
    # imports can work.
    sys.path.insert(0, os.path.abspath(os.path.dirname(enaml_file)))
    # Bung in the command line arguments.
    sys.argv = [enaml_file] + script_argv
    with imports():
        exec code in ns

    requested = options.component
    if requested in ns:
        from enaml.qt.qt_application import QtApplication
        app = QtApplication()
        window = ns[requested]()
        window.show()
        window.send_to_front()
        app.start()
    elif 'main' in ns:
        ns['main']()
    else:
        msg = "Could not find component '%s'" % options.component
        print msg


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = api
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from .scintilla import Scintilla, ScintillaDocument

########NEW FILE########
__FILENAME__ = idle_theme
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from .mono_font import MONO_FONT


# TODO add many more syntaxes to this theme.
#: A Scintilla highlight theme based on the Python IDLE environment.
IDLE_THEME = {
    "settings": {
        "caret": "#000000",
        "color": "#000000",
        "paper": "#FFFFFF",
        "font": MONO_FONT
    },
    "python": {
        "class_name": {
            "color": "#21439C"
        },
        "comment": {
            "color": "#919191"
        },
        "comment_block": {
            "color": "#919191"
        },
        "decorator": {
            "color": "#DAD085"
        },
        "double_quoted_string": {
            "color": "#00A33F"
        },
        "function_method_name": {
            "color": "#21439C"
        },
        "highlighted_identifier": {
            "color": "#A535AE"
        },
        "keyword": {
            "color": "#FF5600"
        },
        "operator": {
            "color": "#FF5600"
        },
        "unclosed_string": {
            "color": "#00A33F",
            "paper": "#EECCCC"
        },
        "single_quoted_string": {
            "color": "#00A33F"
        },
        "triple_double_quoted_string": {
            "color": "#00A33F"
        },
        "triple_single_quoted_string": {
            "color": "#00A33F"
        }
    }
}


IDLE_THEME["enaml"] = IDLE_THEME["python"]

########NEW FILE########
__FILENAME__ = mono_font
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import sys


if sys.platform == 'win32':
    MONO_FONT = '12pt Consolas'
elif sys.platform == 'darwin':
    MONO_FONT = '12pt Menlo'
else:
    MONO_FONT = '12pt Courier'

########NEW FILE########
__FILENAME__ = scintilla
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import uuid

from atom.api import (
    Atom, Int, Constant, Enum, Event, Typed, ForwardTyped, observe, set_default
)

from enaml.core.declarative import d_
from enaml.widgets.control import Control, ProxyControl


#: The available syntaxes for the Scintilla widget.
SYNTAXES = (
    '',
    'bash',
    'batch',
    'cmake',
    'cpp',
    'csharp',
    'css',
    'd',
    'diff',
    'enaml',
    'fortran',
    'fortran77',
    'html',
    'idl',
    'java',
    'javascript',
    'lua',
    'makefile',
    'matlab',
    'octave',
    'pascal',
    'perl',
    'postscript',
    'pov',
    'python',
    'ruby',
    'spice',
    'sql',
    'tcl',
    'tex',
    'verilog',
    'vhdl',
    'xml',
    'yaml',
)


class ScintillaDocument(Atom):
    """ An opaque class which represents a Scintilla text document.

    An instance of this class can be shared with multiple Scintilla
    widgets to enable multiple editor views on the same buffer, or
    to use multiple buffers with the same view.

    """
    #: A uuid which can be used as a handle by the toolkit backend.
    uuid = Constant(factory=lambda: uuid.uuid4().hex)


class ProxyScintilla(ProxyControl):
    """ The abstract definition of a proxy Scintilla object.

    """
    #: A reference to the Scintilla declaration.
    declaration = ForwardTyped(lambda: Scintilla)

    def set_document(self, document):
        raise NotImplementedError

    def set_syntax(self, lexer):
        raise NotImplementedError

    def set_theme(self, theme):
        raise NotImplementedError

    def set_settings(self, settings):
        raise NotImplementedError

    def set_zoom(self, zoom):
        raise NotImplementedError

    def get_text(self):
        raise NotImplementedError

    def set_text(self, text):
        raise NotImplementedError


class Scintilla(Control):
    """ A Scintilla text editing control.

    Notes
    -----
    The 'background', 'foreground', and 'font' attributes have no effect
    on this widget. All styling is supplied via the 'theme' attribute.

    """
    #: The scintilla document buffer to use in the editor. A default
    #: document will be created automatically for each editor. This
    #: value only needs to be supplied when swapping buffers or when
    #: using a single buffer in multiple editors.
    document = d_(Typed(ScintillaDocument, ()))

    #: The language syntax to apply to the document.
    syntax = d_(Enum(*SYNTAXES))

    #: The theme to apply to the widget. See the './THEMES' document
    #: for how to create a theme dict for the widget.
    theme = d_(Typed(dict, ()))

    #: The settings to apply to the widget. See the './SETTINGS'
    #: document for how to create a settings dict for the widget.
    settings = d_(Typed(dict, ()))

    #: The zoom factor for the editor. The value is internally clamped
    #: to the range -10 to 20, inclusive.
    zoom = d_(Int())

    #: An event emitted when the text is changed.
    text_changed = d_(Event(), writable=False)

    #: Text Editors expand freely in height and width by default.
    hug_width = set_default('ignore')
    hug_height = set_default('ignore')

    #: A reference to the ProxyScintilla object.
    proxy = Typed(ProxyScintilla)

    #--------------------------------------------------------------------------
    # Post Validators
    #--------------------------------------------------------------------------
    def _post_validate_document(self, old, new):
        """ Post validate the text document.

        A new document is created when the existing document is set to
        None. This ensures that the proxy object never receives a null
        document and helps keep the state synchronized.

        """
        return new or ScintillaDocument()

    def _post_validate_theme(self, old, new):
        """" Post validate the theme.

        The theme is reset to an empty dictionary if set to None.

        """
        return new or {}

    def _post_validate_settings(self, old, new):
        """" Post validate the settings.

        The settings are reset to an empty dictionary if set to None.

        """
        return new or {}

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('document', 'syntax', 'theme', 'settings', 'zoom')
    def _update_proxy(self, change):
        """ An observer which sends the document change to the proxy.

        """
        # The superclass implementation is sufficient.
        super(Scintilla, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def get_text(self):
        """ Get the text in the current document.

        Returns
        -------
        result : unicode
            The text in the current document.

        """
        if self.proxy_is_active:
            return self.proxy.get_text()
        return u''

    def set_text(self, text):
        """ Set the text in the current document.

        Parameters
        ----------
        text : unicode
            The text to apply to the current document.

        """
        if self.proxy_is_active:
            self.proxy.set_text(text)

########NEW FILE########
__FILENAME__ = slider_transform
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
""" Enaml Standard Library - Slider Transforms

This module contains declarative classes which can be used as children
of a `Slider` to transform the integer range of the slider into an
alternative data space.

"""
from atom.api import Value, Bool, Float, Range

from enaml.core.declarative import Declarative, d_


class SliderTransform(Declarative):
    """ A base class for creating declarative slider transforms.

    A SliderTransform must be subclassed to be useful. The abstract api
    defined below must be implemented by the subclass.

    When using a transform with a slider, the transform takes complete
    ownership of the slider range. No effort is made to observe outside
    changes to the slider range, so all changes should be made on the
    transform.

    """
    #: The data-space minimum for the transform. This may be redefined
    #: by a subclass to enforce stronger typing.
    minimum = d_(Value())

    #: The data-space maximum for the transform. This may be redefined
    #: by a subclass to enforce stronger typing.
    maximum = d_(Value())

    #: The data-space value for the transform. This may be redefined
    #: by a subclass to enforce stronger typing.
    value = d_(Value())

    #: A boolean flag used to prevent loopback cycles.
    _guard = Bool(False)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def initialize(self):
        """ A reimplemented initialization handler.

        The parent slider values are initialized during the transform
        initialization pass.

        """
        super(SliderTransform, self).initialize()
        self._apply_transform()

    def parent_changed(self, old, new):
        """ Handle the parent changed event for the transform.

        """
        super(SliderTransform, self).parent_changed(old, new)
        if old is not None:
            old.unobserve('value', self._on_slider_value_changed)
        if new is not None:
            new.observe('value', self._on_slider_value_changed)

    def _apply_transform(self, minimum=True, maximum=True, value=True):
        """ Apply the current transform to the parent slider.

        Parameters
        ----------
        minimum : bool, optional
            Whether or not to update the slider minimum. The default
            is False.

        maximum : bool, optional
            Whether or not to update the slider maximum. The default
            is False.

        value : bool, optional
            Whether or not to update the slider value. The default
            is False.

        """
        parent = self.parent
        if parent is not None:
            if minimum:
                parent.minimum = self.get_minimum()
            if maximum:
                parent.maximum = self.get_maximum()
            if value:
                parent.value = self.get_value()

    def _on_slider_value_changed(self, change):
        """ Update the transformed value when slider changes.

        """
        if change['type'] == 'update':
            self._guard = True
            try:
                self.set_value(change['value'])
            finally:
                self._guard = False

    def _observe_minimum(self, change):
        """ Update the slider minimum on transform minimum change.

        """
        if change['type'] == 'update':
            self._apply_transform(maximum=False, value=False)

    def _observe_maximum(self, change):
        """ Update the slider maximum on transform maximum change.

        """
        if change['type'] == 'update':
            self._apply_transform(minimum=False, value=False)

    def _observe_value(self, change):
        """ Update the slider value on transform value change.

        """
        if change['type'] == 'update' and not self._guard:
            self._apply_transform(minimum=False, maximum=False)

    #--------------------------------------------------------------------------
    # Abstract API
    #--------------------------------------------------------------------------
    def get_minimum(self):
        """ Get the minimum value of the transform as an int.

        Returns
        -------
        result : int
            The minimum value of the transform converted to an int.

        """
        raise NotImplementedError

    def get_maximum(self):
        """ Get the maximum value of the transform as an int.

        Returns
        -------
        result : int
            The maximum value of the transform converted to an int.

        """
        raise NotImplementedError

    def get_value(self):
        """ Get the value of the transform as an int.

        Returns
        -------
        result : int
            The value of the transform converted to an int.

        """
        raise NotImplementedError

    def set_value(self, value):
        """ Set the value of the transform from an int.

        Parameters
        ----------
        value : int
            The integer value of the slider.

        """
        raise NotImplementedError


class FloatTransform(SliderTransform):
    """ A concreted SliderTransform for floating point values.

    """
    #: A redeclared parent class member which enforces float values.
    minimum = d_(Float(0.0))

    #: A redeclared parent class member which enforces float values.
    maximum = d_(Float(1.0))

    #: A redeclared parent class member which enforces float values.
    value = d_(Float(0.0))

    #: The number of stops to use between the minimum and maximum.
    precision = d_(Range(low=1, value=100))

    #--------------------------------------------------------------------------
    # Abstract API Implementation
    #--------------------------------------------------------------------------
    def get_minimum(self):
        """ Get the minimum value of the transform as an int.

        Returns
        -------
        result : int
            The minimum value of the transform converted to an int.

        """
        return 0

    def get_maximum(self):
        """ Get the maximum value of the transform as an int.

        Returns
        -------
        result : int
            The maximum value of the transform converted to an int.

        """
        return self.precision

    def get_value(self):
        """ Get the value of the transform as an int.

        Returns
        -------
        result : int
            The value of the transform converted to an int.

        """
        offset = self.value - self.minimum
        delta = self.maximum - self.minimum
        return int(offset * self.precision / delta)

    def set_value(self, val):
        """ Set the value of the transform from an int.

        Parameters
        ----------
        value : int
            The integer value of the slider.

        """
        delta = self.maximum - self.minimum
        self.value = (val * delta / self.precision) + self.minimum

########NEW FILE########
__FILENAME__ = styling
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
""" Declarative classes which implement style sheet styling.

"""
from collections import defaultdict

from atom.api import Atom, Unicode, Typed, observe

from enaml.application import Application, deferred_call
from enaml.core.declarative import Declarative, d_


class Setter(Declarative):
    """ A declarative class for defining a style field setter.

    A :class:`Setter` is declared as a child of a :class:`Style`.
    It defines the value to be applied to a style field.

    """
    # The name 'field' was chosen since 'property' is a Python builtin.
    # 'field' also has the added benefit of being the same length as
    # 'value' which means that a group of Setter objects will be nicely
    # aligned in an Enaml source definition.
    #
    #: The style field to which this setter applies.
    field = d_(Unicode())

    #: The value to apply to the style field.
    value = d_(Unicode())

    def destroy(self):
        """ A reimplemented destructor.

        This will notify the :class:`StyleCache` when the setter is
        destroyed.

        """
        super(Setter, self).destroy()
        StyleCache._setter_destroyed(self)

    @observe('field', 'value')
    def _invalidate_cache(self, change):
        if change['type'] == 'update':
            StyleCache._setter_invalidated(self)


# Internal string split cache
_MAX_CACHE = 2000

_SPLIT_CACHE = {}

def _comma_split(text):
    cache = _SPLIT_CACHE
    if text in cache:
        return cache[text]
    if len(cache) >= _MAX_CACHE:
        cache.clear()
    result = tuple(s.strip() for s in text.split(u',') if s)
    cache[text] = result
    return result


class Style(Declarative):
    """ A declarative class for defining a style sheet style.

    A :class:`Style` is declared as a child of a :class:`StyleSheet`.
    It uses child :class:`Setter` objects to define the style fields
    to apply to widgets which are a match for the style.

    A :class:`Style` may have an arbitrary number of :class:`Setter`
    children.

    """
    #: The type name of the element which will match the style. An
    #: empty string will match all elements. Multiple elements can
    #: be separated by a comma and will match using logical OR
    #: semantics.
    element = d_(Unicode())

    #: The name of the widget style class which will match the style.
    #: An empty string will match all style classes. Multiple classes
    #: can be separated by a comma and will match using logical OR
    #: semantics.
    style_class = d_(Unicode())

    #: The object name of the widget which will match the style. An
    #: empty string will match all object names. Multiple object names
    #: can be separated by a comma and will match using logical OR
    #: semantics.
    object_name = d_(Unicode())

    #: The pseudo-class which must be active for the style to apply. An
    #: empty string will apply the syle for all pseudo-classes. Multiple
    #: classes can be separated by a colon will match using logical AND
    #: semantics. Commas can be used to separate multiple classes which
    #: will match using logical OR semantics.
    pseudo_class = d_(Unicode())

    #: The pseudo-element to which the style applies. An empty string
    #: indicates the style applies to the primary element. Multiple
    #: pseudo elements can be separated comma and match using logical
    #: OR semantics.
    pseudo_element = d_(Unicode())

    def setters(self):
        """ Get the :class:`Setter` objects declared for the style.

        Returns
        -------
        result : list
            The :class:`Setter` objects declared for the style.

        """
        return [c for c in self.children if isinstance(c, Setter)]

    def match(self, item):
        """ Get whether or not the style matches an item.

        Parameters
        ----------
        item : :class:`Stylable`
            The item to test for a style match.

        Returns
        -------
        result : int
            The match value for the item. A value less than zero
            indicates no match. A value greater than or equal to zero
            indicates a match and the specificity of the match.

        """
        specificity = 0

        if self.object_name:
            item_name = item.name
            if item_name and item_name in _comma_split(self.object_name):
                specificity += 0x100
            else:
                return -1

        if self.style_class:
            item_class = item.style_class
            if item_class:
                count = 0
                style_classes = _comma_split(self.style_class)
                for item_class in item_class.split():
                    if item_class in style_classes:
                        count += 1
                if count > 0:
                    specificity += 0x10 * count
                else:
                    return -1
            else:
                return -1

        if self.element:
            elements = _comma_split(self.element)
            for t in type(item).__mro__:
                if t.__name__ in elements:
                    specificity += 0x1
                    break
            else:
                return -1

        return specificity

    def destroy(self):
        """ A reimplemented destructor.

        This will notify the :class:`StyleCache` when the style is
        destroyed.

        """
        super(Style, self).destroy()
        StyleCache._style_destroyed(self)

    def child_added(self, child):
        """ A reimplemented child added event handler.

        This will notify the :class:`StyleCache` if the :class:`Setter`
        children of the style have changed.

        """
        super(Style, self).child_added(child)
        if self.is_initialized and isinstance(child, Setter):
            StyleCache._style_setters_changed(self)

    def child_removed(self, child):
        """ A reimplemented child removed event handler.

        This will notify the :class:`StyleCache` if the :class:`Setter`
        children of the style have changed.

        """
        super(Style, self).child_removed(child)
        if self.is_initialized and isinstance(child, Setter):
            StyleCache._style_setters_changed(self)

    @observe('element', 'style_class', 'object_name')
    def _invalidate_match_cache(self, change):
        if change['type'] == 'update':
            StyleCache._style_match_invalidated(self)

    @observe('pseudo_class', 'pseudo_element')
    def _invalidate_pseudo_cache(self, change):
        if change['type'] == 'update':
            StyleCache._style_pseudo_invalidated(self)


class StyleSheet(Declarative):
    """ A declarative class for defining a widget style sheet.

    A :class:`StyleSheet` is declared as a child of a :class:`Stylable`
    widget. It uses child :class:`Style` objects to apply styling to its
    parent widget **and all of the widget's decendents**. A
    :class:`StyleSheet` can also be provided to the global
    :class:`Application <enaml.application.Application>`, in which case
    the styling will be applied to all stylable widgets. The effective
    style sheet for a widget is the union of all its ancestor style
    sheets plus the application style sheet.

    A :class:`StyleSheet` may have an arbitrary number of :class:`Style`
    children. The child style objects are applied to a widget in the
    order of their match specificity within the style sheet.

    """
    def destroy(self):
        """ A reimplemented destructor.

        This will notify the :class:`StyleCache` when the style sheet
        is destroyed.

        """
        super(StyleSheet, self).destroy()
        StyleCache._style_sheet_destroyed(self)

    def styles(self):
        """ Get the :class:`Style` objects declared for the style sheet.

        Returns
        -------
        result : list
            The :class:`Style` objects declared for the style sheet.

        """
        return [c for c in self.children if isinstance(c, Style)]

    def child_added(self, child):
        """ A reimplemented child added event handler.

        This will notify the :class:`StyleCache` if the :class:`Style`
        children of the style sheet have changed.


        """
        super(StyleSheet, self).child_added(child)
        if self.is_initialized and isinstance(child, Style):
            StyleCache._style_sheet_styles_changed(self)

    def child_removed(self, child):
        """ A reimplemented child removed event handler.

        This will notify the :class:`StyleCache` if the :class:`Style`
        children of the style sheet have changed.

        """
        super(StyleSheet, self).child_removed(child)
        if self.is_initialized and isinstance(child, Style):
            StyleCache._style_sheet_styles_changed(self)


class Stylable(Declarative):
    """ A mixin class for defining stylable declarative objects.

    This class can be used as a mixin with any
    :class:`Declarative <enaml.core.Declarative>` class which wishes
    to support style sheets.

    """
    #: The style class to which this item belongs. Multiple classes
    #: can be separated with whitespace. An empty string indicates
    #: the widget does not belong to any style class.
    style_class = d_(Unicode())

    def destroy(self):
        """ A reimplemented destructor.

        This will notify the :class:`StyleCache` when the stylable item
        is destroyed.

        """
        super(Stylable, self).destroy()
        StyleCache._item_destroyed(self)

    def style_sheet(self):
        """ Get the :class:`StyleSheet` defined on the item.

        Returns
        -------
        result : :class:`StyleSheet` or None
            The last :class:`StyleSheet` child defined on the item,
            or None if the item has no such child.

        """
        for child in reversed(self.children):
            if isinstance(child, StyleSheet):
                return child

    def restyle(self):
        """ Restyle the object.

        This method will be called when the style dependencies for the
        object have changed. It should be reimplemented in a subclass
        to take appropriate action for the restyle.

        """
        pass

    def parent_changed(self, old, new):
        """ A reimplemented parent changed event handler.

        This will notifiy the :class:`StyleCache` if the parent of
        the item has changed.

        """
        super(Stylable, self).parent_changed(old, new)
        if self.is_initialized:
            StyleCache._item_parent_changed(self)

    def child_added(self, child):
        """ A reimplemented child added event handler.

        This will notify the :class:`StyleCache` if the
        :class:`StyleSheet` children of the item have changed.

        """
        super(Stylable, self).child_added(child)
        if self.is_initialized and isinstance(child, StyleSheet):
            StyleCache._item_style_sheet_changed(self)

    def child_removed(self, child):
        """ A reimplemented child removed event handler.

        This will notify the :class:`StyleCache` if the
        :class:`StyleSheet` children of the item have changed.

        """
        super(Stylable, self).child_removed(child)
        if self.is_initialized and isinstance(child, StyleSheet):
            StyleCache._item_style_sheet_changed(self)

    @observe('style_class')
    def _invalidate_style_class(self, change):
        if change['type'] == 'update':
            StyleCache._item_style_class_invalidated(self)


class _RestyleTask(Atom):
    dirty = Typed(set, ())
    def __call__(self):
        StyleCache._restyle_task = None
        for item in self.dirty:
            item.restyle()


def _app_style_sheet():
    app = Application.instance()
    if app is not None:
        sheet = app.style_sheet
        if sheet is not None and not sheet.is_initialized:
            sheet.initialize()
        return sheet


class StyleCache(object):
    """ An object which manages the styling caches.

    All interaction with this class is through public class methods.
    This class should be used by code which implements the styling for
    a stylable item. The public API methods can be used to query for
    the Style object which matchs a :class:`Stylable` item.

    """
    #: A private mapping of item to tuple of matching StyleSheet.
    _item_style_sheets = {}

    #: A private mapping of item to tuple of matching Style.
    _item_styles = {}

    #: A private mapping of StyleSheet to set of matched items.
    _style_sheet_items = defaultdict(set)

    #: A private mapping of Style to set of matched items.
    _style_items = defaultdict(set)

    #: The set of all items which have been queried for style.
    _queried_items = set()

    #: A private mapping of Setter to toolkit data.
    _toolkit_setters = {}

    #: A RestyleTask which collapses item restyle requests.
    _restyle_task = None

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    @classmethod
    def style_sheets(cls, item):
        """ Get the :class:`StyleSheet` objects which apply to an item.

        Parameters
        ----------
        item : :class:`Stylable`
            The stylable item of interest.

        Returns
        -------
        result : tuple
            The :class:`StyleSheet` objects which apply to the item,
            in order of ascending precedence.

        """
        cache = cls._item_style_sheets
        if item in cache:
            return cache[item]
        sheets = []
        parent = item.parent
        if parent is not None:
            sheets.extend(cls.style_sheets(parent))
        else:
            app_sheet = _app_style_sheet()
            if app_sheet is not None:
                sheets.append(app_sheet)
        if isinstance(item, Stylable):  # parent may not be a Stylable
            sheet = item.style_sheet()
            if sheet is not None:
                sheets.append(sheet)
            sheet_items = cls._style_sheet_items
            for sheet in sheets:
                sheet_items[sheet].add(item)
        sheets = cache[item] = tuple(sheets)
        cls._queried_items.add(item)
        return sheets

    @classmethod
    def styles(cls, item):
        """ Get the :class:`Style` objects which apply to an item.

        Parameters
        ----------
        item : :class:`Stylable`
            The stylable item of interest.

        Returns
        -------
        result : tuple
            The :class:`Style` objects which apply to the item, in
            order of ascending precedence.

        """
        cache = cls._item_styles
        if item in cache:
            return cache[item]
        styles = []
        for sheet in cls.style_sheets(item):
            matches = []
            for style in sheet.styles():
                specificity = style.match(item)
                if specificity >= 0:
                    matches.append((specificity, len(matches), style))
            if matches:
                matches.sort()
                styles.extend(style for _1, _2, style in matches)
        style_items = cls._style_items
        for style in styles:
            style_items[style].add(item)
        styles = cache[item] = tuple(styles)
        return styles

    @classmethod
    def toolkit_setter(cls, setter, translate):
        """ Get the toolkit representation of a setter.

        This method will return the cached toolkit setter, if available,
        or invoke the translator to create the cached setter. The cached
        toolkit setter will be cleared when the setter is invalidated.

        Parameters
        ----------
        setter : :class:`Setter`
            The style setter of interest.

        translate : callable
            A callable which accepts a single :class:`Setter` argument
            and returns a toolkit representation of the setter. The
            returned value is cached until the setter is invalidated.

        Returns
        -------
        result : object
            The toolkit representation of the setter.

        """
        cache = cls._toolkit_setters
        if setter in cache:
            return cache[setter]
        result = cache[setter] = translate(setter)
        return result

    #--------------------------------------------------------------------------
    # Protected Framework API
    #--------------------------------------------------------------------------
    @classmethod
    def _setter_destroyed(cls, setter):
        # If the parent of the setter is not being destroyed, it will
        # get a child_removed event which will trigger a restyle pass.
        # That logic does not need to be repeated here.
        cls._toolkit_setters.pop(setter, None)

    @classmethod
    def _style_destroyed(cls, style):
        # If the parent of the style is not being destroyed, it will
        # get a child_removed event which will trigger a restyle pass.
        # That logic does not need to be repeated here.
        cls._style_items.pop(style, None)

    @classmethod
    def _style_sheet_destroyed(cls, sheet):
        # If the parent of the sheet is not being destroyed, it will
        # get a child_removed event which will trigger a restyle pass.
        # That logic does not need to be repeated here.
        cls._style_sheet_items.pop(sheet, None)

    @classmethod
    def _item_destroyed(cls, item):
        cls._queried_items.discard(item)
        sheets = cls._item_style_sheets.pop(item, None)
        if sheets is not None:
            sheet_items = cls._style_sheet_items
            for sheet in sheets:
                if sheet in sheet_items:
                    sheet_items[sheet].discard(item)
        styles = cls._item_styles.pop(item, None)
        if styles is not None:
            style_items = cls._style_items
            for style in styles:
                if style in style_items:
                    style_items[style].discard(item)

    @classmethod
    def _setter_invalidated(cls, setter):
        cls._toolkit_setters.pop(setter, None)
        items = cls._style_items.get(setter.parent)
        if items is not None:
            cls._request_restyle(items)

    @classmethod
    def _style_match_invalidated(cls, style):
        cls._style_items.pop(style, None)
        items = cls._style_sheet_items.get(style.parent)
        if items is not None:
            cache = cls._item_styles
            for item in items:
                cache.pop(item, None)
            cls._request_restyle(items)

    @classmethod
    def _style_pseudo_invalidated(cls, style):
        items = cls._style_items.get(style)
        if items is not None:
            cls._request_restyle(items)

    @classmethod
    def _item_style_class_invalidated(cls, item):
        styles = cls._item_styles.pop(item, None)
        if styles is not None:
            style_items = cls._style_items
            for style in styles:
                if style in style_items:
                    style_items[style].discard(item)
        cls._request_restyle((item,))

    @classmethod
    def _style_setters_changed(cls, style):
        items = cls._style_items.get(style)
        if items is not None:
            cls._request_restyle(items)

    @classmethod
    def _style_sheet_styles_changed(cls, sheet):
        items = cls._style_sheet_items.get(sheet, None)
        if items is not None:
            styles = cls._item_styles
            for item in items:
                styles.pop(item, None)
            cls._request_restyle(items)

    @classmethod
    def _item_parent_changed(cls, item):
        # changing a parent is equivalent to changing style sheets
        cls._item_style_sheet_changed(item)

    @classmethod
    def _item_style_sheet_changed(cls, item):
        item_styles = cls._item_styles
        item_sheets = cls._item_style_sheets
        items = [i for i in item.traverse() if i in cls._queried_items]
        for item in items:
            sheets = item_sheets.pop(item, None)
            if sheets is not None:
                sheet_items = cls._style_sheet_items
                for sheet in sheets:
                    if sheet in sheet_items:
                        sheet_items[sheet].discard(item)
            styles = item_styles.pop(item, None)
            if styles is not None:
                style_items = cls._style_items
                for style in styles:
                    if style in style_items:
                        style_items[style].discard(item)
        cls._request_restyle(items)

    @classmethod
    def _app_sheet_changed(cls):
        if cls._queried_items:
            cls._item_style_sheets.clear()
            cls._item_styles.clear()
            cls._style_sheet_items.clear()
            cls._style_items.clear()
            cls._request_restyle(cls._queried_items)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def __new__(cls, *args, **kwargs):
        raise TypeError('Cannot create instances of StyleCache')

    @classmethod
    def _request_restyle(cls, items):
        task = cls._restyle_task
        if task is None:
            task = cls._restyle_task = _RestyleTask()
            deferred_call(task)
        task.dirty.update(items)

########NEW FILE########
__FILENAME__ = validator
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import re

from atom.api import Atom, Bool, Typed, Enum, Str, Unicode


class Validator(Atom):
    """ The base class for creating widget text validators.

    This class is abstract. It's abstract api must be implemented by a
    subclass in order to be usable.

    """
    #: An optional message to associate with the validator. This message
    #: may be used by the toolkit to display information to the user
    #: about what went wrong.
    message = Unicode()

    def validate(self, text):
        """ Validate the text as the user types.

        This method is called on every keystroke to validate the text
        as the user inputs characters. It should be efficient. This is
        an abstract method which must be implemented by sublasses.

        Parameters
        ----------
        text : unicode
            The unicode text entered by the user.

        Returns
        -------
        result : bool
            True if the text is valid, False otherwise.

        """
        raise NotImplementedError

    def fixup(self, text):
        """ An optional method to fix invalid user input.

        This method will be called if user attempts to apply text which
        is not valid. This method may convert the text to a valid form.
        The returned text will be retested for validity. The default
        implementation of this method is a no-op.

        Returns
        -------
        result : unicode
            The optionally modified input text.

        """
        return text


class IntValidator(Validator):
    """ A concrete Validator which handles integer input.

    This validator ensures that the text represents an integer within a
    specified range in a specified base.

    """
    #: The minimum value allowed for the int, inclusive, or None if
    #: there is no lower bound.
    minimum = Typed(int)

    #: The maximum value allowed for the int, inclusive, or None if
    #: there is no upper bound.
    maximum = Typed(int)

    #: The base in which the int is represented.
    base = Enum(10, 2, 8, 16)

    def validate(self, text):
        """ Validates the given text matches the integer range.

        Parameters
        ----------
        text : unicode
            The unicode text edited by the client widget.

        Returns
        -------
        result : bool
            True if the text is valid, False otherwise.

        """
        try:
            value = int(text, self.base)
        except ValueError:
            return False
        minimum = self.minimum
        if minimum is not None and value < minimum:
            return False
        maximum = self.maximum
        if maximum is not None and value > maximum:
            return False
        return True


class FloatValidator(Validator):
    """ A concrete Validator which handles floating point input.

    This validator ensures that the text represents a floating point
    number within a specified range.

    """
    #: The minimum value allowed for the float, inclusive, or None if
    #: there is no lower bound.
    minimum = Typed(float)

    #: The maximum value allowed for the float, inclusive, or None if
    #: there is no upper bound.
    maximum = Typed(float)

    #: Whether or not to allow exponents like '1e6' in the input.
    allow_exponent = Bool(True)

    def validate(self, text):
        """ Validates the given text matches the float range.

        Parameters
        ----------
        text : unicode
            The unicode text edited by the client widget.

        Returns
        -------
        result : bool
            True if the text is valid, False otherwise.

        """
        try:
            value = float(text)
        except ValueError:
            return False
        minimum = self.minimum
        if minimum is not None and value < minimum:
            return False
        maximum = self.maximum
        if maximum is not None and value > maximum:
            return False
        if not self.allow_exponent and 'e' in text.lower():
            return False
        return True


class RegexValidator(Validator):
    """ A concrete Validator which handles text input.

    This validator ensures that the text matches a provided regular
    expression string.

    """
    #: The regular expression string to use for validation. The default
    #: regex matches everything.
    regex = Str(r'.*')

    def validate(self, text):
        """ Validates the given text matches the regular expression.

        Parameters
        ----------
        text : unicode
            The unicode text edited by the client widget.

        Returns
        -------
        result : bool
            True if the text is valid, False otherwise.

        """
        return bool(re.match(self.regex, text))

########NEW FILE########
__FILENAME__ = version
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
""" The version information for this release of Enaml.

"""
from collections import namedtuple

# The major release number. Differences in the major number indicate
# possibly large differences in API.
MAJOR = 0

# The minor release number. Differences in the minor number indicate
# possibly small differences in the API, but these changes will come
# backwards compatibility support when possible. Minor releases are
# typically used for large feature additions.
MINOR = 9

# The micro release number. The micro release number is incremented
# for bug fix releases and small feature additions.
MICRO = 7

#: A namedtuple of the version info for the current release.
version_info = namedtuple('version_info', 'major minor micro')
version_info = version_info(MAJOR, MINOR, MICRO)

# Remove everything but the 'version_info' from this module.
del namedtuple, MAJOR, MINOR, MICRO

########NEW FILE########
__FILENAME__ = abstract_button
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import (
    Bool, Unicode, Coerced, Event, Typed, ForwardTyped, observe, set_default
)

from enaml.core.declarative import d_
from enaml.icon import Icon
from enaml.layout.geometry import Size

from .control import Control, ProxyControl


class ProxyAbstractButton(ProxyControl):
    """ The abstract definition of a proxy AbstractButton object.

    """
    #: A reference to the AbstractButton declaration.
    declaration = ForwardTyped(lambda: AbstractButton)

    def set_text(self, text):
        raise NotImplementedError

    def set_icon(self, icon):
        raise NotImplementedError

    def set_icon_size(self, size):
        raise NotImplementedError

    def set_checkable(self, checkable):
        raise NotImplementedError

    def set_checked(self, checked):
        raise NotImplementedError


class AbstractButton(Control):
    """ A base class for creating button-like controls.

    """
    #: The text to use as the button's label.
    text = d_(Unicode())

    #: The source url for the icon to use for the button.
    icon = d_(Typed(Icon))

    #: The size to use for the icon. The default is an invalid size
    #: and indicates that an appropriate default should be used.
    icon_size = d_(Coerced(Size, (-1, -1)))

    #: Whether or not the button is checkable. The default is False.
    checkable = d_(Bool(False))

    #: Whether a checkable button is currently checked.
    checked = d_(Bool(False))

    #: Fired when the button is pressed then released. The payload will
    #: be the current checked state. This event is triggered by the
    #: proxy object when the button is clicked.
    clicked = d_(Event(bool), writable=False)

    #: Fired when a checkable button is toggled. The payload will be
    #: the current checked state. This event is triggered by the
    #: proxy object when a togglable button is toggled.
    toggled = d_(Event(bool), writable=False)

    #: Buttons hug their contents' width weakly by default.
    hug_width = set_default('weak')

    #: A reference to the ProxyAbstractButton object.
    proxy = Typed(ProxyAbstractButton)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('text', 'icon', 'icon_size', 'checkable', 'checked')
    def _update_proxy(self, change):
        """ An observer which updates the proxy widget.

        """
        # The superclass implementation is sufficient.
        super(AbstractButton, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = action
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed, ForwardTyped, Unicode, Bool, Event, observe

from enaml.core.declarative import d_
from enaml.icon import Icon

from .toolkit_object import ToolkitObject, ProxyToolkitObject


class ProxyAction(ProxyToolkitObject):
    """ The abstract definition of a proxy Action object.

    """
    #: A reference to the Action declaration.
    declaration = ForwardTyped(lambda: Action)

    def set_text(self, text):
        raise NotImplementedError

    def set_tool_tip(self, tool_tip):
        raise NotImplementedError

    def set_status_tip(self, status_tip):
        raise NotImplementedError

    def set_icon(self, icon):
        raise NotImplementedError

    def set_checkable(self, checkable):
        raise NotImplementedError

    def set_checked(self, checked):
        raise NotImplementedError

    def set_enabled(self, enabled):
        raise NotImplementedError

    def set_visible(self, visible):
        raise NotImplementedError

    def set_separator(self, separator):
        raise NotImplementedError


class Action(ToolkitObject):
    """ A non visible widget used in a ToolBar or Menu.

    An Action represents an actionable item in a ToolBar or a Menu.
    Though an Action itself is a non-visible component, it will be
    rendered in an appropriate fashion for the location where it is
    used.

    """
    #: The text label associate with the action.
    text = d_(Unicode())

    #: The tool tip text to use for this action. Typically displayed
    #: as a small label when the user hovers over the action.
    tool_tip = d_(Unicode())

    #: The text that is displayed in the status bar when the user
    #: hovers over the action.
    status_tip = d_(Unicode())

    #: The icon to use for the Action.
    icon = d_(Typed(Icon))

    #: Whether or not the action can be checked.
    checkable = d_(Bool(False))

    #: Whether or not the action is checked. This value only has meaning
    #: if 'checkable' is set to True.
    checked = d_(Bool(False))

    #: Whether or not the item representing the action is enabled.
    enabled = d_(Bool(True))

    #: Whether or not the item representing the action is visible.
    visible = d_(Bool(True))

    #: Whether or not the action should be treated as a separator. If
    #: this value is True, none of the other values have meaning.
    separator = d_(Bool(False))

    #: An event fired when the action is triggered by user interaction.
    #: They payload will be the current checked state. This event is
    #: triggered by the proxy object when the action is triggerd.
    triggered = d_(Event(bool), writable=False)

    #: An event fired when a checkable action changes its checked state.
    #: The payload will be the current checked state. This event is
    #: triggerd by the proxy object when the action is toggled.
    toggled = d_(Event(bool), writable=False)

    #: A reference to the ProxyAction object.
    proxy = Typed(ProxyAction)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('text', 'tool_tip', 'status_tip', 'icon', 'checkable', 'checked',
        'enabled', 'visible', 'separator')
    def _update_proxy(self, change):
        """ An observer which updates the proxy when the Action changes.

        """
        # The superclass implementation is sufficient
        super(Action, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = action_group
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Typed, ForwardTyped, observe

from enaml.core.declarative import d_

from .action import Action
from .toolkit_object import ToolkitObject, ProxyToolkitObject


class ProxyActionGroup(ProxyToolkitObject):
    """ The abstract definition of a proxy ActionGroup object.

    """
    #: A reference to the ActionGroup declaration.
    declaration = ForwardTyped(lambda: ActionGroup)

    def set_exclusive(self, exclusive):
        raise NotImplementedError

    def set_enabled(self, enabled):
        raise NotImplementedError

    def set_visible(self, visible):
        raise NotImplementedError


class ActionGroup(ToolkitObject):
    """ A non visible widget used to group actions.

    An action group can be used in a MenuBar or a ToolBar to group a
    related set of Actions and apply common operations to the set. The
    primary use of an action group is to make any checkable actions in
    the group mutually exclusive.

    """
    #: Whether or not the actions in this group are exclusive.
    exclusive = d_(Bool(True))

    #: Whether or not the actions in this group are enabled.
    enabled = d_(Bool(True))

    #: Whether or not the actions in this group are visible.
    visible = d_(Bool(True))

    #: A reference to the ProxyActionGroup object.
    proxy = Typed(ProxyActionGroup)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def actions(self):
        """ Get Actions defined as children of the ActionGroup.

        """
        return [child for child in self.children if isinstance(child, Action)]

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('exclusive', 'enabled', 'visible')
    def _update_proxy(self, change):
        """ An observer which updates the proxy when the group changes.

        """
        # The superclass implementation is sufficient.
        super(ActionGroup, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = api
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from .action import Action
from .action_group import ActionGroup
from .calendar import Calendar
from .check_box import CheckBox
from .color_dialog import ColorDialog
from .combo_box import ComboBox
from .container import Container
from .date_selector import DateSelector
from .datetime_selector import DatetimeSelector
from .dialog import Dialog
from .dock_area import DockArea
from .dock_item import DockItem
from .dock_pane import DockPane
from .dual_slider import DualSlider
from .field import Field
from .file_dialog import FileDialog
from .file_dialog_ex import FileDialogEx
from .flow_area import FlowArea
from .flow_item import FlowItem
from .focus_tracker import FocusTracker
from .form import Form
from .frame import Border
from .group_box import GroupBox
from .h_group import HGroup
from .html import Html
from .image_view import ImageView
from .ipython_console import IPythonConsole
from .label import Label
from .main_window import MainWindow
from .mdi_area import MdiArea
from .mdi_window import MdiWindow
from .menu import Menu
from .menu_bar import MenuBar
from .mpl_canvas import MPLCanvas
from .multiline_field import MultilineField
from .notebook import Notebook
from .object_combo import ObjectCombo
from .page import Page
from .popup_view import PopupView
from .progress_bar import ProgressBar
from .push_button import PushButton
from .radio_button import RadioButton
from .raw_widget import RawWidget
from .scroll_area import ScrollArea
from .separator import Separator
from .slider import Slider
from .spin_box import SpinBox
from .split_item import SplitItem
from .splitter import Splitter
from .stack import Stack, Transition
from .stack_item import StackItem
from .status_bar import StatusBar
from .status_item import StatusItem
from .time_selector import TimeSelector
from .timer import Timer
from .tool_bar import ToolBar
from .tool_button import ToolButton
from .v_group import VGroup
from .vtk_canvas import VTKCanvas
from .web_view import WebView
from .widget import Feature
from .window import Window

########NEW FILE########
__FILENAME__ = bounded_date
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from datetime import date as pydate

from atom.api import Typed, ForwardTyped, observe

from enaml.core.declarative import d_

from .control import Control, ProxyControl


class ProxyBoundedDate(ProxyControl):
    """ The abstract defintion of a proxy BoundedDate object.

    """
    #: A reference to the BoundedDate declaration.
    declaration = ForwardTyped(lambda: BoundedDate)

    def set_minimum(self, minimum):
        raise NotImplementedError

    def set_maximum(self, maximum):
        raise NotImplementedError

    def set_date(self, date):
        raise NotImplementedError


class BoundedDate(Control):
    """ A base class for components which edit a Python datetime.date
    object bounded between minimum and maximum values.

    This class is not meant to be used directly.

    """
    #: The minimum date available in the date edit. If the minimum value
    #: is changed such that it becomes greater than the current value or
    #: the maximum value, then those values will be adjusted. The default
    #: value is September 14, 1752.
    minimum = d_(Typed(pydate, args=(1752, 9, 14)))

    #: The maximum date available in the date edit. If the maximum value
    #: is changed such that it becomes smaller than the current value or
    #: the minimum value, then those values will be adjusted. The default
    #: value is December 31, 7999.
    maximum = d_(Typed(pydate, args=(7999, 12, 31)))

    #: The date in the control. This will be clipped to the supplied
    #: maximum and minimum values. The default is date.today().
    date = d_(Typed(pydate, factory=pydate.today))

    #: A reference to the ProxyBoundedDate object.
    proxy = Typed(ProxyBoundedDate)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('minimum', 'maximum', 'date')
    def _update_proxy(self, change):
        """ An observer which updates the proxy when the data changes.

        """
        # The superclass implementation is sufficient.
        super(BoundedDate, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # Post Setattr Handlers
    #--------------------------------------------------------------------------
    def _post_setattr_minimum(self, old, new):
        """ Post setattr the minimum date.

        If the new minimum is greater than the current value or the
        maximum, those values are adjusted up.

        """
        if new > self.maximum:
            self.maximum = new
        if new > self.date:
            self.date = new

    def _post_setattr_maximum(self, old, new):
        """ Post setattr the maximum date.

        If the new maximum is less than the current value or the
        minimum, those values are adjusted down.

        """
        if new < self.minimum:
            self.minimum = new
        if new < self.date:
            self.date = new

    #--------------------------------------------------------------------------
    # Post Validate Handlers
    #--------------------------------------------------------------------------
    def _post_validate_date(self, old, new):
        """ Post validate the date for the control.

        If it lies outside of minimum and maximum bounds, it will be
        clipped to the bounds.

        """
        return max(self.minimum, min(new, self.maximum))

########NEW FILE########
__FILENAME__ = bounded_datetime
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from datetime import datetime as pydatetime

from atom.api import Typed, ForwardTyped, observe

from enaml.core.declarative import d_

from .control import Control, ProxyControl


class ProxyBoundedDatetime(ProxyControl):
    """ The abstract defintion of a proxy BoundedDate object.

    """
    #: A reference to the BoundedDatetime declaration.
    declaration = ForwardTyped(lambda: BoundedDatetime)

    def set_minimum(self, minimum):
        raise NotImplementedError

    def set_maximum(self, maximum):
        raise NotImplementedError

    def set_datetime(self, datetime):
        raise NotImplementedError


class BoundedDatetime(Control):
    """ A base class for use with widgets that edit a Python
    datetime.datetime object bounded between minimum and maximum
    values. This class is not meant to be used directly.

    """
    #: The minimum datetime available in the datetime edit. If not
    #: defined then the default value is midnight September 14, 1752.
    minimum = d_(Typed(pydatetime, args=(1752, 9, 14, 0, 0, 0, 0)))

    #: The maximum datetime available in the datetime edit. If not
    #: defined then the default value is the second before midnight
    #: December 31, 7999.
    maximum = d_(Typed(pydatetime, args=(7999, 12, 31, 23, 59, 59, 999000)))

    #: The currently selected date. Default is datetime.now(). The
    #: value is bounded between :attr:`minimum` and :attr:`maximum`.
    datetime = d_(Typed(pydatetime, factory=pydatetime.now))

    #: A reference to the ProxyBoundedDatetime object.
    proxy = Typed(ProxyBoundedDatetime)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('minimum', 'maximum', 'datetime')
    def _update_proxy(self, change):
        """ An observer which updates the proxy when the data changes.

        """
        # The superclass implementation is sufficient.
        super(BoundedDatetime, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # Post Setattr Handlers
    #--------------------------------------------------------------------------
    def _post_setattr_minimum(self, old, new):
        """ Post setattr the minimum datetime.

        If the new minimum is greater than the current value or the
        maximum, those values are adjusted up.

        """
        if new > self.maximum:
            self.maximum = new
        if new > self.datetime:
            self.datetime = new

    def _post_setattr_maximum(self, old, new):
        """ Post setattr the maximum datetime.

        If the new maximum is less than the current value or the
        minimum, those values are adjusted down.

        """
        if new < self.minimum:
            self.minimum = new
        if new < self.datetime:
            self.datetime = new

    #--------------------------------------------------------------------------
    # Post Validate Handlers
    #--------------------------------------------------------------------------
    def _post_validate_datetime(self, old, new):
        """ Post validate the datetime for the control.

        If it lies outside of minimum and maximum bounds, it will be
        clipped to the bounds.

        """
        return max(self.minimum, min(new, self.maximum))

########NEW FILE########
__FILENAME__ = bounded_time
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from datetime import datetime, time as pytime

from atom.api import Typed, ForwardTyped, observe

from enaml.core.declarative import d_

from .control import Control, ProxyControl


class ProxyBoundedTime(ProxyControl):
    """ The abstract defintion of a proxy BoundedTime object.

    """
    #: A reference to the BoundedTime declaration.
    declaration = ForwardTyped(lambda: BoundedTime)

    def set_minimum(self, minimum):
        raise NotImplementedError

    def set_maximum(self, maximum):
        raise NotImplementedError

    def set_time(self, time):
        raise NotImplementedError


class BoundedTime(Control):
    """ A base class for use with widgets that edit a Python
    datetime.time object bounded between minimum and maximum
    values. This class is not meant to be used directly.

    """
    #: The minimum time available in the datetime edit. The default value
    #: is midnight.
    minimum = d_(Typed(pytime, args=(0, 0, 0)))

    #: The maximum time available in the datetime edit. The default is
    #: one second before midnight.
    maximum = d_(Typed(pytime, args=(23, 59, 59, 999000)))

    #: The currently selected time. Default is datetime.now().time().
    #: The value is clipped between :attr:`minimum` and :attr:`maximum`.
    time = d_(Typed(pytime, factory=lambda: datetime.now().time()))

    #: A reference to the ProxyBoundedTime object.
    proxy = Typed(ProxyBoundedTime)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('minimum', 'maximum', 'time')
    def _update_proxy(self, change):
        """ An observer which updates the proxy when the data changes.

        """
        # The superclass implementation is sufficient.
        super(BoundedTime, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # Post Setattr Handlers
    #--------------------------------------------------------------------------
    def _post_setattr_minimum(self, old, new):
        """ Post setattr the minimum time.

        If the new minimum is greater than the current value or the
        maximum, those values are adjusted up.

        """
        if new > self.maximum:
            self.maximum = new
        if new > self.time:
            self.time = new

    def _post_setattr_maximum(self, old, new):
        """ Post setattr the maximum time.

        If the new maximum is less than the current value or the
        minimum, those values are adjusted down.

        """
        if new < self.minimum:
            self.minimum = new
        if new < self.time:
            self.time = new

    #--------------------------------------------------------------------------
    # Post Validate Handlers
    #--------------------------------------------------------------------------
    def _post_validate_time(self, old, new):
        """ Post validate the time for the control.

        If it lies outside of minimum and maximum bounds, it will be
        clipped to the bounds.

        """
        return max(self.minimum, min(new, self.maximum))

########NEW FILE########
__FILENAME__ = calendar
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed, ForwardTyped

from .bounded_date import BoundedDate, ProxyBoundedDate


class ProxyCalendar(ProxyBoundedDate):
    """ The abstract defintion of a proxy Calendar object.

    """
    #: A reference to the Calendar declaration.
    declaration = ForwardTyped(lambda: Calendar)


class Calendar(BoundedDate):
    """ A bounded date control which edits a Python datetime.date using
    a widget which resembles a calendar.

    """
    #: A reference to the ProxyCalendar object.
    proxy = Typed(ProxyCalendar)

########NEW FILE########
__FILENAME__ = check_box
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed, ForwardTyped, set_default

from .abstract_button import AbstractButton, ProxyAbstractButton


class ProxyCheckBox(ProxyAbstractButton):
    """ The abstract definition of a proxy PushButton object.

    """
    #: A reference to the CheckBox declaration.
    declaration = ForwardTyped(lambda: CheckBox)


class CheckBox(AbstractButton):
    """ An checkable button represented by a standard check box widget.

    Use a check box when it's necessary to toggle a boolean value
    independent of any other widgets in a group.

    When its necessary to allow the toggling of only one value in a
    group of values, use a group of RadioButtons or the RadioGroup
    control from the Enaml standard library.

    The interface for AbstractButton fully defines the interface for
    a CheckBox.

    """
    #: Check boxes are checkable by default.
    checkable = set_default(True)

    #: A reference to the ProxyPushButton object.
    proxy = Typed(ProxyCheckBox)

########NEW FILE########
__FILENAME__ = color_dialog
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Typed, ForwardTyped, observe

from enaml.application import Application
from enaml.colors import ColorMember, Color
from enaml.core.declarative import d_

from .toolkit_dialog import ToolkitDialog, ProxyToolkitDialog


class ProxyColorDialog(ProxyToolkitDialog):
    """ The abstract defintion of a proxy ColorDialog object.

    """
    #: A reference to the ColorDialog declaration.
    declaration = ForwardTyped(lambda: ColorDialog)

    @staticmethod
    def custom_count():
        raise NotImplementedError

    @staticmethod
    def custom_color(index):
        raise NotImplementedError

    @staticmethod
    def set_custom_color(index, color):
        raise NotImplementedError

    def set_current_color(self, color):
        raise NotImplementedError

    def set_show_alpha(self, show):
        raise NotImplementedError

    def set_show_buttons(self, show):
        raise NotImplementedError


class ColorDialog(ToolkitDialog):
    """ A toolkit dialog that allows the user to select a color.

    """
    #: The currently selected color of the dialog.
    current_color = d_(ColorMember('white'))

    #: Whether or not to show the alpha value control.
    show_alpha = d_(Bool(True))

    #: Whether or not to show the dialog ok/cancel buttons.
    show_buttons = d_(Bool(True))

    #: The color selected when the user clicks accepts the dialog.
    #: This value is output only.
    selected_color = ColorMember()

    #: A reference to the ProxyColorDialog object.
    proxy = Typed(ProxyColorDialog)

    @staticmethod
    def get_color(parent=None, **kwargs):
        """ A static method which launches a color dialog.

        Parameters
        ----------
        parent : ToolkitObject or None
            The parent toolkit object for this dialog.

        **kwargs
            Additional data to pass to the dialog constructor.

        Returns
        -------
        result : Color or None
            The selected color or None if no color was selected.

        """
        dialog = ColorDialog(parent, **kwargs)
        if dialog.exec_():
            return dialog.selected_color

    @staticmethod
    def custom_count():
        """ Get the number of available custom colors.

        The custom colors are shared among all color dialogs.

        Returns
        -------
        result : int
            The number of available custom colors.

        Notes
        -----
        The Application object must exist before calling this method.

        """
        app = Application.instance()
        assert app is not None, 'the application object does not exist'
        proxy_cls = app.resolve_proxy_class(ColorDialog)
        if proxy_cls is not None:
            return proxy_cls.custom_count()
        return 0

    @staticmethod
    def custom_color(index):
        """ Get the custom color for the given index.

        The custom colors are shared among all color dialogs.

        Parameters
        ----------
        index : int
            The integer index of the custom color.

        Returns
        -------
        result : Color
            The custom color for the index.

        Notes
        -----
        The Application object must exist before calling this method.

        """
        app = Application.instance()
        assert app is not None, 'the application object does not exist'
        proxy_cls = app.resolve_proxy_class(ColorDialog)
        if proxy_cls is not None:
            return proxy_cls.custom_color(index)
        return Color(255, 255, 255)

    @staticmethod
    def set_custom_color(index, color):
        """ Set the custom color for the given index.

        The custom colors are shared among all color dialogs.

        Parameters
        ----------
        index : int
            The integer index of the custom color.

        color : Color
            The custom color to set for the index

        Notes
        -----
        The Application object must exist before calling this method.

        """
        app = Application.instance()
        assert app is not None, 'the application object does not exist'
        proxy_cls = app.resolve_proxy_class(ColorDialog)
        if proxy_cls is not None:
            proxy_cls.set_custom_color(index, color)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('current_color', 'show_alpha', 'show_buttons')
    def _update_proxy(self, change):
        """ An observer which updates the proxy when the data changes.

        """
        # The superclass implementation is sufficient.
        super(ColorDialog, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def _prepare(self):
        """ A reimplemented preparation method.

        This method resets the selected color to None.

        """
        super(ColorDialog, self)._prepare()
        self.selected_color = None

########NEW FILE########
__FILENAME__ = combo_box
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import (
    Bool, List, Int, Property, Unicode, Typed, ForwardTyped, set_default,
    observe
)

from enaml.core.declarative import d_

from .control import Control, ProxyControl


class ProxyComboBox(ProxyControl):
    """ The abstract defintion of a proxy ComboBox object.

    """
    #: A reference to the ComboBox declaration.
    declaration = ForwardTyped(lambda: ComboBox)

    def set_items(self, items):
        raise NotImplementedError

    def set_index(self, index):
        raise NotImplementedError

    def set_editable(self, editable):
        raise NotImplementedError


class ComboBox(Control):
    """ A drop-down list from which one item can be selected at a time.

    Use a combo box to select a single item from a collection of items.

    See `ObjectCombo` for a more robust combo box control.

    """
    #: The unicode strings to display in the combo box.
    items = d_(List(Unicode()))

    #: The integer index of the currently selected item. If the index
    #: falls outside the range of items, the item will be deselected.
    index = d_(Int(-1))

    #: A read only cached property which returns the selected item.
    selected_item = d_(Property(cached=True), writable=False)

    #: Whether the text in the combo box can be edited by the user.
    editable = d_(Bool(False))

    #: A combo box hugs its width weakly by default.
    hug_width = set_default('weak')

    #: A reference to the ProxyComboBox object.
    proxy = Typed(ProxyComboBox)

    @selected_item.getter
    def get_selected_item(self):
        """ The getter function for the selected item property.

        If the index falls out of range, the selected item will be an
        empty string.

        """
        items = self.items
        idx = self.index
        if idx < 0 or idx >= len(items):
            return u''
        return items[idx]

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('index', 'items', 'editable')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(ComboBox, self)._update_proxy(change)

    @observe('index', 'items')
    def _reset_selected_item(self, change):
        """ Reset the selected item when the index or items changes.

        """
        if change['type'] == 'update':
            self.get_member('selected_item').reset(self)

########NEW FILE########
__FILENAME__ = constraints_widget
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import List, ForwardTyped, Typed, observe

from enaml.core.declarative import d_
from enaml.layout.constrainable import ConstrainableMixin, PolicyEnum

from .widget import Widget, ProxyWidget


class ProxyConstraintsWidget(ProxyWidget):
    """ The abstract definition of a proxy ConstraintsWidget object.

    """
    #: A reference to the ConstraintsWidget declaration.
    declaration = ForwardTyped(lambda: ConstraintsWidget)

    def request_relayout(self):
        raise NotImplementedError


class ConstraintsWidget(Widget, ConstrainableMixin):
    """ A Widget subclass which adds constraint information.

    A ConstraintsWidget is augmented with symbolic constraint variables
    which define a box model on the widget. This box model is used to
    declare constraints between this widget and other components which
    participate in constraints-based layout.

    Constraints are added to a widget by assigning a list to the
    'constraints' attribute. This list may contain raw Constraint
    objects, which are created by manipulating the symbolic constraint
    variables, or ConstraintHelper objects which generate Constraint
    objects on request.

    """
    #: The list of user-specified constraints or ConstraintHelpers.
    constraints = d_(List())

    # Redefine the policy enums as declarative members. The docs on
    # the ConstrainableMixin class provide their full explanation.
    hug_width = d_(PolicyEnum('strong'))
    hug_height = d_(PolicyEnum('strong'))
    resist_width = d_(PolicyEnum('strong'))
    resist_height = d_(PolicyEnum('strong'))
    limit_width = d_(PolicyEnum('ignore'))
    limit_height = d_(PolicyEnum('ignore'))

    #: A reference to the ProxyConstraintsWidget object.
    proxy = Typed(ProxyConstraintsWidget)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe(
        'constraints', 'hug_width', 'hug_height', 'resist_width',
        'resist_height', 'limit_width', 'limit_height', 'visible')
    def _layout_invalidated(self, change):
        """ An observer which will relayout the proxy widget.

        """
        if change['type'] == 'update':
            self.request_relayout()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def request_relayout(self):
        """ Request a relayout from the proxy widget.

        This will invoke the 'request_relayout' method on an active
        proxy. The proxy should collapse the requests as necessary.

        """
        if self.proxy_is_active:
            self.proxy.request_relayout()

    def when(self, switch):
        """ A method which returns `self` or None based on the truthness
        of the argument.

        This can be useful to easily turn off the effects of an object
        in constraints-based layout.

        Parameters
        ----------
        switch : bool
            A boolean which indicates whether this instance or None
            should be returned.

        Returns
        -------
        result : self or None
            If 'switch' is boolean True, self is returned. Otherwise,
            None is returned.

        """
        if switch:
            return self

    def layout_constraints(self):
        """ Get the constraints to use for this component's layout.

        This method may be overridden by subclasses as needed to create
        custom constraints. It will be called when the relayout request
        has been made by the layout engine. The default implementation
        will return the list of 'constraints' defined by the user.

        """
        return self.constraints

########NEW FILE########
__FILENAME__ = container
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Coerced, ForwardTyped, Typed, observe, set_default

from enaml.core.declarative import d_, d_func
from enaml.layout.constrainable import ContentsConstrainableMixin
from enaml.layout.geometry import Box
from enaml.layout.layout_helpers import vbox

from .constraints_widget import ConstraintsWidget
from .frame import Frame, ProxyFrame


class ProxyContainer(ProxyFrame):
    """ The abstract definition of a proxy Container object.

    """
    #: A reference to the Container declaration.
    declaration = ForwardTyped(lambda: Container)


class Container(Frame, ContentsConstrainableMixin):
    """ A Frame subclass which provides child layout functionality.

    The Container is the canonical component used to arrange child
    widgets using constraints-based layout. The developer can supply
    a list of constraints on the container which specify how to layout
    it's child widgets.

    There are widgets whose boundaries constraints may not cross. Some
    examples of these would be a ScrollArea or a Notebook. See the
    documentation of a given widget as to whether or not constraints
    may cross its boundaries.

    """
    #: A boolean which indicates whether or not to allow the layout
    #: ownership of this container to be transferred to an ancestor.
    #: This is False by default, which means that every container
    #: get its own layout solver. This improves speed and reduces
    #: memory use (by keeping a solver's internal tableaux small)
    #: but at the cost of not being able to share constraints
    #: across Container boundaries. This flag must be explicitly
    #: marked as True to enable sharing.
    share_layout = d_(Bool(False))

    #: A box object which holds the padding for this component. The
    #: padding is the amount of space between the outer boundary box
    #: and the content box. The default padding is 10 pixels a side.
    #: Certain subclasses, such as GroupBox, may provide additional
    #: margin than what is specified by the padding.
    padding = d_(Coerced(Box, (10, 10, 10, 10)))

    #: A Container does not generate constraints for its size hint by
    #: default. The minimum and maximum size constraints are sufficient
    #: to supply size limits and make for the most natural interaction
    #: between nested containers.
    resist_width = set_default('ignore')
    resist_height = set_default('ignore')
    hug_width = set_default('ignore')
    hug_height = set_default('ignore')

    #: A reference to the ProxyContainer object.
    proxy = Typed(ProxyContainer)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def widgets(self):
        """ Get the child ConstraintsWidgets defined on the container.

        """
        return [c for c in self.children if isinstance(c, ConstraintsWidget)]

    def visible_widgets(self):
        """ Get the visible child ConstraintsWidgets on the container.

        """
        return [w for w in self.widgets() if w.visible]

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event on the container.

        This event handler will request a relayout if the added child
        is an instance of 'ConstraintsWidget'.

        """
        # Request the relayout first so that the widget's updates are
        # disabled before the child is actually added.
        if isinstance(child, ConstraintsWidget):
            self.request_relayout()
        super(Container, self).child_added(child)

    def child_removed(self, child):
        """ Handle the child removed event on the container.

        This event handler will request a relayout if the removed child
        is an instance of 'ConstraintsWidget'.

        """
        # Request the relayout first so that the widget's updates are
        # disabled before the child is actually removed.
        if isinstance(child, ConstraintsWidget):
            self.request_relayout()
        super(Container, self).child_removed(child)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('share_layout', 'padding')
    def _layout_invalidated(self, change):
        """ A private observer which invalidates the layout.

        """
        # The superclass handler is sufficient.
        super(Container, self)._layout_invalidated(change)

    #--------------------------------------------------------------------------
    # Layout Constraints
    #--------------------------------------------------------------------------
    @d_func
    def layout_constraints(self):
        """ The constraints generation for a Container.

        This method supplies default vbox constraints to the visible
        children of the container unless the user has given explicit
        'constraints'.

        This method may also be overridden from Enaml syntax.

        """
        if self.constraints:
            return self.constraints
        return [vbox(*self.visible_widgets())]

########NEW FILE########
__FILENAME__ = control
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed, ForwardTyped

from .constraints_widget import ConstraintsWidget, ProxyConstraintsWidget


class ProxyControl(ProxyConstraintsWidget):
    """ The abstract definition of a proxy Control object.

    """
    #: A reference to the Control declaration.
    declaration = ForwardTyped(lambda: Control)


class Control(ConstraintsWidget):
    """ A widget which represents a leaf node in the hierarchy.

    A Control is conceptually the same as a ConstraintsWidget, except
    that it does not have widget children. This base class serves as
    a placeholder for potential future functionality.

    """
    #: A reference to the proxy Control object.
    proxy = Typed(ProxyControl)

########NEW FILE########
__FILENAME__ = datetime_selector
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Str, Typed, ForwardTyped, observe, set_default

from enaml.core.declarative import d_

from .bounded_datetime import BoundedDatetime, ProxyBoundedDatetime


class ProxyDatetimeSelector(ProxyBoundedDatetime):
    """ The abstract defintion of a proxy DatetimeSelector object.

    """
    #: A reference to the DatetimeSelector declaration.
    declaration = ForwardTyped(lambda: DatetimeSelector)

    def set_datetime_format(self, format):
        raise NotImplementedError

    def set_calendar_popup(self, popup):
        raise NotImplementedError


class DatetimeSelector(BoundedDatetime):
    """ A widget to edit a Python datetime.datetime object.

    This is a geometrically smaller control than what is provided by
    Calendar.

    """
    #: A python date format string to format the datetime. If None is
    #: supplied (or is invalid) the system locale setting is used.
    #: This may not be supported by all backends.
    datetime_format = d_(Str())

    #: Whether to use a calendar popup for selecting the date.
    calendar_popup = d_(Bool(False))

    #: A datetime selector expands freely in width by default
    hug_width = set_default('ignore')

    #: A reference to the ProxyDateSelector object.
    proxy = Typed(ProxyDatetimeSelector)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('datetime_format', 'calendar_popup')
    def _update_proxy(self, change):
        """ An observer which updates the proxy with state change.

        """
        # The superclass implementation is sufficient.
        super(DatetimeSelector, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = date_selector
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Str, Typed, ForwardTyped, observe, set_default

from enaml.core.declarative import d_

from .bounded_date import BoundedDate, ProxyBoundedDate


class ProxyDateSelector(ProxyBoundedDate):
    """ The abstract defintion of a proxy DateSelector object.

    """
    #: A reference to the DateSelector declaration.
    declaration = ForwardTyped(lambda: DateSelector)

    def set_date_format(self, format):
        raise NotImplementedError

    def set_calendar_popup(self, popup):
        raise NotImplementedError


class DateSelector(BoundedDate):
    """ A widget to edit a Python datetime.date object.

    A DateSelector displays a Python datetime.date using an appropriate
    toolkit specific control. This is a geometrically smaller control
    than what is provided by Calendar.

    """
    #: A python date format string to format the date for display. If
    #: If none is supplied (or is invalid) the system locale setting
    #: is used. This may not be supported by all backends.
    date_format = d_(Str())

    #: Whether to use a calendar popup for selecting the date.
    calendar_popup = d_(Bool(False))

    #: A date selector expands freely in width by default.
    hug_width = set_default('ignore')

    #: A reference to the ProxyDateSelector object.
    proxy = Typed(ProxyDateSelector)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('date_format', 'calendar_popup')
    def _update_proxy(self, change):
        """ An observer which updates the proxy with state change.

        """
        # The superclass implementation is sufficient.
        super(DateSelector, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = dialog
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Event, Typed, ForwardTyped, set_default

from enaml.core.declarative import d_

from .window import Window, ProxyWindow


class ProxyDialog(ProxyWindow):
    """ The abstract definition of a proxy Dialog object.

    """
    #: A reference to the Dialog declaration.
    declaration = ForwardTyped(lambda: Dialog)

    def exec_(self):
        raise NotImplementedError

    def done(self, result):
        raise NotImplementedError


class Dialog(Window):
    """ A top-level Window class for creating dialogs.

    """
    #: The result of the dialog. This value is updated before any of
    #: the related dialog events are fired.
    result = d_(Bool(False), writable=False)

    #: An event fired when the dialog is finished. The payload will be
    #: the boolean result of the dialog. This event is fired before
    #: the 'accepted' or rejected event.
    finished = d_(Event(bool), writable=False)

    #: An event fired when the dialog is accepted.
    accepted = d_(Event(), writable=False)

    #: An event fired when the dialog is rejected.
    rejected = d_(Event(), writable=False)

    #: Dialogs are application modal by default.
    modality = set_default('application_modal')

    #: A reference to the ProxyDialog object.
    proxy = Typed(ProxyDialog)

    def exec_(self):
        """ Launch the dialog as a modal window.

        This call will block until the dialog is closed.

        Returns
        -------
        result : bool
            The result value of the dialog.

        """
        if not self.is_initialized:
            self.initialize()
        if not self.proxy_is_active:
            self.activate_proxy()
        return self.proxy.exec_()

    def done(self, result):
        """ Close the dialog and set the result value.

        This will cause a call to `exec_` to return.

        Parameters
        ----------
        result : bool
            The result value for the dialog.

        """
        if self.proxy_is_active:
            self.proxy.done(result)

    def accept(self):
        """ Close the dialog and set the result to True.

        """
        self.done(True)

    def reject(self):
        """ Close the dialog and set the result to False.

        """
        self.done(False)

########NEW FILE########
__FILENAME__ = dock_area
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from contextlib import contextmanager

from atom.api import (
    Bool, Coerced, Enum, Typed, ForwardTyped, Unicode, Event, observe,
    set_default
)

from enaml.core.declarative import d_
from enaml.layout.dock_layout import DockLayout, DockLayoutOp
from enaml.styling import StyleSheet

from .constraints_widget import ConstraintsWidget, ProxyConstraintsWidget
from .dock_events import DockEvent
from .dock_item import DockItem


_dock_area_styles = None
def get_registered_styles(name):
    # lazy import the stdlib module in case it's never needed.
    global _dock_area_styles
    if _dock_area_styles is None:
        import enaml
        with enaml.imports():
            from enaml.stdlib import dock_area_styles
        _dock_area_styles = dock_area_styles
    return _dock_area_styles.get_registered_styles(name)


class ProxyDockArea(ProxyConstraintsWidget):
    """ The abstract definition of a proxy DockArea object.

    """
    #: A reference to the Stack declaration.
    declaration = ForwardTyped(lambda: DockArea)

    def set_tab_position(self, position):
        raise NotImplementedError

    def set_live_drag(self, live_drag):
        raise NotImplementedError

    def set_style(self, style):
        raise NotImplementedError

    def set_dock_events_enabled(self, enabled):
        raise NotImplementedError

    def save_layout(self):
        raise NotImplementedError

    def apply_layout(self, layout):
        raise NotImplementedError

    def update_layout(self, ops):
        raise NotImplementedError


class DockArea(ConstraintsWidget):
    """ A component which arranges dock item children.

    """
    #: The layout of dock items for the area. This attribute is *not*
    #: kept in sync with the layout state of the widget at runtime. The
    #: 'save_layout' method should be called to retrieve the current
    #: layout state.
    layout = d_(Coerced(DockLayout, ()))

    #: The default tab position for newly created dock tabs.
    tab_position = d_(Enum('top', 'bottom', 'left', 'right'))

    #: Whether the dock items resize as a dock splitter is being dragged
    #: (True), or if a simple indicator is drawn until the drag handle
    #: is released (False). The default is True.
    live_drag = d_(Bool(True))

    #: The name of the registered style to apply to the dock area. The
    #: list of available styles can be retrieved by calling the function
    #: `available_styles` in the `enaml.stdlib.dock_area_styles` module.
    #: The default is a style inspired by Visual Studio 2010
    #:
    #: Users can also define and use their own custom style sheets with
    #: the dock area. Simply set this attribute to an empty string so
    #: the default styling is disabled, and proceed to use style sheets
    #: as with any other widget (see the stdlib styles for inspiration).
    #:
    #: Only one mode of styling should be used for the dock area at a
    #: time. Using both modes simultaneously is undefined.
    style = d_(Unicode('vs-2010'))

    #: Whether or not dock events are enabled for the area.
    dock_events_enabled = d_(Bool(False))

    #: An event emitted when a dock event occurs in the dock area.
    #: `dock_events_enabled` must be True in order to recieve events.
    dock_event = d_(Event(DockEvent), writable=False)

    #: A Stack expands freely in height and width by default
    hug_width = set_default('ignore')
    hug_height = set_default('ignore')

    #: A reference to the ProxyStack widget.
    proxy = Typed(ProxyDockArea)

    #: The style sheet created from the 'style' attribute.
    _internal_style = Typed(StyleSheet)

    def initialized(self):
        """ A reimplemented initializer method.

        This method ensures the internal style sheet is created.

        """
        super(DockArea, self).initialized()
        self._refresh_internal_style()

    def dock_items(self):
        """ Get the dock items defined on the stack

        """
        return [c for c in self.children if isinstance(c, DockItem)]

    def save_layout(self):
        """ Save the current layout state of the dock area.

        Returns
        -------
        result : docklayout
            The current layout state of the dock area.

        """
        if self.proxy_is_active:
            return self.proxy.save_layout()
        return self.layout

    def apply_layout(self, layout):
        """ Apply a new layout to the dock area.

        Parameters
        ----------
        layout : DockLayout
            The dock layout to apply to the dock area.

        """
        assert isinstance(layout, DockLayout), 'layout must be a DockLayout'
        if self.proxy_is_active:
            return self.proxy.apply_layout(layout)

    def update_layout(self, ops):
        """ Update the layout configuration using layout operations.

        Parameters
        ----------
        ops : DockLayoutOp or iterable
            A single DockLayoutOp instance or an iterable of the same.
            The operations will be executed in order. If a given op is
            not valid for the current layout state, it will be skipped.

        """
        if isinstance(ops, DockLayoutOp):
            ops = [ops]
        for op in ops:
            assert isinstance(op, DockLayoutOp)
        if self.proxy_is_active:
            self.proxy.update_layout(ops)

    @contextmanager
    def suppress_dock_events(self):
        """ A context manager which supresses dock events.

        This manager will disable dock events for the duration of the
        context, and restore the old value upon exit.

        """
        enabled = self.dock_events_enabled
        self.dock_events_enabled = False
        yield
        self.dock_events_enabled = enabled

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('style')
    def _update_style(self, change):
        """ An observer which updates the internal style sheet.

        """
        change_t = change['type']
        if change_t == 'update' or change_t == 'delete':
            self._refresh_internal_style()

    @observe('layout')
    def _update_layout(self, change):
        """ An observer which updates the layout when it changes.

        """
        if change['type'] == 'update':
            self.apply_layout(change['value'])

    @observe('tab_position', 'live_drag', 'style', 'dock_events_enabled')
    def _update_proxy(self, change):
        """ Update the proxy when the area state changes.

        """
        # The superclass implementation is sufficient.
        super(DockArea, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _refresh_internal_style(self):
        old = self._internal_style
        if old is not None:
            old.destroy()
            self._internal_style = None
        if self.style:
            style_t = get_registered_styles(self.style)
            if style_t is not None:
                sheet = StyleSheet()
                style_t()(sheet)
                self._internal_style = sheet
                sheet.set_parent(self)

########NEW FILE########
__FILENAME__ = dock_events
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, IntEnum, Typed, Unicode


class DockEvent(Atom):
    """ A sentinel base class for events which occur in a dock area.

    """
    pass


class DockItemEvent(DockEvent):
    """ A DockEvent for events which involve a single dock item.

    """
    class Type(IntEnum):
        """ An IntEnum which defines the dock item event types.

        """
        #: The dock item was docked in a dock area.
        Docked = 0

        #: The dock item was undocked from a dock area.
        Undocked = 1

        #: The dock item was extended from a dock bar.
        Extended = 2

        #: The dock item was retracted into a dock bar.
        Retracted = 3

        #: The dock item was shown on the screen.
        Shown = 4

        #: The dock item was hidden from the screen.
        Hidden = 5

        #: The dock item was closed.
        Closed = 6

        #: The dock item became the selected tab in a tab group.
        TabSelected = 7

    # Proxy out the enum values for simpler access.
    Docked = Type.Docked
    Undocked = Type.Undocked
    Extended = Type.Extended
    Retracted = Type.Retracted
    Shown = Type.Shown
    Hidden = Type.Hidden
    Closed = Type.Closed
    TabSelected = Type.TabSelected

    #: The type of the dock item event.
    type = Typed(Type)

    #: The name of the relevant dock item.
    name = Unicode()

########NEW FILE########
__FILENAME__ = dock_item
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import (
    Coerced, Event, Unicode, Bool, Range, Typed, ForwardTyped, observe
)

from enaml.application import deferred_call
from enaml.core.declarative import d_
from enaml.icon import Icon
from enaml.layout.geometry import Size

from .container import Container
from .widget import Widget, ProxyWidget


class ProxyDockItem(ProxyWidget):
    """ The abstract definition of a proxy DockItem object.

    """
    #: A reference to the DockItem declaration.
    declaration = ForwardTyped(lambda: DockItem)

    def set_title(self, title):
        raise NotImplementedError

    def set_title_editable(self, editable):
        raise NotImplementedError

    def set_title_bar_visible(self, visible):
        raise NotImplementedError

    def set_icon(self, icon):
        raise NotImplementedError

    def set_icon_size(self, size):
        raise NotImplementedError

    def set_stretch(self, stretch):
        raise NotImplementedError

    def set_closable(self, closable):
        raise NotImplementedError

    def alert(self, level, on, off, repeat, persist):
        raise NotImplementedError


class DockItem(Widget):
    """ A widget which can be docked in a DockArea.

    A DockItem is a widget which can be docked inside of a DockArea. It
    can have at most a single Container child widget.

    """
    #: The title to use in the title bar.
    title = d_(Unicode())

    #: Whether or the not the title is user editable.
    title_editable = d_(Bool(False))

    #: Whether or not the title bar is visible.
    title_bar_visible = d_(Bool(True))

    #: The icon to use in the title bar.
    icon = d_(Typed(Icon))

    #: The size to use for the icon in the title bar.
    icon_size = d_(Coerced(Size, (-1, -1)))

    #: The stretch factor for the item when docked in a splitter.
    stretch = d_(Range(low=0, value=1))

    #: Whether or not the dock item is closable via a close button.
    closable = d_(Bool(True))

    #: An event emitted when the title bar is right clicked.
    title_bar_right_clicked = d_(Event(), writable=False)

    #: An event emitted when the dock item is closed. The item will be
    #: destroyed after this event has completed.
    closed = d_(Event(), writable=False)

    #: A reference to the ProxyDockItem object.
    proxy = Typed(ProxyDockItem)

    def dock_widget(self):
        """ Get the dock widget defined for the dock pane.

        The last child Container is considered the dock widget.

        """
        for child in reversed(self.children):
            if isinstance(child, Container):
                return child

    def alert(self, level, on=250, off=250, repeat=4, persist=False):
        """ Set the alert level on the dock item.

        This will override any currently applied alert level.

        Parameters
        ----------
        level : unicode
            The alert level token to apply to the dock item.

        on : int
            The duration of the 'on' cycle, in ms. A value of -1 means
            always on.

        off : int
            The duration of the 'off' cycle, in ms. If 'on' is -1, this
            value is ignored.

        repeat : int
            The number of times to repeat the on-off cycle. If 'on' is
            -1, this value is ignored.

        persist : bool
            Whether to leave the alert in the 'on' state when the cycles
            finish. If 'on' is -1, this value is ignored.

        """
        if self.proxy_is_active:
            self.proxy.alert(level, on, off, repeat, persist)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('title', 'title_editable', 'title_bar_visible', 'icon',
        'icon_size', 'stretch', 'closable')
    def _update_proxy(self, change):
        """ Update the proxy when the item state changes.

        """
        # The superclass implementation is sufficient.
        super(DockItem, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _item_closed(self):
        """ Called by the proxy when the toolkit item is closed.

        """
        # TODO allow the user to veto the close request
        self.closed()
        deferred_call(self.destroy)

########NEW FILE########
__FILENAME__ = dock_pane
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import (
    List, Enum, Unicode, Bool, Event, Typed, ForwardTyped, observe
)

from enaml.core.declarative import d_

from .container import Container
from .widget import Widget, ProxyWidget


class ProxyDockPane(ProxyWidget):
    """ The abstract definition of a proxy DockPane object.

    """
    #: A reference to the DockPane declaration.
    declaration = ForwardTyped(lambda: DockPane)

    def set_title(self, title):
        raise NotImplementedError

    def set_title_bar_visible(self, visible):
        raise NotImplementedError

    def set_title_bar_orientation(self, orientation):
        raise NotImplementedError

    def set_closable(self, closable):
        raise NotImplementedError

    def set_movable(self, movable):
        raise NotImplementedError

    def set_floatable(self, floatable):
        raise NotImplementedError

    def set_floating(self, floating):
        raise NotImplementedError

    def set_dock_area(self, area):
        raise NotImplementedError

    def set_allowed_dock_areas(self, areas):
        raise NotImplementedError


class DockPane(Widget):
    """ A widget which can be docked in a MainWindow.

    A DockPane is a widget which can be docked in designated dock areas
    in a MainWindow. It can have at most a single child widget which is
    an instance of Container.

    """
    #: The title to use in the title bar.
    title = d_(Unicode())

    #: Whether or not the title bar is visible.
    title_bar_visible = d_(Bool(True))

    #: The orientation of the title bar.
    title_bar_orientation = d_(Enum('horizontal', 'vertical'))

    #: Whether or not the dock pane is closable via a close button.
    closable = d_(Bool(True))

    #: Whether or not the dock pane is movable by the user.
    movable = d_(Bool(True))

    #: Whether or not the dock can be floated as a separate window.
    floatable = d_(Bool(True))

    #: A boolean indicating whether or not the dock pane is floating.
    floating = d_(Bool(False))

    #: The dock area in the MainWindow where the pane is docked.
    dock_area = d_(Enum('left', 'right', 'top', 'bottom'))

    #: The dock areas in the MainWindow where the pane can be docked
    #: by the user. Note that this does not preclude the pane from
    #: being docked programmatically via the 'dock_area' attribute.
    allowed_dock_areas = d_(List(
        Enum('left', 'right', 'top', 'bottom', 'all'), ['all'],
    ))

    #: An event fired when the user closes the pane by clicking on the
    #: dock pane's close button.
    closed = d_(Event(), writable=False)

    #: A reference to the ProxyDockPane object.
    proxy = Typed(ProxyDockPane)

    def dock_widget(self):
        """ Get the dock widget defined for the dock pane.

        The last child Container is considered the dock widget.

        """
        for child in reversed(self.children):
            if isinstance(child, Container):
                return child

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('title', 'title_bar_visible', 'title_bar_orientation', 'closable',
        'movable', 'floatable', 'floating', 'dock_area', 'allowed_dock_areas')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(DockPane, self)._update_proxy(change)

    # TODO spend some time thinking about the open/close api
    # I would rather everything be consistent, which likely
    # means destroy-on-close behavior should be the norm.
    def open(self):
        #msg = "The 'open()' method will be removed in Enaml version "
        #msg += "0.8.0. Use 'show()' instead."
        #import warnings
        #warnings.warn(msg, FutureWarning, stacklevel=2)
        self.show()

    def close(self):
        #msg = "The 'close()' method will be removed in Enaml version "
        #msg += "0.8.0. Use 'hide()' instead."
        #import warnings
        #warnings.warn(msg, FutureWarning, stacklevel=2)
        self.hide()

########NEW FILE########
__FILENAME__ = dual_slider
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Enum, Int, Range, Typed, ForwardTyped, observe

from enaml.core.declarative import d_

from .control import Control, ProxyControl


#: The base tick position enum defintion.
TickPosition = Enum('no_ticks', 'left', 'right', 'top', 'bottom', 'both')


class ProxyDualSlider(ProxyControl):
    """ The abstract definition of a proxy Slider object.

    """
    #: A reference to the Slider declaration.
    declaration = ForwardTyped(lambda: DualSlider)

    def set_minimum(self, minimum):
        raise NotImplementedError

    def set_maximum(self, maximum):
        raise NotImplementedError

    def set_low_value(self, value):
        raise NotImplementedError

    def set_high_value(self, value):
        raise NotImplementedError

    def set_tick_position(self, position):
        raise NotImplementedError

    def set_tick_interval(self, interval):
        raise NotImplementedError

    def set_orientation(self, orientation):
        raise NotImplementedError

    # def set_tracking(self, tracking):
    #     raise NotImplementedError


class DualSlider(Control):
    """ A simple dual slider widget.

    A dual slider can be used to select a range within a larger range
    of integral values.

    """
    #: The minimum slider value. If the minimum value is changed such
    #: that it becomes greater than the current value or the maximum
    #: value, then those values will be adjusted. The default is 0.
    minimum = d_(Int(0))

    #: The maximum slider value. If the maximum value is changed such
    #: that it becomes smaller than the current value or the minimum
    #: value, then those values will be adjusted. The default is 100.
    maximum = d_(Int(100))

    #: The low position value of the DualSlider. The value will be
    #: clipped to always fall between the minimum and maximum and be
    #: smaller than the high value.
    low_value = d_(Int())

    #: The high position value of the DualSlider. The value will be
    #: clipped to always fall between the minimum and maximum and be
    #: larger than the low value.
    high_value = d_(Int())

    #: A TickPosition enum value indicating how to display the tick
    #: marks. Note that the orientation takes precedence over the tick
    #: mark position and an incompatible tick position will be adapted
    #: according to the current orientation. The default tick position
    #: is 'bottom'.
    tick_position = d_(TickPosition('bottom'))

    #: The interval to place between slider tick marks in value units
    #: (as opposed to pixels). The minimum value is 0, which indicates
    #: that the choice is left up to the client.
    tick_interval = d_(Range(low=0))

    #: The orientation of the slider. The default is 'horizontal'. When
    #: the orientation is flipped the tick positions (if set) also adapt
    #: to reflect the changes  (e.g. the LEFT becomes TOP when the
    #: orientation becomes horizontal).
    orientation = d_(Enum('horizontal', 'vertical'))

    #: If True, the value is updated while sliding. Otherwise, it is
    #: only updated when the slider is released. Defaults to True.
    #tracking = d_(Bool(True))

    #: Whether or not to automatically adjust the 'hug_width' and
    #: 'hug_height' values based on the value of 'orientation'.
    auto_hug = Bool(True)

    #: A reference to the ProxyDualSlider object.
    proxy = Typed(ProxyDualSlider)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('minimum', 'maximum', 'low_value', 'high_value', 'tick_position',
        'tick_interval', 'orientation', 'tracking')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(DualSlider, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # DefaultValue Handlers
    #--------------------------------------------------------------------------
    def _default_hug_width(self):
        """ Get the default hug width for the slider.

        The default hug width is computed based on the orientation.

        """
        if self.orientation == 'horizontal':
            return 'ignore'
        return 'strong'

    def _default_hug_height(self):
        """ Get the default hug height for the slider.

        The default hug height is computed based on the orientation.

        """
        if self.orientation == 'vertical':
            return 'ignore'
        return 'strong'

    def _default_low_value(self):
        """ Get the default low value for the slider

        The default low value is the minimum of the slider.

        """
        return self.minimum

    def _default_high_value(self):
        """ Get the default high value for the slider

        The default high value is the maximum of the slider.

        """
        return self.maximum

    #--------------------------------------------------------------------------
    # PostSetAttr Handlers
    #--------------------------------------------------------------------------
    def _post_setattr_orientation(self, old, new):
        """ Post setattr the orientation for the slider.

        If auto hug is enabled, the hug values will be updated.

        """
        if self.auto_hug:
            if new == 'vertical':
                self.hug_width = 'strong'
                self.hug_height = 'ignore'
            else:
                self.hug_width = 'ignore'
                self.hug_height = 'strong'

    def _post_setattr_minimum(self, old, new):
        """ Post setattr the minimum value for the slider.

        If the new minimum is greater than the current value or maximum,
        those values are adjusted up.

        """
        if new > self.maximum:
            self.maximum = new
        if new > self.high_value:
            self.high_value = new
        if new > self.low_value:
            self.low_value = new

    def _post_setattr_maximum(self, old, new):
        """ Post setattr the maximum value for the slider.

        If the new maximum is less than the current value or the minimum,
        those values are adjusted down.

        """
        if new < self.minimum:
            self.minimum = new
        if new < self.low_value:
            self.low_value = new
        if new < self.high_value:
            self.high_value = new

    #--------------------------------------------------------------------------
    # Post Validation Handlers
    #--------------------------------------------------------------------------
    def _post_validate_low_value(self, old, new):
        """ Post validate the low_value for the slider.

        The low_value is clipped to minimum and high_value bounds.

        """
        return max(self.minimum, min(new, self.maximum))

    def _post_validate_high_value(self, old, new):
        """ Post validate the high_value for the slider.

        The high_value is clipped to low_value and maximum bounds.

        """
        return max(self.minimum, min(new, self.maximum))

########NEW FILE########
__FILENAME__ = field
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import (
    Bool, Int, Unicode, Enum, List, Typed, ForwardTyped, observe, set_default
)

from enaml.core.declarative import d_
from enaml.validator import Validator

from .control import Control, ProxyControl


class ProxyField(ProxyControl):
    """ The abstract definition of a proxy Field object.

    """
    #: A reference to the Field declaration.
    declaration = ForwardTyped(lambda: Field)

    def set_text(self, text):
        raise NotImplementedError

    def set_mask(self, mask):
        raise NotImplementedError

    def set_submit_triggers(self, triggers):
        raise NotImplementedError

    def set_placeholder(self, placeholder):
        raise NotImplementedError

    def set_echo_mode(self, mode):
        raise NotImplementedError

    def set_max_length(self, length):
        raise NotImplementedError

    def set_read_only(self, read_only):
        raise NotImplementedError

    def field_text(self):
        raise NotImplementedError


class Field(Control):
    """ A single line editable text widget.

    """
    #: The unicode text to display in the field.
    text = d_(Unicode())

    #: The mask to use for text input:
    #:  http://qt-project.org/doc/qt-4.8/qlineedit.html#inputMask-prop
    #:
    #: The summary of the mask grammar is as follows:
    #: A   ASCII alphabetic character required. A-Z, a-z.
    #: a   ASCII alphabetic character permitted but not required.
    #: N   ASCII alphanumeric character required. A-Z, a-z, 0-9.
    #: n   ASCII alphanumeric character permitted but not required.
    #: X   Any character required.
    #: x   Any character permitted but not required.
    #: 9   ASCII digit required. 0-9.
    #: 0   ASCII digit permitted but not required.
    #: D   ASCII digit required. 1-9.
    #: d   ASCII digit permitted but not required (1-9).
    #: #   ASCII digit or plus/minus sign permitted but not required.
    #: H   Hexadecimal character required. A-F, a-f, 0-9.
    #: h   Hexadecimal character permitted but not required.
    #: B   Binary character required. 0-1.
    #: b   Binary character permitted but not required.
    #: >   All following alphabetic characters are uppercased.
    #: <   All following alphabetic characters are lowercased.
    #: !   Switch off case conversion.
    #: \   Use \ to escape the special characters listed above to use them as separators.
    #:
    #: The mask consists of a string of mask characters and separators, optionally
    #: followed by a semicolon and the character used for blanks
    #: Eg: 9 digit phone number: (999) 999-9999;_
    mask = d_(Unicode())

    #: The validator to use for this field. If the validator provides
    #: a client side validator, then text will only be submitted if it
    #: passes that validator.
    validator = d_(Typed(Validator))

    #: The list of actions which should cause the client to submit its
    #: text to the server for validation and update. The currently
    #: supported values are 'lost_focus', 'return_pressed', and 'auto'.
    #: The 'auto_sync' mode will attempt to validate and synchronize the
    #: text when the user stops typing.
    submit_triggers = d_(List(
        Enum('lost_focus', 'return_pressed', 'auto_sync'),
        ['lost_focus', 'return_pressed']
    ))

    #: The grayed-out text to display if the field is empty and the
    #: widget doesn't have focus. Defaults to the empty string.
    placeholder = d_(Unicode())

    #: How to display the text in the field. Valid values are 'normal'
    #: which displays the text as normal, 'password' which displays the
    #: text with an obscured character, and 'silent' which displays no
    #: text at all but still allows input.
    echo_mode = d_(Enum('normal', 'password', 'silent'))

    #: The maximum length of the field in characters. The default value
    #: is Zero and indicates there is no maximum length.
    max_length = d_(Int(0))

    #: Whether or not the field is read only. Defaults to False.
    read_only = d_(Bool(False))

    #: How strongly a component hugs it's contents' width. Fields ignore
    #: the width hug by default, so they expand freely in width.
    hug_width = set_default('ignore')

    #: A reference to the ProxyField object.
    proxy = Typed(ProxyField)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('text', 'mask', 'submit_triggers', 'placeholder', 'echo_mode',
        'max_length', 'read_only')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass implementation is sufficient.
        super(Field, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def field_text(self):
        """ Get the text stored in the field control.

        Depending on the state of the field, this text may be different
        than that stored in the 'text' attribute.

        Returns
        -------
        result : unicode
            The unicode text stored in the field.

        """
        if self.proxy_is_active:
            return self.proxy.field_text()
        return u''

########NEW FILE########
__FILENAME__ = file_dialog
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import (
    Enum, Bool, Callable, List, Unicode, Typed, ForwardTyped, Event
)

from enaml.application import deferred_call
from enaml.core.declarative import d_
from .toolkit_object import ToolkitObject, ProxyToolkitObject


class ProxyFileDialog(ProxyToolkitObject):
    """ The abstract defintion of a proxy FileDialog object.

    """
    #: A reference to the FileDialog declaration.
    declaration = ForwardTyped(lambda: FileDialog)

    def open(self):
        raise NotImplementedError

    def exec_(self):
        raise NotImplementedError


class FileDialog(ToolkitObject):
    """ A dialog widget that allows the user to open and save files and
    directories.

    """
    #: The title to use for the dialog.
    title = d_(Unicode())

    #: The mode of the dialog.
    mode = d_(Enum('open_file', 'open_files', 'save_file', 'directory'))

    #: The selected path in the dialog. This value will be used to set
    #: the initial working directory and file, as appropriate, when the
    #: dialog is opened. It will aslo be updated when the dialog is
    #: closed and accepted.
    path = d_(Unicode())

    #: The list of selected paths in the dialog. It will be updated
    #: when the dialog is closed and accepted. It is output only and
    #: is only applicable for the `open_files` mode.
    paths = List(Unicode())

    #: The string filters used to restrict the user's selections.
    filters = d_(List(Unicode()))

    #: The selected filter from the list of filters. This value will be
    #: used as the initial working filter when the dialog is opened. It
    #: will also be updated when the dialog is closed and accepted.
    selected_filter = d_(Unicode())

    #: Whether to use a platform native dialog, when available. This
    #: attribute is deprecated and no longer has any effect. Native
    #: dialogs are always used when available in a given toolkit.
    native_dialog = d_(Bool(True))

    #: An enum indicating if the dialog was accepted or rejected by
    #: the user. It will be updated when the dialog is closed. This
    #: value is output only.
    result = Enum('rejected', 'accepted')

    #: An optional callback which will be invoked when the dialog is
    #: closed. This is a convenience to make it easier to handle a
    #: dialog opened in non-blocking mode. The callback must accept
    #: a single argument, which will be the dialog instance.
    callback = d_(Callable())

    #: An event fired if the dialog is accepted. The payload will be
    #: the selected path.
    accepted = d_(Event(unicode), writable=False)

    #: An event fired when the dialog is rejected. It has no payload.
    rejected = d_(Event(), writable=False)

    #: An event fired when the dialog is closed. It has no payload.
    closed = d_(Event(), writable=False)

    #: Whether to destroy the dialog widget on close. The default is
    #: True since dialogs are typically used in a transitory fashion.
    destroy_on_close = d_(Bool(True))

    #: A reference to the ProxyFileDialog object.
    proxy = Typed(ProxyFileDialog)

    def open(self):
        """ Open the dialog in a non-blocking fashion.

        This method will always return None. The state of the dialog
        will be updated when the dialog is closed by the user.

        """
        if not self.is_initialized:
            self.initialize()
        self.proxy.open()

    def exec_(self):
        """ Open the dialog in a blocking fashion.

        Returns
        -------
        result : unicode
            The path selected by the user, or an empty string if the
            dialog is cancelled.

        """
        if not self.is_initialized:
            self.initialize()
        self.proxy.exec_()
        if self.result == 'accepted':
            return self.path
        return u''

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def _handle_close(self, result, paths, selected_filter):
        """ Called by the proxy object when the dialog is closed.

        Parameters
        ----------
        result : string
            The result of the dialog; either 'accepted' or 'rejected'.

        paths : list
            The list of user selected paths. If the result is 'rejected'
            this should be an empty list.

        selected_filter : unicode
            The user selected name filter. If the result is 'rejected'
            this should be an empty string.

        """
        self.result = result
        if result == 'accepted':
            self.paths = paths
            self.path = paths[0] if paths else u''
            self.selected_filter = selected_filter
            self.accepted(self.path)
        else:
            self.rejected()
        if self.callback:
            self.callback(self)
        self.closed()
        if self.destroy_on_close:
            deferred_call(self.destroy)

########NEW FILE########
__FILENAME__ = file_dialog_ex
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Enum, List, Unicode, Typed, ForwardTyped, observe

from enaml.core.declarative import d_

from .toolkit_dialog import ToolkitDialog, ProxyToolkitDialog


class ProxyFileDialogEx(ProxyToolkitDialog):
    """ The abstract defintion of a proxy FileDialogEx object.

    """
    #: A reference to the FileDialog declaration.
    declaration = ForwardTyped(lambda: FileDialogEx)

    def set_accept_mode(self, accept_mode):
        raise NotImplementedError

    def set_file_mode(self, file_mode):
        raise NotImplementedError

    def set_show_dirs_only(self, show):
        raise NotImplementedError

    def set_current_path(self, path):
        raise NotImplementedError

    def set_name_filters(self, filters):
        raise NotImplementedError

    def set_selected_name_filter(self, selected):
        raise NotImplementedError

    def exec_native(self):
        raise NotImplementedError


class FileDialogEx(ToolkitDialog):
    """ A toolkit dialog for getting file and directory names.

    This dialog supercedes the FileDialog class. New code you should
    use this dialog in lieu of the older version.

    """
    #: The accept mode of the dialog.
    accept_mode = d_(Enum('open', 'save'))

    #: The file mode of the dialog.
    file_mode = d_(Enum(
        'any_file', 'existing_file', 'existing_files', 'directory'))

    #: Whether or not to only show directories. This is only valid when
    #: the file_mode is set to 'directory'.
    show_dirs_only = d_(Bool(False))

    #: The currently selected path in the dialog.
    current_path = d_(Unicode())

    #: The paths selected by the user when the dialog is accepted.
    #: This value is output only.
    selected_paths = List(Unicode())

    #: The name filters used to restrict the available files.
    name_filters = d_(List(Unicode()))

    #: The selected name filter from the list of name filters.
    selected_name_filter = d_(Unicode())

    #: A reference to the ProxyFileDialog object.
    proxy = Typed(ProxyFileDialogEx)

    @staticmethod
    def get_existing_directory(parent=None, **kwargs):
        """ Get an existing directory on the filesystem.

        Parameters
        ----------
        parent : ToolkitObject or None
            The parent toolkit object for this dialog.

        **kwargs
            Additional data to pass to the dialog constructor.

        Returns
        -------
        result : unicode
            The user selected directory path. This will be an empty
            string if no directory was selected.

        """
        kwargs['accept_mode'] = 'open'
        kwargs['file_mode'] = 'directory'
        kwargs['show_dirs_only'] = True
        dialog = FileDialogEx(parent, **kwargs)
        if dialog.exec_native():
            if dialog.selected_paths:
                return dialog.selected_paths[0]
        return u''

    @staticmethod
    def get_open_file_name(parent=None, **kwargs):
        """ Get the file name for an open file dialog.

        Parameters
        ----------
        parent : ToolkitObject or None
            The parent toolkit object for this dialog.

        **kwargs
            Additional data to pass to the dialog constructor.

        Returns
        -------
        result : unicode
            The user selected file name. This will be an empty
            string if no file name was selected.

        """
        kwargs['accept_mode'] = 'open'
        kwargs['file_mode'] = 'existing_file'
        dialog = FileDialogEx(parent, **kwargs)
        if dialog.exec_native():
            if dialog.selected_paths:
                return dialog.selected_paths[0]
        return u''

    @staticmethod
    def get_open_file_names(parent=None, **kwargs):
        """ Get the file names for an open files dialog.

        Parameters
        ----------
        parent : ToolkitObject or None
            The parent toolkit object for this dialog.

        **kwargs
            Additional data to pass to the dialog constructor.

        Returns
        -------
        result : list
            The user selected file names. This will be an empty
            list if no file names were selected.

        """
        kwargs['accept_mode'] = 'open'
        kwargs['file_mode'] = 'existing_files'
        dialog = FileDialogEx(parent, **kwargs)
        if dialog.exec_native():
            return dialog.selected_paths
        return []

    @staticmethod
    def get_save_file_name(parent=None, **kwargs):
        """ Get the file name for a save file dialog.

        Parameters
        ----------
        parent : ToolkitObject or None
            The parent toolkit object for this dialog.

        **kwargs
            Additional data to pass to the dialog constructor.

        Returns
        -------
        result : unicode
            The user selected file name. This will be an empty
            string if no file name was selected.

        """
        kwargs['accept_mode'] = 'save'
        kwargs['file_mode'] = 'any_file'
        dialog = FileDialogEx(parent, **kwargs)
        if dialog.exec_native():
            if dialog.selected_paths:
                return dialog.selected_paths[0]
        return u''

    def exec_native(self):
        """ Open the dialog using a native OS dialog if available.

        Returns
        -------
        result : bool
            Whether or not the dialog was accepted.

        """
        if not self.is_initialized:
            self.initialize()
        if not self.proxy_is_active:
            self.activate_proxy()
        self._prepare()
        self.proxy.exec_native()
        return self.result

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('accept_mode', 'file_mode', 'show_dirs_only', 'current_path',
        'name_filters', 'selected_name_filter')
    def _update_proxy(self, change):
        """ An observer which updates the proxy when the data changes.

        """
        # The superclass implementation is sufficient.
        super(FileDialogEx, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def _prepare(self):
        """ A reimplemented preparation method.

        This method resets the selected paths and filters.

        """
        super(FileDialogEx, self)._prepare()
        self.selected_paths = []
        self.selected_name_filter = u''

########NEW FILE########
__FILENAME__ = flow_area
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import (
    Enum, Range, Coerced, Typed, ForwardTyped, observe, set_default
)

from enaml.core.declarative import d_
from enaml.layout.geometry import Box

from .frame import Frame, ProxyFrame, Border
from .flow_item import FlowItem


class ProxyFlowArea(ProxyFrame):
    """ The abstract definition of a proxy FlowArea object.

    """
    #: A reference to the FlowArea declaration.
    declaration = ForwardTyped(lambda: FlowArea)

    def set_direction(self, direction):
        raise NotImplementedError

    def set_align(self, align):
        raise NotImplementedError

    def set_horizontal_spacing(self, spacing):
        raise NotImplementedError

    def set_vertical_spacing(self, spacing):
        raise NotImplementedError

    def set_margins(self, margins):
        raise NotImplementedError


class FlowArea(Frame):
    """ A widget which lays out its children in flowing manner, wrapping
    around at the end of the available space.

    """
    #: The flow direction of the layout.
    direction = d_(Enum(
        'left_to_right', 'right_to_left', 'top_to_bottom', 'bottom_to_top'
    ))

    #: The alignment of a line of items within the layout.
    align = d_(Enum('leading', 'trailing', 'center', 'justify'))

    #: The amount of horizontal space to place between items.
    horizontal_spacing = d_(Range(low=0, value=10))

    #: The amount of vertical space to place between items.
    vertical_spacing = d_(Range(low=0, value=10))

    #: The margins to use around the outside of the flow area.
    margins = d_(Coerced(Box, (10, 10, 10, 10)))

    #: A FlowArea expands freely in width and height by default.
    hug_width = set_default('ignore')
    hug_height = set_default('ignore')

    #: A reference to the ProxyFlowArea object.
    proxy = Typed(ProxyFlowArea)

    def flow_items(self):
        """ Get the flow item children defined on this area.

        """
        return [c for c in self.children if isinstance(c, FlowItem)]

    #--------------------------------------------------------------------------
    # Default Handlers
    #--------------------------------------------------------------------------
    def _default_border(self):
        """ Get the default border for the flow area.

        The default value matches the default for Qt's QScrollArea.

        """
        return Border(style='styled_panel', line_style='sunken')

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('direction', 'align', 'horizontal_spacing', 'vertical_spacing',
        'margins')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(FlowArea, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = flow_item
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Enum, Range, Coerced, Typed, ForwardTyped, observe

from enaml.core.declarative import d_
from enaml.layout.geometry import Size

from .container import Container
from .widget import Widget, ProxyWidget


class ProxyFlowItem(ProxyWidget):
    """ The abstract definition of a proxy FlowItem object.

    """
    #: A reference to the FlowItem declaration.
    declaration = ForwardTyped(lambda: FlowItem)

    def set_preferred_size(self, size):
        raise NotImplementedError

    def set_align(self, align):
        raise NotImplementedError

    def set_stretch(self, stretch):
        raise NotImplementedError

    def set_ortho_stretch(self, stretch):
        raise NotImplementedError


class FlowItem(Widget):
    """ A widget which can be used as an item in a FlowArea.

    A FlowItem is a widget which can be used as a child of a FlowArea
    widget. It can have at most a single child widget which is an
    instance of Container.

    """
    #: The preferred size of this flow item. This size will be used as
    #: the size of the item in the layout, bounded to the computed min
    #: and max size. A size of (-1, -1) indicates to use the widget's
    #: size hint as the preferred size.
    preferred_size = d_(Coerced(Size, (-1, -1)))

    #: The alignment of this item in the direction orthogonal to the
    #: layout flow.
    align = d_(Enum('leading', 'trailing', 'center'))

    #: The stretch factor for this item in the flow direction, relative
    #: to other items in the same line. The default is zero which means
    #: that the item will not expand in the direction orthogonal to the
    #: layout flow.
    stretch = d_(Range(low=0, value=0))

    #: The stretch factor for this item in the orthogonal direction
    #: relative to other items in the layout. The default is zero
    #: which means that the item will not expand in the direction
    #: orthogonal to the layout flow.
    ortho_stretch = d_(Range(low=0, value=0))

    #: A reference to the ProxyFlowItem object.
    proxy = Typed(ProxyFlowItem)

    def flow_widget(self):
        """ Get the flow widget defined on this flow item.

        The last Container defined on the item is the flow widget.

        """
        for child in reversed(self.children):
            if isinstance(child, Container):
                return child

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('preferred_size', 'align', 'stretch', 'ortho_stretch')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(FlowItem, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = focus_tracker
#------------------------------------------------------------------------------
# Copyright (c) 2014, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import ForwardTyped, Typed

from enaml.core.declarative import d_

from .toolkit_object import ToolkitObject, ProxyToolkitObject
from .widget import Widget


class ProxyFocusTracker(ProxyToolkitObject):
    """ The abstract definition of a proxy FocusTracker object.

    """
    #: A reference to the FocusTracker declaration.
    declaration = ForwardTyped(lambda: FocusTracker)


class FocusTracker(ToolkitObject):
    """ An object which tracks the global application focus widget.

    """
    #: The application widget with the current input focus. This will
    #: be None if no widget in the application has focus, or if the
    #: focused widget does not directly correspond to an Enaml widget.
    focused_widget = d_(Typed(Widget), writable=False)

    #: A reference to the ProxyFocusTracker object.
    proxy = Typed(ProxyFocusTracker)

########NEW FILE########
__FILENAME__ = form
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Int, observe

from enaml.layout.constrainable import ConstraintMember
from enaml.layout.layout_helpers import align, vertical, horizontal, spacer

from enaml.core.declarative import d_

from .container import Container


class Form(Container):
    """ A Container subclass that arranges its children in two columns.

    The left column is typically Labels, but this is not a requirement.
    The right are the actual widgets for data entry. The children should
    be in alternating label/widget order. If there are an odd number
    of children, the last child will span both columns.

    The Form provides an extra constraint variable, 'midline', which
    is used as the alignment anchor for the columns.

    """
    #: The ConstraintVariable giving the midline along which the labels
    #: and widgets are aligned.
    midline = ConstraintMember()

    #: The spacing to place between the form rows, in pixels.
    row_spacing = d_(Int(10))

    #: The spacing to place between the form columns, in pixels.
    column_spacing = d_(Int(10))

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('row_spacing', 'column_spacing')
    def _layout_invalidated(self, change):
        """ A private observer which invalidates the layout.

        """
        # The superclass handler is sufficient.
        super(Form, self)._layout_invalidated(change)

    #--------------------------------------------------------------------------
    # Layout Constraints
    #--------------------------------------------------------------------------
    def layout_constraints(self):
        """ Get the layout constraints for a Form.

        A Form supplies default constraints which will arrange the
        children in a two column layout. User defined 'constraints'
        will be added on top of the generated form constraints.

        This method cannot be overridden from Enaml syntax.

        """
        children = self.visible_widgets()
        labels = children[::2]
        widgets = children[1::2]
        n_labels = len(labels)
        n_widgets = len(widgets)
        if n_labels != n_widgets:
            if n_labels > n_widgets:
                odd_child = labels.pop()
            else:
                odd_child = widgets.pop()
        else:
            odd_child = None

        # Boundary flex spacer
        b_flx = spacer(0).flex()

        # Inter-column flex spacer
        c_flx = spacer(max(0, self.column_spacing)).flex()

        # Inter-row flex spacer
        r_flx = spacer(max(0, self.row_spacing)).flex()

        # Generate the row constraints and make the column stacks
        midline = self.midline
        top = self.contents_top
        left = self.contents_left
        right = self.contents_right
        constraints = self.constraints[:]
        column1 = [top, b_flx]
        column2 = [top, b_flx]
        push = constraints.append
        push_col1 = column1.append
        push_col2 = column2.append
        for label, widget in zip(labels, widgets):
            push((widget.left == midline) | 'strong')
            push(align('v_center', label, widget) | 'strong')
            push(horizontal(left, b_flx, label, c_flx, widget, b_flx, right))
            push_col1(label)
            push_col1(r_flx)
            push_col2(widget)
            push_col2(r_flx)

        # Handle the odd child and create the column constraints
        if odd_child is not None:
            push_col1(odd_child)
            push_col2(odd_child)
            push(horizontal(left, b_flx, odd_child, b_flx, right))
        else:
            column1.pop()
            column2.pop()
        bottom = self.contents_bottom
        push_col1(b_flx)
        push_col1(bottom)
        push_col2(b_flx)
        push_col2(bottom)
        push(vertical(*column1))
        push(vertical(*column2))

        return constraints

########NEW FILE########
__FILENAME__ = frame
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, Enum, Range, ForwardTyped, Typed, observe

from enaml.core.declarative import d_

from .constraints_widget import ConstraintsWidget, ProxyConstraintsWidget


class Border(Atom):
    """ A class for defining a border on a Frame.

    Border instances should be treated as read-only once created.

    """
    #: The style of the border.
    style = Enum('box', 'panel', 'styled_panel')

    #: The showdow style applied to the border.
    line_style = Enum('plain', 'sunken', 'raised')

    #: The thickness of the outer border line.
    line_width = Range(low=0, value=1)

    #: The thickness of the inner border line. This only has an effect
    #: for the 'sunken' and 'raised' line styles.
    midline_width = Range(low=0, value=0)


class ProxyFrame(ProxyConstraintsWidget):
    """ The abstract definition of a proxy Frame object.

    """
    #: A reference to the Frame declaration.
    declaration = ForwardTyped(lambda: Frame)

    def set_border(self, border):
        raise NotImplementedError


class Frame(ConstraintsWidget):
    """ A ConstraintsWidget that draws an optional border.

    This class serves as a base class for widgets such as Container and
    ScrollArea. It should not normally be used directly by user code.

    """
    #: The border to apply to the frame. This may not be supported by
    #: all toolkit backends.
    border = d_(Typed(Border))

    #: A reference to the ProxyContainer object.
    proxy = Typed(ProxyFrame)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('border')
    def _update_proxy(self, change):
        """ An observer which updates the proxy when the border changes.

        """
        # The superclass handler is sufficient
        super(Frame, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = group_box
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Unicode, Enum, Typed, ForwardTyped, observe

from enaml.core.declarative import d_

from .container import Container, ProxyContainer


class ProxyGroupBox(ProxyContainer):
    """ The abstract definition of a proxy GroupBox object.

    """
    #: A reference to the GroupBox declaration.
    declaration = ForwardTyped(lambda: GroupBox)

    def set_title(self, title):
        raise NotImplementedError

    def set_flat(self, flat):
        raise NotImplementedError

    def set_title_align(self, align):
        raise NotImplementedError


class GroupBox(Container):
    """ The GroupBox container, which introduces a group of widgets with
    a title and usually has a border.

    """
    #: The title displayed at the top of the box.
    title = d_(Unicode())

    #: The flat parameter determines if the GroupBox is displayed with
    #: just the title and a header line (True) or with a full border
    #: (False, the default).
    flat = d_(Bool(False))

    #: The alignment of the title text.
    title_align = d_(Enum('left', 'right', 'center'))

    #: A reference to the ProxyGroupBox object.
    proxy = Typed(ProxyGroupBox)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('title', 'flat', 'title_align')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(GroupBox, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = html
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Unicode, Typed, ForwardTyped, observe, set_default

from enaml.core.declarative import d_

from .control import Control, ProxyControl


class ProxyHtml(ProxyControl):
    """ The abstract definition of a proxy Html object.

    """
    #: A reference to the Html declaration.
    declaration = ForwardTyped(lambda: Html)

    def set_source(self, source):
        raise NotImplementedError


class Html(Control):
    """ An extremely simple widget for displaying HTML.

    """
    #: The Html source code to be rendered.
    source = d_(Unicode())

    #: An html control expands freely in height and width by default.
    hug_width = set_default('ignore')
    hug_height = set_default('ignore')

    #: A reference to the ProxyHtml object
    proxy = Typed(ProxyHtml)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('source')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(Html, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = h_group
#------------------------------------------------------------------------------
# Copyright (c) 2014, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Int, Typed, observe

from enaml.core.declarative import d_
from enaml.layout.layout_helpers import align, hbox
from enaml.layout.spacers import Spacer

from .container import Container


class HGroup(Container):
    """ A Container subclass which groups child widgets horizontally.

    User constraints are applied *in addition* to the horizontal group
    constraints. Widgets are aligned along their vertical center.

    """
    #: The horizontal spacing to place between widgets.
    spacing = d_(Int(10))

    #: The optional spacer to add as the first layout item.
    leading_spacer = d_(Typed(Spacer))

    #: The optional spacer to add as the last layout item.
    trailing_spacer = d_(Typed(Spacer))

    #: Whether to align the widths of the widgets.
    align_widths = d_(Bool(True))

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('spacing', 'leading_spacer', 'trailing_spacer', 'align_widths')
    def _layout_invalidated(self, change):
        """ A private observer which invalidates the layout.

        """
        # The superclass handler is sufficient.
        super(HGroup, self)._layout_invalidated(change)

    #--------------------------------------------------------------------------
    # Layout Constraints
    #--------------------------------------------------------------------------
    def layout_constraints(self):
        """ The constraints generation for a HGroup.

        This method supplies horizontal group constraints for the
        children of the container in addition to any user-supplied
        constraints.

        This method cannot be overridden from Enaml syntax.

        """
        widgets = self.visible_widgets()
        items = [self.leading_spacer] + widgets + [self.trailing_spacer]
        cns = self.constraints[:]
        cns.append(hbox(*items, spacing=self.spacing))
        cns.append(align('v_center', *widgets))
        if self.align_widths:
            cns.append(align('width', *widgets))
        return cns

########NEW FILE########
__FILENAME__ = image_view
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Typed, ForwardTyped, observe, set_default

from enaml.core.declarative import d_
from enaml.image import Image

from .control import Control, ProxyControl


class ProxyImageView(ProxyControl):
    """ The abstract definition of a proxy ImageView object.

    """
    #: A reference to the ImageView declaration.
    declaration = ForwardTyped(lambda: ImageView)

    def set_image(self, image):
        raise NotImplementedError

    def set_scale_to_fit(self, scale):
        raise NotImplementedError

    def set_allow_upscaling(self, allow):
        raise NotImplementedError

    def set_preserve_aspect_ratio(self, preserve):
        raise NotImplementedError


class ImageView(Control):
    """ A widget which can display an Image with optional scaling.

    """
    #: The image to display in the viewer.
    image = d_(Typed(Image))

    #: Whether or not to scale the image with the size of the component.
    scale_to_fit = d_(Bool(False))

    #: Whether to allow upscaling of an image if scale_to_fit is True.
    allow_upscaling = d_(Bool(True))

    #: Whether or not to preserve the aspect ratio if scaling the image.
    preserve_aspect_ratio = d_(Bool(True))

    #: An image view hugs its width weakly by default.
    hug_width = set_default('weak')

    #: An image view hugs its height weakly by default.
    hug_height = set_default('weak')

    #: A reference to the ProxyImageView object.
    proxy = Typed(ProxyImageView)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('image', 'scale_to_fit', 'allow_upscaling', 'preserve_aspect_ratio')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(ImageView, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = ipython_console
#------------------------------------------------------------------------------
# Copyright (c) 2014, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Dict, Event, Typed, ForwardTyped, set_default

from enaml.core.declarative import d_

from .control import Control, ProxyControl


class ProxyIPythonConsole(ProxyControl):
    """ The abstract defintion of a proxy IPythonConsole object.

    """
    #: A reference to the IPythonConsole declaration.
    declaration = ForwardTyped(lambda: IPythonConsole)

    def get_var(self, name, default):
        raise NotImplementedError

    def update_ns(self, ns):
        raise NotImplementedError


class IPythonConsole(Control):
    """ A widget which hosts an embedded IPython console.

    """
    #: The initial namespace to apply to the console. Runtime changes
    #: to this value will be ignored. Use 'update_ns' to add variables
    #: to the console at runtime.
    initial_ns = d_(Dict())

    #: An event fired when the user invokes a console exit command.
    exit_requested = d_(Event(), writable=False)

    #: The ipython console expands freely by default.
    hug_width = set_default('ignore')
    hug_height = set_default('ignore')

    #: A reference to the ProxyIPythonConsole object.
    proxy = Typed(ProxyIPythonConsole)

    def get_var(self, name, default=None):
        """ Get a variable from the console namespace.

        Parameters
        ----------
        name : basestring
            The name of the variable to retrieve.

        default : object, optional
            The value to return if the variable does not exist. The
            default is None.

        Returns
        -------
        result : object
            The variable in the namespace, or the provided default.

        """
        if self.proxy_is_active:
            return self.proxy.get_var(name, default)
        return default

    def update_ns(self, **kwargs):
        """ Update the variables in the console namespace.

        Parameters
        ----------
        **kwargs
            The variables to update in the console namespace.

        """
        if self.proxy_is_active:
            self.proxy.update_ns(kwargs)

########NEW FILE########
__FILENAME__ = label
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import (
    Typed, ForwardTyped, Unicode, Enum, Event, observe, set_default
)

from enaml.core.declarative import d_

from .control import Control, ProxyControl


class ProxyLabel(ProxyControl):
    """ The abstract definition of a proxy Label object.

    """
    #: A reference to the Label declaration.
    declaration = ForwardTyped(lambda: Label)

    def set_text(self, text):
        raise NotImplementedError

    def set_align(self, align):
        raise NotImplementedError

    def set_vertical_align(self, align):
        raise NotImplementedError


class Label(Control):
    """ A simple control for displaying read-only text.

    """
    #: The unicode text for the label.
    text = d_(Unicode())

    #: The horizontal alignment of the text in the widget area.
    align = d_(Enum('left', 'right', 'center', 'justify'))

    #: The vertical alignment of the text in the widget area.
    vertical_align = d_(Enum('center', 'top', 'bottom'))

    #: An event emitted when the user clicks a link in the label.
    #: The payload will be the link that was clicked.
    link_activated = d_(Event(), writable=False)

    #: Labels hug their width weakly by default.
    hug_width = set_default('weak')

    #: A reference to the ProxyLabel object.
    proxy = Typed(ProxyLabel)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('text', 'align', 'vertical_align')
    def _update_proxy(self, change):
        """ An observer which sends the state change to the proxy.

        """
        # The superclass implementation is sufficient.
        super(Label, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = main_window
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed, ForwardTyped

from .dock_pane import DockPane
from .menu_bar import MenuBar
from .status_bar import StatusBar
from .tool_bar import ToolBar
from .window import Window, ProxyWindow


class ProxyMainWindow(ProxyWindow):
    """ The abstract definition of a proxy MainWindow object.

    """
    #: A reference to the MainWindow declaration.
    declaration = ForwardTyped(lambda: MainWindow)


class MainWindow(Window):
    """ A top level main window widget.

    MainWindow widgets are top level widgets which provide additional
    functionality beyond frame decoration. A MainWindow may optionally
    contain a MenuBar, any number of ToolBars, a StatusBar, and any
    number of DockPanes. Like Window, a MainWindow can have at most one
    central Container widget, which will be expanded to fit into the
    available space.

    """
    #: A reference to the ProxyMainWindow object.
    proxy = Typed(ProxyMainWindow)

    def menu_bar(self):
        """ Get the menu bar defined as a child on the window.

        The last MenuBar declared as a child is used as the official
        menu bar of the window.

        """
        for child in reversed(self.children):
            if isinstance(child, MenuBar):
                return child

    def dock_panes(self):
        """ Get the dock panes defined as children on the window.

        """
        return [c for c in self.children if isinstance(c, DockPane)]

    def status_bar(self):
        """ Get the status bar defined as a child on the window.

        The last StatuBar declared as a child is used as the official
        status bar of the window.

        """
        for child in reversed(self.children):
            if isinstance(child, StatusBar):
                return child

    def tool_bars(self):
        """ Get the tool bars defined as children on the window.

        """
        return [c for c in self.children if isinstance(c, ToolBar)]

########NEW FILE########
__FILENAME__ = mdi_area
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed, ForwardTyped, set_default

from .constraints_widget import ConstraintsWidget, ProxyConstraintsWidget
from .mdi_window import MdiWindow


class ProxyMdiArea(ProxyConstraintsWidget):
    """ The abstract definition of a proxy MdiArea object.

    """
    #: A reference to the MdiArea declaration.
    declaration = ForwardTyped(lambda: MdiArea)


class MdiArea(ConstraintsWidget):
    """ A widget which acts as a virtual window manager for other
    top level widget.

    An MdiArea can be used to provide an area within an application
    that can display other widgets in their own independent windows.
    Children of an MdiArea should be defined as instances of MdiWindow.

    """
    #: An MdiArea expands freely in width and height by default.
    hug_width = set_default('ignore')
    hug_height = set_default('ignore')

    #: An MdiArea resists clipping only weakly by default.
    resist_width = set_default('weak')
    resist_height = set_default('weak')

    #: A reference to the ProxyMdiArea object.
    proxy = Typed(ProxyMdiArea)

    def mdi_windows(self):
        """ Get the mdi windows defined for the area.

        """
        return [c for c in self.children if isinstance(c, MdiWindow)]

########NEW FILE########
__FILENAME__ = mdi_window
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed, ForwardTyped, Unicode

from enaml.core.declarative import d_
from enaml.icon import Icon

from .widget import Widget, ProxyWidget


class ProxyMdiWindow(ProxyWidget):
    """ The abstract definition of a proxy MdiWindow.

    """
    #: A reference to the MdiWindow declaration.
    declaration = ForwardTyped(lambda: MdiWindow)

    def set_title(self, title):
        raise NotImplementedError

    def set_icon(self, icon):
        raise NotImplementedError


class MdiWindow(Widget):
    """ A widget which can be used as a window in an MdiArea.
    

    Returns
    -------
    result : QWidget or None
        The mdi widget defined for this widget, or None if one is
        not defined.
        
    An MdiWindow is a widget which can be used as an independent window
    in an MdiArea. It can have at most a single child widget which is
    an instance of Widget.

    """
    #: The titlebar text.
    title = d_(Unicode())

    #: The title bar icon.
    icon = d_(Typed(Icon))

    def mdi_widget(self):
        """ Get the mdi widget defined for the window.

        The last Widget child is the mdi widget.

        """
        for child in reversed(self.children):
            if isinstance(child, Widget):
                return child

########NEW FILE########
__FILENAME__ = menu
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Typed, ForwardTyped, Unicode, observe

from enaml.core.declarative import d_

from .action import Action
from .action_group import ActionGroup
from .toolkit_object import ToolkitObject, ProxyToolkitObject


class ProxyMenu(ProxyToolkitObject):
    """ The abstract definition of a proxy Menu object.

    """
    #: A reference to the Menu declaration.
    declaration = ForwardTyped(lambda: Menu)

    def set_title(self, title):
        raise NotImplementedError

    def set_enabled(self, enabled):
        raise NotImplementedError

    def set_visible(self, visible):
        raise NotImplementedError

    def set_context_menu(self, context):
        raise NotImplementedError

    def popup(self):
        raise NotImplementedError

    def close(self):
        raise NotImplementedError


class Menu(ToolkitObject):
    """ A widget used as a menu in a MenuBar.

    """
    #: The title to use for the menu.
    title = d_(Unicode())

    #: Whether or not the menu is enabled.
    enabled = d_(Bool(True))

    #: Whether or not the menu is visible.
    visible = d_(Bool(True))

    #: Whether this menu should behave as a context menu for its parent.
    context_menu = d_(Bool(False))

    #: A reference to the ProxyMenu object.
    proxy = Typed(ProxyMenu)

    def items(self):
        """ Get the items defined on the Menu.

        A menu item is one of Action, ActionGroup, or Menu.

        """
        allowed = (Action, ActionGroup, Menu)
        return [c for c in self.children if isinstance(c, allowed)]

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('title', 'enabled', 'visible', 'context_menu')
    def _update_proxy(self, change):
        """ An observer which updates the proxy when the menu changes.

        """
        # The superclass implementation is sufficient.
        super(Menu, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def popup(self):
        """ Popup the menu over the current mouse location.

        """
        if not self.is_initialized:
            self.initialize()
        if not self.proxy_is_active:
            self.activate_proxy()
        self.proxy.popup()

    def close(self):
        """ Close the menu.

        This API can be used by embedded widgets to close the menu
        at the appropriate time.

        """
        if self.proxy_is_active:
            self.proxy.close()

########NEW FILE########
__FILENAME__ = menu_bar
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed, ForwardTyped

from .menu import Menu
from .toolkit_object import ToolkitObject, ProxyToolkitObject


class ProxyMenuBar(ProxyToolkitObject):
    """ The abstract definition of a proxy MenuBar object.

    """
    #: A reference to the MenuBar declaration.
    declaration = ForwardTyped(lambda: MenuBar)


class MenuBar(ToolkitObject):
    """ A widget used as a menu bar in a MainWindow.

    """
    #: A reference to the ProxyMenuBar object.
    proxy = Typed(ProxyMenuBar)

    def menus(self):
        """ Get the menus defined as children on the menu bar.

        """
        return [child for child in self.children if isinstance(child, Menu)]

########NEW FILE########
__FILENAME__ = mpl_canvas
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed, ForwardTyped, Bool, observe, set_default

from enaml.core.declarative import d_

from .control import Control, ProxyControl


#: Delay the import of matplotlib until needed. This removes the hard
#: dependecy on matplotlib for the rest of the Enaml code base.
def Figure():
    from matplotlib.figure import Figure
    return Figure


class ProxyMPLCanvas(ProxyControl):
    """ The abstract definition of a proxy MPLCanvas object.

    """
    #: A reference to the MPLCanvas declaration.
    declaration = ForwardTyped(lambda: MPLCanvas)

    def set_figure(self, figure):
        raise NotImplementedError

    def set_toolbar_visible(self, visible):
        raise NotImplementedError


class MPLCanvas(Control):
    """ A control which can be used to embded a matplotlib figure.

    """
    #: The matplotlib figure to display in the widget.
    figure = d_(ForwardTyped(Figure))

    #: Whether or not the matplotlib figure toolbar is visible.
    toolbar_visible = d_(Bool(False))

    #: Matplotlib figures expand freely in height and width by default.
    hug_width = set_default('ignore')
    hug_height = set_default('ignore')

    #: A reference to the ProxyMPLCanvas object.
    proxy = Typed(ProxyMPLCanvas)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('figure', 'toolbar_visible')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(MPLCanvas, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = multiline_field
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Typed, ForwardTyped, Unicode, observe, set_default

from enaml.core.declarative import d_

from .control import Control, ProxyControl


class ProxyMultilineField(ProxyControl):
    """ The abstract definition of a proxy MultilineField object.

    """
    #: A reference to the MultilineField declaration.
    declaration = ForwardTyped(lambda: MultilineField)

    def set_text(self, text):
        raise NotImplementedError

    def set_read_only(self, read_only):
        raise NotImplementedError

    def set_auto_sync_text(self, sync):
        raise NotImplementedError

    def sync_text(self):
        raise NotImplementedError

    def field_text(self):
        raise NotImplementedError


class MultilineField(Control):
    """ A simple multiline editable text widget.

    """
    #: The unicode text to display in the field.
    text = d_(Unicode())

    #: Whether or not the field is read only.
    read_only = d_(Bool(False))

    #: Whether the text in the control should be auto-synchronized with
    #: the text attribute on the field. If this is True, the text will
    #: be updated every time the user edits the control. In order to be
    #: efficient, the toolkit will batch updates on a collapsing timer.
    auto_sync_text = d_(Bool(True))

    #: Multiline fields expand freely in width and height by default.
    hug_width = set_default('ignore')
    hug_height = set_default('ignore')

    #: A reference to the ProxyMultilineField object.
    proxy = Typed(ProxyMultilineField)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('text', 'read_only', 'auto_sync_text')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(MultilineField, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def sync_text(self):
        """ Synchronize the text with the text in the control.

        """
        if self.proxy_is_active:
            self.proxy.sync_text()

    def field_text(self):
        """ Get the text stored in the field control.

        Depending on the state of the field, this text may be different
        than that stored in the 'text' attribute.

        Returns
        -------
        result : unicode
            The unicode text stored in the field.

        """
        if self.proxy_is_active:
            return self.proxy.field_text()
        return u''

########NEW FILE########
__FILENAME__ = notebook
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import (
    Enum, Bool, Typed, ForwardTyped, Unicode, observe, set_default
)

from enaml.core.declarative import d_

from .constraints_widget import ConstraintsWidget, ProxyConstraintsWidget
from .page import Page


class ProxyNotebook(ProxyConstraintsWidget):
    """ The abstract definition of a proxy Notebook object.

    """
    #: A reference to the Notebook declaration.
    declaration = ForwardTyped(lambda: Notebook)

    def set_tab_style(self, style):
        raise NotImplementedError

    def set_tab_position(self, position):
        raise NotImplementedError

    def set_tabs_closable(self, closable):
        raise NotImplementedError

    def set_tabs_movable(self, movable):
        raise NotImplementedError

    def set_selected_tab(self, name):
        raise NotImplementedError

    def set_size_hint_mode(self, mode):
        raise NotImplementedError


class Notebook(ConstraintsWidget):
    """ A component which displays its children as tabbed pages.

    """
    #: The style of tabs to use in the notebook. Preferences style
    #: tabs are appropriate for configuration dialogs and the like.
    #: Document style tabs are appropriate for multi-page editing
    #: in code editors and the like.
    tab_style = d_(Enum('document', 'preferences'))

    #: The position of tabs in the notebook.
    tab_position = d_(Enum('top', 'bottom', 'left', 'right'))

    #: Whether or not the tabs in the notebook should be closable.
    tabs_closable = d_(Bool(True))

    #: Whether or not the tabs in the notebook should be movable.
    tabs_movable = d_(Bool(True))

    #: The object name for the selected tab in the notebook.
    selected_tab = d_(Unicode())

    #: The size hint mode for the stack. The default is 'union' and
    #: means that the size hint of the notebook is the union of all
    #: the tab size hints. 'current' means the size hint of the
    #: notebook will be the size hint of the current tab.
    size_hint_mode = d_(Enum('union', 'current'))

    #: A notebook expands freely in height and width by default.
    hug_width = set_default('ignore')
    hug_height = set_default('ignore')

    #: A reference to the ProxyNotebook object.
    proxy = Typed(ProxyNotebook)

    def pages(self):
        """ Get the Page children defined on the notebook.

        """
        return [c for c in self.children if isinstance(c, Page)]

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('tab_style', 'tab_position', 'tabs_closable', 'tabs_movable',
        'selected_tab', 'size_hint_mode')
    def _update_proxy(self, change):
        """ Send the state change to the proxy.

        """
        # The superclass implementation is sufficient.
        super(Notebook, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = object_combo
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import (
    Bool, Callable, List, Value, Typed, ForwardTyped, set_default, observe
)

from enaml.core.declarative import d_

from .control import Control, ProxyControl


class ProxyObjectCombo(ProxyControl):
    """ The abstract defintion of a proxy ObjectCombo object.

    """
    #: A reference to the ObjectCombo declaration.
    declaration = ForwardTyped(lambda: ObjectCombo)

    def set_selected(self, selected):
        raise NotImplementedError

    def set_editable(self, editable):
        raise NotImplementedError

    def request_items_refresh(self):
        raise NotImplementedError


class ObjectCombo(Control):
    """ A drop-down list from which one item can be selected at a time.

    Use a combo box to select a single item from a collection of items.

    """
    #: The list of items to display in the combo box.
    items = d_(List())

    #: The selected item from the list of items. The default will be
    #: the first item in the list of items, or None.
    selected = d_(Value())

    #: The callable to use to convert the items into unicode strings
    #: for display. The default is the builtin 'unicode'.
    to_string = d_(Callable(unicode))

    #: The callable to use to convert the items into icons for
    #: display. The default is a lambda which returns None.
    to_icon = d_(Callable(lambda item: None))

    #: Whether the text in the combo box can be edited by the user.
    editable = d_(Bool(False))

    #: A combo box hugs its width weakly by default.
    hug_width = set_default('weak')

    #: A reference to the ProxyObjectCombo object.
    proxy = Typed(ProxyObjectCombo)

    #--------------------------------------------------------------------------
    # Default Value Handlers
    #--------------------------------------------------------------------------
    def _default_selected(self):
        """ The default value handler for the 'selected' member.

        """
        items = self.items
        if len(items) > 0:
            return items[0]

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('items', 'to_string', 'to_icon')
    def _refresh_proxy(self, change):
        """ An observer which requests an items refresh from the proxy.

        """
        if change['type'] == 'update' and self.proxy_is_active:
            self.proxy.request_items_refresh()

    @observe('selected', 'editable')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(ObjectCombo, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = page
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Unicode, Bool, Event, Typed, ForwardTyped, observe

from enaml.core.declarative import d_
from enaml.icon import Icon

from .container import Container
from .widget import Widget, ProxyWidget


class ProxyPage(ProxyWidget):
    """ The abstract definition for a proxy Page.

    """
    #: A reference to the Page declaration.
    declaration = ForwardTyped(lambda: Page)

    def set_title(self, title):
        raise NotImplementedError

    def set_icon(self, icon):
        raise NotImplementedError

    def set_closable(self, closable):
        raise NotImplementedError


class Page(Widget):
    """ A widget which can be used as a page in a Notebook control.

    A Page is a widget which can be used as a child of a Notebook
    control. It can have at most a single child widget which is an
    instance of Container.

    """
    #: The title to use for the page in the notebook.
    title = d_(Unicode())

    #: The icon to use for the page tab.
    icon = d_(Typed(Icon))

    #: Whether or not this individual page is closable. Note that the
    #: 'tabs_closable' flag on the parent Notebook must be set to True
    #: for this to have any effect.
    closable = d_(Bool(True))

    #: An event fired when the user closes the page by clicking on
    #: the tab's close button.
    closed = d_(Event(), writable=False)

    #: A reference to the ProxyPage object.
    proxy = Typed(ProxyPage)

    def page_widget(self):
        """ Get the page widget defined for the page.

        The last child Container is the page widget.

        """

        for child in reversed(self.children):
            if isinstance(child, Container):
                return child

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('title', 'closable', 'icon')
    def _update_proxy(self, change):
        """ Send the member state change to the proxy.

        """
        # The superclass implementation is sufficient
        super(Page, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _handle_close(self):
        """ A method called by the proxy when the user closes the page.

        """
        self.visible = False
        self.closed()

    # TODO spend some time thinking about the open/close api
    # I would rather everything be consistent, which likely
    # means destroy-on-close behavior should be the norm.
    def open(self):
        #msg = "The 'open()' method will be removed in Enaml version "
        #msg += "0.8.0. Use 'show()' instead."
        #import warnings
        #warnings.warn(msg, FutureWarning, stacklevel=2)
        self.show()

    def close(self):
        #msg = "The 'close()' method will be removed in Enaml version "
        #msg += "0.8.0. Use 'hide()' instead."
        #import warnings
        #warnings.warn(msg, FutureWarning, stacklevel=2)
        self.hide()

########NEW FILE########
__FILENAME__ = popup_view
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import (
    Bool, Coerced, Enum, Float, Event, Int, Typed, ForwardTyped, observe,
    set_default
)

from enaml.application import deferred_call
from enaml.core.declarative import d_
from enaml.layout.geometry import Pos, PosF

from .container import Container
from .widget import Widget, ProxyWidget


def coerce_pos(thing):
    """ Coerce a thing to a Pos.

    """
    if isinstance(thing, tuple):
        return Pos(*thing)
    if isinstance(thing, (int, float)):
        return Pos(thing, thing)
    msg = "Cannot coerce object of type '%s' to a Pos"
    raise ValueError(msg % type(thing).__name__)


def coerce_posf(thing):
    """ Coerce a thing to a PosF.

    """
    if isinstance(thing, tuple):
        return PosF(*thing)
    if isinstance(thing, (int, float)):
        return PosF(thing, thing)
    msg = "Cannot coerce object of type '%s' to a PosF"
    raise ValueError(msg % type(thing).__name__)


class ProxyPopupView(ProxyWidget):
    """ The abstract definition of a proxy PopupView object.

    """
    #: A reference to the PopupView declaration.
    declaration = ForwardTyped(lambda: PopupView)

    def set_anchor(self, anchor):
        raise NotImplementedError

    def set_anchor_mode(self, mode):
        raise NotImplementedError

    def set_parent_anchor(self, anchor):
        raise NotImplementedError

    def set_arrow_size(self, size):
        raise NotImplementedError

    def set_arrow_edge(self, edget):
        raise NotImplementedError

    def set_offset(self, pos):
        raise NotImplementedError

    def set_timeout(self, timeout):
        raise NotImplementedError

    def set_fade_in_duration(self, duration):
        raise NotImplementedError

    def set_fade_out_duration(self, duration):
        raise NotImplementedError

    def set_close_on_click(self, enable):
        raise NotImplementedError

    def close(self):
        raise NotImplementedError


class PopupView(Widget):
    """ A widget which implements a nice popup view.

    A PopupView is a single-use transient widget that is automatically
    destroyed when it is closed. It is useful for showing contextual
    popup dialogs or notification messages.

    """
    #: Static class-level storage for the view instances. A view will
    #: automatically add and remove itself from this list as needed.
    #: This list prevents the need for the user to manage a strong
    #: reference to a transient popup.
    popup_views = []

    #: The type of the window to create. Each has different behavior. The
    #: window type cannot be changed after the widget is created.
    #:
    #: 'popup'
    #:     This window will close when the user presses escape or clicks
    #:     outside of the window. It will block all external interactions
    #:     until it is closed.
    #:
    #: 'tool_tip'
    #:     This window will close when the user clicks inside the window.
    #:     It stays on top of all the other windows on the desktop. It is
    #:     useful for showing mouse cursor or desktop notifications.
    #:
    #: 'window'
    #:     This window will close when the user clicks inside the window.
    #:     It stays on top of its parent, but not the other windows on
    #:     the desktop. It is useful for notifications inside a window.
    window_type = d_(Enum('popup', 'tool_tip', 'window'))

    #: The mode to use for anchoring. The 'parent' mode uses a point
    #: on the parent or the desktop as the target anchor, the 'cursor'
    #: mode uses the current cursor position as the target anchor.
    anchor_mode = d_(Enum('parent', 'cursor'))

    #: The relative position on the parent to use as the anchor. This
    #: anchor will be aligned with the view anchor to position the
    #: popup view. It is expressed as a percentage of the parent size.
    #: The default anchors will position the popup just below the
    #: center of the parent widget.
    parent_anchor = d_(Coerced(PosF, (0.5, 0.5), coercer=coerce_posf))

    #: The relative position on the view to use as the view anchor.
    #: This anchor will be aligned with the parent anchor to position
    #: the popup view. It is expressed as a percentage of the view
    #: size. The default anchors will position the popup just below
    #: the center of the parent widget.
    anchor = d_(Coerced(PosF, (0.5, 0.0), coercer=coerce_posf))

    #: The offset to apply between the two anchors, in pixels.
    offset = d_(Coerced(Pos, (0, 0), coercer=coerce_pos))

    #: The edge of the popup view to use for rendering the arrow.
    arrow_edge = d_(Enum('top', 'bottom', 'left', 'right'))

    #: The size of the arrow in pixels. If this value is > 0, the view
    #: anchor is taken to be the point of the arrow. If the arrow edge
    #: is 'left' or 'right', the anchor's y-coordinate is used to set
    #: the arrow position, and the x-coordinate is ignored. If the
    #: arrow edge is 'top' or 'bottom', the anchor's x-coordinate is
    #: used to set the arrow position, and the y-coordinate is ignored.
    arrow_size = d_(Int(0))

    #: The timeout, in seconds, before automatically closing the popup.
    #: A value less than or equal to zero means no timeout. This is
    #: typically useful when displaying non-interactive notifications.
    timeout = d_(Float(0.0))

    #: The duration of the fade-in, in milliseconds. A value less than
    #: or equal to zero means no fade.
    fade_in_duration = d_(Int(100))

    #: The duration of the fade-out, in milliseconds. A value less than
    #: or equal to zero means no fade.
    fade_out_duration = d_(Int(100))

    #: Whether or not close the popup view on a mouse click. For 'popup'
    #: windows, this means clicking outside of the view. For 'tool_tip'
    #: and 'window' windows, this means clicking inside of the view.
    close_on_click = d_(Bool(True))

    #: Whether or not the background of the popup view is translucent.
    #: This must be True in order to use background colors with alpha
    #: and for the fade in and out animation to have effect. This value
    #: must be set before the popup view is shown. Changes to this value
    #: after the popup is shown will have no effect.
    translucent_background = d_(Bool(True))

    #: An event emitted when the view is closed. After this event is
    #: fired, the view will be destroyed and should not be used.
    closed = d_(Event(), writable=False)

    #: PopupViews are invisible by default.
    visible = set_default(False)

    #: A reference to the ProxyPopupView object.
    proxy = Typed(ProxyPopupView)

    #: This attribute is deprecated and will be removed in Enaml 1.0
    arrow_position = d_(Float(0.5))

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def central_widget(self):
        """ Get the central widget defined on the PopupView.

        The last `Container` child of the window is the central widget.

        """
        for child in reversed(self.children):
            if isinstance(child, Container):
                return child

    def show(self):
        """ Show the PopupView.

        This is a reimplemented method which will intitialize the proxy
        tree before showing the view.

        """
        if not self.is_initialized:
            self.initialize()
        if not self.proxy_is_active:
            self.activate_proxy()
        super(PopupView, self).show()
        PopupView.popup_views.append(self)

    def close(self):
        """ Close the PopupView.

        Closing the view, as opposed to hiding it or setting it's
        visibility to False, will cause the 'closed' event to be
        emitted and the view to be destroyed.

        """
        if self.proxy_is_active:
            self.proxy.close()

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('anchor', 'anchor_mode', 'parent_anchor', 'arrow_size', 'offset',
        'arrow_edge', 'timeout', 'fade_in_duration', 'fade_out_duration',
        'close_on_click')
    def _update_proxy(self, change):
        """ Update the proxy when the PopupView data changes.

        """
        # The superclass handler implementation is sufficient.
        super(PopupView, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _popup_closed(self):
        """ Handle the popup view being closed.

        This method is called by the proxy object when the toolkit
        popup view is closed.

        """
        self.visible = False
        self.closed()
        deferred_call(self.destroy)
        PopupView.popup_views.remove(self)

########NEW FILE########
__FILENAME__ = progress_bar
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import (
    Typed, ForwardTyped, Property, Bool, Int, observe, set_default
)

from enaml.core.declarative import d_

from .control import Control, ProxyControl


class ProxyProgressBar(ProxyControl):
    """ The abstract defintion of a proxy ProgressBar object.

    """
    #: A reference to the ProgressBar declaration.
    declaration = ForwardTyped(lambda: ProgressBar)

    def set_minimum(self, minimum):
        raise NotImplementedError

    def set_maximum(self, maximum):
        raise NotImplementedError

    def set_value(self, value):
        raise NotImplementedError

    def set_text_visible(self, visible):
        raise NotImplementedError


class ProgressBar(Control):
    """ A control which displays a value as a ticking progress bar.

    """
    #: The minimum progress value. If the minimum value is changed such
    #: that it becomes greater than the current value or the maximum
    #: value, then those values will be adjusted. The default is 0.
    minimum = d_(Int(0))

    #: The maximum progress value. If the maximum value is changed such
    #: that it becomes smaller than the current value or the minimum
    #: value, then those values will be adjusted. The default is 100.
    maximum = d_(Int(100))

    #: The position value of the Slider. The value will be clipped to
    #: always fall between the minimum and maximum.
    value = d_(Int(0))

    #: A read only cached property which computes the integer percentage.
    percentage = d_(Property(cached=True), writable=False)

    #: Whether or not to display progress percentage on the control.
    #: This may not be supported by all toolkits and platforms.
    text_visible = d_(Bool(False))

    #: How strongly a component hugs it's content. ProgressBars expand
    #: to fill the available horizontal space by default.
    hug_width = set_default('ignore')

    #: A reference to the ProxyProgressBar object.
    proxy = Typed(ProxyProgressBar)

    @percentage.getter
    def get_percentage(self):
        """ The getter function for the read only percentage property.

        """
        minimum = self.minimum
        maximum = self.maximum
        value = self.value
        dy = maximum - minimum
        if dy == 0:
            res = 0
        elif value == maximum:
            res = 100
        else:
            dx = float(value - minimum)
            res = int(round(100.0 * dx / dy))
            # We already excluded the case where the value was exactly
            # the maximum, so we can't really be at 100%, so round this
            # down to 99% if necessary.
            res = min(res, 99)
        return res

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('minimum', 'maximum', 'value', 'text_visible')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        This observer also resets the 'percentage' property.

        """
        # The superclass handler implementation is sufficient.
        super(ProgressBar, self)._update_proxy(change)

    @observe('minimum', 'maximum', 'value')
    def _reset_percentage(self, change):
        """ An observer which resets the percentage property.

        """
        if change['type'] == 'update':
            self.get_member('percentage').reset(self)

    #--------------------------------------------------------------------------
    # PostSetAttr Handlers
    #--------------------------------------------------------------------------
    def _post_setattr_minimum(self, old, new):
        """ Post setattr the minimum value for the progress bar.

        If the new minimum is greater than the current value or maximum,
        those values are adjusted up.

        """
        if new > self.maximum:
            self.maximum = new
        if new > self.value:
            self.value = new

    def _post_setattr_maximum(self, old, new):
        """ Post setattr the maximum value for the progress bar.

        If the new maximum is less than the current value or the minimum,
        those values are adjusted down.

        """
        if new < self.minimum:
            self.minimum = new
        if new < self.value:
            self.value = new

    #--------------------------------------------------------------------------
    # PostValidate Handlers
    #--------------------------------------------------------------------------
    def _post_validate_value(self, old, new):
        """ Post validate the value for the progress bar.

        The value is clipped to minimum and maximum bounds.

        """
        return max(self.minimum, min(new, self.maximum))

########NEW FILE########
__FILENAME__ = push_button
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Typed, ForwardTyped, observe

from enaml.core.declarative import d_

from .abstract_button import AbstractButton, ProxyAbstractButton
from .menu import Menu


class ProxyPushButton(ProxyAbstractButton):
    """ The abstract definition of a proxy PushButton object.

    """
    #: A reference to the PushButton declaration.
    declaration = ForwardTyped(lambda: PushButton)

    def set_default(self, default):
        raise NotImplementedError


class PushButton(AbstractButton):
    """ A button control represented by a standard push button widget.

    """
    #: Whether this button is the default action button in a dialog.
    default = d_(Bool(False))

    #: A reference to the ProxyPushButton object.
    proxy = Typed(ProxyPushButton)

    def menu(self):
        """ Get the menu defined for the PushButton, if any.

        """
        for child in reversed(self.children):
            if isinstance(child, Menu):
                return child

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('default')
    def _update_proxy(self, change):
        """ Send the member state change to the proxy.

        """
        # The superclass implementation is sufficient
        super(PushButton, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = radio_button
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed, ForwardTyped, set_default

from .abstract_button import AbstractButton, ProxyAbstractButton


class ProxyRadioButton(ProxyAbstractButton):
    """ The abstract definition of a proxy PushButton object.

    """
    #: A reference to the RadioButton declaration.
    declaration = ForwardTyped(lambda: RadioButton)


class RadioButton(AbstractButton):
    """ An exclusive checkable button represented by a standard radio
    button widget.

    Use a radio button to toggle the value of a boolean field. For a
    group of radio buttons with the same widget parent, only one radio
    button may be selected at a time. This makes groups of radio buttons
    useful for selecting amongst a discrete set of values. For multiple
    groups of independent radio buttons, place each group of buttons
    in their own Container.

    The interface for AbstractButton fully defines the interface for
    a RadioButton.

    """
    #: Radio buttons are checkable by default.
    checkable = set_default(True)

    #: A reference to the ProxyRadioButton object.
    proxy = Typed(ProxyRadioButton)

########NEW FILE########
__FILENAME__ = raw_widget
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed, ForwardTyped

from .control import Control, ProxyControl


class ProxyRawWidget(ProxyControl):
    """ The abstract definition of a proxy RawWidget object.

    """
    #: A reference to the RawWidget declaration.
    declaration = ForwardTyped(lambda: RawWidget)

    def get_widget(self):
        raise NotImplementedError


class RawWidget(Control):
    """ A raw toolkit-specific control.

    Use this widget when the toolkit backend for the application is
    known ahead of time, and Enaml does provide an implementation of
    the required widget. This can be used as a hook to inject custom
    widgets into an Enaml widget hierarchy.

    """
    #: A reference to the proxy Control object.
    proxy = Typed(ProxyRawWidget)

    def create_widget(self, parent):
        """ Create the toolkit widget for the control.

        This method should create and initialize the widget.

        Parameters
        ----------
        parent : toolkit widget or None
            The parent toolkit widget for the control.

        Returns
        -------
        result : toolkit widget
            The toolkit specific widget for the control.

        """
        raise NotImplementedError

    def get_widget(self):
        """ Retrieve the toolkit widget for the control.

        Returns
        -------
        result : toolkit widget or None
            The toolkit widget that was previously created by the
            call to 'create_widget' or None if the proxy is not
            active or the widget has been destroyed.

        """
        if self.proxy_is_active:
            return self.proxy.get_widget()

########NEW FILE########
__FILENAME__ = scroll_area
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Enum, Bool, Typed, ForwardTyped, observe, set_default

from enaml.core.declarative import d_

from .container import Container
from .frame import Frame, ProxyFrame, Border


class ProxyScrollArea(ProxyFrame):
    """ The abstract definition of a proxy ScrollArea object.

    """
    #: A reference to the ScrollArea declaration.
    declaration = ForwardTyped(lambda: ScrollArea)

    def set_horizontal_policy(self, policy):
        raise NotImplementedError

    def set_vertical_policy(self, policy):
        raise NotImplementedError

    def set_widget_resizable(self, resizable):
        raise NotImplementedError


class ScrollArea(Frame):
    """ A Frame which displays a single child in a scrollable area.

    A ScrollArea has at most a single child Container widget.

    """
    #: The horizontal scrollbar policy.
    horizontal_policy = d_(Enum('as_needed', 'always_on', 'always_off'))

    #: The vertical scrollbar policy.
    vertical_policy = d_(Enum('as_needed', 'always_on', 'always_off'))

    #: Whether to resize the scroll widget when possible to avoid the
    #: need for scrollbars or to make use of extra space.
    widget_resizable = d_(Bool(True))

    #: A scroll area is free to expand in width and height by default.
    hug_width = set_default('ignore')
    hug_height = set_default('ignore')

    #: A reference to the ProxyScrollArea object.
    proxy = Typed(ProxyScrollArea)

    def scroll_widget(self):
        """ Get the scroll widget child defined on the area.

        The scroll widget is the last Container child.

        """
        for child in reversed(self.children):
            if isinstance(child, Container):
                return child

    #--------------------------------------------------------------------------
    # Default Handlers
    #--------------------------------------------------------------------------
    def _default_border(self):
        """ Get the default border for the scroll area.

        The default value matches the default for Qt's QScrollArea.

        """
        return Border(style='styled_panel', line_style='sunken')

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('horizontal_policy', 'vertical_policy', 'widget_resizable')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(ScrollArea, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = separator
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Range, Enum, Typed, ForwardTyped, observe

from enaml.core.declarative import d_
from .control import Control, ProxyControl


class ProxySeparator(ProxyControl):
    """ The abstract definition of a proxy Separator object.

    """
    #: A reference to the Separator declaration.
    declaration = ForwardTyped(lambda: Separator)

    def set_orientation(self, resizable):
        raise NotImplementedError

    def set_line_style(self, style):
        raise NotImplementedError

    def set_line_width(self, width):
        raise NotImplementedError

    def set_midline_width(self, width):
        raise NotImplementedError


class Separator(Control):
    """ A widget which draws a horizontal or vertical separator line.

    """
    #: The orientation of the separator line.
    orientation = d_(Enum('horizontal', 'vertical'))

    #: The line style for the separator.
    line_style = d_(Enum('sunken', 'raised', 'plain'))

    #: The thickness of the outer separator line.
    line_width = d_(Range(low=0, high=3, value=1))

    #: The thickness of the inner separator line. This only has an
    #: effect for the 'sunken' and 'raised' line styles.
    midline_width = d_(Range(low=0, high=3, value=0))

    #: Whether or not to automatically adjust the 'hug_width' and
    #: 'hug_height' values based on the value of 'orientation'.
    auto_hug = d_(Bool(True))

    #: A reference to the ProxySeparator object.
    proxy = Typed(ProxySeparator)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('orientation', 'line_style', 'line_width', 'midline_width')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(Separator, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # DefaultValue Handlers
    #--------------------------------------------------------------------------
    def _default_hug_width(self):
        """ Get the default hug width for the separator.

        The default hug width is computed based on the orientation.

        """
        if self.orientation == 'horizontal':
            return 'ignore'
        return 'strong'

    def _default_hug_height(self):
        """ Get the default hug height for the separator.

        The default hug height is computed based on the orientation.

        """
        if self.orientation == 'vertical':
            return 'ignore'
        return 'strong'

    #--------------------------------------------------------------------------
    # PostSetAttr Handlers
    #--------------------------------------------------------------------------
    def _post_setattr_orientation(self, old, new):
        """ Post setattr the orientation for the tool bar.

        If auto hug is enabled, the hug values will be updated.

        """
        if self.auto_hug:
            if new == 'vertical':
                self.hug_width = 'strong'
                self.hug_height = 'ignore'
            else:
                self.hug_width = 'ignore'
                self.hug_height = 'strong'

########NEW FILE########
__FILENAME__ = slider
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Enum, Int, Range, Typed, ForwardTyped, observe

from enaml.core.declarative import d_

from .control import Control, ProxyControl


#: The base tick position enum defintion.
TickPosition = Enum('no_ticks', 'left', 'right', 'top', 'bottom', 'both')


class ProxySlider(ProxyControl):
    """ The abstract definition of a proxy Slider object.

    """
    #: A reference to the Slider declaration.
    declaration = ForwardTyped(lambda: Slider)

    def set_minimum(self, minimum):
        raise NotImplementedError

    def set_maximum(self, maximum):
        raise NotImplementedError

    def set_value(self, value):
        raise NotImplementedError

    def set_single_step(self, step):
        raise NotImplementedError

    def set_page_step(self, step):
        raise NotImplementedError

    def set_tick_position(self, position):
        raise NotImplementedError

    def set_tick_interval(self, interval):
        raise NotImplementedError

    def set_orientation(self, orientation):
        raise NotImplementedError

    def set_tracking(self, tracking):
        raise NotImplementedError


class Slider(Control):
    """ A simple slider widget that can be used to select from a range
    of integral values.

    A `SliderTransform` can be used to transform the integer range
    of the slider into another data space. For more details, see
    `enaml.stdlib.slider_transform`.

    """
    #: The minimum slider value. If the minimum value is changed such
    #: that it becomes greater than the current value or the maximum
    #: value, then those values will be adjusted. The default is 0.
    minimum = d_(Int(0))

    #: The maximum slider value. If the maximum value is changed such
    #: that it becomes smaller than the current value or the minimum
    #: value, then those values will be adjusted. The default is 100.
    maximum = d_(Int(100))

    #: The position value of the Slider. The value will be clipped to
    #: always fall between the minimum and maximum.
    value = d_(Int(0))

    #: Defines the number of steps that the slider will move when the
    #: user presses the arrow keys. The default is 1. An upper limit
    #: may be imposed according the limits of the client widget.
    single_step = d_(Range(low=1))

    #: Defines the number of steps that the slider will move when the
    #: user presses the page_up/page_down keys. The Default is 10. An
    #: upper limit may be imposed on this value according to the limits
    #: of the client widget.
    page_step = d_(Range(low=1, value=10))

    #: A TickPosition enum value indicating how to display the tick
    #: marks. Note that the orientation takes precedence over the tick
    #: mark position and an incompatible tick position will be adapted
    #: according to the current orientation. The default tick position
    #: is 'bottom'.
    tick_position = d_(TickPosition('bottom'))

    #: The interval to place between slider tick marks in units of
    #: value (as opposed to pixels). The minimum value is 0, which
    #: indicates that the choice is left up to the client.
    tick_interval = d_(Range(low=0))

    #: The orientation of the slider. The default orientation is
    #: horizontal. When the orientation is flipped the tick positions
    #: (if set) also adapt to reflect the changes  (e.g. the LEFT
    #: becomes TOP when the orientation becomes horizontal).
    orientation = d_(Enum('horizontal', 'vertical'))

    #: If True, the value is updated while sliding. Otherwise, it is
    #: only updated when the slider is released. Defaults to True.
    tracking = d_(Bool(True))

    #: Whether or not to automatically adjust the 'hug_width' and
    #: 'hug_height' values based on the value of 'orientation'.
    auto_hug = d_(Bool(True))

    #: A reference to the ProxySlider object.
    proxy = Typed(ProxySlider)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('minimum', 'maximum', 'value', 'single_step', 'page_step',
        'tick_position', 'tick_interval', 'orientation', 'tracking')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(Slider, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # DefaultValue Handlers
    #--------------------------------------------------------------------------
    def _default_hug_width(self):
        """ Get the default hug width for the separator.

        The default hug width is computed based on the orientation.

        """
        if self.orientation == 'horizontal':
            return 'ignore'
        return 'strong'

    def _default_hug_height(self):
        """ Get the default hug height for the separator.

        The default hug height is computed based on the orientation.

        """
        if self.orientation == 'vertical':
            return 'ignore'
        return 'strong'

    #--------------------------------------------------------------------------
    # PostSetAttr Handlers
    #--------------------------------------------------------------------------
    def _post_setattr_orientation(self, old, new):
        """ Post setattr the orientation for the tool bar.

        If auto hug is enabled, the hug values will be updated.

        """
        if self.auto_hug:
            if new == 'vertical':
                self.hug_width = 'strong'
                self.hug_height = 'ignore'
            else:
                self.hug_width = 'ignore'
                self.hug_height = 'strong'

    def _post_setattr_minimum(self, old, new):
        """ Post setattr the minimum value for the slider.

        If the new minimum is greater than the current value or maximum,
        those values are adjusted up.

        """
        if new > self.maximum:
            self.maximum = new
        if new > self.value:
            self.value = new

    def _post_setattr_maximum(self, old, new):
        """ Post setattr the maximum value for the slider.

        If the new maximum is less than the current value or the minimum,
        those values are adjusted down.

        """
        if new < self.minimum:
            self.minimum = new
        if new < self.value:
            self.value = new

    #--------------------------------------------------------------------------
    # Post Validation Handlers
    #--------------------------------------------------------------------------
    def _post_validate_value(self, old, new):
        """ Post validate the value for the slider.

        The value is clipped to minimum and maximum bounds.

        """
        return max(self.minimum, min(new, self.maximum))

########NEW FILE########
__FILENAME__ = spin_box
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import (
    Int, Bool, Range, Unicode, Typed, ForwardTyped, observe, set_default
)

from enaml.core.declarative import d_

from .control import Control, ProxyControl


class ProxySpinBox(ProxyControl):
    """ The abstract defintion of a proxy SpinBox object.

    """
    #: A reference to the SpinBox declaration.
    declaration = ForwardTyped(lambda: SpinBox)

    def set_minimum(self, minimum):
        raise NotImplementedError

    def set_maximum(self, maximum):
        raise NotImplementedError

    def set_value(self, value):
        raise NotImplementedError

    def set_prefix(self, prefix):
        raise NotImplementedError

    def set_suffix(self, suffix):
        raise NotImplementedError

    def set_special_value_text(self, text):
        raise NotImplementedError

    def set_single_step(self, step):
        raise NotImplementedError

    def set_read_only(self, read_only):
        raise NotImplementedError

    def set_wrapping(self, wrapping):
        raise NotImplementedError


class SpinBox(Control):
    """ A spin box widget which manipulates integer values.

    """
    #: The minimum value for the spin box. Defaults to 0.
    minimum = d_(Int(0))

    #: The maximum value for the spin box. Defaults to 100.
    maximum = d_(Int(100))

    #: The position value of the spin box. The value will be clipped to
    #: always fall between the minimum and maximum.
    value = d_(Int(0))

    #: An optional prefix to include in the displayed text.
    prefix = d_(Unicode())

    #: An optional suffix to include in the displayed text.
    suffix = d_(Unicode())

    #: Optional text to display when the spin box is at its minimum.
    #: This allows the developer to indicate to the user a special
    #: significance to the minimum value e.g. "Auto"
    special_value_text = d_(Unicode())

    #: The step size for the spin box. Defaults to 1.
    single_step = d_(Range(low=1))

    #: Whether or not the spin box is read-only. If True, the user
    #: will not be able to edit the values in the spin box, but they
    #: will still be able to copy the text to the clipboard.
    read_only = d_(Bool(False))

    #: Whether or not the spin box will wrap around at its extremes.
    #: Defaults to False.
    wrapping = d_(Bool(False))

    #: A spin box expands freely in width by default.
    hug_width = set_default('ignore')

    #: A reference to the ProxySpinBox object.
    proxy = Typed(ProxySpinBox)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('minimum', 'maximum', 'value', 'prefix', 'suffix',
        'special_value_text', 'single_step', 'read_only', 'wrapping')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(SpinBox, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # PostSetAttr Handlers
    #--------------------------------------------------------------------------
    def _post_setattr_minimum(self, old, new):
        """ Post setattr the minimum value for the spin box.

        If the new minimum is greater than the current value or maximum,
        those values are adjusted up.

        """
        if new > self.maximum:
            self.maximum = new
        if new > self.value:
            self.value = new

    def _post_setattr_maximum(self, old, new):
        """ Post setattr the maximum value for the spin box.

        If the new maximum is less than the current value or the minimum,
        those values are adjusted down.

        """
        if new < self.minimum:
            self.minimum = new
        if new < self.value:
            self.value = new

    #--------------------------------------------------------------------------
    # Post Validation Handlers
    #--------------------------------------------------------------------------
    def _post_validate_value(self, old, new):
        """ Post validate the value for the spin box.

        The value is clipped to minimum and maximum bounds.

        """
        return max(self.minimum, min(new, self.maximum))

########NEW FILE########
__FILENAME__ = splitter
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Enum, Typed, ForwardTyped, observe, set_default

from enaml.core.declarative import d_

from .constraints_widget import ConstraintsWidget, ProxyConstraintsWidget
from .split_item import SplitItem


class ProxySplitter(ProxyConstraintsWidget):
    """ The abstract definition of a proxy Splitter object.

    """
    #: A reference to the Splitter declaration.
    declaration = ForwardTyped(lambda: Splitter)

    def set_orientation(self, orientation):
        raise NotImplementedError

    def set_live_drag(self, live_drag):
        raise NotImplementedError


class Splitter(ConstraintsWidget):
    """ A widget which displays its children in separate resizable
    compartements that are connected with a resizing bar.

    A Splitter can have an arbitrary number of Container children.

    """
    #: The orientation of the Splitter. 'horizontal' means the children
    #: are laid out left to right, 'vertical' means top to bottom.
    orientation = d_(Enum('horizontal', 'vertical'))

    #: Whether the child widgets resize as a splitter is being dragged
    #: (True), or if a simple indicator is drawn until the drag handle
    #: is released (False). The default is True.
    live_drag = d_(Bool(True))

    #: A splitter expands freely in height and width by default.
    hug_width = set_default('ignore')
    hug_height = set_default('ignore')

    #: A reference to the ProxySplitter object.
    proxy = Typed(ProxySplitter)

    def split_items(self):
        """ Get the split item children defined on the splitter.

        """
        return [c for c in self.children if isinstance(c, SplitItem)]

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('orientation', 'live_drag')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(Splitter, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = split_item
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Range, Value, Typed, ForwardTyped, observe

from enaml.core.declarative import d_

from .container import Container
from .widget import Widget, ProxyWidget


class ProxySplitItem(ProxyWidget):
    """ The abstract definition of a proxy SplitItem object.

    """
    #: A reference to the SplitItem declaration.
    declaration = ForwardTyped(lambda: SplitItem)

    def set_stretch(self, stretch):
        raise NotImplementedError

    def set_collapsible(self, collapsible):
        raise NotImplementedError


class SplitItem(Widget):
    """ A widget which can be used as an item in a Splitter.

    A SplitItem is a widget which can be used as a child of a Splitter
    widget. It can have at most a single child widget which is an
    instance of Container.

    """
    #: The stretch factor for this item. The stretch factor determines
    #: how much an item is resized relative to its neighbors when the
    #: splitter space is allocated.
    stretch = d_(Range(low=0, value=1))

    #: Whether or not the item can be collapsed to zero width by the
    #: user. This holds regardless of the minimum size of the item.
    collapsible = d_(Bool(True))

    #: This is a deprecated attribute. It should no longer be used.
    preferred_size = d_(Value())

    #: A reference to the ProxySplitItem object.
    proxy = Typed(ProxySplitItem)

    def split_widget(self):
        """ Get the split widget defined on the item.

        The split widget is the last child Container.

        """
        for child in reversed(self.children):
            if isinstance(child, Container):
                return child

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('stretch', 'collapsible')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(SplitItem, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = stack
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import (
    Atom, Enum, Int, Range, Typed, ForwardTyped, observe, set_default
)

from enaml.core.declarative import d_

from .constraints_widget import ConstraintsWidget, ProxyConstraintsWidget
from .stack_item import StackItem


class Transition(Atom):
    """ An object representing an animated transition.

    Once a transition is created, it should be considered read-only.

    """
    #: The type of transition effect to use.
    type = Enum('slide', 'wipe', 'iris', 'fade', 'crossfade')

    #: The direction of the transition effect. Some transition types
    #: will ignore the direction if it doesn't apply to the effect.
    direction = Enum(
        'left_to_right', 'right_to_left', 'top_to_bottom', 'bottom_to_top'
    )

    #: The duration of the transition, in milliseconds.
    duration = Range(low=0, value=250)


class ProxyStack(ProxyConstraintsWidget):
    """ The abstract definition of a proxy Stack object.

    """
    #: A reference to the Stack declaration.
    declaration = ForwardTyped(lambda: Stack)

    def set_index(self, index):
        raise NotImplementedError

    def set_transition(self, transition):
        raise NotImplementedError

    def set_size_hint_mode(self, mode):
        raise NotImplementedError


class Stack(ConstraintsWidget):
    """ A component which displays its children as a stack of widgets,
    only one of which is visible at a time.

    """
    #: The index of the visible widget in the stack. The widget itself
    #: does not provide a means to changing this index. That control
    #: must be supplied externally. If the given index falls outside of
    #: the range of stack items, no widget will be visible.
    index = d_(Int(0))

    #: The item transition to use when changing between stack items.
    transition = d_(Typed(Transition))

    #: The size hint mode for the stack. The default is 'union' and
    #: means that the size hint of the stack is the union of all the
    #: stack item size hints. 'current' means the size hint of the
    #: stack will be the size hint of the current stack item.
    size_hint_mode = d_(Enum('union', 'current'))

    #: A Stack expands freely in height and width by default
    hug_width = set_default('ignore')
    hug_height = set_default('ignore')

    #: A reference to the ProxyStack widget.
    proxy = Typed(ProxyStack)

    def stack_items(self):
        """ Get the stack items defined on the stack

        """
        return [c for c in self.children if isinstance(c, StackItem)]

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('index', 'transition', 'size_hint_mode')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(Stack, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = stack_item
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed, ForwardTyped

from .container import Container
from .widget import Widget, ProxyWidget


class ProxyStackItem(ProxyWidget):
    """ The abstract definition of a proxy StackItem object.

    """
    #: A reference to the StackItem declaration.
    declaration = ForwardTyped(lambda: StackItem)


class StackItem(Widget):
    """ A widget which can be used as an item in a Stack.

    A StackItem is a widget which can be used as a child of a Stack
    widget. It can have at most a single child widget which is an
    instance of Container.

    """
    #: A reference to the ProxyStackItem object.
    proxy = Typed(ProxyStackItem)

    def stack_widget(self):
        """ Get the stack widget defined for the item.

        The stack widget is the last child Container.

        """
        for child in reversed(self.children):
            if isinstance(child, Container):
                return child

########NEW FILE########
__FILENAME__ = status_bar
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed, ForwardTyped, Bool, observe

from enaml.core.declarative import d_

from .status_item import StatusItem
from .widget import Widget, ProxyWidget


class ProxyStatusBar(ProxyWidget):
    """ The abstract definition of a proxy StatusBar object.

    """
    #: A reference to the StatusBar declaration.
    declaration = ForwardTyped(lambda: StatusBar)

    def set_size_grip_enabled(self, enabled):
        raise NotImplementedError

    def show_message(self, message, timeout=0):
        raise NotImplementedError

    def clear_message(self):
        raise NotImplementedError


class StatusBar(Widget):
    """ A widget used as a status bar in a MainWindow.

    A status bar can be used to display temporary messages or display
    persistent widgets by declaring StatusItem children.

    """
    #: Whether or not the size grip in the right corner is enabled.
    size_grip_enabled = d_(Bool(True))

    #: A reference to the ProxyStatusBar object.
    proxy = Typed(ProxyStatusBar)

    def status_items(self):
        """ Get the list of status items defined on the status bar.

        """
        return [c for c in self.children if isinstance(c, StatusItem)]

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('size_grip_enabled')
    def _update_proxy(self, change):
        """ Update the proxy when the status bar data changes.

        """
        # The superclass implementation is sufficient.
        super(StatusBar, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def show_message(self, message, timeout=0):
        """ Show a temporary message in the status bar.

        Parameters
        ----------
        message : unicode
            The message to show in the status bar.

        timeout : int, optional
            The number of milliseconds to show the message. The default
            is 0, which will show the message until a new message is
            shown or 'clear_message()' is called.

        """
        if self.proxy_is_active:
            self.proxy.show_message(message, timeout)

    def clear_message(self):
        """ Clear any temporary message displayed in the status bar.

        """
        if self.proxy_is_active:
            self.proxy.clear_message()

########NEW FILE########
__FILENAME__ = status_item
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed, ForwardTyped, Enum, Range, observe

from enaml.core.declarative import d_

from .toolkit_object import ToolkitObject, ProxyToolkitObject
from .widget import Widget


class ProxyStatusItem(ProxyToolkitObject):
    """ The abstract definition of a proxy StatusItem object.

    """
    #: A reference to the StatusItem declaration
    declaration = ForwardTyped(lambda: StatusItem)

    def set_mode(eslf, mode):
        raise NotImplementedError

    def set_stretch(self, stretch):
        raise NotImplementedError


class StatusItem(ToolkitObject):
    """ An item which holds a widget to include in a status bar.

    """
    #: The mode of a status item. A 'normal' item can be obscured by
    #: temporary status messages; a 'permanent' item cannot.
    mode = d_(Enum('normal', 'permanent'))

    #: The stretch factor to apply to this item, relative to the other
    #: items in the status bar.
    stretch = d_(Range(low=0))

    #: A reference to the ProxyStatusItem object.
    proxy = Typed(ProxyStatusItem)

    def status_widget(self):
        """ Get the status widget for the item.

        The last Widget child is used as the status widget.

        """
        for child in reversed(self.children):
            if isinstance(child, Widget):
                return child

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('mode', 'stretch')
    def _update_proxy(self, change):
        """ Update the proxy when the status item data changes.

        """
        # The superclass implementation is sufficient.
        super(StatusItem, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = timer
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Event, Int, ForwardTyped, Typed, observe

from enaml.core.declarative import d_

from .toolkit_object import ToolkitObject, ProxyToolkitObject


class ProxyTimer(ProxyToolkitObject):
    """ The abstract definition of a proxy Timer object.

    """
    #: A reference to the Timer declaration.
    declaration = ForwardTyped(lambda: Timer)

    def set_interval(self, interval):
        raise NotImplementedError

    def set_single_shot(self, single_shot):
        raise NotImplementedError

    def start(self):
        raise NotImplementedError

    def stop(self):
        raise NotImplementedError

    def is_running(self):
        raise NotImplementedError


class Timer(ToolkitObject):
    """ An object which represents a toolkit independent timer.

    """
    #: The interval of the timer, in milliseconds. The default is 0 and
    #: indicates that the timer will fire as soon as the event queue is
    #: emptied of all pending events.
    interval = d_(Int(0))

    #: Whether the timer fires only once, or repeatedly until stopped.
    single_shot = d_(Bool(False))

    #: An event fired when the timer times out.
    timeout = d_(Event(), writable=False)

    #: A reference to the ProxyTimer object.
    proxy = Typed(ProxyTimer)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('single_shot', 'interval')
    def _update_proxy(self, change):
        """ An observer which updates the proxy when the state changes.

        """
        # The superclass implementation is sufficient.
        super(Timer, self)._update_proxy(change)

    def start(self):
        """ Start or restart the timer.

        If the timer is already started, it will be stopped and
        restarted.

        """
        if self.proxy_is_active:
            self.proxy.start()

    def stop(self):
        """ Stop the timer.

        If the timer is already stopped, this is a no-op.

        """
        if self.proxy_is_active:
            self.proxy.stop()

    def is_active(self):
        """ Returns True if the timer is running, False otherwise.

        """
        if self.proxy_is_active:
            return self.proxy.is_running()
        return False

########NEW FILE########
__FILENAME__ = time_selector
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Str, Typed, ForwardTyped, observe, set_default

from enaml.core.declarative import d_

from .bounded_time import BoundedTime, ProxyBoundedTime


class ProxyTimeSelector(ProxyBoundedTime):
    """ The abstract defintion of a proxy TimeSelector object.

    """
    #: A reference to the TimeSelector declaration.
    declaration = ForwardTyped(lambda: TimeSelector)

    def set_time_format(self, format):
        raise NotImplementedError


class TimeSelector(BoundedTime):
    """ A time widget that displays a Python datetime.time object using
    an appropriate toolkit specific control.

    """
    #: A python time format string to format the time. If None is
    #: supplied (or is invalid) the system locale setting is used.
    #: This may not be supported by all backends.
    time_format = d_(Str())

    #: A time selector is free to expand in width by default.
    hug_width = set_default('ignore')

    #: A reference to the ProxyDateSelector object.
    proxy = Typed(ProxyTimeSelector)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('time_format')
    def _update_proxy(self, change):
        """ An observer which updates the proxy with state change.

        """
        # The superclass implementation is sufficient.
        super(TimeSelector, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = toolkit_dialog
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import (
    Bool, Unicode, Typed, ForwardTyped, Event, Callable, observe
)

from enaml.application import deferred_call
from enaml.core.declarative import d_

from .toolkit_object import ToolkitObject, ProxyToolkitObject


class ProxyToolkitDialog(ProxyToolkitObject):
    """ The abstract defintion of a proxy ToolkitDialog object.

    """
    #: A reference to the ToolkitDialog declaration.
    declaration = ForwardTyped(lambda: ToolkitDialog)

    def set_title(self, title):
        raise NotImplementedError

    def show(self):
        raise NotImplementedError

    def open(self):
        raise NotImplementedError

    def exec_(self):
        raise NotImplementedError

    def accept(self):
        raise NotImplementedError

    def reject(self):
        raise NotImplementedError


class ToolkitDialog(ToolkitObject):
    """ A base class for defining toolkit dialogs.

    A toolkit dialog is a dialog where the content is defined by the
    toolkit rather than the user. Customary examples would be a file
    dialog or a color selection dialog, where the implementation can
    often be a native operating system dialog.

    """
    #: The title of the dialog window.
    title = d_(Unicode())

    #: An optional callback which will be invoked when the dialog is
    #: closed. This is a convenience to make it easier to handle a
    #: dialog opened in non-blocking mode. The callback must accept
    #: a single argument, which will be the dialog instance.
    callback = d_(Callable())

    #: Whether to destroy the dialog widget on close. The default is
    #: True since dialogs are typically used in a transitory fashion.
    destroy_on_close = d_(Bool(True))

    #: An event fired if the dialog is accepted. It has no payload.
    accepted = d_(Event(), writable=False)

    #: An event fired when the dialog is rejected. It has no payload.
    rejected = d_(Event(), writable=False)

    #: An event fired when the dialog is finished. The payload is the
    #: boolean result of the dialog.
    finished = d_(Event(bool), writable=False)

    #: Whether or not the dialog was accepted by the user. It will be
    #: updated when the dialog is closed. This value is output only.
    result = Bool(False)

    #: A reference to the ProxyToolkitDialog object.
    proxy = Typed(ProxyToolkitDialog)

    def show(self):
        """ Open the dialog as a non modal dialog.

        """
        if not self.is_initialized:
            self.initialize()
        if not self.proxy_is_active:
            self.activate_proxy()
        self._prepare()
        self.proxy.show()

    def open(self):
        """ Open the dialog as a window modal dialog.

        """
        if not self.is_initialized:
            self.initialize()
        if not self.proxy_is_active:
            self.activate_proxy()
        self._prepare()
        self.proxy.open()

    def exec_(self):
        """ Open the dialog as an application modal dialog.

        Returns
        -------
        result : bool
            Whether or not the dialog was accepted.

        """
        if not self.is_initialized:
            self.initialize()
        if not self.proxy_is_active:
            self.activate_proxy()
        self._prepare()
        self.proxy.exec_()
        return self.result

    def accept(self):
        """ Accept the current state and close the dialog.

        """
        if self.proxy_is_active:
            self.proxy.accept()

    def reject(self):
        """ Reject the current state and close the dialog.

        """
        if self.proxy_is_active:
            self.proxy.reject()

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('title')
    def _update_proxy(self, change):
        """ An observer which updates the proxy when the data changes.

        """
        # The superclass implementation is sufficient.
        super(ToolkitDialog, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def _proxy_finished(self, result):
        """ Called by the proxy object when the dialog is finished.

        Parameters
        ----------
        result : bool
            Wether or not the dialog was accepted.

        """
        self.result = result
        self.finished(result)
        if result:
            self.accepted()
        else:
            self.rejected()
        if self.callback:
            self.callback(self)
        if self.destroy_on_close:
            deferred_call(self.destroy)

    def _prepare(self):
        """ Prepare the dialog to be shown.

        This method can be reimplemented by subclasses.

        """
        self.result = False

########NEW FILE########
__FILENAME__ = toolkit_object
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, Event, Typed, ForwardTyped

from enaml.application import Application
from enaml.core.declarative import Declarative, d_
from enaml.core.object import flag_generator, flag_property


class ProxyToolkitObject(Atom):
    """ The base class of all proxy toolkit objects.

    A ProxyToolkitObject is repsonsible for the communication between
    the Declarative declaration of the object and then implementation
    object which actually performs the behavior.

    Initialization of proxy is backend dependent behavior. Most uses
    will want to initialize the entire proxy tree using traversals
    which are appropriate for their use case. The top level Window
    widget provides a entry point method into the proxy tree for this
    to occur.

    """
    #: A reference to the ToolkitObject declaration.
    declaration = ForwardTyped(lambda: ToolkitObject)

    @property
    def is_active(self):
        """ Test whether or not the proxy is fully activated.

        """
        return self.declaration.proxy_is_active

    def activate_top_down(self):
        """ A method called by the declaration to activate the proxy.

        This method is called in top-down order, during the descent
        phase of the declaration's proxy activation pass.

        """
        pass

    def activate_bottom_up(self):
        """ A method called by the declaration to activate the proxy.

        This method is called in bottom-up order, during the ascent
        phase of the declaration's proxy activation pass.

        """
        pass

    def destroy(self):
        """ Destroy the proxy and any of its resources.

        This method is called by the declaration when it is destroyed.
        It should be reimplemented by subclasses when more control
        is required.

        """
        del self.declaration

    def parent(self):
        """ Get the parent proxy object for this object.

        Returns
        -------
        result : ProxyToolkitObject or None
            The parent toolkit object of this object, or None if no
            such parent exists.

        """
        d = self.declaration.parent
        if isinstance(d, ToolkitObject):
            return d.proxy

    def children(self):
        """ Get the child objects for this object.

        Returns
        -------
        result : generator
            A generator which yields the child proxy objects.

        """
        for d in self.declaration.children:
            if isinstance(d, ToolkitObject):
                yield d.proxy

    def child_added(self, child):
        """ Handle a child being added to the object.

        This method will only be called after the proxy tree is active
        and the UI is running. The default implementation is a no-op.

        Parameters
        ----------
        child : ProxyToolkitObject
            The toolkit proxy child added to the object.

        """
        pass

    def child_removed(self, child):
        """ Handle a child being removed from the object.

        This method will only be called after the proxy tree is active
        and the UI is running. Notably, it will not be called when the
        child is removed because it was destroyed. To handle that case,
        reimplement the 'destroy' method in a subclass. The default
        implementation is a no-op.

        Parameters
        ----------
        child : ProxyToolkitObject
            The toolkit proxy removed the object.

        """
        pass


#: A flag indicating that the object's proxy is ready for use.
ACTIVE_PROXY_FLAG = flag_generator.next()


class ToolkitObject(Declarative):
    """ The base class of all toolkit objects in Enaml.

    """
    #: An event fired when an object's proxy is activated. It is
    #: triggered once during the object lifetime, at the end of the
    #: activate_proxy method.
    activated = d_(Event(), writable=False)

    #: A reference to the ProxyToolkitObject
    proxy = Typed(ProxyToolkitObject)

    #: A property which gets and sets the active proxy flag. This should
    #: not be manipulated directly by user code. This flag will be set to
    #: True by external code after the proxy widget hierarchy is setup.
    proxy_is_active = flag_property(ACTIVE_PROXY_FLAG)

    def initialize(self):
        """ A reimplemented initializer.

        This initializer will invoke the application to create the
        proxy if one has not already been provided.

        """
        if not self.proxy:
            app = Application.instance()
            if app is None:
                msg = 'cannot create a proxy without an active Application'
                raise RuntimeError(msg)
            self.proxy = app.create_proxy(self)
        super(ToolkitObject, self).initialize()

    def destroy(self):
        """ A reimplemented destructor.

        This destructor invokes the 'destroy' method on the proxy
        toolkit object.

        """
        super(ToolkitObject, self).destroy()
        self.proxy_is_active = False
        if self.proxy:
            self.proxy.destroy()
            del self.proxy

    def child_added(self, child):
        """ A reimplemented child added event handler.

        This handler will invoke the superclass handler and then invoke
        the 'child_added()' method on an active proxy.

        """
        super(ToolkitObject, self).child_added(child)
        if isinstance(child, ToolkitObject) and self.proxy_is_active:
            if not child.proxy_is_active:
                child.activate_proxy()
            self.proxy.child_added(child.proxy)

    def child_removed(self, child):
        """ A reimplemented child removed event handler.

        This handler will invoke the superclass handler and then invoke
        the 'child_removed()' method on an active proxy. The method on
        the active proxy will be called even if the child proxy has been
        destroyed.

        """
        super(ToolkitObject, self).child_removed(child)
        if isinstance(child, ToolkitObject) and self.proxy_is_active:
            self.proxy.child_removed(child.proxy)

    def activate_proxy(self):
        """ Activate the proxy object tree.

        This method should be called by a node to activate the proxy
        tree by making two initialization passes over the tree, from
        this node downward. This method is automatically at the proper
        times and should not normally need to be invoked by user code.

        """
        self.activate_top_down()
        for child in self.children:
            if isinstance(child, ToolkitObject):
                child.activate_proxy()
        self.activate_bottom_up()
        self.proxy_is_active = True
        self.activated()

    def activate_top_down(self):
        """ Initialize the proxy on the top-down activation pass.

        By default, this method calls the 'activate_top_down' method on the
        proxy object. It may be reimplemented by subclasses which wish
        to perform toolkit-specific initialization.

        """
        self.proxy.activate_top_down()

    def activate_bottom_up(self):
        """ Initialize the proxy on the bottom-up activation pass.

        By default, this method calls the 'activate_bottom_up' method on the
        proxy object. It may be reimplemented by subclasses which wish
        to perform toolkit-specific initialization.

        """
        self.proxy.activate_bottom_up()

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _update_proxy(self, change):
        """ Update the proxy widget when the Widget data changes.

        This method only updates the proxy when an attribute is updated;
        not when it is created or deleted. It is useful for subclasses
        as a base observer handler

        """
        if change['type'] == 'update' and self.proxy_is_active:
            handler = getattr(self.proxy, 'set_' + change['name'], None)
            if handler is not None:
                handler(change['value'])

########NEW FILE########
__FILENAME__ = tool_bar
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Enum, List, Typed, ForwardTyped, observe

from enaml.core.declarative import d_

from .action import Action
from .action_group import ActionGroup
from .constraints_widget import ConstraintsWidget, ProxyConstraintsWidget


class ProxyToolBar(ProxyConstraintsWidget):
    """ The abstract definition of a proxy ToolBar object.

    """
    #: A reference to the ToolBar declaration.
    declaration = ForwardTyped(lambda: ToolBar)

    def set_button_style(self, style):
        raise NotImplementedError

    def set_movable(self, movable):
        raise NotImplementedError

    def set_floatable(self, floatable):
        raise NotImplementedError

    def set_floating(self, floating):
        raise NotImplementedError

    def set_dock_area(self, area):
        raise NotImplementedError

    def set_allowed_dock_areas(self, areas):
        raise NotImplementedError

    def set_orientation(self, orientation):
        raise NotImplementedError


class ToolBar(ConstraintsWidget):
    """ A widget which displays a row of tool buttons.

    A ToolBar is typically used as a child of a MainWindow where it can
    be dragged and docked in various locations in the same fashion as a
    DockPane. However, a ToolBar can also be used as the child of a
    Container and layed out with constraints, though in this case it will
    lose its ability to be docked.

    """
    #: The button style to apply to actions added to the tool bar.
    button_style = d_(Enum(
        'icon_only', 'text_only', 'text_beside_icon', 'text_under_icon'
    ))

    #: Whether or not the tool bar is movable by the user. This value
    #: only has meaning if the tool bar is the child of a MainWindow.
    movable = d_(Bool(True))

    #: Whether or not the tool bar can be floated as a separate window.
    #: This value only has meaning if the tool bar is the child of a
    #: MainWindow.
    floatable = d_(Bool(True))

    #: A boolean indicating whether or not the tool bar is floating.
    #: This value only has meaning if the tool bar is the child of a
    #: MainWindow.
    floating = d_(Bool(False))

    #: The dock area in the MainWindow where the tool bar is docked.
    #: This value only has meaning if the tool bar is the child of a
    #: MainWindow.
    dock_area = d_(Enum('top', 'right', 'left', 'bottom'))

    #: The areas in the MainWindow where the tool bar can be docked
    #: by the user. This value only has meaning if the tool bar is the
    #: child of a MainWindow.
    allowed_dock_areas = d_(List(
        Enum('top', 'right', 'left', 'bottom', 'all'), ['all'],
    ))

    #: The orientation of the toolbar. This only has meaning when the
    #: toolbar is not a child of a MainWindow and is used as part of
    #: a constraints based layout.
    orientation = d_(Enum('horizontal', 'vertical'))

    #: Whether or not to automatically adjust the 'hug_width' and
    #: 'hug_height' values based on the value of 'orientation'.
    auto_hug = d_(Bool(True))

    #: A reference to the ProxyToolBar object.
    proxy = Typed(ProxyToolBar)

    def items(self):
        """ Get the items defined on the tool bar.

        """
        allowed = (Action, ActionGroup)
        return [c for c in self.children if isinstance(c, allowed)]

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('button_style', 'movable', 'floatable', 'floating', 'dock_area',
        'allowed_dock_areas', 'orientation')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(ToolBar, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # DefaultValue Handlers
    #--------------------------------------------------------------------------
    def _default_hug_width(self):
        """ Get the default hug width for the slider.

        The default hug width is computed based on the orientation.

        """
        if self.orientation == 'horizontal':
            return 'ignore'
        return 'strong'

    def _default_hug_height(self):
        """ Get the default hug height for the slider.

        The default hug height is computed based on the orientation.

        """
        if self.orientation == 'vertical':
            return 'ignore'
        return 'strong'

    #--------------------------------------------------------------------------
    # PostSetAttr Handlers
    #--------------------------------------------------------------------------
    def _post_setattr_orientation(self, old, new):
        """ Post setattr the orientation for the tool bar.

        If auto hug is enabled, the hug values will be updated.

        """
        if self.auto_hug:
            if new == 'vertical':
                self.hug_width = 'strong'
                self.hug_height = 'ignore'
            else:
                self.hug_width = 'ignore'
                self.hug_height = 'strong'

########NEW FILE########
__FILENAME__ = tool_button
#------------------------------------------------------------------------------
# Copyright (c) 2014, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Enum, Typed, ForwardTyped, observe

from enaml.core.declarative import d_

from .abstract_button import AbstractButton, ProxyAbstractButton


class ProxyToolButton(ProxyAbstractButton):
    """ The abstract definition of a proxy ToolButton object.

    """
    #: A reference to the ToolButton declaration.
    declaration = ForwardTyped(lambda: ToolButton)

    def set_button_style(self, style):
        raise NotImplementedError

    def set_auto_raise(self, auto):
        raise NotImplementedError

    def set_popup_mode(self, mode):
        raise NotImplementedError


class ToolButton(AbstractButton):
    """ A widget for creating tool bar buttons.

    A ToolButton can be declared as the child of a ToolBar or used as
    a regular widget in a constraints layout. It supports an optional
    child Menu object which will open when the button is clicked
    according the specified popup mode.

    """
    #: The button style to apply to this tool button.
    button_style = d_(Enum(
        'icon_only', 'text_only', 'text_beside_icon', 'text_under_icon'
    ))

    #: Whether or not auto-raise is enabled for the button.
    auto_raise = d_(Bool(True))

    #: The mode for diplaying a child popup menu.
    popup_mode = d_(Enum('delayed', 'button', 'instant'))

    #: A reference to the ProxyToolButton object.
    proxy = Typed(ProxyToolButton)

    @observe('button_style', 'auto_raise', 'popup_mode')
    def _update_proxy(self, change):
        """ An observer which updates the proxy when the ToolButton changes.

        """
        # The superclass implementation is sufficient
        super(ToolButton, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = vtk_canvas
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import (
    List, Typed, ForwardTyped, ForwardInstance, observe, set_default
)

from enaml.core.declarative import d_

from .control import Control, ProxyControl


#: Delay the import of vtk until needed. This removes the hard dependecy
#: on vtk for the rest of the Enaml code base.
def vtkRenderer():
    from vtk import vtkRenderer
    return vtkRenderer


class ProxyVTKCanvas(ProxyControl):
    """ The abstract definition of a proxy VTKCanvas object.

    """
    #: A reference to the VTKCanvas declaration.
    declaration = ForwardTyped(lambda: VTKCanvas)

    def set_renderer(self, renderer):
        raise NotImplementedError

    def set_renderers(self, renderers):
        raise NotImplementedError

    def render(self):
        raise NotImplementedError


class VTKCanvas(Control):
    """ A control which can be used to embded vtk renderers.

    """
    #: The vtk renderer to display in the window. This should be used
    #: if only a single renderer is required for the scene.
    renderer = d_(ForwardInstance(vtkRenderer))

    #: The list of vtk renderers to display in the window. This should
    #: be used if multiple renderers are required for the scene.
    renderers = d_(List(ForwardInstance(vtkRenderer)))

    #: A VTKCanvas expands freely in height and width by default.
    hug_width = set_default('ignore')
    hug_height = set_default('ignore')

    #: A reference to the ProxyVTKCanvas object.
    proxy = Typed(ProxyVTKCanvas)

    def render(self):
        """ Request a render of the underlying scene.

        """
        if self.proxy_is_active:
            self.proxy.render()

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('renderer', 'renderers')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(VTKCanvas, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = v_group
#------------------------------------------------------------------------------
# Copyright (c) 2014, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Int, Typed, observe

from enaml.core.declarative import d_
from enaml.layout.layout_helpers import align, vbox
from enaml.layout.spacers import Spacer

from .container import Container


class VGroup(Container):
    """ A Container subclass which groups child widgets vertically.

    User constraints are applied *in addition* to the vertical group
    constraints. Widgets are aligned along their left edge.

    """
    #: The vertical spacing to place between widgets.
    spacing = d_(Int(10))

    #: The optional spacer to add as the first layout item.
    leading_spacer = d_(Typed(Spacer))

    #: The optional spacer to add as the last layout item.
    trailing_spacer = d_(Typed(Spacer))

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('spacing', 'leading_spacer', 'trailing_spacer')
    def _layout_invalidated(self, change):
        """ A private observer which invalidates the layout.

        """
        # The superclass handler is sufficient.
        super(VGroup, self)._layout_invalidated(change)

    #--------------------------------------------------------------------------
    # Layout Constraints
    #--------------------------------------------------------------------------
    def layout_constraints(self):
        """ The constraints generation for a VGroup.

        This method supplies left-aligned vertical group constraints for
        the children of the container in addition to any user-supplied
        constraints.

        This method cannot be overridden from Enaml syntax.

        """
        widgets = self.visible_widgets()
        items = [self.leading_spacer] + widgets + [self.trailing_spacer]
        cns = self.constraints[:]
        cns.append(vbox(*items, spacing=self.spacing))
        cns.append(align('left', *widgets))
        return cns

########NEW FILE########
__FILENAME__ = web_view
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Unicode, Typed, ForwardTyped, observe, set_default

from enaml.core.declarative import d_

from .control import Control, ProxyControl


class ProxyWebView(ProxyControl):
    """ The abstract definition of a proxy WebView object.

    """
    #: A reference to the WebView declaration.
    declaration = ForwardTyped(lambda: WebView)

    def set_url(self, url):
        raise NotImplementedError

    def set_html(self, html):
        raise NotImplementedError


class WebView(Control):
    """ A widget which displays a web page.

    Unlike the simpler `Html` widget, this widget supports the features
    of a full web browser.

    """
    #: The URL to load in the web view. This can be a path to a remote
    #: resource or a path to a file on the local filesystem. This value
    #: is mutually exclusive of `html`.
    url = d_(Unicode())

    #: The html to load into the web view. This value is mutually
    #: exclusive of `url`.
    html = d_(Unicode())

    #: The base url for loading content in statically supplied 'html'.
    base_url = d_(Unicode())

    #: A web view expands freely in height and width by default.
    hug_width = set_default('ignore')
    hug_height = set_default('ignore')

    #: A reference to the ProxyWebView object.
    proxy = Typed(ProxyWebView)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('url', 'html')
    def _update_proxy(self, change):
        """ An observer which sends state change to the proxy.

        """
        # The superclass handler implementation is sufficient.
        super(WebView, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = widget
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import (
    Bool, Enum, IntEnum, Unicode, Coerced, Typed, ForwardTyped, observe
)

from enaml.colors import ColorMember
from enaml.core.declarative import d_, d_func
from enaml.fonts import FontMember
from enaml.layout.geometry import Size
from enaml.styling import Stylable

from .toolkit_object import ToolkitObject, ProxyToolkitObject


class ProxyWidget(ProxyToolkitObject):
    """ The abstract definition of a proxy Widget object.

    """
    #: A reference to the Widget declaration.
    declaration = ForwardTyped(lambda: Widget)

    def set_enabled(self, enabled):
        raise NotImplementedError

    def set_visible(self, visible):
        raise NotImplementedError

    def set_background(self, background):
        raise NotImplementedError

    def set_foreground(self, foreground):
        raise NotImplementedError

    def set_font(self, font):
        raise NotImplementedError

    def set_minimum_size(self, minimum_size):
        raise NotImplementedError

    def set_maximum_size(self, maximum_size):
        raise NotImplementedError

    def set_tool_tip(self, tool_tip):
        raise NotImplementedError

    def set_status_tip(self, status_tip):
        raise NotImplementedError

    def ensure_visible(self):
        raise NotImplementedError

    def ensure_hidden(self):
        raise NotImplementedError

    def restyle(self):
        raise NotImplementedError

    def set_focus(self):
        raise NotImplementedError

    def clear_focus(self):
        raise NotImplementedError

    def has_focus(self):
        raise NotImplementedError

    def focus_next_child(self):
        raise NotImplementedError

    def focus_previous_child(self):
        raise NotImplementedError


class Feature(IntEnum):
    """ An IntEnum defining the advanced widget features.

    """
    #: Enables support for custom focus traversal functions.
    FocusTraversal = 0x1

    #: Enables support for focus events.
    FocusEvents = 0x2


class Widget(ToolkitObject, Stylable):
    """ The base class of visible widgets in Enaml.

    """
    #: Whether or not the widget is enabled.
    enabled = d_(Bool(True))

    #: Whether or not the widget is visible.
    visible = d_(Bool(True))

    #: The background color of the widget.
    background = d_(ColorMember())

    #: The foreground color of the widget.
    foreground = d_(ColorMember())

    #: The font used for the widget.
    font = d_(FontMember())

    #: The minimum size for the widget. The default means that the
    #: client should determine an intelligent minimum size.
    minimum_size = d_(Coerced(Size, (-1, -1)))

    #: The maximum size for the widget. The default means that the
    #: client should determine an intelligent maximum size.
    maximum_size = d_(Coerced(Size, (-1, -1)))

    #: The tool tip to show when the user hovers over the widget.
    tool_tip = d_(Unicode())

    #: The status tip to show when the user hovers over the widget.
    status_tip = d_(Unicode())

    #: Set the extra features to enable for this widget. This value must
    #: be provided when the widget is instantiated. Runtime changes to
    #: this value are ignored.
    features = d_(Coerced(Feature.Flags))

    #: A reference to the ProxyWidget object.
    proxy = Typed(ProxyWidget)

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('enabled', 'visible', 'background', 'foreground', 'font',
        'minimum_size', 'maximum_size', 'tool_tip', 'status_tip')
    def _update_proxy(self, change):
        """ Update the proxy widget when the Widget data changes.

        This method only updates the proxy when an attribute is updated;
        not when it is created or deleted.

        """
        # The superclass implementation is sufficient.
        super(Widget, self)._update_proxy(change)

    #--------------------------------------------------------------------------
    # Reimplementations
    #--------------------------------------------------------------------------
    def restyle(self):
        """ Restyle the toolkit widget.

        This method is invoked by the Stylable class when the style
        dependencies have changed for the widget. This will trigger a
        proxy restyle if necessary. This method should not typically be
        called directly by user code.

        """
        if self.proxy_is_active:
            self.proxy.restyle()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def show(self):
        """ Ensure the widget is shown.

        Calling this method will also set the widget visibility to True.

        """
        self.visible = True
        if self.proxy_is_active:
            self.proxy.ensure_visible()

    def hide(self):
        """ Ensure the widget is hidden.

        Calling this method will also set the widget visibility to False.

        """
        self.visible = False
        if self.proxy_is_active:
            self.proxy.ensure_hidden()

    def set_focus(self):
        """ Set the keyboard input focus to this widget.

        FOR ADVANCED USE CASES ONLY: DO NOT ABUSE THIS!

        """
        if self.proxy_is_active:
            self.proxy.set_focus()

    def clear_focus(self):
        """ Clear the keyboard input focus from this widget.

        FOR ADVANCED USE CASES ONLY: DO NOT ABUSE THIS!

        """
        if self.proxy_is_active:
            self.proxy.clear_focus()

    def has_focus(self):
        """ Test whether this widget has input focus.

        FOR ADVANCED USE CASES ONLY: DO NOT ABUSE THIS!

        Returns
        -------
        result : bool
            True if this widget has input focus, False otherwise.

        """
        if self.proxy_is_active:
            return self.proxy.has_focus()
        return False

    def focus_next_child(self):
        """ Give focus to the next widget in the focus chain.

        FOR ADVANCED USE CASES ONLY: DO NOT ABUSE THIS!

        """
        if self.proxy_is_active:
            self.proxy.focus_next_child()

    def focus_previous_child(self):
        """ Give focus to the previous widget in the focus chain.

        FOR ADVANCED USE CASES ONLY: DO NOT ABUSE THIS!

        """
        if self.proxy_is_active:
            self.proxy.focus_previous_child()

    @d_func
    def next_focus_child(self, current):
        """ Compute the next widget which should gain focus.

        When the FocusTraversal feature of the widget is enabled, this
        method will be invoked as a result of a Tab key press or from
        a call to the 'focus_next_child' method on a decendant of the
        owner widget. It should be reimplemented in order to provide
        custom logic for computing the next focus widget.

        ** The FocusTraversal feature must be enabled for the widget in
        order for this method to be called. **

        Parameters
        ----------
        current : Widget or None
            The current widget with input focus, or None if no widget
            has focus or if the toolkit widget with focus does not
            correspond to an Enaml widget.

        Returns
        -------
        result : Widget or None
            The next widget which should gain focus, or None to follow
            the default toolkit behavior.

        """
        return None

    @d_func
    def previous_focus_child(self, current):
        """ Compute the previous widget which should gain focus.

        When the FocusTraversal feature of the widget is enabled, this
        method will be invoked as a result of a Shift+Tab key press or
        from a call to the 'focus_prev_child' method on a decendant of
        the owner widget. It should be reimplemented in order to provide
        custom logic for computing the previous focus widget.

        ** The FocusTraversal feature must be enabled for the widget in
        order for this method to be called. **

        Parameters
        ----------
        current : Widget or None
            The current widget with input focus, or None if no widget
            has focus or if the toolkit widget with focus does not
            correspond to an Enaml widget.

        Returns
        -------
        result : Widget or None
            The previous widget which should gain focus, or None to
            follow the default toolkit behavior.

        """
        return None

    @d_func
    def focus_gained(self):
        """ A method invoked when the widget gains input focus.

        ** The FocusEvents feature must be enabled for the widget in
        order for this method to be called. **

        """
        pass

    @d_func
    def focus_lost(self):
        """ A method invoked when the widget loses input focus.

        ** The FocusEvents feature must be enabled for the widget in
        order for this method to be called. **

        """
        pass

########NEW FILE########
__FILENAME__ = window
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import (
    Atom, Unicode, Enum, Bool, Event, Coerced, Typed, ForwardTyped, observe,
    set_default
)

from enaml.core.declarative import d_
from enaml.icon import Icon
from enaml.layout.geometry import Pos, Rect, Size

from .container import Container
from .widget import Widget, ProxyWidget


class ProxyWindow(ProxyWidget):
    """ The abstract definition of a proxy Window object.

    """
    #: A reference to the Window declaration.
    declaration = ForwardTyped(lambda: Window)

    def set_title(self, title):
        raise NotImplementedError

    def set_modality(self, modality):
        raise NotImplementedError

    def set_icon(self, icon):
        raise NotImplementedError

    def position(self):
        raise NotImplementedError

    def set_position(self, pos):
        raise NotImplementedError

    def size(self):
        raise NotImplementedError

    def set_size(self, size):
        raise NotImplementedError

    def geometry(self):
        raise NotImplementedError

    def set_geometry(self, rect):
        raise NotImplementedError

    def frame_geometry(self):
        raise NotImplementedError

    def minimize(self):
        raise NotImplementedError

    def is_minimized(self):
        raise NotImplementedError

    def maximize(self):
        raise NotImplementedError

    def is_maximized(self):
        raise NotImplementedError

    def restore(self):
        raise NotImplementedError

    def send_to_front(self):
        raise NotImplementedError

    def send_to_back(self):
        raise NotImplementedError

    def activate_window(self):
        raise NotImplementedError

    def center_on_screen(self):
        raise NotImplementedError

    def center_on_widget(self, other):
        raise NotImplementedError

    def close(self):
        raise NotImplementedError


class CloseEvent(Atom):
    """ An payload object carried by a window 'closing' event.

    User code can manipulate this object to veto a close event.

    """
    #: The internal accepted state.
    _accepted = Bool(True)

    def is_accepted(self):
        """ Get whether or not the event is accepted.

        Returns
        -------
        result : bool
            True if the event is accepted, False otherwise. The
            default is True.

        """
        return self._accepted

    def accept(self):
        """ Accept the close event and allow the window to be closed.

        """
        self._accepted = True

    def ignore(self):
        """ Reject the close event and prevent the window from closing.

        """
        self._accepted = False


class Window(Widget):
    """ A top-level Window component.

    A Window component is represents of a top-level visible component
    with a frame decoration. It may have at most one child widget which
    is dubbed the 'central widget'. The central widget is an instance
    of Container and is expanded to fit the size of the window.

    A Window does not support features like MenuBars or DockPanes, for
    such functionality, use a MainWindow widget.

    """
    #: A static set of windows being used by the application. A window
    #: adds itself to this list when it is initialized, and removes
    #: itself when it is destroyed. This allows toplevel windows with
    #: no parent to persist without any other strong references.
    windows = set()

    #: The titlebar text.
    title = d_(Unicode())

    #: The initial position of the window frame. A value of (-1, -1)
    #: indicates that the toolkit should choose the initial position.
    initial_position = d_(Coerced(Pos, (-1, -1)))

    #: The initial size of the window client area. A value of (-1, -1)
    #: indicates that the toolkit should choose the initial size.
    initial_size = d_(Coerced(Size, (-1, -1)))

    #: An enum which indicates the modality of the window. The default
    #: value is 'non_modal'.
    modality = d_(Enum('non_modal', 'application_modal', 'window_modal'))

    #: If this value is set to True, the window will be destroyed on
    #: the completion of the `closed` event.
    destroy_on_close = d_(Bool(True))

    #: The title bar icon.
    icon = d_(Typed(Icon))

    #: Whether the window styas on top of other windows on the desktop.
    #: Changes to this value after the window is shown will be ignored.
    always_on_top = d_(Bool(False))

    #: An event fired when the user request the window to be closed.
    #: This will happen when the user clicks on the "X" button in the
    #: title bar button, or when the 'close' method is called. The
    #: payload will be a CloseEvent object which will allow code to
    #: veto the close event and prevent the window from closing.
    closing = d_(Event(CloseEvent), writable=False)

    #: An event fired when the window is closed.
    closed = d_(Event(), writable=False)

    #: Windows are invisible by default.
    visible = set_default(False)

    #: A reference to the ProxyWindow object.
    proxy = Typed(ProxyWindow)

    def initialize(self):
        """ An overridden initializer method.

        This method adds the window to the static set of Windows.

        """
        super(Window, self).initialize()
        Window.windows.add(self)

    def destroy(self):
        """ An overridden destructor method.

        This method removes the window from the static set of Windows.

        """
        super(Window, self).destroy()
        Window.windows.discard(self)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def central_widget(self):
        """ Get the central widget defined on the window.

        The last `Container` child of the window is the central widget.

        """
        for child in reversed(self.children):
            if isinstance(child, Container):
                return child

    def position(self):
        """ Get the position of the window frame.

        Returns
        -------
        result : Pos
            The current position of the window frame.

        """
        if self.proxy_is_active:
            return self.proxy.position()
        return Pos(-1, -1)

    def set_position(self, pos):
        """ Set the position of the window frame.

        Parameters
        ----------
        pos : Pos
            The desired position of the window the window frame.

        """
        if self.proxy_is_active:
            self.proxy.set_position(pos)

    def size(self):
        """ Get the size of the window client area.

        Returns
        -------
        result : Size
            The current size of the window client area.

        """
        if self.proxy_is_active:
            return self.proxy.size()
        return Size(-1, -1)

    def set_size(self, size):
        """ Set the size of the window client area.

        Parameters
        ----------
        size : Size
            The desired size of the window client area.

        """
        if self.proxy_is_active:
            self.proxy.set_size(size)

    def geometry(self):
        """ Get the geometry of the window client area.

        Returns
        -------
        result : Rect
            The current geometry of the window client area.

        """
        if self.proxy_is_active:
            return self.proxy.geometry()
        return Rect(-1, -1, -1, -1)

    def set_geometry(self, rect):
        """ Set the geometry of the window client area.

        Parameters
        ----------
        rect : Rect
            The desired geometry of the window client area.

        """
        if self.proxy_is_active:
            self.proxy.set_geometry(rect)

    def frame_geometry(self):
        """ Get the geometry of the window frame.

        Returns
        -------
        result : Rect
            The current geometry of the window frame.

        """
        if self.proxy_is_active:
            return self.proxy.frame_geometry()
        return Rect(-1, -1, -1, -1)

    def maximize(self):
        """ Maximize the window.

        """
        if self.proxy_is_active:
            self.proxy.maximize()

    def is_maximized(self):
        """ Get whether the window is maximized.

        """
        if self.proxy_is_active:
            return self.proxy.is_maximized()
        return False

    def minimize(self):
        """ Minimize the window.

        """
        if self.proxy_is_active:
            self.proxy.minimize()

    def is_minimized(self):
        """ Get whether the window is minimized.

        """
        if self.proxy_is_active:
            return self.proxy.is_minimized()
        return False

    def restore(self):
        """ Restore the window from a maximized or minimized state.

        """
        if self.proxy_is_active:
            self.proxy.restore()

    def send_to_front(self):
        """ Send the window to the top of the Z-order.

        This will only affect the Z-order of the window relative to the
        Z-order of other windows in the same application.

        """
        if self.proxy_is_active:
            self.proxy.send_to_front()

    def send_to_back(self):
        """ Send the window to the bottom of the Z-order.

        This will only affect the Z-order of the window relative to the
        Z-order of other windows in the same application.

        """
        if self.proxy_is_active:
            self.proxy.send_to_back()

    def activate_window(self):
        """ Set this window to be the active application window.

        This performs the same operation as clicking the mouse on the
        title bar of the window, except that it will not effect the Z
        order of the window.

        On Windows, this will cause the taskbar icon to flash if the
        window does not belong to the active application.

        """
        if self.proxy_is_active:
            self.proxy.activate_window()

    def center_on_screen(self):
        """ Center the window on the screen.

        """
        if self.proxy_is_active:
            self.proxy.center_on_screen()

    def center_on_widget(self, other):
        """ Center this window on another widget.

        Parameters
        ----------
        other : Widget
            The widget onto which to center this window.

        """
        assert isinstance(other, Widget)
        if self.proxy_is_active and other.proxy_is_active:
            self.proxy.center_on_widget(other)

    def close(self):
        """ Close the window.

        This will cause the window to be hidden, the 'closed' event
        to be fired, and the window subsequently destroyed.

        """
        if self.proxy_is_active:
            self.proxy.close()

    def show(self):
        """ Show the window to the screen.

        This is a reimplemented parent class method which will init
        and build the window hierarchy if needed.

        """
        if not self.is_initialized:
            self.initialize()
        if not self.proxy_is_active:
            self.activate_proxy()
        super(Window, self).show()

    #--------------------------------------------------------------------------
    # Observers
    #--------------------------------------------------------------------------
    @observe('title', 'modality', 'icon')
    def _update_proxy(self, change):
        """ Update the ProxyWindow when the Window data changes.

        """
        # The superclass handler implementation is sufficient.
        super(Window, self)._update_proxy(change)

########NEW FILE########
__FILENAME__ = api
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from .extension import Extension
from .extension_point import ExtensionPoint
from .plugin import Plugin
from .plugin_manifest import PluginManifest
from .workbench import Workbench

########NEW FILE########
__FILENAME__ = api
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from .command import Command

########NEW FILE########
__FILENAME__ = command
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Callable, Unicode

from enaml.core.declarative import Declarative, d_


class Command(Declarative):
    """ A declarative class for defining a workbench command.

    """
    #: The globally unique identifier for the command.
    id = d_(Unicode())

    #: An optional description of the command.
    description = d_(Unicode())

    #: A required callable which handles the command. It must accept a
    #: single argument, which is an instance of ExecutionEvent.
    handler = d_(Callable())

########NEW FILE########
__FILENAME__ = core_plugin
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from collections import defaultdict

from atom.api import Typed

from enaml.workbench.plugin import Plugin

from .command import Command
from .execution_event import ExecutionEvent


COMMANDS_POINT = u'enaml.workbench.core.commands'


class CorePlugin(Plugin):
    """ The core plugin for the Enaml workbench.

    """
    def start(self):
        """ Start the plugin life-cycle.

        This method is called by the framework at the appropriate time.
        It should never be called by user code.

        """
        self._refresh_commands()
        self._bind_observers()

    def stop(self):
        """ Stop the plugin life-cycle.

        This method is called by the framework at the appropriate time.
        It should never be called by user code.

        """
        self._unbind_observers()
        self._commands.clear()
        self._command_extensions.clear()

    def invoke_command(self, command_id, parameters={}, trigger=None):
        """ Invoke the command handler for the given command id.

        Parameters
        ----------
        command_id : unicode
            The unique identifier of the command to invoke.

        parameters : dict, optional
            The parameters to pass to the command handler.

        trigger : object, optional
            The object which triggered the command.

        Returns
        -------
        result : object
            The return value of the command handler.

        """
        if command_id not in self._commands:
            msg = "'%s' is not a registered command id"
            raise ValueError(msg % command_id)

        command = self._commands[command_id]

        event = ExecutionEvent()
        event.command = command
        event.workbench = self.workbench
        event.parameters = parameters  # copied on assignment
        event.trigger = trigger

        return command.handler(event)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    #: The mapping of command id to Command object.
    _commands = Typed(dict, ())

    #: The mapping of extension object to list of Command objects.
    _command_extensions = Typed(defaultdict, (list,))

    def _refresh_commands(self):
        """ Refresh the command objects for the plugin.

        """
        workbench = self.workbench
        point = workbench.get_extension_point(COMMANDS_POINT)
        extensions = point.extensions
        if not extensions:
            self._commands.clear()
            self._command_extensions.clear()
            return

        new_extensions = defaultdict(list)
        old_extensions = self._command_extensions
        for extension in extensions:
            if extension in old_extensions:
                commands = old_extensions[extension]
            else:
                commands = self._load_commands(extension)
            new_extensions[extension].extend(commands)

        commands = {}
        for extension in extensions:
            for command in new_extensions[extension]:
                if command.id in commands:
                    msg = "command '%s' is already registered"
                    raise ValueError(msg % command.id)
                if command.handler is None:
                    msg = "command '%s' does not declare a handler"
                    raise ValueError(msg % command.id)
                commands[command.id] = command

        self._commands = commands
        self._command_extensions = new_extensions

    def _load_commands(self, extension):
        """ Load the command objects for the given extension.

        Parameters
        ----------
        extension : Extension
            The extension object of interest.

        Returns
        -------
        result : list
            The list of Command objects declared by the extension.

        """
        workbench = self.workbench
        commands = extension.get_children(Command)
        if extension.factory is not None:
            for item in extension.factory(workbench):
                if not isinstance(item, Command):
                    msg = "extension '%s' created non-Command of type '%s'"
                    args = (extension.qualified_id, type(item).__name__)
                    raise TypeError(msg % args)
                commands.append(item)
        return commands

    def _on_commands_updated(self, change):
        """ The observer for the commands extension point.

        """
        self._refresh_commands()

    def _bind_observers(self):
        """ Setup the observers for the plugin.

        """
        workbench = self.workbench
        point = workbench.get_extension_point(COMMANDS_POINT)
        point.observe('extensions', self._on_commands_updated)

    def _unbind_observers(self):
        """ Remove the observers for the plugin.

        """
        workbench = self.workbench
        point = workbench.get_extension_point(COMMANDS_POINT)
        point.unobserve('extensions', self._on_commands_updated)

########NEW FILE########
__FILENAME__ = execution_event
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, Dict, Typed, Value

from enaml.workbench.workbench import Workbench

from .command import Command


class ExecutionEvent(Atom):
    """ The object passed to a command handler when it is invoked.

    """
    #: The command which is being invoked.
    command = Typed(Command)

    #: The workbench instance which owns the command.
    workbench = Typed(Workbench)

    #: The user-supplied parameters for the command.
    parameters = Dict()

    #: The user-object object which triggered the command.
    trigger = Value()

########NEW FILE########
__FILENAME__ = extension
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Callable, Int, Unicode

from enaml.core.declarative import Declarative, d_


class Extension(Declarative):
    """ A declarative class which represents a plugin extension.

    An Extension must be declared as a child of a PluginManifest.

    """
    #: The globally unique identifier for the extension.
    id = d_(Unicode())

    #: The fully qualified id of the target extension point.
    point = d_(Unicode())

    #: An optional rank to use for order the extension among others.
    rank = d_(Int())

    #: A callable which will create the implementation object for the
    #: extension point. The call signature and return type are defined
    #: by the extension point plugin which invokes the factory.
    factory = d_(Callable())

    #: An optional description of the extension.
    description = d_(Unicode())

    @property
    def plugin_id(self):
        """ Get the plugin id from the parent plugin manifest.

        """
        return self.parent.id

    @property
    def qualified_id(self):
        """ Get the fully qualified extension identifer.

        """
        this_id = self.id
        if u'.' in this_id:
            return this_id
        return u'%s.%s' % (self.plugin_id, this_id)

    def get_child(self, kind, reverse=False):
        """ Find a child by the given type.

        Parameters
        ----------
        kind : type
            The declarative type of the child of interest.

        reverse : bool, optional
            Whether to search in reversed order. The default is False.

        Returns
        -------
        result : child or None
            The first child found of the requested type.

        """
        it = reversed if reverse else iter
        for child in it(self.children):
            if isinstance(child, kind):
                return child
        return None

    def get_children(self, kind):
        """ Get all the children of the given type.

        Parameters
        ----------
        kind : type
            The declarative type of the children of interest.

        Returns
        -------
        result : list
            The list of children of the request type.

        """
        return [c for c in self.children if isinstance(c, kind)]

########NEW FILE########
__FILENAME__ = extension_point
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Tuple, Unicode

from enaml.core.declarative import Declarative, d_


class ExtensionPoint(Declarative):
    """ A declarative class which represents a pulgin extension point.

    An ExtensionPoint must be declared as a child of a PluginManifest.

    """
    #: The globally unique identifier for the extension point.
    id = d_(Unicode())

    #: The tuple of extensions contributed to this extension point. The
    #: tuple is updated by the framework as needed. It is kept in sorted
    #: order from lowest to highest extension rank. This should never be
    #: modified directly by user code.
    extensions = Tuple()

    #: An optional description of the extension point.
    description = d_(Unicode())

    @property
    def plugin_id(self):
        """ Get the plugin id from the parent plugin manifest.

        """
        return self.parent.id

    @property
    def qualified_id(self):
        """ Get the fully qualified extension point identifer.

        """
        this_id = self.id
        if u'.' in this_id:
            return this_id
        return u'%s.%s' % (self.plugin_id, this_id)

########NEW FILE########
__FILENAME__ = plugin
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, Typed

from .plugin_manifest import PluginManifest


class Plugin(Atom):
    """ A base class for defining workbench plugins.

    """
    #: A reference to the plugin manifest instance which declared the
    #: plugin. This is assigned by the framework and should never be
    #: manipulated by user code.
    manifest = Typed(PluginManifest)

    @property
    def workbench(self):
        """ Get the workbench which is handling the plugin.

        """
        return self.manifest.workbench

    def start(self):
        """ Start the life-cycle of the plugin.

        This method will be called by the workbench after it creates
        the plugin. The default implementation does nothing and can be
        ignored by subclasses which do not need life-cycle behavior.

        This method should never be called by user code.

        """
        pass

    def stop(self):
        """ Stop the life-cycle of the plugin.

        This method will be called by the workbench when the plugin is
        removed. The default implementation does nothing and can be
        ignored by subclasses which do not need life-cycle behavior.

        This method should never be called by user code.

        """
        pass

########NEW FILE########
__FILENAME__ = plugin_manifest
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Callable, ForwardTyped, Unicode

from enaml.core.declarative import Declarative, d_

from .extension import Extension
from .extension_point import ExtensionPoint


def Workbench():
    """ A lazy forward import function for the Workbench type.

    """
    from .workbench import Workbench
    return Workbench


def plugin_factory():
    """ A factory function which returns a plain Plugin instance.

    """
    from .plugin import Plugin
    return Plugin()


class PluginManifest(Declarative):
    """ A declarative class which represents a plugin manifest.

    """
    #: The globally unique identifier for the plugin. The suggested
    #: format is dot-separated, e.g. 'foo.bar.baz'.
    id = d_(Unicode())

    #: The factory which will create the Plugin instance. It should
    #: take no arguments and return an instance of Plugin. Well behaved
    #: applications will make this a function which lazily imports the
    #: plugin class so that startup times remain small.
    factory = d_(Callable(plugin_factory))

    #: The workbench instance with which this manifest is registered.
    #: This is assigned by the framework and should not be manipulated
    #: by user code.
    workbench = ForwardTyped(Workbench)

    #: An optional description of the plugin.
    description = d_(Unicode())

    @property
    def extensions(self):
        """ Get the list of extensions defined by the manifest.

        """
        return [c for c in self.children if isinstance(c, Extension)]

    @property
    def extension_points(self):
        """ Get the list of extensions points defined by the manifest.

        """
        return [c for c in self.children if isinstance(c, ExtensionPoint)]

########NEW FILE########
__FILENAME__ = action_item
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Dict, Typed, Unicode

from enaml.core.declarative import Declarative, d_
from enaml.icon import Icon


class ActionItem(Declarative):
    """ A declarative class for defining a workbench action item.

    """
    #: The "/" separated path to this item in the menu bar.
    path = d_(Unicode())

    #: The parent menu group to which this action item belongs.
    group = d_(Unicode())

    #: The action item will appear before this item in its group.
    before = d_(Unicode())

    #: The action item will appear after this item in its group.
    after = d_(Unicode())

    #: The id of the Command invoked by the action.
    command = d_(Unicode())

    #: The user parameters to pass to the command handler.
    parameters = d_(Dict())

    #: The display label for the action.
    label = d_(Unicode())

    #: The shortcut keybinding for the action. e.g. Ctrl+C
    shortcut = d_(Unicode())

    #: Whether or not the action is visible.
    visible = d_(Bool(True))

    #: Whether or not the action is enabled.
    enabled = d_(Bool(True))

    #: Whether or not the action is checkable.
    checkable = d_(Bool(False))

    #: Whether or not the checkable action is checked.
    checked = d_(Bool(False))

    #: The default display icon for the action.
    icon = d_(Typed(Icon))

    #: The tooltip for the action.
    tool_tip = d_(Unicode())

    #: The statustip for the action.
    status_tip = d_(Unicode())

########NEW FILE########
__FILENAME__ = api
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from .action_item import ActionItem
from .autostart import Autostart
from .branding import Branding
from .item_group import ItemGroup
from .menu_item import MenuItem
from .ui_workbench import UIWorkbench
from .workspace import Workspace

########NEW FILE########
__FILENAME__ = autostart
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Unicode

from enaml.core.declarative import Declarative, d_


class Autostart(Declarative):
    """ A declarative object for use with auto start extensions.

    """
    #: The id of the plugin which should be preemptively started.
    plugin_id = d_(Unicode())

########NEW FILE########
__FILENAME__ = branding
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed, Unicode

from enaml.core.declarative import Declarative, d_
from enaml.icon import Icon


class Branding(Declarative):
    """ A declarative class for defining window branding.

    """
    #: The primary title of the workbench window.
    title = d_(Unicode())

    #: The icon for the workbench window.
    icon = d_(Typed(Icon))

########NEW FILE########
__FILENAME__ = item_group
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Unicode

from enaml.core.declarative import Declarative, d_


class ItemGroup(Declarative):
    """ A declarative class for defining an item group in a menu.

    """
    #: The identifier of group within the menu.
    id = d_(Unicode())

    #: Whether or not the group is visible.
    visible = d_(Bool(True))

    #: Whether or not the group is enabled.
    enabled = d_(Bool(True))

    #: Whether or not checkable ations in the group are exclusive.
    exclusive = d_(Bool(False))

########NEW FILE########
__FILENAME__ = menu_helper
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from collections import defaultdict

from atom.api import Atom, Instance, List, Typed

import kiwisolver as kiwi

from enaml.widgets.action import Action
from enaml.workbench.workbench import Workbench

from .action_item import ActionItem
from .item_group import ItemGroup
from .menu_item import MenuItem

import enaml
with enaml.imports():
    from .workbench_menus import (
        WorkbenchAction, WorkbenchActionGroup, WorkbenchMenu
    )


def solve_ordering(nodes):
    """ Solve for the desired order of the list of nodes.

    This function is an implementation detail and should not be
    consumed by code outside of this module.

    Parameters
    ----------
    nodes : list
        The list of PathNode objects which should be ordered. It
        is assumed that all nodes reside in the same group.

    Returns
    -------
    result : list
        The PathNode objects ordered according to the constraints
        specified by the 'before' and 'after' items attributes.

    """
    variables = {}
    for node in nodes:
        variables[node.id] = kiwi.Variable(str(node.id))

    prev_var = None
    constraints = []
    for node in nodes:
        this_var = variables[node.id]
        constraints.append(this_var >= 0)
        if prev_var is not None:  # weakly preserve relative order
            constraints.append((prev_var + 0.1 <= this_var) | 'weak')
        before = node.item.before
        if before:
            if before not in variables:
                msg = "item '%s' has invalid `before` reference '%s'"
                raise ValueError(msg % (node.path, before))
            target_var = variables[before]
            constraints.append((this_var + 0.1 <= target_var) | 'strong')
        after = node.item.after
        if after:
            if after not in variables:
                msg = "item '%s' has invalid `after` reference '%s'"
                raise ValueError(msg % (node.path, after))
            target_var = variables[after]
            constraints.append((target_var + 0.1 <= this_var) | 'strong')
        prev_var = this_var

    solver = kiwi.Solver()
    for cn in constraints:
        solver.addConstraint(cn)
    solver.updateVariables()

    flat = []
    for node in nodes:
        node_var = variables[node.id]
        flat.append((node_var.value(), node))
    flat.sort()

    return [pair[1] for pair in flat]


class PathNode(Atom):
    """ The base class for the menu building nodes.

    This class is an implementation detail and should not be consumed
    by code outside of this module.

    """
    #: The declarative item for the node.
    item = Instance((MenuItem, ActionItem))

    @property
    def path(self):
        """ Get the sanitized path for the node.

        """
        path = self.item.path.rstrip(u'/')
        if not path:
            return u'/'
        if path[0] != u'/':
            return u'/' + path
        return path

    @property
    def parent_path(self):
        """ Get the sanitized path of the parent node.

        """
        path = self.path.rsplit(u'/', 1)[0]
        return path or u'/'

    @property
    def id(self):
        """ Get the id portion of the path.

        """
        return self.path.rsplit(u'/', 1)[1]

    def assemble(self):
        """ Assemble the menu or action object for the node.

        """
        raise NotImplementedError


class ActionNode(PathNode):
    """ A path node representing an action item.

    This class is an implementation detail and should not be consumed
    by code outside of this module.

    """
    #: The workbench instance to associate with action.
    workbench = Typed(Workbench)

    def assemble(self):
        """ Assemble and return a WorkbenchAction for the node.

        """
        return WorkbenchAction(workbench=self.workbench, item=self.item)


class MenuNode(PathNode):
    """ A path node representing a menu item.

    This class is an implementation detail and should not be consumed
    by code outside of this module.

    """
    #: The child objects defined for this menu node.
    children = List(PathNode)

    def group_data(self):
        """ The group map and list of group items for the node.

        Returns
        -------
        result : tuple
            A tuple of (dict, list) which holds the mapping of group
            id to ItemGroup object, and the flat list of ordered groups.

        """
        group_map = {}
        item_groups = self.item.item_groups

        for group in item_groups:
            if group.id in group_map:
                msg = "menu item '%s' has duplicate group '%s'"
                raise ValueError(msg % (self.path, group.id))
            group_map[group.id] = group

        if u'' not in group_map:
            group = ItemGroup()
            group_map[u''] = group
            item_groups.append(group)

        return group_map, item_groups

    def collect_child_groups(self):
        """ Yield the ordered and grouped children.

        """
        group_map, item_groups = self.group_data()

        grouped = defaultdict(list)
        for child in self.children:
            target_group = child.item.group
            if target_group not in group_map:
                msg = "item '%s' has invalid group '%s'"
                raise ValueError(msg % (child.path, target_group))
            grouped[target_group].append(child)

        for group in item_groups:
            if group.id in grouped:
                nodes = grouped.pop(group.id)
                yield group, solve_ordering(nodes)

    def create_children(self, group, nodes):
        """ Create the child widgets for the given group of nodes.

        This will assemble the nodes and setup the action groups.

        """
        result = []
        actions = []
        children = [node.assemble() for node in nodes]

        def process_actions():
            if actions:
                wag = WorkbenchActionGroup(group=group)
                wag.insert_children(None, actions)
                result.append(wag)
                del actions[:]

        for child in children:
            if isinstance(child, WorkbenchAction):
                actions.append(child)
            else:
                process_actions()
                child.group = group
                result.append(child)

        process_actions()

        return result

    def assemble_children(self):
        """ Assemble the list of child objects for the menu.

        """
        children = []
        for group, nodes in self.collect_child_groups():
            children.extend(self.create_children(group, nodes))
            children.append(Action(separator=True))
        if children:
            children.pop()
        return children

    def assemble(self):
        """ Assemble and return a WorkbenchMenu for the node.

        """
        menu = WorkbenchMenu(item=self.item)
        menu.insert_children(None, self.assemble_children())
        return menu


class RootMenuNode(MenuNode):
    """ A path node representing a root menu item.

    This class is an implementation detail and should not be consumed
    by code outside of this module.

    """
    def group_data(self):
        """ Get the group data for the root menu node.

        """
        group = ItemGroup()
        return {u'': group}, [group]

    def assemble(self):
        """ Assemble and return the list of root menu bar menus.

        """
        return self.assemble_children()


def create_menus(workbench, menu_items, action_items):
    """ Create the WorkbenchMenu objects for the menu bar.

    This is the only external public API of this module.

    Parameters
    ----------
    workbench : Workbench
        The workbench object which is creating the menus.

    menu_items : list
        The list of all MenuItem objects to include in the menus. The
        order of the items in this list is irrelevant.

    action_items : list
        The list of all ActionItem objects to include in the menus.
        The order of the items in this list is irrelevant.

    Returns
    -------
    result : list
        An ordered list of Menu objects which can be directly included
        into the main window's MenuBar.

    """
    # create the nodes for the menu items
    menu_nodes = []
    for item in menu_items:
        node = MenuNode(item=item)
        menu_nodes.append(node)

    # assemble the menu nodes into a tree structure in two passes
    # in order to maintain the relative item definition order
    root = RootMenuNode()
    node_map = {u'/': root}
    for node in menu_nodes:
        path = node.path
        if path in node_map:
            msg = "a menu item already exist for path '%s'"
            raise ValueError(msg % path)
        node_map[path] = node
    for node in menu_nodes:
        parent_path = node.parent_path
        if parent_path not in node_map:
            msg = "the path '%s' does not point to a menu item"
            raise ValueError(msg % parent_path)
        parent = node_map[parent_path]
        parent.children.append(node)

    # create the nodes for the action items
    action_nodes = []
    for item in action_items:
        node = ActionNode(item=item, workbench=workbench)
        action_nodes.append(node)

    # add the action nodes to the tree structure
    for node in action_nodes:
        parent_path = node.parent_path
        if parent_path not in node_map:
            msg = "the path '%s' does not point to a menu item"
            raise ValueError(msg % parent_path)
        path = node.path
        if path in node_map:
            msg = "an item already exist for path '%s'"
            raise ValueError(msg % path)
        parent = node_map[parent_path]
        parent.children.append(node)
        node_map[path] = node

    # generate the menus for the root nodes
    return root.assemble()

########NEW FILE########
__FILENAME__ = menu_item
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Bool, Unicode

from enaml.core.declarative import Declarative, d_

from .item_group import ItemGroup


class MenuItem(Declarative):
    """ A declarative class for defining a menu in the workbench.

    """
    #: The "/" separated path to this item in the menu bar.
    path = d_(Unicode())

    #: The parent menu group to which this menu item belongs.
    group = d_(Unicode())

    #: The menu item will appear before this item in its group.
    before = d_(Unicode())

    #: The menu item will appear after this item in its group.
    after = d_(Unicode())

    #: The display label for the menu.
    label = d_(Unicode())

    #: Whether or not the menu is visible.
    visible = d_(Bool(True))

    #: Whether or not the menu is enabled.
    enabled = d_(Bool(True))

    @property
    def item_groups(self):
        """ Get the item groups defined on this menu item.

        """
        return [c for c in self.children if isinstance(c, ItemGroup)]

########NEW FILE########
__FILENAME__ = ui_plugin
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.application import Application
from enaml.workbench.extension import Extension
from enaml.workbench.plugin import Plugin

from .action_item import ActionItem
from .autostart import Autostart
from .branding import Branding
from .menu_helper import create_menus
from .menu_item import MenuItem
from .window_model import WindowModel
from .workspace import Workspace

import enaml
with enaml.imports():
    from .workbench_window import WorkbenchWindow


ACTIONS_POINT = u'enaml.workbench.ui.actions'

APPLICATION_FACTORY_POINT = u'enaml.workbench.ui.application_factory'

BRANDING_POINT = u'enaml.workbench.ui.branding'

WINDOW_FACTORY_POINT = u'enaml.workbench.ui.window_factory'

WORKSPACES_POINT = u'enaml.workbench.ui.workspaces'

AUTOSTART_POINT = u'enaml.workbench.ui.autostart'


class UIPlugin(Plugin):
    """ The main UI plugin class for the Enaml studio.

    The ui plugin manages the extension points for user contributions
    to the main window.

    """
    def start(self):
        """ Start the plugin life-cycle.

        This method is called by the framework at the appropriate time.
        It should never be called by user code.

        """
        self._create_application()
        self._create_model()
        self._create_window()
        self._bind_observers()
        self._start_autostarts()

    def stop(self):
        """ Stop the plugin life-cycle.

        This method is called by the framework at the appropriate time.
        It should never be called by user code.

        """
        self._stop_autostarts()
        self._unbind_observers()
        self._destroy_window()
        self._release_model()
        self._release_application()

    @property
    def window(self):
        """ Get a reference to the primary window.

        """
        return self._window

    @property
    def workspace(self):
        """ Get a reference to the currently active workspace.

        """
        return self._model.workspace

    def show_window(self):
        """ Ensure the underlying window object is shown.

        """
        self._window.show()

    def hide_window(self):
        """ Ensure the underlying window object is hidden.

        """
        self._window.hide()

    def start_application(self):
        """ Start the application event loop.

        """
        self._application.start()

    def stop_application(self):
        """ Stop the application event loop.

        """
        self._application.stop()

    def close_window(self):
        """ Close the underlying workbench window.

        """
        self._window.close()

    def close_workspace(self):
        """ Close and dispose of the currently active workspace.

        """
        self._workspace_extension = None
        self._model.workspace.stop()
        self._model.workspace.workbench = None
        self._model.workspace = Workspace()

    def select_workspace(self, extension_id):
        """ Select and start the workspace for the given extension id.

        The current workspace will be stopped and released.

        """
        target = None
        workbench = self.workbench
        point = workbench.get_extension_point(WORKSPACES_POINT)
        for extension in point.extensions:
            if extension.qualified_id == extension_id:
                target = extension
                break

        if target is None:
            msg = "'%s' is not a registered workspace extension"
            raise ValueError(msg % extension_id)

        if target is self._workspace_extension:
            return

        old_workspace = self._model.workspace
        old_workspace.stop()
        old_workspace.workbench = None

        self._workspace_extension = target
        new_workspace = self._create_workspace(target)

        new_workspace.workbench = workbench
        new_workspace.start()
        self._model.workspace = new_workspace

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    #: The application provided by an ApplicationFactory extension.
    _application = Typed(Application)

    #: The window object provided by a WindowFactory extension.
    _window = Typed(WorkbenchWindow)

    #: The view model object used to drive the window.
    _model = Typed(WindowModel)

    #: The currently activate branding extension object.
    _branding_extension = Typed(Extension)

    #: The currently activate workspace extension object.
    _workspace_extension = Typed(Extension)

    #: The currently active action extension objects.
    _action_extensions = Typed(dict, ())

    def _create_application(self):
        """ Create the Application object for the ui.

        This will load the highest ranking extension to the application
        factory extension point, and use it to create the instance.

        If an application object already exists, that application will
        be used instead of any defined by a factory, since there can be
        only one application per-process.

        """
        if Application.instance() is not None:
            self._application = Application.instance()
            return

        workbench = self.workbench
        point = workbench.get_extension_point(APPLICATION_FACTORY_POINT)
        extensions = point.extensions
        if not extensions:
            msg = "no contributions to the '%s' extension point"
            raise RuntimeError(msg % APPLICATION_FACTORY_POINT)

        extension = extensions[-1]
        if extension.factory is None:
            msg = "extension '%s' does not declare an application factory"
            raise ValueError(msg % extension.qualified_id)

        application = extension.factory()
        if not isinstance(application, Application):
            msg = "extension '%s' created non-Application type '%s'"
            args = (extension.qualified_id, type(application).__name__)
            raise TypeError(msg % args)

        self._application = application

    def _create_model(self):
        """ Create and initialize the model which drives the window.

        """
        self._model = WindowModel()
        self._refresh_branding()
        self._refresh_actions()

    def _create_window(self):
        """ Create the WorkbenchWindow object for the workbench.

        This will load the highest ranking extension to the window
        factory extension point, and use it to create the instance.

        """
        workbench = self.workbench
        point = workbench.get_extension_point(WINDOW_FACTORY_POINT)
        extensions = point.extensions
        if not extensions:
            msg = "no contributions to the '%s' extension point"
            raise RuntimeError(msg % WINDOW_FACTORY_POINT)

        extension = extensions[-1]
        if extension.factory is None:
            msg = "extension '%s' does not declare a window factory"
            raise ValueError(msg % extension.qualified_id)

        window = extension.factory(workbench)
        if not isinstance(window, WorkbenchWindow):
            msg = "extension '%s' created non-WorkbenchWindow type '%s'"
            args = (extension.qualified_id, type(window).__name__)
            raise TypeError(msg % args)

        window.workbench = workbench
        window.window_model = self._model
        self._window = window

    def _create_workspace(self, extension):
        """ Create the Workspace object for the given extension.

        Parameters
        ----------
        extension : Extension
            The extension object of interest.

        Returns
        -------
        result : Workspace
            The workspace object for the given extension.

        """
        if extension.factory is None:
            msg = "extension '%s' does not declare a workspace factory"
            raise ValueError(msg % extension.qualified_id)

        workspace = extension.factory(self.workbench)
        if not isinstance(workspace, Workspace):
            msg = "extension '%s' created non-Workspace type '%s'"
            args = (extension.qualified_id, type(workspace).__name__)
            raise TypeError(msg % args)

        return workspace

    def _create_action_items(self, extension):
        """ Create the action items for the extension.

        """
        workbench = self.workbench
        menu_items = extension.get_children(MenuItem)
        action_items = extension.get_children(ActionItem)
        if extension.factory:
            for item in extension.factory(workbench):
                if isinstance(item, MenuItem):
                    menu_items.append(item)
                elif isinstance(item, ActionItem):
                    action_items.append(item)
                else:
                    msg = "action extension created invalid action type '%s'"
                    raise TypeError(msg % type(item).__name__)
        return menu_items, action_items

    def _destroy_window(self):
        """ Destroy and release the underlying window object.

        """
        self._window.hide()
        self._window.destroy()
        self._window = None

    def _release_model(self):
        """ Release the underlying window model object.

        """
        self._model.workspace.stop()
        self._model = None

    def _release_application(self):
        """ Stop and release the underlyling application object.

        """
        self._application.stop()
        self._application = None

    def _refresh_branding(self):
        """ Refresh the branding object for the window model.

        """
        workbench = self.workbench
        point = workbench.get_extension_point(BRANDING_POINT)
        extensions = point.extensions
        if not extensions:
            self._branding_extension = None
            self._model.branding = Branding()
            return

        extension = extensions[-1]
        if extension is self._branding_extension:
            return

        if extension.factory:
            branding = extension.factory(workbench)
            if not isinstance(branding, Branding):
                msg = "extension '%s' created non-Branding type '%s'"
                args = (extension.qualified_id, type(branding).__name__)
                raise TypeError(msg % args)
        else:
            branding = extension.get_child(Branding, reverse=True)
            branding = branding or Branding()

        self._branding_extension = extension
        self._model.branding = branding

    def _refresh_actions(self):
        """ Refresh the actions for the workbench window.

        """
        workbench = self.workbench
        point = workbench.get_extension_point(ACTIONS_POINT)
        extensions = point.extensions
        if not extensions:
            self._action_extensions.clear()
            self._model.menus = []
            return

        menu_items = []
        action_items = []
        new_extensions = {}
        old_extensions = self._action_extensions
        for extension in extensions:
            if extension in old_extensions:
                m_items, a_items = old_extensions[extension]
            else:
                m_items, a_items = self._create_action_items(extension)
            new_extensions[extension] = (m_items, a_items)
            menu_items.extend(m_items)
            action_items.extend(a_items)

        menus = create_menus(workbench, menu_items, action_items)
        self._action_extensions = new_extensions
        self._model.menus = menus

    def _get_autostarts(self):
        """ Get the autostart extension objects.

        """
        workbench = self.workbench
        point = workbench.get_extension_point(AUTOSTART_POINT)
        extensions = sorted(point.extensions, key=lambda ext: ext.rank)

        autostarts = []
        for extension in extensions:
            autostarts.extend(extension.get_children(Autostart))

        return autostarts

    def _start_autostarts(self):
        """ Start the plugins for the autostart extension point.

        """
        workbench = self.workbench
        for autostart in self._get_autostarts():
            workbench.get_plugin(autostart.plugin_id)

    def _stop_autostarts(self):
        """ Stop the plugins for the autostart extension point.

        """
        workbench = self.workbench
        for autostart in reversed(self._get_autostarts()):
            plugin = workbench.get_plugin(autostart.plugin_id)
            plugin.stop()

    def _on_branding_updated(self, change):
        """ The observer for the branding extension point.

        """
        self._refresh_branding()

    def _on_actions_updated(self, change):
        """ The observer for the actions extension point.

        """
        self._refresh_actions()

    def _bind_observers(self):
        """ Setup the observers for the plugin.

        """
        workbench = self.workbench

        point = workbench.get_extension_point(BRANDING_POINT)
        point.observe('extensions', self._on_branding_updated)

        point = workbench.get_extension_point(ACTIONS_POINT)
        point.observe('extensions', self._on_actions_updated)

    def _unbind_observers(self):
        """ Remove the observers for the plugin.

        """
        workbench = self.workbench

        point = workbench.get_extension_point(BRANDING_POINT)
        point.unobserve('extensions', self._on_branding_updated)

        point = workbench.get_extension_point(ACTIONS_POINT)
        point.unobserve('extensions', self._on_actions_updated)

########NEW FILE########
__FILENAME__ = ui_workbench
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from enaml.workbench.workbench import Workbench


UI_PLUGIN = u'enaml.workbench.ui'


class UIWorkbench(Workbench):
    """ A class for creating workbench UI applications.

    The UIWorkbench class is a subclass of Workbench which loads the
    builtin ui plugin and provides an entry point to start the main
    application event loop.

    """
    def run(self):
        """ Run the UI workbench application.

        This method will load the core and ui plugins and start the
        main application event loop. This is a blocking call which
        will return when the application event loop exits.

        """
        import enaml
        with enaml.imports():
            from enaml.workbench.core.core_manifest import CoreManifest
            from enaml.workbench.ui.ui_manifest import UIManifest

        self.register(CoreManifest())
        self.register(UIManifest())

        ui = self.get_plugin(UI_PLUGIN)
        ui.show_window()
        ui.start_application()

        # TODO stop all plugins on app exit?

        self.unregister(UI_PLUGIN)

########NEW FILE########
__FILENAME__ = window_model
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, List, Typed

from enaml.widgets.menu import Menu

from .branding import Branding
from .workspace import Workspace


class WindowModel(Atom):
    """ A model which is used to drive the WorkbenchWindow instance.

    """
    #: The branding which contributes the window title and icon.
    branding = Typed(Branding, ())

    #: The menu objects for the menu bar.
    menus = List(Menu)

    #: The currently active workspace for the window.
    workspace = Typed(Workspace, ())

########NEW FILE########
__FILENAME__ = workspace
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed, Unicode

from enaml.core.declarative import Declarative, d_
from enaml.widgets.container import Container
from enaml.workbench.workbench import Workbench


class Workspace(Declarative):
    """ A declarative class for defining a workspace object.

    """
    #: Extra information to display in the window title bar.
    window_title = d_(Unicode())

    #: The primary window content for the workspace. This will be
    #: destroyed automatically when the workspace is disposed.
    content = d_(Typed(Container))

    #: The workbench object which owns the workspace. This will be
    #: assigned when the ui plugin creates the workspace. It will
    #: be available by the time the 'start' method is called.
    workbench = Typed(Workbench)

    def start(self):
        """ Start the workspace.

        This method is called when the UI plugin starts the workspace.
        This can be used to load content or any other resource which
        should exist for the life of the workspace.

        """
        pass

    def stop(self):
        """ Stop the workspace.

        This method is called when the UI plugin closes the workspace.
        This should be used to release any resources acquired during
        the lifetime of the workspace. The content Container will be
        destroyed automatically after this method returns.

        """
        pass

########NEW FILE########
__FILENAME__ = workbench
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from collections import defaultdict

from atom.api import Atom, Event, Typed

from .plugin import Plugin


class Workbench(Atom):
    """ A base class for creating plugin-style applications.

    This class is used for managing the lifecycle of plugins. It does
    not provide any plugins of its own. The UIWorkbench subclass adds
    the 'core' and 'ui' workbench plugins by default.

    """
    #: An event fired when a plugin is added to the workbench. The
    #: payload will be the plugin id.
    plugin_added = Event(unicode)

    #: An event fired when a plugin is removed from the workbench. The
    #: payload will be the plugin id.
    plugin_removed = Event(unicode)

    #: An event fired when an extension point is added to the
    #: workbench. The payload will be the fully qualified id of the
    #: extension point.
    extension_point_added = Event(unicode)

    #: An event fired when an extension point is removed from the
    #: workbench. The payload will be the fully qualified id of the
    #: extension point.
    extension_point_removed = Event(unicode)

    def register(self, manifest):
        """ Register a plugin with the workbench.

        Parameters
        ----------
        manifest : PluginManifest
            The plugin manifest to register with the workbench.

        """
        plugin_id = manifest.id
        if plugin_id in self._manifests:
            msg = "plugin '%s' is already registered"
            raise ValueError(msg % plugin_id)

        self._manifests[plugin_id] = manifest
        manifest.workbench = self

        self._add_extensions(manifest.extensions)
        self._add_extension_points(manifest.extension_points)

        self.plugin_added(plugin_id)

    def unregister(self, plugin_id):
        """ Remove a plugin from the workbench.

        This will remove the extension points and extensions from the
        workbench, and stop the plugin if it was activated.

        Parameters
        ----------
        plugin_id : unicode
            The identifier of the plugin of interest.

        """
        manifest = self._manifests.get(plugin_id)
        if manifest is None:
            msg = "plugin '%s' is not registered"
            raise ValueError(msg % plugin_id)

        plugin = self._plugins.pop(plugin_id, None)
        if plugin is not None:
            plugin.stop()
            plugin.manifest = None

        self._remove_extensions(manifest.extensions)
        self._remove_extension_points(manifest.extension_points)

        del self._manifests[plugin_id]
        manifest.workbench = None

        self.plugin_removed(plugin_id)

    def get_manifest(self, plugin_id):
        """ Get the plugin manifest for a given plugin id.

        Parameters
        ----------
        plugin_id : unicode
            The identifier of the plugin of interest.

        Returns
        -------
        result : PluginManifest or None
            The manifest for the plugin of interest, or None if it
            does not exist.

        """
        return self._manifests.get(plugin_id)

    def get_plugin(self, plugin_id, force_create=True):
        """ Get the plugin object for a given plugin id.

        Parameters
        ----------
        plugin_id : unicode
            The identifier of the plugin of interest.

        force_create : bool, optional
            Whether to automatically import and start the plugin object
            if it is not already active. The default is True.

        Returns
        -------
        result : Plugin or None
            The plugin of interest, or None if it does not exist and/or
            could not be created.

        """
        if plugin_id in self._plugins:
            return self._plugins[plugin_id]

        manifest = self._manifests.get(plugin_id)
        if manifest is None:
            msg = "plugin '%s' is not registered"
            raise ValueError(msg % plugin_id)

        if not force_create:
            return None

        plugin = manifest.factory()
        if not isinstance(plugin, Plugin):
            msg = "plugin '%s' factory created non-Plugin type '%s'"
            raise TypeError(msg % (plugin_id, type(plugin).__name__))

        self._plugins[plugin_id] = plugin
        plugin.manifest = manifest
        plugin.start()
        return plugin

    def get_extension_point(self, extension_point_id):
        """ Get the extension point associated with an id.

        Parameters
        ----------
        extension_point_id : unicode
            The fully qualified id of the extension point of interest.

        Returns
        -------
        result : ExtensionPoint or None
            The desired ExtensionPoint or None if it does not exist.

        """
        return self._extension_points.get(extension_point_id)

    def get_extension_points(self):
        """ Get all of the extension points in the workbench.

        Returns
        -------
        result : list
            A list of all of the extension points in the workbench.

        """
        return self._extension_points.values()

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    #: A mapping of plugin id to PluginManifest.
    _manifests = Typed(dict, ())

    #: A mapping of plugin id to Plugin instance.
    _plugins = Typed(dict, ())

    #: A mapping of extension point id to ExtensionPoint.
    _extension_points = Typed(dict, ())

    #: A mapping of extension id to Extension.
    _extensions = Typed(dict, ())

    #: A mapping of extension point id to set of Extensions.
    _contributions = Typed(defaultdict, (set,))

    def _add_extension_points(self, extension_points):
        """ Add extension points to the workbench.

        Parameters
        ----------
        extension_points : list
            The list of ExtensionPoints to add to the workbench.

        """
        for point in extension_points:
            self._add_extension_point(point)

    def _add_extension_point(self, point):
        """ Add an extension point to the workbench.

        Parameters
        ----------
        point : ExtensionPoint
            The ExtensionPoint to add to the workbench.

        """
        point_id = point.qualified_id
        if point_id in self._extension_points:
            msg = "extension point '%s' is already registered"
            raise ValueError(msg % point_id)

        self._extension_points[point_id] = point
        if point_id in self._contributions:
            to_add = self._contributions[point_id]
            self._update_extension_point(point, [], to_add)

        self.extension_point_added(point_id)

    def _remove_extension_points(self, extension_points):
        """ Remove extension points from the workbench.

        Parameters
        ----------
        extension_points : list
            The list of ExtensionPoints to remove from the workbench.

        """
        for point in extension_points:
            self._remove_extension_point(point)

    def _remove_extension_point(self, point):
        """ Remove an extension point from the workbench.

        Parameters
        ----------
        point : ExtensionPoint
            The ExtensionPoint to remove from the workbench.

        """
        point_id = point.qualified_id
        if point_id not in self._extension_points:
            msg = "extension point '%s' is not registered"
            raise ValueError(msg % point_id)

        del self._extension_points[point_id]
        if point_id in self._contributions:
            to_remove = self._contributions.pop(point_id)
            self._update_extension_point(point, to_remove, [])

        self.extension_point_removed(point_id)

    def _add_extensions(self, extensions):
        """ Add extensions to the workbench.

        Parameters
        ----------
        extensions : list
            The list of Extensions to add to the workbench.

        """
        grouped = defaultdict(set)
        for extension in extensions:
            ext_id = extension.qualified_id
            if ext_id in self._extensions:
                msg = "extension '%s' is already registered"
                raise ValueError(msg % ext_id)
            self._extensions[ext_id] = extension
            grouped[extension.point].add(extension)

        for point_id, exts in grouped.iteritems():
            self._contributions[point_id].update(exts)
            if point_id in self._extension_points:
                point = self._extension_points[point_id]
                self._update_extension_point(point, (), exts)

    def _remove_extensions(self, extensions):
        """ Remove extensions from a workbench.

        Parameters
        ----------
        extensions : list
            The list of Extensions to remove from the workbench.

        """
        grouped = defaultdict(set)
        for extension in extensions:
            ext_id = extension.qualified_id
            if ext_id not in self._extensions:
                msg = "extension '%s' is not registered"
                raise ValueError(msg % ext_id)
            del self._extensions[ext_id]
            grouped[extension.point].add(extension)

        for point_id, exts in grouped.iteritems():
            self._contributions[point_id].difference_update(exts)
            if point_id in self._extension_points:
                point = self._extension_points[point_id]
                self._update_extension_point(point, exts, ())

    def _update_extension_point(self, point, to_remove, to_add):
        """ Update an extension point with delta extension objects.

        Parameters
        ----------
        point : ExtensionPoint
            The extension point of interest.

        to_remove : iterable
            The Extension objects to remove from the point.

        to_add : iterable
            The Extension objects to add to the point.

        """
        if to_remove or to_add:
            extensions = set(point.extensions)
            extensions.difference_update(to_remove)
            extensions.update(to_add)
            key = lambda ext: ext.rank
            point.extensions = tuple(sorted(extensions, key=key))

########NEW FILE########
__FILENAME__ = wx_abstract_button
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Int

from enaml.widgets.abstract_button import ProxyAbstractButton

from .wx_control import WxControl


# cyclic notification guard flags
CHECKED_GUARD = 0x1


class WxAbstractButton(WxControl, ProxyAbstractButton):
    """ A Wx implementation of an Enaml ProxyAbstractButton.

    This class can serve as a base class for widgets that implement
    button behavior such as CheckBox, RadioButton and PushButtons.
    It is not meant to be used directly.

    """
    #: Cyclic notification guard. This a bitfield of multiple guards.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Implement in a subclass to create the widget.

        """
        raise NotImplementedError

    def init_widget(self):
        """ Initialize the button widget.

        """
        super(WxAbstractButton, self).init_widget()
        d = self.declaration
        if d.text:
            self.set_text(d.text)
        self.set_checkable(d.checkable)
        self.set_checked(d.checked)

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_clicked(self, event):
        """ The event handler for the clicked event.

        Parameters
        ----------
        event : wxEvent
            The wx event object. This is ignored by the handler.

        """
        if not self._guard & CHECKED_GUARD:
            checked = self.get_checked()
            self.declaration.checked = checked
            self.declaration.clicked(checked)

    def on_toggled(self, event):
        """ The event handler for the toggled event.

        Parameters
        ----------
        event : wxEvent
            The wx event object. This is ignored by the handler.

        """
        if not self._guard & CHECKED_GUARD:
            checked = self.get_checked()
            self.declaration.checked = checked
            self.declaration.toggled(checked)

    #--------------------------------------------------------------------------
    # ProxyAbstractButton API
    #--------------------------------------------------------------------------
    def set_text(self, text):
        """ Sets the widget's text with the provided value.

        """
        with self.geometry_guard():
            self.widget.SetLabel(text)

    def set_icon(self, icon):
        """ Sets the widget's icon to the provided image

        This is not supported on wx.

        """
        pass

    def set_icon_size(self, icon_size):
        """ Sets the widget's icon size to the provided tuple

        This is not supported on wx.

        """
        pass

    def set_checkable(self, checkable):
        """ Sets whether or not the widget is checkable.

        """
        raise NotImplementedError

    def get_checked(self):
        """ Returns the checked state of the widget.

        """
        raise NotImplementedError

    def set_checked(self, checked):
        """ Sets the widget's checked state with the provided value.

        """
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = wx_action
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from weakref import WeakValueDictionary

import wx
import wx.lib.newevent

from atom.api import Int, Typed

from enaml.widgets.action import ProxyAction

from .wx_toolkit_object import WxToolkitObject


#: An event emitted when a wxAction has been triggered by the user. The
#: payload of the event will have an 'IsChecked' attribute.
wxActionTriggeredEvent, EVT_ACTION_TRIGGERED = wx.lib.newevent.NewEvent()

#: An event emitted by a wxAction when it has been toggled by the user.
#: The payload of the event will have an 'IsChecked' attribute.
wxActionToggledEvent, EVT_ACTION_TOGGLED = wx.lib.newevent.NewEvent()

#: An event emitted by a wxAction when its state has been changed.
wxActionChangedEvent, EVT_ACTION_CHANGED = wx.lib.newevent.NewEvent()


class wxAction(wx.EvtHandler):
    """ A wx.EvtHandler which behaves similar to a QAction.

    """
    #: Class storage which maps action id -> action instance.
    _action_map = WeakValueDictionary()

    @classmethod
    def FindById(cls, action_id):
        """ Find a wxAction instance using the given action id.

        Parameters
        ----------
        action_id : int
            The id for the action.

        Returns
        -------
        result : wxAction or None
            The wxAction instance for the given id, or None if not
            action exists for that id.

        """
        return cls._action_map.get(action_id)

    def __init__(self, parent=None):
        """ Initialize a wxAction.

        Parameters
        ----------
        parent : object or None
            The parent for this wxAction. The parent is not directly
            used by the action, but is provided as a convenience for
            other parts of the framework.

        """
        super(wxAction, self).__init__()
        self._parent = parent
        self._text = u''
        self._tool_tip = u''
        self._status_tip = u''
        self._checkable = False
        self._checked = False
        self._enabled = True
        self._visible = True
        self._group_enabled = True
        self._group_visible = True
        self._separator = False
        self._batch = False
        self._id = wx.NewId()
        self._action_map[self._id] = self

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _EmitChanged(self):
        """ Emits the EVT_ACTION_CHANGED event if not in batch mode.

        """
        if not self._batch:
            event = wxActionChangedEvent()
            event.SetEventObject(self)
            wx.PostEvent(self, event)

    def _SetGroupEnabled(self, enabled):
        """ A private method called by an owner action group.

        Parameters
        ----------
        enabled : bool
            Whether or not the owner group is enabled.

        """
        if self._group_enabled != enabled:
            old = self.IsEnabled()
            self._group_enabled = enabled
            new = self.IsEnabled()
            if old != new:
                self._EmitChanged()

    def _SetGroupVisible(self, visible):
        """ A private method called by an owner action group.

        Parameters
        ----------
        visible : bool
            Whether or not the owner group is visble.

        """
        if self._group_visible != visible:
            old = self.IsVisible()
            self._group_visible = visible
            new = self.IsVisible()
            if old != new:
                self._EmitChanged()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def GetParent(self):
        """ Get the parent of the action.

        Returns
        -------
        result : object or None
            The parent of this action or None.

        """
        return self._parent

    def SetParent(self, parent):
        """ Set the parent of the action.

        Parameters
        ----------
        parent : object or None
            The object to use as the parent of this action.

        """
        self._parent = parent

    def Trigger(self):
        """ A method called by the action owner when the user triggers
        the action.

        This handler will emit the custom EVT_ACTION_TRIGGERED event.
        User code should not typically call this method directly.

        """
        # This event is dispatched immediately in order to preserve
        # the order of event firing for trigger/toggle.
        event = wxActionTriggeredEvent(IsChecked=self._checked)
        event.SetEventObject(self)
        wx.PostEvent(self, event)

    def BeginBatch(self):
        """ Enter batch update mode for the action.

        """
        self._batch = True

    def EndBatch(self, emit=True):
        """ Exit batch update mode for the action.

        Parameters
        ----------
        emit : bool, optional
            If True, emit a changed event after leaving batch mode. The
            default is True.

        """
        self._batch = False
        if emit:
            self._EmitChanged()

    def GetId(self):
        """ Get the unique wx id for this action.

        Returns
        -------
        result : int
            The wx id number for this action.

        """
        return self._id

    def GetText(self):
        """ Get the text for the action.

        Returns
        -------
        result : unicode
            The unicode text for the action.

        """
        return self._text

    def SetText(self, text):
        """ Set the text for the action.

        Parameters
        ----------
        text : unicode
            The unicode text for the action.

        """
        if self._text != text:
            self._text = text
            self._EmitChanged()

    def GetToolTip(self):
        """ Get the tool tip for the action.

        Returns
        -------
        result : unicode
            The unicode tool tip for the action.

        """
        return self._tool_tip

    def SetToolTip(self, tool_tip):
        """ Set the tool tip for the action.

        Parameters
        ----------
        tool_tip : unicode
            The unicode tool tip for the action.

        """
        if self._tool_tip != tool_tip:
            self._tool_tip = tool_tip
            self._EmitChanged()

    def GetStatusTip(self):
        """ Get the status tip for the action.

        Returns
        -------
        result : unicode
            The unicode status tip for the action.

        """
        return self._status_tip

    def SetStatusTip(self, status_tip):
        """ Set the status tip for the action.

        Parameters
        ----------
        status_tip : unicode
            The unicode status tip for the action.

        """
        if self._status_tip != status_tip:
            self._status_tip = status_tip
            self._EmitChanged()

    def IsCheckable(self):
        """ Get whether or not the action is checkable.

        Returns
        -------
        result : bool
            Whether or not the action is checkable.

        """
        return self._checkable

    def SetCheckable(self, checkable):
        """ Set whether or not the action is checkable.

        Parameters
        ----------
        checkable : bool
            Whether or not the action is checkable.

        """
        if self._checkable != checkable:
            self._checkable = checkable
            self._EmitChanged()

    def IsChecked(self):
        """ Get whether or not the action is checked.

        Returns
        -------
        result : bool
            Whether or not the action is checked.

        """
        return self._checked

    def SetChecked(self, checked):
        """ Set whether or not the action is checked.

        Parameters
        ----------
        checked : bool
            Whether or not the action is checked.

        """
        if self._checked != checked:
            self._checked = checked
            self._EmitChanged()
            event = wxActionToggledEvent(IsChecked=checked)
            event.SetEventObject(self)
            wx.PostEvent(self, event)

    def IsEnabled(self):
        """ Get whether or not the action is enabled.

        Returns
        -------
        result : bool
            Whether or not the action is enabled.

        """
        if self._group_enabled:
            return self._enabled
        return False

    def SetEnabled(self, enabled):
        """ Set whether or not the action is enabled.

        Parameters
        ----------
        enabled : bool
            Whether or not the action is enabled.

        """
        if self._enabled != enabled:
            self._enabled = enabled
            if self._group_enabled:
                self._EmitChanged()

    def IsVisible(self):
        """ Get whether or not the action is visible.

        Returns
        -------
        result : bool
            Whether or not the action is visible.

        """
        if self._group_visible:
            return self._visible
        return False

    def SetVisible(self, visible):
        """ Set whether or not the action is visible.

        Parameters
        ----------
        visible : bool
            Whether or not the action is visible.

        """
        if self._visible != visible:
            self._visible = visible
            if self._group_visible:
                self._EmitChanged()

    def IsSeparator(self):
        """ Get whether or not the action is a separator.

        Returns
        -------
        result : bool
            Whether or not the action is a separator.

        """
        return self._separator

    def SetSeparator(self, separator):
        """ Set whether or not the action is a separator.

        Parameters
        ----------
        separator : bool
            Whether or not the action is a separator.

        """
        if self._separator != separator:
            self._separator = separator
            self._EmitChanged()


# cyclic notification guard flags
CHECKED_GUARD = 0x1


class WxAction(WxToolkitObject, ProxyAction):
    """ A Wx implementation of an Enaml ProxyAction.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(wxAction)

    #: Cyclic notification guard. This a bitfield of multiple guards.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying wxAction object.

        """
        self.widget = wxAction(self.parent_widget())

    def init_widget(self):
        """ Create and initialize the underlying control.

        """
        super(WxAction, self).init_widget()
        d = self.declaration
        widget = self.widget
        widget.BeginBatch()
        if d.text:
            self.set_text(d.text)
        if d.tool_tip:
            self.set_tool_tip(d.tool_tip)
        if d.status_tip:
            self.set_status_tip(d.status_tip)
        if d.icon:
            self.set_icon(d.icon)
        self.set_checkable(d.checkable)
        self.set_checked(d.checked)
        self.set_enabled(d.enabled)
        self.set_visible(d.visible)
        self.set_separator(d.separator)
        widget.EndBatch(emit=False)
        widget.Bind(EVT_ACTION_TRIGGERED, self.on_triggered)
        widget.Bind(EVT_ACTION_TOGGLED, self.on_toggled)

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_triggered(self, event):
        """ The event handler for the EVT_ACTION_TRIGGERED event.

        """
        if not self._guard & CHECKED_GUARD:
            checked = event.IsChecked
            self.declaration.checked = checked
            self.declaration.triggered(checked)

    def on_toggled(self, event):
        """ The event handler for the EVT_ACTION_TOGGLED event.

        """
        if not self._guard & CHECKED_GUARD:
            checked = event.IsChecked
            self.declaration.checked = checked
            self.declaration.toggled(checked)

    #--------------------------------------------------------------------------
    # ProxyAction API
    #--------------------------------------------------------------------------
    def set_text(self, text):
        """ Set the text on the underlying control.

        """
        self.widget.SetText(text)

    def set_tool_tip(self, tool_tip):
        """ Set the tool tip on the underlying control.

        """
        self.widget.SetToolTip(tool_tip)

    def set_status_tip(self, status_tip):
        """ Set the status tip on the underyling control.

        """
        self.widget.SetStatusTip(status_tip)

    def set_icon(self, icon):
        """ Set the icon for the action.

        This is not supported on Wx.

        """
        pass

    def set_checkable(self, checkable):
        """ Set the checkable state on the underlying control.

        """
        self.widget.SetCheckable(checkable)

    def set_checked(self, checked):
        """ Set the checked state on the underlying control.

        """
        self._guard |= CHECKED_GUARD
        try:
            self.widget.SetChecked(checked)
        finally:
            self._guard &= ~CHECKED_GUARD

    def set_enabled(self, enabled):
        """ Set the enabled state on the underlying control.

        """
        self.widget.SetEnabled(enabled)

    def set_visible(self, visible):
        """ Set the visible state on the underlying control.

        """
        self.widget.SetVisible(visible)

    def set_separator(self, separator):
        """ Set the separator state on the underlying control.

        """
        self.widget.SetSeparator(separator)

########NEW FILE########
__FILENAME__ = wx_action_group
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx

from atom.api import Typed

from enaml.widgets.action_group import ProxyActionGroup

from .wx_action import WxAction, EVT_ACTION_CHANGED
from .wx_toolkit_object import WxToolkitObject


class wxActionGroup(wx.EvtHandler):
    """ A simple object which keeps track of a group of actions.

    """
    def __init__(self, parent=None):
        """ Initialize a wxActionGroup.

        Parameters
        ----------
        parent : object or None
            The parent for this wxActionGroup. The parent is not used
            directly by the action, but is provided as a convenience
            for other parts of the framework.

        """
        super(wxActionGroup, self).__init__()
        self._parent = parent
        self._exclusive = True
        self._enabled = True
        self._visible = True
        self._actions = []
        self._checked_action = None

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def OnActionChanged(self, event):
        """ The event handler for the EVT_ACTION_CHANGED event.

        This handler will update the current checked action and toggle
        any other old action if the group is exclusive.

        """
        event.Skip()
        action = event.GetEventObject()
        if action.IsChecked():
            old_action = self._checked_action
            self._checked_action = action
            if self.IsExclusive():
                if action is not old_action:
                    if old_action is not None:
                        old_action.SetChecked(False)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def GetParent(self):
        """ Get the parent of the action group.

        Returns
        -------
        result : object or None
            The parent of this action group or None.

        """
        return self._parent

    def SetParent(self, parent):
        """ Set the parent of the action group.

        Parameters
        ----------
        parent : object or None
            The object to use as the parent of this action group.

        """
        self._parent = parent

    def AddAction(self, action):
        """ Add an action to the action group.

        If the action already exists in the group, this is a no-op.

        Parameters
        ----------
        action : wxAction
            The wxAction to add to the group.

        """
        actions = self._actions
        if action not in actions:
            actions.append(action)
            action.Bind(EVT_ACTION_CHANGED, self.OnActionChanged)
            parent = action.GetParent()
            if isinstance(parent, wxActionGroup) and parent is not self:
                parent.RemoveAction(action)
                action.SetParent(self)

        if action.IsChecked():
            old_action = self._checked_action
            self._checked_action = action
            if self.IsExclusive():
                if action is not old_action:
                    if old_action is not None:
                        old_action.SetChecked(False)

        action._SetGroupEnabled(self._enabled)
        action._SetGroupVisible(self._visible)

    def RemoveAction(self, action):
        """ Remove the action from the action group.

        If the action does not exist in the group, this is a no-op.

        Parameters
        ----------
        action : wxAction
            The wxAction to remove from the group.

        """
        actions = self._actions
        if action in actions:
            actions.remove(action)
            action.Unbind(EVT_ACTION_CHANGED, handler=self.OnActionChanged)
            if action is self._checked_action:
                self._checked_action = None

    def GetActions(self):
        """ Get the list of actions for this group.

        Returns
        -------
        result : list
            The list of wxAction instances for this action group. This
            list should not be modified in-place.

        """
        return self._actions

    def GetCheckedAction(self):
        """ Get the currently checked action in the group.

        Returns
        -------
        result : wxAction or None
            The currently checked action in the group, or None if
            no action is checked.

        """
        return self._checked_action

    def IsExclusive(self):
        """ Get whether or not the action group is exclusive.

        Returns
        -------
        result : bool
            Whether or not the action group is exclusive.

        """
        return self._exclusive

    def SetExclusive(self, exclusive):
        """ Set whether or not the action group is exclusive.

        Parameters
        ----------
        exclusive : bool
            Whether or not the action is exclusive.

        """
        if self._exclusive != exclusive:
            self._exclusive = exclusive
            if exclusive:
                curr = self._checked_action
                for action in self._actions:
                    if action is not curr:
                        action.SetChecked(False)

    def IsEnabled(self):
        """ Get whether or not the action group is enabled.

        Returns
        -------
        result : bool
            Whether or not the action group is enabled.

        """
        return self._enabled

    def SetEnabled(self, enabled):
        """ Set whether or not the action group is enabled.

        Parameters
        ----------
        enabled : bool
            Whether or not the action group is enabled.

        """
        if self._enabled != enabled:
            self._enabled = enabled
            for action in self._actions:
                action._SetGroupEnabled(enabled)

    def IsVisible(self):
        """ Get whether or not the action group is visible.

        Returns
        -------
        result : bool
            Whether or not the action group is visible.

        """
        return self._visible

    def SetVisible(self, visible):
        """ Set whether or not the action group is visible.

        Parameters
        ----------
        enabled : bool
            Whether or not the action is visible.

        """
        if self._visible != visible:
            self._visible = visible
            for action in self._actions:
                action._SetGroupVisible(visible)


class WxActionGroup(WxToolkitObject, ProxyActionGroup):
    """ A Wx implementation of an Enaml ProxyActionGroup.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(wxActionGroup)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying action group widget.

        """
        self.widget = wxActionGroup(self.parent_widget())

    def init_widget(self):
        """ Initialize the control.

        """
        super(WxActionGroup, self).init_widget()
        d = self.declaration
        self.set_exclusive(d.exclusive)
        self.set_enabled(d.enabled)
        self.set_visible(d.visible)

    def init_layout(self):
        """ Initialize the layout for the control.

        """
        super(WxActionGroup, self).init_layout()
        widget = self.widget
        for action in self.actions():
            widget.AddAction(action)

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def find_next_action(self, child):
        """ Locate the wxAction object which logically follows the child.

        If the given child is last in the list of children, then the
        parent object will be invoked to find the wxAction which follows
        this action group.

        Parameters
        ----------
        child : QtToolkitObject
            The child object of interest.

        Returns
        -------
        result : wxAction or None
            The wxAction which logically follows the position of the
            child in the list of children. None will be returned if
            a relevant QAction is not found.

        """
        found = False
        for dchild in self.children():
            if found and isinstance(dchild, WxAction):
                return dchild.widget
            else:
                found = child is dchild
        parent = self.parent()
        if parent is not None:
            return parent.find_next_action(self)

    def child_added(self, child):
        """ Handle the child added event for a WxActionGroup.

        """
        super(WxActionGroup, self).child_added(child)
        if isinstance(child, WxAction):
            self.widget.AddAction(child.widget)
            parent = self.parent()
            if parent is not None:
                before = self.find_next_action(child)
                parent.widget.InsertAction(before, child.widget)

    def child_removed(self, child):
        """ Handle the child removed event for a WxActionGroup.

        """
        super(WxActionGroup, self).child_removed(child)
        if isinstance(child, WxAction) and child.widget is not None:
            self.widget.RemoveAction(child.widget)
            parent = self.parent()
            if parent is not None:
                parent.widget.RemoveAction(child.widget)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def actions(self):
        """ Get the WxAction children for this action group.

        Returns
        -------
        result : list
            The list of wxAction instances which are children of this
            action group. Unlike the list returned by the `GetActions`
            method of the wxActionGroup, the children in this list will
            have the correct order.

        """
        isinst = isinstance
        return [c.widget for c in self.children() if isinst(c, WxAction)]

    #--------------------------------------------------------------------------
    # ProxyActionGroup API
    #--------------------------------------------------------------------------
    def set_exclusive(self, exclusive):
        """ Set the exclusive state of the underlying control.

        """
        self.widget.SetExclusive(exclusive)

    def set_enabled(self, enabled):
        """ Set the enabled state of the underlying control.

        """
        self.widget.SetEnabled(enabled)

    def set_visible(self, visible):
        """ Set the visible state of the underlying control.

        """
        self.widget.SetVisible(visible)

########NEW FILE########
__FILENAME__ = wx_application
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx

from atom.api import Typed

from enaml.application import Application, ProxyResolver

from .wx_deferred_caller import DeferredCall, TimedCall
from .wx_factories import WX_FACTORIES


class WxApplication(Application):
    """ A Wx implementation of an Enaml application.

    A WxApplication uses the Wx toolkit to implement an Enaml UI that
    runs in the local process.

    """
    #: The private QApplication instance.
    _wxapp = Typed(wx.App)

    def __init__(self):
        """ Initialize a WxApplication.

        """
        super(WxApplication, self).__init__()
        self._wxapp = wx.GetApp() or wx.PySimpleApp()
        self.resolver = ProxyResolver(factories=WX_FACTORIES)

    #--------------------------------------------------------------------------
    # Abstract API Implementation
    #--------------------------------------------------------------------------
    def start(self):
        """ Start the application's main event loop.

        """
        app = self._wxapp
        if not app.IsMainLoopRunning():
            app.MainLoop()

    def stop(self):
        """ Stop the application's main event loop.

        """
        app = self._wxapp
        if app.IsMainLoopRunning():
            app.Exit()

    def deferred_call(self, callback, *args, **kwargs):
        """ Invoke a callable on the next cycle of the main event loop
        thread.

        Parameters
        ----------
        callback : callable
            The callable object to execute at some point in the future.

        *args, **kwargs
            Any additional positional and keyword arguments to pass to
            the callback.

        """
        DeferredCall(callback, *args, **kwargs)

    def timed_call(self, ms, callback, *args, **kwargs):
        """ Invoke a callable on the main event loop thread at a
        specified time in the future.

        Parameters
        ----------
        ms : int
            The time to delay, in milliseconds, before executing the
            callable.

        callback : callable
            The callable object to execute at some point in the future.

        *args, **kwargs
            Any additional positional and keyword arguments to pass to
            the callback.

        """
        TimedCall(ms, callback, *args, **kwargs)

    def is_main_thread(self):
        """ Indicates whether the caller is on the main gui thread.

        Returns
        -------
        result : bool
            True if called from the main gui thread. False otherwise.

        """
        return wx.Thread_IsMain()

########NEW FILE########
__FILENAME__ = wx_bounded_date
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import datetime

import wx

from atom.api import Int

from enaml.widgets.bounded_date import ProxyBoundedDate

from .wx_control import WxControl


def as_wx_date(py_date):
    """ Convert an iso date string to a wxDateTime.

    """
    day = py_date.day
    month = py_date.month - 1  # wx peculiarity!
    year = py_date.year
    return wx.DateTimeFromDMY(day, month, year)


def as_py_date(wx_date):
    """ Convert a QDate object into and iso date string.

    """
    day = wx_date.GetDay()
    month = wx_date.GetMonth() + 1  # wx peculiarity!
    year = wx_date.GetYear()
    return datetime.date(year, month, day)


# cyclic notification guard flags
CHANGED_GUARD = 0x1


class WxBoundedDate(WxControl, ProxyBoundedDate):
    """ A base class for use with Wx widgets implementing behavior
    for subclasses of BoundedDate.

    """
    #: Cyclic notification guard. This a bitfield of multiple guards.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Implement in a subclass to create the date widget.

        """
        raise NotImplementedError

    def init_widget(self):
        """ Create and initialize the bounded date widget.

        """
        super(WxBoundedDate, self).init_widget()
        d = self.declaration
        self.set_minimum(d.minimum)
        self.set_maximum(d.maximum)
        self.set_date(d.date)

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_date_changed(self, event):
        """ An event handler to connect to the date changed signal of
        the underlying widget.

        This will convert the wxDateTime to iso format and send the Enaml
        widget the 'date_changed' action.

        """
        if not self._guard & CHANGED_GUARD:
            self.declaration.date = self.get_date()

    #--------------------------------------------------------------------------
    # Abstract Methods and ProxyBoundedDate API
    #--------------------------------------------------------------------------
    def get_date(self):
        """ Return the current date in the control.

        Returns
        -------
        result : date
            The current control date as a date object.

        """
        raise NotImplementedError

    def set_minimum(self, date):
        """ Set the widget's minimum date.

        Parameters
        ----------
        date : date
            The date object to use for setting the minimum date.

        """
        raise NotImplementedError

    def set_maximum(self, date):
        """ Set the widget's maximum date.

        Parameters
        ----------
        date : date
            The date object to use for setting the maximum date.

        """
        raise NotImplementedError

    def set_date(self, date):
        """ Set the widget's current date.

        Parameters
        ----------
        date : date
            The date object to use for setting the date.

        """
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = wx_calendar
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from wx.calendar import CalendarCtrl, EVT_CALENDAR

from atom.api import Typed

from enaml.widgets.calendar import ProxyCalendar

from .wx_bounded_date import (
    WxBoundedDate, CHANGED_GUARD, as_wx_date, as_py_date
)


class WxCalendar(WxBoundedDate, ProxyCalendar):
    """ A Wx implementation of an Enaml ProxyCalendar.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(CalendarCtrl)

    #--------------------------------------------------------------------------
    # Initialization
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the calender widget.

        """
        self.widget = CalendarCtrl(self.parent_widget())

    def init_widget(self):
        """ Initialize the widget.

        """
        super(WxCalendar, self).init_widget()
        self.widget.Bind(EVT_CALENDAR, self.on_date_changed)

    #--------------------------------------------------------------------------
    # Abstract Method Implementation
    #--------------------------------------------------------------------------
    def get_date(self):
        """ Return the current date in the control.

        Returns
        -------
        result : date
            The current control date as a Python date object.

        """
        return as_py_date(self.widget.GetDate())

    def set_minimum(self, date):
        """ Set the widget's minimum date.

        Parameters
        ----------
        date : date
            The date object to use for setting the minimum date.

        """
        self.widget.SetLowerDateLimit(as_wx_date(date))

    def set_maximum(self, date):
        """ Set the widget's maximum date.

        Parameters
        ----------
        date : date
            The date object to use for setting the maximum date.

        """
        self.widget.SetUpperDateLimit(as_wx_date(date))

    def set_date(self, date):
        """ Set the widget's current date.

        Parameters
        ----------
        date : date
            The date object to use for setting the date.

        """
        self._guard |= CHANGED_GUARD
        try:
            self.widget.SetDate(as_wx_date(date))
        finally:
            self._guard &= ~CHANGED_GUARD

########NEW FILE########
__FILENAME__ = wx_check_box
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx
import wx.lib.newevent

from atom.api import Typed

from enaml.widgets.check_box import ProxyCheckBox

from .wx_abstract_button import WxAbstractButton, CHECKED_GUARD


#: A check box event emitted when the button is clicked.
wxCheckBoxClicked, EVT_CHECKBOX_CLICKED = wx.lib.newevent.NewEvent()

#: A check event emitted when the button value is changed.
wxCheckBoxToggled, EVT_CHECKBOX_TOGGLED = wx.lib.newevent.NewEvent()


class wxProperCheckBox(wx.CheckBox):
    """ A custom subclass of wx.CheckBox.

    This checkbox emits an EVT_CHECKBOX_CLICKED event whenever the
    button is clicked. It also emits an EVT_CHECKBOX_TOGGLED whenever
    the checkbox changes state.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxProperCheckBox.

        *args, **kwargs
            The positional and keyword arguments required to initialize
            a wx.RadioButton.

        """
        super(wxProperCheckBox, self).__init__(*args, **kwargs)
        self._in_click = False
        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.Bind(wx.EVT_CHECKBOX, self.OnToggled)

    def OnLeftDown(self, event):
        """ Handles the left down mouse event for the check box.

        This is first part of generating a click event.

        """
        event.Skip()
        self._in_click = True

    def OnLeftUp(self, event):
        """ Handles the left up mouse event for the check box.

        This is the second part of generating a click event.

        """
        event.Skip()
        if self._in_click:
            self._in_click = False
            event = wxCheckBoxClicked()
            wx.PostEvent(self, event)

    def OnToggled(self, event):
        """ Handles the standard toggle event and emits the custom
        toggle event for the check box.

        """
        event = wxCheckBoxToggled()
        wx.PostEvent(self, event)

    def SetValue(self, val):
        """ Overrides the default SetValue method to emit proper events.

        """
        old = self.GetValue()
        if old != val:
            super(wxProperCheckBox, self).SetValue(val)
            self._last = val
            event = wxCheckBoxToggled()
            wx.PostEvent(self, event)


class WxCheckBox(WxAbstractButton, ProxyCheckBox):
    """ A Wx implementation of an Enaml ProxyCheckBox.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(wxProperCheckBox)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying check box widget.

        """
        self.widget = wxProperCheckBox(self.parent_widget())

    def init_widget(self):
        """ Create and initialize the check box control.

        """
        super(WxCheckBox, self).init_widget()
        widget = self.widget
        widget.Bind(EVT_CHECKBOX_CLICKED, self.on_clicked)
        widget.Bind(EVT_CHECKBOX_TOGGLED, self.on_toggled)

    #--------------------------------------------------------------------------
    # Abstract API Implementation
    #--------------------------------------------------------------------------
    def set_checkable(self, checkable):
        """ Sets whether or not the widget is checkable.

        This is not supported in Wx.

        """
        pass

    def get_checked(self):
        """ Returns the checked state of the widget.

        """
        return self.widget.GetValue()

    def set_checked(self, checked):
        """ Sets the widget's checked state with the provided value.

        """
        self._guard |= CHECKED_GUARD
        try:
            self.widget.SetValue(checked)
        finally:
            self._guard &= ~CHECKED_GUARD

########NEW FILE########
__FILENAME__ = wx_combo_box
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx

from atom.api import Int, Typed

from enaml.widgets.combo_box import ProxyComboBox

from .wx_control import WxControl


# cyclic notification guard flags
INDEX_GUARD = 0x1


class WxComboBox(WxControl, ProxyComboBox):
    """ A Wx implementation of an Enaml ProxyComboBox.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(wx.ComboBox)

    #: Cyclic notification guard. This a bitfield of multiple guards.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the QComboBox widget.

        """
        self.widget = wx.ComboBox(self.parent_widget(), style=wx.CB_READONLY)

    def init_widget(self):
        """ Create and initialize the underlying widget.

        """
        super(WxComboBox, self).init_widget()
        d = self.declaration
        self.set_items(d.items)
        self.set_index(d.index)
        self.set_editable(d.editable)
        self.widget.Bind(wx.EVT_COMBOBOX, self.on_index_changed)

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_index_changed(self, event):
        """ The signal handler for the index changed signal.

        """
        if not self._guard & INDEX_GUARD:
            self.declaration.index = self.widget.GetCurrentSelection()

    #--------------------------------------------------------------------------
    # ProxyComboBox API
    #--------------------------------------------------------------------------
    def set_items(self, items):
        """ Set the items of the ComboBox.

        """
        widget = self.widget
        sel = widget.GetCurrentSelection()
        widget.SetItems(items)
        widget.SetSelection(sel)

    def set_index(self, index):
        """ Set the current index of the ComboBox

        """
        self._guard |= INDEX_GUARD
        try:
            self.widget.SetSelection(index)
        finally:
            self._guard &= ~INDEX_GUARD

    def set_editable(self, editable):
        """ Set whether the combo box is editable.

        This is not supported on wx.

        """
        pass

########NEW FILE########
__FILENAME__ = wx_constraints_widget
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from contextlib import contextmanager

from atom.api import Int, ForwardTyped

from enaml.widgets.constraints_widget import ProxyConstraintsWidget

from .wx_widget import WxWidget


# keep around for backwards compatibility
def size_hint_guard(obj):
    return obj.geometry_guard()


def WxContainer():
    from .wx_container import WxContainer
    return WxContainer


class WxConstraintsWidget(WxWidget, ProxyConstraintsWidget):
    """ A Wx implementation of an Enaml ProxyConstraintsWidget.

    """
    #: The container which manages the layout for this widget. This
    #: is assigned during the layout building pass.
    layout_container = ForwardTyped(WxContainer)

    #: The layout index for this widget's layout item. This is assigned
    #: during the layout building pass.
    layout_index = Int()

    def destroy(self):
        """ A reimplemented destructor.

        This destructor drops the reference to the layout container.

        """
        del self.layout_container
        super(WxConstraintsWidget, self).destroy()

    #--------------------------------------------------------------------------
    # ProxyConstraintsWidget API
    #--------------------------------------------------------------------------
    def request_relayout(self):
        """ Request a relayout of the proxy widget.

        This method forwards the request to the layout container.

        """
        container = self.layout_container
        if container is not None:
            container.request_relayout()

    #--------------------------------------------------------------------------
    # Layout API
    #--------------------------------------------------------------------------
    def geometry_updated(self):
        """ Notify the layout system that the geometry has changed.

        This method forwards the update to the layout container.

        """
        container = self.layout_container
        if container is not None:
            container.geometry_updated(self)
        self.post_wx_layout_request()

    @contextmanager
    def geometry_guard(self):
        """ A context manager for guarding the geometry of the widget.

        If the proxy is fully active, this context manager will call the
        'geometry_updated' method if the size hint, minimum, or maximum
        size of the widget changes during context execution.

        """
        if not self.is_active:
            yield
            return
        widget = self.widget
        old_hint = widget.GetBestSize()
        old_min = widget.GetMinSize()
        old_max = widget.GetMaxSize()
        yield
        if (old_hint != widget.GetBestSize() or
            old_min != widget.GetMinSize() or
            old_max != widget.GetMaxSize()):
            self.geometry_updated()

    #--------------------------------------------------------------------------
    # Reimplementations
    #--------------------------------------------------------------------------
    def set_font(self, font):
        """ A reimplemented font setter.

        This method sets the font from within a geometry guard.

        """
        with self.geometry_guard():
            super(WxConstraintsWidget, self).set_font(font)

########NEW FILE########
__FILENAME__ = wx_container
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from collections import deque
from contextlib import contextmanager

import wx

from atom.api import Atom, Bool, Callable, Float, Typed

from enaml.layout.layout_manager import LayoutItem, LayoutManager
from enaml.widgets.constraints_widget import ConstraintsWidget
from enaml.widgets.container import ProxyContainer

from .wx_constraints_widget import WxConstraintsWidget
from .wx_frame import WxFrame


# Commonly used default sizes
DEFAULT_BEST_SIZE = wx.Size(-1, -1)
DEFAULT_MIN_SIZE = wx.Size(0, 0)
DEFAULT_MAX_SIZE = wx.Size(16777215, 16777215)


class LayoutPoint(Atom):
    """ A class which represents a point in layout space.

    """
    #: The x-coordinate of the point.
    x = Float(0.0)

    #: The y-coordinate of the point.
    y = Float(0.0)


class WxLayoutItem(LayoutItem):
    """ A concrete LayoutItem implementation for a WxConstraintsWidget.

    """
    #: The constraints widget declaration object for the layout item.
    declaration = Typed(ConstraintsWidget)

    #: The underlying widget for the layout item.
    widget = Typed(wx.Window)

    #: The layout point which represents the offset of the parent item
    #: from the origin of the root item.
    offset = Typed(LayoutPoint)

    #: The layout point which represents the offset of this item from
    #: the offset of the root item.
    origin = Typed(LayoutPoint)

    def constrainable(self):
        """ Get a reference to the underlying constrainable object.

        Returns
        -------
        result : Constrainable
            An object which implements the Constrainable interface.

        """
        return self.declaration

    def margins(self):
        """ Get the margins for the underlying widget.

        Returns
        -------
        result : tuple
            An empty tuple as constraints widgets do not have margins.

        """
        return ()

    def size_hint(self):
        """ Get the size hint for the underlying widget.

        Returns
        -------
        result : tuple
            A 2-tuple of numbers representing the (width, height)
            size hint of the widget.

        """
        hint = self.widget.GetBestSize()
        return (hint.width, hint.height)

    def min_size(self):
        """ Get the minimum size for the underlying widget.

        Returns
        -------
        result : tuple
            A 2-tuple of numbers representing the (width, height)
            min size of the widget. If any value is less than zero,
            constraints will not be generated for that dimension.

        """
        min_size = self.widget.GetMinSize()
        if min_size != DEFAULT_MIN_SIZE:
            return (min_size.width, min_size.height)
        return (-1, -1)

    def max_size(self):
        """ Get the maximum size for the underlying widget.

        Returns
        -------
        result : tuple
            A 2-tuple of numbers representing the (width, height)
            max size of the widget. If any value is less than zero,
            constraints will not be generated for that dimension.

        """
        max_size = self.widget.GetMaxSize()
        if max_size != DEFAULT_MAX_SIZE:
            return (max_size.width, max_size.height)
        return (-1, -1)

    def constraints(self):
        """ Get the user-defined constraints for the item.

        Returns
        -------
        result : list
            The list of user-defined constraints.

        """
        return self.declaration.layout_constraints()

    def set_geometry(self, x, y, width, height):
        """ Set the geometry of the underlying widget.

        Parameters
        ----------
        x : float
            The new value for the x-origin of the widget.

        y : float
            The new value for the y-origin of the widget.

        width : float
            The new value for the width of the widget.

        height : float
            The new value for the height of the widget.

        """
        origin = self.origin
        origin.x = x
        origin.y = y
        offset = self.offset
        x -= offset.x
        y -= offset.y
        self.widget.SetDimensions(x, y, width, height)


class WxContainerItem(WxLayoutItem):
    """ A WxLayoutItem subclass which handles container margins.

    """
    #: A callable used to get the container widget margins.
    margins_func = Callable()

    def margins(self):
        """ Get the margins for the underlying widget.

        Returns
        -------
        result : tuple
            A 4-tuple of ints representing the container margins.

        """
        a, b, c, d = self.declaration.padding
        e, f, g, h = self.margins_func(self.widget)
        return (a + e, b + f, c + g, d + h)


class WxSharedContainerItem(WxContainerItem):
    """ A WxContainerItem subclass which works for shared containers.

    """
    def size_hint_constraints(self):
        """ Get the size hint constraints for the item.

        A shared container does not generate size hint constraints.

        """
        return []


class WxChildContainerItem(WxLayoutItem):
    """ A WxLayoutItem subclass which works for child containers.

    """
    def constraints(self):
        """ Get the user constraints for the item.

        A child container does not expose its user defined constraints
        to the parent container.

        """
        return []

    def min_size(self):
        """ Get the minimum size for the underlying widget.

        The min size for a child container lives on the proxy object.
        The widget limits must be bypassed for child container.

        """
        min_size = self.declaration.proxy.min_size
        if min_size != DEFAULT_MIN_SIZE:
            return (min_size.width, min_size.height)
        return (-1, -1)

    def max_size(self):
        """ Get the maximum size for the underlying widget.

        The max size for a child container lives on the proxy object.
        The widget limits must be bypassed for child container.

        """
        max_size = self.declaration.proxy.max_size
        if max_size != DEFAULT_MAX_SIZE:
            return (max_size.width, max_size.height)
        return (-1, -1)


class wxContainer(wx.PyPanel):
    """ A subclass of wx.PyPanel which allows the default best size to
    be overriden by calling SetBestSize.

    This functionality is used by the WxContainer to override the
    size hint with a value computed from the constraints layout
    manager.

    """
    #: An invalid wx.Size used as the default value for class instances.
    _best_size = wx.Size(-1, -1)

    def DoGetBestSize(self):
        """ Reimplemented parent class method.

        This will return the best size as set by a call to SetBestSize.
        If that is invalid, then the superclass' version will be used.

        """
        size = self._best_size
        if not size.IsFullySpecified():
            size = super(wxContainer, self).DoGetBestSize()
        return size

    def SetBestSize(self, size):
        """ Sets the best size to use for this container.

        """
        self._best_size = size


class wxLayoutTimer(wx.Timer):
    """ A custom wx Timer which for collapsing layout requests.

    """
    def __init__(self, owner):
        super(wxLayoutTimer, self).__init__()
        self.owner = owner

    def Notify(self):
        self.owner._on_relayout_timer()


class WxContainer(WxFrame, ProxyContainer):
    """ A Wx implementation of an Enaml ProxyContainer.

    """
    #: A reference to the toolkit widget created by the proxy.
    widget = Typed(wxContainer)

    #: The minimum size of the container as computed by the layout
    #: manager. This will be updated on every relayout pass and is
    #: used by the WxChildContainerItem to generate size constraints.
    min_size = Typed(wx.Size)

    #: The maximum size of the container as computed by the layout
    #: manager. This will be updated on every relayout pass and is
    #: used by the WxChildContainerItem to generate size constraints.
    max_size = Typed(wx.Size)

    #: A timer used to collapse relayout requests. The timer is created
    #: on an as needed basis and destroyed when it is no longer needed.
    _layout_timer = Typed(wxLayoutTimer)

    #: The layout manager which handles the system of constraints.
    _layout_manager = Typed(LayoutManager)

    #: Whether or not the current container is shown. This is toggled
    #: by the EVT_SHOW handler.
    _is_shown = Bool(True)

    def destroy(self):
        """ A reimplemented destructor.

        This destructor clears the layout timer and layout manager
        so that any potential reference cycles are broken.

        """
        timer = self._layout_timer
        if timer is not None:
            timer.Stop()
            del self._layout_timer
        del self._layout_manager
        super(WxContainer, self).destroy()

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Creates the QContainer widget.

        """
        self.widget = wxContainer(self.parent_widget())

    def init_layout(self):
        """ Initialize the layout of the widget.

        """
        super(WxContainer, self).init_layout()
        self._setup_manager()
        self._update_size_bounds()
        self._update_geometries()
        widget = self.widget
        widget.Bind(wx.EVT_SIZE, self._on_resized)
        widget.Bind(wx.EVT_SHOW, self._on_shown)

    #--------------------------------------------------------------------------
    # Layout API
    #--------------------------------------------------------------------------
    def request_relayout(self):
        """ Request a relayout of the container.

        """
        # If this container owns the layout, (re)start the timer. The
        # list of layout items is reset to prevent an edge case where
        # a parent container layout occurs before the child container,
        # causing the child to resize potentially deleted widgets which
        # still have strong refs in the layout items list.
        manager = self._layout_manager
        if manager is not None:
            if self._layout_timer is None:
                manager.clear_items()
                self.widget.Freeze()
                self._layout_timer = wxLayoutTimer(self)
            self._layout_timer.Start(1, oneShot=True)
            return

        # If an ancestor container owns the layout, proxy the call.
        container = self.layout_container
        if container is not None:
            container.request_relayout()

    def geometry_updated(self, item=None):
        """ Notify the layout system that the geometry has changed.

        Parameters
        ----------
        item : WxConstraintsWidget, optional
            The constraints widget with the updated geometry. If this
            is None, it indicates that this container's geometry is
            the one which has changed.

        """
        # If this container's geometry has changed and it has an ancestor
        # layout container, notify that container since it cares about
        # this container's geometry. If the layout for this container is
        # shared, the layout item will take care of supplying the proper
        # list geometry constraints.
        container = self.layout_container
        if item is None:
            if container is not None:
                container.geometry_updated(self)
            self.post_wx_layout_request()
            return

        # If this container owns its layout, update the manager unless
        # a relayout is pending. A pending relayout means the manager
        # has already been reset and the layout indices are invalid.
        manager = self._layout_manager
        if manager is not None:
            if self._layout_timer is None:
                with self.geometry_guard():
                    manager.update_geometry(item.layout_index)
                    self._update_size_bounds()
                    self._update_geometries()
            return

        # If an ancestor container owns the layout, proxy the call.
        if container is not None:
            container.geometry_updated(item)

    @contextmanager
    def geometry_guard(self):
        """ A context manager for guarding the geometry of the widget.

        This is a reimplementation of the superclass method which uses
        the internally computed min and max size of the container.

        """
        old_hint = self.widget.GetBestSize()
        old_min = self.min_size
        old_max = self.max_size
        yield
        if (old_hint != self.widget.GetBestSize() or
            old_min != self.min_size or
            old_max != self.max_size):
            self.geometry_updated()

    @staticmethod
    def margins_func(widget_item):
        """ Get the margins for the given widget item.

        The container margins are added to the user provided padding
        to determine the final offset from a layout box boundary to
        the corresponding content line. The default container margins
        are zero. This method can be reimplemented by subclasses to
        supply different margins.

        Returns
        -------
        result : tuple
            A 4-tuple of margins (top, right, bottom, left).

        """
        return (0, 0, 0, 0)

    def margins_updated(self, item=None):
        """ Notify the layout system that the margins have changed.

        Parameters
        ----------
        item : WxContainer, optional
            The container widget with the updated margins. If this is
            None, it indicates that this container's margins are the
            ones which have changed.

        """
        # If this container owns its layout, update the manager unless
        # a relayout is pending. A pending relayout means the manager
        # has already been reset and the layout indices are invalid.
        manager = self._layout_manager
        if manager is not None:
            if self._layout_timer is None:
                index = item.layout_index if item else -1
                with self.geometry_guard():
                    manager.update_margins(index)
                    self._update_size_bounds()
                    self._update_geometries()
            return

        # If an ancestor container owns the layout, forward the call.
        container = self.layout_container
        if container is not None:
            container.margins_updated(item or self)

    #--------------------------------------------------------------------------
    # Private Event Handlers
    #--------------------------------------------------------------------------
    def _on_resized(self, event):
        """ The event handler for the EVT_SIZE event.

        This triggers a geometry update for the decendant children.

        """
        if self._is_shown:
            self._update_geometries()

    def _on_shown(self, event):
        """ The event handler for the EVT_SHOW event.

        This handler toggles the value of the _is_shown flag.

        """
        # The EVT_SHOW event is not reliable. For example, it is not
        # emitted on the children of widgets that were hidden. So, if
        # this container is the child of, say, a notebook page, then
        # the switching of tabs does not emit a show event. So, the
        # notebook page must cooperatively emit a show event on this
        # container. Therefore, we can't treat this event as a 'real'
        # toolkit event, we just use it as a hint.
        self._is_shown = shown = event.GetShow()
        if shown:
            self._update_geometries()

    def _on_relayout_timer(self):
        """ Rebuild the layout for the container.

        This method is invoked when the relayout timer is triggered. It
        will reset the manager and update the geometries of the children.

        """
        self._layout_timer.Stop()
        del self._layout_timer
        with self.geometry_guard():
            self._setup_manager()
            self._update_size_bounds()
            self._update_geometries()
        self.widget.Thaw()

    #--------------------------------------------------------------------------
    # Private Layout Handling
    #--------------------------------------------------------------------------
    def _setup_manager(self):
        """ Setup the layout manager.

        This method will create or reset the layout manager and update
        it with a new layout table.

        """
        # Layout ownership can only be transferred *after* the init
        # layout method is called, as layout occurs bottom up. The
        # manager is only created if ownership is unlikely to change.
        share_layout = self.declaration.share_layout
        if share_layout and isinstance(self.parent(), WxContainer):
            timer = self._layout_timer
            if timer is not None:
                timer.Stop()
            del self._layout_timer
            del self._layout_manager
            return

        manager = self._layout_manager
        if manager is None:
            item = WxContainerItem()
            item.declaration = self.declaration
            item.widget = self.widget
            item.origin = LayoutPoint()
            item.offset = LayoutPoint()
            item.margins_func = self.margins_func
            manager = self._layout_manager = LayoutManager(item)
        manager.set_items(self._create_layout_items())

    def _update_geometries(self):
        """ Update the geometries of the layout children.

        This method will resize the layout manager to the container size.

        """
        manager = self._layout_manager
        if manager is not None:
            width, height = self.widget.GetSizeTuple()
            manager.resize(width, height)

    def _update_size_bounds(self):
        """ Update the size bounds of the underlying container.

        This method will update the min, max, and best size of the
        container. It will not automatically trigger a geometry
        notification.

        """
        widget = self.widget
        manager = self._layout_manager
        if manager is None:
            best_size = DEFAULT_BEST_SIZE
            min_size = DEFAULT_MIN_SIZE
            max_size = DEFAULT_MAX_SIZE
        else:
            best_size = wx.Size(*manager.best_size())
            min_size = wx.Size(*manager.min_size())
            max_size = wx.Size(*manager.max_size())

        # Store the computed min and max size, which is used by the
        # WxChildContainerItem to provide min and max size constraints.
        self.min_size = min_size
        self.max_size = max_size

        # If this is a child container, min and max size are not applied
        # to the widget since the ancestor manager must be the ultimate
        # authority on layout size.
        widget.SetBestSize(best_size)
        if isinstance(self.parent(), WxContainer):
            widget.SetMinSize(DEFAULT_MIN_SIZE)
            widget.SetMaxSize(DEFAULT_MAX_SIZE)
        else:
            widget.SetMinSize(min_size)
            widget.SetMaxSize(max_size)

    def _create_layout_items(self):
        """ Create a layout items for the container decendants.

        The layout items are created by traversing the decendants in
        breadth-first order and setting up a LayoutItem object for
        each decendant. The layout item is populated with an offset
        point which represents the offset of the widgets parent to
        the origin of the widget which owns the layout solver. This
        point is substracted from the solved origin of the widget.

        Returns
        -------
        result : list
            A list of LayoutItem objects which represent the flat
            layout traversal.

        """
        layout_items = []
        offset = LayoutPoint()
        queue = deque((offset, child) for child in self.children())
        while queue:
            offset, child = queue.popleft()
            if isinstance(child, WxConstraintsWidget):
                child.layout_container = self
                origin = LayoutPoint()
                if isinstance(child, WxContainer):
                    if child.declaration.share_layout:
                        item = WxSharedContainerItem()
                        item.margins_func = child.margins_func
                        for subchild in child.children():
                            queue.append((origin, subchild))
                    else:
                        item = WxChildContainerItem()
                else:
                    item = WxLayoutItem()
                item.declaration = child.declaration
                item.widget = child.widget
                item.offset = offset
                item.origin = origin
                child.layout_index = len(layout_items)
                layout_items.append(item)
        return layout_items

########NEW FILE########
__FILENAME__ = wx_control
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from enaml.widgets.control import ProxyControl

from .wx_constraints_widget import WxConstraintsWidget


class WxControl(WxConstraintsWidget, ProxyControl):
    """ A Wx implementation of an Enaml Control.

    """
    # The WxConstraintsWidget superclass is a sufficient implementation.
    pass

########NEW FILE########
__FILENAME__ = wx_date_selector
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx

from atom.api import Typed

from enaml.widgets.date_selector import ProxyDateSelector

from .wx_bounded_date import (
    WxBoundedDate, CHANGED_GUARD, as_wx_date, as_py_date
)


class WxDateSelector(WxBoundedDate, ProxyDateSelector):
    """ A Wx implementation of an Enaml ProxyDateSelector.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(wx.DatePickerCtrl)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the wx.DatePickerCtrl widget.

        """
        self.widget = wx.DatePickerCtrl(self.parent_widget())

    def init_widget(self):
        """ Initialize the widget.

        """
        super(WxDateSelector, self).init_widget()
        d = self.declaration
        self.set_date_format(d.date_format)
        self.set_calendar_popup(d.calendar_popup)
        self.widget.Bind(wx.EVT_DATE_CHANGED, self.on_date_changed)

    #--------------------------------------------------------------------------
    # Abstract API Implementation
    #--------------------------------------------------------------------------
    def get_date(self):
        """ Return the current date in the control.

        Returns
        -------
        result : date
            The current control date as a date object.

        """
        return as_py_date(self.widget.GetValue())

    def set_minimum(self, date):
        """ Set the widget's minimum date.

        Parameters
        ----------
        date : date
            The date object to use for setting the minimum date.

        """
        widget = self.widget
        widget.SetRange(as_wx_date(date), widget.GetUpperLimit())


    def set_maximum(self, date):
        """ Set the widget's maximum date.

        Parameters
        ----------
        date : date
            The date object to use for setting the maximum date.

        """
        widget = self.widget
        widget.SetRange(widget.GetLowerLimit(), as_wx_date(date))

    def set_date(self, date):
        """ Set the widget's current date.

        Parameters
        ----------
        date : date
            The date object to use for setting the date.

        """
        self._guard |= CHANGED_GUARD
        try:
            self.widget.SetValue(as_wx_date(date))
        finally:
            self._guard &= ~CHANGED_GUARD

    def set_date_format(self, format):
        """ Set the widget's date format.

        Parameters
        ----------
        format : string
            A Python time formatting string.

        .. note:: Changing the format on wx is not supported.
                  See http://trac.wxwidgets.org/ticket/10988

        """
        pass

    def set_calendar_popup(self, popup):
        """ This is not supported on Wx.

        """
        pass

########NEW FILE########
__FILENAME__ = wx_deferred_caller
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx


class wxDeferredCaller(object):
    """ A simple object which facilitates running callbacks on the main
    application thread.

    """
    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def DeferredCall(self, callback, *args, **kwargs):
        """ Execute the callback on the main gui thread.

        Parameters
        ----------
        callback : callable
            The callable object to execute on the main thread.

        *args, **kwargs
            Any additional positional and keyword arguments to pass to
            the callback.

        """
        wx.CallAfter(callback, *args, **kwargs)

    def TimedCall(self, ms, callback, *args, **kwargs):
        """ Execute a callback on timer in the main gui thread.

        Parameters
        ----------
        ms : int
            The time to delay, in milliseconds, before executing the
            callable.

        callback : callable
            The callable object to execute at on the timer.

        *args, **kwargs
            Any additional positional and keyword arguments to pass to
            the callback.

        """
        f = lambda: wx.CallLater(ms, callback, *args, **kwargs)
        wx.CallAfter(f)


#: A globally available caller instance. This will be created on demand
#: by the globally available caller functions.
_caller = None


def DeferredCall(callback, *args, **kwargs):
    """ Execute the callback on the main gui thread.

    This is a convenience wrapper around QDeferredCaller.deferredCall.
    This should only be called after the QApplication is created.

    """
    global _caller
    c = _caller
    if c is None:
        c = _caller = wxDeferredCaller()
    c.DeferredCall(callback, *args, **kwargs)


def TimedCall(ms, callback, *args, **kwargs):
    """ Execute a callback on a timer in the main gui thread.

    This is a convenience wrapper around QDeferredCaller.timedCall.
    This should only be called after the QApplication is created.

    """
    global _caller
    c = _caller
    if c is None:
        c = _caller = wxDeferredCaller()
    c.TimedCall(ms, callback, *args, **kwargs)

########NEW FILE########
__FILENAME__ = wx_dock_pane
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx
import wx.lib.newevent

from atom.api import Int, Typed

from enaml.widgets.dock_pane import ProxyDockPane

from .wx_container import WxContainer
from .wx_single_widget_sizer import wxSingleWidgetSizer
from .wx_upstream import aui
from .wx_widget import WxWidget


#: A mapping from Enaml dock areas to wx aui dock area enums
_DOCK_AREA_MAP = {
    'top': aui.AUI_DOCK_TOP,
    'right': aui.AUI_DOCK_RIGHT,
    'bottom': aui.AUI_DOCK_BOTTOM,
    'left': aui.AUI_DOCK_LEFT,
}

#: A mapping from wx aui dock area enums to Enaml dock areas.
_DOCK_AREA_INV_MAP = {
    aui.AUI_DOCK_TOP: 'top',
    aui.AUI_DOCK_RIGHT: 'right',
    aui.AUI_DOCK_BOTTOM: 'bottom',
    aui.AUI_DOCK_LEFT: 'left',
}

#: A mapping from Enaml allowed dock areas to wx direction enums.
_ALLOWED_AREAS_MAP = {
    'top': wx.TOP,
    'right': wx.RIGHT,
    'bottom': wx.BOTTOM,
    'left': wx.LEFT,
    'all': wx.ALL,
}

#: A mappint from Enaml orientations to wx orientations.
_ORIENTATION_MAP = {
    'horizontal': wx.HORIZONTAL,
    'vertical': wx.VERTICAL,
}


#: An event emitted when the dock pane is floated.
wxDockPaneFloatedEvent, EVT_DOCK_PANE_FLOATED = wx.lib.newevent.NewEvent()

#: An event emitted when the dock is docked.
wxDockPaneDockedEvent, EVT_DOCK_PANE_DOCKED = wx.lib.newevent.NewEvent()

#: An event emitted when the dock pane is closed.
wxDockPaneClosedEvent, EVT_DOCK_PANE_CLOSED = wx.lib.newevent.NewEvent()


class wxDockPane(wx.Panel):
    """ A wxPanel subclass which adds DockPane features.

    """
    def __init__(self, parent, *args, **kwargs):
        """ Initialize a wxDockPane.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initialize
            a wxPanel.

        """
        super(wxDockPane, self).__init__(parent, *args, **kwargs)
        self._is_open = True
        self._title = u''
        self._title_bar_visible = True
        self._title_bar_orientation = wx.HORIZONTAL
        self._closable = True
        self._movable = True
        self._floatable = True
        self._floating = False
        self._dock_area = aui.AUI_DOCK_LEFT
        self._allowed_dock_areas = wx.ALL
        self._dock_widget = None
        self.SetSizer(wxSingleWidgetSizer())

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _FindPaneManager(self):
        """ Find the pane manager for this dock pane.

        Returns
        -------
        result : AuiManager or None
            The AuiManager for this dock pane, or None if not found.

        """
        event = aui.AuiManagerEvent(aui.wxEVT_AUI_FIND_MANAGER)
        self.ProcessEvent(event)
        return event.GetManager()

    def _PaneInfoOperation(self, closure):
        """ A private method which will run the given closure if there
        is a valid pane info object for this dock pane.

        """
        manager = self._FindPaneManager()
        if manager is not None:
            pane = manager.GetPane(self)
            if pane.IsOk():
                closure(pane)
                manager.Update()

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def OnClose(self, event):
        """ Handles the parent EVT_AUI_PANE_CLOSE event.

        This event handler is called directly by the parent wxMainWindow
        from its pane close event handler. This handler simply emits the
        EVT_DOCK_PANE_CLOSED event.

        """
        self._is_open = False
        wx.PostEvent(self, wxDockPaneClosedEvent())

    def OnFloated(self, event):
        """ Handles the parent EVT_AUI_PANE_FLOATED event.

        This event handler is called directly by the parent wxMainWindow
        from its pane floated event handler. This handler simply emits
        the EVT_DOCK_PANE_FLOATED event.

        """
        self._floating = True
        wx.PostEvent(self, wxDockPaneFloatedEvent())

    def OnDocked(self, event):
        """ Handles the parent EVT_AUI_PANE_DOCKED event.

        This event handler is called directly by the parent wxMainWindow
        from its pane docked event handler. This handler simply emits
        the EVT_DOCK_PANE_DOCKED event.

        """
        self._floating = False
        self._dock_area = event.GetPane().dock_direction
        wx.PostEvent(self, wxDockPaneDockedEvent())

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def MakePaneInfo(self):
        """ Create a new AuiPaneInfo object for this dock pane.

        This is called by the wxMainWindow when it adds this dock pane
        to its internal layout for the first time.

        Returns
        -------
        result : AuiPaneInfo
            An initialized AuiPaneInfo object for this pane.

        """
        info = aui.AuiPaneInfo()

        # Don't allow docking panes as a notebook since that causes
        # issues with finding the proper parent manager on updates
        # and it makes resizing of dock panes abysmally slow.
        info.NotebookDockable(False)

        info.BestSize(self.GetBestSize())
        info.MinSize(self.GetEffectiveMinSize())
        info.Show(self.IsOpen())
        info.Caption(self.GetTitle())
        info.CloseButton(self.GetClosable())
        info.Movable(self.GetMovable())
        info.Floatable(self.GetFloatable())
        info.Direction(self.GetDockArea())

        left = self.GetTitleBarOrientation() == wx.VERTICAL
        info.CaptionVisible(self.GetTitleBarVisible(), left)

        areas = self.GetAllowedDockAreas()
        info.TopDockable(bool(areas & wx.TOP))
        info.RightDockable(bool(areas & wx.RIGHT))
        info.LeftDockable(bool(areas & wx.LEFT))
        info.BottomDockable(bool(areas & wx.BOTTOM))

        if self.GetFloating():
            info.Float()
        else:
            info.Dock()

        return info

    def GetDockWidget(self):
        """ Get the dock widget being managed by this pane.

        Returns
        -------
        result : wxWindow or None
            The wx widget being managed by this dock pane, or None
            if no widget is being managed.

        """
        return self._dock_widget

    def SetDockWidget(self, widget):
        """ Set the dock widget to be managed by the pane.

        Any old dock widget will be removed, but not destroyed.

        Parameters
        ----------
        widget : wxWindow
            The wx widget to use as the dock widget for this pane.

        """
        old_widget = self._dock_widget
        if old_widget:
            old_widget.Hide()
        self._dock_widget = widget
        self.GetSizer().Add(widget)
        self.UpdateSizing()

    def UpdateSizing(self):
        """ Trigger a sizing update of the pane manager.

        """
        def closure(pane):
            pane.MinSize(self.GetBestSize())
        self._PaneInfoOperation(closure)

    def IsOpen(self):
        """ Get whether or not the dock pane is open.

        Returns
        -------
        result : bool
            True if the pane is open, False otherwise.

        """
        return self._is_open

    def Open(self):
        """ Open the dock pane in the main window.

        If the pane is already open, this method is a no-op.

        """
        self._is_open = True
        def closure(pane):
            if not pane.IsShown():
                pane.Show(True)
        self._PaneInfoOperation(closure)

    def Close(self):
        """ Close the dock pane in the main window.

        If the pane is already closed, this method is no-op.

        """
        self._is_open = False
        def closure(pane):
            if pane.IsShown():
                pane.Show(False)
        self._PaneInfoOperation(closure)

    def GetTitle(self):
        """ Get the title for the dock pane.

        Returns
        -------
        result : unicode
            The title of the dock pane.

        """
        return self._title

    def SetTitle(self, title):
        """ Set the title for the dock pane.

        Parameters
        ----------
        title : unicode
            The title to use for the dock pane.

        """
        if self._title != title:
            self._title = title
            def closure(pane):
                pane.Caption(title)
            self._PaneInfoOperation(closure)

    def GetTitleBarVisible(self):
        """ Get the title bar visibility state for the dock pane.

        Returns
        -------
        result : bool
            Whether or not the title bar is visible.

        """
        return self._title_bar_visible

    def SetTitleBarVisible(self, visible):
        """ Set the title bar visibility state for the dock pane.

        Parameters
        ----------
        visible : bool
            Whether or not the title bar should be visible.

        """
        if self._title_bar_visible != visible:
            self._title_bar_visible = visible
            def closure(pane):
                left = self._title_bar_orientation == wx.VERTICAL
                pane.CaptionVisible(visible, left)
            self._PaneInfoOperation(closure)

    def GetTitleBarOrientation(self):
        """ Get the title bar orientation for the dock pane.

        Returns
        -------
        result : int
            The orientation of the title bar. Either wx.HORIZONTAL
            or wx.VERTICAL

        """
        return self._title_bar_orientation

    def SetTitleBarOrientation(self, orientation):
        """ Set the title bar orientation for the dock pane.

        Parameters
        ----------
        result : int
            The orientation of the title bar. Either wx.HORIZONTAL
            or wx.VERTICAL

        """
        if self._title_bar_orientation != orientation:
            self._title_bar_orientation = orientation
            def closure(pane):
                visible = self._title_bar_visible
                left = orientation == wx.VERTICAL
                pane.CaptionVisible(visible, left)
            self._PaneInfoOperation(closure)

    def GetClosable(self):
        """ Get the closable state of the pane.

        Returns
        -------
        result : bool
            Whether or not the pane is closable.

        """
        return self._closable

    def SetClosable(self, closable):
        """ Set the closable state of the pane.

        Parameters
        ----------
        closable : bool
            Whether or not the pane is closable.

        """
        if self._closable != closable:
            self._closable = closable
            def closure(pane):
                pane.CloseButton(closable)
            self._PaneInfoOperation(closure)

    def GetMovable(self):
        """ Get the movable state of the pane.

        Returns
        -------
        result : bool
            Whether or not the pane is movable.

        """
        return self._movable

    def SetMovable(self, movable):
        """ Set the movable state of the pane.

        Parameters
        ----------
        movable : bool
            Whether or not the pane is movable.

        """
        if self._movable != movable:
            self._movable = movable
            def closure(pane):
                pane.Movable(movable)
            self._PaneInfoOperation(closure)

    def GetFloatable(self):
        """ Get the floatable state of the pane.

        Returns
        -------
        result : bool
            Whether or not the pane is floatable.

        """
        return self._floatable

    def SetFloatable(self, floatable):
        """ Set the floatable state of the pane.

        Parameters
        ----------
        floatable : bool
            Whether or not the pane is floatable.

        """
        if self._floatable != floatable:
            self._floatable = floatable
            def closure(pane):
                pane.Floatable(floatable)
            self._PaneInfoOperation(closure)

    def GetFloating(self):
        """ Get the floating state of the pane.

        Returns
        -------
        result : bool
            Whether or not the pane is floating.

        """
        return self._floating

    def SetFloating(self, floating):
        """ Set the floating state of the pane.

        Parameters
        ----------
        floating : bool
            Whether or not the pane should be floating.

        """
        if self._floating != floating:
            self._floating = floating
            def closure(pane):
                if floating:
                    pane.Float()
                else:
                    pane.Dock()
            self._PaneInfoOperation(closure)

    def GetDockArea(self):
        """ Get the current dock area of the pane.

        Returns
        -------
        result : int
            The current dock area of the pane. One of the wx enums
            LEFT, RIGHT, TOP, or BOTTOM.

        """
        return self._dock_area

    def SetDockArea(self, dock_area):
        """ Set the dock area for the pane.

        Parameters
        ----------
        dock_area : int
            The dock area for the pane. One of the wx enums LEFT,
            RIGHT, TOP, or BOTTOM.

        """
        if self._dock_area != dock_area:
            self._dock_area = dock_area
            def closure(pane):
                pane.Direction(dock_area)
            self._PaneInfoOperation(closure)

    def GetAllowedDockAreas(self):
        """ Get the allowed dock areas for the pane.

        Returns
        -------
        result : int
            The allowed dock areas for the pane. One of the wx enums
            LEFT, RIGHT, TOP, BOTTOM, or ALL.

        """
        return self._allowed_dock_areas

    def SetAllowedDockAreas(self, dock_areas):
        """ Set the allowed dock areas for the pane.

        Parameters
        ----------
        dock_areas : int
            The allowed dock areas for the pane. One of the wx enums
            LEFT, RIGHT, TOP, BOTTOM, or ALL.

        """
        if self._allowed_dock_areas != dock_areas:
            self._allowed_dock_areas = dock_areas
            def closure(pane):
                pane.TopDockable(bool(dock_areas & wx.TOP))
                pane.RightDockable(bool(dock_areas & wx.RIGHT))
                pane.LeftDockable(bool(dock_areas & wx.LEFT))
                pane.BottomDockable(bool(dock_areas & wx.BOTTOM))
            self._PaneInfoOperation(closure)


# cyclic notification guard flags
FLOATED_GUARD = 0x1


class WxDockPane(WxWidget, ProxyDockPane):
    """ A Wx implementation of an Enaml ProxyDockPane.

    """
    #: A reference tot he widget created by the proxy.
    widget = Typed(wxDockPane)

    #: Cyclic notification guard. This a bitfield of multiple guards.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the wxDockPane widget.

        """
        self.widget = wxDockPane(self.parent_widget())

    def init_widget(self):
        """ Initialize the dock pane control.

        """
        super(WxDockPane, self).init_widget()
        d = self.declaration
        self.set_title(d.title)
        self.set_title_bar_visible(d.title_bar_visible)
        self.set_title_bar_orientation(d.title_bar_orientation)
        self.set_closable(d.closable)
        self.set_movable(d.movable)
        self.set_floatable(d.floatable)
        self.set_floating(d.floating)
        self.set_dock_area(d.dock_area)
        self.set_allowed_dock_areas(d.allowed_dock_areas)
        widget = self.widget
        widget.Bind(EVT_DOCK_PANE_FLOATED, self.on_floated)
        widget.Bind(EVT_DOCK_PANE_DOCKED, self.on_docked)
        widget.Bind(EVT_DOCK_PANE_CLOSED, self.on_closed)

    def init_layout(self):
        """ Handle the layout initialization for the dock pane.

        """
        super(WxDockPane, self).init_layout()
        self.widget.SetDockWidget(self.dock_widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def dock_widget(self):
        """ Find and return the dock widget child for this widget.

        Returns
        -------
        result : wxWindow or None
            The dock widget defined for this widget, or None if one is
            not defined.

        """
        d = self.declaration.dock_widget()
        if d is not None:
            return d.proxy.widget

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a WxDockPane.

        """
        super(WxDockPane, self).child_added(child)
        if isinstance(child, WxContainer):
            self.widget.SetDockWidget(self.dock_widget())

    def child_removed(self, child):
        """ Handle the child removed event for a WxDockPane.

        """
        super(WxDockPane, self).child_removed(child)
        if isinstance(child, WxContainer):
            self.widget.SetDockWidget(self.dock_widget())

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_closed(self, event):
        """ The event handler for the EVT_DOCK_PANE_CLOSED event.

        """
        # The closed signal is only emitted when the widget is closed
        # by the user, so there is no need for a loopback guard.
        self.declaration.visible = False
        self.declaration.closed()

    def on_floated(self, event):
        """ The event handler for the EVT_DOCK_PANE_FLOATED event.

        """
        if not self._guard & FLOATED_GUARD:
            self._guard |= FLOATED_GUARD
            try:
                self.declaration.floating = True
            finally:
                self._guard &= ~FLOATED_GUARD

    def on_docked(self, event):
        """ The event handler for the EVT_DOCK_PANE_AREA event.

        """
        area = self.widget.GetDockArea()
        if not self._guard & FLOATED_GUARD:
            self._guard |= FLOATED_GUARD
            try:
                self.declaration.floating = False
                self.declaration.dock_area = _DOCK_AREA_INV_MAP[area]
            finally:
                self._guard &= ~FLOATED_GUARD

    #--------------------------------------------------------------------------
    # ProxyDockPane API
    #--------------------------------------------------------------------------
    def set_visible(self, visible):
        """ An overridden visibility setter which to opens|closes the
        dock pane.

        """
        if visible:
            self.widget.Open()
        else:
            self.widget.Close()

    def ensure_visible(self):
        """ An overridden visibility setter which to opens|closes the
        dock pane.

        """
        self.set_visible(True)

    def ensure_hidden(self):
        """ An overridden visibility setter which to opens|closes the
        dock pane.

        """
        self.set_visible(False)

    def set_title(self, title):
        """ Set the title on the underlying widget.

        """
        self.widget.SetTitle(title)

    def set_title_bar_visible(self, visible):
        """ Set the title bar visibility of the underlying widget.

        """
        self.widget.SetTitleBarVisible(visible)

    def set_title_bar_orientation(self, orientation):
        """ Set the title bar orientation of the underyling widget.

        """
        self.widget.SetTitleBarOrientation(_ORIENTATION_MAP[orientation])

    def set_closable(self, closable):
        """ Set the closable state on the underlying widget.

        """
        self.widget.SetClosable(closable)

    def set_movable(self, movable):
        """ Set the movable state on the underlying widget.

        """
        self.widget.SetMovable(movable)

    def set_floatable(self, floatable):
        """ Set the floatable state on the underlying widget.

        """
        self.widget.SetFloatable(floatable)

    def set_floating(self, floating):
        """ Set the floating staet on the underlying widget.

        """
        if not self._guard & FLOATED_GUARD:
            self._guard |= FLOATED_GUARD
            try:
                self.widget.SetFloating(floating)
            finally:
                self._guard &= ~FLOATED_GUARD

    def set_dock_area(self, dock_area):
        """ Set the dock area on the underyling widget.

        """
        self.widget.SetDockArea(_DOCK_AREA_MAP[dock_area])

    def set_allowed_dock_areas(self, dock_areas):
        """ Set the allowed dock areas on the underlying widget.

        """
        wx_areas = 0
        for area in dock_areas:
            wx_areas |= _ALLOWED_AREAS_MAP[area]
        self.widget.SetAllowedDockAreas(wx_areas)

########NEW FILE########
__FILENAME__ = wx_factories
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
def action_factory():
    from .wx_action import WxAction
    return WxAction


def action_group_factory():
    from .wx_action_group import WxActionGroup
    return WxActionGroup


def calendar_factory():
    from .wx_calendar import WxCalendar
    return WxCalendar


def check_box_factory():
    from .wx_check_box import WxCheckBox
    return WxCheckBox


def combo_box_factory():
    from .wx_combo_box import WxComboBox
    return WxComboBox


def container_factory():
    from .wx_container import WxContainer
    return WxContainer


def date_selector_factory():
    from .wx_date_selector import WxDateSelector
    return WxDateSelector


# def datetime_selector_factory():
#     from .wx_datetime_selector import WxDatetimeSelector
#     return WxDatetimeSelector


def dock_pane_factory():
    from .wx_dock_pane import WxDockPane
    return WxDockPane


def field_factory():
    from .wx_field import WxField
    return WxField


def group_box_factory():
    from .wx_group_box import WxGroupBox
    return WxGroupBox


def html_factory():
    from .wx_html import WxHtml
    return WxHtml


# def image_view_factory():
#     from .wx_image_view import WxImageView
#     return WxImageView


def label_factory():
    from .wx_label import WxLabel
    return WxLabel


def main_window_factory():
    from .wx_main_window import WxMainWindow
    return WxMainWindow


def menu_factory():
    from .wx_menu import WxMenu
    return WxMenu


def menu_bar_factory():
    from .wx_menu_bar import WxMenuBar
    return WxMenuBar


def mpl_canvas_factory():
    from .wx_mpl_canvas import WxMPLCanvas
    return WxMPLCanvas


def notebook_factory():
    from .wx_notebook import WxNotebook
    return WxNotebook


def page_factory():
    from .wx_page import WxPage
    return WxPage


def push_button_factory():
    from .wx_push_button import WxPushButton
    return WxPushButton


def progress_bar_factory():
    from .wx_progress_bar import WxProgressBar
    return WxProgressBar


def radio_button_factory():
    from .wx_radio_button import WxRadioButton
    return WxRadioButton


def scroll_area_factory():
    from .wx_scroll_area import WxScrollArea
    return WxScrollArea


def slider_factory():
    from .wx_slider import WxSlider
    return WxSlider


def spin_box_factory():
    from .wx_spin_box import WxSpinBox
    return WxSpinBox


def split_item_factory():
    from .wx_split_item import WxSplitItem
    return WxSplitItem


def splitter_factory():
    from .wx_splitter import WxSplitter
    return WxSplitter


def tool_bar_factory():
    from .wx_tool_bar import WxToolBar
    return WxToolBar


def window_factory():
    from .wx_window import WxWindow
    return WxWindow


WX_FACTORIES = {
    'Action': action_factory,
    'ActionGroup': action_group_factory,
    'Calendar': calendar_factory,
    'CheckBox': check_box_factory,
    'ComboBox': combo_box_factory,
    'Container': container_factory,
    'DateSelector': date_selector_factory,
    'DockPane': dock_pane_factory,
    'Field': field_factory,
    'GroupBox': group_box_factory,
    'Html': html_factory,
    'Label': label_factory,
    'MainWindow': main_window_factory,
    'Menu': menu_factory,
    'MenuBar': menu_bar_factory,
    'MPLCanvas': mpl_canvas_factory,
    'Notebook': notebook_factory,
    'Page': page_factory,
    'PushButton': push_button_factory,
    'ProgressBar': progress_bar_factory,
    'RadioButton': radio_button_factory,
    'ScrollArea': scroll_area_factory,
    'Slider': slider_factory,
    'SpinBox': spin_box_factory,
    'SplitItem': split_item_factory,
    'Splitter': splitter_factory,
    'ToolBar': tool_bar_factory,
    'Window': window_factory,
}

########NEW FILE########
__FILENAME__ = wx_field
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx

from atom.api import Int, Typed

from enaml.widgets.field import ProxyField

from .wx_control import WxControl


class wxLineEdit(wx.TextCtrl):
    """ A wx.TextCtrl subclass which is similar to a QLineEdit in terms
    of features and behavior.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxLineEdit.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments to initialize a
            wx.TextCtrl.

        """
        super(wxLineEdit, self).__init__(*args, **kwargs)
        self._placeholder_text = ''
        self._placeholder_active = False
        self._user_fgcolor = None
        self.Bind(wx.EVT_KILL_FOCUS, self.OnKillFocus)
        self.Bind(wx.EVT_SET_FOCUS, self.OnSetFocus)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _UpdatePlaceholderDisplay(self):
        """ Updates the display with the placeholder text if no text
        is currently set for the control.

        """
        if not self.GetValue() and self._placeholder_text:
            self.ChangeValue(self._placeholder_text)
            color = wx.Color(95, 95, 95)
            super(wxLineEdit, self).SetForegroundColour(color)
            self._placeholder_active = True

    def _RemovePlaceholderDisplay(self):
        """ Removes the placeholder text if it is currently active.

        """
        if self._placeholder_active:
            self.ChangeValue('')
            color = self._user_fgcolor or wx.Color(0, 0, 0)
            super(wxLineEdit, self).SetForegroundColour(color)
            self._placeholder_active = False

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def OnKillFocus(self, event):
        """ Refreshes the placeholder display when the control loses
        focus.

        """
        self._UpdatePlaceholderDisplay()
        event.Skip()

    def OnSetFocus(self, event):
        """ Removes the placeholder display when the control receives
        focus.

        """
        self._RemovePlaceholderDisplay()
        event.Skip()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def GetBestSize(self):
        """ Overridden best size method to add 44 pixels in width to the
        field. This makes Wx consistent with Qt.

        """
        size = super(wxLineEdit, self).GetBestSize()
        return wx.Size(size.GetWidth() + 44, size.GetHeight())

    def SetPlaceHolderText(self, placeholder_text):
        """ Sets the placeholder text to the given value. Pass an empty
        string to turn off the placeholder text functionality.

        """
        self._placeholder_text = placeholder_text
        self._UpdatePlaceholderDisplay()

    def GetPlaceHolderText(self):
        """ Returns the placeholder text for this control.

        """
        return self._placeholder_text

    def ChangeValue(self, text):
        """ Overridden method which moves the insertion point to the end
        of the field when changing the text value. This causes the field
        to behave like Qt.

        """
        super(wxLineEdit, self).ChangeValue(text)
        self.SetInsertionPoint(len(text))

    def GetValue(self):
        """ Returns string value in the control, or an empty string if
        the placeholder text is active.

        """
        if self._placeholder_active:
            return ''
        return super(wxLineEdit, self).GetValue()

    def SetForegroundColour(self, wxColor, force=False):
        """ Sets the foreground color of the field. If the placeholder
        text is being shown, `force` must be True in order to override
        the placeholder text color.

        """
        self._user_fgcolor = wxColor
        if self._placeholder_active and not force:
            return
        super(wxLineEdit, self).SetForegroundColour(wxColor)


# Guard flags
TEXT_GUARD = 0x1
ERROR_FLAG = 0x2


class WxField(WxControl, ProxyField):
    """ A Wx implementation of an Enaml ProxyField.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(wxLineEdit)

    #: A collapsing timer for auto sync text.
    _text_timer = Typed(wx.Timer)

    #: Cyclic notification guard. This a bitfield of multiple guards.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Creates the underlying wxLineEdit widget.

        """
        # We have to do a bit of initialization in the create method
        # since wx requires the style of certain things to be set at
        # the point of instantiation
        d = self.declaration
        style = wx.TE_PROCESS_ENTER
        if d.read_only:
            style |= wx.TE_READONLY
        else:
            style &= ~wx.TE_READONLY
        if d.echo_mode == 'normal':
            style &= ~wx.TE_PASSWORD
        else:
            style |= wx.TE_PASSWORD
        self.widget = wxLineEdit(self.parent_widget(), style=style)

    def init_widget(self):
        """ Create and initialize the underlying widget.

        """
        super(WxField, self).init_widget()
        d = self.declaration
        if d.text:
            self.set_text(d.text)
        if d.mask:
            self.set_mask(d.mask)
        if d.placeholder:
            self.set_placeholder(d.placeholder)
        self.set_echo_mode(d.echo_mode)
        self.set_max_length(d.max_length)
        self.set_read_only(d.read_only)
        self.set_submit_triggers(d.submit_triggers)
        self.widget.Bind(wx.EVT_TEXT, self.on_text_edited)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _validate_and_apply(self):
        """ Validate and apply the text in the control.

        """
        d = self.declaration
        text = self.widget.GetValue()
        if d.validator and not d.validator.validate(text):
            text = d.validator.fixup(text)
            if not d.validator.validate(text):
                return
        self._clear_error_state()
        d.text = text

    def _set_error_state(self):
        """ Set the error state of the widget.

        """
        # A temporary hack until styles are implemented
        if not self._guard & ERROR_FLAG:
            self._guard |= ERROR_FLAG
            # XXX attempting to change the field style here is futile

    def _clear_error_state(self):
        """ Clear the error state of the widget.

        """
        # A temporary hack until styles are implemented
        if self._guard & ERROR_FLAG:
            self._guard &= ~ERROR_FLAG
            # XXX attempting to change the field style here is futile

    #--------------------------------------------------------------------------
    # Event Handling
    #--------------------------------------------------------------------------
    def on_submit_text(self, event):
        """ The event handler for the text submit triggers.

        """
        # Only skip the focus event: wx triggers the system beep if the
        # enter event is skipped.
        if isinstance(event, wx.FocusEvent):
            event.Skip()
        self._guard |= TEXT_GUARD
        try:
            self._validate_and_apply()
        finally:
            self._guard &= ~TEXT_GUARD

    def on_text_edited(self, event):
        """ The event handler for the text edited event.

        """
        # Temporary kludge until error style is fully implemented
        d = self.declaration
        if d.validator and not d.validator.validate(self.widget.GetValue()):
            self._set_error_state()
            self.widget.SetToolTip(wx.ToolTip(d.validator.message))
        else:
            self._clear_error_state()
            self.widget.SetToolTip(wx.ToolTip(''))
        if self._text_timer is not None:
            self._text_timer.Start(300, oneShot=True)

    #--------------------------------------------------------------------------
    # ProxyField API
    #--------------------------------------------------------------------------
    def set_text(self, text):
        """ Updates the text control with the given unicode text.

        """
        if not self._guard & TEXT_GUARD:
            self.widget.ChangeValue(text)
            self._clear_error_state()

    def set_mask(self, mask):
        """ Set the make for the widget.

        This is not supported in Wx.

        """
        pass

    def set_submit_triggers(self, triggers):
        """ Set the submit triggers for the widget.

        """
        widget = self.widget
        handler = self.on_submit_text
        widget.Unbind(wx.EVT_KILL_FOCUS, handler=handler)
        widget.Unbind(wx.EVT_TEXT_ENTER, handler=handler)
        if 'lost_focus' in triggers:
            widget.Bind(wx.EVT_KILL_FOCUS, handler)
        if 'return_pressed' in triggers:
            widget.Bind(wx.EVT_TEXT_ENTER, handler)
        if 'auto_sync' in triggers:
            if self._text_timer is None:
                timer = self._text_timer = wx.Timer()
                timer.Bind(wx.EVT_TIMER, handler)
        else:
            if self._text_timer is not None:
                self._text_timer.Stop()
                self._text_timer = None

    def set_placeholder(self, placeholder):
        """ Sets the placeholder text in the widget.

        """
        self.widget.SetPlaceHolderText(placeholder)

    def set_echo_mode(self, echo_mode):
        """ Sets the echo mode of the wiget.

        """
        # Wx cannot change the echo mode dynamically. It requires
        # creating a brand-new control, so we just ignore the change.
        pass

    def set_max_length(self, max_length):
        """ Set the max length of the control to max_length. If the max
        length is <= 0 or > 32767 then the control will be set to hold
        32kb of text.

        """
        if (max_length <= 0) or (max_length > 32767):
            max_length = 32767
        self.widget.SetMaxLength(max_length)

    def set_read_only(self, read_only):
        """ Sets the read only state of the widget.

        """
        # Wx cannot change the read only state dynamically. It requires
        # creating a brand-new control, so we just ignore the change.
        pass

    def field_text(self):
        """ Get the text stored in the widget.

        """
        return self.widget.GetValue()

########NEW FILE########
__FILENAME__ = wx_frame
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Typed

from enaml.widgets.frame import ProxyFrame

import wx

from .wx_constraints_widget import WxConstraintsWidget


class WxFrame(WxConstraintsWidget, ProxyFrame):
    """ A Wx implementation of an Enaml ProxyFrame.

    """
    #: A reference to the toolkit widget created by the proxy.
    widget = Typed(wx.Panel)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Creates the QContainer widget.

        """
        self.widget = wx.Panel(self.parent_widget())

    #--------------------------------------------------------------------------
    # ProxyFrame API
    #--------------------------------------------------------------------------
    def set_border(self, border):
        """ Set the border for the widget.

        This is not supported on Wx.

        """
        pass

########NEW FILE########
__FILENAME__ = wx_group_box
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx

from atom.api import Typed

from enaml.widgets.group_box import ProxyGroupBox

from .wx_container import WxContainer, wxContainer


WX_ALIGNMENTS = {
    'left': wx.ALIGN_LEFT,
    'center': wx.ALIGN_CENTER,
    'right': wx.ALIGN_RIGHT,
}


class wxGroupBox(wxContainer):
    """ A wxContainer sublcass that implements GroupBox functionality.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxGroupBox.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments to initialize a
            wxContainer.

        """
        super(wxGroupBox, self).__init__(*args, **kwargs)
        self._title = ''
        self._border = wx.StaticBox(self)
        self._line = wx.StaticLine(self)
        self._label = wx.StaticText(self)
        self._label.Raise()
        self._label_size = self._label.GetBestSize()
        self._title_alignment = wx.ALIGN_LEFT
        self._flat = False
        # Set the panel to double buffered or suffer terrible
        # rendering artifacts
        self.SetDoubleBuffered(True)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def GetAlignment(self):
        """ Return the wx alignment flag for the current alignment
        of the group box title.

        """
        return self._title_alignment

    def SetAlignment(self, alignment):
        """ Set the alignment of the title of the group box. Should
        be one of wx.ALIGN_LEFT, wx.ALIGN_RIGHT, wx.ALIGN_CENTER.

        """
        self._title_alignment = alignment
        self._update_layout()

    def GetFlat(self):
        """ Returns a boolean indicating whether the group box is using
        a flat style.

        """
        return self._flat

    def SetFlat(self, flat):
        """ Set whether or not the group box should be displayed using
        a flat style.

        """
        self._flat = flat
        if flat:
            self._border.Show(False)
            self._line.Show(True)
        else:
            self._border.Show(True)
            self._line.Show(False)
        self._update_layout()

    def GetTitle(self):
        """ Return the current title text in the group box.

        """
        # Undo the hack applied in SetTitle(...)
        title = self._title
        if title:
            title = title[1:-1]
        return title

    def SetTitle(self, title):
        """ Set the current title text in the group box.

        """
        # A bit of a hack to give us a little padding around the label
        if title:
            title = ' %s ' % title
        self._title = title
        self._label.SetLabel(title)
        self._label_size = self._label.GetBestSize()
        if not title:
            self._label.Show(False)
        else:
            self._label.Show(True)
        self._update_layout()

    def SetDimensions(self, x, y, width, height):
        """ Overridden parent class method to synchronize the group
        box decorations.

        """
        super(wxGroupBox, self).SetDimensions(x, y, width, height)
        self._update_layout()

    def SetSize(self, size):
        """ Overridden parent class method to synchronize the group
        box decorations.

        """
        super(wxGroupBox, self).SetSize(size)
        self._update_layout()

    def GetContentsMargins(self):
        """ Get the contents margins for the group box.

        These margins are computed empirically so that they look similar
        to the margins provided by Qt on Windows.

        Returns
        -------
        result : tuple
            The top, right, bottom, and left margin values.

        """
        label = self._label
        height = label.GetCharHeight()
        if not label.IsShown():
            height /= 2
        return (height, 1, 1, 1)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _update_layout(self):
        """ Synchronizes the drawing of the group box decorations with
        the panel.

        """
        if self._flat:
            self._update_line_geometry()
        else:
            self._update_border_geometry()
        self._update_title_geometry()
        self.Refresh()

    def _update_border_geometry(self):
        """ Updates the geometry of the border.

        """
        width, height = self.GetSizeTuple()
        self._border.SetSizeWH(width, height)

    def _update_line_geometry(self):
        """ Updates the geometry of the line.

        """
        y = self._label_size.GetHeight() / 2
        width, _ = self.GetSizeTuple()
        self._line.SetDimensions(0, y, width, 2)

    def _update_title_geometry(self):
        """ Updates the geometry of the title.

        """
        label = self._label
        flat = self._flat
        align = self._title_alignment
        text_width, _ = self._label_size
        width, _ = self.GetSizeTuple()
        # These offsets are determined empirically to look similar
        # in form to Qt on Windows
        if align == wx.ALIGN_LEFT:
            x = 0 if flat else 8
            label.Move((x, 0))
        elif align == wx.ALIGN_RIGHT:
            right = width
            right -= 0 if flat else 8
            x = right - text_width
            label.Move((x, 0))
        elif align == wx.ALIGN_CENTER:
            label.CenterOnParent(dir=wx.HORIZONTAL)
        else:
            raise ValueError('Invalid title alignment %s' % align)


class WxGroupBox(WxContainer, ProxyGroupBox):
    """ A Wx implementation of an Enaml ProxyGroupBox.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(wxGroupBox)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Creates the underlying QGroupBox control.

        """
        self.widget = wxGroupBox(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(WxGroupBox, self).init_widget()
        d = self.declaration
        self.set_title(d.title, cm_update=False)
        self.set_flat(d.flat)
        self.set_title_align(d.title_align)

    #--------------------------------------------------------------------------
    # Layout Handling
    #--------------------------------------------------------------------------
    @staticmethod
    def margins_func(widget):
        """ Get the current contents margins for the group box.

        """
        return widget.GetContentsMargins()

    #--------------------------------------------------------------------------
    # ProxyGroupBox API
    #--------------------------------------------------------------------------
    def set_title(self, title, cm_update=True):
        """ Update the title of the group box.

        """
        if not cm_update:
            self.widget.SetTitle(title)
            return
        widget = self.widget
        old_margins = widget.GetContentsMargins()
        widget.SetTitle(title)
        new_margins = widget.GetContentsMargins()
        if old_margins != new_margins:
            self.margins_updated()

    def set_flat(self, flat):
        """ Updates the flattened appearance of the group box.

        """
        self.widget.SetFlat(flat)

    def set_title_align(self, align):
        """ Updates the alignment of the title of the group box.

        """
        wx_align = WX_ALIGNMENTS[align]
        self.widget.SetAlignment(wx_align)

########NEW FILE########
__FILENAME__ = wx_html
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx.html

from atom.api import Typed

from enaml.widgets.html import ProxyHtml

from .wx_control import WxControl


class wxProperHtmlWindow(wx.html.HtmlWindow):
    """ A custom wx Html window that returns a non-braindead best size.

    """
    _best_size = wx.Size(256, 192)

    def GetBestSize(self):
        """ Returns the best size for the html window.

        """
        return self._best_size


class WxHtml(WxControl, ProxyHtml):
    """ A Wx implementation of the Enaml ProxyHtml widget.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(wxProperHtmlWindow)

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying html widget.

        """
        self.widget = wxProperHtmlWindow(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(WxHtml, self).init_widget()
        self.set_source(self.declaration.source)

    #--------------------------------------------------------------------------
    # ProxyHtml API
    #--------------------------------------------------------------------------
    def set_source(self, source):
        """ Set the source of the html widget

        """
        self.widget.SetPage(source)

########NEW FILE########
__FILENAME__ = wx_label
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx

from atom.api import Typed

from enaml.widgets.label import ProxyLabel

from .wx_control import WxControl


ALIGN_MAP = {
    'left': wx.ALIGN_LEFT,
    'right': wx.ALIGN_RIGHT,
    'center': wx.ALIGN_CENTER,
    'justify': wx.ALIGN_LEFT,  # wx doesn't support justification
}


ALIGN_MASK = wx.ALIGN_LEFT | wx.ALIGN_RIGHT | wx.ALIGN_CENTER


class WxLabel(WxControl, ProxyLabel):
    """ A Wx implementation of an Enaml ProxyLabel.

    """
     #: A reference to the widget created by the proxy.
    widget = Typed(wx.StaticText)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying label widget.

        """
        self.widget = wx.StaticText(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(WxLabel, self).init_widget()
        d = self.declaration
        self.set_text(d.text)
        self.set_align(d.align)
        self.set_vertical_align(d.vertical_align)

    #--------------------------------------------------------------------------
    # ProxyLabel API
    #--------------------------------------------------------------------------
    def set_text(self, text):
        """ Set the text in the underlying widget.

        """
        with self.geometry_guard():
            self.widget.SetLabel(text)

    def set_align(self, align):
        """ Set the alignment of the text in the underlying widget.

        """
        widget = self.widget
        style = widget.GetWindowStyle()
        style &= ~ALIGN_MASK
        style |= ALIGN_MAP[align]
        widget.SetWindowStyle(style)
        widget.Refresh()

    def set_vertical_align(self, align):
        """ Set the vertical alignment of the text in the widget.

        This is not supported on Wx.

        """
        pass

########NEW FILE########
__FILENAME__ = wx_layout_request
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from wx.lib.newevent import NewCommandEvent


#: A custom command event that can be posted to request a layout
#: when a widget's geometry has changed. On Qt, this type of event
#: is posted and handled automatically. This fills that gap.
wxEvtLayoutRequested, EVT_COMMAND_LAYOUT_REQUESTED = NewCommandEvent()

########NEW FILE########
__FILENAME__ = wx_main_window
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx

from atom.api import Typed

from enaml.widgets.main_window import ProxyMainWindow

from .wx_action import wxAction
from .wx_container import WxContainer
from .wx_dock_pane import WxDockPane
from .wx_menu_bar import WxMenuBar
from .wx_tool_bar import WxToolBar
from .wx_upstream import aui
from .wx_window import WxWindow


class wxToolBarContainer(wx.Panel):
    """ A simple wx.Panel that arranges the tool bars for a main window.

    """
    # The Wx AuiToolBar is terrible and the aui code which lays out
    # the tool bars is equally as bad. Unless we want to rewrite the
    # entire aui libary to do docking properly, we have to accept that
    # docking toolbars on wx are a no-go. That said, if the user defined
    # multiple tool bars for their main window, it would be bad to only
    # show one of them, which is what we would get if we had the wx.Frame
    # manage the tool bars directly (since it only supports a single tool
    # bar). Instead, we put all of the tool bars in a vertical sizer and
    # stick the entire thing at the top of the main window layout and
    # forbid it from being moved around. If better docking support is
    # desired, the user would be better off with Qt.
    def __init__(self, *args, **kwargs):
        """ Initialize a wxToolBarContainer.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments to initialize a
            wx.Panel.

        """
        super(wxToolBarContainer, self).__init__(*args, **kwargs)
        self._tool_bars = []
        self.SetSizer(wx.BoxSizer(wx.VERTICAL))
        self.SetDoubleBuffered(True)

    def AddToolBar(self, tool_bar):
        """ Add a tool bar to the container.

        If the tool bar already exists in this container, this will be
        a no-op. The tool bar will be reparented to this container.

        Parameters
        ----------
        tool_bar : wxToolBar
            The wxToolBar instance to add to this container.

        """
        tool_bars = self._tool_bars
        if tool_bar not in tool_bars:
            tool_bars.append(tool_bar)
            tool_bar.Reparent(self)
            self.GetSizer().Add(tool_bar, 0, wx.EXPAND)

    def RemoveToolBar(self, tool_bar):
        """ Remove a tool bar from the container.

        If the tool bar already exists in this container, this will be
        a no-op.

        Parameters
        ----------
        tool_bar : wxToolBar
            The wxToolBar instance to remove from the container.

        """
        tool_bars = self._tool_bars
        if tool_bar in tool_bars:
            tool_bars.remove(tool_bar)
            self.GetSizer().Detach(tool_bar)


class wxMainWindow(wx.Frame):
    """ A wx.Frame subclass which adds MainWindow functionality.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxMainWindow.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments necessary to initialize
            a wx.Frame.

        """
        super(wxMainWindow, self).__init__(*args, **kwargs)
        flags = (
            aui.AUI_MGR_DEFAULT | aui.AUI_MGR_LIVE_RESIZE |
            aui.AUI_MGR_USE_NATIVE_MINIFRAMES
        )
        self._manager = aui.AuiManager(self, agwFlags=flags)
        self._central_widget = None
        self._tool_bars = None
        self._batch = False
        self.Bind(wx.EVT_MENU, self.OnMenu)
        self.Bind(wx.EVT_CLOSE, self.OnClose)
        self.Bind(aui.EVT_AUI_PANE_CLOSE, self.OnPaneClose)
        self.Bind(aui.EVT_AUI_PANE_FLOATED, self.OnPaneFloated)
        self.Bind(aui.EVT_AUI_PANE_DOCKED, self.OnPaneDocked)

        # Add a hidden dummy widget to the pane manager. This is a
        # workaround for a Wx bug where the laying out of the central
        # pane will have jitter on window resize (the computed layout
        # origin of the central pane oscillates between (0, 0) and
        # (1, 1)) if there are no other panes in the layout. If we
        # add a hidden pane with zero size, it prevents the jitter.
        self._hidden_widget = wx.Window(self)
        pane = aui.AuiPaneInfo()
        pane.BestSize(wx.Size(0, 0))
        pane.MinSize(wx.Size(0, 0))
        pane.Show(False)
        self._manager.AddPane(self._hidden_widget, pane)

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def OnPaneClose(self, event):
        """ Handle the EVT_AUI_PANE_CLOSE event.

        This event gets passed on to the wxDockPane for handling.

        """
        event.GetPane().window.OnClose(event)

    def OnPaneFloated(self, event):
        """ Handle the EVT_AUI_PANE_FLOATED event.

        This event gets passed on to the wxDockPane for handling.

        """
        event.GetPane().window.OnFloated(event)

    def OnPaneDocked(self, event):
        """ Handle the EVT_AUI_PANE_DOCKED event.

        This event gets passed on to the wxDockPane for handling.

        """
        event.GetPane().window.OnDocked(event)

    def OnMenu(self, event):
        """ The event handler for the EVT_MENU event.

        This event handler will be called when an action is triggered
        in a Menu or a ToolBar.

        """
        action = wxAction.FindById(event.GetId())
        if action is not None:
            if action.IsCheckable():
                action.SetChecked(event.Checked())
            action.Trigger()

    def OnClose(self, event):
        """ The event handler for the EVT_CLOSE event.

        This event handler prevents the frame from being destroyed on
        close. Instead it just sets the visibility to False.

        """
        self.Hide()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def BeginBatch(self):
        """ Enter batch update mode for main window updates.

        Main window updates that are performed after calling this method
        will not be committed until EndBatch is called. This can be used
        to reduce flicker when making updates to the MainWindow.

        """
        self._batch = True

    def EndBatch(self):
        """ Exit batch update mode and process any pending updates.

        After calling this method, any pending main window updates will
        be processed.

        """
        self._batch = False
        self._manager.Update()

    def GetCentralWidget(self):
        """ Get the central widget for the main window.

        Returns
        -------
        result : wxWindow or None
            The central widget for the window, or None if no central
            widget is defined.

        """
        return self._central_widget

    def SetCentralWidget(self, widget):
        """ Set the central widget for the main window.

        Parameters
        ----------
        widget : wxWindow
            The wxWindow instance to use as the central widget in the
            main window.

        """
        manager = self._manager
        old_widget = self._central_widget
        if old_widget:
            old_widget.Hide()
            pane = manager.GetPane(old_widget)
            if pane.IsOk():
                pane.Show(False)
                manager.DetachPane(old_widget)
        self._central_widget = widget
        pane = aui.AuiPaneInfo().CenterPane()
        manager.AddPane(widget, pane)
        if not self._batch:
            manager.Update()

    def SetMenuBar(self, menu_bar):
        """ Set the menu bar for the main window.

        Parameters
        ----------
        menu_bar : wxMenuBar
            The wxMenuBar instance to add to the main window.

        """
        old_bar = self.GetMenuBar()
        if old_bar is not menu_bar:
            super(wxMainWindow, self).SetMenuBar(menu_bar)
            # The menu bar must be refreshed after attachment
            if menu_bar:
                menu_bar.Update()

    def AddToolBar(self, tool_bar):
        """ Add a tool bar to the main window.

        If the tool bar already exists in the main window, calling this
        method is effectively a no-op.

        Parameters
        ----------
        tool_bar : wxToolBar
            The wxToolBar instance to add to the main window.

        """
        bars = self._tool_bars
        manager = self._manager
        if bars is None:
            bars = self._tool_bars = wxToolBarContainer(self)
            pane = aui.AuiPaneInfo().ToolbarPane().Top().Gripper(False)
            manager.AddPane(bars, pane)
        pane = manager.GetPane(bars)
        bars.AddToolBar(tool_bar)
        pane.MinSize(bars.GetBestSize())
        if not self._batch:
            manager.Update()

    def RemoveToolBar(self, tool_bar):
        """ Remove a tool bar from the main window.

        If the tool bar already exists in the main window, calling this
        method is effectively a no-op.

        Parameters
        ----------
        tool_bar : wxToolBar
            The wxToolBar instance to remove from the main window.

        """
        bars = self._tool_bars
        if bars is not None:
            bars.RemoveToolBar(tool_bar)
            tool_bar.Hide()
            manager = self._manager
            pane = manager.GetPane(bars)
            pane.MinSize(bars.GetBestSize())
            if not self._batch:
                manager.Update()
                manager.Update() # 2 calls required, because Wx...

    def AddDockPane(self, dock_pane):
        """ Add a dock pane to the main window.

        If the pane already exists in the main window, calling this
        method is a no-op.

        Parameters
        ----------
        dock_pane : wxDockPane
            The wxDockPane instance to add to the main window.

        """
        manager = self._manager
        pane = manager.GetPane(dock_pane)
        if not pane.IsOk():
            manager.AddPane(dock_pane, dock_pane.MakePaneInfo())
            if not self._batch:
                manager.Update()

    def RemoveDockPane(self, dock_pane):
        """ Remove a dock pane from the main window.

        If the pane does not exist in the window, calling this method
        is a no-op.

        Parameters
        ----------
        dock_pane : wxDockPane
            The wxDockPane instance to remove from the window.

        """
        manager = self._manager
        pane = manager.GetPane(dock_pane)
        if pane.IsOk():
            pane.Show(False)
            manager.DetachPane(dock_pane)
            if not self._batch:
                manager.Update()


class WxMainWindow(WxWindow, ProxyMainWindow):
    """ A Wx implementation of an Enaml ProxyMainWindow.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(wxMainWindow)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying widget wxMainWindow widget.

        """
        style = self.creation_style()
        self.widget = wxMainWindow(self.parent_widget(), style=style)

    def init_layout(self):
        """ Initialize the layout for the underlying widget.

        """
        # The superclass' init_layout() method is explicitly not called
        # since the layout initialization for Window is not appropriate
        # for MainWindow.
        widget = self.widget
        widget.BeginBatch()
        widget.SetMenuBar(self.menu_bar())
        widget.SetCentralWidget(self.central_widget())
        for d in self.dock_panes():
            widget.AddDockPane(d)
        for d in self.tool_bars():
            widget.AddToolBar(d)
        widget.EndBatch()

    def destroy(self):
        """ A reimplemented destructor.

        This will free any reference to the menu bar before destroying
        the underlying window. Wx segfaults otherwise.

        """
        self.widget.SetMenuBar(None)
        super(WxMainWindow, self).destroy()

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def menu_bar(self):
        """ Get the QMenuBar widget defined for the main window.

        """
        d = self.declaration.menu_bar()
        if d is not None:
            return d.proxy.widget or None

    def dock_panes(self):
        """ Get the QDockWidget widgets defined for the main window.

        """
        for d in self.declaration.dock_panes():
            w = d.proxy.widget
            if w:
                yield w

    def tool_bars(self):
        """ Get the QToolBar widgets defined for the main window.

        """
        for d in self.declaration.tool_bars():
            w = d.proxy.widget
            if w:
                yield w

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a WxMainWindow.

        """
        if isinstance(child, WxMenuBar):
            self.widget.SetMenuBar(self.menu_bar())
        elif isinstance(child, WxContainer):
            self.widget.SetCentralWidget(self.central_widget())
        elif isinstance(child, WxDockPane):
            self.widget.AddDockPane(child.widget)
        elif isinstance(child, WxToolBar):
            self.widget.AddToolBar(child.widget)
        else:
            super(WxMainWindow, self).child_added(child)

    def child_removed(self, child):
        """ Handle the child removed event for a WxMainWindow.

        """
        if isinstance(child, WxDockPane):
            self.widget.RemoveDockPane(child.widget)
        elif isinstance(child, WxToolBar):
            self.widget.RemoveToolBar(child.widget)
        elif isinstance(child, WxContainer):
            self.widget.SetCentralWidget(self.central_widget())
        elif isinstance(child, WxMenuBar):
            self.widget.SetMenuBar(self.menu_bar())
        else:
            super(WxMainWindow, self).child_removed(child)

########NEW FILE########
__FILENAME__ = wx_menu
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx
import wx.lib.newevent

from atom.api import Typed

from enaml.widgets.menu import ProxyMenu

from .wx_action import WxAction, EVT_ACTION_CHANGED
from .wx_action_group import WxActionGroup
from .wx_toolkit_object import WxToolkitObject


#: An event emitted when the menu state changes.
wxMenuChangedEvent, EVT_MENU_CHANGED = wx.lib.newevent.NewEvent()


class wxMenu(wx.Menu):
    """ A wx.Menu subclass which provides a more convenient api for
    working with wxMenu and wxAction children.

    """
    def __init__(self, parent, *args, **kwargs):
        """ Initialize a wxMenu.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initialize
            a wx.Menu.

        """
        super(wxMenu, self).__init__(*args, **kwargs)
        self._parent = parent
        self._title = u''
        self._all_items = []
        self._menus_map = {}
        self._actions_map = {}
        self._enabled = True
        self._bar_enabled = True
        self._visible = True
        self._batch = False
        self._is_context_menu = False
        self._id = wx.NewId()

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _EmitChanged(self):
        """ Emits the menu changed event if not in batch mode.

        """
        if not self._batch:
            event = wxMenuChangedEvent()
            event.SetEventObject(self)
            wx.PostEvent(self, event)

    def _SetBarEnabled(self, enabled):
        """ A private method called by an owner menu bar.

        Parameters
        ----------
        enabled : bool
            Whether or not the owner menu bar is enabled.

        """
        if self._bar_enabled != enabled:
            old = self.IsEnabled()
            self._bar_enabled = enabled
            new = self.IsEnabled()
            if old != new:
                self._EmitChanged()

    def _InsertMenuItem(self, index, menu):
        """ Insert a new item into the menu for the given menu.

        Parameters
        ----------
        menu : wxMenu
            The wxMenu instance to use as the submenu.

        Returns
        -------
        result : wx.MenuItem
            The menu item to use for the given menu.

        """
        text = menu.GetTitle()
        menu_id = menu.GetId()
        text = text or 'menu_%d' % menu_id # null text == exception
        res = wx.MenuItem(self, menu_id, text, '', subMenu=menu)
        res.Enable(menu.IsEnabled())
        self.InsertItem(index, res)
        return res

    def _InsertActionItem(self, index, action):
        """ Insert a new item into the menu for the given action.

        Parameters
        ----------
        action : wxAction
            The wx action for which to create a wx.MenuItem.

        Returns
        -------
        result : wx.MenuItem
            The menu item for the given action.

        """
        text = action.GetText()
        help = action.GetStatusTip()
        if action.IsSeparator():
            res = wx.MenuItem(self, wx.ID_SEPARATOR, text, help)
            self.InsertItem(index, res)
        else:
            action_id = action.GetId()
            text = text or 'action_%d' % action_id # null text == exception
            if action.IsCheckable():
                # The wx.ITEM_RADIO kind doesn't behave nicely, so we
                # just use the check kind and rely on the action group
                # to handle the exclusive radio behavior. Changing the
                # bitmap to something that looks like a radio button
                # breaks the Windows theme.
                kind = wx.ITEM_CHECK
                res = wx.MenuItem(self, action_id, text, help, kind)
                # Must instert the item before checking it, or c++
                # assertion errors are thrown
                self.InsertItem(index, res)
                res.Check(action.IsChecked())
            else:
                kind = wx.ITEM_NORMAL
                res = wx.MenuItem(self, action_id, text, help, kind)
                self.InsertItem(index, res)
            res.Enable(action.IsEnabled())
        return res

    def OnActionChanged(self, event):
        """ The event handler for the EVT_ACTION_CHANGED event.

        This handler will be called when a child action changes. It
        ensures that the new state of the child action is in sync with
        the associated menu item.

        """
        event.Skip()
        action = event.GetEventObject()
        item = self._actions_map.get(action)

        # Fist, check for a visibility change. This requires adding or
        # removing the menu item from the menu and the actions map.
        visible = action.IsVisible()
        if visible != bool(item):
            if visible:
                index = self._all_items.index(action)
                n_visible = len(self._actions_map) + len(self._menus_map)
                index = min(index, n_visible)
                new_item = self._InsertActionItem(index, action)
                self._actions_map[action] = new_item
            else:
                self.DestroyItem(item)
                del self._actions_map[action]
            return

        # If the item is invisible, there is nothing to update.
        if not item:
            return

        # If the item is a separator, and the separator state has
        # changed, we need to build an entirely new menu item, and
        # replace the existing item with the new one.
        item_sep = item.IsSeparator()
        action_sep = action.IsSeparator()
        if item_sep or action_sep:
            if item_sep != action_sep:
                self.DestroyItem(item)
                index = self._all_items.index(action)
                n_visible = len(self._actions_map) + len(self._menus_map)
                index = min(index, n_visible)
                new_item = self._InsertActionItem(index, action)
                self._actions_map[action] = new_item
            return

        # For all other state, the menu item can be updated in-place.
        item.SetItemLabel(action.GetText())
        item.SetHelp(action.GetStatusTip())
        if action.IsCheckable():
            item.SetKind(wx.ITEM_CHECK)
            item.Check(action.IsChecked())
        else:
            if item.IsCheckable():
                item.Check(False)
            item.SetKind(wx.ITEM_NORMAL)
        item.Enable(action.IsEnabled())

    def OnMenuChanged(self, event):
        """ The event hanlder for the EVT_MENU_CHANGED event.

        This handler will be called when a child menu changes. It
        ensure that the new state of the child menu is in sync with
        the associated menu item.

        """
        event.Skip()
        menu = event.GetEventObject()
        item = self._menus_map.get(menu)

        # Fist, check for a visibility change. This requires adding or
        # removing the menu item from the menu and the menus map.
        visible = menu.IsVisible()
        if visible != bool(item):
            if visible:
                index = self._all_items.index(menu)
                n_visible = len(self._actions_map) + len(self._menus_map)
                index = min(index, n_visible)
                new_item = self._InsertMenuItem(index, menu)
                self._menus_map[menu] = new_item
            else:
                # Need to first remove the submenu or wx will destroy it.
                item.SetSubMenu(None)
                self.DestroyItem(item)
                del self._menus_map[menu]
            return

        # If the item is invisible, there is nothing to update.
        if not item:
            return

        # For all other state, the menu item can be updated in-place.
        item.SetItemLabel(menu.GetTitle())
        item.Enable(menu.IsEnabled())

    def OnShowContextMenu(self, event):
        """ A private event handler for displaying the context menu.

        This handler is connected to the context menu event on the
        parent widget when this menu is marked as a context menu.

        """
        parent = self._parent
        if parent and isinstance(parent, wx.Window):
            parent.PopupMenu(self)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def BeginBatch(self):
        """ Enter batch update mode for the menu.

        """
        self._batch = True

    def EndBatch(self, emit=True):
        """ Exit batch update mode for the menu.

        Parameters
        ----------
        emit : bool, optional
            If True, emit a changed event after leaving batch mode. The
            default is True.

        """
        self._batch = False
        if emit:
            self._EmitChanged()

    def GetId(self):
        """ Get the unique wx id for this menu.

        Returns
        -------
        result : int
            The wx id number for this menu.

        """
        return self._id

    def GetTitle(self):
        """ Get the title for the menu.

        Returns
        -------
        result : unicode
            The unicode title for the menu.

        """
        return self._title

    def SetTitle(self, title):
        """ Set the title for the menu.

        Parameters
        ----------
        title : unicode
            The unicode string to use as the menu title.

        """
        if self._title != title:
            self._title = title
            self._EmitChanged()

    def IsEnabled(self):
        """ Get whether or not the menu is enabled.

        Returns
        -------
        result : bool
            Whether or not the menu is enabled.

        """
        if self._bar_enabled:
            return self._enabled
        return False

    def SetEnabled(self, enabled):
        """ Set whether or not the menu is enabled.

        Parameters
        ----------
        enabled : bool
            Whether or not the menu is enabled.

        """
        if self._enabled != enabled:
            self._enabled = enabled
            if self._bar_enabled:
                self._EmitChanged()

    def IsVisible(self):
        """ Get whether or not the menu is visible.

        Returns
        -------
        result : bool
            Whether or not the menu is visible.

        """
        return self._visible

    def SetVisible(self, visible):
        """ Set whether or not the menu is visible.

        Parameters
        ----------
        visible : bool
            Whether or not the menu is visible.

        """
        if self._visible != visible:
            self._visible = visible
            self._EmitChanged()

    def IsContextMenu(self):
        """ Whether this menu acts as a context menu for its parent.

        Returns
        -------
        result : bool
            True if this menu acts as a context menu, False otherwise.

        """
        return self._is_context_menu

    def SetContextMenu(self, context):
        """ Set whether this menu acts as a context menu for its parent.

        Parameters
        ----------
        context : bool
            True if this menu should act as a context menu, False
            otherwise.

        """
        old_context = self._is_context_menu
        self._is_context_menu = context
        if old_context != context:
            parent = self._parent
            if parent:
                handler = self.OnShowContextMenu
                if context:
                    parent.Bind(wx.EVT_CONTEXT_MENU, handler)
                else:
                    parent.Unbind(wx.EVT_CONTEXT_MENU, handler=handler)

    def AddMenu(self, menu):
        """ Add a wx menu to the Menu.

        If the menu already exists in this menu, it will be moved to
        the end.

        Parameters
        ----------
        menu : wxMenu
            The wxMenu instance to add to this menu.

        """
        self.InsertMenu(None, menu)

    def InsertMenu(self, before, menu):
        """ Insert a wx menu into the Menu.

        If the menu already exists in this menu, if will be moved to
        the proper location.

        Parameters
        ----------
        before : wxAction, wxMenu, or None
            The item in the menu which should come directly after the
            new sub-menu.

        menu : wxMenu
            The wxMenu instance to insert into this menu.

        """
        all_items = self._all_items
        if menu not in all_items:
            if before in all_items:
                index = all_items.index(before)
            else:
                index = len(all_items)
            all_items.insert(index, menu)
            if menu.IsVisible():
                max_index = len(self._actions_map) + len(self._menus_map)
                index = min(index, max_index)
                menu_item = self._InsertMenuItem(index, menu)
                self._menus_map[menu] = menu_item
            menu.Bind(EVT_MENU_CHANGED, self.OnMenuChanged)
        else:
            # XXX this is a potentially slow way to do things if the
            # number of menus being moved around is large. But, the
            # Wx apis don't appear to offer a better way, so this is
            # what we get (as usual...).
            self.RemoveMenu(menu)
            self.InsertMenu(before, menu)

    def RemoveMenu(self, menu):
        """ Remove a wx menu from the Menu.

        If the menu does not exist in the menu, this is a no-op.

        Parameters
        ----------
        menu : wxMenu
            The wxMenu instance to remove from this menu.

        """
        all_items = self._all_items
        if menu in all_items:
            all_items.remove(menu)
            menu.Unbind(EVT_MENU_CHANGED, handler=self.OnMenuChanged)
            menu_item = self._menus_map.pop(menu, None)
            if menu_item is not None:
                self.RemoveItem(menu_item)
                # Set the SubMenu to None or wx will destroy it.
                menu_item.SetSubMenu(None)

    def AddAction(self, action):
        """ Add a wx action to the Menu.

        If the action already exists in the menu, it will be moved to
        the end.

        Parameters
        ----------
        action : wxAction
            The wxAction instance to add to this menu.

        """
        self.InsertAction(None, action)

    def AddActions(self, actions):
        """ Add multiple wx actions to the Menu.

        If an action already exists in the menu, it will be moved to
        the end.

        Parameters
        ----------
        actions : iterable
            An iterable of wxAction instances to add to the menu.

        """
        insert = self.InsertAction
        for action in actions:
            insert(None, action)

    def InsertAction(self, before, action):
        """ Insert a wx action into the Menu.

        If the action already exists in the menu, it will be moved to
        the proper location.

        Parameters
        ----------
        before : wxAction, wxMenu, or None
            The item in the menu which should come directly after the
            new action.

        action : wxAction
            The wxAction instance to insert into this menu.

        """
        all_items = self._all_items
        if action not in all_items:
            if before in all_items:
                index = all_items.index(before)
            else:
                index = len(all_items)
            all_items.insert(index, action)
            if action.IsVisible():
                max_index = len(self._actions_map) + len(self._menus_map)
                index = min(index, max_index)
                menu_item = self._InsertActionItem(index, action)
                self._actions_map[action] = menu_item
            action.Bind(EVT_ACTION_CHANGED, self.OnActionChanged)
        else:
            # XXX this is a potentially slow way to do things if the
            # number of actions being moved around is large. But, the
            # Wx apis don't appear to offer a better way, so this is
            # what we get (as usual...).
            self.RemoveAction(action)
            self.InsertAction(before, action)

    def InsertActions(self, before, actions):
        """ Insert multiple wx actions into the Menu.

        If an action already exists in this menu, it will be moved to
        the proper location.

        Parameters
        ----------
        before : wxAction, wxMenu, or None
            The item in the menu which should come directly after the
            new actions.

        actions : iterable
            An iterable of wxAction instances to add to the menu.

        """
        insert = self.InsertAction
        for action in actions:
            insert(before, action)

    def RemoveAction(self, action):
        """ Remove a wx action from the Menu.

        If the action does not exist in the menu, this is a no-op.

        Parameters
        ----------
        action : wxAction
            The wxAction instance to remove from this menu.

        """
        all_items = self._all_items
        if action in all_items:
            all_items.remove(action)
            action.Unbind(EVT_ACTION_CHANGED, handler=self.OnActionChanged)
            menu_item = self._actions_map.pop(action, None)
            if menu_item is not None:
                self.RemoveItem(menu_item)

    def RemoveActions(self, actions):
        """ Remove multiple actions from the Menu.

        If an action does not exist in the menu, it will be ignored.

        Parameters
        ----------
        actions : iterable
            An iterable of wxAction instances to remove from the menu.

        """
        remove = self.RemoveAction
        for action in actions:
            remove(action)


class WxMenu(WxToolkitObject, ProxyMenu):
    """ A Wx implementation of an Enaml ProxyMenu.

    """
        #: A reference to the widget created by the proxy.
    widget = Typed(wxMenu)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying menu widget.

        """
        self.widget = wxMenu(self.parent_widget())
        self.widget.BeginBatch()

    def init_widget(self):
        """ Initialize the widget.

        """
        super(WxMenu, self).init_widget()
        d = self.declaration
        self.set_title(d.title)
        self.set_enabled(d.enabled)
        self.set_visible(d.visible)
        self.set_context_menu(d.context_menu)
        self.widget.EndBatch(emit=False)

    def init_layout(self):
        """ Initialize the layout of the widget.

        """
        super(WxMenu, self).init_layout()
        widget = self.widget
        for child in self.children():
            if isinstance(child, WxMenu):
                widget.AddMenu(child.widget)
            elif isinstance(child, WxAction):
                widget.AddAction(child.widget)
            elif isinstance(child, WxActionGroup):
                widget.AddActions(child.actions())

    def destroy(self):
        """ A reimplemented destructor.

        This destructor simply drops the reference to the menu and the
        enaml declaration. Destroying it will cause wx to segfault.

        """
        del self.widget
        del self.declaration

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def find_next_action(self, child):
        """ Get the wxAction instance which follows the child.

        Parameters
        ----------
        child : WxToolkitObject
            The child of interest.

        Returns
        -------
        result : wxAction or None
            The wxAction which comes immediately after the actions of the
            given child, or None if no actions follow the child.

        """
        found = False
        for dchild in self.children():
            if found:
                if isinstance(dchild, (WxMenu, WxAction)):
                    return dchild.widget
                if isinstance(dchild, WxActionGroup):
                    acts = dchild.actions()
                    if len(acts) > 0:
                        return acts[0]
            else:
                found = dchild is child

    def child_added(self, child):
        """ Handle the child added event for a WxMenu.

        """
        super(WxMenu, self).child_added(child)
        if isinstance(child, WxMenu):
            before = self.find_next_action(child)
            self.widget.InsertMenu(before, child.widget)
        elif isinstance(child, WxAction):
            before = self.find_next_action(child)
            self.widget.InsertAction(before, child.widget)
        elif isinstance(child, WxActionGroup):
            before = self.find_next_action(child)
            self.widget.InsertActions(before, child.actions())

    def child_removed(self, child):
        """  Handle the child removed event for a WxMenu.

        """
        super(WxMenu, self).child_removed(child)
        if isinstance(child, WxMenu):
            self.widget.RemoveMenu(child.widget)
        elif isinstance(child, WxAction):
            self.widget.RemoveAction(child.widget)
        elif isinstance(child, WxActionGroup):
            self.widget.RemoveActions(child.actions())

    #--------------------------------------------------------------------------
    # ProxyMenu API
    #--------------------------------------------------------------------------
    def set_title(self, title):
        """ Set the title of the underlyling control.

        """
        self.widget.SetTitle(title)

    def set_visible(self, visible):
        """ Set the visibility on the underlying widget.

        """
        self.widget.SetVisible(visible)

    def set_enabled(self, enabled):
        """ Set the enabled state of the widget.

        """
        self.widget.SetEnabled(enabled)

    def set_context_menu(self, context):
        """ Set whether or not the menu is a context menu.

        """
        self.widget.SetContextMenu(context)

    def popup(self):
        """ Popup the menu at the current mouse location.

        """
        # This is not supported on wx. Wx requires the menu to be
        # popped up over a specified window. It can't be done using
        # global coordinates.
        pass

    def close(self):
        """ This is not supported in wx.

        """
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = wx_menu_bar
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx

from atom.api import Typed

from enaml.widgets.menu_bar import ProxyMenuBar

from .wx_menu import WxMenu, EVT_MENU_CHANGED
from .wx_toolkit_object import WxToolkitObject


class wxMenuBar(wx.MenuBar):
    """ A wx.MenuBar subclass which exposes a more convenient api for
    working with wxMenu children.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxMenuBar.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initialize
            a wx.MenuBar.

        """
        super(wxMenuBar, self).__init__(*args, **kwargs)
        self._menus = []
        self._visible_menus = []
        self._enabled = True

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def OnMenuChanged(self, event):
        """ The event handler for the EVT_MENU_CHANGED event.

        This event handler will synchronize the menu changes with
        the menu bar.

        """
        event.Skip()
        if self.IsAttached():
            menu = event.GetEventObject()

            # First, check for a visibility change. This requires adding
            # or removing the menu from the menu bar.
            visible = menu.IsVisible()
            was_visible = menu in self._visible_menus
            if visible != was_visible:
                if visible:
                    index = self._menus.index(menu)
                    index = min(index, len(self._visible_menus))
                    self._visible_menus.insert(index, menu)
                    self.Insert(index, menu, menu.GetTitle())
                    self.EnableTop(index, menu.IsEnabled())
                else:
                    index = self._visible_menus.index(menu)
                    self._visible_menus.pop(index)
                    self.Remove(index)
                return

            # If the menu isn't visible, there's nothing to do.
            if not visible:
                return

            # For all other state, the menu can be updated in-place.
            index = self._visible_menus.index(menu)
            self.SetMenuLabel(index, menu.GetTitle())
            self.EnableTop(index, menu.IsEnabled())

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def IsEnabled(self):
        """ Get whether or not the menu bar is enabled.

        Returns
        -------
        result : bool
            Whether or not the menu bar is enabled.

        """
        return self._enabled

    def SetEnabled(self, enabled):
        """ Set whether or not the menu bar is enabled.

        Parameters
        ----------
        enabled : bool
            Whether or not the menu bar is enabled.

        """
        # Wx does not provide a means for disabling the entire menu
        # bar, so we must do it manually by disabling each menu.
        if self._enabled != enabled:
            self._enabled = enabled
            for menu in self._menus:
                menu._SetBarEnabled(enabled)

    def AddMenu(self, menu):
        """ Add a wxMenu to the menu bar.

        If the menu already exists in the menu bar, this is a no-op.

        Parameters
        ----------
        menu : wxMenu
            The wxMenu instance to add to the menu bar.

        """
        self.InsertMenu(None, menu)

    def InsertMenu(self, before, menu):
        """ Insert a wxMenu into the menu bar.

        If the menu already exists in the menu bar, this is a no-op.

        Parameters
        ----------
        before : wxMenu
            The menu before which to insert the given menu.

        menu : wxMenu
            The menu to insert into the menu bar.

        """
        menus = self._menus
        if menu not in menus:
            if before in menus:
                index = menus.index(before)
            else:
                index = len(menus)
            menus.insert(index, menu)
            if menu.IsVisible():
                max_index = len(self._visible_menus)
                index = min(index, max_index)
                self._visible_menus.insert(index, menu)
                self.Insert(index, menu, menu.GetTitle())
            menu.Bind(EVT_MENU_CHANGED, self.OnMenuChanged)
            menu._SetBarEnabled(self._enabled)

    def RemoveMenu(self, menu):
        """ Remove a wxMenu from the menu bar.

        If the menu does not exist in the menu bar, this is a no-op.

        Parameters
        ----------
        menu : wxMenu
            The menu to remove from the menu bar.

        """
        menus = self._menus
        if menu in menus:
            menus.remove(menu)
            menu.Unbind(EVT_MENU_CHANGED, handler=self.OnMenuChanged)
            visible_menus = self._visible_menus
            if menu in visible_menus:
                index = visible_menus.index(menu)
                visible_menus.remove(menu)
                self.Remove(index)

    def Update(self):
        """ A method which can be called to update the menu bar.

        Calling this method will manually refresh the state of the
        items in the menu bar. This is useful to call just after
        attaching the menu bar to a frame, since the menu bar state
        cannot be updated prior to being attached.

        """
        if self.IsAttached():
            for index, menu in enumerate(self._visible_menus):
                self.SetMenuLabel(index, menu.GetTitle())
                if not menu.IsEnabled():
                    self.EnableTop(index, False)


class WxMenuBar(WxToolkitObject, ProxyMenuBar):
    """ A Wx implementation of an Enaml ProxyMenuBar.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(wxMenuBar)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying menu bar widget.

        """
        # Wx behaves better when creating the menu bar without a parent.
        self.widget = wxMenuBar()

    def init_layout(self):
        """ Initialize the layout for the menu bar.

        """
        super(WxMenuBar, self).init_layout()
        widget = self.widget
        for child in self.children():
            if isinstance(child, WxMenu):
                widget.AddMenu(child.widget)

    def destroy(self):
        """ A reimplemented destructor.

        This destructor simply drops the reference to the menu bar and
        the enaml declaration and clears the menus in the menu bar.
        Destroying it will cause wx to segfault.

        """
        if self.widget:
            self.widget.SetMenus([])
        del self.widget
        del self.declaration

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def find_next_menu(self, child):
        """ Get the wxMenu instance which follows the child.

        Parameters
        ----------
        child : WxMenu
            The child menu of interest.

        Returns
        -------
        result : wxMenu or None
            The wxMenu which comes immediately after the actions of the
            given child, or None if no actions follow the child.

        """
        found = False
        for dchild in self.children():
            if found:
                if isinstance(dchild, WxMenu):
                    return dchild.widget
            else:
                found = dchild is child

    def child_added(self, child):
        """ Handle the child added event for a WxMenuBar.

        """
        super(WxMenuBar, self).child_added(child)
        if isinstance(child, WxMenu):
            before = self.find_next_menu(child)
            self.widget.InsertMenu(before, child.widget)

    def child_removed(self, child):
        """ Handle the child removed event for a WxMenuBar.

        """
        super(WxMenuBar, self).child_removed(child)
        if isinstance(child, WxMenu):
            self.widget.RemoveMenu(child.widget)

########NEW FILE########
__FILENAME__ = wx_mpl_canvas
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx

from enaml.widgets.mpl_canvas import ProxyMPLCanvas

from .wx_control import WxControl

from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg
from matplotlib.backends.backend_wx import NavigationToolbar2Wx


class WxMPLCanvas(WxControl, ProxyMPLCanvas):
    """ A Wx implementation of an Enaml MPLCanvas.

    """
    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying widget.

        """
        widget = wx.Panel(self.parent_widget())
        sizer = wx.BoxSizer(wx.VERTICAL)
        widget.SetSizer(sizer)
        self.widget = widget

    def init_layout(self):
        """ Initialize the layout of the underlying widget.

        """
        super(WxMPLCanvas, self).init_layout()
        self._refresh_mpl_widget()

    #--------------------------------------------------------------------------
    # Message Handlers
    #--------------------------------------------------------------------------
    def set_figure(self, figure):
        """ Set the MPL figure for the widget.

        """
        with self.geometry_guard():
            self._refresh_mpl_widget()

    def set_toolbar_visible(self, visible):
        """ Set the toolbar visibility for the widget.

        """
        widget = self.widget
        sizer = widget.GetSizer()
        children = sizer.GetChildren()
        if len(children) == 2:
            with self.geometry_guard():
                widget.Freeze()
                toolbar = children[0]
                toolbar.Show(visible)
                sizer.Layout()
                widget.Thaw()

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _refresh_mpl_widget(self):
        """ Create the mpl widget and update the underlying control.

        """
        # Delete the old widgets in the layout, it's just shenanigans
        # to try to reuse the old widgets when the figure changes.
        widget = self.widget
        widget.Freeze()
        sizer = widget.GetSizer()
        sizer.Clear(True)

        # Create the new figure and toolbar widgets. It seems that key
        # events will not be processed without an mpl figure manager.
        # However, a figure manager will create a new toplevel window,
        # which is certainly not desired in this case. This appears to
        # be a limitation of matplotlib.
        figure = self.declaration.figure
        if figure:
            canvas = FigureCanvasWxAgg(widget, -1, figure)
            toolbar = NavigationToolbar2Wx(canvas)
            toolbar.Show(self.declaration.toolbar_visible)
            sizer.Add(toolbar, 0, wx.EXPAND)
            sizer.Add(canvas, 1, wx.EXPAND)

        sizer.Layout()
        widget.Thaw()

########NEW FILE########
__FILENAME__ = wx_notebook
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import weakref
import wx

from atom.api import Instance

from enaml.widgets.notebook import ProxyNotebook

from .wx_constraints_widget import WxConstraintsWidget
from .wx_layout_request import EVT_COMMAND_LAYOUT_REQUESTED
from .wx_page import WxPage
from .wx_upstream import aui


#: A mapping of notebook tab positions for the document style tabs.
#: Wx currently only supports top and bottom tab positions.
_TAB_POSITION_MAP = {
    'top': aui.AUI_NB_TOP,
    'left': aui.AUI_NB_TOP,
    'bottom': aui.AUI_NB_BOTTOM,
    'right': aui.AUI_NB_BOTTOM,
}


#: A mask of notebook tab positions for the document style tabs.
_TAB_POSITION_MASK = aui.AUI_NB_TOP | aui.AUI_NB_BOTTOM


class wxDocumentNotebook(aui.AuiNotebook):
    """ A custom AuiNotebook which handles children of type wxPage.

    This notebook is used to implement 'document' style tabs for an
    Enaml Notebook control.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxDocumentNotebook.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments to pass to the super
            class.

        """
        super(wxDocumentNotebook, self).__init__(*args, **kwargs)
        self.Bind(aui.EVT_AUINOTEBOOK_PAGE_CLOSE, self.OnPageClose)
        self._hidden_pages = weakref.WeakKeyDictionary()

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def OnPageClose(self, event):
        """ The handler for the EVT_AUINOTEBOOK_PAGE_CLOSE event.

        This handler forwards the event to the wxPage instance.

        """
        self.GetPage(event.GetSelection()).OnClose(event)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def GetBestSize(self):
        """ Overridden GetBestSize method which will return the best
        size for the notebook.

        """
        size = wx.Size(256, 192)
        for idx in xrange(self.GetPageCount()):
            page = self.GetPage(idx)
            psize = page.GetBestSize()
            size.SetWidth(max(size.GetWidth(), psize.GetWidth()))
            size.SetHeight(max(size.GetHeight(), psize.GetHeight()))
        # On windows, there's an off by 2 error in the width.
        height = self.GetHeightForPageHeight(size.GetHeight())
        return wx.Size(size.GetWidth() + 2, height)

    def ShowWxPage(self, page):
        """ Show a hidden wxPage instance in the notebook.

        If the page is not owned by the notebook, this is a no-op.

        Parameters
        ----------
        page : wxPage
            The hidden wxPage instance to show in the notebook.

        """
        index = self.GetPageIndex(page)
        if index == -1:
            index = self._hidden_pages.pop(page, -1)
            if index != -1:
                self.InsertWxPage(index, page)

    def HideWxPage(self, page):
        """ Hide the given wxPage instance in the notebook.

        If the page is not owned by the notebook, this is a no-op.

        Parameters
        ----------
        page : wxPage
            The wxPage instance to hide in the notebook.

        """
        index = self.GetPageIndex(page)
        if index != -1:
            self.RemovePage(index)
            page.Show(False)
            self._hidden_pages[page] = index

    def AddWxPage(self, page):
        """ Add a wxPage instance to the notebook.

        This should be used in favor of AddPage for adding a wxPage
        instance to the notebook, as it takes into account the current
        page state.

        Parameters
        ----------
        page : wxPage
            The wxPage instance to add to the notebook.

        """
        if page.IsOpen():
            self.AddPage(page, page.GetTitle())
            index = self.GetPageIndex(page)
            if not page.GetEnabled():
                self.EnableTab(index, False)
            if not page.GetClosable():
                self.SetCloseButton(index, False)
        else:
            page.Show(False)
            self._hidden_pages[page] = self.GetPageCount()

    def InsertWxPage(self, index, page):
        """ Insert a wxPage instance into the notebook.

        This should be used in favor of InsertPage for inserting a
        wxPage instance into the notebook, as it takes into account the
        current page state.

        Parameters
        ----------
        index : int
            The index at which to insert the page.

        page : wxPage
            The wxPage instance to add to the notebook.

        """
        if page.IsOpen():
            index = min(index, self.GetPageCount())
            self.InsertPage(index, page, page.GetTitle())
            if not page.GetEnabled():
                self.EnableTab(index, False)
            if not page.GetClosable():
                self.SetCloseButton(index, False)
        else:
            page.Show(False)
            self._hidden_pages[page] = index

    def RemoveWxPage(self, page):
        """ Remove a wxPage instance from the notebook.

        If the page does not exist in the notebook, this is a no-op.

        Parameters
        ----------
        page : wxPage
            The wxPage instance to remove from the notebook.

        """
        index = self.GetPageIndex(page)
        if index != -1:
            self.RemovePage(index)
            page.Show(False)


class wxPreferencesNotebook(wx.Notebook):
    """ A custom wx.Notebook which handles children of type wxPage.

    This notebook is used to implement 'document' style tabs for an
    Enaml Notebook control.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxPreferencesNotebook.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments to pass to the super
            class.

        """
        super(wxPreferencesNotebook, self).__init__(*args, **kwargs)
        self._hidden_pages = weakref.WeakKeyDictionary()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def GetBestSize(self):
        """ Overridden GetBestSize method which will return the best
        size for the notebook.

        """
        size = wx.Size(256, 192)
        for idx in xrange(self.GetPageCount()):
            page = self.GetPage(idx)
            psize = page.GetBestSize()
            size.SetWidth(max(size.GetWidth(), psize.GetWidth()))
            size.SetHeight(max(size.GetHeight(), psize.GetHeight()))
        # On windows, the wx.Notebook renders each page with 2 pixels
        # of padding on the top, and bottom, and 4 pixels of padding
        # on the left and right (at least under the Windows 7 theme).
        # We need to compensate for this padding along with the space
        # taken up by the tab bar. The tab bar height was manually
        # measured to be 21 pixels. I've found no way to have wx measure
        # it for me (there's nothing in RendererNative for it), so its
        # just hard-coded for now.
        return wx.Size(size.GetWidth() + 8, size.GetHeight() + 25)

    def ShowWxPage(self, page):
        """ Show a hidden wxPage instance in the notebook.

        If the page is not owned by the notebook, this is a no-op.

        Parameters
        ----------
        page : wxPage
            The hidden wxPage instance to show in the notebook.

        """
        index = self.GetPageIndex(page)
        if index == -1:
            index = self._hidden_pages.pop(page, -1)
            if index != -1:
                self.InsertWxPage(index, page)

    def HideWxPage(self, page):
        """ Hide the given wxPage instance in the notebook.

        If the page is not owned by the notebook, this is a no-op.

        Parameters
        ----------
        page : wxPage
            The wxPage instance to hide in the notebook.

        """
        index = self.GetPageIndex(page)
        if index != -1:
            self.RemovePage(index)
            page.Show(False)
            self._hidden_pages[page] = index

    def AddWxPage(self, page):
        """ Add a wxPage instance to the notebook.

        This should be used in favor of AddPage for adding a wxPage
        instance to the notebook, as it takes into account the current
        page state.

        Parameters
        ----------
        page : wxPage
            The wxPage instance to add to the notebook.

        """
        if page.IsOpen():
            self.AddPage(page, page.GetTitle())
        else:
            page.Show(False)
            self._hidden_pages[page] = self.GetPageCount()

    def InsertWxPage(self, index, page):
        """ Insert a wxPage instance into the notebook.

        This should be used in favor of InsertPage for inserting a
        wxPage instance into the notebook, as it takes into account the
        current page state.

        Parameters
        ----------
        index : int
            The index at which to insert the page.

        page : wxPage
            The wxPage instance to add to the notebook.

        """
        if page.IsOpen():
            index = min(index, self.GetPageCount())
            self.InsertPage(index, page, page.GetTitle())
        else:
            page.Show(False)
            self._hidden_pages[page] = index

    def RemoveWxPage(self, page):
        """ Remove a wxPage instance from the notebook.

        If the page does not exist in the notebook, this is a no-op.

        Parameters
        ----------
        page : wxPage
            The wxPage instance to remove from the notebook.

        """
        index = self.GetPageIndex(page)
        if index != -1:
            self.RemovePage(index)
            page.Show(False)

    def GetPageIndex(self, page):
        """ Returns the index of the page in the control.

        Parameters
        ----------
        page : wxPage
            The wxPage instance in the control.

        Returns
        -------
        result : int
            The index of the page in the control, or -1 if the page
            is not found.

        """
        # Wx has no way of querying for the index of a page, so we must
        # linear search ourselves. Hooray for brain-dead toolkits!
        for idx in xrange(self.GetPageCount()):
            if self.GetPage(idx) == page:
                return idx
        return -1

    def EnableTab(self, index, enabled):
        """ Change the enabled state of the tab at the given index.

        Parameters
        ----------
        index : int
            The index of the target tab.

        enabled : bool
            Whether or not the tab should be enabled.

        """
        if index >= 0 and index < self.GetPageCount():
            page = self.GetPage(index)
            page.Enable(enabled)

    def SetCloseButton(self, index, closable):
        """ A dummy method which makes the wxPreferencesNotebook api
        compatible with the wxDocumentNotebook.

        Close buttons cannot be set on a preferences notebook. This
        method exists soley so that child wxPages do not need to
        special case their implementation based on their parent.

        """
        pass


class WxNotebook(WxConstraintsWidget, ProxyNotebook):
    """ A Wx implementation of an Enaml ProxyNotebook.

    """
    #: A reference to the widget created by the proxy.
    widget = Instance((wxPreferencesNotebook, wxDocumentNotebook))

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying wx notebook widget.

        """
        if self.declaration.tab_style == 'preferences':
            w = wxPreferencesNotebook(self.parent_widget())
        else:
            style = aui.AUI_NB_SCROLL_BUTTONS
            w = wxDocumentNotebook(self.parent_widget(), agwStyle=style)
        self.widget = w

    def init_widget(self):
        """ Create and initialize the notebook control

        """
        super(WxNotebook, self).init_widget()
        d = self.declaration
        self.set_tab_style(d.tab_style)
        self.set_tab_position(d.tab_position)
        self.set_tabs_closable(d.tabs_closable)
        self.set_tabs_movable(d.tabs_movable)

    def init_layout(self):
        """ Handle the layout initialization for the notebook.

        """
        super(WxNotebook, self).init_layout()
        widget = self.widget
        for page in self.pages():
            widget.AddWxPage(page)
        widget.Bind(EVT_COMMAND_LAYOUT_REQUESTED, self.on_layout_requested)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def pages(self):
        """ Get the pages defined for the notebook.

        """
        for p in self.declaration.pages():
            yield p.proxy.widget or None

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a WxNotebook.

        """
        super(WxNotebook, self).child_added(child)
        if isinstance(child, WxPage):
            for index, dchild in enumerate(self.children()):
                if child is dchild:
                    self.widget.InsertWxPage(index, child.widget)

    def child_removed(self, child):
        """ Handle the child removed event for a WxNotebook.

        """
        super(WxNotebook, self).child_removed(child)
        if isinstance(child, WxPage):
            self.widget.RemoveWxPage(child.widget)
            self.geometry_updated()

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_layout_requested(self, event):
        """ Handle the layout request event from a child page.

        """
        self.geometry_updated()

    #--------------------------------------------------------------------------
    # ProxyNotebook API
    #--------------------------------------------------------------------------
    def set_tab_style(self, style):
        """ Set the tab style for the underlying widget.

        """
        # Changing the tab style on wx is not supported
        pass

    def set_tab_position(self, position):
        """ Set the position of the tab bar in the widget.

        """
        # Tab position changes only supported on the document notebook.
        widget = self.widget
        if isinstance(widget, wxDocumentNotebook):
            flags = widget.GetAGWWindowStyleFlag()
            flags &= ~_TAB_POSITION_MASK
            flags |= _TAB_POSITION_MAP[position]
            widget.SetAGWWindowStyleFlag(flags)
            widget.Refresh()  # Avoids rendering artifacts

    def set_tabs_closable(self, closable):
        """ Set whether or not the tabs are closable.

        """
        # Closable tabs are only supported on the document notebook.
        widget = self.widget
        if isinstance(widget, wxDocumentNotebook):
            flags = widget.GetAGWWindowStyleFlag()
            if closable:
                flags |= aui.AUI_NB_CLOSE_ON_ALL_TABS
            else:
                flags &= ~aui.AUI_NB_CLOSE_ON_ALL_TABS
            widget.SetAGWWindowStyleFlag(flags)

    def set_tabs_movable(self, movable):
        """ Set whether or not the tabs are movable.

        """
        # Movable tabs are only supported on the document notebook.
        widget = self.widget
        if isinstance(widget, wxDocumentNotebook):
            flags = widget.GetAGWWindowStyleFlag()
            if movable:
                flags |= aui.AUI_NB_TAB_MOVE
            else:
                flags &= ~aui.AUI_NB_TAB_MOVE
            widget.SetAGWWindowStyleFlag(flags)

    def set_size_hint_mode(self, mode):
        """ This is not supported on Wx.

        """
        pass

########NEW FILE########
__FILENAME__ = wx_page
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx
import wx.lib.newevent

from atom.api import Typed

from enaml.widgets.page import ProxyPage

from .wx_container import WxContainer
from .wx_widget import WxWidget
from .wx_single_widget_sizer import wxSingleWidgetSizer


#: An event emitted when the notebook page is closed.
wxPageClosedEvent, EVT_PAGE_CLOSED = wx.lib.newevent.NewEvent()


class wxPage(wx.Panel):
    """ A wxPanel subclass which acts as a page in a wx notebook.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxPage.

        Parameters
        ----------
        *args, **kwargs
            The position and keyword arguments required to initialize
            a wxContainer.

        """
        super(wxPage, self).__init__(*args, **kwargs)
        self._title = u''
        self._closable = True
        self._is_enabled = True
        self._is_open = True
        self._page_widget = None
        self.SetSizer(wxSingleWidgetSizer())
        self.Bind(wx.EVT_SHOW, self.OnShow)

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def OnClose(self, event):
        """ Handle the page close event.

        This event handler is called by the parent notebook. The parent
        event is always be vetoed or else Wx will destroy the page. If
        the page is closable, we close the page and emit the custom
        close event.

        """
        event.Veto()
        if self.GetClosable():
            self.Close()
            evt = wxPageClosedEvent()
            wx.PostEvent(self, evt)

    def OnShow(self, event):
        """ Handle the show event.

        Wx will not emit an EVT_SHOW on the child of this page. So, this
        event handler passes the show event along to the contained page
        widget, so that it can disable its layout when not visible.

        """
        page = self._page_widget
        if page:
            wx.PostEvent(page, event)

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _PageIndexOperation(self, closure):
        """ A private method which will run the given closure if there
        is a valid index for this page.

        """
        parent = self.GetParent()
        if parent:
            index = parent.GetPageIndex(self)
            if index != -1:
                closure(parent, index)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def GetPageWidget(self):
        """ Get the page widget for this page.

        Returns
        -------
        result : wxWindow or None
            The page widget being managed by this page.

        """
        return self._page_widget

    def SetPageWidget(self, widget):
        """ Set the page widget for this page.

        Parameters
        ----------
        widget : wxWindow
            The wx widget to use as the page widget in this page.

        """
        self._page_widget = widget
        self.GetSizer().Add(widget)

    def IsOpen(self):
        """ Get whether or not the page is open.

        Returns
        -------
        result : bool
            True if the page is open, False otherwise.

        """
        return self._is_open

    def Open(self):
        """ Open the page in the notebook.

        """
        self._is_open = True
        parent = self.GetParent()
        if parent:
            parent.ShowWxPage(self)

    def Close(self):
        """ Close the page in the notebook.

        """
        self._is_open = False
        parent = self.GetParent()
        if parent:
            parent.HideWxPage(self)

    def GetEnabled(self):
        """ Get the enabled state of the page.

        This method should be used in favor of IsEnabled.

        Returns
        -------
        result : bool
            True the page is enabled, False otherwise.

        """
        return self._is_enabled

    def SetEnabled(self, enabled):
        """ Set the enabled state of the page.

        This method should be used in favor of Enable.

        Parameters
        ---------
        enabled : bool
            Whether or not the page should be enabled.

        """
        self._is_enabled = enabled
        def closure(nb, index):
            nb.EnableTab(index, enabled)
        self._PageIndexOperation(closure)

    def GetTitle(self):
        """ Returns tab title for this page.

        Returns
        -------
        result : unicode
            The title string for the page's tab.

        """
        return self._title

    def SetTitle(self, title):
        """ Set the title for this page.

        Parameters
        ----------
        title : unicode
            The string to use for this page's tab title.

        """
        self._title = title
        def closure(nb, index):
            nb.SetPageText(index, title)
        self._PageIndexOperation(closure)

    def GetClosable(self):
        """ Returns whether or not this page is closable.

        Returns
        -------
        result : bool
            True if this page is closable, False otherwise.

        """
        return self._closable

    def SetClosable(self, closable):
        """ Set whether this page is closable.

        Parameters
        ----------
        closable : bool
            True if this page should be closable, False otherwise.

        """
        self._closable = closable
        def closure(nb, index):
            nb.SetCloseButton(index, closable)
        self._PageIndexOperation(closure)


class WxPage(WxWidget, ProxyPage):
    """ A Wx implementation of an Enaml notebook ProxyPage.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(wxPage)

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying wxPage widget.

        """
        self.widget = wxPage(self.parent_widget())

    def init_widget(self):
        """ Create and initialize the page control.

        """
        super(WxPage, self).init_widget()
        d = self.declaration
        self.set_title(d.title)
        self.set_closable(d.closable)
        if d.icon:
            self.set_icon(d.icon)
        self.widget.Bind(EVT_PAGE_CLOSED, self.on_page_closed)

    def init_layout(self):
        """ Initialize the layout of the notebook page.

        """
        super(WxPage, self).init_layout()
        self.widget.SetPageWidget(self.page_widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def page_widget(self):
        """ Find and return the page widget child for this widget.

        """
        p = self.declaration.page_widget()
        if p is not None:
            return p.proxy.widget or None

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a WxPage.

        """
        super(WxPage, self).child_removed(child)
        if isinstance(child, WxContainer):
            self.widget.SetPageWidget(self.page_widget())

    def child_removed(self, child):
        """ Handle the child removed event for a WxPage.

        """
        super(WxPage, self).child_removed(child)
        if isinstance(child, WxContainer):
            self.widget.SetPageWidget(self.page_widget())

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_page_closed(self, event):
        """ The event handler for the EVT_PAGE_CLOSED event.

        """
        self.declaration._handle_close()

    #--------------------------------------------------------------------------
    # ProxyPage API
    #--------------------------------------------------------------------------
    def set_visible(self, visible):
        """ An overridden visibility setter which to opens|closes the
        notebook page.

        """
        if visible:
            self.widget.Open()
        else:
            self.widget.Close()

    def ensure_visible(self):
        """ An overridden visibility setter which to opens|closes the
        notebook page.

        """
        self.set_visible(True)

    def ensure_hidden(self):
        """ An overridden visibility setter which to opens|closes the
        notebook page.

        """
        self.set_visible(False)

    def set_enabled(self, enabled):
        """ An overridden enabled setter which sets the tab enabled
        state.

        """
        self.widget.SetEnabled(enabled)

    def set_title(self, title):
        """ Set the title of the tab for this page.

        """
        self.widget.SetTitle(title)

    def set_icon(self, icon):
        """ Sets the widget's icon to the provided image.

        This is not supported on Wx.

        """
        pass

    def set_closable(self, closable):
        """ Set whether or not this page is closable.

        """
        self.widget.SetClosable(closable)

########NEW FILE########
__FILENAME__ = wx_progress_bar
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx

from atom.api import Typed

from enaml.widgets.progress_bar import ProxyProgressBar

from .wx_control import WxControl


class WxProgressBar(WxControl, ProxyProgressBar):
    """ A Wx implementation of an Enaml ProxyProgressBar.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(wx.Gauge)

    #--------------------------------------------------------------------------
    # Setup Methods
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying wx.Gauge widget.

        """
        self.widget = wx.Gauge(self.parent_widget())

    def init_widget(self):
        """ Create and initialize the progress bar control.

        """
        super(WxProgressBar, self).init_widget()
        d = self.declaration
        self.set_minimum(d.minimum)
        self.set_maximum(d.maximum)
        self.set_value(d.value)
        self.set_text_visible(d.text_visible)

    #--------------------------------------------------------------------------
    # ProxyProgressBar API
    #--------------------------------------------------------------------------
    def set_minimum(self, value):
        """ Set the minimum value of the progress bar

        """
        d = self.declaration
        self.widget.SetRange(d.maximum - value)

    def set_maximum(self, value):
        """ Set the maximum value of the progress bar

        """
        d = self.declaration
        self.widget.SetRange(value - d.minimum)

    def set_value(self, value):
        """ Set the value of the progress bar

        """
        d = self.declaration
        self.widget.SetValue(value - d.minimum)

    def set_text_visible(self, visible):
        """ Set the text visibility on the widget.

        This is not implemented on Wx.

        """
        pass

########NEW FILE########
__FILENAME__ = wx_push_button
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx

from atom.api import Typed

from enaml.widgets.push_button import ProxyPushButton

from .wx_abstract_button import WxAbstractButton


class WxPushButton(WxAbstractButton, ProxyPushButton):
    """ A Wx implementation of the Enaml ProxyPushButton.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(wx.Button)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying wxButton widget.

        """
        self.widget = wx.Button(self.parent_widget())

    def init_widget(self):
        """ Handle layout initialization for the push button.

        """
        super(WxPushButton, self).init_widget()
        self.widget.Bind(wx.EVT_BUTTON, self.on_clicked)

    #--------------------------------------------------------------------------
    # Abstract API Implementation
    #--------------------------------------------------------------------------
    def set_checkable(self, checkable):
        """ Sets whether or not the widget is checkable.

        This is not supported on Wx.

        """
        pass

    def get_checked(self):
        """ Returns the checked state of the widget.

        """
        return False

    def set_checked(self, checked):
        """ Sets the widget's checked state with the provided value.

        """
        pass

    #--------------------------------------------------------------------------
    # ProxyPushButton API
    #--------------------------------------------------------------------------
    def set_default(self, default):
        """ This is not supported on Wx.

        """
        pass

########NEW FILE########
__FILENAME__ = wx_radio_button
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from weakref import WeakKeyDictionary

import wx
import wx.lib.newevent

from atom.api import Typed

from enaml.widgets.radio_button import ProxyRadioButton

from .wx_abstract_button import WxAbstractButton, CHECKED_GUARD


#: A radio button event that is emited when the button is clicked.
wxRadioClicked, EVT_RADIO_CLICKED = wx.lib.newevent.NewEvent()

#: A radio button event emitted when the button value is changed.
wxRadioToggled, EVT_RADIO_TOGGLED = wx.lib.newevent.NewEvent()


class wxProperRadioButton(wx.RadioButton):
    """ A custom stubclass of wx.RadioButton.

    The wx.RadioButton doesn't emit toggled events when it unchecks the
    other radio buttons in the same group. So, the only time an
    EVT_RADIOBUTTON is emitted is when the button changes from off to
    on. This custom subclass does some orchestration and will emit an
    EVT_RADIO_TOGGLED whenever the control changes its value. It also
    emits an EVT_RADIO_CLICKED event when the control is clicked, even
    if the click doesn't change the value in the control.

    """
    #: The WeakKeyDictionary which stores the sibling radio buttons
    #: for a given parent widget. When any radio button is toggled,
    #: the list of siblings is iterated and each child is given the
    #: the chance to see it's been toggled off. If it has, then it
    #: will emit a toggled event.
    _parents = WeakKeyDictionary()

    def __init__(self, *args, **kwargs):
        """ Initialize a wxProperRadioButton.

        *args, **kwargs
            The positional and keyword arguments required to initialize
            a wx.RadioButton.

        """
        super(wxProperRadioButton, self).__init__(*args, **kwargs)
        parent = self.GetParent()
        if parent:
            children = self._parents.setdefault(parent, [])
            children.append(self)
        self._last = self.GetValue()
        self._in_click = False
        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.Bind(wx.EVT_RADIOBUTTON, self.OnToggled)

    def OnLeftDown(self, event):
        """ Handles the left down mouse event for the radio button.

        This is first part of generating a click event.

        """
        event.Skip()
        self._in_click = True

    def OnLeftUp(self, event):
        """ Handles the left up mouse event for the radio button.

        This is the second part of generating a click event.

        """
        event.Skip()
        if self._in_click:
            self._in_click = False
            event = wxRadioClicked()
            wx.PostEvent(self, event)

    def OnToggled(self, event):
        """ Handles the standard toggle event and emits a toggle on
        event. After emitting that event, it will cycle through the
        list of its siblings and give them a change to emit a toggle
        off event.

        """
        self._last = self.GetValue()
        event = wxRadioToggled()
        wx.PostEvent(self, event)
        self.CheckSiblings()

    def CheckToggledOff(self):
        """ Checks the state of the radio button to see if it has been
        toggled from on to off. If it has, it will emit a toggle off
        event.

        """
        last = self._last
        curr = self.GetValue()
        if not curr and last:
            self._last = curr
            event = wxRadioToggled()
            wx.PostEvent(self, event)

    def CheckSiblings(self):
        """ Iterates over the siblings of this radio button, giving
        each a chance to respond to a possible toggle off.

        """
        parent = self.GetParent()
        if parent:
            parents = self._parents
            if parent in parents:
                for child in parents[parent]:
                    child.CheckToggledOff()

    def SetValue(self, val):
        """ Overrides the default SetValue method to emit proper events.

        """
        old = self.GetValue()
        if old != val:
            super(wxProperRadioButton, self).SetValue(val)
            self._last = val
            event = wxRadioToggled()
            wx.PostEvent(self, event)
            self.CheckSiblings()

    def Destroy(self):
        """ Overridden destroy method to remove the radio button from
        the list of siblings before it's destroyed.

        """
        parent = self.GetParent()
        if parent:
            parents = self._parents
            if parent in parents:
                children = parents[parent]
                try:
                    children.remove(self)
                except ValueError:
                    pass
        super(wxProperRadioButton, self).Destroy()


class WxRadioButton(WxAbstractButton, ProxyRadioButton):
    """ A Wx implementation of an Enaml ProxyRadioButton.

    WxRadioButton uses a custom wx.RadioButton control. Radio buttons
    with the same parent will be mutually exclusive. For independent
    groups, place them in their own parent component.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(wxProperRadioButton)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Creates the underlying custom wx.RadioButton control.

        """
        self.widget = wxProperRadioButton(self.parent_widget())

    def init_widget(self):
        """ Initialize the radio button control.

        """
        super(WxRadioButton, self).init_widget()
        widget = self.widget
        widget.Bind(EVT_RADIO_CLICKED, self.on_clicked)
        widget.Bind(EVT_RADIO_TOGGLED, self.on_toggled)

    #--------------------------------------------------------------------------
    # Abstract API Implementation
    #--------------------------------------------------------------------------
    def set_checkable(self, checkable):
        """ Sets whether or not the widget is checkable.

        This is not supported in Wx.

        """
        pass

    def get_checked(self):
        """ Returns the checked state of the widget.

        """
        return self.widget.GetValue()

    def set_checked(self, checked):
        """ Sets the widget's checked state with the provided value.

        """
        self._guard |= CHECKED_GUARD
        try:
            self.widget.SetValue(checked)
        finally:
            self._guard &= ~CHECKED_GUARD

########NEW FILE########
__FILENAME__ = wx_resource_helpers
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx

from enaml.fontext import FontStyle


FONT_STYLE = {
    FontStyle.Normal: wx.FONTSTYLE_NORMAL,
    FontStyle.Italic: wx.FONTSTYLE_ITALIC,
    FontStyle.Oblique: wx.FONTSTYLE_SLANT,
}


# ASPECT_RATIO_MODE = {
#     'ignore': Qt.IgnoreAspectRatio,
#     'keep': Qt.KeepAspectRatio,
#     'keep_by_expanding': Qt.KeepAspectRatioByExpanding
# }


# TRANSFORM_MODE = {
#     'fast': Qt.FastTransformation,
#     'smooth': Qt.SmoothTransformation
# }


# ICON_MODE = {
#     'normal': QIcon.Normal,
#     'disabled': QIcon.Disabled,
#     'active': QIcon.Active,
#     'selected': QIcon.Selected,
# }


# ICON_STATE = {
#     'off': QIcon.Off,
#     'on': QIcon.On,
# }


# def QImage_from_Image(image):
#     """ Convert an Enaml Image into a QImage.

#     Parameters
#     ----------
#     image : Image
#         The Enaml Image object.

#     Returns
#     -------
#     result : QImage
#         The QImage instance for the given Enaml image.

#     """
#     format = image.format
#     if format == 'auto':
#         format = ''
#     qimage = QImage.fromData(image.data, format)
#     if -1 not in image.size and not qimage.isNull():
#         qsize = QSize(*image.size)
#         if qsize != qimage.size():
#             mode = ASPECT_RATIO_MODE[image.aspect_ratio_mode]
#             transform = TRANSFORM_MODE[image.transform_mode]
#             qimage = qimage.scaled(qsize, mode, transform)
#     return qimage


# def get_cached_qimage(image):
#     """ Get the cached QImage for the Enaml Image.

#     Parameters
#     ----------
#     image : Image
#         The Enaml Image object.

#     Returns
#     -------
#     result : QImage
#         The cached QImage for the image. If no cached image exists, one
#         will be created.

#     """
#     qimage = image._tkdata
#     if not isinstance(qimage, QImage):
#         qimage = image._tkdata = QImage_from_Image(image)
#     return qimage


# def QIcon_from_Icon(icon):
#     """ Convert the given Enaml Icon into a QIcon.

#     Parameters
#     ----------
#     icon : Icon
#         The Enaml Icon object.

#     Returns
#     -------
#     result : QIcon
#         The QIcon instance for the given Enaml icon.

#     """
#     qicon = QIcon()
#     for icon_image in icon.images:
#         image = icon_image.image
#         if not image:
#             continue
#         mode = ICON_MODE[icon_image.mode]
#         state = ICON_STATE[icon_image.state]
#         qimage = get_cached_qimage(image)
#         qpixmap = QPixmap.fromImage(qimage)
#         qicon.addPixmap(qpixmap, mode, state)
#     return qicon


# def get_cached_qicon(icon):
#     """ Get the cached QIcon for the Enaml Icon.

#     Parameters
#     ----------
#     icon : Icon
#         The Enaml Icon object.

#     Returns
#     -------
#     result : QIcon
#         The cached QIcon for the icon. If no cached icon exists, one
#         will be created.

#     """
#     qicon = icon._tkdata
#     if not isinstance(qicon, QIcon):
#         qicon = icon._tkdata = QIcon_from_Icon(icon)
#     return qicon


def wxColor_from_Color(color):
    """ Convert the given Enaml Color into a wxColor.

    Parameters
    ----------
    color : Color
        The Enaml Color object.

    Returns
    -------
    result : wxColor
        The wxColor instance for the given Enaml color.

    """
    return wx.Color(color.red, color.green, color.blue, color.alpha)


def get_cached_wxcolor(color):
    """ Get the cached QColor for the Enaml Color.

    Parameters
    ----------
    color : Color
        The Enaml Color object.

    Returns
    -------
    result : QColor
        The cached QColor for the color. If no cached color exists, one
        will be created.

    """
    wxcolor = color._tkdata
    if not isinstance(wxcolor, wx.Color):
        wxcolor = color._tkdata = wxColor_from_Color(color)
    return wxcolor


def wxFont_from_Font(font):
    """ Convert the given Enaml Font into a wxFont.

    Parameters
    ----------
    font : Font
        The Enaml Font object.

    Returns
    -------
    result : wxFont
        The wxFont instance for the given Enaml font.

    """
    wxstyle = FONT_STYLE[font.style]
    if font.weight < 50:
        wxweight = wx.FONTWEIGHT_LIGHT
    elif font.weight >= 75:
        wxweight = wx.FONTWEIGHT_BOLD
    else:
        wxweight = wx.FONTWEIGHT_NORMAL
    wxfamily = wx.FONTFAMILY_DEFAULT
    wxfont = wx.Font(font.pointsize, wxfamily, wxstyle, wxweight)
    wxfont.SetFaceName(font.family)
    return wxfont


def get_cached_wxfont(font):
    """ Get the cached wxFont for the Enaml Font.

    Parameters
    ----------
    font : Font
        The Enaml Font object.

    Returns
    -------
    result : wxFont
        The cached wxFont for the font. If no cached font exists, one
        will be created.

    """
    wxfont = font._tkdata
    if not isinstance(wxfont, wx.Font):
        wxfont = font._tkdata = wxFont_from_Font(font)
    return wxfont

########NEW FILE########
__FILENAME__ = wx_scroll_area
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx

from atom.api import Typed

from enaml.widgets.scroll_area import ProxyScrollArea

from .wx_container import WxContainer
from .wx_frame import WxFrame
from .wx_single_widget_sizer import wxSingleWidgetSizer


# The 'always_on' scroll policy is not supported on wx, because it
# requires setting a window style flag which does not dynamically
# toggle in a reliable fashion. Since we only support 'off' or 'auto'
# it's easiest to use this mapping to convert straight from policy
# values into a respective scroll rate. A rate of Zero causes wx not
# to show the scroll bar. A positive rate indicates to scroll that many
# pixels per event. We set the rate to 1 to have smooth scrolling. Wx
# doesn't make a distinction between scroll events caused by the mouse
# or scrollbar and those caused by clicking the scroll buttons (ala qt),
# and thus this rate applies the same to all of those events. Since we
# expect that clicking on a scroll button happens much more infrequently
# than scrolling by dragging the scroll bar, we opt for a lower rate
# in order to get smooth drag scrolling and sacrifice some usability
# on the scroll buttons.
SCROLLBAR_MAP = {
    'as_needed': 1,
    'always_off': 0,
    'always_on': 1,
}


class wxScrollAreaSizer(wxSingleWidgetSizer):
    """ A wxSingleWidgetSizer subclass which makes adjusts the min
    size to account for a 2 pixel error in Wx.

    """
    def CalcMin(self):
        """ Returns the minimum size for the area owned by the sizer.

        Returns
        -------
        result : wxSize
            The wx size representing the minimum area required by the
            sizer.

        """
        # The effective min size computation is correct, but the wx
        # scrolled window interprets it with an error of 2px. That
        # is we need to make wx think that the min size is 2px smaller
        # than it actually is so that scroll bars should and hide at
        # the appropriate sizes.
        res = super(wxScrollAreaSizer, self).CalcMin()
        if res.IsFullySpecified():
            res.width -= 2
            res.height -= 2
        return res

    def RecalcSizes(self):
        """ Resizes the child to fit the available space of the window.

        This takes into account the maximum allowed size of the widget.

        """
        widget = self.GetWidget()
        if widget:
            size = self.GetSize()
            size.DecTo(self.CalcMax())
            widget.SetSize(size)


class wxScrollArea(wx.ScrolledWindow):
    """ A custom wx.ScrolledWindow which is suits Enaml's use case.

    """
    #: The internal best size. The same as QAbstractScrollArea.
    _best_size = wx.Size(256, 192)

    def __init__(self, *args, **kwargs):
        """ Initialize a wxScrollArea.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initialize
            a wxScrolledWindow.

        """
        super(wxScrollArea, self).__init__(*args, **kwargs)
        self._scroll_widget = None
        self.SetSizer(wxScrollAreaSizer())

    def GetBestSize(self):
        """ An overridden parent class method which returns a sensible
        best size.

        The default wx implementation returns a best size of (16, 16)
        on Windows; far too small to be useful. So, we just adopt the
        size hint of (256, 192) used in Qt's QAbstractScrollArea.

        """
        return self._best_size

    def GetScrollWidget(self):
        """ Get the scroll widget for this scroll area.

        Returns
        -------
        results : wxWindow
            The wxWindow being scrolled by this scroll area.

        """
        return self._scroll_widget

    def SetScrollWidget(self, widget):
        """ Set the scroll widget for this scroll area.

        Parameters
        ----------
        widget : wxWindow
            The wxWindow which should be scrolled by this area.

        """
        self._scroll_widget = widget
        self.GetSizer().Add(widget)


class WxScrollArea(WxFrame, ProxyScrollArea):
    """ A Wx implementation of an Enaml ScrollArea.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(wxScrollArea)

    def create_widget(self):
        """ Create the underlying wxScrolledWindow widget.

        """
        style = wx.HSCROLL | wx.VSCROLL | wx.BORDER_SIMPLE
        self.widget = wxScrollArea(self.parent_widget(), style=style)

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(WxScrollArea, self).init_widget()
        d = self.declaration
        self.set_horizontal_policy(d.horizontal_policy)
        self.set_vertical_policy(d.vertical_policy)
        self.set_widget_resizable(d.widget_resizable)

    def init_layout(self):
        """ Handle the layout initialization for the scroll area.

        """
        super(WxScrollArea, self).init_layout()
        self.widget.SetScrollWidget(self.scroll_widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def scroll_widget(self):
        """ Find and return the scroll widget child for this widget.

        """
        w = self.declaration.scroll_widget()
        if w is not None:
            return w.proxy.widget or None

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a WxScrollArea.

        """
        super(WxScrollArea, self).child_added(child)
        if isinstance(child, WxContainer):
            self.widget.SetScrollWidget(self.scroll_widget())

    def child_removed(self, child):
        """ Handle the child removed event for a WxScrollArea.

        """
        super(WxScrollArea, self).child_removed(child)
        if isinstance(child, WxContainer):
            self.widget.SetScrollWidget(self.scroll_widget())

    #--------------------------------------------------------------------------
    # Overrides
    #--------------------------------------------------------------------------
    def replace_constraints(self, old_cns, new_cns):
        """ A reimplemented WxConstraintsWidget layout method.

        Constraints layout may not cross the boundary of a ScrollArea,
        so this method is no-op which stops the layout propagation.

        """
        pass

    #--------------------------------------------------------------------------
    # ProxyScrollArea API
    #--------------------------------------------------------------------------
    def set_horizontal_policy(self, policy):
        """ Set the horizontal scrollbar policy of the widget.

        """
        horiz = SCROLLBAR_MAP[policy]
        vert = SCROLLBAR_MAP[self.declaration.vertical_policy]
        self.widget.SetScrollRate(horiz, vert)

    def set_vertical_policy(self, policy):
        """ Set the vertical scrollbar policy of the widget.

        """
        horiz = SCROLLBAR_MAP[self.declaration.horizontal_policy]
        vert = SCROLLBAR_MAP[policy]
        self.widget.SetScrollRate(horiz, vert)

    def set_widget_resizable(self, resizable):
        """ Set whether or not the scroll widget is resizable.

        This is not supported on Wx.

        """
        pass

########NEW FILE########
__FILENAME__ = wx_single_widget_sizer
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx


class wxSingleWidgetSizer(wx.PySizer):
    """ A custom wx Sizer for sizing a single child widget.

    There can only be one widget in this sizer at a time and it should
    be added via the .Add(...) method. Old items will be removed
    automatically (but not destroyed).

    """
    _default_size = wx.Size(-1, -1)

    _widget = None

    def CalcMax(self):
        """ A method to compute the maximum size allowed by the sizer.

        This is not a native wx sizer method, but is included for
        convenience.

        """
        widget = self._widget
        if not widget:
            return self._default_size
        return widget.GetMaxSize()

    def GetWidget(self):
        """ Get a reference tot he underlying widget.

        """
        return self._widget

    def Add(self, widget):
        """ Adds the given widget to the sizer, removing the old widget
        if present. The old widget is not destroyed.

        """
        if self._widget is not widget:
            self.Clear(deleteWindows=False)
            old = self._widget
            if old:
                old.Hide()
            self._widget = widget
            if widget:
                widget.Show()
                res = super(wxSingleWidgetSizer, self).Add(widget)
                self.Layout()
                return res

    def CalcMin(self):
        """ Returns the minimum size for the children this sizer is
        managing.

        """
        widget = self._widget
        if not widget:
            return self._default_size
        return widget.GetEffectiveMinSize()

    def RecalcSizes(self):
        """ Resizes the child to fit the available space of the window.

        """
        widget = self._widget
        if widget:
            widget.SetSize(self.GetSize())

########NEW FILE########
__FILENAME__ = wx_slider
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx
import wx.lib.newevent

from atom.api import Int, Typed

from enaml.widgets.slider import ProxySlider

from .wx_control import WxControl


#: Horizontal tick mapping
_TICK_POSITION_MAP = {
    'top': wx.SL_TOP | wx.SL_AUTOTICKS,
    'bottom': wx.SL_BOTTOM | wx.SL_AUTOTICKS,
    'left': wx.SL_LEFT | wx.SL_AUTOTICKS,
    'right': wx.SL_RIGHT | wx.SL_AUTOTICKS,
    'both': wx.SL_BOTH | wx.SL_AUTOTICKS,
}


#: An OR'd combination of all the tick flags.
_TICK_MASK = (
    wx.SL_TOP | wx.SL_BOTTOM | wx.SL_LEFT | wx.SL_RIGHT | wx.SL_BOTH |
    wx.SL_AUTOTICKS
)


#: A map adapting orientation to tick positions
_TICK_ADAPT_MAP = {
    'vertical': {
        'left': 'left',
        'right': 'right',
        'both': 'both',
        'top': 'left',
        'bottom': 'right',
    },
    'horizontal': {
        'left': 'top',
        'right': 'bottom',
        'both': 'both',
        'top': 'top',
        'bottom': 'bottom',
    },
}


#: A map from string orientation to wx slider orientation
_ORIENTATION_MAP = {
    'horizontal': wx.SL_HORIZONTAL,
    'vertical': wx.SL_VERTICAL,
}


#: An OR'd combination of all the orientation flags
_ORIENTATION_MASK = wx.SL_HORIZONTAL | wx.SL_VERTICAL


#: A new event emitted by the custom slider control
wxSliderEvent, EVT_SLIDER = wx.lib.newevent.NewEvent()


class wxProperSlider(wx.Slider):
    """ A wx.Slider subclass which supports tracking.

    """
    #: The event types for the frequent thumb track event
    _tracking_evt = wx.EVT_SCROLL_THUMBTRACK.evtType[0]

    #: The event type for the thumb release event.
    _release_evt = wx.EVT_SCROLL_THUMBRELEASE.evtType[0]

    #: The event type for the scroll end event.
    _end_evt = wx.EVT_SCROLL_CHANGED.evtType[0]

    def __init__(self, *args, **kwargs):
        """ Initialize a wxProperSlider.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments for initializing a
            wx.Slider.

        """
        super(wxProperSlider, self).__init__(*args, **kwargs)
        self._tracking = True
        self.Bind(wx.EVT_SCROLL, self.OnScroll)

    def OnScroll(self, event):
        """ An event handler which handles all scroll events.

        This handler determines whether or not a slider event sould be
        emitted for the scroll changed, based on whether tracking is
        enabled for the slider.

        """
        evt_type = event.EventType

        # We never emit on the _end_event since that is windows-only
        if evt_type == self._end_evt:
            return

        if self._tracking:
            if evt_type != self._release_evt:
                emit = True
            else:
                emit = False
        else:
            emit = evt_type != self._tracking_evt

        if emit:
            evt = wxSliderEvent()
            wx.PostEvent(self, evt)

    def GetTracking(self):
        """ Whether or not tracking is enabled for the slider.

        Returns
        -------
        result : bool
            True if tracking is enabled for the slider, False otherwise.

        """
        return self._tracking

    def SetTracking(self, tracking):
        """ Set whether tracking is enabled for the slider.

        Parameters
        ----------
        tracking : bool
            True if tracking should be enabled, False otherwise.

        """
        self._tracking = tracking


#: A cyclic guard flag
VALUE_FLAG = 0x1


class WxSlider(WxControl, ProxySlider):
    """ A Wx implementation of an Enaml ProxySlider.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(wxProperSlider)

    #: Cyclic notification guard flags.
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying wxProperSlider widget.

        """
        self.widget = wxProperSlider(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        # NOTE: The tick interval must be set *after* the tick position
        # or Wx will ignore the tick interval. grrr...
        super(WxSlider, self).init_widget()
        d = self.declaration
        self.set_minimum(d.minimum)
        self.set_maximum(d.maximum)
        self.set_value(d.value)
        self.set_orientation(d.orientation)
        self.set_page_step(d.page_step)
        self.set_single_step(d.single_step)
        self.set_tick_position(d.tick_position)
        self.set_tick_interval(d.tick_interval)
        self.set_tracking(d.tracking)
        self.widget.Bind(EVT_SLIDER, self.on_value_changed)

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_value_changed(self, event):
        """ Send the 'value_changed' action to the Enaml widget when the
        slider value has changed.

        """
        if not self._guard & VALUE_FLAG:
            self._guard |= VALUE_FLAG
            try:
                self.declaration.value = self.widget.GetValue()
            finally:
                self._guard &= ~VALUE_FLAG

    #--------------------------------------------------------------------------
    # ProxySlider API
    #--------------------------------------------------------------------------
    def set_value(self, value):
        """ Set the value of the underlying widget.

        """
        if not self._guard & VALUE_FLAG:
            self._guard |= VALUE_FLAG
            try:
                self.widget.SetValue(value)
            finally:
                self._guard &= ~VALUE_FLAG

    def set_maximum(self, maximum):
        """ Set the maximum value of the underlying widget.

        """
        widget = self.widget
        minimum, _ = widget.GetRange()
        widget.SetRange(minimum, maximum)

    def set_minimum(self, minimum):
        """ Set the minimum value of the underlying widget.

        """
        widget = self.widget
        _, maximum = widget.GetRange()
        widget.SetRange(minimum, maximum)

    def set_orientation(self, orientation):
        """ Set the orientation of the underlying widget.

        """
        widget = self.widget
        style = widget.GetWindowStyle()
        style &= ~_ORIENTATION_MASK
        style |= _ORIENTATION_MAP[orientation]
        widget.SetWindowStyle(style)

    def set_page_step(self, page_step):
        """ Set the page step of the underlying widget.

        """
        self.widget.SetPageSize(page_step)

    def set_single_step(self, single_step):
        """ Set the single step of the underlying widget.

        """
        self.widget.SetLineSize(single_step)

    def set_tick_interval(self, interval):
        """ Set the tick interval of the underlying widget.

        """
        self.widget.SetTickFreq(interval)

    def set_tick_position(self, tick_position):
        """ Set the tick position of the underlying widget.

        """
        widget = self.widget
        style = widget.GetWindowStyle()
        style &= ~_TICK_MASK
        if tick_position != 'no_ticks':
            if style & wx.SL_VERTICAL:
                tick_position = _TICK_ADAPT_MAP['vertical'][tick_position]
            else:
                tick_position = _TICK_ADAPT_MAP['horizontal'][tick_position]
            style |= _TICK_POSITION_MAP[tick_position]
        widget.SetWindowStyle(style)

    def set_tracking(self, tracking):
        """ Set the tracking of the underlying widget.

        """
        self.widget.SetTracking(tracking)

########NEW FILE########
__FILENAME__ = wx_spin_box
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx
import wx.lib.newevent

from atom.api import Int, Typed

from enaml.widgets.spin_box import ProxySpinBox

from .wx_control import WxControl


#: The changed event for the custom spin box
wxSpinBoxEvent, EVT_SPIN_BOX = wx.lib.newevent.NewEvent()


class wxProperSpinBox(wx.SpinCtrl):
    """ A custom wx spin control that acts more like QSpinBox.

    The standard wx.SpinCtrl doesn't support too many features, and
    the ones it does support are (like wrapping) are limited. So,
    this custom control hard codes the internal range to the maximum
    range of the wx.SpinCtrl and implements wrapping manually.

    For changed events, users should bind to EVT_SPIN_BOX rather than
    EVT_SPINCTRL.

    See the method docstrings for supported functionality.

    This control is really a god awful hack and needs to be rewritten
    using a combination wx.SpinButton and wx.TextCtrl.

    """
    def __init__(self, *args, **kwargs):
        """ CustomSpinCtrl constructor.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments for initializing a
            wx.SpinCtrl.

        """
        # The max range of the wx.SpinCtrl is the range of a signed
        # 32bit integer. We don't care about wx's internal value of
        # the control, since we maintain our own internal counter.
        # and because the internal value of the widget gets reset to
        # the minimum of the range whenever SetValueString is called.
        self._hard_min = -(1 << 31)
        self._hard_max = (1 << 31) - 1
        self._internal_value = 0
        self._low = 0
        self._high = 100
        self._step = 1
        self._prefix = u''
        self._suffix = u''
        self._special_value_text = u''
        self._value_string = unicode(self._low)
        self._wrap = False
        self._read_only = False

        # Stores whether spin-up or spin-down was pressed.
        self._spin_state = None

        super(wxProperSpinBox, self).__init__(*args, **kwargs)
        super(wxProperSpinBox, self).SetRange(self._hard_min, self._hard_max)

        # Setting the spin control to process the enter key removes
        # its processing of the Tab key. This is desired for two reasons:
        # 1) It is consistent with the Qt version of the control.
        # 2) The default tab processing is kinda wacky in that when
        #    tab is pressed, it emits a text event with the string
        #    representation of the integer value of the control,
        #    regardless of the value of the user supplied string.
        #    This is definitely not correct and so processing on
        #    Enter allows us to avoid the issue entirely.
        self.WindowStyle |= wx.TE_PROCESS_ENTER

        self.Bind(wx.EVT_SPIN_UP, self.OnSpinUp)
        self.Bind(wx.EVT_SPIN_DOWN, self.OnSpinDown)
        self.Bind(wx.EVT_SPINCTRL, self.OnSpinCtrl)
        self.Bind(wx.EVT_TEXT, self.OnText)
        self.Bind(wx.EVT_KILL_FOCUS, self.OnKillFocus)
        self.Bind(wx.EVT_TEXT_ENTER, self.OnEnterPressed)

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def OnEnterPressed(self, event):
        """ The event handler for an enter key press. It forces an
        interpretation of the current text control value.

        """
        self.InterpretText()

    def OnKillFocus(self, event):
        """ Handles evaluating the text in the control when the control
        loses focus.

        """
        # The spin control doesn't emit a spin event when losing focus
        # to process typed input change unless it results in a different
        # value, so we have to handle it manually and update the control
        # again after the event. It must be invoked on a CallAfter or it
        # doesn't work properly. The lambda avoids a DeadObjectError if
        # the app is exited before the callback executes.
        wx.CallAfter(lambda: self.InterpretText() if self else None)

    def OnText(self, event):
        """ Handles the text event of the spin control to store away the
        user typed text for later conversion.

        """
        if self._read_only:
            return
        # Do not be tempted to try to implement the 'tracking' feature
        # by adding logic to this method. Wx emits this event at weird
        # times such as ctrl-a select all as well as when SetValueString
        # is called. Granted, this can be avoided with a recursion guard,
        # however, there is no way to get/set the caret position on the
        # control and every call to SetValueString resets the caret
        # position to Zero. So, there is really no possible way to
        # implement 'tracking' without creating an entirely new custom
        # control. So for now, the wx backend just lacks that feature.
        self._value_string = event.GetString()

    def OnSpinUp(self, event):
        """ The event handler for the spin up event. We veto the spin
        event to prevent the control from changing it's internal value.
        Instead, we maintain complete control of the value.

        """
        event.Veto()
        if self._read_only:
            return
        self._spin_state = 'up'
        self.OnSpinCtrl(event)
        self._spin_state = None

    def OnSpinDown(self, event):
        """ The event handler for the spin down event. We veto the spin
        event to prevent the control from changing it's internal value.
        Instead, we maintain complete control of the value.

        """
        event.Veto()
        if self._read_only:
            return
        self._spin_state = 'down'
        self.OnSpinCtrl(event)
        self._spin_state = None

    def OnSpinCtrl(self, event):
        """ Handles the spin control being changed by user interaction.
        All of the manual stepping and wrapping logic is computed by
        this method.

        """
        if self._read_only:
            return
        last = self._internal_value
        low = self._low
        high = self._high
        step = self._step
        wrap = self._wrap
        spin_state = self._spin_state
        if spin_state == 'down':
            if last == low:
                if wrap:
                    computed = high
                else:
                    computed = low
            else:
                computed = last - step
                if computed < low:
                    computed = low
            self.SetValue(computed)
        elif spin_state == 'up':
            if last == high:
                if wrap:
                    computed = low
                else:
                    computed = high
            else:
                computed = last + step
                if computed > high:
                    computed = high
            self.SetValue(computed)
        else:
            # A suprious spin event generated by wx when the widget loses
            # focus. We can safetly ignore it.
            pass

    #--------------------------------------------------------------------------
    # Getters/Setters
    #--------------------------------------------------------------------------
    def GetLow(self):
        """ Returns the minimum value of the control.

        """
        return self._low

    def GetMin(self):
        """ Equivalent to GetLow().

        """
        return self._low

    def SetLow(self, low):
        """ Sets the minimum value of the control and changes the
        value to the min if the current value would be out of range.

        """
        if low < self._hard_min:
            raise ValueError('%s is too low for wxProperSpinBox.' % low)
        self._low = low
        if self.GetValue() < low:
            self.SetValue(low)

    def GetHigh(self):
        """ Returns the maximum value of the control.

        """
        return self._high

    def GetMax(self):
        """ Equivalent to GetHigh().

        """
        return self._high

    def SetHigh(self, high):
        """ Sets the maximum value of the control and changes the
        value to the max if the current value would be out of range.

        """
        if high > self._hard_max:
            raise ValueError('%s is too high for wxProperSpinBox.' % high)
        self._high = high
        if self.GetValue() > high:
            self.SetValue(high)

    def SetRange(self, low, high):
        """ Sets the low and high values of the control.

        """
        self.SetLow(low)
        self.SetHigh(high)

    def GetStep(self):
        """ Returns the step size of the control.

        """
        return self._step

    def SetStep(self, step):
        """ Sets the step size of the control.

        """
        self._step = step

    def GetWrap(self):
        """ Gets the wrap flag of the control.

        """
        return self._wrap

    def SetWrap(self, wrap):
        """ Sets the wrap flag of the control.

        """
        self._wrap = wrap

    def GetPrefix(self):
        """ Get the prefix text for the control.

        Returns
        -------
        result : unicode
            The unicode prefix text.

        """
        return self._prefix

    def SetPrefix(self, prefix):
        """ Set the prefix text for the control.

        Parameters
        ----------
        prefix : unicode
            The unicode prefix text for the control.

        """
        self._prefix = prefix

    def GetSuffix(self):
        """ Get the suffix text for the control.

        Returns
        -------
        result : unicode
            The unicode suffix text.

        """
        return self._suffix

    def SetSuffix(self, suffix):
        """ Set the suffix text for the control.

        Parameters
        ----------
        suffix : unicode
            The unicode suffix text for the control.

        """
        self._suffix = suffix

    def GetSpecialValueText(self):
        """ Returns the special value text for the spin box.

        Returns
        -------
        result : unicode
            The unicode special value text.

        """
        return self._special_value_text

    def SetSpecialValueText(self, text):
        """ Set the special value text for the control.

        Parameters
        ----------
        text : unicode
            The unicode special value text for the control.

        """
        self._special_value_text = text

    def GetReadOnly(self):
        """ Get the read only flag for the control.

        Returns
        -------
        result : bool
            True if the control is read only, False otherwise.

        """
        return self._suffix

    def SetReadOnly(self, read_only):
        """ Set the read only flag for the control

        Parameters
        ----------
        read_only : bool
            True if the control should be read only, False otherwise.

        """
        self._read_only = read_only

    def GetValue(self):
        """ Returns the internal integer value of the control.

        """
        return self._internal_value

    def SetValue(self, value):
        """ Sets the value of the control to the given value, provided
        that the value is within the range of the control. If the
        given value is within range, and is different from the current
        value of the control, an EVT_SPIN_BOX will be emitted.

        """
        different = False
        if self._low <= value <= self._high:
            different = (self._internal_value != value)
            self._internal_value = value

        # Always set the value string, just to be overly
        # safe that we don't fall out of sync.
        self._value_string = self.TextFromValue(self._internal_value)
        self.SetValueString(self._value_string)

        if different:
            evt = wxSpinBoxEvent()
            wx.PostEvent(self, evt)

    #--------------------------------------------------------------------------
    # Support Methods
    #--------------------------------------------------------------------------
    def InterpretText(self):
        """ Interprets the user supplied text and updates the control.

        """
        prefix = self._prefix
        suffix = self._suffix
        svt = self._special_value_text
        text = self._value_string
        if svt and text == svt:
            self.SetValue(self._low)
            return
        if prefix and text.startswith(prefix):
            text = text[len(prefix):]
        if suffix and text.endswith(suffix):
            text = text[:-len(suffix)]
        try:
            value = int(text)
        except ValueError:
            value = self._internal_value
        self.SetValue(value)

    def TextFromValue(self, value):
        """ Converts the given integer to a string for display.

        """
        prefix = self._prefix
        suffix = self._suffix
        svt = self._special_value_text
        if value == self._low and svt:
            return svt
        text = unicode(value)
        if prefix:
            text = '%s%s' % (prefix, text)
        if suffix:
            text = '%s%s' % (text, suffix)
        return text


#: Cyclic guard flag
VALUE_FLAG = 0x1


class WxSpinBox(WxControl, ProxySpinBox):
    """ A Wx implementation of an Enaml ProxySpinBox.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(wxProperSpinBox)

    #: Cyclic guard flags
    _guard = Int(0)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying wxProperSpinBox widget.

        """
        self.widget = wxProperSpinBox(self.parent_widget())

    def init_widget(self, ):
        """ Create and initialize the slider control.

        """
        super(WxSpinBox, self).init_widget()
        d = self.declaration
        self.set_maximum(d.maximum)
        self.set_minimum(d.minimum)
        self.set_value(d.value)
        self.set_prefix(d.prefix)
        self.set_suffix(d.suffix)
        self.set_special_value_text(d.special_value_text)
        self.set_single_step(d.single_step)
        self.set_read_only(d.read_only)
        self.set_wrapping(d.wrapping)
        self.widget.Bind(EVT_SPIN_BOX, self.on_value_changed)

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_value_changed(self, event):
        """ The event handler for the 'EVT_SPIN_BOX' event.

        """
        if not self._guard & VALUE_FLAG:
            self._guard |= VALUE_FLAG
            try:
                self.declaration.value = self.widget.GetValue()
            finally:
                self._guard &= ~VALUE_FLAG

    #--------------------------------------------------------------------------
    # ProxySpinBox API
    #--------------------------------------------------------------------------
    def set_maximum(self, maximum):
        """ Set the widget's maximum value.

        """
        self.widget.SetHigh(maximum)

    def set_minimum(self, minimum):
        """ Set the widget's minimum value.

        """
        self.widget.SetLow(minimum)

    def set_value(self, value):
        """ Set the spin box's value.

        """
        if not self._guard & VALUE_FLAG:
            self._guard |= VALUE_FLAG
            try:
                self.widget.SetValue(value)
            finally:
                self._guard &= ~VALUE_FLAG


    def set_prefix(self, prefix):
        """ Set the prefix for the spin box.

        """
        self.widget.SetPrefix(prefix)

    def set_suffix(self, suffix):
        """ Set the suffix for the spin box.

        """
        self.widget.SetSuffix(suffix)

    def set_special_value_text(self, text):
        """ Set the special value text for the spin box.

        """
        self.widget.SetSpecialValueText(text)

    def set_single_step(self, step):
        """ Set the widget's single step value.

        """
        self.widget.SetStep(step)

    def set_read_only(self, read_only):
        """ Set the widget's read only flag.

        """
        self.widget.SetReadOnly(read_only)

    def set_wrapping(self, wrapping):
        """ Set the widget's wrapping flag.

        """
        self.widget.SetWrap(wrapping)

########NEW FILE########
__FILENAME__ = wx_splitter
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx
from wx.lib.splitter import MultiSplitterWindow

from atom.api import Typed

from enaml.widgets.splitter import ProxySplitter

from .wx_constraints_widget import WxConstraintsWidget
from .wx_split_item import WxSplitItem


_ORIENTATION_MAP = {
    'horizontal': wx.HORIZONTAL,
    'vertical': wx.VERTICAL,
}


class wxSplitter(MultiSplitterWindow):
    """ A wx.lib.splitter.MultiSplitterWindow subclass that changes
    the behavior of resizing neighbors to be consistent with Qt.

    """
    def _OnMouse(self, event):
        """ Overriden parent class mouse event handler which fakes the
        state of the keyboard so that resize behavior is consistent
        between wx and Qt.

        """
        # We modify the mouse event to "fake" like the shift key is
        # always down. This causes the splitter to not adjust its
        # neighbor when dragging the sash. This behavior is consistent
        # with Qt's behavior. This is not *the best* way to handle this,
        # but it's the easiest and quickest at the moment. The proper
        # way would be to reimplement this method in its entirety and
        # allow the adjustNeighbor computation to be based on keyboard
        # state as well as attribute flags.
        #
        # TODO implement this properly (or just rewrite this entire
        # control, because like everything else in Wx, it's crap).
        event.m_shiftDown = True
        return super(wxSplitter, self)._OnMouse(event)

    def _GetWindowMin(self, window):
        """ Overriden parent class method which properly computes the
        window min size.

        """
        size = window.GetEffectiveMinSize()
        if self._orient == wx.HORIZONTAL:
            res = size.GetWidth()
        else:
            res = size.GetHeight()
        return res

    def _GetSashSize(self):
        """ Overridden parent class method to return a proper sash size
        for the custom sash painting.

        """
        return 4

    def _DrawSash(self, dc):
        """ Overridden parent class method which draws a custom sash.

        On Windows, the default themed sash drawing causes the sash to
        not be visible; this method corrects that problem and draws a
        sash which is visibly similar to Enaml's Qt Windows version.

        """
        sash_size = self._GetSashSize()
        width, height = self.GetClientSize()
        light_pen = wx.WHITE_PEN
        dark_pen = wx.GREY_PEN
        brush = wx.Brush(self.GetBackgroundColour())
        if self._orient == wx.HORIZONTAL:
            pos = 0
            for sash in self._sashes[:-1]:
                pos += sash
                dc.SetPen(wx.TRANSPARENT_PEN)
                dc.SetBrush(brush)
                dc.DrawRectangle(pos, 0, sash_size, height)
                dc.SetPen(light_pen)
                dc.DrawLine(pos + 1, 0, pos + 1, height)
                dc.SetPen(dark_pen)
                dc.DrawLine(pos + 2, 0, pos + 2, height)
                pos += sash_size
        else:
            pos = 0
            for sash in self._sashes[:-1]:
                pos += sash
                dc.SetPen(wx.TRANSPARENT_PEN)
                dc.SetBrush(brush)
                dc.DrawRectangle(0, pos, width, sash_size)
                dc.SetPen(light_pen)
                dc.DrawLine(0, pos + 1, width, pos + 1)
                dc.SetPen(dark_pen)
                dc.DrawLine(0, pos + 2, width, pos + 2)
                pos += sash_size

    def _OnSize(self, event):
        """ Overridden parent class method which resizes the sashes.

        The default Wx behavior allocates all extra space to the last
        split item, and it will clip the items when the window size is
        reduced. This override uses a weighted algorithm to allocate
        the free space among the items and will not allow the items
        to be clipped by a window resize.

        """
        # Pre-fetch some commonly used objects
        get_min = self._GetWindowMin
        windows = self._windows
        sashes = self._sashes

        # Compute the total space available for the sashes
        sash_widths = self._GetSashSize() * (len(windows) - 1)
        offset = sash_widths + 2 * self._GetBorderSize()
        if self._orient == wx.HORIZONTAL:
            free_space = self.GetClientSize().GetWidth() - offset
        else:
            free_space = self.GetClientSize().GetHeight() - offset

        # Compute the effective stretch factors for each window. The
        # effective stretch factor is the greater of the current or
        # minimum width of the window, multiplied by the window's
        # stretch factor.
        parts = []
        total_stretch = 0
        for idx, (sash, window) in enumerate(zip(sashes, windows)):
            minw = get_min(window)
            if sash < minw:
                sash = sashes[idx] = minw
            stretch = window.GetStretch() * sash
            parts.append((stretch, idx, minw, window))
            total_stretch += stretch

        # Add (or remove) the extra space by fairly allocating it to
        # each window based on their effective stretch factor.
        diff_space = free_space - sum(sashes)
        for stretch, idx, minw, window in parts:
            if stretch > 0:
                d = diff_space * stretch / total_stretch
                new = max(sashes[idx] + d, minw)
                sashes[idx] = new

        # Since the windows are clipped to their minimum width, it's
        # possible that the current space occupied by the windows will
        # be too large. In that case, the overage is distributed to the
        # windows fairly, based on their relative capacity for shrink.
        curr_space = sum(sashes)
        if curr_space > free_space:
            diffs = []
            total_diff = 0
            for stretch, idx, minw, window in parts:
                diff = sashes[idx] - minw
                if diff > 0:
                    diffs.append((diff, window, idx, minw))
                    total_diff += diff
            remaining = curr_space - free_space
            diffs.sort()
            for diff, window, idx, minw in reversed(diffs):
                delta = remaining * diff / total_diff
                old = sashes[idx]
                new = max(old - delta, minw)
                actual_diff = old - new
                remaining -= actual_diff
                total_diff -= actual_diff
                sashes[idx] = new

        # The superclass handler which will actually perform the layout.
        super(wxSplitter, self)._OnSize(event)


class WxSplitter(WxConstraintsWidget, ProxySplitter):
    """ A Wx implementation of an Enaml ProxySplitter.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(wxSplitter)

    #--------------------------------------------------------------------------
    # Setup methods
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Creates the underlying wxSplitter widget.

        """
        self.widget = wxSplitter(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying control.

        """
        super(WxSplitter, self).init_widget()
        d = self.declaration
        self.set_orientation(d.orientation)
        self.set_live_drag(d.live_drag)

    def init_layout(self):
        """ Handle the layout initialization for the splitter.

        """
        super(WxSplitter, self).init_layout()
        widget = self.widget
        for item in self.split_items():
            widget.AppendWindow(item)

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a WxSplitter.

        """
        super(WxSplitter, self).child_added(child)
        if isinstance(child, WxSplitItem):
            for index, dchild in enumerate(self.children()):
                if child is dchild:
                    self.widget.InsertWindow(index, child.widget)
                    self.geometry_updated()

    def child_removed(self, child):
        """ Handle the child removed event for a WxSplitter.

        """
        super(WxSplitter, self).child_removed(child)
        if isinstance(child, WxSplitItem):
            widget = child.widget
            self.widget.DetachWindow(widget)
            widget.Hide()
            self.geometry_updated()

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def split_items(self):
        """ Get the split items defined for the widget.

        """
        for d in self.declaration.split_items():
            yield d.proxy.widget or None

    #--------------------------------------------------------------------------
    # ProxySplitter API
    #--------------------------------------------------------------------------
    def set_orientation(self, orientation):
        """ Update the orientation of the splitter.

        """
        wx_orientation = _ORIENTATION_MAP[orientation]
        widget = self.widget
        with self.geometry_guard():
            widget.SetOrientation(wx_orientation)
            widget.SizeWindows()

    def set_live_drag(self, live_drag):
        """ Updates the drag state of the splitter.

        """
        if live_drag:
            self.widget.WindowStyle |= wx.SP_LIVE_UPDATE
        else:
            self.widget.WindowStyle &= ~wx.SP_LIVE_UPDATE

########NEW FILE########
__FILENAME__ = wx_split_item
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx

from atom.api import Typed

from enaml.widgets.split_item import ProxySplitItem

from .wx_single_widget_sizer import wxSingleWidgetSizer
from .wx_container import WxContainer
from .wx_widget import WxWidget


class wxSplitItem(wx.Panel):
    """ A wxPanel subclass which acts as an item in a wxSplitter.

    """
    def __init__(self, parent):
        """ Initialize a wxSplitItem.

        Parameters
        ----------
        parent : wx.Window
            The parent widget of the split item.

        """
        super(wxSplitItem, self).__init__(parent)
        self._split_widget = None
        self._stretch = 0
        self.SetSizer(wxSingleWidgetSizer())

    def GetSplitWidget(self):
        """ Get the split widget for this split item.

        Returns
        -------
        result : wxWindow or None
            The split widget being managed by this item.

        """
        return self._split_widget

    def SetSplitWidget(self, widget):
        """ Set the split widget for this split item.

        Parameters
        ----------
        widget : wxWindow
            The wxWindow to use as the split widget in this item.

        """
        self._split_widget = widget
        self.GetSizer().Add(widget)

    def GetStretch(self):
        """ Get the stretch factor for the widget.

        Returns
        -------
        result : int
            The stretch factor for the widget.

        """
        return self._stretch

    def SetStretch(self, stretch):
        """ Set the stretch factor for the widget.

        Parameters
        ----------
        stretch : int
            The stretch factor for the widget.

        """
        self._stretch = stretch


class WxSplitItem(WxWidget, ProxySplitItem):
    """ A Wx implementation of an Enaml ProxySplitItem.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(wxSplitItem)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the underlying QStackItem widget.

        """
        self.widget = wxSplitItem(self.parent_widget())

    def init_widget(self):
        """ Initialize the underyling widget.

        """
        super(WxSplitItem, self).init_widget()
        d = self.declaration
        self.set_stretch(d.stretch)
        self.set_collapsible(d.collapsible)

    def init_layout(self):
        """ Initialize the layout for the underyling widget.

        """
        super(WxSplitItem, self).init_layout()
        self.widget.SetSplitWidget(self.split_widget())

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def split_widget(self):
        """ Find and return the split widget child for this widget.

        Returns
        -------
        result : wxWindow or None
            The split widget defined for this widget, or None if one is
            not defined.

        """
        d = self.declaration.split_widget()
        if d is not None:
            return d.proxy.widget or None

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_added(self, child):
        """ Handle the child added event for a WxSplitItem.

        """
        super(WxSplitItem, self).child_added(child)
        if isinstance(child, WxContainer):
            self.widget.SetSplitWidget(self.split_widget())

    def child_removed(self, child):
        """ Handle the child removed event for a WxSplitItem.

        """
        super(WxSplitItem, self).child_removed(child)
        if isinstance(child, WxContainer):
            self.widget.SetSplitWidget(self.split_widget())

    #--------------------------------------------------------------------------
    # ProxySplitItem API
    #--------------------------------------------------------------------------
    def set_stretch(self, stretch):
        """ Set the stretch factor for the underlying widget.

        """
        self.widget.SetStretch(stretch)

    def set_collapsible(self, collapsible):
        """ Set the collapsible flag for the underlying widget.

        This is not supported on wx.

        """
        pass

########NEW FILE########
__FILENAME__ = wx_toolkit_object
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx

from atom.api import Typed

from enaml.widgets.toolkit_object import ProxyToolkitObject


class WxToolkitObject(ProxyToolkitObject):
    """ A Wx implementation of an Enaml ProxyToolkitObject.

    """
    #: A reference to the toolkit widget created by the proxy.
    widget = Typed(wx.Object)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the toolkit widget for the proxy object.

        This method is called during the top-down pass, just before the
        'init_widget()' method is called. This method should create the
        toolkit widget and assign it to the 'widget' attribute.

        """
        self.widget = wx.Object()

    def init_widget(self):
        """ Initialize the state of the toolkit widget.

        This method is called during the top-down pass, just after the
        'create_widget()' method is called. This method should init the
        state of the widget. The child widgets will not yet be created.

        """
        pass

    def init_layout(self):
        """ Initialize the layout of the toolkit widget.

        This method is called during the bottom-up pass. This method
        should initialize the layout of the widget. The child widgets
        will be fully initialized and layed out when this is called.

        """
        pass

    #--------------------------------------------------------------------------
    # ProxyToolkitObject API
    #--------------------------------------------------------------------------
    def activate_top_down(self):
        """ Activate the proxy tree for the top-down pass.

        """
        self.create_widget()
        self.init_widget()

    def activate_bottom_up(self):
        """ Activate the proxy tree for the bottom-up pass.

        """
        self.init_layout()

    def destroy(self):
        """ A reimplemented destructor.

        This destructor will drop the reference to the toolkit widget.

        """
        if self.widget:
            try:
                self.widget.Destroy()
            except AttributeError:
                pass
            del self.widget
        super(WxToolkitObject, self).destroy()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def parent_widget(self):
        """ Get the parent toolkit widget for this object.

        Returns
        -------
        result : wxObject or None
            The toolkit widget declared on the declaration parent, or
            None if there is no such parent.

        """
        parent = self.parent()
        if parent is not None:
            if parent.widget:
                return parent.widget

    def child_widgets(self):
        """ Get the child toolkit widgets for this object.

        Returns
        -------
        result : iterable of wxObject
            The child widgets defined for this object.

        """
        for child in self.children():
            if child.widget:
                yield child.widget

########NEW FILE########
__FILENAME__ = wx_tool_bar
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx

from atom.api import Typed

from enaml.widgets.tool_bar import ProxyToolBar

from .wx_action import WxAction, EVT_ACTION_CHANGED
from .wx_action_group import WxActionGroup
from .wx_constraints_widget import WxConstraintsWidget


#: A mapping from Enaml orientation to wx Orientation
_ORIENTATION_MAP = {
    'horizontal': wx.HORIZONTAL,
    'vertical': wx.VERTICAL,
}


class wxToolBar(wx.ToolBar):
    """ A wx.ToolBar subclass which handles wxAction instances.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxToolBar.

        Parameters
        ----------
        *args, **kwargs
            The position and keyword arguments needed to initialize
            an AuiToolBar.

        """
        super(wxToolBar, self).__init__(*args, **kwargs)
        self._all_items = []
        self._actions_map = {}

    #--------------------------------------------------------------------------
    # Private API
    #--------------------------------------------------------------------------
    def _InsertAction(self, index, action):
        """ Insert a new tool into the tool bar for the given action.

        Parameters
        ----------
        action : wxAction
            The wxAction instance to add to the tool bar.

        Returns
        -------
        result : wxToolBarToolBase
            The tool base item created when adding the control to the
            tool bar.

        """
        if action.IsSeparator():
            item = self.InsertSeparator(index)
        else:
            text = action.GetText()
            short_help = action.GetToolTip()
            long_help = action.GetStatusTip()
            action_id = action.GetId()
            bmp = wx.EmptyBitmap(0, 0)
            if action.IsCheckable():
                item = self.InsertLabelTool(
                    index, action_id, text, bmp, kind=wx.ITEM_CHECK,
                    shortHelp=short_help, longHelp=long_help,
                )
                if action.IsChecked() != item.IsToggled():
                    item.Toggle()
            else:
                item = self.InsertLabelTool(
                    index, action_id, text, bmp, kind=wx.ITEM_NORMAL,
                    shortHelp=short_help, longHelp=long_help,
                )
            item.Enable(action.IsEnabled())
        return item

    def OnActionChanged(self, event):
        """ The event handler for the EVT_ACTION_CHANGED event.

        This handler will be called when a child action changes. It
        ensures that the new state of the child action is in sync with
        the associated tool bar item.

        """
        event.Skip()
        action = event.GetEventObject()
        item = self._actions_map.get(action)

        # Handle a visibility change. The tool must be added/removed.
        visible = action.IsVisible()
        if visible != bool(item):
            if visible:
                index = self._all_items.index(action)
                index = min(index, len(self._actions_map))
                new_item = self._InsertAction(index, action)
                self._actions_map[action] = new_item
                self.Realize()
            else:
                self.DeleteTool(item.GetId())
                del self._actions_map[action]
            return

        # If the item is invisible, there is nothing to update.
        if not item:
            return

        # Handle a separator change. The existing tool must be replaced.
        if action.IsSeparator() != item.IsSeparator():
            self.DeleteTool(item.GetId())
            del self._actions_map[action]
            index = self._all_items.index(action)
            index = min(index, len(self._actions_map))
            new_item = self._InsertAction(index, action)
            self._actions_map[action] = new_item
            self.Realize()
            return

        # Handle a checkable change. The existing too must be replaced.
        if action.IsCheckable() != item.CanBeToggled():
            self.DeleteTool(item.GetId())
            del self._actions_map[action]
            index = self._all_items.index(action)
            index = min(index, len(self._actions_map))
            new_item = self._InsertAction(index, action)
            self._actions_map[action] = new_item
            self.Realize()
            return

        # All other state can be updated in-place.
        item.SetLabel(action.GetText())
        item.SetShortHelp(action.GetToolTip())
        item.SetLongHelp(action.GetStatusTip())
        if action.IsCheckable():
            if action.IsChecked() != item.IsToggled():
                item.Toggle()
        item.Enable(action.IsEnabled())
        self.Realize()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def AddAction(self, action, realize=True):
        """ Add an action to the tool bar.

        If the action already exists in the toolbar, it will be moved
        to the end.

        Parameters
        ----------
        action : wxAction
            The wxAction instance to add to the tool bar.

        realize : bool, optional
            Whether the toolbar should realize the change immediately.
            If False, Realize() will need to be called manually once
            all desired changes have been made. The default is True.

        """
        self.InsertAction(None, action, realize)

    def AddActions(self, actions, realize=True):
        """ Add multiple wx actions to the tool bar.

        If an action already exists in the tool bar, it will be moved
        to the end.

        Parameters
        ----------
        actions : iterable
            An iterable of wxAction instances to add to the tool bar.

        realize : bool, optional
            Whether the toolbar should realize the change immediately.
            If False, Realize() will need to be called manually once
            all desired changes have been made. The default is True.

        """
        insert = self.InsertAction
        for action in actions:
            insert(None, action, False)
        if realize:
            self.Realize()

    def InsertAction(self, before, action, realize=True):
        """ Insert a wx action into the tool bar.

        If the action already exists in the tool bar, it will be moved
        to the proper location.

        Parameters
        ----------
        before : wxAction or None
            The action in the tool bar which should come directly after
            the new action.

        action : wxAction
            The wxAction instance to insert into this tool bar.

        realize : bool, optional
            Whether the toolbar should realize the change immediately.
            If False, Realize() will need to be called manually once
            all desired changes have been made. The default is True.

        """
        all_items = self._all_items
        if action not in all_items:
            if before in all_items:
                index = all_items.index(before)
            else:
                index = len(all_items)
            all_items.insert(index, action)
            if action.IsVisible():
                max_index = len(self._actions_map)
                index = min(index, max_index)
                item = self._InsertAction(index, action)
                self._actions_map[action] = item
            action.Bind(EVT_ACTION_CHANGED, self.OnActionChanged)
            if realize:
                self.Realize()
        else:
            # XXX this is a potentially slow way to do things if the
            # number of actions being moved around is large. But, the
            # Wx apis don't appear to offer a better way, so this is
            # what we get (as usual...).
            self.RemoveAction(action)
            self.InsertAction(before, action, realize)

    def InsertActions(self, before, actions, realize=True):
        """ Insert multiple wx actions into the Menu.

        If an action already exists in this menu, it will be moved to
        the proper location.

        Parameters
        ----------
        before : wxAction, wxMenu, or None
            The item in the menu which should come directly after the
            new actions.

        actions : iterable
            An iterable of wxAction instances to add to the tool bar.

        realize : bool, optional
            Whether the toolbar should realize the change immediately.
            If False, Realize() will need to be called manually once
            all desired changes have been made. The default is True.

        """
        insert = self.InsertAction
        for action in actions:
            insert(before, action, False)
        if realize:
            self.Realize()

    def RemoveAction(self, action):
        """ Remove a wx action from the tool bar.

        If the action does not exist in the tool bar, this is a no-op.

        Parameters
        ----------
        action : wxAction
            The wxAction instance to remove from this tool bar.

        """
        all_items = self._all_items
        if action in all_items:
            all_items.remove(action)
            action.Unbind(EVT_ACTION_CHANGED, handler=self.OnActionChanged)
            item = self._actions_map.pop(action, None)
            if item is not None:
                self.DeleteTool(item.GetId())

    def RemoveActions(self, actions):
        """ Remove multiple actions from the tool bar.

        If an action does not exist in the tool bar, it will be ignored.

        Parameters
        ----------
        actions : iterable
            An iterable of wxActions to remove from the tool bar.

        """
        remove = self.RemoveAction
        for action in actions:
            remove(action)


class WxToolBar(WxConstraintsWidget, ProxyToolBar):
    """ A Wx implementation of an Enaml ToolBar.

    """
    #: A reference to the widget created by the proxy.
    widget = Typed(wxToolBar)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Create the QCustomToolBar widget.

        """
        # The orientation of a tool bar can only be set at creation time.
        # Wx does not support changing it dynamically. It is only set if
        # the tool bar is a child of something other than a wx.Frame.
        # The style must include TB_FLAT or separators won't be drawn.
        d = self.declaration
        parent = self.parent_widget()
        style =  wx.TB_FLAT | wx.TB_TEXT | wx.NO_BORDER
        if not isinstance(parent, wx.Frame):
            style |= _ORIENTATION_MAP[d.orientation]
        else:
            style |= wx.HORIZONTAL

        self.widget = wxToolBar(parent, style=style)

        # Setting the tool bar to double buffered avoids a ton of
        # flickering on Windows during resize events.
        self.widget.SetDoubleBuffered(True)

        # For now, we set the bitmap size to 0 since we don't yet
        # support icons or images.
        self.widget.SetToolBitmapSize(wx.Size(0, 0))

    def init_layout(self):
        """ Initialize the layout for the toolbar.

        """
        super(WxToolBar, self).init_layout()
        widget = self.widget
        for child in self.children():
            if isinstance(child, WxAction):
                widget.AddAction(child.widget, False)
            elif isinstance(child, WxActionGroup):
                widget.AddActions(child.actions(), False)
        widget.Realize()

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def find_next_action(self, child):
        """ Locate the wxAction object which logically follows the child.

        Parameters
        ----------
        child : WxToolkitObject
            The child object of interest.

        Returns
        -------
        result : wxAction or None
            The wxAction which logically follows the position of the
            child in the list of children. None will be returned if
            a relevant wxAction is not found.

        """
        found = False
        for dchild in self.children():
            if found:
                if isinstance(dchild, WxAction):
                    return dchild.widget
                if isinstance(dchild, WxActionGroup):
                    acts = dchild.actions()
                    if len(acts) > 0:
                        return acts[0]
            else:
                found = dchild is child

    def child_added(self, child):
        """ Handle the child added event for a WxToolBar.

        """
        super(WxToolBar, self).child_added(child)
        if isinstance(child, WxAction):
            before = self.find_next_action(child)
            self.widget.InsertAction(before, child.widget)
        elif isinstance(child, WxActionGroup):
            before = self.find_next_action(child)
            self.widget.InsertActions(before, child.actions())

    def child_removed(self, child):
        """  Handle the child removed event for a WxToolBar.

        """
        super(WxToolBar, self).child_removed(child)
        if isinstance(child, WxAction):
            if child.widget is not None:
                self.widget.RemoveAction(child.widget)
        elif isinstance(child, WxActionGroup):
            self.widget.RemoveActions(child.actions())

    #--------------------------------------------------------------------------
    # ProxyToolBar API
    #--------------------------------------------------------------------------
    def set_visible(self, visible):
        """ Overridden parent class visibility setter which properly
        handles the visibility of the tool bar.

        """
        # XXX implement me!
        pass

    def set_button_style(self, style):
        """ This is not supported on wx.

        """
        pass

    def set_orientation(self, orientation):
        """ Set the orientation of the underlying widget.

        """
        # Wx does not support dynamically changing the orientation.
        pass

    def set_movable(self, movable):
        """ Set the movable state on the underlying widget.

        """
        # The standard wx toolbar doesn't support docking. The Aui
        # toolbar sucks, don't use it.
        pass

    def set_floatable(self, floatable):
        """ Set the floatable state on the underlying widget.

        """
        # The standard wx toolbar doesn't support docking. The Aui
        # toolbar sucks, don't use it.
        pass

    def set_floating(self, floating):
        """ Set the floating staet on the underlying widget.

        """
        # The standard wx toolbar doesn't support docking. The Aui
        # toolbar sucks, don't use it.
        pass

    def set_dock_area(self, dock_area):
        """ Set the dock area on the underyling widget.

        """
        # The standard wx toolbar doesn't support docking. The Aui
        # toolbar sucks, don't use it.
        pass

    def set_allowed_dock_areas(self, dock_areas):
        """ Set the allowed dock areas on the underlying widget.

        """
        # The standard wx toolbar doesn't support docking. The Aui
        # toolbar sucks, don't use it.
        pass

########NEW FILE########
__FILENAME__ = auibar
"""
`auibar.py` contains an implementation of :class:`AuiToolBar`, which is a completely owner-drawn
toolbar perfectly integrated with the AUI layout system. This allows drag and drop of
toolbars, docking/floating behaviour and the possibility to define "overflow" items
in the toolbar itself.

The default theme that is used is :class:`AuiToolBar`, which provides a modern,
glossy look and feel. The theme can be changed by calling :meth:`AuiToolBar.SetArtProvider`.
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx
import types

from aui_utilities import BitmapFromBits, StepColour, GetLabelSize
from aui_utilities import GetBaseColour, MakeDisabledBitmap

import framemanager
from aui_constants import *

# wxPython version string
_VERSION_STRING = wx.VERSION_STRING

# AuiToolBar events
wxEVT_COMMAND_AUITOOLBAR_TOOL_DROPDOWN = wx.NewEventType()
wxEVT_COMMAND_AUITOOLBAR_OVERFLOW_CLICK = wx.NewEventType()
wxEVT_COMMAND_AUITOOLBAR_RIGHT_CLICK = wx.NewEventType()
wxEVT_COMMAND_AUITOOLBAR_MIDDLE_CLICK = wx.NewEventType()
wxEVT_COMMAND_AUITOOLBAR_BEGIN_DRAG = wx.NewEventType()

EVT_AUITOOLBAR_TOOL_DROPDOWN = wx.PyEventBinder(wxEVT_COMMAND_AUITOOLBAR_TOOL_DROPDOWN, 1)
""" A dropdown `AuiToolBarItem` is being shown. """
EVT_AUITOOLBAR_OVERFLOW_CLICK = wx.PyEventBinder(wxEVT_COMMAND_AUITOOLBAR_OVERFLOW_CLICK, 1)
""" The user left-clicked on the overflow button in `AuiToolBar`. """
EVT_AUITOOLBAR_RIGHT_CLICK = wx.PyEventBinder(wxEVT_COMMAND_AUITOOLBAR_RIGHT_CLICK, 1)
""" Fires an event when the user right-clicks on a `AuiToolBarItem`. """
EVT_AUITOOLBAR_MIDDLE_CLICK = wx.PyEventBinder(wxEVT_COMMAND_AUITOOLBAR_MIDDLE_CLICK, 1)
""" Fires an event when the user middle-clicks on a `AuiToolBarItem`. """
EVT_AUITOOLBAR_BEGIN_DRAG = wx.PyEventBinder(wxEVT_COMMAND_AUITOOLBAR_BEGIN_DRAG, 1)
""" A drag operation involving a toolbar item has started. """

# ----------------------------------------------------------------------

class CommandToolBarEvent(wx.PyCommandEvent):
    """ A specialized command event class for events sent by :class:`AuiToolBar`. """
    
    def __init__(self, command_type, win_id):
        """
        Default class constructor.

        :param `command_type`: the event kind or an instance of :class:`PyCommandEvent`.
        :param integer `win_id`: the window identification number.
        """
        
        if type(command_type) == types.IntType:    
            wx.PyCommandEvent.__init__(self, command_type, win_id)
        else:
            wx.PyCommandEvent.__init__(self, command_type.GetEventType(), command_type.GetId())
            
        self.is_dropdown_clicked = False
        self.click_pt = wx.Point(-1, -1)
        self.rect = wx.Rect(-1, -1, 0, 0)
        self.tool_id = -1


    def IsDropDownClicked(self):
        """ Returns whether the drop down menu has been clicked. """

        return self.is_dropdown_clicked
    

    def SetDropDownClicked(self, c):
        """
        Sets whether the drop down menu has been clicked.

        :param bool `c`: ``True`` to set the drop down as clicked, ``False`` otherwise.
        """

        self.is_dropdown_clicked = c    


    def GetClickPoint(self):
        """ Returns the point where the user clicked with the mouse. """

        return self.click_pt

    
    def SetClickPoint(self, p):
        """
        Sets the clicking point.

        :param Point `p`: the location of the mouse click.
        """
        
        self.click_pt = p    


    def GetItemRect(self):
        """ Returns the :class:`AuiToolBarItem` rectangle. """

        return self.rect

    
    def SetItemRect(self, r):
        """
        Sets the :class:`AuiToolBarItem` rectangle.

        :param Rect `r`: the toolbar item rectangle.
        """

        self.rect = r    


    def GetToolId(self):
        """ Returns the :class:`AuiToolBarItem` identifier. """

        return self.tool_id

    
    def SetToolId(self, id):
        """
        Sets the :class:`AuiToolBarItem` identifier.

        :param integer `id`: the toolbar item identifier.
        """

        self.tool_id = id   


# ----------------------------------------------------------------------

class AuiToolBarEvent(CommandToolBarEvent):
    """ A specialized command event class for events sent by :class:`AuiToolBar`. """
    
    def __init__(self, command_type=None, win_id=0):
        """
        Default class constructor.

        :param `command_type`: the event kind or an instance of :class:`PyCommandEvent`.
        :param integer `win_id`: the window identification number.
        """

        CommandToolBarEvent.__init__(self, command_type, win_id)

        if type(command_type) == types.IntType:
            self.notify = wx.NotifyEvent(command_type, win_id)
        else:
            self.notify = wx.NotifyEvent(command_type.GetEventType(), command_type.GetId())

        
    def GetNotifyEvent(self):
        """ Returns the actual :class:`NotifyEvent`. """
        
        return self.notify


    def IsAllowed(self):
        """ Returns whether the event is allowed or not. """

        return self.notify.IsAllowed()


    def Veto(self):
        """
        Prevents the change announced by this event from happening.

        It is in general a good idea to notify the user about the reasons for
        vetoing the change because otherwise the applications behaviour (which
        just refuses to do what the user wants) might be quite surprising.
        """

        self.notify.Veto()


    def Allow(self):
        """
        This is the opposite of :meth:`Veto`: it explicitly allows the event to be
        processed. For most events it is not necessary to call this method as the
        events are allowed anyhow but some are forbidden by default (this will
        be mentioned in the corresponding event description).
        """

        self.notify.Allow()


# ----------------------------------------------------------------------

class ToolbarCommandCapture(wx.PyEvtHandler):
    """ A class to handle the dropdown window menu. """
    
    def __init__(self):
        """ Default class constructor. """
        
        wx.PyEvtHandler.__init__(self)
        self._last_id = 0


    def GetCommandId(self):
        """ Returns the event command identifier. """
        
        return self._last_id 


    def ProcessEvent(self, event):
        """
        Processes an event, searching event tables and calling zero or more suitable
        event handler function(s).

        :param `event`: the event to process.

        :note: Normally, your application would not call this function: it is called
         in the wxPython implementation to dispatch incoming user interface events
         to the framework (and application).
         However, you might need to call it if implementing new functionality (such as
         a new control) where you define new event types, as opposed to allowing the
         user to override functions.

         An instance where you might actually override the :meth:`ProcessEvent` function is where
         you want to direct event processing to event handlers not normally noticed by
         wxPython. For example, in the document/view architecture, documents and views
         are potential event handlers. When an event reaches a frame, :meth:`ProcessEvent` will
         need to be called on the associated document and view in case event handler
         functions are associated with these objects. 

         The normal order of event table searching is as follows:

         1. If the object is disabled (via a call to :meth:`~EvtHandler.SetEvtHandlerEnabled`) the function
            skips to step (6).
         2. If the object is a :class:`Window`, :meth:`ProcessEvent` is recursively called on the window's 
            :class:`Validator`. If this returns ``True``, the function exits.
         3. wxWidgets `SearchEventTable` is called for this event handler. If this fails, the
            base class table is tried, and so on until no more tables exist or an appropriate
            function was found, in which case the function exits.
         4. The search is applied down the entire chain of event handlers (usually the chain
            has a length of one). If this succeeds, the function exits.
         5. If the object is a :class:`Window` and the event is a :class:`CommandEvent`, :meth:`ProcessEvent` is
            recursively applied to the parent window's event handler. If this returns ``True``,
            the function exits.
         6. Finally, :meth:`ProcessEvent` is called on the :class:`App` object.
        """
        
        if event.GetEventType() == wx.wxEVT_COMMAND_MENU_SELECTED:
            self._last_id = event.GetId()
            return True
        
        if self.GetNextHandler():
            return self.GetNextHandler().ProcessEvent(event)

        return False


# ----------------------------------------------------------------------

class AuiToolBarItem(object):
    """
    AuiToolBarItem is a toolbar element.
    
    It has a unique id (except for the separators which always have id = -1), the
    style (telling whether it is a normal button, separator or a control), the
    state (toggled or not, enabled or not) and short and long help strings. The
    default implementations use the short help string for the tooltip text which
    is popped up when the mouse pointer enters the tool and the long help string
    for the applications status bar.
    """

    def __init__(self, item=None):
        """
        Default class constructor.

        :param `item`: another instance of :class:`AuiToolBarItem`.
        """

        if item:
            self.Assign(item)
            return
        
        self.window = None
        self.clockwisebmp = wx.NullBitmap
        self.counterclockwisebmp = wx.NullBitmap
        self.clockwisedisbmp = wx.NullBitmap
        self.counterclockwisedisbmp = wx.NullBitmap
        self.sizer_item = None
        self.spacer_pixels = 0
        self.id = 0
        self.kind = ITEM_NORMAL
        self.state = 0   # normal, enabled
        self.proportion = 0
        self.active = True
        self.dropdown = True
        self.sticky = True
        self.user_data = 0

        self.label = ""
        self.bitmap = wx.NullBitmap
        self.disabled_bitmap = wx.NullBitmap
        self.hover_bitmap = wx.NullBitmap
        self.short_help = ""
        self.long_help = ""
        self.target = None
        self.min_size = wx.Size(-1, -1)
        self.alignment = wx.ALIGN_CENTER
        self.orientation = AUI_TBTOOL_HORIZONTAL
        

    def Assign(self, c):
        """
        Assigns the properties of the :class:`AuiToolBarItem` `c` to `self`.

        :param `c`: another instance of :class:`AuiToolBarItem`.
        """

        self.window = c.window
        self.label = c.label
        self.bitmap = c.bitmap
        self.disabled_bitmap = c.disabled_bitmap
        self.hover_bitmap = c.hover_bitmap
        self.short_help = c.short_help
        self.long_help = c.long_help
        self.sizer_item = c.sizer_item
        self.min_size = c.min_size
        self.spacer_pixels = c.spacer_pixels
        self.id = c.id
        self.kind = c.kind
        self.state = c.state
        self.proportion = c.proportion
        self.active = c.active
        self.dropdown = c.dropdown
        self.sticky = c.sticky
        self.user_data = c.user_data
        self.alignment = c.alignment
        self.orientation = c.orientation
        self.target = c.target


    def SetWindow(self, w):
        """
        Assigns a window to the toolbar item.

        :param Window `w`: associate this window `w` to the :class:`AuiToolBarItem`.
        """

        self.window = w

        
    def GetWindow(self):
        """ Returns window associated to the toolbar item. """

        return self.window        


    def SetId(self, new_id):
        """
        Sets the toolbar item identifier.

        :param integer `new_id`: the new tool id.
        """

        self.id = new_id

        
    def GetId(self):
        """ Returns the toolbar item identifier. """

        return self.id 


    def SetKind(self, new_kind):
        """
        Sets the :class:`AuiToolBarItem` kind.

        :param integer `new_kind`: can be one of the following items:

         ========================  =============================
         Item Kind                 Description
         ========================  =============================
         ``ITEM_CONTROL``          The item in the :class:`AuiToolBar` is a control
         ``ITEM_LABEL``            The item in the :class:`AuiToolBar` is a text label
         ``ITEM_SPACER``           The item in the :class:`AuiToolBar` is a spacer
         ``ITEM_SEPARATOR``        The item in the :class:`AuiToolBar` is a separator
         ``ITEM_CHECK``            The item in the :class:`AuiToolBar` is a toolbar check item
         ``ITEM_NORMAL``           The item in the :class:`AuiToolBar` is a standard toolbar item
         ``ITEM_RADIO``            The item in the :class:`AuiToolBar` is a toolbar radio item
         ========================  =============================
        """

        self.kind = new_kind


    def GetKind(self):
        """
        Returns the toolbar item kind.

        See :meth:`SetKind` for more details.
        """

        return self.kind
        

    def SetState(self, new_state):
        """
        Sets the toolbar item state.

        :param `new_state`: can be one of the following states:

         ============================================  ======================================
         Button State Constant                         Description     
         ============================================  ======================================
         ``AUI_BUTTON_STATE_NORMAL``                   Normal button state
         ``AUI_BUTTON_STATE_HOVER``                    Hovered button state
         ``AUI_BUTTON_STATE_PRESSED``                  Pressed button state
         ``AUI_BUTTON_STATE_DISABLED``                 Disabled button state
         ``AUI_BUTTON_STATE_HIDDEN``                   Hidden button state
         ``AUI_BUTTON_STATE_CHECKED``                  Checked button state
         ============================================  ======================================
    
        """

        self.state = new_state

        
    def GetState(self):
        """
        Returns the toolbar item state.

        :see: :meth:`SetState` for more details.
        """
        
        return self.state 


    def SetSizerItem(self, s):
        """
        Associates a sizer item to this toolbar item.

        :param `s`: an instance of :class:`SizerItem`.
        """

        self.sizer_item = s

        
    def GetSizerItem(self):
        """ Returns the associated sizer item. """

        return self.sizer_item 


    def SetLabel(self, s):
        """
        Sets the toolbar item label.

        :param string `s`: the toolbar item label.
        """

        self.label = s

        
    def GetLabel(self):
        """ Returns the toolbar item label. """

        return self.label 


    def SetBitmap(self, bmp):
        """
        Sets the toolbar item bitmap.

        :param Bitmap `bmp`: the image associated with this :class:`AuiToolBarItem`.
        """
        
        self.bitmap = bmp

        
    def GetBitmap(self):
        """ Returns the toolbar item bitmap. """

        return self.GetRotatedBitmap(False)


    def SetDisabledBitmap(self, bmp):
        """
        Sets the toolbar item disabled bitmap.

        :param Bitmap `bmp`: the disabled image associated with this :class:`AuiToolBarItem`.
        """
        
        self.disabled_bitmap = bmp

        
    def GetDisabledBitmap(self):
        """ Returns the toolbar item disabled bitmap. """
        
        return self.GetRotatedBitmap(True)


    def SetHoverBitmap(self, bmp):
        """
        Sets the toolbar item hover bitmap.

        :param Bitmap `bmp`: the hover image associated with this :class:`AuiToolBarItem`.
        """
        
        self.hover_bitmap = bmp


    def SetOrientation(self, a):
        """
        Sets the toolbar tool orientation.

        :param integer `a`: one of ``AUI_TBTOOL_HORIZONTAL``, ``AUI_TBTOOL_VERT_CLOCKWISE`` or
         ``AUI_TBTOOL_VERT_COUNTERCLOCKWISE``.
        """

        self.orientation = a


    def GetOrientation(self):
        """ Returns the toolbar tool orientation. """

        return self.orientation
    
        
    def GetHoverBitmap(self):
        """ Returns the toolbar item hover bitmap. """
        
        return self.hover_bitmap 


    def GetRotatedBitmap(self, disabled):
        """
        Returns the correct bitmap depending on the tool orientation.

        :param bool `disabled`: whether to return the disabled bitmap or not.
        """
        
        bitmap_to_rotate = (disabled and [self.disabled_bitmap] or [self.bitmap])[0]
        if not bitmap_to_rotate.IsOk() or self.orientation == AUI_TBTOOL_HORIZONTAL:
            return bitmap_to_rotate

        rotated_bitmap = wx.NullBitmap
        clockwise = True
        if self.orientation == AUI_TBTOOL_VERT_CLOCKWISE:
            rotated_bitmap = (disabled and [self.clockwisedisbmp] or [self.clockwisebmp])[0]

        elif self.orientation == AUI_TBTOOL_VERT_COUNTERCLOCKWISE:
            rotated_bitmap = (disabled and [self.counterclockwisedisbmp] or [self.counterclockwisebmp])[0]
            clockwise = False

        if not rotated_bitmap.IsOk():
            rotated_bitmap = wx.BitmapFromImage(bitmap_to_rotate.ConvertToImage().Rotate90(clockwise))

        return rotated_bitmap


    def SetShortHelp(self, s):
        """
        Sets the short help string for the :class:`AuiToolBarItem`, to be displayed in a
        :class:`ToolTip` when the mouse hover over the toolbar item.

        :param string `s`: the tool short help string.
        """

        self.short_help = s

        
    def GetShortHelp(self):
        """ Returns the short help string for the :class:`AuiToolBarItem`. """

        return self.short_help 


    def SetLongHelp(self, s):
        """
        Sets the long help string for the toolbar item. This string is shown in the
        statusbar (if any) of the parent frame when the mouse pointer is inside the
        tool.

        :param string `s`: the tool long help string.
        """

        self.long_help = s

        
    def GetLongHelp(self):
        """ Returns the long help string for the :class:`AuiToolBarItem`. """

        return self.long_help 


    def SetMinSize(self, s):
        """
        Sets the toolbar item minimum size.

        :param Size `s`: the toolbar item minimum size.
        """

        self.min_size = wx.Size(*s)

        
    def GetMinSize(self):
        """ Returns the toolbar item minimum size. """

        return self.min_size 


    def SetSpacerPixels(self, s):
        """
        Sets the number of pixels for a toolbar item with kind = ``ITEM_SEPARATOR``.

        :param integer `s`: number of pixels.
        """

        self.spacer_pixels = s

        
    def GetSpacerPixels(self):
        """ Returns the number of pixels for a toolbar item with kind = ``ITEM_SEPARATOR``. """

        return self.spacer_pixels 


    def SetProportion(self, p):
        """
        Sets the :class:`AuiToolBarItem` proportion in the toolbar.

        :param integer `p`: the item proportion.
        """

        self.proportion = p

        
    def GetProportion(self):
        """ Returns the :class:`AuiToolBarItem` proportion in the toolbar. """

        return self.proportion 


    def SetActive(self, b):
        """
        Activates/deactivates the toolbar item.

        :param bool `b`: ``True`` to activate the item, ``False`` to deactivate it.
        """

        self.active = b

        
    def IsActive(self):
        """ Returns whether the toolbar item is active or not. """

        return self.active
    

    def SetHasDropDown(self, b):
        """
        Sets whether the toolbar item has an associated dropdown menu.

        :param bool `b`: ``True`` to set a dropdown menu, ``False`` otherwise.
        """

        self.dropdown = b

        
    def HasDropDown(self):
        """ Returns whether the toolbar item has an associated dropdown menu or not. """

        return self.dropdown 


    def SetSticky(self, b):
        """
        Sets whether the toolbar item is sticky (permanent highlight after mouse enter)
        or not.

        :param bool `b`: ``True`` to set the item as sticky, ``False`` otherwise.
        """

        self.sticky = b

        
    def IsSticky(self):
        """ Returns whether the toolbar item has a sticky behaviour or not. """

        return self.sticky 


    def SetUserData(self, data):
        """
        Associates some kind of user data to the toolbar item.
        
        :param PyObject `data`: a Python object.

        :note: The user data can be any Python object.
        """

        self.user_data = data

        
    def GetUserData(self):
        """ Returns the associated user data. """

        return self.user_data
    

    def SetAlignment(self, align):
        """
        Sets the toolbar item alignment.

        :param integer `align`: the item alignment, which can be one of the available :class:`Sizer`
         alignments.
        """

        self.alignment = align

        
    def GetAlignment(self):
        """ Returns the toolbar item alignment. """

        return self.alignment        


# ----------------------------------------------------------------------

class AuiDefaultToolBarArt(object):
    """
    Toolbar art provider code - a tab provider provides all drawing functionality to the :class:`AuiToolBar`.
    This allows the :class:`AuiToolBar` to have a plugable look-and-feel.

    By default, a :class:`AuiToolBar` uses an instance of this class called :class:`AuiDefaultToolBarArt`
    which provides bitmap art and a colour scheme that is adapted to the major platforms'
    look. You can either derive from that class to alter its behaviour or write a
    completely new tab art class. Call :meth:`AuiToolBar.SetArtProvider` to make use this new tab art.
    """

    def __init__(self):
        """ Default class constructor. """

        self.SetDefaultColours()

        self._agwFlags = 0
        self._text_orientation = AUI_TBTOOL_TEXT_BOTTOM
        self._highlight_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_HIGHLIGHT)

        self._separator_size = 7
        self._orientation = AUI_TBTOOL_HORIZONTAL
        self._gripper_size = 7
        self._overflow_size = 16

        button_dropdown_bits = "\xe0\xf1\xfb"
        overflow_bits = "\x80\xff\x80\xc1\xe3\xf7"

        self._button_dropdown_bmp = BitmapFromBits(button_dropdown_bits, 5, 3, wx.BLACK)
        self._disabled_button_dropdown_bmp = BitmapFromBits(button_dropdown_bits, 5, 3,
                                                            wx.Colour(128, 128, 128))
        self._overflow_bmp = BitmapFromBits(overflow_bits, 7, 6, wx.BLACK)
        self._disabled_overflow_bmp = BitmapFromBits(overflow_bits, 7, 6, wx.Colour(128, 128, 128))

        self._font = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)


    def SetDefaultColours(self, base_colour=None):
        """
        Sets the default colours, which are calculated from the given base colour.

        :param `base_colour`: an instance of :class:`Colour`. If defaulted to ``None``, a colour
         is generated accordingly to the platform and theme.
        """

        if base_colour is None:
            self._base_colour = GetBaseColour()
        else:
            self._base_colour = base_colour

        darker3_colour = StepColour(self._base_colour, 60)
        darker5_colour = StepColour(self._base_colour, 40)

        self._gripper_pen1 = wx.Pen(darker5_colour)
        self._gripper_pen2 = wx.Pen(darker3_colour)
        self._gripper_pen3 = wx.WHITE_PEN
        

    def Clone(self):
        """ Clones the :class:`AuiDefaultToolBarArt` art. """

        return AuiDefaultToolBarArt()


    def SetAGWFlags(self, agwFlags):
        """
        Sets the toolbar art flags.

        :param integer `agwFlags`: a combination of the following values:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_TB_TEXT``                      Shows the text in the toolbar buttons; by default only icons are shown
         ``AUI_TB_NO_TOOLTIPS``               Don't show tooltips on :class:`AuiToolBar` items
         ``AUI_TB_NO_AUTORESIZE``             Do not auto-resize the :class:`AuiToolBar`
         ``AUI_TB_GRIPPER``                   Shows a gripper on the :class:`AuiToolBar`
         ``AUI_TB_OVERFLOW``                  The :class:`AuiToolBar` can contain overflow items
         ``AUI_TB_VERTICAL``                  The :class:`AuiToolBar` is vertical
         ``AUI_TB_HORZ_LAYOUT``               Shows the text and the icons alongside, not vertically stacked. This style
                                              must be used with ``AUI_TB_TEXT``
         ``AUI_TB_PLAIN_BACKGROUND``          Don't draw a gradient background on the toolbar
         ``AUI_TB_HORZ_TEXT``                 Combination of ``AUI_TB_HORZ_LAYOUT`` and ``AUI_TB_TEXT``
         ==================================== ==================================
        
        """
        
        self._agwFlags = agwFlags


    def GetAGWFlags(self):
        """
        Returns the :class:`AuiDefaultToolBarArt` flags.

        :see: :meth:`~AuiDefaultToolBarArt.SetAGWFlags` for more details.
        """

        return self._agwFlags


    def SetFont(self, font):
        """
        Sets the :class:`AuiDefaultToolBarArt` font.

        :param Font `font`: the font used for displaying toolbar item labels.
        """

        self._font = font


    def SetTextOrientation(self, orientation):
        """
        Sets the text orientation.

        :param integer `orientation`: can be one of the following constants:

         ==================================== ==================================
         Orientation Switches                 Description
         ==================================== ==================================
         ``AUI_TBTOOL_TEXT_LEFT``             Text in :class:`AuiToolBar` items is aligned left
         ``AUI_TBTOOL_TEXT_RIGHT``            Text in :class:`AuiToolBar` items is aligned right
         ``AUI_TBTOOL_TEXT_TOP``              Text in :class:`AuiToolBar` items is aligned top
         ``AUI_TBTOOL_TEXT_BOTTOM``           Text in :class:`AuiToolBar` items is aligned bottom
         ==================================== ==================================
        
        """

        self._text_orientation = orientation


    def GetFont(self):
        """ Returns the :class:`AuiDefaultToolBarArt` font. """

        return self._font


    def GetTextOrientation(self):
        """
        Returns the :class:`AuiDefaultToolBarArt` text orientation. 

        :see: :meth:`~AuiDefaultToolBarArt.SetTextOrientation` for more details.
        """

        return self._text_orientation


    def SetOrientation(self, orientation):
        """
        Sets the toolbar tool orientation.

        :param integer `orientation`: one of ``AUI_TBTOOL_HORIZONTAL``, ``AUI_TBTOOL_VERT_CLOCKWISE`` or
         ``AUI_TBTOOL_VERT_COUNTERCLOCKWISE``.
        """

        self._orientation = orientation


    def GetOrientation(self):
        """ Returns the toolbar orientation. """

        return self._orientation        


    def DrawBackground(self, dc, wnd, _rect, horizontal=True):
        """
        Draws a toolbar background with a gradient shading.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param Rect `_rect`: the :class:`AuiToolBarItem` rectangle;
        :param bool `horizontal`: ``True`` if the toolbar is horizontal, ``False`` if it is vertical.
        """

        rect = wx.Rect(*_rect)

        start_colour = StepColour(self._base_colour, 180)
        end_colour = StepColour(self._base_colour, 85)
        reflex_colour = StepColour(self._base_colour, 95)
        
        dc.GradientFillLinear(rect, start_colour, end_colour,
                              (horizontal and [wx.SOUTH] or [wx.EAST])[0])

        left = rect.GetLeft()
        right = rect.GetRight()
        top = rect.GetTop()
        bottom = rect.GetBottom()

        dc.SetPen(wx.Pen(reflex_colour))
        if horizontal:
            dc.DrawLine(left, bottom, right+1, bottom)
        else:
            dc.DrawLine(right, top, right, bottom+1)
            

    def DrawPlainBackground(self, dc, wnd, _rect):
        """
        Draws a toolbar background with a plain colour.

        This method contrasts with the default behaviour of the :class:`AuiToolBar` that
        draws a background gradient and this break the window design when putting
        it within a control that has margin between the borders and the toolbar
        (example: put :class:`AuiToolBar` within a :class:`StaticBoxSizer` that has a plain background).
      
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param Rect `_rect`: the :class:`AuiToolBarItem` rectangle.
        """
        
        rect = wx.Rect(*_rect)
        rect.height += 1

        dc.SetBrush(wx.Brush(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DFACE)))
        dc.DrawRectangle(rect.x - 1, rect.y - 1, rect.width + 2, rect.height + 1)


    def DrawLabel(self, dc, wnd, item, rect):
        """
        Draws a toolbar item label.
        
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param `item`: an instance of :class:`AuiToolBarItem`;
        :param Rect `rect`: the :class:`AuiToolBarItem` rectangle.
        """
        
        dc.SetFont(self._font)

        if item.state & AUI_BUTTON_STATE_DISABLED:
            dc.SetTextForeground(wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT))
        else:
            dc.SetTextForeground(wx.SystemSettings.GetColour(wx.SYS_COLOUR_BTNTEXT))
            
        orient = item.GetOrientation()

        horizontal = orient == AUI_TBTOOL_HORIZONTAL
        # we only care about the text height here since the text
        # will get cropped based on the width of the item
        label_size = GetLabelSize(dc, item.GetLabel(), not horizontal)
        text_width = label_size.GetWidth()
        text_height = label_size.GetHeight()

        if orient == AUI_TBTOOL_HORIZONTAL:
            text_x = rect.x + (rect.width - text_width) / 2
            text_y = rect.y + (rect.height - text_height) / 2
            dc.DrawText(item.GetLabel(), text_x, text_y)

        elif orient == AUI_TBTOOL_VERT_CLOCKWISE:
            text_x = rect.x + (rect.width + text_width) / 2
            text_y = rect.y
            dc.DrawRotatedText(item.GetLabel(), text_x, text_y, 270)

        elif AUI_TBTOOL_VERT_COUNTERCLOCKWISE:
            text_x = rect.x + (rect.width - text_width) / 2
            text_y = rect.y + text_height
            dc.DrawRotatedText(item.GetLabel(), text_x, text_y, 90)


    def DrawButton(self, dc, wnd, item, rect):
        """
        Draws a toolbar item button.
        
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param `item`: an instance of :class:`AuiToolBarItem`;
        :param Rect `rect`: the :class:`AuiToolBarItem` rectangle.
        """

        bmp_rect, text_rect = self.GetToolsPosition(dc, item, rect)

        if not item.GetState() & AUI_BUTTON_STATE_DISABLED:
        
            if item.GetState() & AUI_BUTTON_STATE_PRESSED:
            
                dc.SetPen(wx.Pen(self._highlight_colour))
                dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 150)))
                dc.DrawRectangleRect(rect)
            
            elif item.GetState() & AUI_BUTTON_STATE_HOVER or item.IsSticky():
            
                dc.SetPen(wx.Pen(self._highlight_colour))
                dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 170)))

                # draw an even lighter background for checked item hovers (since
                # the hover background is the same colour as the check background)
                if item.GetState() & AUI_BUTTON_STATE_CHECKED:
                    dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 180)))

                dc.DrawRectangleRect(rect)
            
            elif item.GetState() & AUI_BUTTON_STATE_CHECKED:
            
                # it's important to put this code in an else statment after the
                # hover, otherwise hovers won't draw properly for checked items
                dc.SetPen(wx.Pen(self._highlight_colour))
                dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 170)))
                dc.DrawRectangleRect(rect)
            
        if item.GetState() & AUI_BUTTON_STATE_DISABLED:
            bmp = item.GetDisabledBitmap()
        else:
            bmp = item.GetBitmap()

        if bmp.IsOk():
            dc.DrawBitmap(bmp, bmp_rect.x, bmp_rect.y, True)
        else:
            # If there is no bitmap to draw, the text can use the whole
            # item rect.
            text_rect = rect

        # set the item's text colour based on if it is disabled
        dc.SetTextForeground(wx.BLACK)
        if item.GetState() & AUI_BUTTON_STATE_DISABLED:
            dc.SetTextForeground(DISABLED_TEXT_COLOUR)

        if self._agwFlags & AUI_TB_TEXT and item.GetLabel() != "":
            self.DrawLabel(dc, wnd, item, text_rect)
        

    def DrawDropDownButton(self, dc, wnd, item, rect):
        """
        Draws a toolbar dropdown button.
        
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param `item`: an instance of :class:`AuiToolBarItem`;
        :param Rect `rect`: the :class:`AuiToolBarItem` rectangle.
        """
        
        dropbmp_x = dropbmp_y = 0

        button_rect = wx.Rect(rect.x, rect.y, rect.width-BUTTON_DROPDOWN_WIDTH, rect.height)
        dropdown_rect = wx.Rect(rect.x+rect.width-BUTTON_DROPDOWN_WIDTH-1, rect.y, BUTTON_DROPDOWN_WIDTH+1, rect.height)

        horizontal = item.GetOrientation() == AUI_TBTOOL_HORIZONTAL
        
        if horizontal:
            button_rect = wx.Rect(rect.x, rect.y, rect.width-BUTTON_DROPDOWN_WIDTH, rect.height)
            dropdown_rect = wx.Rect(rect.x+rect.width-BUTTON_DROPDOWN_WIDTH-1, rect.y, BUTTON_DROPDOWN_WIDTH+1, rect.height)
        else:
            button_rect = wx.Rect(rect.x, rect.y, rect.width, rect.height-BUTTON_DROPDOWN_WIDTH)
            dropdown_rect = wx.Rect(rect.x, rect.y+rect.height-BUTTON_DROPDOWN_WIDTH-1, rect.width, BUTTON_DROPDOWN_WIDTH+1)

        dropbmp_width = self._button_dropdown_bmp.GetWidth()
        dropbmp_height = self._button_dropdown_bmp.GetHeight()
        if not horizontal:
            tmp = dropbmp_width
            dropbmp_width = dropbmp_height
            dropbmp_height = tmp

        dropbmp_x = dropdown_rect.x + (dropdown_rect.width/2) - dropbmp_width/2
        dropbmp_y = dropdown_rect.y + (dropdown_rect.height/2) - dropbmp_height/2

        bmp_rect, text_rect = self.GetToolsPosition(dc, item, button_rect)
        
        if item.GetState() & AUI_BUTTON_STATE_PRESSED:
        
            dc.SetPen(wx.Pen(self._highlight_colour))
            dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 140)))
            dc.DrawRectangleRect(button_rect)
            dc.DrawRectangleRect(dropdown_rect)
        
        elif item.GetState() & AUI_BUTTON_STATE_HOVER or item.IsSticky():
        
            dc.SetPen(wx.Pen(self._highlight_colour))
            dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 170)))
            dc.DrawRectangleRect(button_rect)
            dc.DrawRectangleRect(dropdown_rect)

        elif item.GetState() & AUI_BUTTON_STATE_CHECKED:
            # it's important to put this code in an else statment after the 
            # hover, otherwise hovers won't draw properly for checked items 
            dc.SetPen(wx.Pen(self._highlight_colour))
            dc.SetBrush(wx.Brush(StepColour(self._highlight_colour, 170)))
            dc.DrawRectangle(button_rect)
            dc.DrawRectangle(dropdown_rect)
            
        if item.GetState() & AUI_BUTTON_STATE_DISABLED:
        
            bmp = item.GetDisabledBitmap()
            dropbmp = self._disabled_button_dropdown_bmp
        
        else:
        
            bmp = item.GetBitmap()
            dropbmp = self._button_dropdown_bmp
        
        if not bmp.IsOk():
            return

        dc.DrawBitmap(bmp, bmp_rect.x, bmp_rect.y, True)
        if horizontal:
            dc.DrawBitmap(dropbmp, dropbmp_x, dropbmp_y, True)
        else:
            dc.DrawBitmap(wx.BitmapFromImage(dropbmp.ConvertToImage().Rotate90(item.GetOrientation() == AUI_TBTOOL_VERT_CLOCKWISE)),
                          dropbmp_x, dropbmp_y, True)
            
        # set the item's text colour based on if it is disabled
        dc.SetTextForeground(wx.BLACK)
        if item.GetState() & AUI_BUTTON_STATE_DISABLED:
            dc.SetTextForeground(DISABLED_TEXT_COLOUR)

        if self._agwFlags & AUI_TB_TEXT and item.GetLabel() != "":  
            self.DrawLabel(dc, wnd, item, text_rect)
        

    def DrawControlLabel(self, dc, wnd, item, rect):
        """
        Draws a label for a toolbar control.
        
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param `item`: an instance of :class:`AuiToolBarItem`;
        :param Rect `rect`: the :class:`AuiToolBarItem` rectangle.
        """

        label_size = GetLabelSize(dc, item.GetLabel(), item.GetOrientation() != AUI_TBTOOL_HORIZONTAL)
        text_height = label_size.GetHeight()
        text_width = label_size.GetWidth()

        dc.SetFont(self._font)

        if self._agwFlags & AUI_TB_TEXT:
        
            tx, text_height = dc.GetTextExtent("ABCDHgj")        

        text_width, ty = dc.GetTextExtent(item.GetLabel())

        # don't draw the label if it is wider than the item width
        if text_width > rect.width:
            return

        # set the label's text colour
        dc.SetTextForeground(wx.BLACK)

        text_x = rect.x + (rect.width/2) - (text_width/2) + 1
        text_y = rect.y + rect.height - text_height - 1

        if self._agwFlags & AUI_TB_TEXT and item.GetLabel() != "": 
            dc.DrawText(item.GetLabel(), text_x, text_y)
    

    def GetLabelSize(self, dc, wnd, item):
        """
        Returns the label size for a toolbar item.
        
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param `item`: an instance of :class:`AuiToolBarItem`.
        """

        dc.SetFont(self._font)
        label_size = GetLabelSize(dc, item.GetLabel(), self._orientation != AUI_TBTOOL_HORIZONTAL)

        return wx.Size(item.GetMinSize().GetWidth(), label_size.GetHeight())


    def GetToolSize(self, dc, wnd, item):
        """
        Returns the toolbar item size.
        
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param `item`: an instance of :class:`AuiToolBarItem`.
        """
        
        if not item.GetBitmap().IsOk() and not self._agwFlags & AUI_TB_TEXT:
            return wx.Size(16, 16)

        width = item.GetBitmap().GetWidth()
        height = item.GetBitmap().GetHeight()

        if self._agwFlags & AUI_TB_TEXT:
        
            dc.SetFont(self._font)
            label_size = GetLabelSize(dc, item.GetLabel(), self.GetOrientation() != AUI_TBTOOL_HORIZONTAL)
            padding = 6
            
            if self._text_orientation == AUI_TBTOOL_TEXT_BOTTOM:
            
                if self.GetOrientation() != AUI_TBTOOL_HORIZONTAL:
                    height += 3   # space between top border and bitmap
                    height += 3   # space between bitmap and text
                    padding = 0

                height += label_size.GetHeight()
            
                if item.GetLabel() != "":
                    width = max(width, label_size.GetWidth()+padding)
                
            elif self._text_orientation == AUI_TBTOOL_TEXT_RIGHT and item.GetLabel() != "":
            
                if self.GetOrientation() == AUI_TBTOOL_HORIZONTAL:
                    
                    width += 3  # space between left border and bitmap
                    width += 3  # space between bitmap and text
                    padding = 0

                width += label_size.GetWidth()
                height = max(height, label_size.GetHeight()+padding)
                
        # if the tool has a dropdown button, add it to the width
        if item.HasDropDown():
            if item.GetOrientation() == AUI_TBTOOL_HORIZONTAL:
                width += BUTTON_DROPDOWN_WIDTH+4
            else:
                height += BUTTON_DROPDOWN_WIDTH+4

        return wx.Size(width, height)


    def DrawSeparator(self, dc, wnd, _rect):
        """
        Draws a toolbar separator.
        
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param Rect `_rect`: the :class:`AuiToolBarItem` rectangle.
        """
        
        horizontal = True
        if self._agwFlags & AUI_TB_VERTICAL:
            horizontal = False

        rect = wx.Rect(*_rect)

        if horizontal:
        
            rect.x += (rect.width/2)
            rect.width = 1
            new_height = (rect.height*3)/4
            rect.y += (rect.height/2) - (new_height/2)
            rect.height = new_height
        
        else:
        
            rect.y += (rect.height/2)
            rect.height = 1
            new_width = (rect.width*3)/4
            rect.x += (rect.width/2) - (new_width/2)
            rect.width = new_width
        
        start_colour = StepColour(self._base_colour, 80)
        end_colour = StepColour(self._base_colour, 80)
        dc.GradientFillLinear(rect, start_colour, end_colour, (horizontal and [wx.SOUTH] or [wx.EAST])[0])


    def DrawGripper(self, dc, wnd, rect):
        """
        Draws the toolbar gripper.
        
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param Rect `rect`: the :class:`AuiToolBarItem` rectangle.
        """
        
        i = 0
        while 1:
        
            if self._agwFlags & AUI_TB_VERTICAL:
            
                x = rect.x + (i*4) + 4
                y = rect.y + 3
                if x > rect.GetWidth() - 4:
                    break
            
            else:
            
                x = rect.x + 3
                y = rect.y + (i*4) + 4
                if y > rect.GetHeight() - 4:
                    break
            
            dc.SetPen(self._gripper_pen1)
            dc.DrawPoint(x, y)
            dc.SetPen(self._gripper_pen2)
            dc.DrawPoint(x, y+1)
            dc.DrawPoint(x+1, y)
            dc.SetPen(self._gripper_pen3)
            dc.DrawPoint(x+2, y+1)
            dc.DrawPoint(x+2, y+2)
            dc.DrawPoint(x+1, y+2)

            i += 1


    def DrawOverflowButton(self, dc, wnd, rect, state):
        """
        Draws the overflow button for the :class:`AuiToolBar`.
        
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` derived window;
        :param Rect `rect`: the :class:`AuiToolBarItem` rectangle;
        :param integer `state`: the overflow button state.
        """
        
        if state & AUI_BUTTON_STATE_HOVER or  state & AUI_BUTTON_STATE_PRESSED:
        
            cli_rect = wnd.GetClientRect()
            light_gray_bg = StepColour(self._highlight_colour, 170)

            if self._agwFlags & AUI_TB_VERTICAL:
            
                dc.SetPen(wx.Pen(self._highlight_colour))
                dc.DrawLine(rect.x, rect.y, rect.x+rect.width, rect.y)
                dc.SetPen(wx.Pen(light_gray_bg))
                dc.SetBrush(wx.Brush(light_gray_bg))
                dc.DrawRectangle(rect.x, rect.y+1, rect.width, rect.height)
            
            else:
            
                dc.SetPen(wx.Pen(self._highlight_colour))
                dc.DrawLine(rect.x, rect.y, rect.x, rect.y+rect.height)
                dc.SetPen(wx.Pen(light_gray_bg))
                dc.SetBrush(wx.Brush(light_gray_bg))
                dc.DrawRectangle(rect.x+1, rect.y, rect.width, rect.height)
            
        x = rect.x + 1 + (rect.width-self._overflow_bmp.GetWidth())/2
        y = rect.y + 1 + (rect.height-self._overflow_bmp.GetHeight())/2
        dc.DrawBitmap(self._overflow_bmp, x, y, True)


    def GetElementSize(self, element_id):
        """
        Returns the size of a UI element in the :class:`AuiToolBar`.

        :param integer `element_id`: can be one of the following:

         ==================================== ==================================
         Element Identifier                   Description
         ==================================== ==================================
         ``AUI_TBART_SEPARATOR_SIZE``         Separator size in :class:`AuiToolBar`
         ``AUI_TBART_GRIPPER_SIZE``           Gripper size in :class:`AuiToolBar`
         ``AUI_TBART_OVERFLOW_SIZE``          Overflow button size in :class:`AuiToolBar`
         ==================================== ==================================        
        """
        
        if element_id == AUI_TBART_SEPARATOR_SIZE:
            return self._separator_size
        elif element_id == AUI_TBART_GRIPPER_SIZE:
            return self._gripper_size
        elif element_id == AUI_TBART_OVERFLOW_SIZE:
            return self._overflow_size

        return 0


    def SetElementSize(self, element_id, size):
        """
        Sets the size of a UI element in the :class:`AuiToolBar`.

        :param integer `element_id`: can be one of the following:

         ==================================== ==================================
         Element Identifier                   Description
         ==================================== ==================================
         ``AUI_TBART_SEPARATOR_SIZE``         Separator size in :class:`AuiToolBar`
         ``AUI_TBART_GRIPPER_SIZE``           Gripper size in :class:`AuiToolBar`
         ``AUI_TBART_OVERFLOW_SIZE``          Overflow button size in :class:`AuiToolBar`
         ==================================== ==================================        

        :param integer `size`: the new size of the UI element.        
        """
        
        if element_id == AUI_TBART_SEPARATOR_SIZE:
            self._separator_size = size
        elif element_id == AUI_TBART_GRIPPER_SIZE:
            self._gripper_size = size
        elif element_id == AUI_TBART_OVERFLOW_SIZE:
            self._overflow_size = size


    def ShowDropDown(self, wnd, items):
        """
        Shows the drop down window menu for overflow items.

        :param `wnd`: an instance of :class:`Window`;
        :param list `items`: a list of the overflow toolbar items.
        """

        menuPopup = wx.Menu()
        items_added = 0

        for item in items:

            if item.GetKind() not in [ITEM_SEPARATOR, ITEM_SPACER, ITEM_CONTROL]:
            
                text = item.GetShortHelp()
                if text == "":
                    text = item.GetLabel()
                if text == "":
                    text = " "

                kind = item.GetKind()
                m = wx.MenuItem(menuPopup, item.GetId(), text, item.GetShortHelp(), kind)
                orientation = item.GetOrientation()
                item.SetOrientation(AUI_TBTOOL_HORIZONTAL)
                
                if kind not in [ITEM_CHECK, ITEM_RADIO]:
                    m.SetBitmap(item.GetBitmap())

                item.SetOrientation(orientation)                    
                    
                menuPopup.AppendItem(m)
                if kind in [ITEM_CHECK, ITEM_RADIO]:            
                    state = (item.state & AUI_BUTTON_STATE_CHECKED and [True] or [False])[0]
                    m.Check(state)

                items_added += 1
            
            else:
            
                if items_added > 0 and item.GetKind() == ITEM_SEPARATOR:
                    menuPopup.AppendSeparator()
            
        # find out where to put the popup menu of window items
        pt = wx.GetMousePosition()
        pt = wnd.ScreenToClient(pt)

        # find out the screen coordinate at the bottom of the tab ctrl
        cli_rect = wnd.GetClientRect()
        pt.y = cli_rect.y + cli_rect.height

        cc = ToolbarCommandCapture()
        wnd.PushEventHandler(cc)

        # Adjustments to get slightly better menu placement
        if wx.Platform == "__WXMAC__":
            pt.y += 5
            pt.x -= 5

        wnd.PopupMenu(menuPopup, pt)
        command = cc.GetCommandId()
        wnd.PopEventHandler(True)

        return command


    def GetToolsPosition(self, dc, item, rect):
        """
        Returns the bitmap and text rectangles for a toolbar item.
        
        :param `dc`: a :class:`DC` device context;
        :param `item`: an instance of :class:`AuiToolBarItem`;
        :param Rect `rect`: the tool rectangle.
        """
        
        text_width = text_height = 0
        horizontal = self._orientation == AUI_TBTOOL_HORIZONTAL
        text_bottom = self._text_orientation == AUI_TBTOOL_TEXT_BOTTOM
        text_right = self._text_orientation == AUI_TBTOOL_TEXT_RIGHT
        bmp_width = item.GetBitmap().GetWidth()
        bmp_height = item.GetBitmap().GetHeight()
     
        if self._agwFlags & AUI_TB_TEXT:        
            dc.SetFont(self._font)
            label_size = GetLabelSize(dc, item.GetLabel(), not horizontal)
            text_height = label_size.GetHeight()
            text_width = label_size.GetWidth()
        
        bmp_x = bmp_y = text_x = text_y = 0

        if horizontal and text_bottom:
            bmp_x = rect.x + (rect.width/2) - (bmp_width/2)
            bmp_y = rect.y + 3
            text_x = rect.x + (rect.width/2) - (text_width/2)
            text_y = rect.y + ((bmp_y - rect.y) * 2) + bmp_height
        
        elif horizontal and text_right:
            bmp_x = rect.x + 3
            bmp_y = rect.y + (rect.height/2) - (bmp_height / 2)
            text_x = rect.x + ((bmp_x - rect.x) * 2) + bmp_width
            text_y = rect.y + (rect.height/2) - (text_height/2)
        
        elif not horizontal and text_bottom:
            bmp_x = rect.x + (rect.width / 2) - (bmp_width / 2)
            bmp_y = rect.y + 3
            text_x = rect.x + (rect.width / 2) - (text_width / 2)
            text_y = rect.y + ((bmp_y - rect.y) * 2) + bmp_height
        
        bmp_rect = wx.Rect(bmp_x, bmp_y, bmp_width, bmp_height)
        text_rect = wx.Rect(text_x, text_y, text_width, text_height)

        return bmp_rect, text_rect

    
class AuiToolBar(wx.PyControl):
    """
    AuiToolBar is a completely owner-drawn toolbar perfectly integrated with the AUI layout system.
    This allows drag and drop of toolbars, docking/floating behaviour and the possibility to define
    "overflow" items in the toolbar itself.

    The default theme that is used is :class:`AuiDefaultToolBarArt`, which provides a modern,
    glossy look and feel. The theme can be changed by calling :meth:`AuiToolBar.SetArtProvider`.
    """

    def __init__(self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=0, agwStyle=AUI_TB_DEFAULT_STYLE):
        """
        Default class constructor.

        :param Window `parent`: the :class:`AuiToolBar` parent;
        :param integer `id`: an identifier for the control: a value of -1 is taken to mean a default;
        :param Point `pos`: the control position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform;
        :param Size `size`: the control size. A value of (-1, -1) indicates a default size,
         chosen by either the windowing system or wxPython, depending on platform;
        :param integer `style`: the control window style;
        :param integer `agwStyle`: the AGW-specific window style. This can be a combination of the
         following bits:
        
         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_TB_TEXT``                      Shows the text in the toolbar buttons; by default only icons are shown
         ``AUI_TB_NO_TOOLTIPS``               Don't show tooltips on :class:`AuiToolBar` items
         ``AUI_TB_NO_AUTORESIZE``             Do not auto-resize the :class:`AuiToolBar`
         ``AUI_TB_GRIPPER``                   Shows a gripper on the :class:`AuiToolBar`
         ``AUI_TB_OVERFLOW``                  The :class:`AuiToolBar` can contain overflow items
         ``AUI_TB_VERTICAL``                  The :class:`AuiToolBar` is vertical
         ``AUI_TB_HORZ_LAYOUT``               Shows the text and the icons alongside, not vertically stacked.
                                              This style must be used with ``AUI_TB_TEXT``
         ``AUI_TB_PLAIN_BACKGROUND``          Don't draw a gradient background on the toolbar
         ``AUI_TB_HORZ_TEXT``                 Combination of ``AUI_TB_HORZ_LAYOUT`` and ``AUI_TB_TEXT``
         ==================================== ==================================

         The default value for `agwStyle` is: ``AUI_TB_DEFAULT_STYLE`` = 0

        """
        
        wx.PyControl.__init__(self, parent, id, pos, size, style|wx.BORDER_NONE)

        self._sizer = wx.BoxSizer(wx.HORIZONTAL)
        self.SetSizer(self._sizer)
        self._button_width = -1
        self._button_height = -1
        self._sizer_element_count = 0
        self._action_pos = wx.Point(-1, -1)
        self._action_item = None
        self._tip_item = None
        self._art = AuiDefaultToolBarArt()
        self._tool_packing = 2
        self._tool_border_padding = 3
        self._tool_text_orientation = AUI_TBTOOL_TEXT_BOTTOM
        self._tool_orientation = AUI_TBTOOL_HORIZONTAL
        self._tool_alignment = wx.EXPAND
        self._gripper_sizer_item = None
        self._overflow_sizer_item = None
        self._dragging = False

        self._agwStyle = self._originalStyle = agwStyle

        self._gripper_visible = (self._agwStyle & AUI_TB_GRIPPER and [True] or [False])[0]
        self._overflow_visible = (self._agwStyle & AUI_TB_OVERFLOW and [True] or [False])[0]
        self._overflow_state = 0
        self._custom_overflow_prepend = []
        self._custom_overflow_append = []

        self._items = []
        
        self.SetMargins(5, 5, 2, 2)
        self.SetFont(wx.NORMAL_FONT)
        self._art.SetAGWFlags(self._agwStyle)
        self.SetExtraStyle(wx.WS_EX_PROCESS_IDLE)
        
        if agwStyle & AUI_TB_HORZ_LAYOUT:
            self.SetToolTextOrientation(AUI_TBTOOL_TEXT_RIGHT)
        elif agwStyle & AUI_TB_VERTICAL:
            if agwStyle & AUI_TB_CLOCKWISE:
                self.SetToolOrientation(AUI_TBTOOL_VERT_CLOCKWISE)
            elif agwStyle & AUI_TB_COUNTERCLOCKWISE:
                self.SetToolOrientation(AUI_TBTOOL_VERT_COUNTERCLOCKWISE)
 
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        
        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_IDLE, self.OnIdle)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_DCLICK, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.Bind(wx.EVT_RIGHT_DOWN, self.OnRightDown)
        self.Bind(wx.EVT_RIGHT_DCLICK, self.OnRightDown)
        self.Bind(wx.EVT_RIGHT_UP, self.OnRightUp)
        self.Bind(wx.EVT_MIDDLE_DOWN, self.OnMiddleDown)
        self.Bind(wx.EVT_MIDDLE_DCLICK, self.OnMiddleDown)
        self.Bind(wx.EVT_MIDDLE_UP, self.OnMiddleUp)
        self.Bind(wx.EVT_MOTION, self.OnMotion)
        self.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow)
        self.Bind(wx.EVT_SET_CURSOR, self.OnSetCursor)


    def SetWindowStyleFlag(self, style):
        """
        Sets the style of the window.
        
        :param integer `style`: the new window style. 

        :note: Please note that some styles cannot be changed after the window
         creation and that `Refresh` might need to be be called after changing the
         others for the change to take place immediately.

        :note: Overridden from :class:`PyControl`.
        """

        wx.PyControl.SetWindowStyleFlag(self, style|wx.BORDER_NONE)
        

    def SetAGWWindowStyleFlag(self, agwStyle):
        """
        Sets the AGW-specific style of the window.
        
        :param integer `agwStyle`: the new window style. This can be a combination of the
         following bits:
        
         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_TB_TEXT``                      Shows the text in the toolbar buttons; by default only icons are shown
         ``AUI_TB_NO_TOOLTIPS``               Don't show tooltips on :class:`AuiToolBar` items
         ``AUI_TB_NO_AUTORESIZE``             Do not auto-resize the :class:`AuiToolBar`
         ``AUI_TB_GRIPPER``                   Shows a gripper on the :class:`AuiToolBar`
         ``AUI_TB_OVERFLOW``                  The :class:`AuiToolBar` can contain overflow items
         ``AUI_TB_VERTICAL``                  The :class:`AuiToolBar` is vertical
         ``AUI_TB_HORZ_LAYOUT``               Shows the text and the icons alongside, not vertically stacked.
                                              This style must be used with ``AUI_TB_TEXT``
         ``AUI_TB_PLAIN_BACKGROUND``          Don't draw a gradient background on the toolbar
         ``AUI_TB_HORZ_TEXT``                 Combination of ``AUI_TB_HORZ_LAYOUT`` and ``AUI_TB_TEXT``
         ==================================== ==================================

        :note: Please note that some styles cannot be changed after the window
         creation and that `Refresh` might need to be be called after changing the
         others for the change to take place immediately.
        """
        self._agwStyle = self._originalStyle = agwStyle

        if self._art:
            self._art.SetAGWFlags(self._agwStyle)
        
        if agwStyle & AUI_TB_GRIPPER:
            self._gripper_visible = True
        else:
            self._gripper_visible = False

        if agwStyle & AUI_TB_OVERFLOW:
            self._overflow_visible = True
        else:
            self._overflow_visible = False

        if agwStyle & AUI_TB_HORZ_LAYOUT:
            self.SetToolTextOrientation(AUI_TBTOOL_TEXT_RIGHT)
        else:
            self.SetToolTextOrientation(AUI_TBTOOL_TEXT_BOTTOM)

        if agwStyle & AUI_TB_VERTICAL:
            if agwStyle & AUI_TB_CLOCKWISE:
                self.SetToolOrientation(AUI_TBTOOL_VERT_CLOCKWISE)
            elif agwStyle & AUI_TB_COUNTERCLOCKWISE:
                self.SetToolOrientation(AUI_TBTOOL_VERT_COUNTERCLOCKWISE)

                
    def GetAGWWindowStyleFlag(self):
        """
        Returns the AGW-specific window style flag.

        :see: :meth:`SetAGWWindowStyleFlag` for an explanation of various AGW-specific style.
        """
        return self._agwStyle
    

    def SetArtProvider(self, art):
        """
        Instructs :class:`AuiToolBar` to use art provider specified by parameter `art`
        for all drawing calls. This allows plugable look-and-feel features. 

        :param `art`: an art provider.

        :note: The previous art provider object, if any, will be deleted by :class:`AuiToolBar`.
        """
        
        del self._art
        self._art = art

        if self._art:
            self._art.SetAGWFlags(self._agwStyle)
            self._art.SetTextOrientation(self._tool_text_orientation)
            self._art.SetOrientation(self._tool_orientation)
        

    def GetArtProvider(self):
        """ Returns the current art provider being used. """

        return self._art

    def AddSimpleTool(self, tool_id, label, bitmap, short_help_string="", kind=ITEM_NORMAL, target=None):
        """
        Adds a tool to the toolbar. This is the simplest method you can use to
        ass an item to the :class:`AuiToolBar`.

        :param integer `tool_id`: an integer by which the tool may be identified in subsequent operations;
        :param string `label`: the toolbar tool label;
        :param Bitmap `bitmap`: the primary tool bitmap;
        :param string `short_help_string`: this string is used for the tools tooltip;
        :param integer `kind`: the item kind. Can be one of the following:

         ========================  =============================
         Item Kind                 Description
         ========================  =============================
         ``ITEM_CONTROL``          The item in the :class:`AuiToolBar` is a control
         ``ITEM_LABEL``            The item in the :class:`AuiToolBar` is a text label
         ``ITEM_SPACER``           The item in the :class:`AuiToolBar` is a spacer
         ``ITEM_SEPARATOR``        The item in the :class:`AuiToolBar` is a separator
         ``ITEM_CHECK``            The item in the :class:`AuiToolBar` is a toolbar check item
         ``ITEM_NORMAL``           The item in the :class:`AuiToolBar` is a standard toolbar item
         ``ITEM_RADIO``            The item in the :class:`AuiToolBar` is a toolbar radio item
         ========================  =============================

        :param `target`: a custom string indicating that an instance of :class:`~lib.agw.aui.framemanager.AuiPaneInfo`
         has been minimized into this toolbar.
        """
        
        return self.AddTool(tool_id, label, bitmap, wx.NullBitmap, kind, short_help_string, "", None, target)


    def AddToggleTool(self, tool_id, bitmap, disabled_bitmap, toggle=False, client_data=None, short_help_string="", long_help_string=""):
        """
        Adds a toggle tool to the toolbar. 

        :param integer `tool_id`: an integer by which the tool may be identified in subsequent operations;
        :param Bitmap `bitmap`: the primary tool bitmap;
        :param Bitmap `disabled_bitmap`: the bitmap to use when the tool is disabled. If it is equal to
         :class:`NullBitmap`, the disabled bitmap is automatically generated by greing the normal one;
        :param PyObject `client_data`: whatever Python object to associate with the toolbar item;
        :param string `short_help_string`: this string is used for the tools tooltip;
        :param string `long_help_string`: this string is shown in the statusbar (if any) of the parent
         frame when the mouse pointer is inside the tool.
        """

        kind = (toggle and [ITEM_CHECK] or [ITEM_NORMAL])[0]
        return self.AddTool(tool_id, "", bitmap, disabled_bitmap, kind, short_help_string, long_help_string, client_data)


    def AddTool(self, tool_id, label, bitmap, disabled_bitmap, kind, short_help_string='', long_help_string='', client_data=None, target=None):
        """
        Adds a tool to the toolbar. This is the full feature version of :meth:`AddTool`.

        :param integer `tool_id`: an integer by which the tool may be identified in subsequent operations;
        :param string `label`: the toolbar tool label;
        :param Bitmap `bitmap`: the primary tool bitmap;
        :param Bitmap `disabled_bitmap`: the bitmap to use when the tool is disabled. If it is equal to
         :class:`NullBitmap`, the disabled bitmap is automatically generated by greing the normal one;
        :param integer `kind`: the item kind. Can be one of the following:

         ========================  =============================
         Item Kind                 Description
         ========================  =============================
         ``ITEM_CONTROL``          The item in the :class:`AuiToolBar` is a control
         ``ITEM_LABEL``            The item in the :class:`AuiToolBar` is a text label
         ``ITEM_SPACER``           The item in the :class:`AuiToolBar` is a spacer
         ``ITEM_SEPARATOR``        The item in the :class:`AuiToolBar` is a separator
         ``ITEM_CHECK``            The item in the :class:`AuiToolBar` is a toolbar check item
         ``ITEM_NORMAL``           The item in the :class:`AuiToolBar` is a standard toolbar item
         ``ITEM_RADIO``            The item in the :class:`AuiToolBar` is a toolbar radio item
         ========================  =============================

        :param string `short_help_string`: this string is used for the tools tooltip;
        :param string `long_help_string`: this string is shown in the statusbar (if any) of the parent
         frame when the mouse pointer is inside the tool.
        :param PyObject `client_data`: whatever Python object to associate with the toolbar item.
        :param `target`: a custom string indicating that an instance of :class:`~lib.agw.aui.framemanager.AuiPaneInfo`
         has been minimized into this toolbar.
        """
        
        item = AuiToolBarItem()
        item.window = None
        item.label = label
        item.bitmap = bitmap
        item.disabled_bitmap = disabled_bitmap
        item.short_help = short_help_string
        item.long_help = long_help_string
        item.target = target
        item.active = True
        item.dropdown = False
        item.spacer_pixels = 0

        if tool_id == wx.ID_ANY:
            tool_id = wx.NewId()
            
        item.id = tool_id
        item.state = 0
        item.proportion = 0
        item.kind = kind
        item.sizer_item = None
        item.min_size = wx.Size(-1, -1)
        item.user_data = 0
        item.sticky = False
        item.orientation = self._tool_orientation

        if not item.disabled_bitmap.IsOk():
            # no disabled bitmap specified, we need to make one
            if item.bitmap.IsOk():
                item.disabled_bitmap = MakeDisabledBitmap(item.bitmap)
        
        self._items.append(item)
        return self._items[-1]


    def AddCheckTool(self, tool_id, label, bitmap, disabled_bitmap, short_help_string="", long_help_string="", client_data=None):
        """
        Adds a new check (or toggle) tool to the :class:`AuiToolBar`.
        
        :see: :meth:`AddTool` for an explanation of the input parameters.
        """

        return self.AddTool(tool_id, label, bitmap, disabled_bitmap, ITEM_CHECK, short_help_string, long_help_string, client_data) 


    def AddRadioTool(self, tool_id, label, bitmap, disabled_bitmap, short_help_string="", long_help_string="", client_data=None):
        """
        Adds a new radio tool to the toolbar.

        Consecutive radio tools form a radio group such that exactly one button
        in the group is pressed at any moment, in other words whenever a button
        in the group is pressed the previously pressed button is automatically
        released. You should avoid having the radio groups of only one element
        as it would be impossible for the user to use such button.

        :note: By default, the first button in the radio group is initially pressed,
         the others are not.

        :see: :meth:`AddTool` for an explanation of the input parameters.
        """

        return self.AddTool(tool_id, label, bitmap, disabled_bitmap, ITEM_RADIO, short_help_string, long_help_string, client_data)

    
    def AddControl(self, control, label=""):
        """
        Adds any control to the toolbar, typically e.g. a :class:`ComboBox`.

        :param Window `control`: the control to be added;
        :param string `label`: the label which appears if the control goes into the
         overflow items in the toolbar.
        """

        item = AuiToolBarItem()
        item.window = control
        item.label = label
        item.bitmap = wx.NullBitmap
        item.disabled_bitmap = wx.NullBitmap
        item.active = True
        item.dropdown = False
        item.spacer_pixels = 0
        item.id = control.GetId()
        item.state = 0
        item.proportion = 0
        item.kind = ITEM_CONTROL
        item.sizer_item = None
        item.min_size = control.GetEffectiveMinSize()
        item.user_data = 0
        item.sticky = False
        item.orientation = self._tool_orientation

        self._items.append(item)
        return self._items[-1]


    def AddLabel(self, tool_id, label="", width=0):
        """
        Adds a label tool to the :class:`AuiToolBar`.

        :param integer `tool_id`: an integer by which the tool may be identified in subsequent operations;
        :param string `label`: the toolbar tool label;
        :param integer `width`: the tool width.
        """

        min_size = wx.Size(-1, -1)
        
        if width != -1:
            min_size.x = width

        item = AuiToolBarItem()
        item.window = None
        item.label = label
        item.bitmap = wx.NullBitmap
        item.disabled_bitmap = wx.NullBitmap
        item.active = True
        item.dropdown = False
        item.spacer_pixels = 0

        if tool_id == wx.ID_ANY:
            tool_id = wx.NewId()
        
        item.id = tool_id
        item.state = 0
        item.proportion = 0
        item.kind = ITEM_LABEL
        item.sizer_item = None
        item.min_size = min_size
        item.user_data = 0
        item.sticky = False
        item.orientation = self._tool_orientation

        self._items.append(item)
        return self._items[-1]


    def AddSeparator(self):
        """ Adds a separator for spacing groups of tools. """
        
        item = AuiToolBarItem()
        item.window = None
        item.label = ""
        item.bitmap = wx.NullBitmap
        item.disabled_bitmap = wx.NullBitmap
        item.active = True
        item.dropdown = False
        item.id = -1
        item.state = 0
        item.proportion = 0
        item.kind = ITEM_SEPARATOR
        item.sizer_item = None
        item.min_size = wx.Size(-1, -1)
        item.user_data = 0
        item.sticky = False
        item.orientation = self._tool_orientation

        self._items.append(item)
        return self._items[-1]


    def AddSpacer(self, pixels):
        """
        Adds a spacer for spacing groups of tools.

        :param integer `pixels`: the width of the spacer.
        """

        item = AuiToolBarItem()
        item.window = None
        item.label = ""
        item.bitmap = wx.NullBitmap
        item.disabled_bitmap = wx.NullBitmap
        item.active = True
        item.dropdown = False
        item.spacer_pixels = pixels
        item.id = -1
        item.state = 0
        item.proportion = 0
        item.kind = ITEM_SPACER
        item.sizer_item = None
        item.min_size = wx.Size(-1, -1)
        item.user_data = 0
        item.sticky = False
        item.orientation = self._tool_orientation

        self._items.append(item)
        return self._items[-1]


    def AddStretchSpacer(self, proportion=1):
        """
        Adds a stretchable spacer for spacing groups of tools.

        :param integer `proportion`: the stretchable spacer proportion.
        """
        
        item = AuiToolBarItem()
        item.window = None
        item.label = ""
        item.bitmap = wx.NullBitmap
        item.disabled_bitmap = wx.NullBitmap
        item.active = True
        item.dropdown = False
        item.spacer_pixels = 0
        item.id = -1
        item.state = 0
        item.proportion = proportion
        item.kind = ITEM_SPACER
        item.sizer_item = None
        item.min_size = wx.Size(-1, -1)
        item.user_data = 0
        item.sticky = False
        item.orientation = self._tool_orientation

        self._items.append(item)
        return self._items[-1]


    def Clear(self):
        """ Deletes all the tools in the :class:`AuiToolBar`. """

        self._items = []
        self._sizer_element_count = 0


    def ClearTools(self):
        """ Deletes all the tools in the :class:`AuiToolBar`. """

        self.Clear()
        

    def DeleteTool(self, tool_id):
        """
        Removes the specified tool from the toolbar and deletes it.

        :param integer `tool_id`: the :class:`AuiToolBarItem` identifier.

        :returns: ``True`` if the tool was deleted, ``False`` otherwise.
        
        :note: Note that it is unnecessary to call :meth:`Realize` for the change to
         take place, it will happen immediately.
        """

        idx = self.GetToolIndex(tool_id)
        
        if idx >= 0 and idx < len(self._items):
            self._items.pop(idx)
            self.Realize()
            return True
        
        return False


    def DeleteToolByPos(self, pos):
        """
        This function behaves like :meth:`DeleteTool` but it deletes the tool at the specified position and not the one with the given id.

        :param integer `pos`: the tool position.

        :see: :meth:`~AuiToolBar.DeleteTool`        
        """
        
        if pos >= 0 and pos < len(self._items):
            
            self._items.pop(pos)
            self.Realize()
            return True

        return False


    def FindControl(self, id):
        """
        Returns a pointer to the control identified by `id` or ``None`` if no corresponding control is found.

        :param integer `id`: the control identifier.        
        """
        
        wnd = self.FindWindow(id)
        return wnd


    def FindTool(self, tool_id):
        """
        Finds a tool for the given tool id.

        :param integer `tool_id`: the :class:`AuiToolBarItem` identifier.
        """
        
        for item in self._items:
            if item.id == tool_id:
                return item
    
        return None


    def FindToolByLabel(self, label):
        """
        Finds a tool for the given label.

        :param string `label`: the :class:`AuiToolBarItem` label.
        """
        
        for item in self._items:
            if item.label == label:
                return item
    
        return None


    def FindToolForPosition(self, x, y):
        """
        Finds a tool for the given mouse position.

        :param integer `x`: mouse `x` position;
        :param integer `y`: mouse `y` position.

        :returns: a pointer to a :class:`AuiToolBarItem` if a tool is found, or ``None`` otherwise.
        """

        for i, item in enumerate(self._items):
            if not item.sizer_item:
                continue

            rect = item.sizer_item.GetRect()
            if rect.Contains((x,y)):
            
                # if the item doesn't fit on the toolbar, return None
                if not self.GetToolFitsByIndex(i):
                    return None

                return item
            
        return None


    def HitTest(self, x, y):
        """
        Finds a tool for the given mouse position.

        :param integer `x`: mouse `x` screen position;
        :param integer `y`: mouse `y` screen position.

        :returns: a pointer to a :class:`AuiToolBarItem` if a tool is found, or ``None`` otherwise.

        :note: This method is similar to :meth:`FindToolForPosition` but it works with absolute coordinates.
        """
        
        return self.FindToolForPosition(*self.ScreenToClient((x,y)))


    def FindToolForPositionWithPacking(self, x, y):
        """
        Finds a tool for the given mouse position, taking into account also the tool packing.

        :param integer `x`: mouse `x` position;
        :param integer `y`: mouse `y` position.

        :returns: a pointer to a :class:`AuiToolBarItem` if a tool is found, or ``None`` otherwise.
        """
        
        count = len(self._items)
        
        for i, item in enumerate(self._items):
            if not item.sizer_item:
                continue

            rect = item.sizer_item.GetRect()

            # apply tool packing
            if i+1 < count:
                rect.width += self._tool_packing

            if rect.Contains((x,y)):
            
                # if the item doesn't fit on the toolbar, return None
                if not self.GetToolFitsByIndex(i):
                    return None

                return item

        return None


    def FindToolByIndex(self, pos):
        """
        Finds a tool for the given tool position in the :class:`AuiToolBar`.

        :param integer `pos`: the tool position in the toolbar.

        :returns: a pointer to a :class:`AuiToolBarItem` if a tool is found, or ``None`` otherwise.        
        """
        
        if pos < 0 or pos >= len(self._items):
            return None

        return self._items[pos]


    def SetToolBitmapSize(self, size):
        """
        Sets the default size of each tool bitmap. The default bitmap size is 16 by 15 pixels.

        :param Size `size`: the size of the bitmaps in the toolbar.

        :note: This should be called to tell the toolbar what the tool bitmap
         size is. Call it before you add tools.

        :note: Note that this is the size of the bitmap you pass to :meth:`AddTool`,
         and not the eventual size of the tool button.

        .. todo::

           Add :class:`ToolBar` compatibility, actually implementing this method.
           
        """

        # TODO: wx.ToolBar compatibility
        pass


    def GetToolBitmapSize(self):
        """
        Returns the size of bitmap that the toolbar expects to have. The default bitmap size is 16 by 15 pixels.

        :note: Note that this is the size of the bitmap you pass to :meth:`AddTool`,
         and not the eventual size of the tool button.

        .. todo::

           Add :class:`ToolBar` compatibility, actually implementing this method.
           
        """
        
        # TODO: wx.ToolBar compatibility
        return wx.Size(16, 15)


    def SetToolProportion(self, tool_id, proportion):
        """
        Sets the tool proportion in the toolbar.

        :param integer `tool_id`: the :class:`AuiToolBarItem` identifier;
        :param integer `proportion`: the tool proportion in the toolbar.
        """

        item = self.FindTool(tool_id)
        if not item:
            return

        item.proportion = proportion


    def GetToolProportion(self, tool_id):
        """
        Returns the tool proportion in the toolbar.

        :param integer `tool_id`: the :class:`AuiToolBarItem` identifier.
        """

        item = self.FindTool(tool_id)
        if not item:
            return

        return item.proportion


    def SetToolSeparation(self, separation):
        """
        Sets the separator size for the toolbar.

        :param integer `separation`: the separator size in pixels.
        """

        if self._art:
            self._art.SetElementSize(AUI_TBART_SEPARATOR_SIZE, separation)


    def GetToolSeparation(self):
        """ Returns the separator size for the toolbar, in pixels. """
        
        if self._art:
            return self._art.GetElementSize(AUI_TBART_SEPARATOR_SIZE)

        return 5


    def SetToolDropDown(self, tool_id, dropdown):
        """
        Assigns a drop down window menu to the toolbar item.

        :param integer `tool_id`: the :class:`AuiToolBarItem` identifier;
        :param bool `dropdown`: whether to assign a drop down menu or not.
        """

        item = self.FindTool(tool_id)
        if not item:
            return

        item.dropdown = dropdown


    def GetToolDropDown(self, tool_id):
        """
        Returns whether the toolbar item identified by `tool_id` has an associated drop down window menu or not.

        :param integer `tool_id`: the :class:`AuiToolBarItem` identifier.
        """

        item = self.FindTool(tool_id)
        if not item:
            return

        return item.dropdown


    def SetToolSticky(self, tool_id, sticky):
        """
        Sets the toolbar item as sticky or non-sticky.

        :param integer `tool_id`: the :class:`AuiToolBarItem` identifier;
        :param bool `sticky`: whether the tool should be sticky or not.
        """

        # ignore separators
        if tool_id == -1:
            return

        item = self.FindTool(tool_id)
        if not item:
            return

        if item.sticky == sticky:
            return

        item.sticky = sticky

        self.Refresh(False)
        self.Update()


    def GetToolSticky(self, tool_id):
        """
        Returns whether the toolbar item identified by `tool_id` has a sticky behaviour or not.

        :param integer `tool_id`: the :class:`AuiToolBarItem` identifier.
        """

        item = self.FindTool(tool_id)
        if not item:
            return

        return item.sticky


    def SetToolBorderPadding(self, padding):
        """
        Sets the padding between the tool border and the label.

        :param integer `padding`: the padding in pixels.
        """

        self._tool_border_padding = padding


    def GetToolBorderPadding(self):
        """ Returns the padding between the tool border and the label, in pixels. """

        return self._tool_border_padding


    def SetToolTextOrientation(self, orientation):
        """
        Sets the label orientation for the toolbar items.

        :param integer `orientation`: the :class:`AuiToolBarItem` label orientation.
        """

        self._tool_text_orientation = orientation

        if self._art:
            self._art.SetTextOrientation(orientation)
    

    def GetToolTextOrientation(self):
        """ Returns the label orientation for the toolbar items. """

        return self._tool_text_orientation


    def SetToolOrientation(self, orientation):
        """
        Sets the tool orientation for the toolbar items.

        :param integer `orientation`: the :class:`AuiToolBarItem` orientation.
        """

        self._tool_orientation = orientation
        if self._art:
            self._art.SetOrientation(orientation)


    def GetToolOrientation(self):
        """ Returns the orientation for the toolbar items. """

        return self._tool_orientation        


    def SetToolPacking(self, packing):
        """
        Sets the value used for spacing tools. The default value is 1 pixel.

        :param integer `packing`: the value for packing.
        """

        self._tool_packing = packing


    def GetToolPacking(self):
        """ Returns the value used for spacing tools. The default value is 1 pixel. """

        return self._tool_packing


    def SetOrientation(self, orientation):
        """
        Sets the toolbar orientation.

        :param integer `orientation`: either ``wx.VERTICAL`` or ``wx.HORIZONTAL``.

        :note: This can be temporarily overridden by :class:`~lib.agw.aui.framemanager.AuiManager` when floating and
         docking a :class:`AuiToolBar`.
        """

        pass
    

    def SetMargins(self, left=-1, right=-1, top=-1, bottom=-1):
        """
        Set the values to be used as margins for the toolbar.

        :param integer `left`: the left toolbar margin;
        :param integer `right`: the right toolbar margin;
        :param integer `top`: the top toolbar margin;
        :param integer `bottom`: the bottom toolbar margin.
        """

        if left != -1:
            self._left_padding = left
        if right != -1:
            self._right_padding = right
        if top != -1:
            self._top_padding = top
        if bottom != -1:
            self._bottom_padding = bottom


    def SetMarginsSize(self, size):
        """
        Set the values to be used as margins for the toolbar.

        :param Size `size`: the margin size (an instance of :class:`Size`).
        """
        
        self.SetMargins(size.x, size.x, size.y, size.y)


    def SetMarginsXY(self, x, y):
        """
        Set the values to be used as margins for the toolbar.
        
        :param integer `x`: left margin, right margin and inter-tool separation value;
        :param integer `y`: top margin, bottom margin and inter-tool separation value.
        """
        
        self.SetMargins(x, x, y, y)        

            
    def GetGripperVisible(self):
        """ Returns whether the toolbar gripper is visible or not. """

        return self._gripper_visible


    def SetGripperVisible(self, visible):
        """
        Sets whether the toolbar gripper is visible or not.

        :param bool `visible`: ``True`` for a visible gripper, ``False`` otherwise.
        """

        self._gripper_visible = visible
        if visible:
            self._agwStyle |= AUI_TB_GRIPPER
        else:
            self._agwStyle &= ~AUI_TB_GRIPPER
            
        self.Realize()
        self.Refresh(False)


    def GetOverflowVisible(self):
        """ Returns whether the overflow button is visible or not. """

        return self._overflow_visible


    def SetOverflowVisible(self, visible):
        """
        Sets whether the overflow button is visible or not.

        :param bool `visible`: ``True`` for a visible overflow button, ``False`` otherwise.
        """

        self._overflow_visible = visible
        if visible:
            self._agwStyle |= AUI_TB_OVERFLOW
        else:
            self._agwStyle &= ~AUI_TB_OVERFLOW

        self.Refresh(False)


    def SetFont(self, font):
        """
        Sets the :class:`AuiToolBar` font.

        :param Font `font`: the new toolbar font.

        :note: Overridden from :class:`PyControl`.
        """        

        res = wx.PyControl.SetFont(self, font)

        if self._art:
            self._art.SetFont(font)
    
        return res


    def SetHoverItem(self, pitem):
        """
        Sets a toolbar item to be currently hovered by the mouse.

        :param `pitem`: an instance of :class:`AuiToolBarItem`.
        """

        former_hover = None

        for item in self._items:
        
            if item.state & AUI_BUTTON_STATE_HOVER:
                former_hover = item
                
            item.state &= ~AUI_BUTTON_STATE_HOVER

        if pitem:
            pitem.state |= AUI_BUTTON_STATE_HOVER
        
        if former_hover != pitem:
            self.Refresh(False)
            self.Update()
        

    def SetPressedItem(self, pitem):
        """
        Sets a toolbar item to be currently in a "pressed" state.

        :param `pitem`: an instance of :class:`AuiToolBarItem`.
        """

        former_item = None

        for item in self._items:
        
            if item.state & AUI_BUTTON_STATE_PRESSED:
                former_item = item
                
            item.state &= ~AUI_BUTTON_STATE_PRESSED
        
        if pitem:
            pitem.state &= ~AUI_BUTTON_STATE_HOVER
            pitem.state |= AUI_BUTTON_STATE_PRESSED
        
        if former_item != pitem:
            self.Refresh(False)
            self.Update()
    

    def RefreshOverflowState(self):
        """ Refreshes the overflow button. """

        if not self._overflow_sizer_item:
            self._overflow_state = 0
            return
        
        overflow_state = 0
        overflow_rect = self.GetOverflowRect()

        # find out the mouse's current position
        pt = wx.GetMousePosition()
        pt = self.ScreenToClient(pt)

        # find out if the mouse cursor is inside the dropdown rectangle
        if overflow_rect.Contains((pt.x, pt.y)):

            if _VERSION_STRING < "2.9":
                leftDown = wx.GetMouseState().LeftDown()
            else:
                leftDown = wx.GetMouseState().LeftIsDown()
        
            if leftDown:
                overflow_state = AUI_BUTTON_STATE_PRESSED
            else:
                overflow_state = AUI_BUTTON_STATE_HOVER
        
        if overflow_state != self._overflow_state:
            self._overflow_state = overflow_state
            self.Refresh(False)
            self.Update()
        
        self._overflow_state = overflow_state


    def ToggleTool(self, tool_id, state):
        """
        Toggles a tool on or off. This does not cause any event to get emitted.

        :param integer `tool_id`: tool in question.
        :param bool `state`: if ``True``, toggles the tool on, otherwise toggles it off.

        :note: This only applies to a tool that has been specified as a toggle tool.
        """
        tool = self.FindTool(tool_id)
        if tool:
            if tool.kind == ITEM_RADIO:
                if state and not (tool.state & AUI_BUTTON_STATE_CHECKED):
                    tool.state |= AUI_BUTTON_STATE_CHECKED
                    items = self._items
                    index = items.index(tool)
                    for item in items[index + 1:]:
                        if item.kind != ITEM_RADIO:
                            break
                        item.state &= ~AUI_BUTTON_STATE_CHECKED
                    for item in reversed(items[:index]):
                        if item.kind != ITEM_RADIO:
                            break
                        item.state &= ~AUI_BUTTON_STATE_CHECKED
            elif tool.kind == ITEM_CHECK:
                if state:
                    tool.state |= AUI_BUTTON_STATE_CHECKED
                else:
                    tool.state &= ~AUI_BUTTON_STATE_CHECKED 

    def GetToolToggled(self, tool_id):
        """
        Returns whether a tool is toggled or not.

        :param integer `tool_id`: the toolbar item identifier.

        :note: This only applies to a tool that has been specified as a toggle tool.
        """        

        tool = self.FindTool(tool_id)

        if tool:
            if tool.kind not in [ITEM_CHECK, ITEM_RADIO]:
                return False

            return (tool.state & AUI_BUTTON_STATE_CHECKED and [True] or [False])[0]
        
        return False


    def EnableTool(self, tool_id, state):
        """
        Enables or disables the tool.

        :param integer `tool_id`: identifier for the tool to enable or disable.
        :param bool `state`: if ``True``, enables the tool, otherwise disables it.
        """

        tool = self.FindTool(tool_id)

        if tool:
        
            if state:
                tool.state &= ~AUI_BUTTON_STATE_DISABLED
            else:
                tool.state |= AUI_BUTTON_STATE_DISABLED
        

    def GetToolEnabled(self, tool_id):
        """
        Returns whether the tool identified by `tool_id` is enabled or not.

        :param integer `tool_id`: the tool identifier.
        """

        tool = self.FindTool(tool_id)

        if tool:
            return (tool.state & AUI_BUTTON_STATE_DISABLED and [False] or [True])[0]

        return False


    def GetToolLabel(self, tool_id):
        """
        Returns the tool label for the tool identified by `tool_id`.

        :param integer `tool_id`: the tool identifier.
        """

        tool = self.FindTool(tool_id)
        if not tool:
            return ""
        
        return tool.label


    def SetToolLabel(self, tool_id, label):
        """
        Sets the tool label for the tool identified by `tool_id`.

        :param integer `tool_id`: the tool identifier;
        :param string `label`: the new toolbar item label.
        """
        
        tool = self.FindTool(tool_id)
        if tool:    
            tool.label = label
    

    def GetToolBitmap(self, tool_id):
        """
        Returns the tool bitmap for the tool identified by `tool_id`.

        :param integer `tool_id`: the tool identifier.
        """
        
        tool = self.FindTool(tool_id)
        if not tool:
            return wx.NullBitmap

        return tool.bitmap


    def SetToolBitmap(self, tool_id, bitmap):
        """
        Sets the tool bitmap for the tool identified by `tool_id`.

        :param integer `tool_id`: the tool identifier;
        :param Bitmap `bitmap`: the new bitmap for the toolbar item.
        """
        
        tool = self.FindTool(tool_id)
        if tool:
            tool.bitmap = bitmap


    def SetToolNormalBitmap(self, tool_id, bitmap):
        """
        Sets the tool bitmap for the tool identified by `tool_id`.

        :param integer `tool_id`: the tool identifier;
        :param Bitmap `bitmap`: the new bitmap for the toolbar item.
        """
        
        self.SetToolBitmap(tool_id, bitmap)


    def SetToolDisabledBitmap(self, tool_id, bitmap):
        """
        Sets the tool disabled bitmap for the tool identified by `tool_id`.

        :param integer `tool_id`: the tool identifier;
        :param Bitmap `bitmap`: the new disabled bitmap for the toolbar item.
        """
        
        tool = self.FindTool(tool_id)
        if tool:
            tool.disabled_bitmap = bitmap


    def GetToolShortHelp(self, tool_id):
        """
        Returns the short help for the given tool.

        :param integer `tool_id`: the tool identifier.
        """

        tool = self.FindTool(tool_id)
        if not tool:
            return ""

        return tool.short_help


    def SetToolShortHelp(self, tool_id, help_string):
        """
        Sets the short help for the given tool.

        :param integer `tool_id`: the tool identifier;
        :param string `help_string`: the string for the short help.
        """
        
        tool = self.FindTool(tool_id)
        if tool:
            tool.short_help = help_string


    def GetToolLongHelp(self, tool_id):
        """
        Returns the long help for the given tool.

        :param integer `tool_id`: the tool identifier.
        """

        tool = self.FindTool(tool_id)
        if not tool:
            return ""

        return tool.long_help


    def SetToolAlignment(self, alignment=wx.EXPAND):
        """
        This sets the alignment for all of the tools within the toolbar
        (only has an effect when the toolbar is expanded).

        :param integer `alignment`: :class:`Sizer` alignment value
         (``wx.ALIGN_CENTER_HORIZONTAL`` or ``wx.ALIGN_CENTER_VERTICAL``).
        """

        self._tool_alignment = alignment



    def SetToolLongHelp(self, tool_id, help_string):
        """
        Sets the long help for the given tool.

        :param integer `tool_id`: the tool identifier;
        :param string `help_string`: the string for the long help.
        """
        
        tool = self.FindTool(tool_id)
        if tool:
            tool.long_help = help_string
    

    def SetCustomOverflowItems(self, prepend, append):
        """
        Sets the two lists `prepend` and `append` as custom overflow items.

        :param list `prepend`: a list of :class:`AuiToolBarItem` to be prepended;
        :param list `append`: a list of :class:`AuiToolBarItem` to be appended.
        """

        self._custom_overflow_prepend = prepend
        self._custom_overflow_append = append


    def GetToolCount(self):
        """ Returns the number of tools in the :class:`AuiToolBar`. """

        return len(self._items)


    def GetToolIndex(self, tool_id):
        """
        Returns the position of the tool in the toolbar given its identifier.

        :param integer `tool_id`: the toolbar item identifier.
        """

        # this will prevent us from returning the index of the
        # first separator in the toolbar since its id is equal to -1
        if tool_id == -1:
            return wx.NOT_FOUND

        for i, item in enumerate(self._items):
            if item.id == tool_id:
                return i
        
        return wx.NOT_FOUND


    def GetToolPos(self, tool_id):
        """
        Returns the position of the tool in the toolbar given its identifier.

        :param integer `tool_id`: the toolbar item identifier.
        """
        
        return self.GetToolIndex(tool_id)
                                

    def GetToolFitsByIndex(self, tool_id):
        """
        Returns whether the tool identified by `tool_id` fits into the toolbar or not.

        :param integer `tool_id`: the toolbar item identifier.
        """
        
        if tool_id < 0 or tool_id >= len(self._items):
            return False

        if not self._items[tool_id].sizer_item:
            return False

        cli_w, cli_h = self.GetClientSize()
        rect = self._items[tool_id].sizer_item.GetRect()

        if self._agwStyle & AUI_TB_VERTICAL:
            # take the dropdown size into account
            if self._overflow_visible:
                cli_h -= self._overflow_sizer_item.GetSize().y

            if rect.y+rect.height < cli_h:
                return True
        
        else:
        
            # take the dropdown size into account
            if self._overflow_visible:
                cli_w -= self._overflow_sizer_item.GetSize().x

            if rect.x+rect.width < cli_w:
                return True
        
        return False


    def GetToolFits(self, tool_id):
        """
        Returns whether the tool identified by `tool_id` fits into the toolbar or not.

        :param integer `tool_id`: the toolbar item identifier.
        """
        
        return self.GetToolFitsByIndex(self.GetToolIndex(tool_id))


    def GetToolRect(self, tool_id):
        """
        Returns the toolbar item rectangle

        :param integer `tool_id`: the toolbar item identifier.
        """

        tool = self.FindTool(tool_id)
        if tool and tool.sizer_item:
            return tool.sizer_item.GetRect()

        return wx.Rect()


    def GetToolBarFits(self):
        """ Returns whether the :class:`AuiToolBar` size fits in a specified size. """

        if len(self._items) == 0:
            # empty toolbar always 'fits'
            return True
        
        # entire toolbar content fits if the last tool fits
        return self.GetToolFitsByIndex(len(self._items) - 1)


    def Realize(self):
        """ Realizes the toolbar. This function should be called after you have added tools. """

        dc = wx.ClientDC(self)
        
        if not dc.IsOk():
            return False

        horizontal = True
        if self._agwStyle & AUI_TB_VERTICAL:
            horizontal = False

        # create the new sizer to add toolbar elements to
        sizer = wx.BoxSizer((horizontal and [wx.HORIZONTAL] or [wx.VERTICAL])[0])

        # add gripper area
        separator_size = self._art.GetElementSize(AUI_TBART_SEPARATOR_SIZE)
        gripper_size = self._art.GetElementSize(AUI_TBART_GRIPPER_SIZE)
        
        if gripper_size > 0 and self._gripper_visible:        
            if horizontal:
                self._gripper_sizer_item = sizer.Add((gripper_size, 1), 0, wx.EXPAND)
            else:
                self._gripper_sizer_item = sizer.Add((1, gripper_size), 0, wx.EXPAND)
        else:
            self._gripper_sizer_item = None
        
        # add "left" padding
        if self._left_padding > 0:
            if horizontal:
                sizer.Add((self._left_padding, 1))
            else:
                sizer.Add((1, self._left_padding))
        
        count = len(self._items)
        for i, item in enumerate(self._items):
        
            sizer_item = None
            kind = item.kind

            if kind == ITEM_LABEL:
                
                size = self._art.GetLabelSize(dc, self, item)
                sizer_item = sizer.Add((size.x + (self._tool_border_padding*2),
                                        size.y + (self._tool_border_padding*2)),
                                       item.proportion,
                                       item.alignment)
                if i+1 < count:
                    sizer.AddSpacer(self._tool_packing)
                

            elif kind in [ITEM_CHECK, ITEM_NORMAL, ITEM_RADIO]:
                
                size = self._art.GetToolSize(dc, self, item)
                sizer_item = sizer.Add((size.x + (self._tool_border_padding*2),
                                        size.y + (self._tool_border_padding*2)),
                                       0,
                                       item.alignment)
                # add tool packing
                if i+1 < count:
                    sizer.AddSpacer(self._tool_packing)

            elif kind == ITEM_SEPARATOR:
                
                if horizontal:
                    sizer_item = sizer.Add((separator_size, 1), 0, wx.EXPAND)
                else:
                    sizer_item = sizer.Add((1, separator_size), 0, wx.EXPAND)

                # add tool packing
                if i+1 < count:
                    sizer.AddSpacer(self._tool_packing)

            elif kind == ITEM_SPACER:
                
                if item.proportion > 0:
                    sizer_item = sizer.AddStretchSpacer(item.proportion)
                else:
                    sizer_item = sizer.Add((item.spacer_pixels, 1))
                    
            elif kind == ITEM_CONTROL:
                
                vert_sizer = wx.BoxSizer(wx.VERTICAL)
                vert_sizer.AddStretchSpacer(1)
                ctrl_sizer_item = vert_sizer.Add(item.window, 0, wx.EXPAND)
                vert_sizer.AddStretchSpacer(1)
                
                if self._agwStyle & AUI_TB_TEXT and \
                    self._tool_text_orientation == AUI_TBTOOL_TEXT_BOTTOM and \
                    item.GetLabel() != "":
                
                    s = self.GetLabelSize(item.GetLabel())
                    vert_sizer.Add((1, s.y))

                sizer_item = sizer.Add(vert_sizer, item.proportion, wx.EXPAND)
                min_size = item.min_size

                # proportional items will disappear from the toolbar if
                # their min width is not set to something really small
                if item.proportion != 0:
                    min_size.x = 1
                
                if min_size.IsFullySpecified():
                    sizer.SetItemMinSize(vert_sizer, min_size)
                    vert_sizer.SetItemMinSize(item.window, min_size)
                
                # add tool packing
                if i+1 < count:
                    sizer.AddSpacer(self._tool_packing)
                
            item.sizer_item = sizer_item
        

        # add "right" padding
        if self._right_padding > 0:
            if horizontal:
                sizer.Add((self._right_padding, 1))
            else:
                sizer.Add((1, self._right_padding))
        
        # add drop down area
        self._overflow_sizer_item = None
        if self._agwStyle & AUI_TB_OVERFLOW:
            overflow_size = self._art.GetElementSize(AUI_TBART_OVERFLOW_SIZE)
            if overflow_size > 0 and self._overflow_visible:
                if horizontal:
                    self._overflow_sizer_item = sizer.Add((overflow_size, 1), 0, wx.EXPAND)
                else:
                    self._overflow_sizer_item = sizer.Add((1, overflow_size), 0, wx.EXPAND)
            else:
                self._overflow_sizer_item = None

        # the outside sizer helps us apply the "top" and "bottom" padding
        outside_sizer = wx.BoxSizer((horizontal and [wx.VERTICAL] or [wx.HORIZONTAL])[0])

        # add "top" padding
        if self._top_padding > 0:
        
            if horizontal:
                outside_sizer.Add((1, self._top_padding))
            else:
                outside_sizer.Add((self._top_padding, 1))
        
        # add the sizer that contains all of the toolbar elements
        outside_sizer.Add(sizer, 1, self._tool_alignment)

        # add "bottom" padding
        if self._bottom_padding > 0:
        
            if horizontal:
                outside_sizer.Add((1, self._bottom_padding))
            else:
                outside_sizer.Add((self._bottom_padding, 1))

        del self._sizer # remove old sizer
        self._sizer = outside_sizer
        self.SetSizer(outside_sizer)

        # calculate the rock-bottom minimum size
        for item in self._items:
        
            if item.sizer_item and item.proportion > 0 and item.min_size.IsFullySpecified():
                item.sizer_item.SetMinSize((0, 0))
        
        self._absolute_min_size = self._sizer.GetMinSize()

        # reset the min sizes to what they were
        for item in self._items:
        
            if item.sizer_item and item.proportion > 0 and item.min_size.IsFullySpecified():
                item.sizer_item.SetMinSize(item.min_size)
        
        # set control size
        size = self._sizer.GetMinSize()
        self.SetMinSize(size)
        self._minWidth = size.x
        self._minHeight = size.y

        if self._agwStyle & AUI_TB_NO_AUTORESIZE == 0:
        
            cur_size = self.GetClientSize()
            new_size = self.GetMinSize()

            if new_size != cur_size:
            
                self.SetClientSize(new_size)
            
            else:
            
                self._sizer.SetDimension(0, 0, cur_size.x, cur_size.y)
            
        else:
        
            cur_size = self.GetClientSize()
            self._sizer.SetDimension(0, 0, cur_size.x, cur_size.y)
                    
        self.Refresh(False)
        return True

    def GetOverflowState(self):
        """ Returns the state of the overflow button. """

        return self._overflow_state

    def GetOverflowRect(self):
        """ Returns the rectangle of the overflow button. """

        cli_rect = wx.RectPS(wx.Point(0, 0), self.GetClientSize())
        overflow_rect = wx.Rect(*self._overflow_sizer_item.GetRect())
        overflow_size = self._art.GetElementSize(AUI_TBART_OVERFLOW_SIZE)

        if self._agwStyle & AUI_TB_VERTICAL:
        
            overflow_rect.y = cli_rect.height - overflow_size
            overflow_rect.x = 0
            overflow_rect.width = cli_rect.width
            overflow_rect.height = overflow_size
        
        else:
        
            overflow_rect.x = cli_rect.width - overflow_size
            overflow_rect.y = 0
            overflow_rect.width = overflow_size
            overflow_rect.height = cli_rect.height
        
        return overflow_rect


    def GetLabelSize(self, label):
        """
        Returns the standard size of a toolbar item.

        :param string `label`: a test label.
        """

        dc = wx.ClientDC(self)
        dc.SetFont(self._font)

        return GetLabelSize(dc, label, self._tool_orientation != AUI_TBTOOL_HORIZONTAL)


    def GetAuiManager(self):
        """ Returns the :class:`~lib.agw.aui.framemanager.AuiManager` which manages the toolbar. """

        return getattr(self, '_auiManager', None)


    def SetAuiManager(self, auiManager):
        """ Sets the :class:`~lib.agw.aui.framemanager.AuiManager` which manages the toolbar. """
        
        self._auiManager = auiManager        

        
    def DoIdleUpdate(self):
        """ Updates the toolbar during idle times. """

        handler = self.GetEventHandler()
        if not handler:
            return
        
        need_refresh = False

        for item in self._items:
                
            if item.id == -1:
                continue

            evt = wx.UpdateUIEvent(item.id)
            evt.SetEventObject(self)

            if handler.ProcessEvent(evt):
            
                if evt.GetSetEnabled():
                
                    if item.window:
                        is_enabled = item.window.IsEnabled()
                    else:
                        is_enabled = (item.state & AUI_BUTTON_STATE_DISABLED and [False] or [True])[0]

                    new_enabled = evt.GetEnabled()
                    if new_enabled != is_enabled:
                    
                        if item.window:
                            item.window.Enable(new_enabled)
                        else:
                            if new_enabled:
                                item.state &= ~AUI_BUTTON_STATE_DISABLED
                            else:
                                item.state |= AUI_BUTTON_STATE_DISABLED
                        
                        need_refresh = True
                    
                if evt.GetSetChecked():
                
                    # make sure we aren't checking an item that can't be
                    if item.kind != ITEM_CHECK and item.kind != ITEM_RADIO:
                        continue

                    is_checked = (item.state & AUI_BUTTON_STATE_CHECKED and [True] or [False])[0]
                    new_checked = evt.GetChecked()

                    if new_checked != is_checked:
                    
                        if new_checked:
                            item.state |= AUI_BUTTON_STATE_CHECKED
                        else:
                            item.state &= ~AUI_BUTTON_STATE_CHECKED

                        need_refresh = True
                    
        if need_refresh:
            self.Refresh(False)

        
    def OnSize(self, event):
        """
        Handles the ``wx.EVT_SIZE`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`SizeEvent` event to be processed.        
        """
        x, y = self.GetClientSize()
        realize = False

        if (x >= y and self._absolute_min_size.x > x) or (y > x and self._absolute_min_size.y > y):
            # hide all flexible items
            for item in self._items:
                if item.sizer_item and item.proportion > 0 and item.sizer_item.IsShown():
                    item.sizer_item.Show(False)
                    item.sizer_item.SetProportion(0)

            if self._originalStyle & AUI_TB_OVERFLOW:
                if not self.GetOverflowVisible():
                    self.SetOverflowVisible(True)
                    realize = True
                       
        else:
            if self._originalStyle & AUI_TB_OVERFLOW and not self._custom_overflow_append and \
               not self._custom_overflow_prepend:
                if self.GetOverflowVisible():
                    self.SetOverflowVisible(False)
                    realize = True

            # show all flexible items
            for item in self._items:
                if item.sizer_item and item.proportion > 0 and not item.sizer_item.IsShown():
                    item.sizer_item.Show(True)
                    item.sizer_item.SetProportion(item.proportion)
                
        self._sizer.SetDimension(0, 0, x, y)

        if realize:
            self.Realize()
        else:
            self.Refresh(False)
            
        self.Update()

        
    def DoSetSize(self, x, y, width, height, sizeFlags=wx.SIZE_AUTO):
        """        
        Sets the position and size of the window in pixels. The `sizeFlags`
        parameter indicates the interpretation of the other params if they are
        equal to -1.

        :param integer `x`: the window `x` position;
        :param integer `y`: the window `y` position;
        :param integer `width`: the window width;
        :param integer `height`: the window height;
        :param integer `sizeFlags`: may have one of this bit set:
   
         ===================================  ======================================
         Size Flags                           Description
         ===================================  ======================================
         ``wx.SIZE_AUTO``                     A -1 indicates that a class-specific default should be used.
         ``wx.SIZE_AUTO_WIDTH``               A -1 indicates that a class-specific default should be used for the width.
         ``wx.SIZE_AUTO_HEIGHT``              A -1 indicates that a class-specific default should be used for the height.
         ``wx.SIZE_USE_EXISTING``             Existing dimensions should be used if -1 values are supplied.
         ``wx.SIZE_ALLOW_MINUS_ONE``          Allow dimensions of -1 and less to be interpreted as real dimensions, not default values.
         ``wx.SIZE_FORCE``                    Normally, if the position and the size of the window are already the same as the
                                              parameters of this function, nothing is done. but with this flag a window resize may
                                              be forced even in this case (supported in wx 2.6.2 and later and only implemented
                                              for MSW and ignored elsewhere currently) 
         ===================================  ======================================

        :note: Overridden from :class:`PyControl`.
        """
        
        parent_size = self.GetParent().GetClientSize()
        if x + width > parent_size.x:
            width = max(0, parent_size.x - x)
        if y + height > parent_size.y:
            height = max(0, parent_size.y - y)

        wx.PyControl.DoSetSize(self, x, y, width, height, sizeFlags)


    def OnIdle(self, event):
        """
        Handles the ``wx.EVT_IDLE`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`IdleEvent` event to be processed.        
        """
        
        self.DoIdleUpdate()
        event.Skip()


    def DoGetBestSize(self):
        """
        Gets the size which best suits the window: for a control, it would be the
        minimal size which doesn't truncate the control, for a panel - the same
        size as it would have after a call to `Fit()`.
        
        :note: Overridden from :class:`PyControl`.
        """
        return self._absolute_min_size
    

    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`PaintEvent` event to be processed.        
        """
        dc = wx.AutoBufferedPaintDC(self)
        cli_rect = wx.RectPS(wx.Point(0, 0), self.GetClientSize())

        horizontal = True
        if self._agwStyle & AUI_TB_VERTICAL:
            horizontal = False

        if self._agwStyle & AUI_TB_PLAIN_BACKGROUND:
            self._art.DrawPlainBackground(dc, self, cli_rect)
        else:
            self._art.DrawBackground(dc, self, cli_rect, horizontal)

        gripper_size = self._art.GetElementSize(AUI_TBART_GRIPPER_SIZE)
        dropdown_size = self._art.GetElementSize(AUI_TBART_OVERFLOW_SIZE)

        # paint the gripper
        if self._agwStyle & AUI_TB_GRIPPER and gripper_size > 0 and self._gripper_sizer_item:
            gripper_rect = wx.Rect(*self._gripper_sizer_item.GetRect())
            if horizontal:
                gripper_rect.width = gripper_size
            else:
                gripper_rect.height = gripper_size
                
            self._art.DrawGripper(dc, self, gripper_rect)
        
        # calculated how far we can draw items
        if horizontal:
            last_extent = cli_rect.width
        else:
            last_extent = cli_rect.height
            
        if self._overflow_visible:
            last_extent -= dropdown_size

        # paint each individual tool
        for item in self._items:

            if not item.sizer_item:
                continue

            item_rect = wx.Rect(*item.sizer_item.GetRect())

            if (horizontal and item_rect.x + item_rect.width >= last_extent) or \
               (not horizontal and item_rect.y + item_rect.height >= last_extent):

                break
            
            if item.kind == ITEM_SEPARATOR:
                # draw a separator
                self._art.DrawSeparator(dc, self, item_rect)
            
            elif item.kind == ITEM_LABEL:
                # draw a text label only
                self._art.DrawLabel(dc, self, item, item_rect)
            
            elif item.kind == ITEM_NORMAL:
                # draw a regular button or dropdown button
                if not item.dropdown:
                    self._art.DrawButton(dc, self, item, item_rect)
                else:
                    self._art.DrawDropDownButton(dc, self, item, item_rect)
            
            elif item.kind == ITEM_CHECK:
                # draw a regular toggle button or a dropdown one
                if not item.dropdown:
                    self._art.DrawButton(dc, self, item, item_rect)
                else:
                    self._art.DrawDropDownButton(dc, self, item, item_rect)

            elif item.kind == ITEM_RADIO:
                # draw a toggle button
                self._art.DrawButton(dc, self, item, item_rect)
            
            elif item.kind == ITEM_CONTROL:
                # draw the control's label
                self._art.DrawControlLabel(dc, self, item, item_rect)
            
            # fire a signal to see if the item wants to be custom-rendered
            self.OnCustomRender(dc, item, item_rect)
        
        # paint the overflow button
        if dropdown_size > 0 and self._overflow_sizer_item:
            dropdown_rect = self.GetOverflowRect()
            self._art.DrawOverflowButton(dc, self, dropdown_rect, self._overflow_state)

        
    def OnEraseBackground(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`EraseEvent` event to be processed.

        :note: This is intentionally empty, to reduce flicker.
        """

        pass
    

    def OnLeftDown(self, event):
        """
        Handles the ``wx.EVT_LEFT_DOWN`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`MouseEvent` event to be processed.        
        """
        
        cli_rect = wx.RectPS(wx.Point(0, 0), self.GetClientSize())
        self.StopPreviewTimer()

        if self._gripper_sizer_item:
        
            gripper_rect = wx.Rect(*self._gripper_sizer_item.GetRect())
            if gripper_rect.Contains(event.GetPosition()):
            
                # find aui manager
                manager = self.GetAuiManager()
                if not manager:
                    return

                x_drag_offset = event.GetX() - gripper_rect.GetX()
                y_drag_offset = event.GetY() - gripper_rect.GetY()

                clientPt = wx.Point(*event.GetPosition())
                screenPt = self.ClientToScreen(clientPt)
                managedWindow = manager.GetManagedWindow()
                managerClientPt = managedWindow.ScreenToClient(screenPt)

                # gripper was clicked
                manager.OnGripperClicked(self, managerClientPt, wx.Point(x_drag_offset, y_drag_offset))            
                return

        if self._overflow_sizer_item:
            overflow_rect = self.GetOverflowRect()

            if self._art and self._overflow_visible and overflow_rect.Contains(event.GetPosition()):
            
                e = AuiToolBarEvent(wxEVT_COMMAND_AUITOOLBAR_OVERFLOW_CLICK, -1)
                e.SetEventObject(self)
                e.SetToolId(-1)
                e.SetClickPoint(event.GetPosition())
                processed = self.ProcessEvent(e)

                if processed:
                    self.DoIdleUpdate()
                else:                
                    overflow_items = []

                    # add custom overflow prepend items, if any
                    count = len(self._custom_overflow_prepend)
                    for i in xrange(count):
                        overflow_items.append(self._custom_overflow_prepend[i])

                    # only show items that don't fit in the dropdown
                    count = len(self._items)
                    for i in xrange(count):
                    
                        if not self.GetToolFitsByIndex(i):
                            overflow_items.append(self._items[i])
                    
                    # add custom overflow append items, if any
                    count = len(self._custom_overflow_append)
                    for i in xrange(count):
                        overflow_items.append(self._custom_overflow_append[i])

                    res = self._art.ShowDropDown(self, overflow_items)
                    self._overflow_state = 0
                    self.Refresh(False)
                    if res != -1:
                        e = wx.CommandEvent(wx.wxEVT_COMMAND_MENU_SELECTED, res)
                        e.SetEventObject(self)
                        if not self.GetParent().ProcessEvent(e):
                            tool = self.FindTool(res)
                            if tool:
                                state = (tool.state & AUI_BUTTON_STATE_CHECKED and [True] or [False])[0]
                                self.ToggleTool(res, not state)
                    
                return
            
        self._dragging = False
        self._action_pos = wx.Point(*event.GetPosition())
        self._action_item = self.FindToolForPosition(*event.GetPosition())

        if self._action_item:
        
            if self._action_item.state & AUI_BUTTON_STATE_DISABLED:
            
                self._action_pos = wx.Point(-1, -1)
                self._action_item = None
                return
            
            self.SetPressedItem(self._action_item)

            # fire the tool dropdown event
            e = AuiToolBarEvent(wxEVT_COMMAND_AUITOOLBAR_TOOL_DROPDOWN, self._action_item.id)
            e.SetEventObject(self)
            e.SetToolId(self._action_item.id)
            e.SetDropDownClicked(False)

            mouse_x, mouse_y = event.GetX(), event.GetY()
            rect = wx.Rect(*self._action_item.sizer_item.GetRect())

            if self._action_item.dropdown:
                if (self._action_item.orientation == AUI_TBTOOL_HORIZONTAL and \
                    mouse_x >= (rect.x+rect.width-BUTTON_DROPDOWN_WIDTH-1) and \
                    mouse_x < (rect.x+rect.width)) or \
                    (self._action_item.orientation != AUI_TBTOOL_HORIZONTAL and \
                     mouse_y >= (rect.y+rect.height-BUTTON_DROPDOWN_WIDTH-1) and \
                     mouse_y < (rect.y+rect.height)):
                    
                    e.SetDropDownClicked(True)            
            
            e.SetClickPoint(event.GetPosition())
            e.SetItemRect(rect)
            self.ProcessEvent(e)
            self.DoIdleUpdate()
        

    def OnLeftUp(self, event):
        """
        Handles the ``wx.EVT_LEFT_UP`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`MouseEvent` event to be processed.        
        """
        
        self.SetPressedItem(None)

        hit_item = self.FindToolForPosition(*event.GetPosition())
        
        if hit_item and not hit_item.state & AUI_BUTTON_STATE_DISABLED:
            self.SetHoverItem(hit_item)

        if self._dragging:
            # reset drag and drop member variables
            self._dragging = False
            self._action_pos = wx.Point(-1, -1)
            self._action_item = None
        
        else:

            if self._action_item and hit_item == self._action_item:
                self.SetToolTipString("")

                if hit_item.kind in [ITEM_CHECK, ITEM_RADIO]:
                    toggle = not (self._action_item.state & AUI_BUTTON_STATE_CHECKED)
                    self.ToggleTool(self._action_item.id, toggle)

                    # repaint immediately
                    self.Refresh(False)
                    self.Update()
                    
                    e = wx.CommandEvent(wx.wxEVT_COMMAND_MENU_SELECTED, self._action_item.id)
                    e.SetEventObject(self)
                    e.SetInt(toggle)
                    self._action_pos = wx.Point(-1, -1)
                    self._action_item = None
                    
                    self.ProcessEvent(e)
                    self.DoIdleUpdate()
                    
                else:

                    if self._action_item.id == ID_RESTORE_FRAME:
                        # find aui manager
                        manager = self.GetAuiManager()

                        if not manager:
                            return

                        if self._action_item.target:
                            pane = manager.GetPane(self._action_item.target)
                        else:
                            pane = manager.GetPane(self)
                            
                        e = framemanager.AuiManagerEvent(framemanager.wxEVT_AUI_PANE_MIN_RESTORE)

                        e.SetManager(manager)
                        e.SetPane(pane)

                        manager.ProcessEvent(e)
                        self.DoIdleUpdate()

                    else:

                        e = wx.CommandEvent(wx.wxEVT_COMMAND_MENU_SELECTED, self._action_item.id)
                        e.SetEventObject(self)
                        self.ProcessEvent(e)
                        self.DoIdleUpdate()
                
        # reset drag and drop member variables
        self._dragging = False
        self._action_pos = wx.Point(-1, -1)
        self._action_item = None


    def OnRightDown(self, event):
        """
        Handles the ``wx.EVT_RIGHT_DOWN`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`MouseEvent` event to be processed.        
        """
        
        cli_rect = wx.RectPS(wx.Point(0, 0), self.GetClientSize())

        if self._gripper_sizer_item:
            gripper_rect = self._gripper_sizer_item.GetRect()
            if gripper_rect.Contains(event.GetPosition()):
                return
        
        if self._overflow_sizer_item:
        
            dropdown_size = self._art.GetElementSize(AUI_TBART_OVERFLOW_SIZE)
            if dropdown_size > 0 and event.GetX() > cli_rect.width - dropdown_size and \
               event.GetY() >= 0 and event.GetY() < cli_rect.height and self._art:
                return
            
        self._action_pos = wx.Point(*event.GetPosition())
        self._action_item = self.FindToolForPosition(*event.GetPosition())

        if self._action_item:
            if self._action_item.state & AUI_BUTTON_STATE_DISABLED:
            
                self._action_pos = wx.Point(-1, -1)
                self._action_item = None
                return


    def OnRightUp(self, event):
        """
        Handles the ``wx.EVT_RIGHT_UP`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`MouseEvent` event to be processed.        
        """
        
        hit_item = self.FindToolForPosition(*event.GetPosition())

        if self._action_item and hit_item == self._action_item:
            
            e = AuiToolBarEvent(wxEVT_COMMAND_AUITOOLBAR_RIGHT_CLICK, self._action_item.id)
            e.SetEventObject(self)
            e.SetToolId(self._action_item.id)
            e.SetClickPoint(self._action_pos)
            self.ProcessEvent(e)
            self.DoIdleUpdate()
            
        else:
        
            # right-clicked on the invalid area of the toolbar
            e = AuiToolBarEvent(wxEVT_COMMAND_AUITOOLBAR_RIGHT_CLICK, -1)
            e.SetEventObject(self)
            e.SetToolId(-1)
            e.SetClickPoint(self._action_pos)
            self.ProcessEvent(e)
            self.DoIdleUpdate()
        
        # reset member variables
        self._action_pos = wx.Point(-1, -1)
        self._action_item = None


    def OnMiddleDown(self, event):
        """
        Handles the ``wx.EVT_MIDDLE_DOWN`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`MouseEvent` event to be processed.        
        """
        
        cli_rect = wx.RectPS(wx.Point(0, 0), self.GetClientSize())

        if self._gripper_sizer_item:
        
            gripper_rect = self._gripper_sizer_item.GetRect()
            if gripper_rect.Contains(event.GetPosition()):
                return
        
        if self._overflow_sizer_item:
        
            dropdown_size = self._art.GetElementSize(AUI_TBART_OVERFLOW_SIZE)
            if dropdown_size > 0 and event.GetX() > cli_rect.width - dropdown_size and \
               event.GetY() >= 0 and event.GetY() < cli_rect.height and self._art:            
                return
            
        self._action_pos = wx.Point(*event.GetPosition())
        self._action_item = self.FindToolForPosition(*event.GetPosition())

        if self._action_item:
            if self._action_item.state & AUI_BUTTON_STATE_DISABLED:
            
                self._action_pos = wx.Point(-1, -1)
                self._action_item = None
                return


    def OnMiddleUp(self, event):
        """
        Handles the ``wx.EVT_MIDDLE_UP`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`MouseEvent` event to be processed.        
        """
        
        hit_item = self.FindToolForPosition(*event.GetPosition())

        if self._action_item and hit_item == self._action_item:        
            if hit_item.kind == ITEM_NORMAL:
            
                e = AuiToolBarEvent(wxEVT_COMMAND_AUITOOLBAR_MIDDLE_CLICK, self._action_item.id)
                e.SetEventObject(self)
                e.SetToolId(self._action_item.id)
                e.SetClickPoint(self._action_pos)
                self.ProcessEvent(e)
                self.DoIdleUpdate()
            
        # reset member variables
        self._action_pos = wx.Point(-1, -1)
        self._action_item = None


    def OnMotion(self, event):
        """
        Handles the ``wx.EVT_MOTION`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`MouseEvent` event to be processed.        
        """
        
        # start a drag event
        if not self._dragging and self._action_item != None and self._action_pos != wx.Point(-1, -1) and \
           abs(event.GetX() - self._action_pos.x) + abs(event.GetY() - self._action_pos.y) > 5:
        
            self.SetToolTipString("")
            self._dragging = True

            e = AuiToolBarEvent(wxEVT_COMMAND_AUITOOLBAR_BEGIN_DRAG, self.GetId())
            e.SetEventObject(self)
            e.SetToolId(self._action_item.id)
            self.ProcessEvent(e)
            self.DoIdleUpdate()
            return
        
        hit_item = self.FindToolForPosition(*event.GetPosition())
        
        if hit_item:        
            if not hit_item.state & AUI_BUTTON_STATE_DISABLED:
                self.SetHoverItem(hit_item)
            else:
                self.SetHoverItem(None)
        
        else:        
            # no hit item, remove any hit item
            self.SetHoverItem(hit_item)
        
        # figure out tooltips
        packing_hit_item = self.FindToolForPositionWithPacking(*event.GetPosition())
        
        if packing_hit_item:
        
            if packing_hit_item != self._tip_item:
                self._tip_item = packing_hit_item

                if packing_hit_item.short_help != "":
                    self.StartPreviewTimer()
                    self.SetToolTipString(packing_hit_item.short_help)
                else:
                    self.SetToolTipString("")
                    self.StopPreviewTimer()
            
        else:
        
            self.SetToolTipString("")
            self._tip_item = None
            self.StopPreviewTimer()
        
        # if we've pressed down an item and we're hovering
        # over it, make sure it's state is set to pressed
        if self._action_item:
        
            if self._action_item == hit_item:
                self.SetPressedItem(self._action_item)
            else:
                self.SetPressedItem(None)
        
        # figure out the dropdown button state (are we hovering or pressing it?)
        self.RefreshOverflowState()


    def OnLeaveWindow(self, event):
        """
        Handles the ``wx.EVT_LEAVE_WINDOW`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`MouseEvent` event to be processed.        
        """

        self.RefreshOverflowState()
        self.SetHoverItem(None)
        self.SetPressedItem(None)

        self._tip_item = None
        self.StopPreviewTimer()


    def OnSetCursor(self, event):
        """
        Handles the ``wx.EVT_SET_CURSOR`` event for :class:`AuiToolBar`.

        :param `event`: a :class:`SetCursorEvent` event to be processed.        
        """
        
        cursor = wx.NullCursor

        if self._gripper_sizer_item:
        
            gripper_rect = self._gripper_sizer_item.GetRect()
            if gripper_rect.Contains((event.GetX(), event.GetY())):
                cursor = wx.StockCursor(wx.CURSOR_SIZING)
            
        event.SetCursor(cursor)


    def OnCustomRender(self, dc, item, rect):
        """
        Handles custom render for single :class:`AuiToolBar` items.
        
        :param `dc`: a :class:`DC` device context;
        :param `item`: an instance of :class:`AuiToolBarItem`;
        :param Rect `rect`: the toolbar item rect.

        :note: This method must be overridden to provide custom rendering of items.
        """
        
        pass


    def IsPaneMinimized(self):
        """ Returns whether this :class:`AuiToolBar` contains a minimized pane tool. """
        
        manager = self.GetAuiManager()
        if not manager:
            return False
        
        if manager.GetAGWFlags() & AUI_MGR_PREVIEW_MINIMIZED_PANES == 0:
            # No previews here
            return False

        self_name = manager.GetPane(self).name
        
        if not self_name.endswith("_min"):
            # Wrong tool name
            return False

        return self_name[0:-4]
    
        
    def StartPreviewTimer(self):
        """ Starts a timer in :class:`~lib.agw.aui.framemanager.AuiManager` to slide-in/slide-out the minimized pane. """

        self_name = self.IsPaneMinimized()
        if not self_name:
            return

        manager = self.GetAuiManager()        
        manager.StartPreviewTimer(self)


    def StopPreviewTimer(self):
        """ Stops a timer in :class:`~lib.agw.aui.framemanager.AuiManager` to slide-in/slide-out the minimized pane. """

        self_name = self.IsPaneMinimized()
        if not self_name:
            return

        manager = self.GetAuiManager()        
        manager.StopPreviewTimer()
            

########NEW FILE########
__FILENAME__ = auibook
"""
`auibook.py` contains a notebook control which implements many features common in
applications with dockable panes. Specifically, :class:`AuiNotebook` implements functionality
which allows the user to rearrange tab order via drag-and-drop, split the tab window
into many different splitter configurations, and toggle through different themes to
customize the control's look and feel.

An effort has been made to try to maintain an API as similar to that of :class:`Notebook`.

The default theme that is used is :class:`~lib.agw.aui.tabart.AuiDefaultTabArt`, which provides a modern, glossy
look and feel. The theme can be changed by calling :meth:`AuiNotebook.SetArtProvider() <AuiNotebook.SetArtProvider>`.
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx
import types
import datetime

from wx.lib.expando import ExpandoTextCtrl

import framemanager
import tabart as TA

from aui_utilities import LightColour, MakeDisabledBitmap, TabDragImage
from aui_utilities import TakeScreenShot, RescaleScreenShot

from aui_constants import *

# AuiNotebook events
wxEVT_COMMAND_AUINOTEBOOK_PAGE_CLOSE = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_PAGE_CLOSED = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGED = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BUTTON = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BEGIN_DRAG = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_END_DRAG = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_DRAG_MOTION = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_ALLOW_DND = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_DRAG_DONE = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_DOWN = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_UP = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_DOWN = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_UP = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_TAB_DCLICK = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BG_MIDDLE_DOWN = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BG_MIDDLE_UP = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BG_RIGHT_DOWN = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BG_RIGHT_UP = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_BG_DCLICK = wx.NewEventType()

# Define a new event for a drag cancelled
wxEVT_COMMAND_AUINOTEBOOK_CANCEL_DRAG = wx.NewEventType()

# Define events for editing a tab label
wxEVT_COMMAND_AUINOTEBOOK_BEGIN_LABEL_EDIT = wx.NewEventType()
wxEVT_COMMAND_AUINOTEBOOK_END_LABEL_EDIT = wx.NewEventType()

# Create event binders
EVT_AUINOTEBOOK_PAGE_CLOSE = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CLOSE, 1)
""" A tab in `AuiNotebook` is being closed. Can be vetoed by calling `Veto()`. """
EVT_AUINOTEBOOK_PAGE_CLOSED = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CLOSED, 1)
""" A tab in `AuiNotebook` has been closed. """
EVT_AUINOTEBOOK_PAGE_CHANGED = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGED, 1)
""" The page selection was changed. """
EVT_AUINOTEBOOK_PAGE_CHANGING = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, 1)
""" The page selection is being changed. """
EVT_AUINOTEBOOK_BUTTON = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BUTTON, 1)
""" The user clicked on a button in the `AuiNotebook` tab area. """
EVT_AUINOTEBOOK_BEGIN_DRAG = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BEGIN_DRAG, 1)
""" A drag-and-drop operation on a notebook tab has started. """
EVT_AUINOTEBOOK_END_DRAG = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_END_DRAG, 1)
""" A drag-and-drop operation on a notebook tab has finished. """
EVT_AUINOTEBOOK_DRAG_MOTION = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_DRAG_MOTION, 1)
""" A drag-and-drop operation on a notebook tab is ongoing. """
EVT_AUINOTEBOOK_ALLOW_DND = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_ALLOW_DND, 1)
""" Fires an event asking if it is OK to drag and drop a tab. """
EVT_AUINOTEBOOK_DRAG_DONE = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_DRAG_DONE, 1)
""" A drag-and-drop operation on a notebook tab has finished. """
EVT_AUINOTEBOOK_TAB_MIDDLE_DOWN = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_DOWN, 1)
""" The user clicked with the middle mouse button on a tab. """
EVT_AUINOTEBOOK_TAB_MIDDLE_UP = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_UP, 1)
""" The user clicked with the middle mouse button on a tab. """
EVT_AUINOTEBOOK_TAB_RIGHT_DOWN = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_DOWN, 1)
""" The user clicked with the right mouse button on a tab. """
EVT_AUINOTEBOOK_TAB_RIGHT_UP = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_UP, 1)
""" The user clicked with the right mouse button on a tab. """
EVT_AUINOTEBOOK_BG_MIDDLE_DOWN = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BG_MIDDLE_DOWN, 1)
""" The user middle-clicked in the tab area but not over a tab or a button. """
EVT_AUINOTEBOOK_BG_MIDDLE_UP = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BG_MIDDLE_UP, 1)
""" The user middle-clicked in the tab area but not over a tab or a button. """
EVT_AUINOTEBOOK_BG_RIGHT_DOWN = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BG_RIGHT_DOWN, 1)
""" The user right-clicked in the tab area but not over a tab or a button. """
EVT_AUINOTEBOOK_BG_RIGHT_UP = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BG_RIGHT_UP, 1)
""" The user right-clicked in the tab area but not over a tab or a button. """
EVT_AUINOTEBOOK_BG_DCLICK = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BG_DCLICK, 1)
""" The user left-clicked on the tab area not occupied by `AuiNotebook` tabs. """
EVT_AUINOTEBOOK_CANCEL_DRAG = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_CANCEL_DRAG, 1)
""" A drag and drop operation has been cancelled. """
EVT_AUINOTEBOOK_TAB_DCLICK = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_TAB_DCLICK, 1)
""" The user double-clicked with the left mouse button on a tab. """
EVT_AUINOTEBOOK_BEGIN_LABEL_EDIT = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_BEGIN_LABEL_EDIT, 1)
""" The user double-clicked with the left mouse button on a tab which text is editable. """
EVT_AUINOTEBOOK_END_LABEL_EDIT = wx.PyEventBinder(wxEVT_COMMAND_AUINOTEBOOK_END_LABEL_EDIT, 1)
""" The user finished editing a tab label. """


# -----------------------------------------------------------------------------
# Auxiliary class: TabTextCtrl
# This is the temporary ExpandoTextCtrl created when you edit the text of a tab
# -----------------------------------------------------------------------------

class TabTextCtrl(ExpandoTextCtrl):
    """ Control used for in-place edit. """

    def __init__(self, owner, tab, page_index):
        """
        Default class constructor.
        For internal use: do not call it in your code!

        :param `owner`: the :class:`AuiNotebook` owning the tab;
        :param `tab`: the actual :class:`AuiTabCtrl` tab;
        :param integer `page_index`: the :class:`AuiTabContainer` page index for the tab.
        """

        self._owner = owner
        self._tabEdited = tab
        self._pageIndex = page_index
        self._startValue = tab.caption
        self._finished = False
        self._aboutToFinish = False
        self._currentValue = self._startValue

        x, y, w, h = self._tabEdited.rect

        wnd = self._tabEdited.control
        if wnd:
            x += wnd.GetSize()[0] + 2
            h = 0

        image_h = 0
        image_w = 0

        image = tab.bitmap

        if image.IsOk():
            image_w, image_h = image.GetWidth(), image.GetHeight()
            image_w += 6

        dc = wx.ClientDC(self._owner)
        h = max(image_h, dc.GetMultiLineTextExtent(tab.caption)[1])
        h = h + 2

        # FIXME: what are all these hardcoded 4, 8 and 11s really?
        x += image_w
        w -= image_w + 4

        y = (self._tabEdited.rect.height - h)/2 + 1

        expandoStyle = wx.WANTS_CHARS
        if wx.Platform in ["__WXGTK__", "__WXMAC__"]:
            expandoStyle |= wx.SIMPLE_BORDER
            xSize, ySize = w + 2, h
        else:
            expandoStyle |= wx.SUNKEN_BORDER
            xSize, ySize = w + 2, h+2

        ExpandoTextCtrl.__init__(self, self._owner, wx.ID_ANY, self._startValue,
                                 wx.Point(x, y), wx.Size(xSize, ySize),
                                 expandoStyle)

        if wx.Platform == "__WXMAC__":
            self.SetFont(owner.GetFont())
            bs = self.GetBestSize()
            self.SetSize((-1, bs.height))

        self.Bind(wx.EVT_CHAR, self.OnChar)
        self.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        self.Bind(wx.EVT_KILL_FOCUS, self.OnKillFocus)


    def AcceptChanges(self):
        """ Accepts/refuses the changes made by the user. """

        value = self.GetValue()
        notebook = self._owner.GetParent()

        if value == self._startValue:
            # nothing changed, always accept
            # when an item remains unchanged, the owner
            # needs to be notified that the user decided
            # not to change the tree item label, and that
            # the edit has been cancelled
            notebook.OnRenameCancelled(self._pageIndex)
            return True

        if not notebook.OnRenameAccept(self._pageIndex, value):
            # vetoed by the user
            return False

        # accepted, do rename the item
        notebook.SetPageText(self._pageIndex, value)

        return True


    def Finish(self):
        """ Finish editing. """

        if not self._finished:

            notebook = self._owner.GetParent()

            self._finished = True
            self._owner.SetFocus()
            notebook.ResetTextControl()


    def OnChar(self, event):
        """
        Handles the ``wx.EVT_CHAR`` event for :class:`TabTextCtrl`.

        :param `event`: a :class:`KeyEvent` event to be processed.
        """

        keycode = event.GetKeyCode()
        shiftDown = event.ShiftDown()

        if keycode == wx.WXK_RETURN:
            if shiftDown and self._tabEdited.IsMultiline():
                event.Skip()
            else:
                self._aboutToFinish = True
                self.SetValue(self._currentValue)
                # Notify the owner about the changes
                self.AcceptChanges()
                # Even if vetoed, close the control (consistent with MSW)
                wx.CallAfter(self.Finish)

        elif keycode == wx.WXK_ESCAPE:
            self.StopEditing()

        else:
            event.Skip()


    def OnKeyUp(self, event):
        """
        Handles the ``wx.EVT_KEY_UP`` event for :class:`TabTextCtrl`.

        :param `event`: a :class:`KeyEvent` event to be processed.
        """

        if not self._finished:

            # auto-grow the textctrl:
            mySize = self.GetSize()

            dc = wx.ClientDC(self)
            sx, sy, dummy = dc.GetMultiLineTextExtent(self.GetValue() + "M")

            self.SetSize((sx, -1))
            self._currentValue = self.GetValue()

        event.Skip()


    def OnKillFocus(self, event):
        """
        Handles the ``wx.EVT_KILL_FOCUS`` event for :class:`TabTextCtrl`.

        :param `event`: a :class:`FocusEvent` event to be processed.
        """

        if not self._finished and not self._aboutToFinish:

            # We must finish regardless of success, otherwise we'll get
            # focus problems:
            if not self.AcceptChanges():
                self._owner.GetParent().OnRenameCancelled(self._pageIndex)

        # We must let the native text control handle focus, too, otherwise
        # it could have problems with the cursor (e.g., in wxGTK).
        event.Skip()
        wx.CallAfter(self._owner.GetParent().ResetTextControl)


    def StopEditing(self):
        """ Suddenly stops the editing. """

        self._owner.GetParent().OnRenameCancelled(self._pageIndex)
        self.Finish()


    def item(self):
        """ Returns the item currently edited. """

        return self._tabEdited


# ----------------------------------------------------------------------

class AuiNotebookPage(object):
    """
    A simple class which holds information about tab captions, bitmaps and
    colours.
    """

    def __init__(self):
        """
        Default class constructor.
        Used internally, do not call it in your code!
        """

        self.window = None              # page's associated window
        self.caption = ""               # caption displayed on the tab
        self.bitmap = wx.NullBitmap     # tab's bitmap
        self.dis_bitmap = wx.NullBitmap # tab's disabled bitmap
        self.rect = wx.Rect()           # tab's hit rectangle
        self.active = False             # True if the page is currently active
        self.enabled = True             # True if the page is currently enabled
        self.hasCloseButton = True      # True if the page has a close button using the style
                                        # AUI_NB_CLOSE_ON_ALL_TABS
        self.control = None             # A control can now be inside a tab
        self.renamable = False          # If True, a tab can be renamed by a left double-click

        self.text_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_BTNTEXT)

        self.access_time = datetime.datetime.now() # Last time this page was selected


    def IsMultiline(self):
        """ Returns whether the tab contains multiline text. """

        return "\n" in self.caption


# ----------------------------------------------------------------------

class AuiTabContainerButton(object):
    """
    A simple class which holds information about tab buttons and their state.
    """

    def __init__(self):
        """
        Default class constructor.
        Used internally, do not call it in your code!
        """

        self.id = -1                                      # button's id
        self.cur_state = AUI_BUTTON_STATE_NORMAL          # current state (normal, hover, pressed, etc.)
        self.location = wx.LEFT                           # buttons location (wxLEFT, wxRIGHT, or wxCENTER)
        self.bitmap = wx.NullBitmap                       # button's hover bitmap
        self.dis_bitmap = wx.NullBitmap                   # button's disabled bitmap
        self.rect = wx.Rect()                             # button's hit rectangle


# ----------------------------------------------------------------------

class CommandNotebookEvent(wx.PyCommandEvent):
    """ A specialized command event class for events sent by :class:`AuiNotebook` . """

    def __init__(self, command_type=None, win_id=0):
        """
        Default class constructor.

        :param `command_type`: the event kind or an instance of :class:`PyCommandEvent`.
        :param integer `win_id`: the window identification number.
        """

        if type(command_type) == types.IntType:
            wx.PyCommandEvent.__init__(self, command_type, win_id)
        else:
            wx.PyCommandEvent.__init__(self, command_type.GetEventType(), command_type.GetId())

        self.old_selection = -1
        self.selection = -1
        self.drag_source = None
        self.dispatched = 0
        self.label = ""
        self.editCancelled = False
        self.page = None


    def SetSelection(self, s):
        """
        Sets the selection member variable.

        :param integer `s`: the new selection.
        """

        self.selection = s
        self._commandInt = s


    def GetSelection(self):
        """ Returns the currently selected page, or -1 if none was selected. """

        return self.selection


    def SetOldSelection(self, s):
        """
        Sets the id of the page selected before the change.

        :param integer `s`: the old selection.
        """

        self.old_selection = s


    def GetOldSelection(self):
        """
        Returns the page that was selected before the change, or -1 if none was
        selected.
        """

        return self.old_selection


    def SetDragSource(self, s):
        """
        Sets the drag and drop source.

        :param `s`: the drag source.
        """

        self.drag_source = s


    def GetDragSource(self):
        """ Returns the drag and drop source. """

        return self.drag_source


    def SetDispatched(self, b):
        """
        Sets the event as dispatched (used for automatic :class:`AuiNotebook` ).

        :param `b`: whether the event was dispatched or not.
        """

        self.dispatched = b


    def GetDispatched(self):
        """ Returns whether the event was dispatched (used for automatic :class:`AuiNotebook` ). """

        return self.dispatched


    def IsEditCancelled(self):
        """ Returns the edit cancel flag (for ``EVT_AUINOTEBOOK_BEGIN`` | ``END_LABEL_EDIT`` only)."""

        return self.editCancelled


    def SetEditCanceled(self, editCancelled):
        """
        Sets the edit cancel flag (for ``EVT_AUINOTEBOOK_BEGIN`` | ``END_LABEL_EDIT`` only).

        :param bool `editCancelled`: whether the editing action has been cancelled or not.
        """

        self.editCancelled = editCancelled


    def GetLabel(self):
        """Returns the label-itemtext (for ``EVT_AUINOTEBOOK_BEGIN`` | ``END_LABEL_EDIT`` only)."""

        return self.label


    def SetLabel(self, label):
        """
        Sets the label. Useful only for ``EVT_AUINOTEBOOK_END_LABEL_EDIT``.

        :param string `label`: the new label.
        """

        self.label = label


    Page      = property(lambda self: self.page,
                         lambda self, page: setattr(self, 'page', page))
    Selection = property(lambda self: self.GetSelection(), lambda self, sel: self.SetSelection(sel))

# ----------------------------------------------------------------------

class AuiNotebookEvent(CommandNotebookEvent):
    """ A specialized command event class for events sent by :class:`AuiNotebook`. """

    def __init__(self, command_type=None, win_id=0):
        """
        Default class constructor.

        :param `command_type`: the event kind or an instance of :class:`PyCommandEvent`.
        :param integer `win_id`: the window identification number.
        """

        CommandNotebookEvent.__init__(self, command_type, win_id)

        if type(command_type) == types.IntType:
            self.notify = wx.NotifyEvent(command_type, win_id)
        else:
            self.notify = wx.NotifyEvent(command_type.GetEventType(), command_type.GetId())


    def GetNotifyEvent(self):
        """ Returns the actual :class:`NotifyEvent`. """

        return self.notify


    def IsAllowed(self):
        """ Returns whether the event is allowed or not. """

        return self.notify.IsAllowed()


    def Veto(self):
        """
        Prevents the change announced by this event from happening.

        It is in general a good idea to notify the user about the reasons for
        vetoing the change because otherwise the applications behaviour (which
        just refuses to do what the user wants) might be quite surprising.
        """

        self.notify.Veto()


    def Allow(self):
        """
        This is the opposite of :meth:`Veto`: it explicitly allows the event to be
        processed. For most events it is not necessary to call this method as the
        events are allowed anyhow but some are forbidden by default (this will
        be mentioned in the corresponding event description).
        """

        self.notify.Allow()


# ---------------------------------------------------------------------------- #
# Class TabNavigatorProps
# ---------------------------------------------------------------------------- #

class TabNavigatorProps(object):
    """
    Data storage class for managing and providing access to :class:`TabNavigatorWindow` properties.
    """

    def __init__(self):
        """ Default class constructor. """

        super(TabNavigatorProps, self).__init__()

        # Attributes
        self._icon = wx.NullBitmap
        self._font = wx.NullFont
        self._minsize = wx.DefaultSize

    # Accessors
    Icon = property(lambda self: self._icon,
                    lambda self, icon: setattr(self, '_icon', icon),
                    doc='Sets/Gets the icon for the L{TabNavigatorWindow}, an instance of :class:`Bitmap`.')
    Font = property(lambda self: self._font,
                    lambda self, font: setattr(self, '_font', font),
                    doc='Sets/Gets the font for the L{TabNavigatorWindow}, an instance of :class:`Font`.')
    MinSize = property(lambda self: self._minsize,
                       lambda self, size: setattr(self, '_minsize', size),
                       doc='Sets/Gets the minimum size for the L{TabNavigatorWindow}, an instance of :class:`Size`.')

# ---------------------------------------------------------------------------- #
# Class TabNavigatorWindow
# ---------------------------------------------------------------------------- #

class TabNavigatorWindow(wx.Dialog):
    """
    This class is used to create a modal dialog that enables "Smart Tabbing",
    similar to what you would get by hitting ``Alt`` + ``Tab`` on Windows.
    """

    def __init__(self, parent, props):
        """
        Default class constructor. Used internally.

        :param `parent`: the :class:`TabNavigatorWindow` parent;
        :param `props`: the :class:`TabNavigatorProps` object.
        """

        wx.Dialog.__init__(self, parent, wx.ID_ANY, "", size=props.MinSize, style=0)

        self._selectedItem = -1
        self._indexMap = []
        self._props = props

        if not self._props.Icon.IsOk():
            self._props.Icon = Mondrian.GetBitmap()

        if props.Icon.GetSize() != (16, 16):
            img = self._props.Icon.ConvertToImage()
            img.Rescale(16, 16, wx.IMAGE_QUALITY_HIGH)
            self._props.Icon = wx.BitmapFromImage(img)

        if self._props.Font.IsOk():
            self.Font = self._props.Font

        sz = wx.BoxSizer(wx.VERTICAL)

        self._listBox = wx.ListBox(self, wx.ID_ANY,
                                   wx.DefaultPosition,
                                   wx.Size(200, 150), [],
                                   wx.LB_SINGLE | wx.NO_BORDER)

        mem_dc = wx.MemoryDC()
        mem_dc.SelectObject(wx.EmptyBitmap(1,1))
        font = wx.SystemSettings_GetFont(wx.SYS_DEFAULT_GUI_FONT)
        font.SetWeight(wx.BOLD)
        mem_dc.SetFont(font)

        panelHeight = mem_dc.GetCharHeight()
        panelHeight += 4 # Place a spacer of 2 pixels

        # Out signpost bitmap is 24 pixels
        if panelHeight < 24:
            panelHeight = 24

        self._panel = wx.Panel(self, wx.ID_ANY, wx.DefaultPosition,
                               wx.Size(-1, panelHeight))

        sz.Add(self._panel, 0, wx.EXPAND)
        sz.Add(self._listBox, 1, wx.EXPAND)

        self.SetSizer(sz)

        # Connect events to the list box
        self._listBox.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        self._listBox.Bind(wx.EVT_NAVIGATION_KEY, self.OnNavigationKey)
        self._listBox.Bind(wx.EVT_LISTBOX_DCLICK, self.OnItemSelected)

        # Connect paint event to the panel
        self._panel.Bind(wx.EVT_PAINT, self.OnPanelPaint)
        self._panel.Bind(wx.EVT_ERASE_BACKGROUND, self.OnPanelEraseBg)

        self.SetBackgroundColour(wx.SystemSettings_GetColour(wx.SYS_COLOUR_3DFACE))
        self._listBox.SetBackgroundColour(wx.SystemSettings_GetColour(wx.SYS_COLOUR_3DFACE))
        self.PopulateListControl(parent)

        self.SetInitialSize(props.MinSize)
        self.Centre()

        # Set focus on the list box to avoid having to click on it to change
        # the tab selection under GTK.
        self._listBox.SetFocus()


    def OnKeyUp(self, event):
        """
        Handles the ``wx.EVT_KEY_UP`` for the :class:`TabNavigatorWindow`.

        :param `event`: a :class:`KeyEvent` event to be processed.
        """

        if event.GetKeyCode() == wx.WXK_CONTROL:
            self.CloseDialog()


    def OnNavigationKey(self, event):
        """
        Handles the ``wx.EVT_NAVIGATION_KEY`` for the :class:`TabNavigatorWindow`.

        :param `event`: a :class:`NavigationKeyEvent` event to be processed.
        """

        selected = self._listBox.GetSelection()
        bk = self.GetParent()
        maxItems = bk.GetPageCount()

        if event.GetDirection():

            # Select next page
            if selected == maxItems - 1:
                itemToSelect = 0
            else:
                itemToSelect = selected + 1

        else:

            # Previous page
            if selected == 0:
                itemToSelect = maxItems - 1
            else:
                itemToSelect = selected - 1

        self._listBox.SetSelection(itemToSelect)


    def PopulateListControl(self, book):
        """
        Populates the :class:`TabNavigatorWindow` listbox with a list of tabs.

        :param `book`: the actual :class:`AuiNotebook`.
        """
        # Index of currently selected page
        selection = book.GetSelection()
        # Total number of pages
        count = book.GetPageCount()
        # List of (index, AuiNotebookPage)
        pages = list(enumerate(book.GetTabContainer().GetPages()))
        if book.GetAGWWindowStyleFlag() & AUI_NB_ORDER_BY_ACCESS:
            # Sort pages using last access time. Most recently used is the
            # first in line
            pages.sort(
                key = lambda element: element[1].access_time,
                reverse = True
            )
        else:
            # Manually add the current selection as first item
            # Remaining ones are added in the next loop
            del pages[selection]
            self._listBox.Append(book.GetPageText(selection))
            self._indexMap.append(selection)

        for (index, page) in pages:
            self._listBox.Append(book.GetPageText(index))
            self._indexMap.append(index)

        # Select the next entry after the current selection
        self._listBox.SetSelection(0)
        dummy = wx.NavigationKeyEvent()
        dummy.SetDirection(True)
        self.OnNavigationKey(dummy)


    def OnItemSelected(self, event):
        """
        Handles the ``wx.EVT_LISTBOX_DCLICK`` event for the :class:`ListBox` inside :class:`TabNavigatorWindow`.

        :param `event`: a :class:`ListEvent` event to be processed.
        """

        self.CloseDialog()


    def CloseDialog(self):
        """ Closes the :class:`TabNavigatorWindow` dialog, setting selection in :class:`AuiNotebook`. """

        bk = self.GetParent()
        self._selectedItem = self._listBox.GetSelection()
        self.EndModal(wx.ID_OK)


    def GetSelectedPage(self):
        """ Gets the page index that was selected when the dialog was closed. """

        return self._indexMap[self._selectedItem]


    def OnPanelPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for :class:`TabNavigatorWindow` top panel.

        :param `event`: a :class:`PaintEvent` event to be processed.
        """

        dc = wx.PaintDC(self._panel)
        rect = self._panel.GetClientRect()

        bmp = wx.EmptyBitmap(rect.width, rect.height)

        mem_dc = wx.MemoryDC()
        mem_dc.SelectObject(bmp)

        endColour = wx.SystemSettings_GetColour(wx.SYS_COLOUR_BTNSHADOW)
        startColour = LightColour(endColour, 50)
        mem_dc.GradientFillLinear(rect, startColour, endColour, wx.SOUTH)

        # Draw the caption title and place the bitmap
        # get the bitmap optimal position, and draw it
        bmpPt, txtPt = wx.Point(), wx.Point()
        bmpPt.y = (rect.height - self._props.Icon.GetHeight())/2
        bmpPt.x = 3
        mem_dc.DrawBitmap(self._props.Icon, bmpPt.x, bmpPt.y, True)

        # get the text position, and draw it
        font = wx.SystemSettings_GetFont(wx.SYS_DEFAULT_GUI_FONT)
        font.SetWeight(wx.BOLD)
        mem_dc.SetFont(font)
        fontHeight = mem_dc.GetCharHeight()

        txtPt.x = bmpPt.x + self._props.Icon.GetWidth() + 4
        txtPt.y = (rect.height - fontHeight)/2
        mem_dc.SetTextForeground(wx.WHITE)
        mem_dc.DrawText("Opened tabs:", txtPt.x, txtPt.y)
        mem_dc.SelectObject(wx.NullBitmap)

        dc.DrawBitmap(bmp, 0, 0)


    def OnPanelEraseBg(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for :class:`TabNavigatorWindow` top panel.

        :param `event`: a :class:`EraseEvent` event to be processed.

        :note: This is intentionally empty, to reduce flicker.
        """

        pass


# ----------------------------------------------------------------------
# -- AuiTabContainer class implementation --

class AuiTabContainer(object):
    """
    AuiTabContainer is a class which contains information about each tab.
    It also can render an entire tab control to a specified DC.
    It's not a window class itself, because this code will be used by
    the :class:`AuiNotebook`, where it is disadvantageous to have separate
    windows for each tab control in the case of "docked tabs".

    A derived class, :class:`AuiTabCtrl`, is an actual :class:`Window` - derived window
    which can be used as a tab control in the normal sense.
    """

    def __init__(self, auiNotebook):
        """
        Default class constructor.
        Used internally, do not call it in your code!

        :param `auiNotebook`: the parent :class:`AuiNotebook` window.
        """

        self._tab_offset = 0
        self._agwFlags = 0
        self._art = TA.AuiDefaultTabArt()

        self._buttons = []
        self._pages = []
        self._tab_close_buttons = []

        self._rect = wx.Rect()
        self._auiNotebook = auiNotebook

        self.AddButton(AUI_BUTTON_LEFT, wx.LEFT)
        self.AddButton(AUI_BUTTON_RIGHT, wx.RIGHT)
        self.AddButton(AUI_BUTTON_WINDOWLIST, wx.RIGHT)
        self.AddButton(AUI_BUTTON_CLOSE, wx.RIGHT)


    def SetArtProvider(self, art):
        """
        Instructs :class:`AuiTabContainer` to use art provider specified by parameter `art`
        for all drawing calls. This allows plugable look-and-feel features.

        :param `art`: an art provider.

        :note: The previous art provider object, if any, will be deleted by :class:`AuiTabContainer`.
        """

        del self._art
        self._art = art

        if self._art:
            self._art.SetAGWFlags(self._agwFlags)


    def GetArtProvider(self):
        """ Returns the current art provider being used. """

        return self._art


    def SetAGWFlags(self, agwFlags):
        """
        Sets the tab art flags.

        :param integer `agwFlags`: a combination of the following values:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close :class:`AuiNotebook` tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by :class:`~lib.agw.aui.framemanager.AuiManager` to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less full screen,
                                              tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ``AUI_NB_ORDER_BY_ACCESS``           Tab navigation order by last access time for the tabs
         ``AUI_NB_NO_TAB_FOCUS``              Don't draw tab focus rectangle
         ==================================== ==================================

        .. todo:: Implementation of flags ``AUI_NB_RIGHT`` and ``AUI_NB_LEFT``.

        """

        self._agwFlags = agwFlags

        # check for new close button settings
        self.RemoveButton(AUI_BUTTON_LEFT)
        self.RemoveButton(AUI_BUTTON_RIGHT)
        self.RemoveButton(AUI_BUTTON_WINDOWLIST)
        self.RemoveButton(AUI_BUTTON_CLOSE)

        if agwFlags & AUI_NB_SCROLL_BUTTONS:
            self.AddButton(AUI_BUTTON_LEFT, wx.LEFT)
            self.AddButton(AUI_BUTTON_RIGHT, wx.RIGHT)

        if agwFlags & AUI_NB_WINDOWLIST_BUTTON:
            self.AddButton(AUI_BUTTON_WINDOWLIST, wx.RIGHT)

        if agwFlags & AUI_NB_CLOSE_BUTTON:
            self.AddButton(AUI_BUTTON_CLOSE, wx.RIGHT)

        if self._art:
            self._art.SetAGWFlags(self._agwFlags)


    def GetAGWFlags(self):
        """
        Returns the tab art flags.

        .. seealso:: :meth:`SetAGWFlags` for a list of possible return values.
        """

        return self._agwFlags


    def SetNormalFont(self, font):
        """
        Sets the normal font for drawing tab labels.

        :param Font `font`: the new font to use to draw tab labels in their normal, un-selected state.
        """

        self._art.SetNormalFont(font)


    def SetSelectedFont(self, font):
        """
        Sets the selected tab font for drawing tab labels.

        :param Font `font`: the new font to use to draw tab labels in their selected state.
        """

        self._art.SetSelectedFont(font)


    def SetMeasuringFont(self, font):
        """
        Sets the font for calculating text measurements.

        :param Font `font`: the new font to use to measure tab label text extents.
        """

        self._art.SetMeasuringFont(font)


    def SetTabRect(self, rect):
        """
        Sets the tab area rectangle.

        :param Rect `rect`: the available area for :class:`AuiTabContainer`.
        """

        self._rect = rect

        if self._art:
            minMaxTabWidth = self._auiNotebook.GetMinMaxTabWidth()
            self._art.SetSizingInfo(rect.GetSize(), len(self._pages), minMaxTabWidth)


    def AddPage(self, page, info):
        """
        Adds a page to the tab control.

        :param Window `page`: the window associated with this tab;
        :param `info`: an instance of :class:`AuiNotebookPage`.
        """

        page_info = info
        page_info.window = page

        self._pages.append(page_info)

        # let the art provider know how many pages we have
        if self._art:
            minMaxTabWidth = self._auiNotebook.GetMinMaxTabWidth()
            self._art.SetSizingInfo(self._rect.GetSize(), len(self._pages), minMaxTabWidth)

        return True


    def InsertPage(self, page, info, idx):
        """
        Inserts a page in the tab control in the position specified by `idx`.

        :param Window `page`: the window associated with this tab;
        :param `info`: an instance of :class:`AuiNotebookPage`;
        :param integer `idx`: the page insertion index.
        """

        page_info = info
        page_info.window = page

        if idx >= len(self._pages):
            self._pages.append(page_info)
        else:
            self._pages.insert(idx, page_info)

        # let the art provider know how many pages we have
        if self._art:
            minMaxTabWidth = self._auiNotebook.GetMinMaxTabWidth()
            self._art.SetSizingInfo(self._rect.GetSize(), len(self._pages), minMaxTabWidth)

        return True


    def MovePage(self, page, new_idx):
        """
        Moves a page in a new position specified by `new_idx`.

        :param Window `page`: the window associated with this tab;
        :param integer `new_idx`: the new page position.
        """

        idx = self.GetIdxFromWindow(page)
        if idx == -1:
            return False

        # get page entry, make a copy of it
        p = self.GetPage(idx)

        # remove old page entry
        self.RemovePage(page)

        # insert page where it should be
        self.InsertPage(page, p, new_idx)

        return True


    def RemovePage(self, wnd):
        """
        Removes a page from the tab control.

        :param `wnd`: an instance of :class:`Window`, a window associated with this tab.
        """

        minMaxTabWidth = self._auiNotebook.GetMinMaxTabWidth()

        for page in self._pages:
            if page.window == wnd:
                self._pages.remove(page)
                self._tab_offset = min(self._tab_offset, len(self._pages) - 1)

                # let the art provider know how many pages we have
                if self._art:
                    self._art.SetSizingInfo(self._rect.GetSize(), len(self._pages), minMaxTabWidth)

                return True

        return False


    def SetActivePage(self, wndOrInt):
        """
        Sets the :class:`AuiNotebook` active page.

        :param `wndOrInt`: an instance of :class:`Window` or an integer specifying a tab index.
        """

        if type(wndOrInt) == types.IntType:

            if wndOrInt >= len(self._pages):
                return False

            wnd = self._pages[wndOrInt].window

        else:
            wnd = wndOrInt

        found = False

        for indx, page in enumerate(self._pages):
            if page.window == wnd:
                page.active = True
                found = True
            else:
                page.active = False

        return found


    def SetNoneActive(self):
        """ Sets all the tabs as inactive (non-selected). """

        for page in self._pages:
            page.active = False


    def GetActivePage(self):
        """ Returns the current selected tab or ``wx.NOT_FOUND`` if none is selected. """

        for indx, page in enumerate(self._pages):
            if page.active:
                return indx

        return wx.NOT_FOUND


    def GetWindowFromIdx(self, idx):
        """
        Returns the window associated with the tab with index `idx`.

        :param integer `idx`: the tab index.
        """

        if idx >= len(self._pages):
            return None

        return self._pages[idx].window


    def GetIdxFromWindow(self, wnd):
        """
        Returns the tab index based on the window `wnd` associated with it.

        :param `wnd`: an instance of :class:`Window`.
        """

        for indx, page in enumerate(self._pages):
            if page.window == wnd:
                return indx

        return wx.NOT_FOUND


    def GetPage(self, idx):
        """
        Returns the page specified by the given index.

        :param integer `idx`: the tab index.
        """

        if idx < 0 or idx >= len(self._pages):
            raise Exception("Invalid Page index")

        return self._pages[idx]


    def GetPages(self):
        """ Returns a list of all the pages in this :class:`AuiTabContainer`. """

        return self._pages


    def GetPageCount(self):
        """ Returns the number of pages in the :class:`AuiTabContainer`. """

        return len(self._pages)


    def GetEnabled(self, idx):
        """
        Returns whether a tab is enabled or not.

        :param integer `idx`: the tab index.
        """

        if idx < 0 or idx >= len(self._pages):
            return False

        return self._pages[idx].enabled


    def EnableTab(self, idx, enable=True):
        """
        Enables/disables a tab in the :class:`AuiTabContainer`.

        :param integer `idx`: the tab index;
        :param bool `enable`: ``True`` to enable a tab, ``False`` to disable it.
        """

        if idx < 0 or idx >= len(self._pages):
            raise Exception("Invalid Page index")

        self._pages[idx].enabled = enable
        wnd = self.GetWindowFromIdx(idx)
        wnd.Enable(enable)


    def AddButton(self, id, location, normal_bitmap=wx.NullBitmap, disabled_bitmap=wx.NullBitmap):
        """
        Adds a button in the tab area.

        :param integer `id`: the button identifier. This can be one of the following:

         ==============================  =================================
         Button Identifier               Description
         ==============================  =================================
         ``AUI_BUTTON_CLOSE``            Shows a close button on the tab area
         ``AUI_BUTTON_WINDOWLIST``       Shows a window list button on the tab area
         ``AUI_BUTTON_LEFT``             Shows a left button on the tab area
         ``AUI_BUTTON_RIGHT``            Shows a right button on the tab area
         ==============================  =================================

        :param integer `location`: the button location. Can be ``wx.LEFT`` or ``wx.RIGHT``;
        :param Bitmap `normal_bitmap`: the bitmap for an enabled tab;
        :param Bitmap `disabled_bitmap`: the bitmap for a disabled tab.
        """

        button = AuiTabContainerButton()
        button.id = id
        button.bitmap = normal_bitmap
        button.dis_bitmap = disabled_bitmap
        button.location = location
        button.cur_state = AUI_BUTTON_STATE_NORMAL

        self._buttons.append(button)


    def CloneButtons(self):
        """
        Clones the tab area buttons when the :class:`AuiNotebook` is being split.

        :see: :meth:`AddButton`

        :note: Standard buttons for :class:`AuiNotebook` are not cloned, only custom ones.
        """

        singleton_list = [AUI_BUTTON_CLOSE, AUI_BUTTON_WINDOWLIST, AUI_BUTTON_LEFT, AUI_BUTTON_RIGHT]
        clones = []

        for button in self._buttons:
            if button.id not in singleton_list:
                new_button = AuiTabContainerButton()
                new_button.id = button.id
                new_button.bitmap = button.bitmap
                new_button.dis_bitmap = button.dis_bitmap
                new_button.location = button.location
                clones.append(new_button)

        return clones


    def RemoveButton(self, id):
        """
        Removes a button from the tab area.

        :param integer `id`: the button identifier. See :meth:`AddButton` for a list of button identifiers.

        :see: :meth:`AddButton`
        """

        for button in self._buttons:
            if button.id == id:
                self._buttons.remove(button)
                return


    def GetTabOffset(self):
        """ Returns the tab offset. """

        return self._tab_offset


    def SetTabOffset(self, offset):
        """
        Sets the tab offset.

        :param integer `offset`: the tab offset.
        """

        self._tab_offset = offset


    def Render(self, raw_dc, wnd):
        """
        Renders the tab catalog to the specified :class:`DC`.

        It is a virtual function and can be overridden to provide custom drawing
        capabilities.

        :param `raw_dc`: a :class:`DC` device context;
        :param `wnd`: an instance of :class:`Window`.
        """

        if not raw_dc or not raw_dc.IsOk():
            return

        dc = wx.MemoryDC()

        # use the same layout direction as the window DC uses to ensure that the
        # text is rendered correctly
        dc.SetLayoutDirection(raw_dc.GetLayoutDirection())

        page_count = len(self._pages)
        button_count = len(self._buttons)

        # create off-screen bitmap
        bmp = wx.EmptyBitmap(self._rect.GetWidth(), self._rect.GetHeight())
        dc.SelectObject(bmp)

        if not dc.IsOk():
            return

        # prepare the tab-close-button array
        # make sure tab button entries which aren't used are marked as hidden
        for i in xrange(page_count, len(self._tab_close_buttons)):
            self._tab_close_buttons[i].cur_state = AUI_BUTTON_STATE_HIDDEN

        # make sure there are enough tab button entries to accommodate all tabs
        while len(self._tab_close_buttons) < page_count:
            tempbtn = AuiTabContainerButton()
            tempbtn.id = AUI_BUTTON_CLOSE
            tempbtn.location = wx.CENTER
            tempbtn.cur_state = AUI_BUTTON_STATE_HIDDEN
            self._tab_close_buttons.append(tempbtn)

        # find out if size of tabs is larger than can be
        # afforded on screen
        total_width = visible_width = 0
        tab_width = [0] * page_count

        for i in xrange(page_count):
            page = self._pages[i]

            # determine if a close button is on this tab
            close_button = False
            if (self._agwFlags & AUI_NB_CLOSE_ON_ALL_TABS and page.hasCloseButton) or \
               (self._agwFlags & AUI_NB_CLOSE_ON_ACTIVE_TAB and page.active and page.hasCloseButton):

                close_button = True

            control = page.control
            if control:
                try:
                    control.GetSize()
                except wx.PyDeadObjectError:
                    page.control = None

            size, x_extent = self._art.GetTabSize(dc, wnd, page.caption, page.bitmap, page.active,
                                                  (close_button and [AUI_BUTTON_STATE_NORMAL] or \
                                                   [AUI_BUTTON_STATE_HIDDEN])[0], page.control)

            if i+1 < page_count:
                total_width += x_extent
                tab_width[i] = x_extent
            else:
                total_width += size[0]
                tab_width[i] = size[0]

            if i >= self._tab_offset:            
                if i+1 < page_count:
                    visible_width += x_extent
                else:
                    visible_width += size[0]

        # Calculate the width of visible buttons
        buttons_width = 0

        for button in self._buttons:
            if not (button.cur_state & AUI_BUTTON_STATE_HIDDEN):
                buttons_width += button.rect.GetWidth()

        total_width += buttons_width

        if (total_width > self._rect.GetWidth() and page_count > 1) or self._tab_offset != 0:

            # show left/right buttons
            for button in self._buttons:
                if button.id == AUI_BUTTON_LEFT or \
                   button.id == AUI_BUTTON_RIGHT:

                    button.cur_state &= ~AUI_BUTTON_STATE_HIDDEN

        else:

            # hide left/right buttons
            for button in self._buttons:
                if button.id == AUI_BUTTON_LEFT or \
                   button.id == AUI_BUTTON_RIGHT:
                    
                    button.cur_state |= AUI_BUTTON_STATE_HIDDEN

        # Re-calculate the width of visible buttons (may have been hidden/shown)
        buttons_width = 0
        for button in self._buttons:
            if not (button.cur_state & AUI_BUTTON_STATE_HIDDEN):
                buttons_width += button.rect.GetWidth()

        # Shift the tab offset down to make use of available space
        available_width = self._rect.GetWidth() - buttons_width
        while self._tab_offset > 0 and visible_width + tab_width[self._tab_offset - 1] < available_width:
            self._tab_offset -= 1
            visible_width += tab_width[self._tab_offset]

        # determine whether left button should be enabled
        for button in self._buttons:
            if button.id == AUI_BUTTON_LEFT:
                if self._tab_offset == 0:
                    button.cur_state |= AUI_BUTTON_STATE_DISABLED
                else:
                    button.cur_state &= ~AUI_BUTTON_STATE_DISABLED

            if button.id == AUI_BUTTON_RIGHT:
                if visible_width < self._rect.GetWidth() - buttons_width:
                    button.cur_state |= AUI_BUTTON_STATE_DISABLED
                else:
                    button.cur_state &= ~AUI_BUTTON_STATE_DISABLED

        # draw background
        self._art.DrawBackground(dc, wnd, self._rect)

        # draw buttons
        left_buttons_width = 0
        right_buttons_width = 0

        # draw the buttons on the right side
        offset = self._rect.x + self._rect.width

        for i in xrange(button_count):
            button = self._buttons[button_count - i - 1]

            if button.location != wx.RIGHT:
                continue
            if button.cur_state & AUI_BUTTON_STATE_HIDDEN:
                continue

            button_rect = wx.Rect(*self._rect)
            button_rect.SetY(1)
            button_rect.SetWidth(offset)

            button.rect = self._art.DrawButton(dc, wnd, button_rect, button, wx.RIGHT)

            offset -= button.rect.GetWidth()
            right_buttons_width += button.rect.GetWidth()

        offset = 0

        # draw the buttons on the left side
        for i in xrange(button_count):
            button = self._buttons[button_count - i - 1]

            if button.location != wx.LEFT:
                continue
            if button.cur_state & AUI_BUTTON_STATE_HIDDEN:
                continue

            button_rect = wx.Rect(offset, 1, 1000, self._rect.height)

            button.rect = self._art.DrawButton(dc, wnd, button_rect, button, wx.LEFT)

            offset += button.rect.GetWidth()
            left_buttons_width += button.rect.GetWidth()

        offset = left_buttons_width

        if offset == 0:
            offset += self._art.GetIndentSize()

        # buttons before the tab offset must be set to hidden
        for i in xrange(self._tab_offset):
            self._tab_close_buttons[i].cur_state = AUI_BUTTON_STATE_HIDDEN
            if self._pages[i].control:
                if self._pages[i].control.IsShown():
                    self._pages[i].control.Hide()

        # draw tab before tab offset
        if self._tab_offset > 0:
            page = self._pages[self._tab_offset - 1]
            tab_button = self._tab_close_buttons[self._tab_offset - 1]
            size, x_extent = self._art.GetTabSize(dc, wnd, page.caption, page.bitmap, page.active, tab_button.cur_state, page.control)

            rect = wx.Rect(offset - x_extent, 0, self._rect.width - right_buttons_width - offset - x_extent - 2, self._rect.height)
            clip_rect = wx.Rect(*self._rect)
            clip_rect.x = offset

            dc.SetClippingRect(clip_rect)
            self._art.DrawTab(dc, wnd, page, rect, tab_button.cur_state)
            dc.DestroyClippingRegion()

        # draw the tabs
        active = 999
        active_offset = 0

        rect = wx.Rect(*self._rect)
        rect.y = 0
        rect.height = self._rect.height

        for i in xrange(self._tab_offset, page_count):

            page = self._pages[i]
            tab_button = self._tab_close_buttons[i]

            # determine if a close button is on this tab
            if (self._agwFlags & AUI_NB_CLOSE_ON_ALL_TABS and page.hasCloseButton) or \
               (self._agwFlags & AUI_NB_CLOSE_ON_ACTIVE_TAB and page.active and page.hasCloseButton):

                if tab_button.cur_state == AUI_BUTTON_STATE_HIDDEN:

                    tab_button.id = AUI_BUTTON_CLOSE
                    tab_button.cur_state = AUI_BUTTON_STATE_NORMAL
                    tab_button.location = wx.CENTER

            else:

                tab_button.cur_state = AUI_BUTTON_STATE_HIDDEN

            rect.x = offset
            rect.width = self._rect.width - right_buttons_width - offset - 2

            if rect.width <= 0:
                break

            page.rect, tab_button.rect, x_extent = self._art.DrawTab(dc, wnd, page, rect, tab_button.cur_state)

            if page.active:
                active = i
                active_offset = offset
                active_rect = wx.Rect(*rect)

            offset += x_extent

        lenPages = len(self._pages)
        # make sure to deactivate buttons which are off the screen to the right
        for j in xrange(i+1, len(self._tab_close_buttons)):
            self._tab_close_buttons[j].cur_state = AUI_BUTTON_STATE_HIDDEN
            if j > 0 and j <= lenPages:
                if self._pages[j-1].control:
                    if self._pages[j-1].control.IsShown():
                        self._pages[j-1].control.Hide()

        # draw the active tab again so it stands in the foreground
        if active >= self._tab_offset and active < len(self._pages):

            page = self._pages[active]
            tab_button = self._tab_close_buttons[active]

            rect.x = active_offset
            dummy = self._art.DrawTab(dc, wnd, page, active_rect, tab_button.cur_state)

        raw_dc.Blit(self._rect.x, self._rect.y, self._rect.GetWidth(), self._rect.GetHeight(), dc, 0, 0)


    def IsTabVisible(self, tabPage, tabOffset, dc, wnd):
        """
        Returns whether a tab is visible or not.

        :param integer `tabPage`: the tab index;
        :param integer `tabOffset`: the tab offset;
        :param `dc`: a :class:`DC` device context;
        :param `wnd`: an instance of :class:`Window` derived window.
        """

        if not dc or not dc.IsOk():
            return False

        page_count = len(self._pages)
        button_count = len(self._buttons)
        self.Render(dc, wnd)

        # Hasn't been rendered yet assume it's visible
        if len(self._tab_close_buttons) < page_count:
            return True

        if self._agwFlags & AUI_NB_SCROLL_BUTTONS:
            # First check if both buttons are disabled - if so, there's no need to
            # check further for visibility.
            arrowButtonVisibleCount = 0
            for i in xrange(button_count):

                button = self._buttons[i]
                if button.id == AUI_BUTTON_LEFT or \
                   button.id == AUI_BUTTON_RIGHT:

                    if button.cur_state & AUI_BUTTON_STATE_HIDDEN == 0:
                        arrowButtonVisibleCount += 1

            # Tab must be visible
            if arrowButtonVisibleCount == 0:
                return True

        # If tab is less than the given offset, it must be invisible by definition
        if tabPage < tabOffset:
            return False

        # draw buttons
        left_buttons_width = 0
        right_buttons_width = 0

        offset = 0

        # calculate size of the buttons on the right side
        offset = self._rect.x + self._rect.width

        for i in xrange(button_count):
            button = self._buttons[button_count - i - 1]

            if button.location != wx.RIGHT:
                continue
            if button.cur_state & AUI_BUTTON_STATE_HIDDEN:
                continue

            offset -= button.rect.GetWidth()
            right_buttons_width += button.rect.GetWidth()

        offset = 0

        # calculate size of the buttons on the left side
        for i in xrange(button_count):
            button = self._buttons[button_count - i - 1]

            if button.location != wx.LEFT:
                continue
            if button.cur_state & AUI_BUTTON_STATE_HIDDEN:
                continue

            offset += button.rect.GetWidth()
            left_buttons_width += button.rect.GetWidth()

        offset = left_buttons_width

        if offset == 0:
            offset += self._art.GetIndentSize()

        rect = wx.Rect(*self._rect)
        rect.y = 0
        rect.height = self._rect.height

        # See if the given page is visible at the given tab offset (effectively scroll position)
        for i in xrange(tabOffset, page_count):

            page = self._pages[i]
            tab_button = self._tab_close_buttons[i]

            rect.x = offset
            rect.width = self._rect.width - right_buttons_width - offset - 2

            if rect.width <= 0:
                return False # haven't found the tab, and we've run out of space, so return False

            size, x_extent = self._art.GetTabSize(dc, wnd, page.caption, page.bitmap, page.active, tab_button.cur_state, page.control)
            offset += x_extent

            if i == tabPage:

                # If not all of the tab is visible, and supposing there's space to display it all,
                # we could do better so we return False.
                if (self._rect.width - right_buttons_width - offset - 2) <= 0 and (self._rect.width - right_buttons_width - left_buttons_width) > x_extent:
                    return False
                else:
                    return True

        # Shouldn't really get here, but if it does, assume the tab is visible to prevent
        # further looping in calling code.
        return True


    def MakeTabVisible(self, tabPage, win):
        """
        Make the tab visible if it wasn't already.

        :param integer `tabPage`: the tab index;
        :param `win`: an instance of :class:`Window` derived window.
        """

        dc = wx.ClientDC(win)

        if not self.IsTabVisible(tabPage, self.GetTabOffset(), dc, win):
            for i in xrange(len(self._pages)):
                if self.IsTabVisible(tabPage, i, dc, win):
                    self.SetTabOffset(i)
                    win.Refresh()
                    return


    def TabHitTest(self, x, y):
        """
        TabHitTest() tests if a tab was hit, passing the window pointer
        back if that condition was fulfilled.

        :param integer `x`: the mouse `x` position;
        :param integer `y`: the mouse `y` position.
        """

        if not self._rect.Contains((x,y)):
            return None

        btn = self.ButtonHitTest(x, y)
        if btn:
            if btn in self._buttons:
                return None

        for i in xrange(self._tab_offset, len(self._pages)):
            page = self._pages[i]
            if page.rect.Contains((x,y)):
                return page.window

        return None


    def ButtonHitTest(self, x, y):
        """
        Tests if a button was hit.

        :param integer `x`: the mouse `x` position;
        :param integer `y`: the mouse `y` position.

        :returns: and instance of :class:`AuiTabContainerButton` if a button was hit, ``None`` otherwise.
        """

        if not self._rect.Contains((x,y)):
            return None

        for button in self._buttons:
            if button.rect.Contains((x,y)) and \
               (button.cur_state & (AUI_BUTTON_STATE_HIDDEN|AUI_BUTTON_STATE_DISABLED)) == 0:
                return button

        for button in self._tab_close_buttons:
            if button.rect.Contains((x,y)) and \
               (button.cur_state & (AUI_BUTTON_STATE_HIDDEN|AUI_BUTTON_STATE_DISABLED)) == 0:
                return button

        return None


    def DoShowHide(self):
        """
        This function shows the active window, then hides all of the other windows
        (in that order).
        """

        pages = self.GetPages()

        # show new active page first
        for page in pages:
            if page.active:
                page.window.Show(True)
                break

        # hide all other pages
        for page in pages:
            if not page.active:
                page.window.Show(False)


# ----------------------------------------------------------------------
# -- AuiTabCtrl class implementation --

class AuiTabCtrl(wx.PyControl, AuiTabContainer):
    """
    This is an actual :class:`Window` - derived window which can be used as a tab control in the normal sense.
    """

    def __init__(self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.DefaultSize,
                 style=wx.NO_BORDER|wx.WANTS_CHARS|wx.TAB_TRAVERSAL):
        """
        Default class constructor.
        Used internally, do not call it in your code!

        :param `parent`: the :class:`AuiNotebook` parent;
        :param integer `id`: an identifier for the control: a value of -1 is taken to mean a default;
        :param Point `pos`: the control position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform;
        :param Size `size`: the control size. A value of (-1, -1) indicates a default size,
         chosen by either the windowing system or wxPython, depending on platform;
        :param integer `style`: the window style.
        """

        wx.PyControl.__init__(self, parent, id, pos, size, style, name="AuiTabCtrl")
        AuiTabContainer.__init__(self, parent)

        self._click_pt = wx.Point(-1, -1)
        self._is_dragging = False
        self._hover_button = None
        self._pressed_button = None
        self._drag_image = None
        self._drag_img_offset = (0, 0)
        self._on_button = False

        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_DCLICK, self.OnLeftDClick)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.Bind(wx.EVT_MIDDLE_DOWN, self.OnMiddleDown)
        self.Bind(wx.EVT_MIDDLE_UP, self.OnMiddleUp)
        self.Bind(wx.EVT_RIGHT_DOWN, self.OnRightDown)
        self.Bind(wx.EVT_RIGHT_UP, self.OnRightUp)
        self.Bind(wx.EVT_SET_FOCUS, self.OnSetFocus)
        self.Bind(wx.EVT_KILL_FOCUS, self.OnKillFocus)
        self.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown)
        self.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnCaptureLost)
        self.Bind(wx.EVT_MOTION, self.OnMotion)
        self.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow)
        self.Bind(EVT_AUINOTEBOOK_BUTTON, self.OnButton)


    def IsDragging(self):
        """ Returns whether the user is dragging a tab with the mouse or not. """

        return self._is_dragging


    def GetDefaultBorder(self):
        """ Returns the default border style for :class:`AuiTabCtrl`. """

        return wx.BORDER_NONE


    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`PaintEvent` event to be processed.
        """

        dc = wx.PaintDC(self)
        dc.SetFont(self.GetFont())

        if self.GetPageCount() > 0:
            self.Render(dc, self)


    def OnEraseBackground(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`EraseEvent` event to be processed.

        :note: This is intentionally empty, to reduce flicker.
        """

        pass


    def DoGetBestSize(self):
        """
        Gets the size which best suits the window: for a control, it would be the
        minimal size which doesn't truncate the control, for a panel - the same
        size as it would have after a call to `Fit()`.

        :note: Overridden from :class:`PyControl`.
        """

        return wx.Size(self._rect.width, self._rect.height)


    def OnSize(self, event):
        """
        Handles the ``wx.EVT_SIZE`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`SizeEvent` event to be processed.
        """

        s = event.GetSize()
        self.SetTabRect(wx.Rect(0, 0, s.GetWidth(), s.GetHeight()))


    def OnLeftDown(self, event):
        """
        Handles the ``wx.EVT_LEFT_DOWN`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`MouseEvent` event to be processed.
        """

        if not self.HasCapture():
            self.CaptureMouse()

        self._click_pt = wx.Point(-1, -1)
        self._is_dragging = False
        self._click_tab = None
        self._pressed_button = None

        wnd = self.TabHitTest(event.GetX(), event.GetY())

        if wnd is not None:
            new_selection = self.GetIdxFromWindow(wnd)

            # AuiNotebooks always want to receive this event
            # even if the tab is already active, because they may
            # have multiple tab controls
            if (new_selection != self.GetActivePage() or isinstance(self.GetParent(), AuiNotebook)) and \
               not self._hover_button:
                e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, self.GetId())
                e.SetSelection(new_selection)
                e.SetOldSelection(self.GetActivePage())
                e.SetEventObject(self)
                self.GetEventHandler().ProcessEvent(e)

            self._click_pt.x = event.GetX()
            self._click_pt.y = event.GetY()
            self._click_tab = wnd

            wnd.SetFocus()
        else:
            page_index = self.GetActivePage()
            if page_index != wx.NOT_FOUND:
                self.GetWindowFromIdx(page_index).SetFocus()

            self._hover_button = self.ButtonHitTest(event.GetX(), event.GetY())

            if self._hover_button:
                self._pressed_button = self._hover_button
                self._pressed_button.cur_state = AUI_BUTTON_STATE_PRESSED
                self._on_button = True

                self.Refresh()
                self.Update()


    def OnCaptureLost(self, event):
        """
        Handles the ``wx.EVT_MOUSE_CAPTURE_LOST`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`MouseCaptureLostEvent` event to be processed.
        """

        if self._is_dragging:
            self._is_dragging = False
            self._on_button = False

            if self._drag_image:
                self._drag_image.EndDrag()
                del self._drag_image
                self._drag_image = None

            event = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_CANCEL_DRAG, self.GetId())
            event.SetSelection(self.GetIdxFromWindow(self._click_tab))
            event.SetOldSelection(event.GetSelection())
            event.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(event)


    def OnLeftUp(self, event):
        """
        Handles the ``wx.EVT_LEFT_UP`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`MouseEvent` event to be processed.
        """

        self._on_button = False

        if self._is_dragging:

            if self.HasCapture():
                self.ReleaseMouse()

            self._is_dragging = False
            if self._drag_image:
                self._drag_image.EndDrag()
                del self._drag_image
                self._drag_image = None
                self.GetParent().Refresh()

            evt = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_END_DRAG, self.GetId())
            evt.SetSelection(self.GetIdxFromWindow(self._click_tab))
            evt.SetOldSelection(evt.GetSelection())
            evt.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(evt)

            return

        self.GetParent()._mgr.HideHint()

        if self.HasCapture():
            self.ReleaseMouse()

        if self._hover_button:
            self._pressed_button = self._hover_button
            self._hover_button.cur_state = AUI_BUTTON_STATE_NORMAL

        if self._pressed_button:

            # make sure we're still clicking the button
            button = self.ButtonHitTest(event.GetX(), event.GetY())

            if button is None:
                return

            if button != self._pressed_button:
                self._pressed_button = None
                return

            self.Refresh()
            self.Update()

            if self._pressed_button.cur_state & AUI_BUTTON_STATE_DISABLED == 0:

                evt = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BUTTON, self.GetId())
                evt.SetSelection(self.GetIdxFromWindow(self._click_tab))
                evt.SetInt(self._pressed_button.id)
                evt.SetEventObject(self)
                eventHandler = self.GetEventHandler()

                if eventHandler is not None:
                    eventHandler.ProcessEvent(evt)

            self._pressed_button = None

        self._click_pt = wx.Point(-1, -1)
        self._is_dragging = False
        self._click_tab = None


    def OnMiddleUp(self, event):
        """
        Handles the ``wx.EVT_MIDDLE_UP`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`MouseEvent` event to be processed.
        """

        eventHandler = self.GetEventHandler()
        if not isinstance(eventHandler, AuiTabCtrl):
            event.Skip()
            return

        x, y = event.GetX(), event.GetY()
        wnd = self.TabHitTest(x, y)

        if wnd:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_UP, self.GetId())
            e.SetEventObject(self)
            e.Page = wnd
            e.SetSelection(self.GetIdxFromWindow(wnd))
            self.GetEventHandler().ProcessEvent(e)
        elif not self.ButtonHitTest(x, y):
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BG_MIDDLE_UP, self.GetId())
            e.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(e)


    def OnMiddleDown(self, event):
        """
        Handles the ``wx.EVT_MIDDLE_DOWN`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`MouseEvent` event to be processed.
        """

        eventHandler = self.GetEventHandler()
        if not isinstance(eventHandler, AuiTabCtrl):
            event.Skip()
            return

        x, y = event.GetX(), event.GetY()
        wnd = self.TabHitTest(x, y)

        if wnd:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_DOWN, self.GetId())
            e.SetEventObject(self)
            e.Page = wnd
            e.SetSelection(self.GetIdxFromWindow(wnd))
            self.GetEventHandler().ProcessEvent(e)
        elif not self.ButtonHitTest(x, y):
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BG_MIDDLE_DOWN, self.GetId())
            e.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(e)


    def OnRightUp(self, event):
        """
        Handles the ``wx.EVT_RIGHT_UP`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`MouseEvent` event to be processed.
        """

        x, y = event.GetX(), event.GetY()
        wnd = self.TabHitTest(x, y)

        if wnd:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_UP, self.GetId())
            e.SetEventObject(self)
            e.Selection = self.GetIdxFromWindow(wnd)
            e.Page = wnd
            self.GetEventHandler().ProcessEvent(e)
        elif not self.ButtonHitTest(x, y):
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BG_RIGHT_UP, self.GetId())
            e.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(e)


    def OnRightDown(self, event):
        """
        Handles the ``wx.EVT_RIGHT_DOWN`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`MouseEvent` event to be processed.
        """

        x, y = event.GetX(), event.GetY()
        wnd = self.TabHitTest(x, y)

        if wnd:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_DOWN, self.GetId())
            e.SetEventObject(self)
            e.SetSelection(self.GetIdxFromWindow(wnd))
            e.Page = wnd
            self.GetEventHandler().ProcessEvent(e)
        elif not self.ButtonHitTest(x, y):
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BG_RIGHT_DOWN, self.GetId())
            e.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(e)


    def OnLeftDClick(self, event):
        """
        Handles the ``wx.EVT_LEFT_DCLICK`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`MouseEvent` event to be processed.
        """

        x, y = event.GetX(), event.GetY()
        wnd = self.TabHitTest(x, y)

        if wnd:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_DCLICK, self.GetId())
            e.SetEventObject(self)
            e.SetSelection(self.GetIdxFromWindow(wnd))
            e.Page = wnd
            self.GetEventHandler().ProcessEvent(e)
        elif not self.ButtonHitTest(x, y):
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BG_DCLICK, self.GetId())
            e.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(e)


    def OnMotion(self, event):
        """
        Handles the ``wx.EVT_MOTION`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`MouseEvent` event to be processed.
        """

        pos = event.GetPosition()

        # check if the mouse is hovering above a button

        button = self.ButtonHitTest(pos.x, pos.y)
        wnd = self.TabHitTest(pos.x, pos.y)

        if wnd is not None:
            mouse_tab = self.GetIdxFromWindow(wnd)
            if not self._pages[mouse_tab].enabled:
                self._hover_button = None
                return

        if self._on_button:
            return

        if button:

            if self._hover_button and button != self._hover_button:
                self._hover_button.cur_state = AUI_BUTTON_STATE_NORMAL
                self._hover_button = None
                self.Refresh()
                self.Update()

            if button.cur_state != AUI_BUTTON_STATE_HOVER:
                button.cur_state = AUI_BUTTON_STATE_HOVER
                self.Refresh()
                self.Update()
                self._hover_button = button
                return

        else:

            if self._hover_button:
                self._hover_button.cur_state = AUI_BUTTON_STATE_NORMAL
                self._hover_button = None
                self.Refresh()
                self.Update()

        if not event.LeftIsDown() or self._click_pt == wx.Point(-1, -1):
            return

        if not self.HasCapture():
            return

        wnd = self.TabHitTest(pos.x, pos.y)

        if not self._is_dragging:

            drag_x_threshold = wx.SystemSettings.GetMetric(wx.SYS_DRAG_X)
            drag_y_threshold = wx.SystemSettings.GetMetric(wx.SYS_DRAG_Y)

            if abs(pos.x - self._click_pt.x) > drag_x_threshold or \
               abs(pos.y - self._click_pt.y) > drag_y_threshold:

                self._is_dragging = True

                if self._drag_image:
                    self._drag_image.EndDrag()
                    del self._drag_image
                    self._drag_image = None

                if self._agwFlags & AUI_NB_DRAW_DND_TAB:
                    # Create the custom draw image from the icons and the text of the item
                    mouse_tab = self.GetIdxFromWindow(wnd)
                    page = self._pages[mouse_tab]
                    tab_button = self._tab_close_buttons[mouse_tab]
                    self._drag_image = TabDragImage(self, page, tab_button.cur_state, self._art)

                    if self._agwFlags & AUI_NB_TAB_FLOAT:
                        self._drag_image.BeginDrag(wx.Point(0,0), self, fullScreen=True)
                    else:
                        self._drag_image.BeginDragBounded(wx.Point(0,0), self, self.GetParent())

                    # Capture the mouse cursor position offset relative to
                    # The tab image location
                    self._drag_img_offset = (pos[0] - page.rect.x,
                                             pos[1] - page.rect.y)

                    self._drag_image.Show()

        if not wnd:
            evt2 = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BEGIN_DRAG, self.GetId())
            evt2.SetSelection(self.GetIdxFromWindow(self._click_tab))
            evt2.SetOldSelection(evt2.GetSelection())
            evt2.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(evt2)
            if evt2.GetDispatched():
                return

        evt3 = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_DRAG_MOTION, self.GetId())
        evt3.SetSelection(self.GetIdxFromWindow(self._click_tab))
        evt3.SetOldSelection(evt3.GetSelection())
        evt3.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(evt3)

        if self._drag_image:
            # Apply the drag images offset
            pos -= self._drag_img_offset
            self._drag_image.Move(pos)


    def OnLeaveWindow(self, event):
        """
        Handles the ``wx.EVT_LEAVE_WINDOW`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`MouseEvent` event to be processed.
        """

        if self._hover_button:
            self._hover_button.cur_state = AUI_BUTTON_STATE_NORMAL
            self._hover_button = None
            self.Refresh()
            self.Update()


    def OnButton(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_BUTTON`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        button = event.GetInt()

        if button == AUI_BUTTON_LEFT or button == AUI_BUTTON_RIGHT:
            if button == AUI_BUTTON_LEFT:
                if self.GetTabOffset() > 0:

                    self.SetTabOffset(self.GetTabOffset()-1)
                    self.Refresh()
                    self.Update()
            else:
                self.SetTabOffset(self.GetTabOffset()+1)
                self.Refresh()
                self.Update()

        elif button == AUI_BUTTON_WINDOWLIST:
            idx = self.GetArtProvider().ShowDropDown(self, self._pages, self.GetActivePage())

            if idx != -1:

                e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, self.GetId())
                e.SetSelection(idx)
                e.SetOldSelection(self.GetActivePage())
                e.SetEventObject(self)
                self.GetEventHandler().ProcessEvent(e)

        else:
            event.Skip()


    def OnSetFocus(self, event):
        """
        Handles the ``wx.EVT_SET_FOCUS`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`FocusEvent` event to be processed.
        """

        self.Refresh()


    def OnKillFocus(self, event):
        """
        Handles the ``wx.EVT_KILL_FOCUS`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`FocusEvent` event to be processed.
        """

        self.Refresh()


    def OnKeyDown(self, event):
        """
        Handles the ``wx.EVT_KEY_DOWN`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`KeyEvent` event to be processed.
        """

        key = event.GetKeyCode()
        nb = self.GetParent()

        if key == wx.WXK_LEFT:
            nb.AdvanceSelection(False)
            self.SetFocus()

        elif key == wx.WXK_RIGHT:
            nb.AdvanceSelection(True)
            self.SetFocus()

        elif key == wx.WXK_HOME:
            newPage = 0
            nb.SetSelection(newPage)
            self.SetFocus()

        elif key == wx.WXK_END:
            newPage = nb.GetPageCount() - 1
            nb.SetSelection(newPage)
            self.SetFocus()

        elif key == wx.WXK_TAB:
            if not event.ControlDown():
                flags = 0
                if not event.ShiftDown(): flags |= wx.NavigationKeyEvent.IsForward
                if event.CmdDown():       flags |= wx.NavigationKeyEvent.WinChange
                self.Navigate(flags)
            else:

                if not nb or not isinstance(nb, AuiNotebook):
                    event.Skip()
                    return

                bForward = bWindowChange = 0
                if not event.ShiftDown(): bForward |= wx.NavigationKeyEvent.IsForward
                if event.CmdDown():       bWindowChange |= wx.NavigationKeyEvent.WinChange

                keyEvent = wx.NavigationKeyEvent()
                keyEvent.SetDirection(bForward)
                keyEvent.SetWindowChange(bWindowChange)
                keyEvent.SetFromTab(True)
                keyEvent.SetEventObject(nb)

                if not nb.GetEventHandler().ProcessEvent(keyEvent):

                    # Not processed? Do an explicit tab into the page.
                    win = self.GetWindowFromIdx(self.GetActivePage())
                    if win:
                        win.SetFocus()

                self.SetFocus()

                return

        else:
            event.Skip()


    def OnKeyDown2(self, event):
        """
        Handles the ``wx.EVT_KEY_DOWN`` event for :class:`AuiTabCtrl`.

        :param `event`: a :class:`KeyEvent` event to be processed.

        .. deprecated:: 0.6
           This implementation is now deprecated. Refer to :meth:`OnKeyDown` for the correct one.
        """

        if self.GetActivePage() == -1:
            event.Skip()
            return

        # We can't leave tab processing to the system on Windows, tabs and keys
        # get eaten by the system and not processed properly if we specify both
        # wxTAB_TRAVERSAL and wxWANTS_CHARS. And if we specify just wxTAB_TRAVERSAL,
        # we don't key arrow key events.

        key = event.GetKeyCode()

        if key == wx.WXK_NUMPAD_PAGEUP:
            key = wx.WXK_PAGEUP
        if key == wx.WXK_NUMPAD_PAGEDOWN:
            key = wx.WXK_PAGEDOWN
        if key == wx.WXK_NUMPAD_HOME:
            key = wx.WXK_HOME
        if key == wx.WXK_NUMPAD_END:
            key = wx.WXK_END
        if key == wx.WXK_NUMPAD_LEFT:
            key = wx.WXK_LEFT
        if key == wx.WXK_NUMPAD_RIGHT:
            key = wx.WXK_RIGHT

        if key == wx.WXK_TAB or key == wx.WXK_PAGEUP or key == wx.WXK_PAGEDOWN:

            bCtrlDown = event.ControlDown()
            bShiftDown = event.ShiftDown()

            bForward = (key == wx.WXK_TAB and not bShiftDown) or (key == wx.WXK_PAGEDOWN)
            bWindowChange = (key == wx.WXK_PAGEUP) or (key == wx.WXK_PAGEDOWN) or bCtrlDown
            bFromTab = (key == wx.WXK_TAB)

            nb = self.GetParent()
            if not nb or not isinstance(nb, AuiNotebook):
                event.Skip()
                return

            keyEvent = wx.NavigationKeyEvent()
            keyEvent.SetDirection(bForward)
            keyEvent.SetWindowChange(bWindowChange)
            keyEvent.SetFromTab(bFromTab)
            keyEvent.SetEventObject(nb)

            if not nb.GetEventHandler().ProcessEvent(keyEvent):

                # Not processed? Do an explicit tab into the page.
                win = self.GetWindowFromIdx(self.GetActivePage())
                if win:
                    win.SetFocus()

            return

        if len(self._pages) < 2:
            event.Skip()
            return

        newPage = -1

        if self.GetLayoutDirection() == wx.Layout_RightToLeft:
            forwardKey = wx.WXK_LEFT
            backwardKey = wx.WXK_RIGHT
        else:
            forwardKey = wx.WXK_RIGHT
            backwardKey = wx.WXK_LEFT

        if key == forwardKey:
            if self.GetActivePage() == -1:
                newPage = 0
            elif self.GetActivePage() < len(self._pages) - 1:
                newPage = self.GetActivePage() + 1

        elif key == backwardKey:
            if self.GetActivePage() == -1:
                newPage = len(self._pages) - 1
            elif self.GetActivePage() > 0:
                newPage = self.GetActivePage() - 1

        elif key == wx.WXK_HOME:
            newPage = 0

        elif key == wx.WXK_END:
            newPage = len(self._pages) - 1

        else:
            event.Skip()

        if newPage != -1:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, self.GetId())
            e.SetSelection(newPage)
            e.SetOldSelection(newPage)
            e.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(e)

        else:
            event.Skip()


# ----------------------------------------------------------------------

class TabFrame(wx.PyWindow):
    """
    TabFrame is an interesting case. It's important that all child pages
    of the multi-notebook control are all actually children of that control
    (and not grandchildren). TabFrame facilitates this. There is one
    instance of TabFrame for each tab control inside the multi-notebook.

    It's important to know that TabFrame is not a real window, but it merely
    used to capture the dimensions/positioning of the internal tab control and
    it's managed page windows.
    """

    def __init__(self, parent):
        """
        Default class constructor.
        Used internally, do not call it in your code!
        """

        pre = wx.PrePyWindow()

        self._tabs = None
        self._rect = wx.Rect(0, 0, 200, 200)
        self._tab_ctrl_height = 20
        self._tab_rect = wx.Rect()
        self._parent = parent

        self.PostCreate(pre)


    def SetTabCtrlHeight(self, h):
        """
        Sets the tab control height.

        :param integer `h`: the tab area height.
        """

        self._tab_ctrl_height = h


    def DoSetSize(self, x, y, width, height, flags=wx.SIZE_AUTO):
        """
        Sets the position and size of the window in pixels. The `flags`
        parameter indicates the interpretation of the other params if they are
        equal to -1.

        :param integer `x`: the window `x` position;
        :param integer `y`: the window `y` position;
        :param integer `width`: the window width;
        :param integer `height`: the window height;
        :param integer `flags`: may have one of this bit set:

         ===================================  ======================================
         Size Flags                           Description
         ===================================  ======================================
         ``wx.SIZE_AUTO``                     A -1 indicates that a class-specific default should be used.
         ``wx.SIZE_AUTO_WIDTH``               A -1 indicates that a class-specific default should be used for the width.
         ``wx.SIZE_AUTO_HEIGHT``              A -1 indicates that a class-specific default should be used for the height.
         ``wx.SIZE_USE_EXISTING``             Existing dimensions should be used if -1 values are supplied.
         ``wx.SIZE_ALLOW_MINUS_ONE``          Allow dimensions of -1 and less to be interpreted as real dimensions, not default values.
         ``wx.SIZE_FORCE``                    Normally, if the position and the size of the window are already the same as the
                                              parameters of this function, nothing is done. but with this flag a window resize
                                              may be forced even in this case (supported in wx 2.6.2 and later and only implemented
                                              for MSW and ignored elsewhere currently)
         ===================================  ======================================

        :note: Overridden from :class:`PyControl`.
        """

        self._rect = wx.Rect(x, y, max(1, width), max(1, height))
        self.DoSizing()


    def DoGetSize(self):
        """
        Returns the window size.

        :note: Overridden from :class:`PyControl`.
        """

        return self._rect.width, self._rect.height


    def DoGetClientSize(self):
        """
        Returns the window client size.

        :note: Overridden from :class:`PyControl`.
        """

        return self._rect.width, self._rect.height


    def Show(self, show=True):
        """
        Shows/hides the window.

        :param bool `show`: ``True`` to show the window, ``False`` otherwise.

        :note:

         Overridden from :class:`PyControl`, this method always returns ``False`` as
         :class:`TabFrame` should never be phisically shown on screen.
        """

        return False


    def DoSizing(self):
        """ Does the actual sizing of the tab control. """

        if not self._tabs:
            return

        hideOnSingle = ((self._tabs.GetAGWFlags() & AUI_NB_HIDE_ON_SINGLE_TAB) and \
                        self._tabs.GetPageCount() <= 1)

        if not hideOnSingle and not self._parent._hide_tabs:
            tab_height = self._tab_ctrl_height

            self._tab_rect = wx.Rect(self._rect.x, self._rect.y, self._rect.width, self._tab_ctrl_height)

            if self._tabs.GetAGWFlags() & AUI_NB_BOTTOM:
                self._tab_rect = wx.Rect(self._rect.x, self._rect.y + self._rect.height - tab_height,
                                         self._rect.width, tab_height)
                self._tabs.SetDimensions(self._rect.x, self._rect.y + self._rect.height - tab_height,
                                         self._rect.width, tab_height)
                self._tabs.SetTabRect(wx.Rect(0, 0, self._rect.width, tab_height))

            else:

                self._tab_rect = wx.Rect(self._rect.x, self._rect.y, self._rect.width, tab_height)
                self._tabs.SetDimensions(self._rect.x, self._rect.y, self._rect.width, tab_height)
                self._tabs.SetTabRect(wx.Rect(0, 0, self._rect.width, tab_height))

            # TODO: elif (GetAGWFlags() & AUI_NB_LEFT)
            # TODO: elif (GetAGWFlags() & AUI_NB_RIGHT)

            self._tabs.Refresh()
            self._tabs.Update()

        else:

            tab_height = 0
            self._tabs.SetDimensions(self._rect.x, self._rect.y, self._rect.width, tab_height)
            self._tabs.SetTabRect(wx.Rect(0, 0, self._rect.width, tab_height))

        pages = self._tabs.GetPages()

        for page in pages:

            height = self._rect.height - tab_height

            if height < 0:
                # avoid passing negative height to wx.Window.SetSize(), this
                # results in assert failures/GTK+ warnings
                height = 0

            if self._tabs.GetAGWFlags() & AUI_NB_BOTTOM:
                page.window.SetDimensions(self._rect.x, self._rect.y, self._rect.width, height)

            else:
                page.window.SetDimensions(self._rect.x, self._rect.y + tab_height,
                                          self._rect.width, height)

            # TODO: elif (GetAGWFlags() & AUI_NB_LEFT)
            # TODO: elif (GetAGWFlags() & AUI_NB_RIGHT)

            if repr(page.window.__class__).find("AuiMDIChildFrame") >= 0:
                page.window.ApplyMDIChildFrameRect()


    def Update(self):
        """
        Calling this method immediately repaints the invalidated area of the window
        and all of its children recursively while this would usually only happen when
        the flow of control returns to the event loop.

        :note: Notice that this function doesn't invalidate any area of the window so
         nothing happens if nothing has been invalidated (i.e. marked as requiring a redraw).
         Use `Refresh` first if you want to immediately redraw the window unconditionally.

        :note: Overridden from :class:`PyControl`.
        """

        # does nothing
        pass


# ----------------------------------------------------------------------
# -- AuiNotebook class implementation --

class AuiNotebook(wx.PyPanel):
    """
    AuiNotebook is a notebook control which implements many features common in applications with dockable panes.
    Specifically, AuiNotebook implements functionality which allows the user to rearrange tab
    order via drag-and-drop, split the tab window into many different splitter configurations, and toggle
    through different themes to customize the control's look and feel.

    An effort has been made to try to maintain an API as similar to that of :class:`Notebook`.

    The default theme that is used is :class:`~lib.agw.aui.tabart.AuiDefaultTabArt`, which provides a modern, glossy
    look and feel. The theme can be changed by calling :meth:`AuiNotebook.SetArtProvider`.
    """

    def __init__(self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.DefaultSize,
                 style=0, agwStyle=AUI_NB_DEFAULT_STYLE, name="AuiNotebook"):
        """
        Default class constructor.

        :param Window `parent`: the :class:`AuiNotebook` parent;
        :param integer `id`: an identifier for the control: a value of -1 is taken to mean a default;
        :param Point `pos`: the control position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform;
        :param Size `size`: the control size. A value of (-1, -1) indicates a default size,
         chosen by either the windowing system or wxPython, depending on platform;
        :param integer `style`: the underlying :class:`PyPanel` window style;
        :param integer `agwStyle`: the AGW-specific window style. This can be a combination of the following bits:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet.
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet.
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close :class:`AuiNotebook` tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by :class:`~lib.agw.aui.framemanager.AuiManager` to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less full screen,
                                              tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ``AUI_NB_ORDER_BY_ACCESS``           Tab navigation order by last access time for the tabs
         ``AUI_NB_NO_TAB_FOCUS``              Don't draw tab focus rectangle
         ==================================== ==================================

         Default value for `agwStyle` is:
         ``AUI_NB_DEFAULT_STYLE`` = ``AUI_NB_TOP`` | ``AUI_NB_TAB_SPLIT`` | ``AUI_NB_TAB_MOVE`` | ``AUI_NB_SCROLL_BUTTONS`` | ``AUI_NB_CLOSE_ON_ACTIVE_TAB`` | ``AUI_NB_MIDDLE_CLICK_CLOSE`` | ``AUI_NB_DRAW_DND_TAB``

        :param string `name`: the window name.
        """

        self._curpage = -1
        self._tab_id_counter = AuiBaseTabCtrlId
        self._dummy_wnd = None
        self._hide_tabs = False
        self._sash_dclick_unsplit = False
        self._tab_ctrl_height = 20
        self._requested_bmp_size = wx.Size(-1, -1)
        self._requested_tabctrl_height = -1
        self._textCtrl = None
        self._tabBounds = (-1, -1)
        self._click_tab = None

        wx.PyPanel.__init__(self, parent, id, pos, size, style|wx.BORDER_NONE|wx.TAB_TRAVERSAL, name=name)
        self._mgr = framemanager.AuiManager()
        self._tabs = AuiTabContainer(self)

        self.InitNotebook(agwStyle)

    NavigatorProps = property(lambda self: self._navProps)


    def Destroy(self):
        """
        Destroys the window safely.

        Use this function instead of the ``del`` operator, since different window
        classes can be destroyed differently. Frames and dialogs are not destroyed
        immediately when this function is called -- they are added to a list of
        windows to be deleted on idle time, when all the window's events have been
        processed. This prevents problems with events being sent to non-existent windows.

        :return: ``True`` if the window has either been successfully deleted, or
         it has been added to the list of windows pending real deletion.

        .. note::

           This method has been added to safely un-initialize the underlying
           :class:`~lib.agw.aui.framemanager.AuiManager` which manages the :class:`AuiNotebook`
           layout (i.e., tab split, re-ordering, tab floating etc...).
         
        """
        
        self._mgr.UnInit()
        return wx.PyPanel.Destroy(self)
        

    def __getitem__(self, index):
        """
        More Pythonic way to get a specific page, also useful for iterating
        over all pages.

        :param integer `index`: the page index.

        .. note::

           This method makes easier to iterate over all the pages in the notebook, i.e. you can
           safely do::

               for page in notebook:
                   DoSomething(page)


        """
        
        if index < self.GetPageCount():
            return self.GetPage(index)
        else:
            raise IndexError("Invalid page index")


    def GetTabContainer(self):
        """ Returns the instance of :class:`AuiTabContainer`. """

        return self._tabs


    def InitNotebook(self, agwStyle):
        """
        Contains common initialization code called by all constructors.

        :param integer `agwStyle`: the notebook style.

        :see: :meth:`~AuiNotebook.__init__` for a list of available `agwStyle` bits.
        """

        self._agwFlags = agwStyle

        self._popupWin = None
        self._imageList = None
        self._navProps = TabNavigatorProps()
        self._last_drag_x = 0

        self._normal_font = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        self._selected_font = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        self._selected_font.SetWeight(wx.BOLD)

        self.SetArtProvider(TA.AuiDefaultTabArt())

        self._dummy_wnd = wx.Window(self, wx.ID_ANY, wx.Point(0, 0), wx.Size(0, 0))
        self._dummy_wnd.SetSize((200, 200))
        self._dummy_wnd.Show(False)

        self._mgr.SetManagedWindow(self)
        self._mgr.SetAGWFlags(AUI_MGR_DEFAULT)
        self._mgr.SetDockSizeConstraint(1.0, 1.0) # no dock size constraint

        self._mgr.AddPane(self._dummy_wnd, framemanager.AuiPaneInfo().Name("dummy").Bottom().CaptionVisible(False).Show(False))
        self._mgr.Update()

        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_CHILD_FOCUS, self.OnChildFocusNotebook)
        self.Bind(EVT_AUINOTEBOOK_PAGE_CHANGING, self.OnTabClicked,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_BEGIN_DRAG, self.OnTabBeginDrag,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_END_DRAG, self.OnTabEndDrag,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_DRAG_MOTION, self.OnTabDragMotion,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_CANCEL_DRAG, self.OnTabCancelDrag,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_BUTTON, self.OnTabButton,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_TAB_MIDDLE_DOWN, self.OnTabMiddleDown,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_TAB_MIDDLE_UP, self.OnTabMiddleUp,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_TAB_RIGHT_DOWN, self.OnTabRightDown,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_TAB_RIGHT_UP, self.OnTabRightUp,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_BG_DCLICK, self.OnTabBgDClick,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)
        self.Bind(EVT_AUINOTEBOOK_TAB_DCLICK, self.OnTabDClick,
                  id=AuiBaseTabCtrlId, id2=AuiBaseTabCtrlId+500)

        self.Bind(wx.EVT_NAVIGATION_KEY, self.OnNavigationKeyNotebook)


    def SetArtProvider(self, art):
        """
        Sets the art provider to be used by the notebook.

        :param `art`: an art provider.
        """

        self._tabs.SetArtProvider(art)
        self.UpdateTabCtrlHeight(force=True)


    def SavePerspective(self):
        """
        Saves the entire user interface layout into an encoded string, which can then
        be stored by the application (probably using :class:`Config`). When a perspective
        is restored using :meth:`LoadPerspective`, the entire user interface will return
        to the state it was when the perspective was saved.
        """

        # Build list of panes/tabs
        tabs = ""
        all_panes = self._mgr.GetAllPanes()

        for pane in all_panes:

            if pane.name == "dummy":
                continue

            tabframe = pane.window

            if tabs:
                tabs += "|"

            tabs += pane.name + "="

            # add tab id's
            page_count = tabframe._tabs.GetPageCount()

            for p in xrange(page_count):

                page = tabframe._tabs.GetPage(p)
                page_idx = self._tabs.GetIdxFromWindow(page.window)

                if p:
                    tabs += ","

                if p == tabframe._tabs.GetActivePage():
                    tabs += "+"
                elif page_idx == self._curpage:
                    tabs += "*"

                tabs += "%u"%page_idx

        tabs += "@"

        # Add frame perspective
        tabs += self._mgr.SavePerspective()

        return tabs


    def LoadPerspective(self, layout):
        """
        Loads a layout which was saved with :meth:`SavePerspective`.

        :param string `layout`: a string which contains a saved :class:`AuiNotebook` layout.
        """

        # Remove all tab ctrls (but still keep them in main index)
        tab_count = self._tabs.GetPageCount()
        for i in xrange(tab_count):
            wnd = self._tabs.GetWindowFromIdx(i)

            # find out which onscreen tab ctrl owns this tab
            ctrl, ctrl_idx = self.FindTab(wnd)
            if not ctrl:
                return False

            # remove the tab from ctrl
            if not ctrl.RemovePage(wnd):
                return False

        self.RemoveEmptyTabFrames()

        sel_page = 0
        tabs = layout[0:layout.index("@")]
        to_break1 = False

        while 1:

            if "|" not in tabs:
                to_break1 = True
                tab_part = tabs
            else:
                tab_part = tabs[0:tabs.index('|')]

            if "=" not in tab_part:
                # No pages in this perspective...
                return False

            # Get pane name
            pane_name = tab_part[0:tab_part.index("=")]

            # create a new tab frame
            new_tabs = TabFrame(self)
            self._tab_id_counter += 1
            new_tabs._tabs = AuiTabCtrl(self, self._tab_id_counter)
            new_tabs._tabs.SetArtProvider(self._tabs.GetArtProvider().Clone())
            new_tabs.SetTabCtrlHeight(self._tab_ctrl_height)
            new_tabs._tabs.SetAGWFlags(self._agwFlags)
            dest_tabs = new_tabs._tabs

            # create a pane info structure with the information
            # about where the pane should be added
            pane_info = framemanager.AuiPaneInfo().Name(pane_name).Bottom().CaptionVisible(False)
            self._mgr.AddPane(new_tabs, pane_info)

            # Get list of tab id's and move them to pane
            tab_list = tab_part[tab_part.index("=")+1:]
            to_break2, active_found = False, False

            while 1:
                if "," not in tab_list:
                    to_break2 = True
                    tab = tab_list
                else:
                    tab = tab_list[0:tab_list.index(",")]
                    tab_list = tab_list[tab_list.index(",")+1:]

                # Check if this page has an 'active' marker
                c = tab[0]
                if c in ['+', '*']:
                    tab = tab[1:]

                tab_idx = int(tab)
                if tab_idx >= self.GetPageCount():
                    to_break1 = True
                    break

                # Move tab to pane
                page = self._tabs.GetPage(tab_idx)
                newpage_idx = dest_tabs.GetPageCount()
                dest_tabs.InsertPage(page.window, page, newpage_idx)

                if c == '+':
                    dest_tabs.SetActivePage(newpage_idx)
                    active_found = True
                elif c == '*':
                    sel_page = tab_idx

                if to_break2:
                    break

            if not active_found:
                dest_tabs.SetActivePage(0)

            new_tabs.DoSizing()
            dest_tabs.DoShowHide()
            dest_tabs.Refresh()

            if to_break1:
                break

            tabs = tabs[tabs.index('|')+1:]

        # Load the frame perspective
        frames = layout[layout.index('@')+1:]
        self._mgr.LoadPerspective(frames)

        # Force refresh of selection
        self._curpage = -1
        self.SetSelection(sel_page)

        return True


    def SetTabCtrlHeight(self, height):
        """
        Sets the tab height.

        By default, the tab control height is calculated by measuring the text
        height and bitmap sizes on the tab captions.

        Calling this method will override that calculation and set the tab control
        to the specified height parameter. A call to this method will override
        any call to :meth:`SetUniformBitmapSize`. Specifying -1 as the height will
        return the control to its default auto-sizing behaviour.

        :param integer `height`: the tab control area height.
        """

        self._requested_tabctrl_height = height

        # if window is already initialized, recalculate the tab height
        if self._dummy_wnd:
            self.UpdateTabCtrlHeight()


    def SetUniformBitmapSize(self, size):
        """
        Ensures that all tabs will have the same height, even if some tabs don't have bitmaps.
        Passing ``wx.DefaultSize`` to this method will instruct the control to use dynamic tab
        height, which is the default behaviour. Under the default behaviour, when a tab with a
        large bitmap is added, the tab control's height will automatically increase to accommodate
        the larger bitmap.

        :param Size `size`: the tab bitmap size.
        """

        self._requested_bmp_size = wx.Size(*size)

        # if window is already initialized, recalculate the tab height
        if self._dummy_wnd:
            self.UpdateTabCtrlHeight()


    def UpdateTabCtrlHeight(self, force=False):
        """
        :meth:`UpdateTabCtrlHeight` does the actual tab resizing. It's meant
        to be used interally.

        :param bool `force`: ``True`` to force the tab art to repaint.
        """

        # get the tab ctrl height we will use
        height = self.CalculateTabCtrlHeight()

        # if the tab control height needs to change, update
        # all of our tab controls with the new height
        if self._tab_ctrl_height != height or force:
            art = self._tabs.GetArtProvider()

            self._tab_ctrl_height = height

            all_panes = self._mgr.GetAllPanes()
            for pane in all_panes:

                if pane.name == "dummy":
                    continue

                tab_frame = pane.window
                tabctrl = tab_frame._tabs
                tab_frame.SetTabCtrlHeight(self._tab_ctrl_height)
                tabctrl.SetArtProvider(art.Clone())
                tab_frame.DoSizing()


    def UpdateHintWindowSize(self):
        """ Updates the :class:`~lib.agw.aui.framemanager.AuiManager` hint window size. """

        size = self.CalculateNewSplitSize()

        # the placeholder hint window should be set to this size
        info = self._mgr.GetPane("dummy")

        if info.IsOk():
            info.MinSize(size)
            info.BestSize(size)
            self._dummy_wnd.SetSize(size)


    def CalculateNewSplitSize(self):
        """ Calculates the size of the new split. """

        # count number of tab controls
        tab_ctrl_count = 0
        all_panes = self._mgr.GetAllPanes()

        for pane in all_panes:
            if pane.name == "dummy":
                continue

            tab_ctrl_count += 1

        # if there is only one tab control, the first split
        # should happen around the middle
        if tab_ctrl_count < 2:
            new_split_size = self.GetClientSize()
            new_split_size.x /= 2
            new_split_size.y /= 2

        else:

            # this is in place of a more complicated calculation
            # that needs to be implemented
            new_split_size = wx.Size(180, 180)

        return new_split_size


    def CalculateTabCtrlHeight(self):
        """ Calculates the tab control area height. """

        # if a fixed tab ctrl height is specified,
        # just return that instead of calculating a
        # tab height
        if self._requested_tabctrl_height != -1:
            return self._requested_tabctrl_height

        # find out new best tab height
        art = self._tabs.GetArtProvider()

        return art.GetBestTabCtrlSize(self, self._tabs.GetPages(), self._requested_bmp_size)


    def GetArtProvider(self):
        """ Returns the associated art provider. """

        return self._tabs.GetArtProvider()


    def SetAGWWindowStyleFlag(self, agwStyle):
        """
        Sets the AGW-specific style of the window.

        :param integer `agwStyle`: the new window style. This can be a combination of the following bits:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet.
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet.
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close :class:`AuiNotebook` tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by :class:`~lib.agw.aui.framemanager.AuiManager` to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less full screen,
                                              tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ``AUI_NB_ORDER_BY_ACCESS``           Tab navigation order by last access time for the tabs
         ``AUI_NB_NO_TAB_FOCUS``              Don't draw tab focus rectangle
         ==================================== ==================================

        :note: Please note that some styles cannot be changed after the window
         creation and that `Refresh` might need to be be called after changing the
         others for the change to take place immediately.

        .. todo:: Implementation of flags ``AUI_NB_RIGHT`` and ``AUI_NB_LEFT``.
        """

        self._agwFlags = agwStyle

        # if the control is already initialized
        if self._mgr.GetManagedWindow() == self:

            # let all of the tab children know about the new style

            all_panes = self._mgr.GetAllPanes()
            for pane in all_panes:
                if pane.name == "dummy":
                    continue

                tabframe = pane.window
                tabctrl = tabframe._tabs
                tabctrl.SetAGWFlags(self._agwFlags)
                tabframe.DoSizing()
                tabctrl.Refresh()
                tabctrl.Update()


    def GetAGWWindowStyleFlag(self):
        """
        Returns the AGW-specific style of the window.

        :see: :meth:`SetAGWWindowStyleFlag` for a list of possible AGW-specific window styles.
        """

        return self._agwFlags


    def AddPage(self, page, caption, select=False, bitmap=wx.NullBitmap, disabled_bitmap=wx.NullBitmap, control=None):
        """
        Adds a page. If the `select` parameter is ``True``, calling this will generate a
        page change event.

        :param Window `page`: the page to be added;
        :param string `caption`: specifies the text for the new page;
        :param bool `select`: specifies whether the page should be selected;
        :param Bitmap `bitmap`: the bitmap to display in the enabled tab;
        :param Bitmap `disabled_bitmap`: the bitmap to display in the disabled tab;
        :param Window `control`: almost any :class:`Window` -derived instance to be located
         inside a tab.
        """

        return self.InsertPage(self.GetPageCount(), page, caption, select, bitmap, disabled_bitmap, control)


    def InsertPage(self, page_idx, page, caption, select=False, bitmap=wx.NullBitmap, disabled_bitmap=wx.NullBitmap,
                   control=None):
        """
        This is similar to :meth:`AddPage`, but allows the ability to specify the insert location.

        :param integer `page_idx`: specifies the position for the new page;
        :param Window `page`: the page to be added;
        :param string `caption`: specifies the text for the new page;
        :param bool `select`: specifies whether the page should be selected;
        :param Bitmap `bitmap`: the bitmap to display in the enabled tab;
        :param Bitmap `disabled_bitmap`: the bitmap to display in the disabled tab;
        :param Window `control`: almost any :class:`Window` -derived instance to be located
         inside a tab.
        """

        if not page:
            return False

        page.Reparent(self)
        info = AuiNotebookPage()
        info.window = page
        info.caption = caption
        info.bitmap = bitmap
        info.active = False
        info.control = control

        originalPaneMgr = framemanager.GetManager(page)
        if originalPaneMgr:
            originalPane = originalPaneMgr.GetPane(page)

            if originalPane:
                info.hasCloseButton = originalPane.HasCloseButton()

        if bitmap.IsOk() and not disabled_bitmap.IsOk():
            disabled_bitmap = MakeDisabledBitmap(bitmap)

        info.dis_bitmap = disabled_bitmap

        # if there are currently no tabs, the first added
        # tab must be active
        if self._tabs.GetPageCount() == 0:
            info.active = True

        self._tabs.InsertPage(page, info, page_idx)

        # if that was the first page added, even if
        # select is False, it must become the "current page"
        # (though no select events will be fired)
        if not select and self._tabs.GetPageCount() == 1:
            select = True

        active_tabctrl = self.GetActiveTabCtrl()
        if page_idx >= active_tabctrl.GetPageCount():
            active_tabctrl.AddPage(page, info)
        else:
            active_tabctrl.InsertPage(page, info, page_idx)

        force = False
        if control:
            force = True
            control.Reparent(active_tabctrl)
            control.Show()

        self.UpdateTabCtrlHeight(force=force)
        self.DoSizing()
        active_tabctrl.DoShowHide()

        # adjust selected index
        if self._curpage >= page_idx:
            self._curpage += 1

        if select:
            self.SetSelectionToWindow(page)

        return True


    def DeletePage(self, page_idx):
        """
        Deletes a page at the given index. Calling this method will generate a page
        change event.

        :param integer `page_idx`: the page index to be deleted.

        :note:

         :meth:`DeletePage` removes a tab from the multi-notebook, and destroys the window as well.

        :see: :meth:`RemovePage`
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        wnd = self._tabs.GetWindowFromIdx(page_idx)
        # hide the window in advance, as this will
        # prevent flicker
        wnd.Show(False)

        self.RemoveControlFromPage(page_idx)

        if not self.RemovePage(page_idx):
            return False

        wnd.Destroy()

        return True


    def RemovePage(self, page_idx):
        """
        Removes a page, without deleting the window pointer.

        :param integer `page_idx`: the page index to be removed.

        :note:

         :meth:`RemovePage` removes a tab from the multi-notebook, but does not destroy the window.

        :see: :meth:`DeletePage`
        """

        # save active window pointer
        active_wnd = None
        if self._curpage >= 0:
            active_wnd = self._tabs.GetWindowFromIdx(self._curpage)

        # save pointer of window being deleted
        wnd = self._tabs.GetWindowFromIdx(page_idx)
        new_active = None

        # make sure we found the page
        if not wnd:
            return False

        # find out which onscreen tab ctrl owns this tab
        ctrl, ctrl_idx = self.FindTab(wnd)
        if not ctrl:
            return False

        currentPage = ctrl.GetPage(ctrl_idx)
        is_curpage = (self._curpage == page_idx)
        is_active_in_split = currentPage.active

        # remove the tab from main catalog
        if not self._tabs.RemovePage(wnd):
            return False

        # remove the tab from the onscreen tab ctrl
        ctrl.RemovePage(wnd)

        if is_active_in_split:

            ctrl_new_page_count = ctrl.GetPageCount()

            if ctrl_idx >= ctrl_new_page_count:
                ctrl_idx = ctrl_new_page_count - 1

            if ctrl_idx >= 0 and ctrl_idx < ctrl.GetPageCount():

                ctrl_idx = self.FindNextActiveTab(ctrl_idx, ctrl)

                # set new page as active in the tab split
                ctrl.SetActivePage(ctrl_idx)

                # if the page deleted was the current page for the
                # entire tab control, then record the window
                # pointer of the new active page for activation
                if is_curpage:
                    new_active = ctrl.GetWindowFromIdx(ctrl_idx)

        else:

            # we are not deleting the active page, so keep it the same
            new_active = active_wnd

        if not new_active:

            # we haven't yet found a new page to active,
            # so select the next page from the main tab
            # catalogue

            if 0 <= page_idx < self._tabs.GetPageCount():
                new_active = self._tabs.GetPage(page_idx).window
            if not new_active and self._tabs.GetPageCount() > 0:
                new_active = self._tabs.GetPage(0).window

        self.RemoveEmptyTabFrames()

        # set new active pane
        if new_active:
            if not self.IsBeingDeleted():
                self._curpage = -1
                self.SetSelectionToWindow(new_active)
        else:
            self._curpage = -1
            self._tabs.SetNoneActive()

        return True


    def FindNextActiveTab(self, ctrl_idx, ctrl):
        """
        Finds the next active tab (used mainly when :class:`AuiNotebook` has inactive/disabled
        tabs in it).

        :param integer `ctrl_idx`: the index of the first (most obvious) tab to check for active status;
        :param `ctrl`: an instance of :class:`AuiTabCtrl`.
        """

        if self.GetEnabled(ctrl_idx):
            return ctrl_idx

        for indx in xrange(ctrl_idx, ctrl.GetPageCount()):
            if self.GetEnabled(indx):
                return indx

        for indx in xrange(ctrl_idx, -1, -1):
            if self.GetEnabled(indx):
                return indx

        return 0


    def HideAllTabs(self, hidden=True):
        """
        Hides all tabs on the :class:`AuiNotebook` control.

        :param bool `hidden`: if ``True`` hides all tabs.
        """

        self._hide_tabs = hidden


    def SetSashDClickUnsplit(self, unsplit=True):
        """
        Sets whether to unsplit a splitted :class:`AuiNotebook` when double-clicking on a sash.

        :param bool `unsplit`: ``True`` to unsplit on sash double-clicking, ``False`` otherwise.
        """

        self._sash_dclick_unsplit = unsplit


    def GetSashDClickUnsplit(self):
        """
        Returns whether a splitted :class:`AuiNotebook` can be unsplitted by double-clicking
        on the splitter sash.
        """

        return self._sash_dclick_unsplit


    def SetMinMaxTabWidth(self, minTabWidth, maxTabWidth):
        """
        Sets the minimum and/or the maximum tab widths for :class:`AuiNotebook` when the
        ``AUI_NB_TAB_FIXED_WIDTH`` style is defined.

        Pass -1 to either `minTabWidth` or `maxTabWidth` to reset to the default tab
        width behaviour for :class:`AuiNotebook`.

        :param integer `minTabWidth`: the minimum allowed tab width, in pixels;
        :param integer `maxTabWidth`: the maximum allowed tab width, in pixels.

        :note: Minimum and maximum tabs widths are used only when the ``AUI_NB_TAB_FIXED_WIDTH``
         style is present.
        """

        if minTabWidth > maxTabWidth:
            raise Exception("Minimum tab width must be less or equal than maximum tab width")

        self._tabBounds = (minTabWidth, maxTabWidth)
        self.SetAGWWindowStyleFlag(self._agwFlags)


    def GetMinMaxTabWidth(self):
        """
        Returns the minimum and the maximum tab widths for :class:`AuiNotebook` when the
        ``AUI_NB_TAB_FIXED_WIDTH`` style is defined.

        :note: Minimum and maximum tabs widths are used only when the ``AUI_NB_TAB_FIXED_WIDTH``
         style is present.

        :see: :meth:`SetMinMaxTabWidth` for more information.
        """

        return self._tabBounds


    def GetPageIndex(self, page_wnd):
        """
        Returns the page index for the specified window. If the window is not
        found in the notebook, ``wx.NOT_FOUND`` is returned.

        :param Window `page_wnd`: the window we are looking for.
        """

        return self._tabs.GetIdxFromWindow(page_wnd)


    def SetPageText(self, page_idx, text):
        """
        Sets the tab label for the page.

        :param integer `page_idx`: the page index;
        :param string `text`: the new tab label.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        should_refresh = page_info.caption != text
        page_info.caption = text

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False

        info = ctrl.GetPage(ctrl_idx)
        should_refresh = should_refresh or info.caption != text
        info.caption = text

        if should_refresh:
            ctrl.Refresh()
            ctrl.Update()

        self.UpdateTabCtrlHeight(force=True)

        return True


    def GetPageText(self, page_idx):
        """
        Returns the tab label for the page.

        :param integer `page_idx`: the page index.
        """

        if page_idx >= self._tabs.GetPageCount():
            return ""

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        return page_info.caption


    def SetPageBitmap(self, page_idx, bitmap):
        """
        Sets the tab bitmap for the page.

        :param integer `page_idx`: the page index;
        :param Bitmap `bitmap`: the bitmap to display on the page tab.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        should_refresh = page_info.bitmap is not bitmap
        page_info.bitmap = bitmap
        if bitmap.IsOk() and not page_info.dis_bitmap.IsOk():
            page_info.dis_bitmap = MakeDisabledBitmap(bitmap)

        # tab height might have changed
        self.UpdateTabCtrlHeight()

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False

        info = ctrl.GetPage(ctrl_idx)
        should_refresh = should_refresh or info.bitmap is not bitmap
        info.bitmap = bitmap
        info.dis_bitmap = page_info.dis_bitmap
        if should_refresh:
            ctrl.Refresh()
            ctrl.Update()

        return True


    def GetPageBitmap(self, page_idx):
        """
        Returns the tab bitmap for the page.

        :param integer `page_idx`: the page index.
        """

        if page_idx >= self._tabs.GetPageCount():
            return wx.NullBitmap

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        return page_info.bitmap


    def SetImageList(self, imageList):
        """
        Sets the image list for the :class:`AuiNotebook` control.

        :param ImageList `imageList`: the bitmap image list to associate to :class:`AuiNotebook`.
        """

        self._imageList = imageList


    def AssignImageList(self, imageList):
        """
        Sets the image list for the :class:`AuiNotebook` control.

        :param `imageList`: an instance of :class:`ImageList`.
        """

        self.SetImageList(imageList)


    def GetImageList(self):
        """ Returns the associated image list (if any). """

        return self._imageList


    def SetPageImage(self, page, image):
        """
        Sets the image index for the given page.

        :param integer `page`: the page index;
        :param integer `image`: an index into the image list which was set with :meth:`SetImageList`.
        """

        if page >= self._tabs.GetPageCount():
            return False

        if not isinstance(image, types.IntType):
            raise Exception("The image parameter must be an integer, you passed " \
                            "%s"%repr(image))

        if not self._imageList:
            raise Exception("To use SetPageImage you need to associate an image list " \
                            "Using SetImageList or AssignImageList")

        if image >= self._imageList.GetImageCount():
            raise Exception("Invalid image index (%d), the image list contains only" \
                            " (%d) bitmaps"%(image, self._imageList.GetImageCount()))

        if image == -1:
            self.SetPageBitmap(page, wx.NullBitmap)
            return

        bitmap = self._imageList.GetBitmap(image)
        self.SetPageBitmap(page, bitmap)


    def GetPageImage(self, page):
        """
        Returns the image index for the given page.

        :param integer `page`: the given page for which to retrieve the image index.
        """

        if page >= self._tabs.GetPageCount():
            return wx.NOT_FOUND

        bitmap = self.GetPageBitmap(page)
        bmpData1 = bitmap.ConvertToImage().GetData()

        for indx in xrange(self._imageList.GetImageCount()):
            imgListBmp = self._imageList.GetBitmap(indx)
            bmpData2 = imgListBmp.ConvertToImage().GetData()
            if bmpData1 == bmpData2:
                return indx

        return wx.NOT_FOUND


    def SetPageTextColour(self, page_idx, colour):
        """
        Sets the tab text colour for the page.

        :param integer `page_idx`: the page index;
        :param Colour `colour`: the new tab label text colour.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        should_refresh = page_info.text_colour != colour
        page_info.text_colour = colour

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False

        info = ctrl.GetPage(ctrl_idx)
        should_refresh = should_refresh or info.text_colour != colour
        info.text_colour = page_info.text_colour

        if should_refresh:
            ctrl.Refresh()
            ctrl.Update()

        return True


    def GetPageTextColour(self, page_idx):
        """
        Returns the tab text colour for the page.

        :param integer `page_idx`: the page index.
        """

        if page_idx >= self._tabs.GetPageCount():
            return wx.NullColour

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        return page_info.text_colour


    def AddControlToPage(self, page_idx, control):
        """
        Adds a control inside a tab (not in the tab area).

        :param integer `page_idx`: the page index;
        :param Window `control`: almost any :class:`Window` -derived instance to be located
         inside a tab.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        page_info.control = control

        # tab height might have changed
        self.UpdateTabCtrlHeight(force=True)

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False

        control.Reparent(ctrl)

        info = ctrl.GetPage(ctrl_idx)
        info.control = control
        ctrl.Refresh()
        ctrl.Update()

        return True


    def RemoveControlFromPage(self, page_idx):
        """
        Removes a control from a tab (not from the tab area).

        :param integer `page_idx`: the page index.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        page_info = self._tabs.GetPage(page_idx)
        if page_info.control is None:
            return False

        page_info.control.Destroy()
        page_info.control = None

        # tab height might have changed
        self.UpdateTabCtrlHeight(force=True)

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False

        info = ctrl.GetPage(ctrl_idx)
        info.control = None
        ctrl.Refresh()
        ctrl.Update()

        return True


    def SetCloseButton(self, page_idx, hasCloseButton):
        """
        Sets whether a tab should display a close button or not.

        :param integer `page_idx`: the page index;
        :param bool `hasCloseButton`: ``True`` if the page displays a close button.

        :note: This can only be called if ``AUI_NB_CLOSE_ON_ALL_TABS`` is specified.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        # There's really not a need for this exception. If the close on
        # all tabs is False, no close buttons get drawn.
        #if self._agwFlags & AUI_NB_CLOSE_ON_ALL_TABS == 0:
        #    raise Exception("SetCloseButton can only be used with AUI_NB_CLOSE_ON_ALL_TABS style.")

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        page_info.hasCloseButton = hasCloseButton

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False

        info = ctrl.GetPage(ctrl_idx)
        info.hasCloseButton = page_info.hasCloseButton
        ctrl.Refresh()
        ctrl.Update()

        return True


    def HasCloseButton(self, page_idx):
        """
        Returns whether a tab displays a close button or not.

        :param integer `page_idx`: the page index.

        :note: This can only be called if ``AUI_NB_CLOSE_ON_ALL_TABS`` is specified.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        page_info = self._tabs.GetPage(page_idx)
        return page_info.hasCloseButton


    def GetSelection(self):
        """ Returns the index of the currently active page, or -1 if none was selected. """

        return self._curpage


    def GetCurrentPage(self):
        """ Returns the currently active page (not the index), or ``None`` if none was selected. """

        if self._curpage >= 0 and self._curpage < self._tabs.GetPageCount():
            return self.GetPage(self._curpage)

        return None


    def EnsureVisible(self, indx):
        """
        Ensures the input page index `indx` is visible.

        :param integer `indx`: the page index.
        """

        self._tabs.MakeTabVisible(indx, self)


    def SetSelection(self, new_page, force=False):
        """
        Sets the page selection. Calling this method will generate a page change event.

        :param integer `new_page`: the index of the new selection;
        :param bool `force`: whether to force the selection or not.
        """
        wnd = self._tabs.GetWindowFromIdx(new_page)

        #Update page access time
        self._tabs.GetPages()[new_page].access_time = datetime.datetime.now()

        if not wnd or not self.GetEnabled(new_page):
            return self._curpage

        # don't change the page unless necessary
        # however, clicking again on a tab should give it the focus.
        if new_page == self._curpage and not force:

            ctrl, ctrl_idx = self.FindTab(wnd)
            if wx.Window.FindFocus() != ctrl:
                ctrl.SetFocus()

            return self._curpage

        evt = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, self.GetId())
        evt.SetSelection(new_page)
        evt.SetOldSelection(self._curpage)
        evt.SetEventObject(self)

        if not self.GetEventHandler().ProcessEvent(evt) or evt.IsAllowed():

            old_curpage = self._curpage
            self._curpage = new_page

            # program allows the page change
            evt.SetEventType(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGED)
            self.GetEventHandler().ProcessEvent(evt)

            if not evt.IsAllowed(): # event is no longer allowed after handler
                return self._curpage

            ctrl, ctrl_idx = self.FindTab(wnd)

            if ctrl:
                self._tabs.SetActivePage(wnd)
                ctrl.SetActivePage(ctrl_idx)
                self.DoSizing()
                ctrl.DoShowHide()
                ctrl.MakeTabVisible(ctrl_idx, ctrl)

                # set fonts
                all_panes = self._mgr.GetAllPanes()
                for pane in all_panes:
                    if pane.name == "dummy":
                        continue

                    tabctrl = pane.window._tabs
                    if tabctrl != ctrl:
                        tabctrl.SetSelectedFont(self._normal_font)
                    else:
                        tabctrl.SetSelectedFont(self._selected_font)

                    tabctrl.Refresh()
                    tabctrl.Update()

                # Set the focus to the page if we're not currently focused on the tab.
                # This is Firefox-like behaviour.
                if wnd.IsShownOnScreen() and wx.Window.FindFocus() != ctrl:
                    wnd.SetFocus()

                return old_curpage

        return self._curpage


    def SetSelectionToWindow(self, win):
        """
        Sets the selection based on the input window `win`.

        :param `win`: a :class:`Window` derived window.
        """

        idx = self._tabs.GetIdxFromWindow(win)

        if idx == wx.NOT_FOUND:
            raise Exception("invalid notebook page")

        if not self.GetEnabled(idx):
            return

        # since a tab was clicked, let the parent know that we received
        # the focus, even if we will assign that focus immediately
        # to the child tab in the SetSelection call below
        # (the child focus event will also let AuiManager, if any,
        # know that the notebook control has been activated)

        parent = self.GetParent()
        if parent:
            eventFocus = wx.ChildFocusEvent(self)
            parent.GetEventHandler().ProcessEvent(eventFocus)

        self.SetSelection(idx)


    def SetSelectionToPage(self, page):
        """
        Sets the selection based on the input page.

        :param `page`: an instance of :class:`AuiNotebookPage`.
        """

        self.SetSelectionToWindow(page.window)


    def GetPageCount(self):
        """ Returns the number of pages in the notebook. """

        return self._tabs.GetPageCount()


    def GetPage(self, page_idx):
        """
        Returns the page specified by the given index.

        :param integer `page_idx`: the page index.
        """

        if page_idx >= self._tabs.GetPageCount():
            raise Exception("invalid notebook page")

        return self._tabs.GetWindowFromIdx(page_idx)


    def GetPageInfo(self, page_idx):
        """
        Returns the :class:`AuiNotebookPage` info structure specified by the given index.

        :param integer `page_idx`: the page index.
        """

        if page_idx >= self._tabs.GetPageCount():
            raise Exception("invalid notebook page")

        return self._tabs.GetPage(page_idx)


    def GetEnabled(self, page_idx):
        """
        Returns whether the page specified by the index `page_idx` is enabled.

        :param integer `page_idx`: the page index.
        """

        return self._tabs.GetEnabled(page_idx)


    def EnableTab(self, page_idx, enable=True):
        """
        Enables/disables a page in the notebook.

        :param integer `page_idx`: the page index;
        :param bool `enable`: ``True`` to enable the page, ``False`` to disable it.
        """

        self._tabs.EnableTab(page_idx, enable)
        self.Refresh()


    def DoSizing(self):
        """ Performs all sizing operations in each tab control. """

        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue

            tabframe = pane.window
            tabframe.DoSizing()


    def GetAuiManager(self):
        """ Returns the associated :class:`~lib.agw.aui.framemanager.AuiManager`. """

        return self._mgr


    def GetActiveTabCtrl(self):
        """
        Returns the active tab control. It is called to determine which control
        gets new windows being added.
        """

        if self._curpage >= 0 and self._curpage < self._tabs.GetPageCount():

            # find the tab ctrl with the current page
            ctrl, idx = self.FindTab(self._tabs.GetPage(self._curpage).window)
            if ctrl:
                return ctrl

        # no current page, just find the first tab ctrl
        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue

            tabframe = pane.window
            return tabframe._tabs

        # If there is no tabframe at all, create one
        tabframe = TabFrame(self)
        tabframe.SetTabCtrlHeight(self._tab_ctrl_height)
        self._tab_id_counter += 1
        tabframe._tabs = AuiTabCtrl(self, self._tab_id_counter)

        tabframe._tabs.SetAGWFlags(self._agwFlags)
        tabframe._tabs.SetArtProvider(self._tabs.GetArtProvider().Clone())
        self._mgr.AddPane(tabframe, framemanager.AuiPaneInfo().Center().CaptionVisible(False).
                          PaneBorder((self._agwFlags & AUI_NB_SUB_NOTEBOOK) == 0))

        self._mgr.Update()

        return tabframe._tabs


    def FindTab(self, page):
        """
        Finds the tab control that currently contains the window as well
        as the index of the window in the tab control. It returns ``True`` if the
        window was found, otherwise ``False``.

        :param `page`: an instance of :class:`AuiNotebookPage`.
        """

        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue

            tabframe = pane.window

            page_idx = tabframe._tabs.GetIdxFromWindow(page)

            if page_idx != -1:

                ctrl = tabframe._tabs
                idx = page_idx
                return ctrl, idx

        return None, wx.NOT_FOUND


    def Split(self, page, direction):
        """
        Performs a split operation programmatically.

        :param integer `page`: indicates the page that will be split off. This page will also become
         the active page after the split.
        :param integer `direction`: specifies where the pane should go, it should be one of the
         following: ``wx.TOP``, ``wx.BOTTOM``, ``wx.LEFT``, or ``wx.RIGHT``.
        """

        cli_size = self.GetClientSize()

        # get the page's window pointer
        wnd = self.GetPage(page)
        if not wnd:
            return

        # notebooks with 1 or less pages can't be split
        if self.GetPageCount() < 2:
            return

        # find out which tab control the page currently belongs to

        src_tabs, src_idx = self.FindTab(wnd)
        if not src_tabs:
            return

        selection = self.GetSelection()
        
        # choose a split size
        if self.GetPageCount() > 2:
            split_size = self.CalculateNewSplitSize()
        else:
            # because there are two panes, always split them
            # equally
            split_size = self.GetClientSize()
            split_size.x /= 2
            split_size.y /= 2

        # create a new tab frame
        new_tabs = TabFrame(self)
        new_tabs._rect = wx.RectPS(wx.Point(0, 0), split_size)
        new_tabs.SetTabCtrlHeight(self._tab_ctrl_height)
        self._tab_id_counter += 1
        new_tabs._tabs = AuiTabCtrl(self, self._tab_id_counter)

        new_tabs._tabs.SetArtProvider(self._tabs.GetArtProvider().Clone())
        new_tabs._tabs.SetAGWFlags(self._agwFlags)
        dest_tabs = new_tabs._tabs

        page_info = src_tabs.GetPage(src_idx)
        if page_info.control:
            self.ReparentControl(page_info.control, dest_tabs)

        cloned_buttons = self.CloneTabAreaButtons()
        for clone in cloned_buttons:
            dest_tabs.AddButton(clone.id, clone.location, clone.bitmap, clone.dis_bitmap)
        # create a pane info structure with the information
        # about where the pane should be added
        pane_info = framemanager.AuiPaneInfo().Bottom().CaptionVisible(False)

        if direction == wx.LEFT:

            pane_info.Left()
            mouse_pt = wx.Point(0, cli_size.y/2)

        elif direction == wx.RIGHT:

            pane_info.Right()
            mouse_pt = wx.Point(cli_size.x, cli_size.y/2)

        elif direction == wx.TOP:

            pane_info.Top()
            mouse_pt = wx.Point(cli_size.x/2, 0)

        elif direction == wx.BOTTOM:

            pane_info.Bottom()
            mouse_pt = wx.Point(cli_size.x/2, cli_size.y)

        self._mgr.AddPane(new_tabs, pane_info, mouse_pt)
        self._mgr.Update()

        # remove the page from the source tabs
        page_info.active = False

        src_tabs.RemovePage(page_info.window)

        if src_tabs.GetPageCount() > 0:
            if selection < 0 or selection == src_idx:
                active_page = 0
            else:
                if selection > src_idx:
                    selection -= 1

                active_page = selection
            
            src_tabs.SetActivePage(active_page)
            src_tabs.DoShowHide()
            src_tabs.Refresh()

        # add the page to the destination tabs
        dest_tabs.InsertPage(page_info.window, page_info, 0)

        if src_tabs.GetPageCount() == 0:
            self.RemoveEmptyTabFrames()

        self.DoSizing()
        dest_tabs.DoShowHide()
        dest_tabs.Refresh()

        # force the set selection function reset the selection
        self._curpage = -1

        # set the active page to the one we just split off
        self.SetSelectionToPage(page_info)

        self.UpdateHintWindowSize()


    def UnSplit(self):
        """ Restores original view after a tab split. """

        self.Freeze()

        # remember the tab now selected
        nowSelected = self.GetSelection()
        # select first tab as destination
        self.SetSelection(0)
        # iterate all other tabs
        for idx in xrange(1, self.GetPageCount()):
            # get win reference
            win = self.GetPage(idx)
            # get tab title
            title = self.GetPageText(idx)
            # get page bitmap
            bmp = self.GetPageBitmap(idx)
            # remove from notebook
            self.RemovePage(idx)
            # re-add in the same position so it will tab
            self.InsertPage(idx, win, title, False, bmp)
        # restore orignial selected tab
        self.SetSelection(nowSelected)

        self.Thaw()


    def ReparentControl(self, control, dest_tabs):
        """
        Reparents a control added inside a tab.

        :param Window `control`: almost any :class:`Window` -derived instance to be located
         inside a tab;
        :param `dest_tabs`: the destination :class:`AuiTabCtrl`.
        """

        control.Hide()
        control.Reparent(dest_tabs)


    def UnsplitDClick(self, part, sash_size, pos):
        """
        Unsplit the :class:`AuiNotebook` on sash double-click.

        :param `part`: an UI part representing the sash;
        :param integer `sash_size`: the sash size;
        :param Point `pos`: the double-click mouse position.

        .. warning::

           Due to a bug on MSW, for disabled pages :func:`FindWindowAtPoint`
           returns the wrong window. See http://trac.wxwidgets.org/ticket/2942
           
        """

        if not self._sash_dclick_unsplit:
            # Unsplit not allowed
            return

        pos1 = wx.Point(*pos)
        pos2 = wx.Point(*pos)
        if part.orientation == wx.HORIZONTAL:
            pos1.y -= 2*sash_size
            pos2.y += 2*sash_size + self.GetTabCtrlHeight()
        elif part.orientation == wx.VERTICAL:
            pos1.x -= 2*sash_size
            pos2.x += 2*sash_size
        else:
            raise Exception("Invalid UI part orientation")

        pos1, pos2 = self.ClientToScreen(pos1), self.ClientToScreen(pos2)
        win1, win2 = wx.FindWindowAtPoint(pos1), wx.FindWindowAtPoint(pos2)

        if isinstance(win1, wx.ScrollBar):
            # Hopefully it will work
            pos1 = wx.Point(*pos)
            shift = wx.SystemSettings.GetMetric(wx.SYS_VSCROLL_X) + 2*(sash_size+1)
            if part.orientation == wx.HORIZONTAL:
                pos1.y -= shift
            else:
                pos1.x -= shift

            pos1 = self.ClientToScreen(pos1)
            win1 = wx.FindWindowAtPoint(pos1)

        if isinstance(win2, wx.ScrollBar):
            pos2 = wx.Point(*pos)
            shift = wx.SystemSettings.GetMetric(wx.SYS_VSCROLL_X) + 2*(sash_size+1)
            if part.orientation == wx.HORIZONTAL:
                pos2.y += shift
            else:
                pos2.x += shift

            pos2 = self.ClientToScreen(pos2)
            win2 = wx.FindWindowAtPoint(pos2)

        if not win1 or not win2:
            # How did we get here?
            return

        if isinstance(win1, AuiNotebook) or isinstance(win2, AuiNotebook):
            # This is a bug on MSW, for disabled pages wx.FindWindowAtPoint
            # returns the wrong window.
            # See http://trac.wxwidgets.org/ticket/2942
            return

        tab_frame1, tab_frame2 = self.GetTabFrameFromWindow(win1), self.GetTabFrameFromWindow(win2)

        if not tab_frame1 or not tab_frame2:
            return

        tab_ctrl_1, tab_ctrl_2 = tab_frame1._tabs, tab_frame2._tabs

        if tab_ctrl_1.GetPageCount() > tab_ctrl_2.GetPageCount():
            src_tabs = tab_ctrl_2
            dest_tabs = tab_ctrl_1
        else:
            src_tabs = tab_ctrl_1
            dest_tabs = tab_ctrl_2

        selection = -1
        page_count = dest_tabs.GetPageCount()

        for page in xrange(src_tabs.GetPageCount()-1, -1, -1):
            # remove the page from the source tabs
            page_info = src_tabs.GetPage(page)
            if page_info.active:
                selection = page_count + page
            src_tabs.RemovePage(page_info.window)

            # add the page to the destination tabs
            dest_tabs.AddPage(page_info.window, page_info)
            if page_info.control:
                self.ReparentControl(page_info.control, dest_tabs)

        self.RemoveEmptyTabFrames()

        dest_tabs.DoShowHide()
        self.DoSizing()
        dest_tabs.Refresh()
        self._mgr.Update()
        if selection > 0:
            wx.CallAfter(dest_tabs.MakeTabVisible, selection, self)


    def OnSize(self, event):
        """
        Handles the ``wx.EVT_SIZE`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`SizeEvent` event to be processed.
        """

        self.UpdateHintWindowSize()
        event.Skip()


    def OnTabClicked(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_PAGE_CHANGING`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        if self._textCtrl is not None:
            self._textCtrl.StopEditing()

        ctrl = event.GetEventObject()
        assert ctrl != None

        wnd = ctrl.GetWindowFromIdx(event.GetSelection())
        assert wnd != None

        self.SetSelectionToWindow(wnd)


    def OnTabBgDClick(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_BG_DCLICK`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        if self._textCtrl is not None:
            self._textCtrl.StopEditing()

        # notify owner that the tabbar background has been double-clicked
        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BG_DCLICK, self.GetId())
        e.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(e)


    def OnTabDClick(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_TAB_DCLICK`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        # notify owner that the tabbar background has been double-clicked
        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_DCLICK, self.GetId())
        e.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(e)

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        if not self.IsRenamable(event.GetSelection()):
            return

        self.EditTab(event.GetSelection())


    def OnTabBeginDrag(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_BEGIN_DRAG`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        self._last_drag_x = 0


    def OnTabDragMotion(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_DRAG_MOTION`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        self._curpage = event.GetSelection()

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        if self._textCtrl is not None:
            self._textCtrl.StopEditing()

        screen_pt = wx.GetMousePosition()
        client_pt = self.ScreenToClient(screen_pt)
        zero = wx.Point(0, 0)

        src_tabs = event.GetEventObject()
        dest_tabs = self.GetTabCtrlFromPoint(client_pt)

        if dest_tabs == src_tabs:

            # always hide the hint for inner-tabctrl drag
            self._mgr.HideHint()

            # if tab moving is not allowed, leave
            if not self._agwFlags & AUI_NB_TAB_MOVE:
                return

            pt = dest_tabs.ScreenToClient(screen_pt)

            # this is an inner-tab drag/reposition
            dest_location_tab = dest_tabs.TabHitTest(pt.x, pt.y)

            if dest_location_tab:

                src_idx = event.GetSelection()
                dest_idx = dest_tabs.GetIdxFromWindow(dest_location_tab)

                # prevent jumpy drag
                if (src_idx == dest_idx) or dest_idx == -1 or \
                   (src_idx > dest_idx and self._last_drag_x <= pt.x) or \
                   (src_idx < dest_idx and self._last_drag_x >= pt.x):

                    self._last_drag_x = pt.x
                    return

                src_tab = dest_tabs.GetWindowFromIdx(src_idx)
                dest_tabs.MovePage(src_tab, dest_idx)
                self._tabs.MovePage(self._tabs.GetPage(src_idx).window, dest_idx)
                dest_tabs.SetActivePage(dest_idx)
                dest_tabs.DoShowHide()
                dest_tabs.Refresh()
                self._last_drag_x = pt.x

            return

        # if external drag is allowed, check if the tab is being dragged
        # over a different AuiNotebook control
        if self._agwFlags & AUI_NB_TAB_EXTERNAL_MOVE:

            tab_ctrl = wx.FindWindowAtPoint(screen_pt)

            # if we aren't over any window, stop here
            if not tab_ctrl:
                if self._agwFlags & AUI_NB_TAB_FLOAT:
                    if self.IsMouseWellOutsideWindow():
                        hintRect = wx.RectPS(screen_pt, (400, 300))
                        # Use CallAfter so we overwrite the hint that might be
                        # shown by our superclass:
                        wx.CallAfter(self._mgr.ShowHint, hintRect)
                return

            # make sure we are not over the hint window
            if not isinstance(tab_ctrl, wx.Frame):
                while tab_ctrl:
                    if isinstance(tab_ctrl, AuiTabCtrl):
                        break

                    tab_ctrl = tab_ctrl.GetParent()

                if tab_ctrl:
                    nb = tab_ctrl.GetParent()

                    if nb != self:

                        hint_rect = tab_ctrl.GetClientRect()
                        hint_rect.x, hint_rect.y = tab_ctrl.ClientToScreenXY(hint_rect.x, hint_rect.y)
                        self._mgr.ShowHint(hint_rect)
                        return

            else:

                if not dest_tabs:
                    # we are either over a hint window, or not over a tab
                    # window, and there is no where to drag to, so exit
                    return

        if self._agwFlags & AUI_NB_TAB_FLOAT:
            if self.IsMouseWellOutsideWindow():
                hintRect = wx.RectPS(screen_pt, (400, 300))
                # Use CallAfter so we overwrite the hint that might be
                # shown by our superclass:
                wx.CallAfter(self._mgr.ShowHint, hintRect)
                return

        # if there are less than two panes, split can't happen, so leave
        if self._tabs.GetPageCount() < 2:
            return

        # if tab moving is not allowed, leave
        if not self._agwFlags & AUI_NB_TAB_SPLIT:
            return

        if dest_tabs:

            hint_rect = dest_tabs.GetRect()
            hint_rect.x, hint_rect.y = self.ClientToScreenXY(hint_rect.x, hint_rect.y)
            self._mgr.ShowHint(hint_rect)

        else:
            rect = self._mgr.CalculateHintRect(self._dummy_wnd, client_pt, zero)
            if rect.IsEmpty():
                self._mgr.HideHint()
                return

            hit_wnd = wx.FindWindowAtPoint(screen_pt)
            if hit_wnd and not isinstance(hit_wnd, AuiNotebook):
                tab_frame = self.GetTabFrameFromWindow(hit_wnd)
                if tab_frame:
                    hint_rect = wx.Rect(*tab_frame._rect)
                    hint_rect.x, hint_rect.y = self.ClientToScreenXY(hint_rect.x, hint_rect.y)
                    rect.Intersect(hint_rect)
                    self._mgr.ShowHint(rect)
                else:
                    self._mgr.DrawHintRect(self._dummy_wnd, client_pt, zero)
            else:
                self._mgr.DrawHintRect(self._dummy_wnd, client_pt, zero)


    def OnTabEndDrag(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_END_DRAG`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        self._mgr.HideHint()

        src_tabs = event.GetEventObject()
        if not src_tabs:
            raise Exception("no source object?")

        # get the mouse position, which will be used to determine the drop point
        mouse_screen_pt = wx.GetMousePosition()
        mouse_client_pt = self.ScreenToClient(mouse_screen_pt)

        # check for an external move
        if self._agwFlags & AUI_NB_TAB_EXTERNAL_MOVE:
            tab_ctrl = wx.FindWindowAtPoint(mouse_screen_pt)

            while tab_ctrl:

                if isinstance(tab_ctrl, AuiTabCtrl):
                    break

                tab_ctrl = tab_ctrl.GetParent()

            if tab_ctrl:

                nb = tab_ctrl.GetParent()

                if nb != self:

                    # find out from the destination control
                    # if it's ok to drop this tab here
                    e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_ALLOW_DND, self.GetId())
                    e.SetSelection(event.GetSelection())
                    e.SetOldSelection(event.GetSelection())
                    e.SetEventObject(self)
                    e.SetDragSource(self)
                    e.Veto() # dropping must be explicitly approved by control owner

                    nb.GetEventHandler().ProcessEvent(e)

                    if not e.IsAllowed():

                        # no answer or negative answer
                        self._mgr.HideHint()
                        return

                    # drop was allowed
                    src_idx = event.GetSelection()
                    src_page = src_tabs.GetWindowFromIdx(src_idx)

                    # Check that it's not an impossible parent relationship
                    p = nb
                    while p and not p.IsTopLevel():
                        if p == src_page:
                            return

                        p = p.GetParent()

                    # get main index of the page
                    main_idx = self._tabs.GetIdxFromWindow(src_page)
                    if main_idx == wx.NOT_FOUND:
                        raise Exception("no source page?")

                    # make a copy of the page info
                    page_info = self._tabs.GetPage(main_idx)

                    # remove the page from the source notebook
                    self.RemovePage(main_idx)

                    # reparent the page
                    src_page.Reparent(nb)

                    # Reparent the control in a tab (if any)
                    if page_info.control:
                        self.ReparentControl(page_info.control, tab_ctrl)

                    # find out the insert idx
                    dest_tabs = tab_ctrl
                    pt = dest_tabs.ScreenToClient(mouse_screen_pt)

                    target = dest_tabs.TabHitTest(pt.x, pt.y)
                    insert_idx = -1
                    if target:
                        insert_idx = dest_tabs.GetIdxFromWindow(target)

                    # add the page to the new notebook
                    if insert_idx == -1:
                        insert_idx = dest_tabs.GetPageCount()

                    dest_tabs.InsertPage(page_info.window, page_info, insert_idx)
                    nb._tabs.AddPage(page_info.window, page_info)

                    nb.DoSizing()
                    dest_tabs.DoShowHide()
                    dest_tabs.Refresh()

                    # set the selection in the destination tab control
                    nb.SetSelectionToPage(page_info)

                    # notify owner that the tab has been dragged
                    e2 = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_DRAG_DONE, self.GetId())
                    e2.SetSelection(event.GetSelection())
                    e2.SetOldSelection(event.GetSelection())
                    e2.SetEventObject(self)
                    self.GetEventHandler().ProcessEvent(e2)

                    # notify the target notebook that the tab has been dragged
                    e3 = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_DRAG_DONE, nb.GetId())
                    e3.SetSelection(insert_idx)
                    e3.SetOldSelection(insert_idx)
                    e3.SetEventObject(nb)
                    nb.GetEventHandler().ProcessEvent(e3)

                    return

        if self._agwFlags & AUI_NB_TAB_FLOAT:
            self._mgr.HideHint()
            if self.IsMouseWellOutsideWindow():
                # Use CallAfter so we our superclass can deal with the event first
                wx.CallAfter(self.FloatPage, self.GetSelection())
                event.Skip()
                return

        # only perform a tab split if it's allowed
        dest_tabs = None

        if self._agwFlags & AUI_NB_TAB_SPLIT and self._tabs.GetPageCount() >= 2:

            # If the pointer is in an existing tab frame, do a tab insert
            hit_wnd = wx.FindWindowAtPoint(mouse_screen_pt)
            tab_frame = self.GetTabFrameFromTabCtrl(hit_wnd)
            insert_idx = -1

            if tab_frame:

                dest_tabs = tab_frame._tabs

                if dest_tabs == src_tabs:
                    return

                pt = dest_tabs.ScreenToClient(mouse_screen_pt)
                target = dest_tabs.TabHitTest(pt.x, pt.y)

                if target:
                    insert_idx = dest_tabs.GetIdxFromWindow(target)

            else:

                zero = wx.Point(0, 0)
                rect = self._mgr.CalculateHintRect(self._dummy_wnd, mouse_client_pt, zero)

                if rect.IsEmpty():
                    # there is no suitable drop location here, exit out
                    return

                # If there is no tabframe at all, create one
                new_tabs = TabFrame(self)
                new_tabs._rect = wx.RectPS(wx.Point(0, 0), self.CalculateNewSplitSize())
                new_tabs.SetTabCtrlHeight(self._tab_ctrl_height)
                self._tab_id_counter += 1
                new_tabs._tabs = AuiTabCtrl(self, self._tab_id_counter)
                new_tabs._tabs.SetArtProvider(self._tabs.GetArtProvider().Clone())
                new_tabs._tabs.SetAGWFlags(self._agwFlags)

                self._mgr.AddPane(new_tabs, framemanager.AuiPaneInfo().Bottom().CaptionVisible(False), mouse_client_pt)
                self._mgr.Update()
                dest_tabs = new_tabs._tabs

                cloned_buttons = self.CloneTabAreaButtons()
                for clone in cloned_buttons:
                    dest_tabs.AddButton(clone.id, clone.location, clone.bitmap, clone.dis_bitmap)
            # remove the page from the source tabs
            page_info = src_tabs.GetPage(event.GetSelection())

            if page_info.control:
                self.ReparentControl(page_info.control, dest_tabs)

            page_info.active = False
            src_tabs.RemovePage(page_info.window)

            if src_tabs.GetPageCount() > 0:
                src_tabs.SetActivePage(0)
                src_tabs.DoShowHide()
                src_tabs.Refresh()

            # add the page to the destination tabs
            if insert_idx == -1:
                insert_idx = dest_tabs.GetPageCount()

            dest_tabs.InsertPage(page_info.window, page_info, insert_idx)

            if src_tabs.GetPageCount() == 0:
                self.RemoveEmptyTabFrames()

            self.DoSizing()
            dest_tabs.DoShowHide()
            dest_tabs.Refresh()

            # force the set selection function reset the selection
            self._curpage = -1

            # set the active page to the one we just split off
            self.SetSelectionToPage(page_info)

            self.UpdateHintWindowSize()

        # notify owner that the tab has been dragged
        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_DRAG_DONE, self.GetId())
        e.SetSelection(event.GetSelection())
        e.SetOldSelection(event.GetSelection())
        e.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(e)


    def OnTabCancelDrag(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_CANCEL_DRAG`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        self._mgr.HideHint()

        src_tabs = event.GetEventObject()
        if not src_tabs:
            raise Exception("no source object?")


    def IsMouseWellOutsideWindow(self):
        """ Returns whether the mouse is well outside the :class:`AuiNotebook` screen rectangle. """

        screen_rect = self.GetScreenRect()
        screen_rect.Inflate(50, 50)

        return not screen_rect.Contains(wx.GetMousePosition())


    def FloatPage(self, page_index):
        """
        Float the page in `page_index` by reparenting it to a floating frame.

        :param integer `page_index`: the index of the page to be floated.

        .. warning::

           When the notebook is more or less full screen, tabs cannot be dragged far
           enough outside of the notebook to become floating pages.
           
        """

        root_manager = framemanager.GetManager(self)
        page_title = self.GetPageText(page_index)
        page_contents = self.GetPage(page_index)
        page_bitmap = self.GetPageBitmap(page_index)
        text_colour = self.GetPageTextColour(page_index)
        info = self.GetPageInfo(page_index)

        if root_manager and root_manager != self._mgr:
            root_manager = framemanager.GetManager(self)

            if hasattr(page_contents, "__floating_size__"):
                floating_size = wx.Size(*page_contents.__floating_size__)
            else:
                floating_size = page_contents.GetBestSize()
                if floating_size == wx.DefaultSize:
                    floating_size = wx.Size(300, 200)

            page_contents.__page_index__ = page_index
            page_contents.__aui_notebook__ = self
            page_contents.__text_colour__ = text_colour
            page_contents.__control__ = info.control

            if info.control:
                info.control.Reparent(page_contents)
                info.control.Hide()
                info.control = None

            self.RemovePage(page_index)
            self.RemoveEmptyTabFrames()

            pane_info = framemanager.AuiPaneInfo().Float().FloatingPosition(wx.GetMousePosition()). \
                        FloatingSize(floating_size).BestSize(floating_size).Name("__floating__%s"%page_title). \
                        Caption(page_title).Icon(page_bitmap)
            root_manager.AddPane(page_contents, pane_info)
            root_manager.Bind(framemanager.EVT_AUI_PANE_CLOSE, self.OnCloseFloatingPage)
            self.GetActiveTabCtrl().DoShowHide()
            self.DoSizing()
            root_manager.Update()

        else:
            frame = wx.Frame(self, title=page_title,
                             style=wx.DEFAULT_FRAME_STYLE|wx.FRAME_TOOL_WINDOW|
                                   wx.FRAME_FLOAT_ON_PARENT | wx.FRAME_NO_TASKBAR)

            if info.control:
                info.control.Reparent(frame)
                info.control.Hide()

            frame.bitmap = page_bitmap
            frame.page_index = page_index
            frame.text_colour = text_colour
            frame.control = info.control
            page_contents.Reparent(frame)
            frame.Bind(wx.EVT_CLOSE, self.OnCloseFloatingPage)
            frame.Move(wx.GetMousePosition())
            frame.Show()
            self.RemovePage(page_index)

            self.RemoveEmptyTabFrames()

        wx.CallAfter(self.RemoveEmptyTabFrames)


    def OnCloseFloatingPage(self, event):
        """
        Handles the ``wx.EVT_CLOSE`` event for a floating page in :class:`AuiNotebook`.

        :param `event`: a :class:`CloseEvent` event to be processed.
        """

        root_manager = framemanager.GetManager(self)
        if root_manager and root_manager != self._mgr:
            pane = event.pane
            if pane.name.startswith("__floating__"):
                self.ReDockPage(pane)
                return

            event.Skip()
        else:
            event.Skip()
            frame = event.GetEventObject()
            page_title = frame.GetTitle()
            page_contents = list(frame.GetChildren())[-1]
            page_contents.Reparent(self)
            self.InsertPage(frame.page_index, page_contents, page_title, select=True, bitmap=frame.bitmap, control=frame.control)

            if frame.control:
                src_tabs, idx = self.FindTab(page_contents)
                frame.control.Reparent(src_tabs)
                frame.control.Hide()
                frame.control = None

            self.SetPageTextColour(frame.page_index, frame.text_colour)


    def ReDockPage(self, pane):
        """
        Re-docks a floating :class:`AuiNotebook` tab in the original position, when possible.

        :param `pane`: an instance of :class:`~lib.agw.aui.framemanager.AuiPaneInfo`.
        """

        root_manager = framemanager.GetManager(self)

        pane.window.__floating_size__ = wx.Size(*pane.floating_size)
        page_index = pane.window.__page_index__
        text_colour = pane.window.__text_colour__
        control = pane.window.__control__

        root_manager.DetachPane(pane.window)
        self.InsertPage(page_index, pane.window, pane.caption, True, pane.icon, control=control)

        self.SetPageTextColour(page_index, text_colour)
        self.GetActiveTabCtrl().DoShowHide()
        self.DoSizing()
        if control:
            self.UpdateTabCtrlHeight(force=True)

        self._mgr.Update()
        root_manager.Update()


    def GetTabCtrlFromPoint(self, pt):
        """
        Returns the tab control at the specified point.

        :param Point `pt`: the mouse location.
        """

        # if we've just removed the last tab from the source
        # tab set, the remove the tab control completely
        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue

            tabframe = pane.window
            if tabframe._tab_rect.Contains(pt):
                return tabframe._tabs

        return None


    def GetTabFrameFromTabCtrl(self, tab_ctrl):
        """
        Returns the tab frame associated with a tab control.

        :param `tab_ctrl`: an instance of :class:`AuiTabCtrl`.
        """

        # if we've just removed the last tab from the source
        # tab set, the remove the tab control completely
        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue

            tabframe = pane.window
            if tabframe._tabs == tab_ctrl:
                return tabframe

        return None


    def GetTabFrameFromWindow(self, wnd):
        """
        Returns the tab frame associated with a window.

        :param Window `wnd`: the window for which we want to locate the :class:`TabFrame`.
        """

        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue

            tabframe = pane.window
            for page in tabframe._tabs.GetPages():
                if wnd == page.window:
                    return tabframe

        return None


    def RemoveEmptyTabFrames(self):
        """ Removes all the empty tab frames. """

        # if we've just removed the last tab from the source
        # tab set, the remove the tab control completely
        all_panes = self._mgr.GetAllPanes()

        for indx in xrange(len(all_panes)-1, -1, -1):
            pane = all_panes[indx]
            if pane.name == "dummy":
                continue

            tab_frame = pane.window
            if tab_frame._tabs.GetPageCount() == 0:
                self._mgr.DetachPane(tab_frame)
                tab_frame._tabs.Destroy()
                tab_frame._tabs = None
                del tab_frame

        # check to see if there is still a center pane
        # if there isn't, make a frame the center pane
        first_good = None
        center_found = False

        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue

            if pane.dock_direction == AUI_DOCK_CENTRE:
                center_found = True
            if not first_good:
                first_good = pane.window

        if not center_found and first_good:
            self._mgr.GetPane(first_good).Centre()

        if not self.IsBeingDeleted():
            self._mgr.Update()


    def OnChildFocusNotebook(self, event):
        """
        Handles the ``wx.EVT_CHILD_FOCUS`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`ChildFocusEvent` event to be processed.
        """

        # if we're dragging a tab, don't change the current selection.
        # This code prevents a bug that used to happen when the hint window
        # was hidden.  In the bug, the focus would return to the notebook
        # child, which would then enter this handler and call
        # SetSelection, which is not desired turn tab dragging.

        event.Skip()

        all_panes = self._mgr.GetAllPanes()
        for pane in all_panes:
            if pane.name == "dummy":
                continue
            tabframe = pane.window
            if tabframe._tabs.IsDragging():
                return

##        # change the tab selection to the child
##        # which was focused
##        idx = self._tabs.GetIdxFromWindow(event.GetWindow())
##        if idx != -1 and idx != self._curpage:
##            self.SetSelection(idx)


    def SetNavigatorIcon(self, bmp):
        """
        Sets the icon used by the :class:`TabNavigatorWindow`.

        :param Bitmap `bmp`: the new bitmap for the :class:`TabNavigatorWindow`.
        """

        if isinstance(bmp, wx.Bitmap) and bmp.IsOk():
            self.NavigatorProps.Icon = bmp
        else:
            raise TypeError("SetNavigatorIcon requires a valid bitmap")


    def OnNavigationKeyNotebook(self, event):
        """
        Handles the ``wx.EVT_NAVIGATION_KEY`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`NavigationKeyEvent` event to be processed.
        """

        if event.IsWindowChange():
            if self._agwFlags & AUI_NB_SMART_TABS:
                if not self._popupWin:
                    self._popupWin = TabNavigatorWindow(self, self.NavigatorProps)
                    self._popupWin.SetReturnCode(wx.ID_OK)
                    self._popupWin.ShowModal()
                    idx = self._popupWin.GetSelectedPage()
                    self._popupWin.Destroy()
                    self._popupWin = None
                    # Need to do CallAfter so that the selection and its
                    # associated events get processed outside the context of
                    # this key event. Not doing so causes odd issues with the
                    # window focus under certain use cases on Windows.
                    wx.CallAfter(self.SetSelection, idx, True)
                else:
                    # a dialog is already opened
                    self._popupWin.OnNavigationKey(event)
                    return
            else:
                # change pages
                # FIXME: the problem with this is that if we have a split notebook,
                # we selection may go all over the place.
                self.AdvanceSelection(event.GetDirection())

        else:
            # we get this event in 3 cases
            #
            # a) one of our pages might have generated it because the user TABbed
            # out from it in which case we should propagate the event upwards and
            # our parent will take care of setting the focus to prev/next sibling
            #
            # or
            #
            # b) the parent panel wants to give the focus to us so that we
            # forward it to our selected page. We can't deal with this in
            # OnSetFocus() because we don't know which direction the focus came
            # from in this case and so can't choose between setting the focus to
            # first or last panel child
            #
            # or
            #
            # c) we ourselves (see MSWTranslateMessage) generated the event
            #
            parent = self.GetParent()

            # the wxObject* casts are required to avoid MinGW GCC 2.95.3 ICE
            isFromParent = event.GetEventObject() == parent
            isFromSelf = event.GetEventObject() == self

            if isFromParent or isFromSelf:

                # no, it doesn't come from child, case (b) or (c): forward to a
                # page but only if direction is backwards (TAB) or from ourselves,
                if self.GetSelection() != wx.NOT_FOUND and (not event.GetDirection() or isFromSelf):

                    # so that the page knows that the event comes from it's parent
                    # and is being propagated downwards
                    event.SetEventObject(self)

                    page = self.GetPage(self.GetSelection())
                    if not page.GetEventHandler().ProcessEvent(event):
                        page.SetFocus()

                    #else: page manages focus inside it itself

                else: # otherwise set the focus to the notebook itself

                    self.SetFocus()

            else:

                # send this event back for the 'wraparound' focus.
                winFocus = event.GetCurrentFocus()

                if winFocus:
                    event.SetEventObject(self)
                    winFocus.GetEventHandler().ProcessEvent(event)


    def OnTabButton(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_BUTTON`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        tabs = event.GetEventObject()
        button_id = event.GetInt()

        if button_id == AUI_BUTTON_CLOSE:

            selection = event.GetSelection()

            if selection == -1:

                # if the close button is to the right, use the active
                # page selection to determine which page to close
                selection = tabs.GetActivePage()

            if selection == -1 or not tabs.GetEnabled(selection):
                return

            if selection != -1:

                close_wnd = tabs.GetWindowFromIdx(selection)

                if close_wnd.GetName() == "__fake__page__":
                    # This is a notebook preview
                    previous_active, page_status = close_wnd.__previousStatus
                    for page, status in zip(tabs.GetPages(), page_status):
                        page.enabled = status

                    main_idx = self._tabs.GetIdxFromWindow(close_wnd)
                    self.DeletePage(main_idx)

                    if previous_active >= 0:
                        tabs.SetActivePage(previous_active)
                        page_count = tabs.GetPageCount()
                        selection = -1

                        for page in xrange(page_count):
                            # remove the page from the source tabs
                            page_info = tabs.GetPage(page)
                            if page_info.active:
                                selection = page
                                break

                        tabs.DoShowHide()
                        self.DoSizing()
                        tabs.Refresh()

                        if selection >= 0:
                            wx.CallAfter(tabs.MakeTabVisible, selection, self)

                    # Don't fire the event
                    return

                # ask owner if it's ok to close the tab
                e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CLOSE, self.GetId())
                idx = self._tabs.GetIdxFromWindow(close_wnd)
                e.SetSelection(idx)
                e.SetOldSelection(event.GetSelection())
                e.SetEventObject(self)
                self.GetEventHandler().ProcessEvent(e)
                if not e.IsAllowed():
                    return

                if repr(close_wnd.__class__).find("AuiMDIChildFrame") >= 0:
                    close_wnd.Close()

                else:
                    main_idx = self._tabs.GetIdxFromWindow(close_wnd)
                    self.DeletePage(main_idx)

                # notify owner that the tab has been closed
                e2 = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CLOSED, self.GetId())
                e2.SetSelection(idx)
                e2.SetEventObject(self)
                self.GetEventHandler().ProcessEvent(e2)

                if self.GetPageCount() == 0:
                    mgr = self.GetAuiManager()
                    win = mgr.GetManagedWindow()
                    win.SendSizeEvent()


    def OnTabMiddleDown(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_TAB_MIDDLE_DOWN`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        # patch event through to owner
        wnd = tabs.GetWindowFromIdx(event.GetSelection())

        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_DOWN, self.GetId())
        e.SetSelection(self._tabs.GetIdxFromWindow(wnd))
        e.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(e)


    def OnTabMiddleUp(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_TAB_MIDDLE_UP`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        # if the AUI_NB_MIDDLE_CLICK_CLOSE is specified, middle
        # click should act like a tab close action.  However, first
        # give the owner an opportunity to handle the middle up event
        # for custom action

        wnd = tabs.GetWindowFromIdx(event.GetSelection())

        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_MIDDLE_UP, self.GetId())
        e.SetSelection(self._tabs.GetIdxFromWindow(wnd))
        e.SetEventObject(self)
        if self.GetEventHandler().ProcessEvent(e):
            return
        if not e.IsAllowed():
            return

        # check if we are supposed to close on middle-up
        if self._agwFlags & AUI_NB_MIDDLE_CLICK_CLOSE == 0:
            return

        # simulate the user pressing the close button on the tab
        event.SetInt(AUI_BUTTON_CLOSE)
        self.OnTabButton(event)


    def OnTabRightDown(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_TAB_RIGHT_DOWN`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        # patch event through to owner
        wnd = tabs.GetWindowFromIdx(event.GetSelection())

        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_DOWN, self.GetId())
        e.SetSelection(self._tabs.GetIdxFromWindow(wnd))
        e.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(e)


    def OnTabRightUp(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_TAB_RIGHT_UP`` event for :class:`AuiNotebook`.

        :param `event`: a :class:`AuiNotebookEvent` event to be processed.
        """

        tabs = event.GetEventObject()
        if not tabs.GetEnabled(event.GetSelection()):
            return

        # patch event through to owner
        wnd = tabs.GetWindowFromIdx(event.GetSelection())

        e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_TAB_RIGHT_UP, self.GetId())
        e.SetSelection(self._tabs.GetIdxFromWindow(wnd))
        e.SetEventObject(self)
        self.GetEventHandler().ProcessEvent(e)


    def SetNormalFont(self, font):
        """
        Sets the normal font for drawing tab labels.

        :param Font `font`: the new font to use to draw tab labels in their normal, un-selected state.
        """

        self._normal_font = font
        self.GetArtProvider().SetNormalFont(font)


    def SetSelectedFont(self, font):
        """
        Sets the selected tab font for drawing tab labels.

        :param Font `font`: the new font to use to draw tab labels in their selected state.
        """

        self._selected_font = font
        self.GetArtProvider().SetSelectedFont(font)


    def SetMeasuringFont(self, font):
        """
        Sets the font for calculating text measurements.

        :param Font `font`: the new font to use to measure tab label text extents.
        """

        self.GetArtProvider().SetMeasuringFont(font)


    def SetFont(self, font):
        """
        Sets the tab font.

        :param Font `font`: the new font to use to draw tab labels in their normal, un-selected state.

        :note: Overridden from :class:`PyPanel`.
        """

        wx.PyPanel.SetFont(self, font)

        selectedFont = wx.Font(font.GetPointSize(), font.GetFamily(),
                               font.GetStyle(), wx.BOLD, font.GetUnderlined(),
                               font.GetFaceName(), font.GetEncoding())

        self.SetNormalFont(font)
        self.SetSelectedFont(selectedFont)
        self.SetMeasuringFont(selectedFont)

        # Recalculate tab container size based on new font
        self.UpdateTabCtrlHeight(force=False)
        self.DoSizing()

        return True


    def GetTabCtrlHeight(self):
        """ Returns the tab control height. """

        return self._tab_ctrl_height


    def GetHeightForPageHeight(self, pageHeight):
        """
        Gets the height of the notebook for a given page height.

        :param integer `pageHeight`: the given page height.
        """

        self.UpdateTabCtrlHeight()

        tabCtrlHeight = self.GetTabCtrlHeight()
        decorHeight = 2
        return tabCtrlHeight + pageHeight + decorHeight


    def AdvanceSelection(self, forward=True, wrap=True):
        """
        Cycles through the tabs.

        :param bool `forward`: whether to advance forward or backward;
        :param bool `wrap`: ``True`` to return to the first tab if we reach the last tab.

        :note: The call to this function generates the page changing events.
        """

        tabCtrl = self.GetActiveTabCtrl()
        newPage = -1

        focusWin = tabCtrl.FindFocus()
        activePage = tabCtrl.GetActivePage()
        lenPages = len(tabCtrl.GetPages())

        if lenPages == 1:
            return False

        if forward:
            if lenPages > 1:

                if activePage == -1 or activePage == lenPages - 1:
                    if not wrap:
                        return False

                    newPage = 0

                elif activePage < lenPages - 1:
                    newPage = activePage + 1

        else:

            if lenPages > 1:
                if activePage == -1 or activePage == 0:
                    if not wrap:
                        return False

                    newPage = lenPages - 1

                elif activePage > 0:
                    newPage = activePage - 1


        if newPage != -1:
            if not self.GetEnabled(newPage):
                return False

            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, tabCtrl.GetId())
            e.SetSelection(newPage)
            e.SetOldSelection(activePage)
            e.SetEventObject(tabCtrl)
            self.GetEventHandler().ProcessEvent(e)

##        if focusWin:
##            focusWin.SetFocus()

        return True


    def ShowWindowMenu(self):
        """
        Shows the window menu for the active tab control associated with this
        notebook, and returns ``True`` if a selection was made.
        """

        tabCtrl = self.GetActiveTabCtrl()
        idx = tabCtrl.GetArtProvider().ShowDropDown(tabCtrl, tabCtrl.GetPages(), tabCtrl.GetActivePage())

        if not self.GetEnabled(idx):
            return False

        if idx != -1:
            e = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGING, tabCtrl.GetId())
            e.SetSelection(idx)
            e.SetOldSelection(tabCtrl.GetActivePage())
            e.SetEventObject(tabCtrl)
            self.GetEventHandler().ProcessEvent(e)

            return True

        else:

            return False


    def AddTabAreaButton(self, id, location, normal_bitmap=wx.NullBitmap, disabled_bitmap=wx.NullBitmap):
        """
        Adds a button in the tab area.

        :param integer `id`: the button identifier. This can be one of the following:

         ==============================  =================================
         Button Identifier               Description
         ==============================  =================================
         ``AUI_BUTTON_CLOSE``            Shows a close button on the tab area
         ``AUI_BUTTON_WINDOWLIST``       Shows a window list button on the tab area
         ``AUI_BUTTON_LEFT``             Shows a left button on the tab area
         ``AUI_BUTTON_RIGHT``            Shows a right button on the tab area
         ==============================  =================================

        :param integer `location`: the button location. Can be ``wx.LEFT`` or ``wx.RIGHT``;
        :param Bitmap `normal_bitmap`: the bitmap for an enabled tab;
        :param Bitmap `disabled_bitmap`: the bitmap for a disabled tab.
        """

        active_tabctrl = self.GetActiveTabCtrl()
        active_tabctrl.AddButton(id, location, normal_bitmap, disabled_bitmap)


    def RemoveTabAreaButton(self, id):
        """
        Removes a button from the tab area.

        :param integer `id`: the button identifier.

        :see: :meth:`AddTabAreaButton` for a list of button identifiers.
        """

        active_tabctrl = self.GetActiveTabCtrl()
        active_tabctrl.RemoveButton(id)


    def CloneTabAreaButtons(self):
        """
        Clones the tab area buttons when the :class:`AuiNotebook` is being split.

        :see: :meth:`AddTabAreaButton`
        
        :note: Standard buttons for :class:`AuiNotebook` are not cloned, only custom ones.
        """

        active_tabctrl = self.GetActiveTabCtrl()
        clones = active_tabctrl.CloneButtons()

        return clones


    def HasMultiplePages(self):
        """
        This method should be overridden to return ``True`` if this window has multiple pages. All
        standard class with multiple pages such as :class:`Notebook`, :class:`Listbook` and :class:`Treebook`
        already override it to return ``True`` and user-defined classes with similar behaviour
        should do it as well to allow the library to handle such windows appropriately.

        :note: Overridden from :class:`PyPanel`.
        """

        return True


    def GetDefaultBorder(self):
        """ Returns the default border style for :class:`AuiNotebook`. """

        return wx.BORDER_NONE


    def NotebookPreview(self, thumbnail_size=200):
        """
        Generates a preview of all the pages in the notebook (MSW and GTK only).

        :param integer `thumbnail_size`: the maximum size of every page thumbnail
         (default=200 pixels).

        :note: this functionality is currently unavailable on wxMAC.
        """

        if wx.Platform == "__WXMAC__":
            return False

        tabCtrl = self.GetActiveTabCtrl()
        activePage = tabCtrl.GetActivePage()
        pages = tabCtrl.GetPages()

        pageStatus, pageText = [], []

        for indx, page in enumerate(pages):

            pageStatus.append(page.enabled)

            if not page.enabled:
                continue

            self.SetSelectionToPage(page)
            pageText.append(page.caption)

            rect = page.window.GetScreenRect()
            bmp = RescaleScreenShot(TakeScreenShot(rect), thumbnail_size)

            page.enabled = False
            if indx == 0:
                il = wx.ImageList(bmp.GetWidth(), bmp.GetHeight(), True)

            il.Add(bmp)

        # create the list control
        listCtrl = wx.ListCtrl(self, style=wx.LC_ICON|wx.LC_AUTOARRANGE|wx.LC_HRULES|wx.LC_VRULES,
                               name="__fake__page__")

        # assign the image list to it
        listCtrl.AssignImageList(il, wx.IMAGE_LIST_NORMAL)
        listCtrl.__previousStatus = [activePage, pageStatus]

        # create some items for the list
        for indx, text in enumerate(pageText):
            listCtrl.InsertImageStringItem(10000, text, indx)

        self.AddPage(listCtrl, "AuiNotebook Preview", True, bitmap=auinotebook_preview.GetBitmap(), disabled_bitmap=wx.NullBitmap)
        return True


    def SetRenamable(self, page_idx, renamable):
        """
        Sets whether a tab can be renamed via a left double-click or not.

        :param integer `page_idx`: the page index;
        :param bool `renamable`: ``True`` if the page can be renamed.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        # update our own tab catalog
        page_info = self._tabs.GetPage(page_idx)
        page_info.renamable = renamable

        # update what's on screen
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False

        info = ctrl.GetPage(ctrl_idx)
        info.renamable = page_info.renamable

        return True


    def IsRenamable(self, page_idx):
        """
        Returns whether a tab can be renamed or not.

        :param integer `page_idx`: the page index.

        :returns: ``True`` is a page can be renamed, ``False`` otherwise.
        """

        if page_idx >= self._tabs.GetPageCount():
            return False

        page_info = self._tabs.GetPage(page_idx)
        return page_info.renamable


    def OnRenameCancelled(self, page_index):
        """
        Called by :class:`TabTextCtrl`, to cancel the changes and to send the
        ``EVT_AUINOTEBOOK_END_LABEL_EDIT`` event.

        :param integer `page_index`: the page index in the notebook.
        """

        # let owner know that the edit was cancelled
        evt = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_END_LABEL_EDIT, self.GetId())

        evt.SetSelection(page_index)
        evt.SetEventObject(self)
        evt.SetLabel("")
        evt.SetEditCanceled(True)
        self.GetEventHandler().ProcessEvent(evt)


    def OnRenameAccept(self, page_index, value):
        """
        Called by :class:`TabTextCtrl`, to accept the changes and to send the
        ``EVT_AUINOTEBOOK_END_LABEL_EDIT`` event.

        :param integer `page_index`: the page index in the notebook;
        :param string `value`: the new label for the tab.
        """

        evt = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_END_LABEL_EDIT, self.GetId())
        evt.SetSelection(page_index)
        evt.SetEventObject(self)
        evt.SetLabel(value)
        evt.SetEditCanceled(False)

        return not self.GetEventHandler().ProcessEvent(evt) or evt.IsAllowed()


    def ResetTextControl(self):
        """ Called by :class:`TabTextCtrl` when it marks itself for deletion. """

        if not self._textCtrl:
            return

        self._textCtrl.Destroy()
        self._textCtrl = None

        # tab height might have changed
        self.UpdateTabCtrlHeight(force=True)


    def EditTab(self, page_index):
        """
        Starts the editing of an item label, sending a ``EVT_AUINOTEBOOK_BEGIN_LABEL_EDIT`` event.

        :param integer `page_index`: the page index we want to edit.
        """

        if page_index >= self._tabs.GetPageCount():
            return False

        if not self.IsRenamable(page_index):
            return False

        page_info = self._tabs.GetPage(page_index)
        ctrl, ctrl_idx = self.FindTab(page_info.window)
        if not ctrl:
            return False

        evt = AuiNotebookEvent(wxEVT_COMMAND_AUINOTEBOOK_BEGIN_LABEL_EDIT, self.GetId())
        evt.SetSelection(page_index)
        evt.SetEventObject(self)
        if self.GetEventHandler().ProcessEvent(evt) and not evt.IsAllowed():
            # vetoed by user
            return False

        if self._textCtrl is not None and page_info != self._textCtrl.item():
            self._textCtrl.StopEditing()

        self._textCtrl = TabTextCtrl(ctrl, page_info, page_index)
        self._textCtrl.SetFocus()

        return True

########NEW FILE########
__FILENAME__ = aui_constants
"""
This module contains all the constants used by wxPython-AUI.

Especially important and meaningful are constants for AuiManager, AuiDockArt and
AuiNotebook.
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx
from wx.lib.embeddedimage import PyEmbeddedImage

# ------------------------- #
# - AuiNotebook Constants - #
# ------------------------- #

# For tabart
# --------------

vertical_border_padding = 4
""" Border padding used in drawing tabs. """

if wx.Platform == "__WXMAC__":
    nb_close_bits = "\xFF\xFF\xFF\xFF\x0F\xFE\x03\xF8\x01\xF0\x19\xF3" \
                    "\xB8\xE3\xF0\xE1\xE0\xE0\xF0\xE1\xB8\xE3\x19\xF3" \
                    "\x01\xF0\x03\xF8\x0F\xFE\xFF\xFF"
    """ AuiNotebook close button image on wxMAC. """

elif wx.Platform == "__WXGTK__":
    nb_close_bits = "\xff\xff\xff\xff\x07\xf0\xfb\xef\xdb\xed\x8b\xe8" \
                    "\x1b\xec\x3b\xee\x1b\xec\x8b\xe8\xdb\xed\xfb\xef" \
                    "\x07\xf0\xff\xff\xff\xff\xff\xff"
    """ AuiNotebook close button image on wxGTK. """

else:
    nb_close_bits = "\xff\xff\xff\xff\xff\xff\xff\xff\xe7\xf3\xcf\xf9" \
                    "\x9f\xfc\x3f\xfe\x3f\xfe\x9f\xfc\xcf\xf9\xe7\xf3" \
                    "\xff\xff\xff\xff\xff\xff\xff\xff"
    """ AuiNotebook close button image on wxMSW. """

nb_left_bits = "\xff\xff\xff\xff\xff\xff\xff\xfe\x7f\xfe\x3f\xfe\x1f" \
               "\xfe\x0f\xfe\x1f\xfe\x3f\xfe\x7f\xfe\xff\xfe\xff\xff" \
               "\xff\xff\xff\xff\xff\xff"
""" AuiNotebook left button image. """

nb_right_bits = "\xff\xff\xff\xff\xff\xff\xdf\xff\x9f\xff\x1f\xff\x1f" \
                "\xfe\x1f\xfc\x1f\xfe\x1f\xff\x9f\xff\xdf\xff\xff\xff" \
                "\xff\xff\xff\xff\xff\xff"
""" AuiNotebook right button image. """

nb_list_bits = "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x0f" \
               "\xf8\xff\xff\x0f\xf8\x1f\xfc\x3f\xfe\x7f\xff\xff\xff" \
               "\xff\xff\xff\xff\xff\xff"
""" AuiNotebook windows list button image. """


#----------------------------------------------------------------------
tab_active_center = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAAEAAAAbCAYAAAC9WOV0AAAABHNCSVQICAgIfAhkiAAAADNJ"
    "REFUCJltzMEJwDAUw9DHX6OLdP/Bop4KDc3F2EIYrsFtrZow8GnH6OD1zvRTajvY2QMHIhNx"
    "jUhuAgAAAABJRU5ErkJggg==")
""" Center active tab image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_active_left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAA8AAAAbCAYAAACjkdXHAAAABHNCSVQICAgIfAhkiAAAAglJ"
    "REFUOI2Nkk9rE0EYh5/J7mpW06xE2iSmeFHxEoqIAc/FQ5CKgn4DP4KlIQG/QVsQbBEKgop+"
    "Anvy4rV4bLT2JCGJPVXqwaZJd+f1kN26WTfJDrzszDLPPL/5o0jeFGAC54A0YKmEYAo4DzjA"
    "LHAZmElqtIGrhmEsvtzcfPNtb6/V6524SWALKBiGsfhxe/uzFhGth5XEmgVubWxsvA1Az68k"
    "1nngYbPZ7ASg69c06wxwe3V9/b3reVqHwGmwCZRs2370fX//wIuA0+CLwEKj0XilZTSu602G"
    "FcP7vLe7+7XlRaCgPw62gGv5fP6p63raiwFdLWKOgdNArl6vV1UqpQgcYdcYbwooAPfb7c7h"
    "mTWmUjGwCWTL5fL1K6VSLiqQyMTYyLVa/UEwe9IC0chFYKnb/XnkeiIDV+Q0UsG/qNkCnEql"
    "crNQLDpaxpskJnYayD1bXl4S/xrDoPLHKjQOmsHwlCuHv44+ZJ2sLTrGGqzg7zEc+VK1Wl1w"
    "HMcG0DFxw6sFsRVwAZhdWak9FoRJ+w2HCKzzwN3jXv+daVmGDkdWoMKb9fumHz0DFFfX1p5Y"
    "lmXo6N0G48jzVEDOt97pdA9ezOXzGU+PzBmN6VuDqyoDN3Z2vjyfKxQynhYkJuJ/L02Ara3X"
    "n3602r8HrpaTUy3HAy1/+hNq8O+r+q4WETirmFMNBwm3v+gdmytKNIUpAAAAAElFTkSuQmCC")
""" Left active tab image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_active_right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAA8AAAAbCAYAAACjkdXHAAAABHNCSVQICAgIfAhkiAAAAkpJ"
    "REFUOI2NlM1rU0EUxX9zZ5KaWq3GKKnGutC0FEWCWAWLRUOxBetK/wdp6Re6F6TFXXGhuFdw"
    "b7dCQUUpiFt1XbB2q7Uf1iTvunjzkpe0afNgmLnDnHvOPe/OWCALtAFC+Cktfha4CRwBDnhg"
    "BQhaSrK19bf89dv35WfPX7y01haBbiAFmH3BlUA1Gm8WFt75BFkg0TK4VAl0Y3NL5+efvgIK"
    "wOH92EVjxRljGBi4VgTOeLDbk7kcqEZju1TWX7/Xgtm5J6+BS8ChvdilLhAhkUya4eFbxVQq"
    "1e3ZbUtgg8GKJd/Tk70/NjYCHCPsgX1kV8K5VA70z8amfvy0tAwMAcebSRfijikY8ez5/OlM"
    "JrOncbIjp4K1lmRb0sw8eDgCpAm7rwlz46YIzjpGb48WveyDNPhDfCOuHmNwzpHL5dK9fX3n"
    "mkmvaxJiayOCWMvM1PSdZtJrhiloLJMYIeESDFwf7Acyu0mXGLYmX0PpYi3ZbFdnoVDoBTpp"
    "uCxCjFob1tYKzlnGJyZHd5Mu6uVGkqvMCmCwzjE4eOMqcALoINauUic37hjhLXPWcTSdThWL"
    "QxcJX5yqdGk4H/cP9a4755iYnLpL+M/b8e0qjafrekb9TUskuNx/5TzQ5Y1zO9yOZEd1R7OI"
    "JdXebh/Pzt3zCToAMZv/AjU1orDWWKAGVJVSqcTqysp6X+/ZaeAL8KNac9wsVQ8yNeOsdZw8"
    "let4/2HpEdAPXDAb20HLj7xqeHT158ra4uLbz2bdg03krmetxrH9KDAmHP8Bn0j1t/01UV0A"
    "AAAASUVORK5CYII=")
""" Right active tab image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_close = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABHNCSVQICAgIfAhkiAAAAI9J"
    "REFUKJG90MEKAWEUxfEfM4rxAFIommzZzNb7v4BsLJTsiGQlYjHfME3flrO75/xvnXv5p/qY"
    "R/wcWTUktWCKFbrYB6/AAhecmwunAI/RwQAjbLGpoFakwjLATxzqMLQjC68A3/FohkljLkKN"
    "Ha4YKg8+VkBag3Pll9a1GikmuPk+4qMMs0jFMXoR/0d6A9JRFV/jxY+iAAAAAElFTkSuQmCC")
""" Normal close button image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_close_h = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABHNCSVQICAgIfAhkiAAAAOlJ"
    "REFUKJGVkiFuw0AQRd849hUS7iPUwGEllhyjYJ+gaK9Q4CsY9QTFIY4shQQucI8Q7l6h3Z0S"
    "r7UgjdrPZvVm52k0wpJLWe4y51qgVpECQFQnYPzabN4ra2cAAbgWxZMmyavAkTtROIn33fM0"
    "fcilLHep92+/wXHTd5K8JJlzbYD3w8C2aVZo2zTsh4FF5Zg516ZAHYBb35MbszbkxnDr+3hQ"
    "napIIUv1eT6vYPggvAGoSJE88r6XVFQnRA7BOdYIk8IUUZ1SYAQOsXOskRsT1+P/11pZO4v3"
    "ncLpESzed5W1c1jQn0/jBzPfck1qdmfjAAAAAElFTkSuQmCC")
""" Hover close button image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_close_p = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABHNCSVQICAgIfAhkiAAAASxJ"
    "REFUKJF9kbFLQlEYxX/nvbs55OAkiJAE7k7Nibo9xf+hrTlyr3Boipb+BCGq0bApJEQcG0Ms"
    "aQ0Lmq5+Dc+nDtbZ7uHce37fd8VSlWwh50PfRKqClWJXI8y6bu5uHj5e3wEEcJDP75txLBSx"
    "RYbdS7QfJ5PnsJIt5BbB4hQjkrQtjxlFILOXyvQDH/qmUCSJznDAYetkFTxsndAZDggkhCIf"
    "+qaLmWP1bu8oN+qrC+VGnd7t3bpKqrp4wBjl+ux8FUweSLwlXCnYCv2PHGgE1BLmTYykad2i"
    "kcOsi1TbZN7EKDfq67NZV5VsIeedvzQjCv5YK8R/4bw7Cl+/P7920+kJkBEq/hWWaPem45cQ"
    "YDybTfdSmf5CizckwHaAH9ATZldu7i560/ELwC+6RXdU6KzezAAAAABJRU5ErkJggg==")
""" Pressed close button image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_inactive_center = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAAEAAAAbCAYAAAC9WOV0AAAABHNCSVQICAgIfAhkiAAAAElJ"
    "REFUCJlVyiEOgDAUBNHp3qmX5iYkyMpqBAaFILRdDGn4qybZB98yy3ZZrRu1PpABAQiDSLN+"
    "h4NLEU8CBAfoPHZUywr3M/wCTz8c3/qQrUcAAAAASUVORK5CYII=")
""" Center inactive tab image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_inactive_left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAA8AAAAbCAYAAACjkdXHAAAABHNCSVQICAgIfAhkiAAAAf5J"
    "REFUOI2llE1rE1EUhp8bZwyhaZomk5DaD40hSWPQVkTd6KIIEUWlLqTEhTaLulBQ6sfKjeBC"
    "ECULXQku/Alx7d6/U1EQae45LjJpJ5NOnOKBgYG5z33Px3sG/iPMIc87QAmYBZKHgdOu69a2"
    "3/W2yrVGK5vPLTlxFV3Xrb3+8v1Ntd5oiSpWBmnEidKT972tar3R6ovSt4qoxoIdoFipNlpW"
    "B6AVRYFEHNWn3a8dz/PK1rIHEgN2UpnMseVTK7fUGBME48CFe88+3sh5+SXr1xmMSbABvJXz"
    "l9siYAVGWJ0Mu/OVZr5Q8CpWfFWzD2Imj2qu/fhtG4wRVUIZg0bDBsgtn15dt6qIKKBDQZ81"
    "kWmnzly6OZ+ZzhSt7jfK6CBjFMwEk5TWOy82AVQGhzVUb5RJEkC2fLK6JgIiPhioeZJJUhev"
    "3j2RTqdzooqge2ojCxwxqrnrG4/uq4Ida3HgAjMOJ4CZSq1+RVBUzCgQinDDstfa282jyeTU"
    "rhUGF4CJgMPKhbXbmw9VFfG7fBA4LCao7AAzi8cXz1kF0dENMqH38KgWnnd7nSMJxxE5wI4+"
    "MHyCaeeAYvPshQ0RJby3wVSDHxxgAVh99elb9/evndmfP3boW2FsqGNhMMCdBy8/fJ5KZ6at"
    "qL+3Q1dEzFkNGMX82ZWh18e0/vVT/wuFmdYVv/ruKgAAAABJRU5ErkJggg==")
""" Left inactive tab image for the Chrome tab art. """

#----------------------------------------------------------------------
tab_inactive_right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAA8AAAAbCAYAAACjkdXHAAAABHNCSVQICAgIfAhkiAAAAhBJ"
    "REFUOI2llM9rE1EQxz8zb1dSTKNuYtW01kQDRoKFWi9FEEq1IooUUWoPokWCtVqkR69KsSBU"
    "8OJRPOhBxZNe/At6FBER/HFUPEq1IGn3ecgm2ZjdJODCHPY9vvP9fufNDPzHZ4DDQBrYBKwB"
    "ftfoJys/Kw9ef/1y8/6rh67rHgKS3WLl6cqqtcCGD58+vn+zdPXorUql8g5Y7wTWdd+y4Vus"
    "teQK+yfKi8/KwM5umBXAAgioCIP54gTQBzgdwTbsQZR0JpOfXXw+0w27hn9EBGMcyRcPnulJ"
    "pbKd2JvACKgKnpcePH99+TSwvT3YEphusKsqB4ZHp4FMNWUn5loSEVSFbZ63b8eeUhpwu5Md"
    "JBFRjHHk7LXb08CuNuAaZTgEEaFQHJoEvDjpakOYmnURUFWSvam+0ujJfqAnmlnABhG2jlTZ"
    "j19YuEzMm7dUu34hihrDQG7vGLCViPq0VruuvdquyWSvN3xsKhclvbXaoUQiihFlfLJ8iYiq"
    "O/EtUC2xGGF3vjAObAnI6stCsZbYCLwnEonNY+dulALvHWSH2YN2PXLq4hz/9HpjnmOs18DZ"
    "bP9IIL0+afV5juqzRgLFcV1n9u6LGWAgWnaMBFHBOIbi0MgU1S3jAcjyyw9xqpvzWou1Pj++"
    "f/t8b/7EAvBW5u48agU37abWs99rv1YfL81fkT8V34YxbZ696d4CfwEszZSZx6Z26wAAAABJ"
    "RU5ErkJggg==")
""" Right inactive tab image for the Chrome tab art. """

# For auibook
# -----------

AuiBaseTabCtrlId = 5380
""" Base window identifier for AuiTabCtrl. """

AUI_NB_TOP                 = 1 << 0
""" With this style, tabs are drawn along the top of the notebook. """
AUI_NB_LEFT                = 1 << 1  # not implemented yet
""" With this style, tabs are drawn along the left of the notebook.
Not implemented yet. """
AUI_NB_RIGHT               = 1 << 2  # not implemented yet
""" With this style, tabs are drawn along the right of the notebook.
Not implemented yet. """
AUI_NB_BOTTOM              = 1 << 3
""" With this style, tabs are drawn along the bottom of the notebook. """
AUI_NB_TAB_SPLIT           = 1 << 4
""" Allows the tab control to be split by dragging a tab. """
AUI_NB_TAB_MOVE            = 1 << 5
""" Allows a tab to be moved horizontally by dragging. """
AUI_NB_TAB_EXTERNAL_MOVE   = 1 << 6
""" Allows a tab to be moved to another tab control. """
AUI_NB_TAB_FIXED_WIDTH     = 1 << 7
""" With this style, all tabs have the same width. """
AUI_NB_SCROLL_BUTTONS      = 1 << 8
""" With this style, left and right scroll buttons are displayed. """
AUI_NB_WINDOWLIST_BUTTON   = 1 << 9
""" With this style, a drop-down list of windows is available. """
AUI_NB_CLOSE_BUTTON        = 1 << 10
""" With this style, a close button is available on the tab bar. """
AUI_NB_CLOSE_ON_ACTIVE_TAB = 1 << 11
""" With this style, a close button is available on the active tab. """
AUI_NB_CLOSE_ON_ALL_TABS   = 1 << 12
""" With this style, a close button is available on all tabs. """
AUI_NB_MIDDLE_CLICK_CLOSE  = 1 << 13
""" Allows to close `AuiNotebook` tabs by mouse middle button click. """
AUI_NB_SUB_NOTEBOOK        = 1 << 14
""" This style is used by `AuiManager` to create automatic `AuiNotebooks`. """
AUI_NB_HIDE_ON_SINGLE_TAB  = 1 << 15
""" Hides the tab window if only one tab is present. """
AUI_NB_SMART_TABS          = 1 << 16
""" Use `Smart Tabbing`, like ``Alt`` + ``Tab`` on Windows. """
AUI_NB_USE_IMAGES_DROPDOWN = 1 << 17
""" Uses images on dropdown window list menu instead of check items. """
AUI_NB_CLOSE_ON_TAB_LEFT   = 1 << 18
""" Draws the tab close button on the left instead of on the right
(a la Camino browser). """
AUI_NB_TAB_FLOAT           = 1 << 19
""" Allows the floating of single tabs.
Known limitation: when the notebook is more or less full screen, tabs
cannot be dragged far enough outside of the notebook to become
floating pages. """
AUI_NB_DRAW_DND_TAB        = 1 << 20
""" Draws an image representation of a tab while dragging. """
AUI_NB_ORDER_BY_ACCESS     = 1 << 21
""" Tab navigation order by last access time. """
AUI_NB_NO_TAB_FOCUS        = 1 << 22
""" Don't draw tab focus rectangle. """

AUI_NB_DEFAULT_STYLE = AUI_NB_TOP | AUI_NB_TAB_SPLIT | AUI_NB_TAB_MOVE | \
                       AUI_NB_SCROLL_BUTTONS | AUI_NB_CLOSE_ON_ACTIVE_TAB | \
                       AUI_NB_MIDDLE_CLICK_CLOSE | AUI_NB_DRAW_DND_TAB
""" Default `AuiNotebook` style. """

#----------------------------------------------------------------------
Mondrian = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAHFJ"
    "REFUWIXt1jsKgDAQRdF7xY25cpcWC60kioI6Fm/ahHBCMh+BRmGMnAgEWnvPpzK8dvrFCCCA"
    "coD8og4c5Lr6WB3Q3l1TBwLYPuF3YS1gn1HphgEEEABcKERrGy0E3B0HFJg7C1N/f/kTBBBA"
    "+Vi+AMkgFEvBPD17AAAAAElFTkSuQmCC")
""" Default icon for the Smart Tabbing dialog. """

# -------------------------- #
# - FrameManager Constants - #
# -------------------------- #

# Docking Styles
AUI_DOCK_NONE = 0
""" No docking direction. """
AUI_DOCK_TOP = 1
""" Top docking direction. """
AUI_DOCK_RIGHT = 2
""" Right docking direction. """
AUI_DOCK_BOTTOM = 3
""" Bottom docking direction. """
AUI_DOCK_LEFT = 4
""" Left docking direction. """
AUI_DOCK_CENTER = 5
""" Center docking direction. """
AUI_DOCK_CENTRE = AUI_DOCK_CENTER
""" Centre docking direction. """
AUI_DOCK_NOTEBOOK_PAGE = 6
""" Automatic AuiNotebooks docking style. """

# Floating/Dragging Styles
AUI_MGR_ALLOW_FLOATING           = 1 << 0
""" Allow floating of panes. """
AUI_MGR_ALLOW_ACTIVE_PANE        = 1 << 1
""" If a pane becomes active, "highlight" it in the interface. """
AUI_MGR_TRANSPARENT_DRAG         = 1 << 2
""" If the platform supports it, set transparency on a floating pane
while it is dragged by the user. """
AUI_MGR_TRANSPARENT_HINT         = 1 << 3
""" If the platform supports it, show a transparent hint window when
the user is about to dock a floating pane. """
AUI_MGR_VENETIAN_BLINDS_HINT     = 1 << 4
""" Show a "venetian blind" effect when the user is about to dock a
floating pane. """
AUI_MGR_RECTANGLE_HINT           = 1 << 5
""" Show a rectangle hint effect when the user is about to dock a
floating pane. """
AUI_MGR_HINT_FADE                = 1 << 6
""" If the platform supports it, the hint window will fade in and out. """
AUI_MGR_NO_VENETIAN_BLINDS_FADE  = 1 << 7
""" Disables the "venetian blind" fade in and out. """
AUI_MGR_LIVE_RESIZE              = 1 << 8
""" Live resize when the user drag a sash. """
AUI_MGR_ANIMATE_FRAMES           = 1 << 9
""" Fade-out floating panes when they are closed (all platforms which support
frames transparency) and show a moving rectangle when they are docked
(Windows < Vista and GTK only). """
AUI_MGR_AERO_DOCKING_GUIDES      = 1 << 10
""" Use the new Aero-style bitmaps as docking guides. """
AUI_MGR_PREVIEW_MINIMIZED_PANES  = 1 << 11
""" Slide in and out minimized panes to preview them. """
AUI_MGR_WHIDBEY_DOCKING_GUIDES   = 1 << 12
""" Use the new Whidbey-style bitmaps as docking guides. """
AUI_MGR_SMOOTH_DOCKING           = 1 << 13
""" Performs a "smooth" docking of panes (a la PyQT). """
AUI_MGR_USE_NATIVE_MINIFRAMES    = 1 << 14
""" Use miniframes with native caption bar as floating panes instead or custom
drawn caption bars (forced on wxMac). """
AUI_MGR_AUTONB_NO_CAPTION        = 1 << 15
""" Panes that merge into an automatic notebook will not have the pane
caption visible. """


AUI_MGR_DEFAULT = AUI_MGR_ALLOW_FLOATING | AUI_MGR_TRANSPARENT_HINT | \
                  AUI_MGR_HINT_FADE | AUI_MGR_NO_VENETIAN_BLINDS_FADE
""" Default `AuiManager` style. """

# Panes Customization
AUI_DOCKART_SASH_SIZE = 0
""" Customizes the sash size. """
AUI_DOCKART_CAPTION_SIZE = 1
""" Customizes the caption size. """
AUI_DOCKART_GRIPPER_SIZE = 2
""" Customizes the gripper size. """
AUI_DOCKART_PANE_BORDER_SIZE = 3
""" Customizes the pane border size. """
AUI_DOCKART_PANE_BUTTON_SIZE = 4
""" Customizes the pane button size. """
AUI_DOCKART_BACKGROUND_COLOUR = 5
""" Customizes the background colour. """
AUI_DOCKART_BACKGROUND_GRADIENT_COLOUR = 6
""" Customizes the background gradient colour. """
AUI_DOCKART_SASH_COLOUR = 7
""" Customizes the sash colour. """
AUI_DOCKART_ACTIVE_CAPTION_COLOUR = 8
""" Customizes the active caption colour. """
AUI_DOCKART_ACTIVE_CAPTION_GRADIENT_COLOUR = 9
""" Customizes the active caption gradient colour. """
AUI_DOCKART_INACTIVE_CAPTION_COLOUR = 10
""" Customizes the inactive caption colour. """
AUI_DOCKART_INACTIVE_CAPTION_GRADIENT_COLOUR = 11
""" Customizes the inactive gradient caption colour. """
AUI_DOCKART_ACTIVE_CAPTION_TEXT_COLOUR = 12
""" Customizes the active caption text colour. """
AUI_DOCKART_INACTIVE_CAPTION_TEXT_COLOUR = 13
""" Customizes the inactive caption text colour. """
AUI_DOCKART_BORDER_COLOUR = 14
""" Customizes the border colour. """
AUI_DOCKART_GRIPPER_COLOUR = 15
""" Customizes the gripper colour. """
AUI_DOCKART_CAPTION_FONT = 16
""" Customizes the caption font. """
AUI_DOCKART_GRADIENT_TYPE = 17
""" Customizes the gradient type (no gradient, vertical or horizontal). """
AUI_DOCKART_DRAW_SASH_GRIP = 18
""" Draw a sash grip on the sash. """
AUI_DOCKART_HINT_WINDOW_COLOUR = 19
""" Customizes the hint window background colour (currently light blue). """

# Caption Gradient Type
AUI_GRADIENT_NONE = 0
""" No gradient on the captions. """
AUI_GRADIENT_VERTICAL = 1
""" Vertical gradient on the captions. """
AUI_GRADIENT_HORIZONTAL = 2
""" Horizontal gradient on the captions. """

# Pane Button State
AUI_BUTTON_STATE_NORMAL = 0
""" Normal button state. """
AUI_BUTTON_STATE_HOVER = 1 << 1
""" Hovered button state. """
AUI_BUTTON_STATE_PRESSED = 1 << 2
""" Pressed button state. """
AUI_BUTTON_STATE_DISABLED = 1 << 3
""" Disabled button state. """
AUI_BUTTON_STATE_HIDDEN   = 1 << 4
""" Hidden button state. """
AUI_BUTTON_STATE_CHECKED  = 1 << 5
""" Checked button state. """

# Pane minimize mode
AUI_MINIMIZE_POS_SMART    = 0x01
""" Minimizes the pane on the closest tool bar. """
AUI_MINIMIZE_POS_TOP      = 0x02
""" Minimizes the pane on the top tool bar. """
AUI_MINIMIZE_POS_LEFT     = 0x03
""" Minimizes the pane on its left tool bar. """
AUI_MINIMIZE_POS_RIGHT    = 0x04
""" Minimizes the pane on its right tool bar. """
AUI_MINIMIZE_POS_BOTTOM   = 0x05
""" Minimizes the pane on its bottom tool bar. """
AUI_MINIMIZE_POS_TOOLBAR  = 0x06
""" Minimizes the pane on its bottom tool bar. """
AUI_MINIMIZE_POS_MASK     = 0x17
""" Mask to filter the position flags. """
AUI_MINIMIZE_CAPT_HIDE    = 0
""" Hides the caption of the minimized pane. """
AUI_MINIMIZE_CAPT_SMART   = 0x08
""" Displays the caption in the best rotation (horz or clockwise). """
AUI_MINIMIZE_CAPT_HORZ    = 0x10
""" Displays the caption horizontally. """
AUI_MINIMIZE_CAPT_MASK    = 0x18
""" Mask to filter the caption flags. """

# Button kind
AUI_BUTTON_CLOSE = 101
""" Shows a close button on the pane. """
AUI_BUTTON_MAXIMIZE_RESTORE = 102
""" Shows a maximize/restore button on the pane. """
AUI_BUTTON_MINIMIZE = 103
""" Shows a minimize button on the pane. """
AUI_BUTTON_PIN = 104
""" Shows a pin button on the pane. """
AUI_BUTTON_OPTIONS = 105
""" Shows an option button on the pane (not implemented). """
AUI_BUTTON_WINDOWLIST = 106
""" Shows a window list button on the pane (for AuiNotebook). """
AUI_BUTTON_LEFT = 107
""" Shows a left button on the pane (for AuiNotebook). """
AUI_BUTTON_RIGHT = 108
""" Shows a right button on the pane (for AuiNotebook). """
AUI_BUTTON_UP = 109
""" Shows an up button on the pane (not implemented). """
AUI_BUTTON_DOWN = 110
""" Shows a down button on the pane (not implemented). """
AUI_BUTTON_CUSTOM1 = 201
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM2 = 202
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM3 = 203
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM4 = 204
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM5 = 205
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM6 = 206
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM7 = 207
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM8 = 208
""" Shows a custom button on the pane. """
AUI_BUTTON_CUSTOM9 = 209
""" Shows a custom button on the pane. """

# Pane Insert Level
AUI_INSERT_PANE = 0
""" Level for inserting a pane. """
AUI_INSERT_ROW = 1
""" Level for inserting a row. """
AUI_INSERT_DOCK = 2
""" Level for inserting a dock. """

# Action constants
actionNone = 0
""" No current action. """
actionResize = 1
""" Resize action. """
actionClickButton = 2
""" Click on a pane button action. """
actionClickCaption = 3
""" Click on a pane caption action. """
actionDragToolbarPane = 4
""" Drag a floating toolbar action. """
actionDragFloatingPane = 5
""" Drag a floating pane action. """
actionDragMovablePane = 6
""" Move a pane action. """

# Drop/Float constants
auiInsertRowPixels = 10
""" Number of pixels between rows. """
auiNewRowPixels = 40
""" Number of pixels for a new inserted row. """
auiLayerInsertPixels = 40
""" Number of pixels between layers. """
auiLayerInsertOffset = 5
""" Number of offset pixels between layers. """
auiToolBarLayer = 10
""" AUI layer for a toolbar. """

# some built in bitmaps

if wx.Platform == "__WXMAC__":

    close_bits = "\xFF\xFF\xFF\xFF\x0F\xFE\x03\xF8\x01\xF0\x19\xF3\xB8\xE3\xF0" \
                 "\xE1\xE0\xE0\xF0\xE1\xB8\xE3\x19\xF3\x01\xF0\x03\xF8\x0F\xFE\xFF\xFF"
    """ Close button bitmap for a pane on wxMAC. """

elif wx.Platform == "__WXGTK__":

    close_bits = "\xff\xff\xff\xff\x07\xf0\xfb\xef\xdb\xed\x8b\xe8\x1b\xec\x3b\xee" \
                 "\x1b\xec\x8b\xe8\xdb\xed\xfb\xef\x07\xf0\xff\xff\xff\xff\xff\xff"
    """ Close button bitmap for a pane on wxGTK. """

else:

    close_bits = "\xff\xff\xff\xff\xff\xff\xff\xff\xcf\xf3\x9f\xf9\x3f\xfc\x7f\xfe" \
                 "\x3f\xfc\x9f\xf9\xcf\xf3\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
    """ Close button bitmap for a pane on wxMSW. """

pin_bits     = '\xff\xff\xff\xff\xff\xff\x1f\xfc\xdf\xfc\xdf\xfc\xdf\xfc\xdf\xfc' \
               '\xdf\xfc\x0f\xf8\x7f\xff\x7f\xff\x7f\xff\xff\xff\xff\xff\xff\xff'
""" Pin button bitmap for a pane. """

max_bits     = '\xff\xff\xff\xff\xff\xff\x07\xf0\xf7\xf7\x07\xf0\xf7\xf7\xf7\xf7' \
               '\xf7\xf7\xf7\xf7\xf7\xf7\x07\xf0\xff\xff\xff\xff\xff\xff\xff\xff'
""" Maximize button bitmap for a pane. """

restore_bits = '\xff\xff\xff\xff\xff\xff\x1f\xf0\x1f\xf0\xdf\xf7\x07\xf4\x07\xf4' \
               '\xf7\xf5\xf7\xf1\xf7\xfd\xf7\xfd\x07\xfc\xff\xff\xff\xff\xff\xff'
""" Restore/maximize button bitmap for a pane. """

minimize_bits = '\xff\xff\xff\xff\xff\xff\x07\xf0\xf7\xf7\x07\xf0\xff\xff\xff\xff' \
                '\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff'
""" Minimize button bitmap for a pane. """

restore_xpm = ["16 15 3 1",
               "       c None",
               ".      c #000000",
               "+      c #FFFFFF",
               "                ",
               "     .......... ",
               "     .++++++++. ",
               "     .......... ",
               "     .++++++++. ",
               " ..........+++. ",
               " .++++++++.+++. ",
               " ..........+++. ",
               " .++++++++..... ",
               " .++++++++.     ",
               " .++++++++.     ",
               " .++++++++.     ",
               " .++++++++.     ",
               " ..........     ",
               "                "]
""" Restore/minimize button bitmap for a pane. """

#----------------------------------------------------------------------

down_focus_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACaUlE"
    "QVRIib2WvWsUQRjGn5mdnWxyTaqz9q+QlLnGToSgWAYDNjbpNCAGDGIvaRPbNJGQyiAEbK+w"
    "sAo2qexyEhbxsvt+jMXc3u3liPfhmWeXnWVm9vc+vO/M7prVzTb+gxyA7Ye/nXPWWmvtXKBb"
    "B9YBcM5lWZam6by4QNcBsNamaeq9d87NmWutdc59+NgGoKIizCwsxMTMFI8oZmZilzomZiFm"
    "FWERaXbv7eyueO+TJEHM79LSkvfeWnv2qftgex2ASGDmkrUkKUspiIuCy5IL4qKQgnghdQVx"
    "ScKsxCKiaH8lIu99NOwAEFGsG4Dv5xeiQYOKBBYVUWJlFhIVVmIlEZGQJKVIYBbWoKqqwQN5"
    "nqdpuri42OMys6rGOG/X78yW0bXWNyLqcyyAEEIIYcYK3aB5Lazb4o5fsPc3ToFaloxBwMle"
    "6+9Pjfd7stda6HR85+dCPC86Y6ETcQEcHz32eZ7meZrnx0ePJnlk0vwenm70r/PkTgWdjjuV"
    "rnPPfvxaa+3NcL3GMaub7XdPtNFoZFn24tmX1/trAOLuM6aaFQwQYExAMPWNaUw1FW+eHj5/"
    "dbfZbDYajY33F7e1L4gUA5uo3fd8AWbQH70bjGqEyxLq3LoMYhKCgakCIWZoLLdkMRE43Iy0"
    "tWi9QOP8xoIFAyBUjF7dgOizb9iMhLmByxIAHbAGKYigUPX3hqog47hSvfCHfYRaDcNg3IzO"
    "7GmydRaGi37zMujrut/9l58nijROQ9yd3ZXLy8urq6vZWFmW9f+Yhrje++XlZR2keDpZa4f+"
    "H/pKkiR+/f9dDsDWgQW6QHcuxKg/ZbVtCjjzINkAAAAASUVORK5CYII=")
""" VS2005 focused docking guide window down bitmap. """

#----------------------------------------------------------------------
down_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACY0lE"
    "QVRIib2WwWrUUBSG/3tzc5s2m0JhXPsU0u1s3Lkpui4W3PgAuhAFi2/QbesTVEphwCIU3Hbh"
    "wk2LG1fujJQgtMk55x4Xd2aS6VAzM479JyQhufnOz3/uzcQMBgP8BzkAeZ4756y11tqlQIui"
    "cACcc1mWpWm6ZK61Nk1T771zbilcxBxiAs659x/OAAQJIswsLMTEzBR/UczMxC51TMxCzEGE"
    "RaR39WB3b9N7nyTJkLu2tua9t9ZefLx69GYbgIgyc82hJqlrqYiriuuaK+Kqkop4JXUVcU3C"
    "HIhFJODsCxF57xu/RBT7BuDb958SNGgQUZYgEogDs5AE4UAcSEREk6QWUWbhoCGEENQDZVmm"
    "abq6ujrkMnMIIdZ5t31vsUC3+l+JaMyxAFRVVRds0C1azsS6O273hH24cwq0UjIGipP9/t+f"
    "6vZ7st9fKQpf/FqJ28+iEzoTF8Dx0RNflmlZpmV5fPR4lkdmzffwdGe8XyZ3Luh83Ll0k3vx"
    "4/dWf3+B/Q2OGQwGGxsbeZ5nWfbi2efXB1sA4uozZjRKDaAwRqGmvTCNGQ3F26eHz1/d7/V6"
    "eZ6fn5/f1bogCmhsonU+9AWY5nr0bjCtKS6LtrltGcQQ1MCMCiEm1MmtWUwETh6mjq1qw0Jd"
    "fmPD1ADQEWPYNyD6HBs2U2Vu4bIoEBpWE0EE6ej68NaoSBdXRi/8SR/a6qE29830yKFmm2c6"
    "2fTbp8FYN/0evPw0U6UuTXB39zYvLy+vr68XY2VZNv5imuB679fX10MT8Xyy1k58P4yVJEn8"
    "9/93OQBFURRFsRTcWH8An5lwqISXsWUAAAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window down bitmap. """

#----------------------------------------------------------------------
left_focus_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACVElE"
    "QVRIibWWvW8TQRDF3+7Ors8ShSsaSpo0dEgoFcINVChSBFRUkajpIKKgiPgP0pqGJiAhITqE"
    "FIk2BQUVHT2VK+y7ndmhWN/5Ixcbh8tYWvtO8vvdm5mdPXPv+RmuMgjA670/RGSttdZ2q354"
    "YgkAERVF4b3vHABMCIC11nsfQiCiqwJYa4noxbNvOw/6AJIk62ySJMLMwhI5MnPMnxzMzJHJ"
    "E0dmicxJhEXk+uTO0fFuCME5h1yDxbh5+zEz93q+LGOv50WUmStOVZSqkjJyWXJVcRm5LKWM"
    "3PNURq6iMKfIIpJw9n08Hg8Gg36/3wL4+eu3iHpykcWTS5pElCWJpMiJWaIk4RQ5RRERda4S"
    "UWbhpCmllDQA0+k0pZQFVwF3bzEAZ5N3jgje+0COnPVknbUAdm5cW5/1/eGPxcuL2saoAczC"
    "DQWAV0/fr1c/HxcBFNC8QGEMMu3NuyddAfIjG9QLjKJTB3NIHV050EZuoQI6+93q4P7B6TYA"
    "A2gW1xlC61K0OXi492HZ6EbAnGFqEmBmhlYc7A9HutRq/wgA5plSwDT9tORgfzgCNsmv2QfQ"
    "OvEwps7BooOPpwebxFsB83wazdWdl321BjOGWWejrciZ0+wBMwef76LPnx6trXFrivIfVOsl"
    "P2V7FwH4MhpuCTBLX7mjckU628naTImlrdDdLDJ59OT+XDDU8SwyTX+Y2bC7hIPVA+fty6/b"
    "SmwBODreHY/H0+n0P0WLomjegJYAIYTBYNAcp5cOa20IoQXgnMuvAh0GATg8scAEmHQrneMv"
    "3LAo6X/e0vAAAAAASUVORK5CYII=")
""" VS2005 focused docking guide window left bitmap. """

#----------------------------------------------------------------------
left_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACTklE"
    "QVRIibWWPWsUURSG3/u5u8RiKxtLmzR2gqQSttFKhKBWqQL+BQXL4D9IGxsrBUGEFCIEbC0s"
    "rOzshYHt3Jl7PizuzsduJhs3Ts7C3Z2BfZ95zzn33DGnp6e4zvAAdnZ2vPfWWmvtsOpFUXgA"
    "3vvxeBxCuC6AtTaEEGP03g8LQE5RTo73/sXzr7sPJwCExTorLMxExMSJEhGl/MlBRJTIB0+J"
    "iBORMBMz3/xz7+h4L8bonFsCunH77lMiGo1CWabRKDArEVUkVeKq4jJRWVJVUZmoLLlMNAq+"
    "TFQlJpJEzCz49n0+n0+n08lk0gP4+es3swbvEnHwTlSYlViYJZEQcWJhkkSSmJnVuYpZiZhE"
    "RUREI7BYLESkTVE37t8hAM5KcM57hBCid97Z4K2zFsDurRubk74/+9G9vKhtjBrAdG4oALw6"
    "eLdZ/XxcBFBA8wKFMci012+fDQXIj2xQLzCKQR20kDqGcqCNXKcCuvzd6+DB4dk2AANoFtcl"
    "QutS9Dl49Pj9qtFLAS3D1CTALA2tOdifnehKq/0jAGgzpYBp+mnFwf7sBLhMfsM+gNaJhzF1"
    "DroOPpwdXibeC2jzaTRXty37eg2WDLPJRl+RM6fZA6YFn++iTx+fbKxxb4ryH1TrJT9lfxcB"
    "+Hwy2xJgVr5yR+WKDLaTtZkSK1thuFlk8ujJ/dkxNPAsMk1/mOWwu4KD9QPnzcsv20psATg6"
    "3pvP54vF4j9Fx+Nx8wa0AogxTqfT5ji9clhrY4w9AOdcfhUYMDyAoiiKohhWt4m/9Qss43IB"
    "CBMAAAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window left bitmap. """

#----------------------------------------------------------------------
right_focus_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACWElE"
    "QVRIibWWv2/TQBTHv3e+uyRbJwZWFv4AJNSRLjChSkhlYqrEzFZVDAwVC3PXsrAUISTExlKJ"
    "tQMSWzcmFqaqQqT2+8VwtuMkbiBp+mzF0pPz/dzX7z373IMXp7jJCABebf8JIXjvvffrVd8/"
    "9gFACGE4HMYY1w4AxgGA9z7GmFIKIdwUwHsfQth7/vXuoxEAFfWFV1ERZhYWYmJmykcOZmbi"
    "EAMTsxCzirCI3BrfPzjcTCkVRYFcg27cubfDzINBLEsaDKKIMXPFWpFUlZTEZclVxSVxWUpJ"
    "PIihJK5ImJVYRBSn387Pzzc2NkajUQ/g7McvEYuhIJYYCjUVMRYVUWJlFhIVVmIlERErikrE"
    "mIXVVFXVEnB5eamqWXAW8Gb39uKHevbzNwARZVFirUSIlFkqEVUD8Pb71P1Lt83LZ+8BAA7O"
    "AYABMAPcFfcvDXj97ikA5wxmHVVrf64LyA7Mau1so770uVjRQa1lzaKtSc2ZWAR4uHsyn2xq"
    "YBnjbFp4zsRCBw6Ptz/M5GoHgLla15AfUV8F/gEwA/Bk66jPgXNwMNhkyf199F816DIaB5bx"
    "yB2aO2qFLsp/+Xiy22YmczA1Cq4hLQlwsK56xwHgumLWln0pgPv8aWcmNdVF7TKujkWAL0db"
    "88nagXWb0xYgVn4XWf0CymdzWQNgapJzWC7HCnPQF5M5aBhXzthqgMkcoF57Zxx6YvaDMzO3"
    "148pwMHhJhFdXFwQ0XVEh8NhuwOaAqSUUkoxxvaLulp471NKPYC80ci7gXVFALB/7IExMF6j"
    "bht/AXIQRaTUgkiHAAAAAElFTkSuQmCC")
""" VS2005 focused docking guide window right bitmap. """

#----------------------------------------------------------------------
right_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACVElE"
    "QVRIibWWv2sUQRTHvzM7M3dHmlQWtjb+AYKkTaOVCEKsrAL+CxaWwcY6bWysRAQRUtgEbC0E"
    "u3RWNsJCCILZfb8sZvdu925zej/yveMWHnvvM9837+2OOz09xU0qANjZ2QkheO+999vNXpZl"
    "ABBCGI/HMcabAnjvY4wppRDCdgHIJcrFCSG8eP7l7sMJABX1hVdREWYWFmJiZsqfLGZm4hAD"
    "E7MQs4qwiNz6c//oeC+lVBRFA+jqzr0DZh6NYlXRaBRFjJlr1pqkrqUiriqua66Iq0oq4lEM"
    "FXFNwqzEIqL4+u3i4mJ3d3cymQwAzn/8ErEYCmKJoVBTEWNRESVWZiFRYSVWEhGxoqhFjFlY"
    "TVVVLQFXV1eqOitRV68Pby+v6fnP3wBElEWJtRYhUmapRVQNwJvvvftXbpuXz94BABycAwAD"
    "YAa4a+5fGfDq7VMAzhnMOllt+rMpIDswa3JnG81lyMWaDppc1i7a2tCCiWWAB4dni8F2Dyxj"
    "nPUTL5hY6sDh0eP3c7HGAWCuyWvIJRragX8AzAA82T8ZcuAcHAw2W/JwH/3XHnQZrQPLeOQO"
    "zR21Rhflv3w4O5xGZnPQGwXXklYEOFg3e8cB4LrJbLrtKwHcp48Hc6FeF02Xcb2WAT6f7C8G"
    "GwfWbU5bglj7WWTNAyh/28sWAL1JzrK8HWvMwZBmc9Ayrp2x9QCzOUCz9s44DGj+hTM3t5ur"
    "Bzg63iOiy8tLItok6Xg8np6AeoCUUkopxjh9o64n731KaQCQDxr5NLAtBQBlWZZlucWkXf0F"
    "imtJnvbT2psAAAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window right bitmap. """

#----------------------------------------------------------------------
tab_focus_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAdCAIAAADZ8fBYAAAAA3NCSVQICAjb4U/gAAAC10lE"
    "QVRIidWWT0gUcRTH387+ZveXZgzsbmvSsmqEfzBJSYz+gUsHCYJgISPytCQKFhJdpIN0qIUO"
    "ezIUaU/roQ5eEzp46ZT/DhG4haCXdSUPK+Wuzvze+02HgdFmFqMtD76Bx8yb3/v8vr/3Zn4z"
    "np6ReTgCYwAwdqfEGFMURVGU/wIdfaswAGCMcc5VVf1fXIBdBgCKoqiq+nxkobn3BABIkgBA"
    "hIiEJFAgorAOyxARBTKVoUAkgSiJkIhO73a/nLjGOd/nWkrPXbqLiH6/CgBEJiIaKA1BhkG6"
    "QF1Hw0BdoK6TLtCvMl2gIQhRCiQiCfPLm5ubtbW1YNXXtuzadyJTZV4AkKYkMpEkkRQoEUmQ"
    "JJQCpSAiMr1eg8hEJJSmlFJK0wdQLBYR0cl9laj7l6LGY5/tc2ejsrmdgeGJbG5nYHgym9uJ"
    "x9KHeGuMNd7B8fSMzCfvyerq6rHHn2bmEgPDE09G+/9WaSqZmRofisfSiadnotHoozclp94K"
    "oGWznNxn/e8q4LqznNwXmb4KuO6s4643lZyugOvOcj8PDyrgurOOe30r05tKZv7ALavXmszt"
    "rXZZL7EjhTmuU8lpRxNSyemZuUEAmJlLOPzU+CAAuKFluO7OWpF4LO1OPsTcejOOTcRepqXR"
    "tngs7Y6U4bbcqNrIF6bGh6yt0prAgm7kC6E2fSNfWF9b2d7e1jStvqGlbMSmeRsuP7zZZvp8"
    "PvCoW1s/a2qq7vddD57y3b7VZfmNfGFxadUQBgqztbWps7Pdy04uLq0WSyVJnoMRgUY45NM0"
    "bXZZ7OvtaA8vLOdeT85mP+4eXN35K/6W5nBjxFz5tv7+w8LWF3+oTW+IBpsavStf1+xIfTTY"
    "cNbknDPGfqsD5/xCa6AuDFe791xtEJyHIhHedTGw17tnj49EeFdH8GAkEAhwzgF+7HMZY5qm"
    "cc6tD6rDGGOMMUS075aN2Ho9R/R/9gsXZ7dKHM+ODQAAAABJRU5ErkJggg==")
""" VS2005 focused docking guide window center bitmap. """

#----------------------------------------------------------------------
tab_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAdCAIAAADZ8fBYAAAAA3NCSVQICAjb4U/gAAAC1klE"
    "QVRIidWVTWgTQRTHJ5vZZEyMLKSx1RbSImJbioeiCKIechLBU8CCtadAaaGIFC/iQTxowENO"
    "hUohp/Tiocdce/Gk/TiIpTm0JCnmA+OaFJs2u/PerIcp27IbKsZ66Ft47P5n3m/evLc768lm"
    "s+Q/GCWEBINBSqmiKIqinApU13VKCKGUMsZUVT1lrqIoqqq+frYyeP8cIUSgIIQgAgACcuAA"
    "wOUlDQCAA1UpcADkAAIREPHiwa2383cYY0TWwa7AlRuPAMDvVwkhiBYAmCBMjqaJBgfDANME"
    "g4NhoMHBr1KDg8kRQHBAREE+r1er1Z6enkOubbn8d0RLpV5CiLAEogUoEAUHAYAcBYLgIDgi"
    "ouX1mogWAIKwhBBCWD5Cms0mADi57xKX/6Ws8dgX+97ZqFxpb3JmPlfam5x5nyvtxWPpE7yc"
    "I+c7OJ5sNhsOh4PB4Kunn5aWE5Mz87MvJv4201QyszA3HY+lE88vRaPRYrHozLcDaNsoJ/fl"
    "xIcOuO4oJ/dNZqwDrjvqrOebSi52wHVHud+HJx1w3VFnvb6d5ZtKZv7AbZuvXMztZbvkR+wI"
    "oY7nVHLR0YRUcnFpeYoQsrSccPiFuSlCiBvahuvurFTisbQ7+ARz55txHCL2NmWOtsVjabfS"
    "hjt0L1Cu1BfmpuVRKReQ0HKlHhkxypV6Ib/ZaDQ0TesfGGqr2DTv+Ph4IBDw+XzEo9Zqv0Kh"
    "wOOxu10XfA8f3JS+XKmvrm2Z3ARuDQ9fGx297qXnV9e2mvv7Aj3HFQ5md8Snadru7u7Rua6q"
    "6sp6aTNXzX08OL67q7f9Q4PdTP1ZKCn5Qq321R8ZMQaiXf19VuGbJ1/8IZX+aNdAnxWJRHp7"
    "e7e3t4+4oVCo0Wjout5qtdx9YIwxxlqtlj3aVgmHw5qmbWxsHNWXUqppGmNM/lCd/aWUUgoA"
    "9mhbhTFGKT3sm67ruq7v7Oy4cR3bb5uW079be13FAAAAAElFTkSuQmCC")
""" VS2005 unfocused docking guide window center bitmap. """

#----------------------------------------------------------------------
up_focus_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACTUlE"
    "QVRIic2WP28TMRjGH/85c1miqEF8CnbUgSFdukVRmZGQ+gW6Vgwd+hW60Yq1gMQMQzpHGZAg"
    "C6JS+QIMmUju/L5+Ge6ulzoRTcMh5TmdZfv8/vT4Pcu26h2N8R9kAZwMfltrtdZa60agx5fa"
    "ArDWpmmaJElTXGBmAWitkyRxzllrG+Zqra21bz+OAQQOzETExJ48EfniKURE5MkmljwRe6LA"
    "TMz8ZPbs9GzXOWeMQZHfW33/NOufvALALESUU8g95zlnnrKM8pwyT1nGmadHic085Z6Jgidm"
    "Dhh/mU6nnU6n1WrFXAA/fv7iIEECsxAH5uApELHnwBQ8Bc/MLMbkzELEFCSEEII4YD6fhxAK"
    "Tsx9/tQDEIgqOzRggAQQQEEBguIFgKoNqDdfvy1yYq41emG4QKkSpDQAiNQfFQClpBoZcaK2"
    "s0awEHzXVVyri1gxN7FaFuILu6qwtAyokqWWwEvcxNTTKsIK95Cqs4JJzV02vMJvHS/1cFFQ"
    "UGV+K3tSzWlZq/5bOWGllIio0mzpX+pZSJXdVRmOuabcItRC+ZfKcn+pFRvN65fvNihj9Y7G"
    "o9FoMplcX18f9M5lUx30zofD4WQyubm56R2Nm9oYY20B98XeRfPcAro+ei1uf/DBt9u+3c7b"
    "7f7gfTPc/cOr7HE36+5k3Z28u5N1u/uHV/dG3X+gfb7YW8dgpC1YD1vBjfP7oEW6Lvf0bHc6"
    "nc7n881YaZre3pjucJ1znU7n9qx+qLTWzrkVXGNMcav4d1kAx5camAGzRoiF/gCKPmudbgYP"
    "HQAAAABJRU5ErkJggg==")
""" VS2005 focused docking guide window up bitmap. """

#----------------------------------------------------------------------
up_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACTklE"
    "QVRIic2WP4vUQBjGn/mTMUtgWS6yvb29XGGzzXXHwdWCcGBzH8BCweK+wnWyWKtot6DNge0V"
    "gjYnNn4BA9vdJvO+81ok2ewmi7d3RtgnZEgm8/545skwiZrNZvgPsgCSJLHWaq211r1Asyyz"
    "AKy1cRxHUdQzV2sdRZFzzlrbCxdlDmUC1to3Hy8BBA7MRMTEnjwR+fIoRUTkyUaWPBF7osBM"
    "zDy+fnR2vu+cM8ZU3KV+fLo+fPUUALMQUUGh8FwUnHvKcyoKyj3lOeee7kU291R4JgqemDng"
    "8ut8Ph+NRoPBoM0F8PPXbw4SJDALcWAOngIRew5MwVPwzMxiTMEsRExBQgghiAMWi0UIoclh"
    "VY8fegACUVWHBgwQAQIoKEBQngBQ3wPq9bfv7XzX7o1eGS5QqgIpDQAizUMFQCmpR3bf26qc"
    "NYKV4nVX7aumaavNjayWlfrSriotdQF1WKoD7nAj00yrLCvdQ+rOGiYNt2t4g9+mXprhoqCg"
    "qnxre1LPqatN762asFJKRFRltvIvzSykTndTwm2uqbYItdL+5aLbX2nDRvPiyds7tC2p2WyW"
    "pmmSJHEcP3/25cPFSXfQNjqeTE9fPhiPx0mSXF1d9bMxdrUD3OPJtH9uCd0evRX38Oi9Hw79"
    "cFgMh4dH7/rhHpxc5PfTPN3L070i3cvT9ODk4saqmz9on6eTbQy2tAPrYSe47XxvtUi35Z6d"
    "78/n88VicTdWHMfLP6Y1rnNuNBotv9W3ldbaObeBa4wp/yr+XRZAlmVZlvWCW+oP2FUt8NYb"
    "g5wAAAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window up bitmap. """

#----------------------------------------------------------------------
down = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACFUlE"
    "QVRIidWVPWvbUBSG3+tv8KKpnYtH/4DuJtCti2nntBm7depQWih0zT9w/AtSQsDQ0JIfkKFD"
    "wRC61Iu3uBgRiKXz1eFalizb8QfxkFdCurofz3l1zhVyg8EAe1BhH9BHyC3NWkTU/XYFQEVF"
    "mFlYiImZyR9ezMzEpXKJiVmIWUVYRJ7cPT/uHizhFgqF6+93Lz8fAhAxZo5ZY5I4log4ijiO"
    "OSKOIomIq+VSRByTMCuxiCiufo3H4yAI8txisQjgz98bUVNTEWNRESVWZiFRYSVWEhGxYjEW"
    "MWZhNVVVtQoQhuESrtfXw6e7JbTd+k1E6dv3+/3dQPeo3+8/3n22Si+OLgFLn52D4aLTun/V"
    "er8XnVZ1NKqM/lX9eTNaC92IC+D87HUlDMthWA7D87NXmyzZNL+nl0ez60Nyt4Jux91Kee71"
    "8Lbd6uxwzXFcr9drNpv+4f2bn59O2gDMAMC5ZJY5wOCcwZxlV7tkKr68PX338Vmj0cBev7f8"
    "d0GkSG0i0576Alza7707LGqBy2JZblYOPgnm4JJA8Blay41ZnAfO3xbumWjTQOv8+oKZA2AJ"
    "Y1o3wPucGXYLYVZwWQzQlJWmwIMs6Z8OJUHWcUU1aWZ9WKaGlo67xZlTbbbPbL7oq7fBTHm/"
    "Jx9+bBRpnea4x92D4XA4mUx2Y9VqteVcAEEQ1Ov13bhZ5fP7IFB4v/v41f8HFQ1ap0nfm7YA"
    "AAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window down bitmap. """

#----------------------------------------------------------------------
down_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACaUlE"
    "QVRIib2WvWsUQRjGn5mdnWxyTaqz9q+QlLnGToSgWAYDNjbpNCAGDGIvaRPbNJGQyiAEbK+w"
    "sAo2qexyEhbxsvt+jMXc3u3liPfhmWeXnWVm9vc+vO/M7prVzTb+gxyA7Ye/nXPWWmvtXKBb"
    "B9YBcM5lWZam6by4QNcBsNamaeq9d87NmWutdc59+NgGoKIizCwsxMTMFI8oZmZilzomZiFm"
    "FWERaXbv7eyueO+TJEHM79LSkvfeWnv2qftgex2ASGDmkrUkKUspiIuCy5IL4qKQgnghdQVx"
    "ScKsxCKiaH8lIu99NOwAEFGsG4Dv5xeiQYOKBBYVUWJlFhIVVmIlEZGQJKVIYBbWoKqqwQN5"
    "nqdpuri42OMys6rGOG/X78yW0bXWNyLqcyyAEEIIYcYK3aB5Lazb4o5fsPc3ToFaloxBwMle"
    "6+9Pjfd7stda6HR85+dCPC86Y6ETcQEcHz32eZ7meZrnx0ePJnlk0vwenm70r/PkTgWdjjuV"
    "rnPPfvxaa+3NcL3GMaub7XdPtNFoZFn24tmX1/trAOLuM6aaFQwQYExAMPWNaUw1FW+eHj5/"
    "dbfZbDYajY33F7e1L4gUA5uo3fd8AWbQH70bjGqEyxLq3LoMYhKCgakCIWZoLLdkMRE43Iy0"
    "tWi9QOP8xoIFAyBUjF7dgOizb9iMhLmByxIAHbAGKYigUPX3hqog47hSvfCHfYRaDcNg3IzO"
    "7GmydRaGi37zMujrut/9l58nijROQ9yd3ZXLy8urq6vZWFmW9f+Yhrje++XlZR2keDpZa4f+"
    "H/pKkiR+/f9dDsDWgQW6QHcuxKg/ZbVtCjjzINkAAAAASUVORK5CYII=")
""" VS2005 focused docking guide window down bitmap. """

#----------------------------------------------------------------------
left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACMElE"
    "QVRIib2WPYsTURSG3zv3ThKJRSqblDYLwU6wFMKCViIEtbKQ/QdWgrXt/oO4hZWCIEIKUfYH"
    "WFgIATuraewHM3PPh8XNZCaTSWI2oydwMx/kfeY959wzMbPZDC3FaDTavOi23Wgron8n/Z8A"
    "rnry/NmXk/vXAAhLZCNhYSYiJvbkiciHTwgiIk8uduSJ2BMJMzHzjd93zi9OmwEAbt5+TETd"
    "bpxlvtuNmZWIcpLcc55z5inLKM8p85RlnHnqxi7zlHsmEk/MLPj6LUmS4XDYDPjx8xezxs56"
    "4thZUWFWYmEWT0LEnoVJPIlnZlZrc2YlYhIVERHtAIvFYquDu7cIgI0kttY5xHHccdbZKHaR"
    "jSIAJ8Pru5M+GX+vnm4rslEDmMoFBYCXT9/uVt+MbQAFNCxQGINAe/XmSVuA8MgGxQKjaNVB"
    "CSmiLQe6kqtUQJfHjQ7unV0eAjCABnFdIrQoRZODBw/frRvdCygZpiABZmmo5mAynupaq/0l"
    "ACgzpYBZ9dOag8l4CuyT37EPoEXiYUyRg6qD95dn+8QbAWU+jYbqlmWv12DJMLtsNBU5cFZ7"
    "wJTgzS76+OHRzho3pij8QLVYwlM2dxGAT9PxgQCz9hU6KlSktZ2sqymxthXam0UmjJ7QnxVD"
    "Lc8is+oPsxx2V3BQf+G8fvH5UIkDAOcXp0mSVF94V4ter5emab/frwMADAaDcOOYSNO00+mE"
    "4zrgePWaiAMwn8+PF932//MPv0Uk8OspzrYAAAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window left bitmap. """

#----------------------------------------------------------------------
left_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACVElE"
    "QVRIibWWvW8TQRDF3+7Ors8ShSsaSpo0dEgoFcINVChSBFRUkajpIKKgiPgP0pqGJiAhITqE"
    "FIk2BQUVHT2VK+y7ndmhWN/5Ixcbh8tYWvtO8vvdm5mdPXPv+RmuMgjA670/RGSttdZ2q354"
    "YgkAERVF4b3vHABMCIC11nsfQiCiqwJYa4noxbNvOw/6AJIk62ySJMLMwhI5MnPMnxzMzJHJ"
    "E0dmicxJhEXk+uTO0fFuCME5h1yDxbh5+zEz93q+LGOv50WUmStOVZSqkjJyWXJVcRm5LKWM"
    "3PNURq6iMKfIIpJw9n08Hg8Gg36/3wL4+eu3iHpykcWTS5pElCWJpMiJWaIk4RQ5RRERda4S"
    "UWbhpCmllDQA0+k0pZQFVwF3bzEAZ5N3jgje+0COnPVknbUAdm5cW5/1/eGPxcuL2saoAczC"
    "DQWAV0/fr1c/HxcBFNC8QGEMMu3NuyddAfIjG9QLjKJTB3NIHV050EZuoQI6+93q4P7B6TYA"
    "A2gW1xlC61K0OXi492HZ6EbAnGFqEmBmhlYc7A9HutRq/wgA5plSwDT9tORgfzgCNsmv2QfQ"
    "OvEwps7BooOPpwebxFsB83wazdWdl321BjOGWWejrciZ0+wBMwef76LPnx6trXFrivIfVOsl"
    "P2V7FwH4MhpuCTBLX7mjckU628naTImlrdDdLDJ59OT+XDDU8SwyTX+Y2bC7hIPVA+fty6/b"
    "SmwBODreHY/H0+n0P0WLomjegJYAIYTBYNAcp5cOa20IoQXgnMuvAh0GATg8scAEmHQrneMv"
    "3LAo6X/e0vAAAAAASUVORK5CYII=")
""" VS2005 focused docking guide window left bitmap. """

#----------------------------------------------------------------------
right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACMklE"
    "QVRIibWWvY7TUBCFz83vojSuKNiShgdAol8hQYWQkJaKAuUNtqWmoeANFgoqhJAQHRLaB6BA"
    "orC0HWnSUEURK2LPmRmKayeO4wTysydWbI+c+e7xzDgOo9EIK0rTdDW4m0Ij4FBK07R1fdmj"
    "rh3QqZ6cPf965+ENAKbWardMTZWkUoVCUuIniiSFnW6HQqqQpkpVvfnn3uu395sBAG7fPSXZ"
    "73ezTPr9rqqTzGm5aJ5rJswy5jkzYZZpJux3O5kwFyVNqKqGb9/H4/Hx8XEz4PLnL1XvdtpC"
    "7Xba5qbqVFM1oZEqakoTmqiqerudqzqpNDczM+8Bs9lsrYNXw1ub7+nl+DcAVaOa0HJVESM1"
    "VzVzAG9+LF2/dZFfPHsPAAgIAQAcgDsQ1ly/NeDlu6cAQnC4V7L6/GtfQHTgXuSONopdk4sd"
    "HRS5vFy0l6EVE5sAD4YXq8GyBh4xwZcTr5jY6CDg0eMPtVjhAPBQ5HXEW9RUgX8A3AE8OTlv"
    "chACAhy+WHJzH/1XDaqM0oFHPGKHxo7aoYviTz5eDOeRxRwsjUIoSVsCAryaveIACNVkPi/7"
    "VoDw+dNpLbTURfNlrNcmwJfzk9Vg4cCrzekbEDs/i7x4AMWt3B0AsDTJUR7LscMcNGkxByVj"
    "7YztBljMAYq1V8ahQfU/nNrc7q/6e9FkMplOpyKyT9Kjo6MkSQaDQZqmdQdJkiRJsk92AFdX"
    "V71eLx7XAQfRYDCYH68FHOr19C8Ad0k9S0aHzwAAAABJRU5ErkJggg==")
""" VS2005 unfocused docking guide window right bitmap. """

#----------------------------------------------------------------------
right_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAIAAABE/PnQAAAAA3NCSVQICAjb4U/gAAACWElE"
    "QVRIibWWv2/TQBTHv3e+uyRbJwZWFv4AJNSRLjChSkhlYqrEzFZVDAwVC3PXsrAUISTExlKJ"
    "tQMSWzcmFqaqQqT2+8VwtuMkbiBp+mzF0pPz/dzX7z373IMXp7jJCABebf8JIXjvvffrVd8/"
    "9gFACGE4HMYY1w4AxgGA9z7GmFIKIdwUwHsfQth7/vXuoxEAFfWFV1ERZhYWYmJmykcOZmbi"
    "EAMTsxCzirCI3BrfPzjcTCkVRYFcg27cubfDzINBLEsaDKKIMXPFWpFUlZTEZclVxSVxWUpJ"
    "PIihJK5ImJVYRBSn387Pzzc2NkajUQ/g7McvEYuhIJYYCjUVMRYVUWJlFhIVVmIlERErikrE"
    "mIXVVFXVEnB5eamqWXAW8Gb39uKHevbzNwARZVFirUSIlFkqEVUD8Pb71P1Lt83LZ+8BAA7O"
    "AYABMAPcFfcvDXj97ikA5wxmHVVrf64LyA7Mau1so770uVjRQa1lzaKtSc2ZWAR4uHsyn2xq"
    "YBnjbFp4zsRCBw6Ptz/M5GoHgLla15AfUV8F/gEwA/Bk66jPgXNwMNhkyf199F816DIaB5bx"
    "yB2aO2qFLsp/+Xiy22YmczA1Cq4hLQlwsK56xwHgumLWln0pgPv8aWcmNdVF7TKujkWAL0db"
    "88nagXWb0xYgVn4XWf0CymdzWQNgapJzWC7HCnPQF5M5aBhXzthqgMkcoF57Zxx6YvaDMzO3"
    "148pwMHhJhFdXFwQ0XVEh8NhuwOaAqSUUkoxxvaLulp471NKPYC80ci7gXVFALB/7IExMF6j"
    "bht/AXIQRaTUgkiHAAAAAElFTkSuQmCC")
""" VS2005 focused docking guide window right bitmap. """

#----------------------------------------------------------------------
tab = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAdCAIAAADZ8fBYAAAAA3NCSVQICAjb4U/gAAACq0lE"
    "QVRIidWWTWgTQRTHJ+3ETEugERrtF6QhFhKsIlgQRITm5LkBvdiDhBZKc5DiRXryoAEPPRUi"
    "pTnVi4cee5NePAitFtFoVxSyheYDa02KCd3deW/Gw2Cy7MZaIz307TK7/Gfeb9587Nvx6LpO"
    "TsA6TgJ6glyqHgcHB4/ub0ZvdRFCBApCCCIAICAHDgBcXcoAADhQLwUOgBxAIAIinju89iRz"
    "gzHW5Pb09BBCImO3AcDn8xJCECUAWCAsjpaFJgfTBMsCk4NposnB56UmB4sjgOCAiIJsbJXL"
    "5b6+PsYYtQev5b8hSi/tJIQIKRAloEAUHAQAchQIgoPgiIiys9NClAAIQgohhJBnCKnX6wDQ"
    "jFfZ0+TA/8xpIv6+8e5cN61Qm05ltEJtOvVMK9QS8ewRpWqj2js4nsb+nbv3cnU9OZ3KzD2c"
    "/NdIF9IrS4sziXg2+aA/FAr5/X5nvG1AW3o5ufOTL9rgur2c3Mcrd9rgur1Oe7wL6edtcN1e"
    "7v1wtw2u2+u0z2978S6kV/7CbRmv6sxdquVSH7HTR/9tE+PLUsqp2cz27k/7PTWbkcezifHl"
    "tbW1XC6n6zp1dONeWaUk4tnjTwtx5F81KEcSaQxzdT1p1xPxrFtpwY3d7C6WKkuLMypVqg4U"
    "tFiqBEfNYqmi57er1WogEBgOx1oqDVoz/77e2Onu6hq7emGg/6w9imKp8ubt149a/mI0rGqV"
    "8u7DlyuXRuzKp8/5yzG/yr9NrmEYm1uFba2svTq0c0eu+2LR88z7Qy905PW9vZwvOGqGQ73D"
    "Q1Lf9eR3vitlONQbHpLBYHBwcJAx5rGfd6rV6v7+vmEY7nVgjDHGDMNo1LZUIpGIc34ppYFA"
    "gDGmfqgOo5RSSgGgUdtSUSUANLmqWp0q/mTK82hFcX4Bm24GMv+uL+EAAAAASUVORK5CYII=")
""" VS2005 unfocused docking guide window center bitmap. """

#----------------------------------------------------------------------
tab_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAdCAIAAADZ8fBYAAAAA3NCSVQICAjb4U/gAAAC10lE"
    "QVRIidWWT0gUcRTH387+ZveXZgzsbmvSsmqEfzBJSYz+gUsHCYJgISPytCQKFhJdpIN0qIUO"
    "ezIUaU/roQ5eEzp46ZT/DhG4haCXdSUPK+Wuzvze+02HgdFmFqMtD76Bx8yb3/v8vr/3Zn4z"
    "np6ReTgCYwAwdqfEGFMURVGU/wIdfaswAGCMcc5VVf1fXIBdBgCKoqiq+nxkobn3BABIkgBA"
    "hIiEJFAgorAOyxARBTKVoUAkgSiJkIhO73a/nLjGOd/nWkrPXbqLiH6/CgBEJiIaKA1BhkG6"
    "QF1Hw0BdoK6TLtCvMl2gIQhRCiQiCfPLm5ubtbW1YNXXtuzadyJTZV4AkKYkMpEkkRQoEUmQ"
    "JJQCpSAiMr1eg8hEJJSmlFJK0wdQLBYR0cl9laj7l6LGY5/tc2ejsrmdgeGJbG5nYHgym9uJ"
    "x9KHeGuMNd7B8fSMzCfvyerq6rHHn2bmEgPDE09G+/9WaSqZmRofisfSiadnotHoozclp94K"
    "oGWznNxn/e8q4LqznNwXmb4KuO6s4643lZyugOvOcj8PDyrgurOOe30r05tKZv7ALavXmszt"
    "rXZZL7EjhTmuU8lpRxNSyemZuUEAmJlLOPzU+CAAuKFluO7OWpF4LO1OPsTcejOOTcRepqXR"
    "tngs7Y6U4bbcqNrIF6bGh6yt0prAgm7kC6E2fSNfWF9b2d7e1jStvqGlbMSmeRsuP7zZZvp8"
    "PvCoW1s/a2qq7vddD57y3b7VZfmNfGFxadUQBgqztbWps7Pdy04uLq0WSyVJnoMRgUY45NM0"
    "bXZZ7OvtaA8vLOdeT85mP+4eXN35K/6W5nBjxFz5tv7+w8LWF3+oTW+IBpsavStf1+xIfTTY"
    "cNbknDPGfqsD5/xCa6AuDFe791xtEJyHIhHedTGw17tnj49EeFdH8GAkEAhwzgF+7HMZY5qm"
    "cc6tD6rDGGOMMUS075aN2Ho9R/R/9gsXZ7dKHM+ODQAAAABJRU5ErkJggg==")
""" VS2005 focused docking guide window center bitmap. """

#----------------------------------------------------------------------
up = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACHUlE"
    "QVRIidWWP4vUQBjGn8mfcyGQYiM2W8mWsRcLm22uWw6uFpQt7WwVLPwKVsp+gFMsAwqynY2F"
    "oLAgNu4HsEiz3E7mfee1yN9Lcueu7oo+IcPMZN4fz7yZzEQlSYIDyAMQx/F+ocvl0tkvsdKh"
    "uF6z8eLsAwDLlpmImNiQISKTX7mIiAx5vkeGiA2RZSZmvnF++9nzO0EQ9HC/vj2fPr0PgFmI"
    "KCObGc4y1oa0piwjbUhr1oau+Z42lBkmsoaY2eLjpzRN+7kAvn3/wVasWGYhtszWkCViw5bJ"
    "GrKGmVlcN2MWIiYr1lpr5QjYbDb9eQBw95YBIBBVdDiAC/iAAAoKEOQ3AJRtQL38/OXS/ALw"
    "XKcxXKBUAVIOAIjUDxUApaQcecV7A3DkuYJG8EVX7VpdtNXm+p4jjfjcrsotdQFlslQH3OH6"
    "bj2tPCx3Dyk7S5jU3K7hHr91vNTDRUFBFfkt7Uk5p6763lsxYaWUiKjCbOFf6llImd2+DLe5"
    "ruM0UlA5uazS7S/Usz88vnf2G2VLKkmSap989OD9m8WsO2gbnU7mD5/cHI/H+C/3yR24p5P5"
    "/rk5dHv0VtzpyWsThiYMszCcnrzaD/d4ttDXIx0NdTTMoqGOouPZ4pdR7e+iq3fzyTYGWzrY"
    "etj7zwOAOI7/yjmPHRfpFVKr1apqrNfrNE2bx+pOGgwGo9Eor1/wGwRB9QPwh/oH9oed9BPW"
    "YyQlBOJt4AAAAABJRU5ErkJggg==")
""" VS2005 unfocused docking guide window up bitmap. """
#----------------------------------------------------------------------
up_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB0AAAAgCAIAAABhFeQrAAAAA3NCSVQICAjb4U/gAAACTUlE"
    "QVRIic2WP28TMRjGH/85c1miqEF8CnbUgSFdukVRmZGQ+gW6Vgwd+hW60Yq1gMQMQzpHGZAg"
    "C6JS+QIMmUju/L5+Ge6ulzoRTcMh5TmdZfv8/vT4Pcu26h2N8R9kAZwMfltrtdZa60agx5fa"
    "ArDWpmmaJElTXGBmAWitkyRxzllrG+Zqra21bz+OAQQOzETExJ48EfniKURE5MkmljwRe6LA"
    "TMz8ZPbs9GzXOWeMQZHfW33/NOufvALALESUU8g95zlnnrKM8pwyT1nGmadHic085Z6Jgidm"
    "Dhh/mU6nnU6n1WrFXAA/fv7iIEECsxAH5uApELHnwBQ8Bc/MLMbkzELEFCSEEII4YD6fhxAK"
    "Tsx9/tQDEIgqOzRggAQQQEEBguIFgKoNqDdfvy1yYq41emG4QKkSpDQAiNQfFQClpBoZcaK2"
    "s0awEHzXVVyri1gxN7FaFuILu6qwtAyokqWWwEvcxNTTKsIK95Cqs4JJzV02vMJvHS/1cFFQ"
    "UGV+K3tSzWlZq/5bOWGllIio0mzpX+pZSJXdVRmOuabcItRC+ZfKcn+pFRvN65fvNihj9Y7G"
    "o9FoMplcX18f9M5lUx30zofD4WQyubm56R2Nm9oYY20B98XeRfPcAro+ei1uf/DBt9u+3c7b"
    "7f7gfTPc/cOr7HE36+5k3Z28u5N1u/uHV/dG3X+gfb7YW8dgpC1YD1vBjfP7oEW6Lvf0bHc6"
    "nc7n881YaZre3pjucJ1znU7n9qx+qLTWzrkVXGNMcav4d1kAx5camAGzRoiF/gCKPmudbgYP"
    "HQAAAABJRU5ErkJggg==")
""" VS2005 focused docking guide window up bitmap. """

#----------------------------------------------------------------------
aero_dock_pane = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAMAAABnVw3AAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAb3WKdHqPdnyRd3+deYGge4OifISifoallZaWgIy1g463hZC5hZG6iJO8o6Sk"
    "pKSkpKWlpaampqenqKmpqaqqqqurq6ysrKysra6urq+vr7CwsLGxsbKysrOzs7S0tLS0tLW1"
    "tba2tre3t7i4uLm5uru7vLy8vL29vr6+iZfLjJrNjpzPjpzQkZ7PkJ/SlKHSkaHek6Pgk6Th"
    "labjmKjlnqzhnqzjoa/npbPov8DAwMDAwMHBwsLCwsPDw8TExMXFxsbGycnJycrKysvLzMzM"
    "zM3Nzc7Ozs/Pz9DQ0NDQ0NHR0dLS0tPT09TU1NTU1tbW1tfX0tTY19jY1tjd2NjY2dnZ2dra"
    "2tvb29zc29zf3Nzc3N3d3d7e3t/fxs7szNPt0NXo0dfu1djk09js2tzk3d/k3d/m2Nzv3N/r"
    "1Nr02N713OH13OL23+X43+X54ODg4eHh4eLi4+Pj4uPm4uPn4+Tk5OTk5OXl5ubm5+fn4eLo"
    "4uTs5eXp5efv5+jo6Ojo6enp6urq6+vr6Onv7Ozs7O3t7e7u7u/v4Ob55Oj16Ov37e/26+/9"
    "7/D28PDw8fHx8vLy8/Pz8/P09PT09fX19vb29vf38vT89ff9+Pj4+Pj5+vr6+vr7+/v8/Pz8"
    "/f39/v7+////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAsPpcmgAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAf+SURBVGhD7Zr7d9tEGoa9UKBZCiapneBQN3bUQlgo13DbhXBrnRQnS0LJNhDbUO7s"
    "ErCtZWWZm2Rj2YHdbWQsCSQL2/yjZkaypBlpdKH14XA4vL8kkuebx3PR6HtnHBtHkfxyZoGs"
    "zMtR4sfjWJRi0mJRHZGlFhej1BCNs1XyocDbpa0ooEjtSfcDOHp6apyFAMzop4XfF2f0K7Vn"
    "qpyhr0bT5AwHvhpOkzPQ/TVNjt73lT6c4jzQNV/1p8npq77SBlNsj6b4Sr1Ozmtr99xpvQpm"
    "6LKvquyMVezOe9Ze81uDfNbRHLUtiPaqNi8KvrqqztvlRGGbypFJRM7mMoOtnPNHDV8JisOB"
    "QczyJolE4qy/MMAX6Pl23VdNGeeMBi+sE0AEzsYl92tgXqj5ipNcnNHo0oYX5OVsnfe8beab"
    "VVQcelHveTij895XrJdD6SGc4b+HCIglcHTK0yAPJ4dPAYOJtUd/78b3dAdE4owYz6zzcM4Q"
    "3tEop/v18ePHv+7aICJndMbdIDdn93Iwp/vh7VAf2iAy5/KuC+TmPN0J5HQ+eNDUB51Ji8ic"
    "zjMhnAwpIbT7TfjXU4+ZeuqfbRNE5miZEE5qGNSe2g//s/RDLYgzSoVwiKlammMmvVTjLE0w"
    "NH+UJmV37peFe3yInM3NZp0liz/azk+NM0ptt3tkdXZSxGQ1vD3EDOpiep6s9EVSeW+y5e03"
    "/1Qt+ie/Fseb1HnaE5AS+ieL7k+IHMwTzqDDcDofkB+6P8qfRkPtpAEkD9Bbxsa4J+RHyCgo"
    "hZRRm/xi9sxZH61smMBUQUEiRzwyC6G3jLk8IY8PdvElWMdf/6745om9DQP0UhELxDjQW8Zc"
    "ntDF6Z8CdXSoID/XuxtyTmlBHD0dcy0ALs4oCRLrdiBHpmDuncT7wdWenxZ+I5xhEgxMWHvg"
    "2AW3Z+RpD4c/ChMO6WVhjZlMmRwscMjhQwo5WM9+hT8WgyQwCgIVtOLIFPQSSdyKDb7CpwXg"
    "DLGa2b49g/W+1jc4LSrgcR1IJgdYpL5tk/o6i4YMYL/hX6TmYD76XtN0k9MPAE044Pt9/5ED"
    "qmERQ8DBPWHNMlT6O08eaqqeBManRWn+vrEvUdAbJTVVO3zyHX0SrtXQCOAtAQd71BnVdFQ/"
    "fvnQ6qGq9BOyLDcp1d83aj0KFJETqqIerj705Y9muMqgEcBbxhZwT1iVJSjt/dvOrR4q8oQj"
    "+/tGtWtyFEk5XD132/saDJeVKhYxABwNFrNVMV7P2he3nDi3+oksaQkQxVMSVga7ABxYc0Lu"
    "yZ+snjtxyxcarECqoIVUHXBUowGWSl1RFKVXbrj5xP2rH0tdNQGCeKqLlcEuZJGCFSckUfp4"
    "9f4TN9/wigRq6JXQQjLkiC1U2xx0VOKnN91636MHQqN7EnxIL7exMthFm1+G1yeFunDw6H23"
    "3vSpCOK5xjZaqKMCTodHtVVjgGryu5DT5ETIqWabWBnsojnhNJkm5Lwrwwpq9S20UEsBnDaW"
    "mOWrhrOuaJ8/8MgBx1ydA8a0nOV9sjdwm6tnoXed48vcwSMPfK5VjHAmj0bwEuC0aFTrpaIp"
    "4coTB2y1Mwe+VznLYmWwC5bNwq8+xxbZgyeuCGZwqbKOFuIgB/eEueL+RI03vq2U27Ogt4vZ"
    "SZKLuUcrE65l4YjO1vYr377RmMQWyjm0LNsL4BQblf2yMAvaXwjhwC4CnP1Kw/qSETiFPUSA"
    "A4x2IRPcHujFZxk0br8U2h43B8ye/RAOnKHXxykJd4Dx3AvmZOCQ33Fd7Zlwlpx+oxnXjgX3"
    "Hyoap4XNohzWb6VWHHx62eHQbMt2WuY/teeegxXEw9qT5i2vZvAwzn6VT0CO02+McDpt6PSp"
    "U+bf9N+MuEQF/YL4PICeL7a12UK9Wr5SclTlN1YMjv2cgqfSeHHIWm4H/lX0s/8wOCvnmbIT"
    "WMbWA+D5NmNj3KuVOsgCyF2cMyq5i7NutjfOmtsyytkj46+wWDb7fW6DdSKFoxJi/zqXUvBc"
    "Jr+EHCHNzMUdJWBrgJ5fNDsL6O61lFF6MWsGUevW8K4knMDZBOoXlvLecybXMmRVUrBEWnq8"
    "98BCE+br8eUuWrWeUr95zr1JZNjQf5P3kpp8re05uXPks4F9tHOSALpGzsqu/z65sjuZlCju"
    "GjkJMYDThUuGS+GcVIP2hsVtzP+/sfRf654Kl0CX6t2w/SqwxARx3nr8YVOPvxnAofl22P7b"
    "0wXCu9Npj3LlL6auOD3pbQ/dpMP2E3fXsd1ps21xxc5ilbf/DPU2csfLqXXyYfuj42zL23Fx"
    "M7k3pHx27NixzxT7WlY8HJqXlsP2e8e5Hd4DiqPJ8nev/unV75AbHg7NdvbC96/HSy3PVIhL"
    "6Caf/LqMXbrbwzRF9ywg/S5gc80DiveABXAELYWtroRzaIbvPus9miGcl6xfEOp417k4GFTE"
    "OTTb7G4QDmaI5z9rnQbL0A4rLl71Fcqh6RrfEZ+NeP4zHm8uXT4SeM5O+We7ARwZpsaG6nzr"
    "qrSXiXyeBebkhcyFCmuPdkLq+qpnWD5DEkfnMhd+wfkcLArOG+20Yaaw66s92kkFfvl5I/6l"
    "FgLPAad4TtsJOgecIifgHBB4wun9PgT3lphvrHtSKCI20u9qfJI6Yy33vjr/4Fg98Ee/hZ8H"
    "k2bLAu4tsYRomvPN5S1RDvSEU3tOXd4S2yICnnBqHJe3RLMD6AmjKNJ64PKW6C8VoSeMop8B"
    "XFekjMjBOHUAAAAASUVORK5CYII=")

#----------------------------------------------------------------------
aero_dock_pane_denied = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAYAAABQif3yAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "ABh0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjM2qefiJQAAELhJREFUeF7tnfmPHNURx81v"
    "hEsCIQQCxCnu60d+AH5BCCGBAAkEP/AHABKKkEhCCErCHcA4WGAIYJwYbOMrGHzgE9vYxvje"
    "9drYa+99etd7zHov766PSn3avFFvu3v6dU9Pz2Q9K5Vmtt9VVd9X76zqOWtSCf4NDw9LfX39"
    "pMbGxklHR0YKxuHvzj570tVXXz3ptttuO6tgjUykioeGhuTbRYukrr5eRkZG5OTJkwUj6qcd"
    "2ptIOiyYLFV79khDQ0PBAPEDm/Zot2BCTZSKFy9eLGNjY6mCc+zYMaHdiaLDgsmxYOHCVIHB"
    "kvij3YIJNVEqLoNTwkgWAxysp2w5Fp2iDI6FkoqVxYBz4sQJSYPM6q1sORaIoyRAOX78eCpE"
    "W+VhzQIYsgAOwLC8TYvK4EQAB1DY66RBtIX1lIc1C4BQEgobHR1NhegAZXAsgDHDGgrj3CsN"
    "ohMwjJYtxwIglITCjh49mgrRAc5YcGpqa2Xjxo2yZs0aWaiKR/m5aNonn0hLS4vodUEq1NTc"
    "LO3t7UK7YbzBP3IgD3JZ9LXSzLJj505Zvny57Nu3T7p7eqS/v9/qzGzBggVO3h4tkwb19fU5"
    "wyft2lxPGN6QC/mQszQR8OGqqqpKlv3wg7S2tloJ61UISjpy5IgcPnw4FaIDMITaguPlFzmR"
    "F7lLGqRdu3bJ1q1bnTHcphf65UFJvb29cujQoVSoq6tLuHmNCw4yIC9yI39JAlRRUSH7q6tj"
    "g5I9RlFw6M1tbW2pUEdHh3D7mg84hnfkRw8lBRC3iNu3b88bGGenruDQm5t1oo5KKDpqGSx0"
    "cHAwEXDgHz2U1K0qEyMbx7hDmbtcXHDYSDa3tDsbyigAsVJLEhz0gD5KwnpYrcSd/IPmnKiW"
    "MzZ2TOoaWuWPr051PvnfFqCkwUEm9FESq7jlK1YkYjHuOScKOAMDA9LRmZG/vj07S/zPcxuA"
    "CgEOsqCXolpPtU6ABw8eLBo4AFDb0CX/+GjNacRzG4AKBQ56QT9FA2j9Tz9JJpMpCji0W12b"
    "kQ//XRVIpJMvlwUVCpxebXfDhg3FA2fp0qWJO/7ZLAhYalfXD8nsJR3yr7ltgUT63oODzr4p"
    "CKBCgcP5IPopmuX899tvndVREqu0KHMOe6DhoyekKxNOg5qP/GmDgzzop2jgFMIZ43t17mO/"
    "woon13CEwskXRrmA4YC1s7PTOS6i3SQ7WdFvVwsBDmdUu5VYsbFBZNgpFBlgOMTcvXt3GRyb"
    "3slwgMKYK9ggFopYLOzfv98Zfmz4ipqnqBd4hXRjqqisdPyX5+txTqGI+mknaResknC3KiQ4"
    "SSsszfrK4KTkdBgX1JJYEKTpAJiWo2G+7STuqLh3715n0xR2j+5O59496nyweMkSZ2WUlsNg"
    "Eu3AL3xHkZXNtI1fgluf6B8cxu2N4ob5sRTFfKOYPlfCtXV1zgrJT3HcSm7dtk2WLlvmHB6u"
    "WLmyoLTmxx+dC7IgEOETfuE7ipzoxejHdpV3WhhkPmF+NB6FYXdeDciVSl0peZWybv162aO9"
    "B2Wk4VjIMh1w/ACCP/iMI2MccAyI2TDIfML88gEHx8Hvvv9+HDjsO37QiyrbnpZUPgBatXr1"
    "aR0F/uggaYOTDYPMZ5efDzgodv78+eP8odl0couYlNJt62EopV2vbzb8xQHGLAiiDmuG32wY"
    "ZBmck473TRkcz95knvZM97zSE9FyRvTgs2X6dNn3zDNSdd99DvGdZ6RFtRzvHAd/xbCc7B4p"
    "H8vhRDjungChg8AJu4Y4zssd3nxTKq64QpruvVd6nn9eMq+9Jn36rOfFF6Xp/vul4sornTzk"
    "DQPJWE4QOHFkRAb0E9Z2ULpzLpfPEcwhbTzuPgKBAccdScAlGsNLrt46qouG3Q89JLU33yyZ"
    "d9+VgVmzfCkzebLU3Xqrk5cyueo04HijGuAvbiAX5dBPHMsbZzlUEEfJHOUzidoseU1AFHkp"
    "4wdOd3e3A04QL2O6vK56/HGpv/126fv4YznyxRdyZOZM6Z87Vwa0p0F85xlp5Km/4w6nDGX9"
    "6oUPnApp1w8cd6wQfNvEDpl86CeqXo23bNZy4vYOLrJsgaltGpL+wePZ/DDttRzAYSlthPMK"
    "1qIK//XSS6Xr9del7/PPpV979oC+t2bQQzwjjTzkpQxlgxQFOLTrB46788E/ctgChH6igjMu"
    "0s5EksUJ8WvVxsMCnGhsT3W3zFx0SBrbT0WrUcaA447DMeAY63LzNKoK3HXTTdLy5JPS9+mn"
    "MvjVV1ZE3tannnLKUoefnAYcb0yQmRPhF57gHzmQB/5zyU5+9BNVr77g2FiANw9XyTAYFOh0"
    "7NhxaTuUkY9nVsknczTmRoUz+WF63rx5zjLWELefpgd72+pWT5bKSy6RHp3kB6dNi0S9b78t"
    "lZddJtThJyebUNp188J3+DP88gn/yIE8yIV8QbKTH/1E1eu4MEgsJ26YH3f8CEHP89LIyKh6"
    "X7bLW1NXyZQvK7PgIAxlcoFDurdXNrz3ntTcfbcMqKI7dXXWpRbRrcNWr1JGqY/5R6lfaRDS"
    "ZwOap++555wytffcI9Th19vxbwsCB36RjU8DDvIgF/Ihp1d2+Cc/+gkbWfzSs5F2JszP22ts"
    "/m9qavK9Qqa3tLV1yqtvfiVvfbhSpkw/BU5D22gWTPLM1Z7pFowdNUrimbf9mpdektZHHpHB"
    "l1+WtqeflhNaPuzvpObpffhhp0zro48KdXjrRTkGHK+S4Y/8WBaf8I8cyINcyIecyOK9Sqcu"
    "9GOjR3ceM+RnFwQ88Ov9Yc84oEMwor0MUaZqb7W89Mo/5S9vGHAqZJoDzql2KEObCO8WyoBD"
    "urftuldekfYHHpChZ5+VVlW4LTg9N94oA7paa3/wQaEOv14O73QKr4JN5yGdcvCPHFOmVzjg"
    "IB9yIi/pbj1QF/oJ06EfP8w7WXColMk4KuGEwUbLG+hEfc0th+TPr/1H3piyXCZ/vlM+mtUk"
    "dS3DTuwNUWsAMOebb8a1iasSUWKcsXl5adBhqvGaa2ToscekQ0Fqf/996fjgA+nUvc5hHba6"
    "lLqVmF8ySn3vvCNHdH7KXH+9DN51lzRee61Qh7de2qJT0K43Df7gF/n4hH/kQB7kQj7kRF63"
    "DtAJMjohlxH1yuGvEwZpNqE8gMGotEfjclguMvG5yXH602HgYG3raeAw6cM8AnnBYYzmHoc8"
    "Xl7ata09uiAYUksY1n3O8J13yvAtt8jwDTeE0pDmoSx1eOs1bQWBQzqy8ekFB/mQ06sD/gcs"
    "9BNVp4DphEEacOg9cXzDKvWGEIX6RT4z3jJZNrd2y9QZFfLR142OcMZhkEDZ2XPmjIv7pB7A"
    "QSA/fvY+8YS06Z5l5KqrIhFlKOtXp7F82vXGocIfvMAX+RxwVA7kQS7kQ06v/DwDUPQTVa+0"
    "50TaGXBAiyElKhEDybjKhVQQMRxU/tohMxa2SG3zsMMsgGKtRnjTuww45PHjpWHTJtmhFtB5"
    "8cUypgq3IfJShrJ+dRrlmU7h7unwRzqy8Qn/yIE8yBUkMzoBIPQTVafZMEgDTpR4GLeL7E4N"
    "nILBWo3Jz0X0yM27uqWj62i2p2Gts2fPHjdWUxdKyuVCWztjhmw5/3ypvuACGbrwQjl+0UW+"
    "RBp5yEuZINdeE3tKu965E/5IRzaUDf/IgTy55K3Ta206GvqxiRFy58k61qcFDkpHIAREKBin"
    "581S4d1mj1Bh4CBInZbbfvnlsv6cc2THuedKzXnnSdNvxHeekUYe8ob5XAMA7XqHIPgz4BiA"
    "kCOsQ5YMODBSU1MTidzguKOmcaTAAyWX5RhFN+p4Xv3CC7L9uutkkwLx02/Ed57t1zTyhPVc"
    "t+V4I7gBh7kjqnwAydBWdMvJFxz3Kg+h/MABTNLwa8bRfceOHbJlyxbnNSfr9HUna/REYLXe"
    "5zj02WeyVv0BCFz65ZdfnOhmXJtY1qJklOYGzA2Od9V5RoKDgpxhTe9i3BMmygsChzQUjEfM"
    "NnWd+vnnn2W9euqsViBWqAvVMh2WKMvR/6pVq2TdunUOeOblDfiDEQpoJmsDUBYcLeudvOHv"
    "jLOcXOAssRjWmLsMoWSUapTtVrCxhFwvnGB11KJDF6CWJDgspcPGZr90xtQ4wxrg0ObX2jPd"
    "9dKzbcAxgDCBU09YAFWudI71N6kVQl4Z4a+oloPfGmv7sEiypMBh7qAu2uTsyguO7YIAfhka"
    "cZNFBl/SNHzPoKB0ItoYHv3kgz8sNGoHjLsgcEfaOa/vx+OTSZYeGDWSjIkW5rEEWzLA4GH5"
    "o7rC+oETtAl1DzvuzaPftQXPOC3GullIeA8YOSLhgBF33wMHDviCA3/bdEFBR2BRYisjeSmD"
    "fqKcELgj7bJvoYobSVavoLDTj3K4xxBDwNIc3X379dZF333nDFNhdbKJ3aUAo9ygV7sMKwAr"
    "NZ2YTz8vFywPP3GUGTSswycdyQyhYXyRTr20iX6iROU5kXb67oLTAn1BmfE+apQBzDM22xK3"
    "iziPBylj8+bNjsIChyrXEIYL7QZdkSGMH9+LtB42l0EysQjYqUcsYfMt/MK3rYwswRkSo0YZ"
    "oH9wSCQCG6HjHv2EKYQNaRiF1VGs9HFHMIloOkYlhQSnWIpNot0yODHex5aE4m3qmPDgrF27"
    "1vFrsx3n4+SjftqxUXiUPBMaHG5I9+nylxVPId8vTf20Q3tRlB+Wd8KCw96CV2EVEhRv3bTn"
    "3XOFAZArfcKCwxIU/4I0wcHZxHta8X8PDvsLLp/cB4/5CEVZ5g4bYDJ9w9LaMRRKPZlTDn65"
    "CG8X7zlfPnJw0gLgRX1rFOdg5qglH2HcZW3B2b2/V+/zm2TqzPpAIn3HnlMv9U4LHHM+xglG"
    "Ud+3xpsKORS0ubm0Bc8WHJS9Wx0t3v10eyCRHgaMSU/KcgCHjTmfRX1TIRMpxx9x3uccBJYB"
    "x8aNFcX+Wt0qf5+87DTiufHLDquLfEmBQ0fljAy3qKK+45NDBW4gjWuVrXXkyoeSgpzj/Vxb"
    "UWxTc4f86W9fZon/jQN6mDuscTpPAhwzpNEmTooxDl2SLcL7k9krcNydxMIAJYUp1Js+MDAo"
    "+6rr5Pd/eM/55P8odSRhOcjO/IvVHNQr9ZJ4rzRQc5qK9SSxODDgRDlqN1EANbUN2aiAKOWx"
    "nnwtx7jssg0o6kLAa3tcDOFMkQRAKAnFuj32bb97Ix5sypmIhrjgYDEAw8hBXRvVs7Tkfq4F"
    "11NcloxXftwhLh9wbMDwy8MQGAccM5SxOgMYLv9K9mdaYAwLYtxlc8owR68y18s2CwaUhAJx"
    "dE+DTOyNLThGFlZlWAuyUgcWU7LAmKEOk2YOOqCeNBwsYkkIwXLb5j6dW0R6YRrA0AaKZc7x"
    "ugb78crOH1kYvimLxRlfu5IbynKt+xjimBj5xAnEHAaGTdQmmgyA0iD48Yuy8+MTMBw/N51n"
    "cBwx8iW7/k2xNvevHdr4J3DvzqkDG7g0iJ6Psm3v+yfErx3GxR8Ai/KDeoRclP9yawBwmGRT"
    "/0G9MjjhXRNw0vxBvXFhfuHsndk5ACduGGTUED/yZ39Qr2w54R0vbXerkrhSDldLaeQog1Ma"
    "OPhyUQanDE7WFao8rEXoDGXLiaCstLOWwUlb4xHaM0tpmxPsJPKUh7UI4OQTBhkVrNPC/CLw"
    "eUZmzScM0uZKwp3HN8zvjNR6BKHjhkGGXUd40wPD/CLwekZmjRMGaXMl4c6TaJhfAVD6HyAO"
    "VvwtWIicAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_dock_pane_bottom = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAYAAABQif3yAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzoyMTozMiArMDEwMExUiZ4AAAAHdElNRQfZAxkQJgE7q5VA"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAEFtJREFUeNrtXVtsHFcZ"
    "/me8a+9617Ed3x3HcXNxnDhxmsShQQqEolKq0pLeVakSqA8g8YIEQvDAC0g8IB6okEAoPEBB"
    "QEvbJKWFJqBSWpSUosYpdpzaiXN1Yju+xJfYXtu73hnOd3bPerz3uezMoPqTRrM7u3PO///f"
    "ufz/ucxI5EKEQiH16tWrdP36dVpYXCxYPn6fj1paWmjdunVHmpub33Bab9djfn5ePX7ihHrl"
    "6lV1cXFRVRSlYAfSRz7Ib3Bw8FmndU+G5LQAyeg5f14tCwZp06ZNtuV548YNmp2bo47du11l"
    "D9lpAZJx/do12rBhg615NjU18XzdBteRsxQOk8fjsTVP5Id83QbXkbOGFayRw6CqqtMipMUa"
    "OS6GvY27DthVmiXJVQ7aKriSHBBjZ1PjVoI+8eQgn6KiIqdVTotPPDmoNW51CFxJDuBWg9kJ"
    "V5Jjd5/j1oKwRo6LUXByBi5fVm+PjNDS0hJNT09TLpOPjY3xIxqN2mIASZbJ6/HwPF997bWs"
    "4sGnq6iooJKSEqpvaKBtW7cW1M0rCDlHjx5t29/Z2TfOFI6Ew7Rj504q9nopGAzmvPfYsWNU"
    "Xl5OkUikkHonAE/N5/NRbU0NPfnEEzn/Pzc3x2UbHR2lkydPqjW1tdS5f39BSLKcnJ6eHvXm"
    "rVtUX1dH+/buNZQGmjS7ao7IL1+IAlZZWUltbW00PDxMf33rLXVjUxN1dHRYSpKl5Jw7d05d"
    "WFigLz74IMmy8ZEhEGNbs2bSlW5sbKT6+nrq6uri+u/bt88ygiwbW/voo49Uf2kpHThwwBQx"
    "AIylKIotBwqBWecD+kJv6A87WGVTS8jB7OXy8jJtb221RChhNL0H+g+991jpGUJ/2AH2sCI9"
    "S8gZYn3Mvffea4mCRoHZ03BE0T2LarXLDjvAHlbANDlnu7rU3bt3Ozo+VV/fQNcHR+jnR1/l"
    "Z3x3CrAD7AG7mE3LNDnj4+O8U3QK8Jomp+boty+9R77San7Gd1x3CrAH7GIWpsjp7+9Xt2ze"
    "7JgRQMDoxCK9+EoXlZbVJQ58x3UnCYJdYB8zaZgi5zYLxGpY8OYEysrKaGh0mf7y7gj5grUp"
    "B67jd/zPCVQzu2DUwQxMxTlzs7Pk9/ttVzwQCNDoVDF19c2Sz1+V8X9dfUu0Z3uQGquDPLK3"
    "VUbmVt+9e9dUGqbIwXIir9drq9LA4uIiNTdUUFWlL+d//ewvM5MztssIu5hdbmWKHMQjVk/x"
    "FpeU8PgDgR3STwf8PjV5Oy8PcSaUebQBsovYCPlajUzy5wvXTRnc09JCo6ytbmxo4AFdtjgk"
    "H+VBQKZFimLQc2hoiFpsXP6bL1xHzq5du+jE66/zYXyMWRUXFxcsL4wuY+Cyr7+fHn/sMadV"
    "T4El5FgdZT925AiGQOj06dO0uLRUMOV9rCnb2NzM87NSB6uaetfVHIEOFmXj+CRjbcVnAWBV"
    "LTRdc9bm+1NhVbOWSKW3t1fVu80PEbDeEQJ4R5tYO79z506bTGUeH3/8Md0YHOTxVb6AYcfG"
    "x6m2tjbve8Q2SOYUSSINwra7PXv20IbGRl3eEQb3QI6emhNmgdkQ85C6u7vpy48+mvI7PKjz"
    "vb08bbi6hV4qCze7av167iWmwxtvvklGbAO5hX2M2OaJxx+XJDPb/JB5dXW1IaNgqx+GN9rb"
    "21ddP33mDE9z65YtpmdU8wEKw8DAAP+cTNCFCxewmdeQbYyQo7UNtkHKTmzzA/hWPyaEFhj/"
    "whqEdtbkYfkRhkAKfZSWltK2bdtofGIiRUbI55htGC8eJ7b5AcgzzGIYbZOIz06s90cNjaYZ"
    "jYB8TtkGvKy50i6GY0Eod8FpdUzgtEOeXHOckkfIYYocMzFONi+MN28u2tBkVEez8V+CHCMJ"
    "qQbvy6hAUv9jN9LlaaYAGrWPKJgeIYCRuQeV3ZOv8Oh0xX+RebqaIdIxOw+i1xDZ5NfaRsid"
    "Sz6hmxpfuKhXHnG/rDWKXugh5sZwmBbDcs77rKiNenUQ+Wb7HYD80CNX/CX0M9Qaae7zJF/Q"
    "lRDlNiSi/P4rM3SuL0KH71tPDVWU4j5nM4idyNasoTRP3o3SmXN3WSzmpbYt5TnXcxspaNoW"
    "xVSfI/qITPd6PF4am5il9/4zTLK3cpWy/J6kQqHmSK9QyJhvSg2QaH5hmekzTuvLi6i2uoyW"
    "lyPZEjalS6JZM3JkWyAuSTIN3hqjF1/5kMLLikbe3AIrmr7MriMbcUIeAegDvaAf9EzWXWsf"
    "IzYVeclaAfQemQRAhHvnzjT95g9vx2qXmihIq/+bVDBE52nnLoNkIrLJl+An9gPXD3pC33SF"
    "1oge2hpsuuYkC4A28+LANXrhF3/UeMYqiW43uXSkK7121pxMsmivrfxnRQ9R2KAn9BVeXK6C"
    "m488ArzPwVB12MAaKwxSzs/PpzQLLc2N9M1vPEu//PXfUkoG5kRERyq+J5oLJgPSwkixXe40"
    "PC/kh3yT52uEfJAL0wWK4k/RB3pWlAdWLSAEUUgX9sGhB3CghDfIyTG6k0y7x0WL2dlZqq6q"
    "pOefe4D+9Mb5FIWT23ABUXqQpl3k5NP/ZZIH+lVXldPU1NSqdETsZNSuKa60IXKyCI65jOam"
    "evrqMwfoxN9vJjw7/B/r0bRVX2sIrUHsQKYmRfyGa5A3MTrNrnk9Mj3D9IK3Njp6O4XgxGJF"
    "g3oIOTxmjKFkqDkCw8NDfGf04fsaeJyDvyXXnHT32rknVItMsqzITBTwF9G+fQ3sLHH90kHE"
    "KooBPbQBrrkgNEOJ0wJVvrFmHYWW/BRkCi2FIqvinHQ1x85FI8mOSNKPCf3QLwVLJWrb7Gf6"
    "KFyvTBBDMEb0SHGlCw3McG5tUhgxY4nnC6R3VZ2dNEjnSgtAbsgPPezasWDL0ihU7ZmZmYz3"
    "Jz7HLtiieC5Z0umnx6u1oqA5vuIz05SB47K4AI6QkzBChrE1R5CuBXCYLMdrTjL0mEN0vGZm"
    "TeHyRpir7ManFXqEknZD6xBor+ULEUsgckccYhTLrD/EOrGydetS8ne6kfOUMOVy7SSzEtrd"
    "ZOm2LOZbTJAO1radef/9zM2PZtZSTlcA4+5uOSNmc5pd4ZDPKduAF0/LPffwx1Nh77wYY8oX"
    "iJpx6BEcmcOo2LRUk2G1aD5NFQyGZ7jh/Pn7788Ypff29vKFg83NzSn3Q/Z/vPMONTSkf6gE"
    "5Mt3l11y3sI2eta9rdpp19JCHrz54tjx46rHwE4ybGzCclU9UTCUHB4Zob6+Pjp06NCq3yAY"
    "2n8YLpcc+A9WZEJulPB0fQbkm5iYoIMHD6bd9Y1AMhQK8cKSDlgJig1c2GVXV1eXt20EOWFW"
    "2GGffMF32sE2/f149ttK8ezu7lYHb97UtZIeuwwqKyr4GFK+wEPxqliJbGWKp8OtW7f48w08"
    "eXTQPmZwEIpxvHS1F2l4mUEzjQwHAwGqZUavybHe+9LAAN1hJIfzfECfIOfOnTu6dhlAl+aN"
    "G7FwfmWXgVHgsYufO3xY97B4PsjHEMUObLPPByAGNebkqVP09FNPGbax61xpAbca3k6srZV2"
    "MVxXcyZCsfONSz3051ulNLZYuPJT61PoSFOINrV28O/VpU5rvxquIwf4/qmbpO74Ej3wnEqb"
    "/RLBzypmLTd8JQ87w1XIlzI4v/Alo+wDQtUldobLg3HlgZBKR/8lkXzqffrRQxudVjsFriPn"
    "2sVukrY8TD/+dJQCKotVmDU9MshgnyUeN3IvRk8vC4LgyymY7GOxyjKIYhcOSCo9eb9M3104"
    "yPJ9i6r37nFa/VVwXZ9z/GaAWg5JVBzNPnwiM3ZAWq5DzsIiSPJGFap8KJav22Cq5ojF6Va+"
    "SWMqLFOrTyIlS7gFgxezdurufO48MXupsrZQyfBX1KhGv0wXwtaVU2EPs3taTZFTYnLQ0SiK"
    "mc79A/P09r+naHImc/7ryz302c4K6thVRss2LUkQy6IQ7ZeYfG6PKXKCZWU8AEVka+WCDJRm"
    "NcMBLLKsdrQFCdXrxWMXM6bzzIPbacfOMprX8KddtCnGFKwe0wQ5WM+nZ+gmHUyRg0fiT8/M"
    "0IZAwFpy1JVVvPwM48mxz+hCmJ9AIWbw9vYa+lpRhF741bspaXzr65+j1rYamouoq9NSNekX"
    "YE5ADKjemZzUNXSTNi0zN7e1tUl4wweEsXJOCGRE4h4VXGDhCic8LiV2vhtWqXV7I/3wO1+g"
    "2akbiQPfcR2/KyoljmjSZ6QfUVZqkFmIMTUMkGJkGfYxk57pXrCuvp4/RgQCWUWQwpcjqbFz"
    "/FAZY/wzxY/49ZmwQg11FfSD7z1NodlhfsZ3XE/cS0lpaNPla9KsIUZM/uEpHBjFNgvT5OD1"
    "JFeuXOGCWfU4FBiLxyKa0q4t9YqoRRSrVRPLRdS+YzP97Cff5md8j9LKfxK1heI1UV1JP6Ja"
    "M+MJvcXUxaWLFy15bYsl/iMeNIT5GZQaKwgSzZmS4VCTDlwbXiCqaNrEz+n+I/qcVWQJYkzU"
    "HOGdgRg4Rt09PSkTe46Sg/fG4HHCeOoUJq7M9kFKvERHNCVc2+9oa4D2WIimvw5nTdTCaLxW"
    "RuL9TTievlFixMwuZlsHLl/mjyy26j06lkVeeG8MShAef4USJEjCNb0rZBCTRKLxGqQ5lLhx"
    "hUOQ96HEak1UWSFIOARwMvX0OUIX0b9ghhW6/re7m2di5ftzLB1bg2B48xSe/NTa2spdbQSp"
    "Yv4937UGsT5BZWcczBCqFO9n4kUc42s6SrtKq709ni5qUHzYQEiVa75fNGEgRkyPYy3ERdbH"
    "oClz9ZunACHg2bNn1YFLl/i6BDzWCorkG5Rh0GFZiZdsOWZYGUaVKNF7yzrMkOxOC/cczZmk"
    "rtScXPKBHOw9QuCNKfqRkRGu3yOPPPL/8c42gc7OTi4w3nY4ODjIV8pMTU/ncWc1vTypUh1r"
    "19aXSFTmlShQJJGvKDZs45Vjo9NFOswhRqHDjJ0ldp5nF2YjGMdTWCWU6CWW1mH2P0wr50Kl"
    "5m2H+wv0Ij2Bgk8Z6H1d48M/fVddZDVnjhmuRJK5gEXc3ZJILYr1HXrIEU0ayFli5GDoZ4GR"
    "E2Lexnw4FutEIrHRDTPz/YWA6+ZzgKVIbHimlElXwuzGKg9vxkRThgk3RSc53DNjaS3FD3h2"
    "yIM7Cvbv08oLriQHrto8K+oBZjQf62iK0ZRFV1xLVSc5fJiGsRBG7Ymi9sSO0HJsSfAaOXrA"
    "SjSatiV2hFlThqkWT7wp45zIMYLygSBHjKMlalA8D441cvRB0RzZpg9yIdO9Im03w3XT1GtY"
    "wRo5LsYaOS7GGjkuxho5LoY7yZHtE8ydBojBda50tV+iAPNxg8VywQ3nY9oHvDKVxfN1G1xH"
    "zvO7vfTPniLa8Jko+VlwGGTRZ9BL5GcRaElRbODTY2BsLaJI5FNUKmH3e2WViotUquHPspGo"
    "6qREX9nrod85rXwSXEfO/o5d1P7hB/T7Cwdpx6dU2lYqUwUjJcjI8LOqVMLO2Lnj0TNCoMZm"
    "PBfYMc9q5TQ7JhljlxaJhk4TtSkfUOeeXfklaCNcV5dVhunpafqw5wK93K/Q7fnCxfH1AZme"
    "bZPpQEc7VVRUYL7GVfb4H1Voiukj7VWUAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_dock_pane_center = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAYAAABQif3yAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzoyMTozMiArMDEwMExUiZ4AAAAHdElNRQfZAxkQKidFE1+x"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAEAxJREFUeNrtXdtvHNUZ"
    "/2Zv3l2vb7HjWxzbcRzjJCQOcSKQiBSQEBclFAgX0VYt4qnq9blP/Qeqqi+t2gi1BaQCJYQg"
    "oAQQD6VKHhBxwCGJc784dhzbcRzHt73O9Pxm96xnd2e9c9uZqdifdLT27syc832/c77zfec2"
    "ArkQS0tL0pUrV+jatWu0HI2WLZ9QMEjd3d1UW1v7TGdn54dOy+16LC4uSu8fOSJdvnJFikaj"
    "kiiKZUt4PvJBfqOjoy87LXs+BKcLkI9T330n1UQi1NXVZVue169fp/mFBdq+bZur9OFxugD5"
    "uHb1Kq1bt87WPDs6OuR83QbXkROLx8nn89maJ/JDvm6D68ipYAUVchgkSXK6CKqokONi2Gvc"
    "dcCu2iwIrnLQcuBKckCMnabGrQR978lBPl6v12mRVfG9Jwetxq0OgSvJAdyqMDvhSnLs7nPc"
    "WhEq5LgYZSfn4qVL0q2JCYrFYnT37l0qpfKpqSk5pVIpWxQgeDzk9/nkPA+9996qxYNPV19f"
    "T1VVVdTa1kabenvL6uaVhZyDBw/2D+7aNTLNBE7E47R5yxYK+P0UiURK3nv48GGqq6ujRCJR"
    "TrmzgKcWDAapee1aev7AgZLXLywsyGWbnJyko0ePSmubm2nX4GBZSLKcnFOnTkk3xsaotaWF"
    "dj7wgKFnwKTZ1XJ4flrBK1hDQwP19/fTzZs36d+ffCKt7+ig7du3W0qSpeScPHlSWl5epice"
    "f5w8HuMjQyDGNrNm0pVub2+n1tZWGhoakuXfuXOnZQRZNrb2zTffSKFwmHbv3m2KGADKEkXR"
    "loRKYNb5gLyQG/JDD1bp1BJyMHuZTCbpvr4+SwrFlaY3of/Qe4+VniHkhx6gDyueZwk546yP"
    "2bFjhyUCGgVmT+MJUfcsqtUuO/QAfVgB0+ScGBqStm3b5uj4VGtrG10bnaA/HTwkf+J/pwA9"
    "QB/Qi9lnmSZnenpa7hSdArymO7ML9MbbX1Iw3CR/4n987xSgD+jFLEyRc+7cOWljT49jSgAB"
    "k7ej9Pq7QxSuackm/I/vnSQIeoF+zDzDFDm3WCC2lgVvTqCmpobGJ5P08X8mKBhpLkj4Hr/j"
    "OifQxPSCUQczMBXnLMzPUygUsl3w6upqmpwN0NDIPAVDjUWvGxqJ0cB9EWpvisiRva1lZG71"
    "vXv3TD3DFDlYTuT3+20VGohGo9TZVk+NDcGS14bYJXN35mwvI/RidrmVKXIQj1g9xRuoqpLj"
    "DwR2eL4a8PvsnVuaPMS5peKjDSg7j42Qr9UoVn6tcN2UwYbubppktrq9rU0O6FaLQ7QIDwKK"
    "LVLkg57j4+PUbePyX61wHTn3338/HfngA3kYH2NWgUCgbHlhdBkDlyPnztFzzz7rtOgFsIQc"
    "q6PsZ595BkMgdOzYMYrGYmUTPshM2frOTjk/K2WwytS7ruVwbGdRNtL3GZUVn2WAVa3QdMup"
    "zPcXwiqzln3K6dOnJb3b/BAB6x0hgHfUxez8li1bil7zuze/oKszMQoG/GVfjenziNRZH6Df"
    "vvxo0WvOnj1L10dH5fhKK1Dqqelpam5u1nwP3wbJnCKBP4Ow7W5gYIDWtbfr8o4wuAdy9LSc"
    "OAvMxpmHNDw8TD94+umC33/9189ocGsvdXa0UjjooZDPQ1U+gQIs7vEyI+xFbOKBPRZID28o"
    "okgSpZj3nZLSnzHmit9ZiNHvX/uCHtpSr0rQhx99REZ0g0rF9WNENweee07wmd3mp9ekQUDE"
    "Mh5W+DNnztDWrVtzfl9IEj390Ca6siBRiMWYQZb8HharMEIYR/J9HiHdWeppUygloiIRJLEy"
    "J9mnl30RYh7bL3+ylw59/lXBPSjfAzt22LYFUqkb8OJxYpsfIG/1u3495zuMf3kzzcHOXizC"
    "lJJIFeaI8jmmG8aLz4ltfgDyjLMYRtnynHYs8vNH+ZzSjcyLo9pYBTBBkuKTKLc16aVR7V7+"
    "fLfCMXJkF5xya6uUSegX5I6bWTjRw/uJdB/D+xk5QNPtEKw8S5kkRZly7nFQN4ApcszEOKu5"
    "yFBiEuR40iSJQlqJnsxvQuZTTwTNSZA/FcSkpNKtx6iMZs10lhwjD5IM3ldUgMzf8KbizM1N"
    "sH99EnOdQYzEGwquSXtseqq20lNLZUiBxyayL8UMPWqymKmARvXDK66PF8DI3IPE7tFaeMzP"
    "8GuRuVrL4aYua9bEXLMmtxp2m8BbgU6zpmraKNe0qZWJ64aXu5SuuGxSZuGiXmL4/R5eACPQ"
    "Q8z1m3GKxj2a7oOy4kymRKZ2pxTmhys0Jan3H8WS2v3Z1lNCRg6UH3KUWtHK5TNkjRT3+fK/"
    "0PUgKk0sJrTOXZ6jkyMJ2vvgGmprpJLuM5QWZcFokOkgIGBUQBF0ZrwCj85RHSVJIAR9WkJc"
    "+b5YWZSt/c69FB0/eY+Wl/3Uv7Gu5HpuI2ZNaVFM9Tm8jyh2r8/np6nb8/TlVzfJ42/IEVbK"
    "2Bk1oqCshCQyJQo5LcfL/k+bNkm3KyXmmbQU73vE9FCOqhwFLUCgxeUkk2ea1tR5qbmphpLJ"
    "VbaqmBwUzpo1I2m1BeKC4KHRsSl6/d2vKZ4UFeUtXeAcsyZmPDdOEuWZKK2Jcu9P8WdrMGti"
    "pm/lgDyQC/JBznzZlfoxolOel0dZAL2pWAEQ4c7M3KV//POLTE+crUi51+ZVDPlZlFYaq6AU"
    "Q8qYn4SoIIonSUfK3MOfwZ+ZYGwlU7kVp1j5svykf5Dlg5yQV63SGtGrsgWb6nNEFW8Nfcz5"
    "i1fpzbeOUlV2TZmU4aewdhSaEqJ7rMl8PBqjDREvtYY91FAlUK1foGqfIA+EBjIDoeiLtHQ9"
    "Eq20lDhrRlFGxiJrMsgnzr6fn1yULyrW56ysMlqRg1e2P/75Lfrpj56ijRvW5/RBfPWQXr3i"
    "Hr6qSCYHQ9VxA2ussFFqcXGxoADdne30m5+/TH/5+2cFNQNzIlwI/j+HXAYpXaNn2Z9rWMuJ"
    "sFTlw8h0mgywwYdd9JKTENMtEeQss7SUSpvPWMau5c/X8PKhXBgxFsVQgTyQs76uOmcBIYgE"
    "OdAPkh6AGO4NyuQY3Umm3OOixPz8PDU1NtCrP36M/vXhdwUCF6tR3JRAiXOsn11kaYmREwZB"
    "njRBntTKyIBogJx4SkFQcsVMSkU8DL5XSC1egXxNjXU0OzubIw/fLWdUrwVmzRA5qxQcE02Y"
    "MHvlpd105PMbWc8O12M9mtImKxUBNSXZ9/dYlV5ICDI5yymBQilBNmdeeT4H5jFt2rSSI/cz"
    "8sgDI4cxhbTMUoI9N5GTf66S8B3Kmx2dZt/5WcYvMbngrU1O3iqoaNnFihn96AUvh4//Y+gh"
    "RVoOx82b4/LO6L0Ptslxjhyh57UctXuz3prSAVB6XoqRA63kZO9TxDvcQRAVDkE+eOVLl5mo"
    "OuSlnTvb2Kcgy6cGHquIBlqOMsA1F4QqvJNiQJNvX1tLS7EQRZhAsaVETpxT2HKcQ0H+Cvmw"
    "ADESFqi/J8TkEWW5ioEPwRjRa4ErXW5ghrO3Q2TETGXPF1B3VZ2fbMt3pTlQbpQfcti1Y8GW"
    "pVFo2nNzc0Xvz/5ti8iry7KafHq8WisqmuMzoWpTBnYjHYk7P02eD0fIySpBZWxN1KEfDH76"
    "MytyVs2P0hN3PuZ7C6n0fJC8AgdzOX6JZlJRCvhUDotwmCzHW45RgJgwU2hjFXMyoqVNjTy2"
    "5mGEsM84oyvKUrOXfS4t0emh07S1w/5NYKUgk+PEGZeqawjY31qnAtBimoIC/eGNo6u6q/zx"
    "xUSs8hJtbvPQU1vWuGYNAYevKhAouZPMSih3k6ltWYR+sHiwjv0U8aN1EIV8aSUGPOnk95K8"
    "CnRpYYnVLole+8VjqoEgAsfjx4/Lm3Y3b96c8zvkRf5vv/MO9WzYQJ3r1xeUBb87pRvw4utm"
    "BcPxVNg7D3dRT6cI4ZH0FByZ47wybFpa29RU8PtyLE5hIUX71geoiZkstI5axkgEJHkFCmRW"
    "gGIQ9OvhcVpTlZKfp7a+bJGZLOxa27dvn+pxYpAbY2JNKuUAUD6tu+zylcx1o2fdW85Ou+7u"
    "dIB9+P33pc39/bp3kmGhdkN9va4oGEJO3LpFI2fP0p49ewp+/9vn39K3k0kKBkrv96xj5D3a"
    "lqSpiTHVMqDmQ1iM9amhvq6OOru6qHfjxqJTz9jAhVbX0tKiWTecnJk7d+Rz3LQCjQPHB2Dh"
    "/PMHDqxY4uHhYWn0xg1dK+mxy0AmR0fLwaF4jaxG9m3apPr72NiYXECfhs24wVBIVj7G8dRa"
    "L57hZwotNjIcqa6mZqb0tUVaDseFixdp5vZtims8oC9LzsyMrl0GkAXmdWBgYGWXgVHg2MVH"
    "9u7VPSyuBVoUEXBgm70WgJja2lo6+umn9OILLxjWsWtdabcq3k5Uth26GK5tOZcuXaJp2Pky"
    "vnQIHTz6m97eXqfFVYUryTnGYhMcKjc4OFjWcwj4TjLkt+fhh50WuwCuI+ci84xwqq4du8mU"
    "O8mQ76YiHqRTcF2fA1Nm9+F62L2GfN0GUy2HL0638k0aCMS0nEQVjUm0GC2dZ4gFquHg6t4s"
    "8rPykHGuD7OnBJsiB+M/iPidwOhElIbOzNP8YvHRiZpqL22/L0Jbe8O2lYsviwLZVSb7S1Pk"
    "RGpq5AAUka2dJ6gDfd0hIjFOn/73RtFrHtm1nvp6ShNj9SQbyMF6PgSiZmCKHByJf3dujtZV"
    "V1tOjhaF9fXUkc+bpEMfDxf89uL+AerpqtP0HCunTEBMdlxNx9CN6rPM3Nzf3y/gDR8ojJUC"
    "6ln03dPVSK++NEjL87eyCf/jey0Lya0EH1ODF4iRZejHzPNMe2stra3y6DQKZBVBepQGAtY0"
    "ROiVHz5C0aUZ+RP/a53GsIogPhcjE8NiJ4xim4VpcvB6ksuXL8sFQ7KSIK0JWXZ3ttGvfvai"
    "/In/9W69sIIceH3QwYXz5y15bYslQSgOGhoZGZHnPRB1m315g5E9qri+taVJt/doNgzgCwj5"
    "3NG3w8PUyfRhBSwJQvHeGBwnjFOn+KykU+sS7LiHg5syyBwOh/GWLfnIYqveo2PZCAHeGwNP"
    "BbN4qEGcJHxXbPd0Mdj1ehYj6wK4LLx/wbnakBUtBgsgrHx/jqVjaygY3jyFgcS+vj7Z1YaZ"
    "4fPvWk+ztbvV8TxLzffzABPE4FqYMqyFOM/6GJgyV795CuAFPHHihHTxwgV5XQLOHIMgWoIy"
    "3trsAlc4n70sdS3WIyDwxhT9xMSELN/+/fvLUpvKXkWVbzucvXu35PUQ+sknnrD9hXo49E5L"
    "0Njw//62QyX0CoB1CViqFCvjkcVKgBx05iDGzHx/OeC6+RzA6GYuI6i8m1onjHpSRvOqkKMD"
    "Rg9KMoIKOTph5y43txIDuG6auoIVVMhxMSrkuBgVclyMCjkuhivJcWK6wY1wHTnKbZDlRv42"
    "P7fBdXGOmW2QepG/zc9tcKX9MLoNUi/yt/k5LXc+XFcgDiPbIPUif5uf2/A/9n+1U7cLqMYA"
    "AAAASUVORK5CYII=")

#----------------------------------------------------------------------
aero_dock_pane_left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAYAAABQif3yAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzoyMTozMiArMDEwMExUiZ4AAAAHdElNRQfZAxkQKBW/8myz"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAD+tJREFUeNrtXWlsVNcV"
    "Pm8Wz9iewTYYbxhjjDFmM4SloKwkipI0QiIhIU2VSlV+VVGrqlX6p5XaRpXa/kilVmqriD/N"
    "IqWtQkjSJA2ozdJUQJMGEwwYAwZjDLaxjbHB23iW93q/O3PtWT1vmzevynzS9fO8eXOX893l"
    "nHOXJ5ENMT09rfT09FBvby/NBAI5S6fY66XGxkZatGjRnoaGhnfzXW7bY2pqSnnr7beVSz09"
    "SiAQUGRZzllA/EgH6fX19T2d77InQ8p3BpJx6vRpxe/z0YoVKyxL88qVKzQxOUltGzfaSh6O"
    "fGcgGb2XL9OyZcssTbO+vp6nazfYjpzZYJBcLpelaSI9pGs32I6cAuZRIIdBUZR8ZyEtCuTY"
    "GNZ27hpgVW2WJFspaAmwJTkgxsquxq4EfeXJQTpOpzPfRU6Lrzw5aDV2VQhsSQ5gV4FZCVuS"
    "Y/WYY9eKUCDHxsg5Od0XLyrXBwdpdnaWxsfHKZvIh4eHeYhEIpYIQHI4yO1y8TQPvPnmgtmD"
    "TldeXk4ej4dqamtpdXNzTtW8nJCzf//+1q3btnWNsAKHgkFau24dFbnd5PP5sv724MGDVFZW"
    "RqFQKJflngM0Na/XS1VLl9ITe/dmfX5ycpLnbWhoiA4dOqQsraqibVu35oQk08k5deqUcvXa"
    "NaqprqYtd9yhKw50aVa1HJGeWogKVlFRQa2trTQwMEB//+ADZXl9PbW1tZlKkqnknDhxQpmZ"
    "maGHH3qIHA79niEQY1m3ZlCVrquro5qaGmpvb+fl37Jli2kEmeZb+/LLL5XikhLavn27IWIA"
    "CEuWZUsCKoFR5QPlRblRfsjBLJmaQg5mL8PhMK1paTElU0JoWgPGD62/MVMzRPkhB8jDjPhM"
    "IaefjTGbN282pYB6gdnTYEjWPItqtsoOOUAeZsAwOcfb25WNGzfm1T9VU1NLvX2D9If9B/gV"
    "n/MFyAHygFyMxmWYnJGRET4o5gvQmm6OTdKrf/mUvCWV/IrPuJ8vQB6Qi1EYIufcuXPKqqam"
    "vAkBBAzdCNArb7RTib96LuAz7ueTIMgF8jEShyFyrjNDbCkz3vIBv99P/UNhev9fg+T1VaUE"
    "3Mf3eC4fqGRygdfBCAzZOZMTE1RcXGx5wUtLS2lorIjauybIW7wk43PtXbO0aY2P6ip93LK3"
    "NI9Mrb59+7ahOAyRg+VEbrfb0kIDgUCAGmrLaUmFN+uzxeyRWzdvWZ5HyMXocitD5MAeMXuK"
    "t8jj4fYHDDvEnw74fuzmdVUa4q3pzN4G5F3YRkjXbGTKv1rYbspgZWMjDbG+uq62lht0C9kh"
    "agoPAjItUhROz/7+fmq0cPmvWtiOnA0bNtDb77zD3fjwWRUVFeUsLXiX4bjsOneOHn/ssXwX"
    "PQWmkGO2lf3Ynj1wgdCRI0coMDubs8J7WVe2vKGBp2dmGczq6m3XcgTamJWN8FVGYcVnDmBW"
    "KzTccgrz/akwq1vjsQwODv68u+fyC691hmlg0pj6lw21pRJ9a52T7t65I/dSMglnz56lK319"
    "3L5SCwh2eGSEqqqqVP9GbINkShHnRWJWrPKNP50mpfVOum+nQqtKJILN72VfQ0+CJeGSov2f"
    "lj4QFMO6CLNGBVMsyK4z7Hp5RqF/fiaRo+sY/e27X0v5HTSo02fOcMchVN1cL5WFmr1k8WKu"
    "JabDu++9R5s2baJldXWaNEfkG2XQ4t4KMqO1n2mPHR0dtPfxxyXpkyPHlBdv7qBf3qeQj/Ht"
    "dMTI4EGKXkWCGgqtiMD+RBSQpVBYjt4LsUh/+LFCzy86RvfeuTPhd0eOHqXKykpqXrXK8Iyq"
    "GqAydHd38/+TCers7MRmXl1bIPWQIyC2QTpePh2i+nskKpKjtT3XiLBEXOzP2l0SvXo2MUX4"
    "v7AGYf26dXz5EVwguQ4lJSW0evVqGrlxIyWvvUxIVm+BBMQ2SMcN1s1Usz7MyiEdaVV5JELa"
    "QqEQIR/r/dFCIzFvRHwIMhvL6i2QgNgGWVClbQxeLVCT5bgrQnwNVmKftbYuJUMA5Ng/8Wp4"
    "vhXyZJMgX/kR+eDkwH+IsSDCGHBi7HFElQA5lkMoBYqkQyFQoiQosTTwPzQ4KUupefdmow1N"
    "eu04o/ZflBwlLkhR4c0N1bEmo1VUijLfUuRYfPwai1iZe05J/JFJBTNLmEaMbEVnOUTF5ORE"
    "WAQhFhxytMVIjmgrigor2mQkjQTNdZNKNP5ip0RT7Aq7x0EKpfP2i4IYnQfRKoiFBCgWOIpn"
    "EbLlTwhXiS1c1Jof8XtHVBhxLScmUEWOq+1K4nikJvCWEwtlbqbzX52hSsytSFHDNJM89NY2"
    "vRBpKVm+BwJBB10ZCGa1v+I1Pj35SRhzImHiBqIzNuYgbUloAHo0AZrv1sqLJOrqHKaPPp+l"
    "J79eS0WLnRRgbMtxmVlIIFZioW4Ntfnm7QgdPXGb2WJual1VlnU9t56KFj/Wxro1oqAcHfjh"
    "rpn7OqYI8CtpVAjYDxpKJerrH6MDH/SQ01PN76MShCJxY0+accZqcjKmm9ICWNc8E6ZPPx+h"
    "xWVOqqr0UzgcWihiQ2VxCIGFWW2OsL4sjO0XGBPmujmFjxmyhoAM1Xki1HXhKr3wm8PMoJqv"
    "YTJLI6LMq9LpgH462SDMdViIOJEfgSAT2CtvfEF914ZZTXekLI4XceopR3xanBwIKyRHSYpQ"
    "TLVW5v+PH3vUhMUeBw0MjtDPfvV6quApNubEtZz4jMULxIqQTERCSLknHoy2ipdf/5BGR8e5"
    "RZ9cDiFkPflJIAfdDLo1BJAUUkRrigoyIshSEbxs4Dp78iQ994Nfp62JiB8NKZKGnHy0nPia"
    "mq41JT6jULz6gFu//eOf6Xz35TktLpkYPfkR4GPOayMKLQmEqMIjURkbwH1MpYLq62EDkJt7"
    "qSWuLDhUDjot6zfRS7/7MT3/01dTvuu5LdOVSZneY/WigShhjgQuc2QQnmKr1GloXkgP6SbP"
    "1yAPuId8YbpAlotTavr3n3uaystKExYQgijECycughZgmkRog1GFgI1pE0xjK2Kf3JGo1ibF"
    "lAHepUmkiZyu8QjdW7uUfvGTZ+jFl44kfDfLIpwOzysE8RC1B1qQVeRkG7DFXqF0+Xn2mQep"
    "ckkZjY2NJcQjbCe9O/QSVGli5EwxgRWz4GWkFcXI4FzgOUeUILXkQH/5x3WiR1uW0ws/eoR+"
    "/9r5ue/Qpc3ENDZR+HhBxAvECmTqUsR3uIf1c3PeaXbP7XLQU09t59ra0ND1FILnFivqLIfI"
    "R4ycCCNHptKIgwIsriIn7B2FT7YJPlwayAEw/rxxOUQbFpfRvkebuJ3DyWHxTrO0QmlU6bnf"
    "WrgnNJmMdHmZH0eISoudtGVLLbtKNDDQnzYeYavIOsoRb+BGyZFTFQA55gCN9xxogRxTEL4Y"
    "CdP6+iW0IzBB5T4HjYxH5hyt/Lk0Lcfqg4mS04/7cq71YFzylUjU2lRMdUtl3pVlgnDB6ClH"
    "iiqda3SOyVTc5KcDw2EamF5Yfc0n0qnSAiBndnqYmutly3YsWDLNN8Oa0H8YMbdCC7tqlOgN"
    "SwqeDtm80tDagip3DphR0fK+4jPTlEHe82ID2IqcvAonXbeaZ7LyTk4ytIhDDLxGZk2h8oaY"
    "qmzH0wqj5DisXTSNtIQo9LYcYUvAcocdohdhpupinZh/0SLbrCEQcFUyfb2UKVD+IoclBHlY"
    "dfC7HTTBSl5RlKqgq20DIAdr244eO5a5+4mbtXSka10xdbeMEdOUZlc41rVl22VnJuJ32nlY"
    "pXM9u9FNn5x0Uv097AYzTvyuqG+thAVvzLfm1uhbA2DjhGPebm+EeFweV3R9nJ9VCP8nRHvq"
    "pzJmMltXBYHhDDdcH7j//oxW+pkzZ/jCwYaGhpTfw+r/6OOPqbY2/aESSysrVe+yS04bcYug"
    "Fgk77RobydW2ds2H67/47MG/du6klTsUWsMMrXLGhJ+Rwv4ljxR157glbV0fJ4ZdZ5Wou2aS"
    "XW8zknrYjdP/JWq99Rltf6At4TfIGPp/CC7bumQ8gxWZKDxqeLoxAxuvbty4QTt37ky76xuG"
    "5PT0NG+B6YCVoNjAhV121dXVqtdKC3KCzDbCcl614DvtBgf5Trsn9u6NVs+bDMdPn6346zmZ"
    "rk/ltvlWemR6dNk0rd+8kcrSNMVr167x8w1cKgZoLxM4CMWa5HTdDuJwM4Fm8gz7Skupigkd"
    "LWQhXOjuplFGclDlAX2CnNHRUU27DFCWhuXLsXA+usvAiKBx7OKu++7T7BZXAzWCKMrDNns1"
    "ADFoMYcOH6Z9Tz6pW8a2U6UF7Cp4K1FYK21j2LblXLx4kW/LUOvL0gMM8Bhvmpub813ctLAl"
    "OdhAhUPltm7dmtNzCMROMqR391135bvYKbAdOdhlhlN1rXihHojHiSEwUJEuVGc7wXZjDroy"
    "qw/Xw+61dDvb8g1DLQeGoFiqapZHGYaYmpOoAsyYnQpkT7OYWdEl3oW1WaRn5iHjQh5G97Qa"
    "Isdj0OloBH2DAWrvnKCJqcxz9P5SJ7Wt8dH65hLL8iWWRYFsj8Hx0hA5Pr+fG6CwbK1ekNHS"
    "WEwkB+nwv69mfGbXtuXU0pSdGLPnkUDO1NSUJtdNOhgiB0fij9+6RctKS00nR43AWprKyOUM"
    "04H3O1K+27d7EzWtKFMVj5m76IRDdfTmTU2um7RxGflxa2urhDd8IDNmFlDL0tWmFUvo2ae2"
    "0szE9bmAz7ivZjmsmRA+NWiB8CxDPkbiM6ytVdfU8GNEkCGzCNIiNBCwuMJH3/7mLgpMj/Ir"
    "PqudfzGLoPjJP9hO8GIbhWFy8HqSS5cu8YyZeRyKlsXfSLKxoZa+9519/MqXEpu0BUQLOWLq"
    "4sL586a8tsUUI3RFQwN1dXXR2rVrudVt9OUN6ZbGZgOer6mu1Kw9GjUDxMQgiIFidLKjI2Vi"
    "Ty9MMULx3hgcJ9zb28snrsweg9RC7x5MvRBdGcqM2dbuixf5kcVmvUfHNA8B3hsDTQXHX6EG"
    "CZJwT+sKGas2TulZFyDKIsYXzLCirGgxWMtg5vtzTPWtIWN48xQciS0tLVzVRjcj5t/VnmZr"
    "dasTaWab7xcGJogR0+M4wPU8G2PQldn6zVOAyODx48eV7gsX+Am3ONYKBVFjlInWZhWEwMXs"
    "ZbZnJyYmuOGNo/AHBwd5+Xbv3p2T2pTzKhr/tsOx8fGsz6PQjzz8sOUv1MOhd2qMxor/97cd"
    "xkNrAbAuAYfhzebwyOJ4gBwM5iDGyHx/LmC7+RzAyp1thXdTa4ReTUpvWgVyNECPEaoXBXI0"
    "Il/bDu0G201TFzCPAjk2RoEcG6NAjo1RIMfGsCU5djoZN5+wHTlYTiS2+uUaydv87Abb2TmN"
    "K1fS0NAQX/UpjtrKFZK3+dkNtuw/Dr71lrK2tdWSF+phFx0mCLHNL9/lTobtMiTQ0dGh9F29"
    "qumFQlqRvM3PbvgfnhklmOdyrPoAAAAASUVORK5CYII=")

#----------------------------------------------------------------------
aero_dock_pane_right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAYAAABQif3yAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzoyMTozMiArMDEwMExUiZ4AAAAHdElNRQfZAxkQJBxqm5sb"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAD6VJREFUeNrtXVlsVNcZ"
    "/mc89oztGWyDd8xgjDEGgx02BSVEkKRK8kCWkkWpIjVKX6pIbdVK6UP7UFWV2r60ah8aRbw0"
    "SdUsDSFEJAW60SQCSlIMMXYwqwEb23gBY7zNfnu+O3PG1zN3PHebe2+V+dBhPHfuPcv/nfOf"
    "/z/bdZANMTs7K/T19dG1a9doLhDIWTrFHg81NjbSkiVLnvT7/QetLrftMTMzI3xw4IBwpa9P"
    "CAQCQiwWy1lA/EgH6fX39z9vddlT4bA6A6k4290t+LxeWrlypWlpXr9+naamp6l940ZbycNp"
    "dQZSce3qVVq+fLmpaTY0NIjp2g22IycYCpHL5TI1TaSHdO0G25GTxzzy5DAIgmB1FmSRJ8fG"
    "MFe5q4BZtdnhsJWBtgC2JAfEmKlq7ErQ154cpFNQUGB1kWXxtScHrcauBoEtyQHsKjAzYUty"
    "zO5z7FoR8uTYGDkn59Lly8LN4WEKBoN0584dyiby0dFRMUSjUVME4HA6qdDlEtPc9/77i2YP"
    "Nl15eTm53W6qraujNc3NOTXzckLO3r17W7ds3do7xgocDoVo3fr1VFRYSF6vN+uz+/fvp7Ky"
    "MgqHw7ksdxKw1DweD1VXVdHTe/ZkvX96elrM28jICB0+fFioqq6mrVu25IQkw8k5e/asMHDj"
    "BtXW1NDmTZs0xQGVZlbL4ekpBa9gFRUV1NraSkNDQ/TXQ4eEFQ0N1N7ebihJhpJz+vRpYW5u"
    "jh595BFyOrWPDIEY09SaTlO6vr6eamtrqbOzUyz/5s2bDSPIsLG1M2fOCMUlJbRt2zZdxAAQ"
    "ViwWMyWgEug1PlBelBvlhxyMkqkh5GD2MhKJ0NqWFkMyxYWmNqD/UPuMkZYhyg85QB5GxGcI"
    "OYOsj7nnnnsMKaBWYPY0FI6pnkU12mSHHCAPI6CbnFOdncLGjRstHZ+qra2ja/3D9Ie9+8RP"
    "fLcKkAPkAbnojUs3OWNjY2KnaBVgNd2emKY33/mUPCWV4ie+47pVgDwgF73QRc758+eF1U1N"
    "lgkBBIyMB+iN9zqpxFeTDPiO61YSBLlAPnri0EXOTeaIVTHnzQr4fD4aHInQx58Mk8dbnRZw"
    "Hb/jPitQyeSCUQc90OXnTE9NUXFxsekFLy0tpZGJIursnSJP8bKM93X2BqljrZfqK72iZ29q"
    "HplZfffuXV1x6CIHy4kKCwtNLTQQCATIX1dOyyo8We8tZrdM3p40PY+Qi97lVrrIgT9i9BRv"
    "kdst+h9w7BC/HPD7xO2biizEydnMow3IO/eNkK7RyJR/pbDdlMGqxkYaYbq6vq5OdOgW80OU"
    "FB4EZFqkyAc9BwcHqdHE5b9KYTtyNmzYQAc+/FAcxseYVVFRUc7SwugyBi57z5+nbz71lNVF"
    "T4Mh5BjtZT/15JMYAqFjx45RIBjMWeE9TJWt8PvF9Iwsg1Gq3nYth6OdedkIX2fkV3zmAEa1"
    "Qt0tJz/fnw6j1Foylp6eHkHtNj94wGpHCGAdrWR6fv369SaJSj+Onfyc/nwuSsMzua2E9V4n"
    "fbvNRZvaN4ozriI52HbX0dFBy+vrVVlHGNwDOWpaTog5ZoPMQurq6qInHn887XdYUN09PWLc"
    "MHVzvVQWZvaypUtFK1EOT7z6BQmt99HO7QKtLnEQxkM8LEuQErwslyPeN6jpH+AAwPOKMLHB"
    "TQ2xzzn2eXVOoH+cdJCz9wS9+52N5NCzzQ8CrKys1CQUbPXD8EZbW9uC68eOHxfjbF69WveM"
    "qhKgMly6dEn8O5Wgz06cpN9O3ke/3CkQ6nGBM0GGGBzxz8S9aqqQwAP7LyqALIEisfi1MIv0"
    "R0cF+nHF5+S0YpsfIG71YwRJgfEvrEFoYyoPy48wBJLrUFJSQmvWrKGx8fG0PL55LkYNDzio"
    "KBav7blGlCXiYv+t2+Wg17vD5LRimx+ANEPMh+EGBQ9WrPdHC40mRiOkYZypmRqmw8w0d5BW"
    "tdshpp03pW0My5xQsXbSQp/AaoNczrDBlZjkE8GR8rtDQ96FDAGIJf7QRY4eH2cxK0xUbzbZ"
    "0ISxVfQFUZadAvQ9zrgRIPZBQtw4EBwaDAIhToKQSAN/w4JzSMSZJEeLkAWNzy2IQ/q8tBVZ"
    "4NjKpRkTJMERF17SOEg0GbXVSBDmW0osEZ/4mYiY58LFM6Vl7kFgzyhtPeh0k50+axVyLYPH"
    "o3ceRA2yrfiMst/CLDhZltysyZQwW3oO9q+QUGgJwtQQlFSTQjz+aMKkht/DpJQkySkVilqo"
    "Ieb6UIgCIWfW54xojWrLwNOVFWRC5cC/qWY6bHxgjsoLHfO1XVjYHykJgpAeeFwRYV6BJMnR"
    "FBQ8C2LOX5mk46fv0u270QUCSU1b7poZIVO6QDRCooNYVOCgm7eidPDoLbp4bowqipwLCNIT"
    "opLACQR09Tmc4kzPulyFNDo+RZ9+PkTOwop0MmSEozkvOrBYuhBYKBYnCMM1k9MR2ndokL5f"
    "WUgrl1dQ/4wQ78hVpCdtcYgXrQWf4Vg8njS1piUstkDc4XBS/41ReuO9/1IoMt+HKFGFMUlf"
    "ZnbrSYUoPCbJmGSMIBiK0s9/c4R6Lw5QvTu+3jqmMuAf+hve+vB3RIjFW0+qWtOyQp8/l1pQ"
    "eP+3bt2h19/657xpQly/ZlaL3BAwc5dBagtKU2tCvEZHZWyUn/3qLRoaHqOlzFJQo8aSVlqK"
    "SuNGgWBUy0kVJKyfC5eu0u9efVtiGQvEu13pc6lpW9FyMuWFXwtHE2otQ+N6+Ye/pt4vvyQP"
    "65OiMsKWC0lVxtVZQnWGovHAK4LY52AYP6RhjRUGKWdmZtLUQqO/nn7w8vP02h//llZTseaM"
    "L1Xi3zmQB8SFkWKzzGkYLEgP6QZk5rL+NCbQskCYCdFFHc70nuW13/+EXJW1dHFS+WYvTlKY"
    "NZ0gK2aAfZlhhsdkSCDGMX3E2oyfk6N1J5l0j4sUU1NTVLmsgl564Rv0l4PdC36TqsRU8BqL"
    "OM0iJ1v/Fw2z8jDBBZCdlJHIX/z0Baqvq6JPRqOqhm+4+gqLxMTDLEtjJhonJCZtOVr3YEYT"
    "m5zkBIm5Hn9DLb343DY68PeBpGWH+7EeTaoSOfjffPOUGZDr8xaAkYNaHYxS0rZ1FxXQK688"
    "Rn5mrX08EBGvOVWYa5wcUZXF4nGLJLGoMGcUjkrI0SqMWIaWwzE0NCjujN55bx2d7g3Hna2U"
    "liNrvpq4J1QK2XIwSc2wjiEUi48IlHld9PDDTTTlLaN3+kLkYqzwCTil4EYG4kQfE2QXoNow"
    "8uBMmNRAsuVoGltbrMYlMDExQfVVS2g2WEzeYgcFZ8ML/By5lmPmopFUQyQNCR9nbE6g8ion"
    "3dvhI1ruo5OjEXE4xykda1OITA4o0gHRUam1lmtghrO5IcaIGU2eL5BphMFKLJaXG7Mxevtm"
    "hIpW+ah7wpxWbcrSKKioycnJjM8n/45fMKXg2fIih5tzMTo2IhDTbFTsyv2UhuUrPjNNGVie"
    "FxvAEnKSQsgwtmYJbKBWU2F5y0mFGvHweSE9s6ZYGxdmpr0dTyt08UKaDdk1BCpqLt/4hEWQ"
    "8Ju0IsL6Q6yh8y1ZIp++09wF5UiLVxOXmxUu204yIyHdTSa3ZVFpNUE8WNt2/MSJzH0Vu4eX"
    "ySlXAROzoGWMmCaZXeEVRTEqZY/7ipymEORmTcVX6KQpVpxK5na4GletEo+nwt55PsakFBh9"
    "RlBDKoiBULFpqSrDalElqgqVCWe44fOhBx9MyzevBD09PeLCQb/fn/Y88v6vo0eprk7+UIk9"
    "K2bos54CanggSm7mlPiYheZlAVPVHla9mRypEOlocEL58I2HWeWIy+2Kr4/zMVJ8/yZxzbQL"
    "b77Y/8EHgkvDTjJsbFrCap0abx4qaGh4mHp7e2nHjh0LfsMid+h/CC5bPnAPVowi32iBcn0G"
    "8jc+Pk7bt2+X3fUNB3l2dlasLHLYtqmD2vpO0rtfbadV9wq0tsRB5YwJH9YSMDLcWDPtAEHq"
    "VJ9IDPsMYo00I2iafWKSuI9d6P6CqHXyJG3t2DCvRbq6uoT+gQHZkdlMwC6DivJycYxNKXAo"
    "3jLWYlrWrJH9/caNG+L5Bi4FHbSHCRyEYhxPrvUijkJGMkbP5eAtLaXqmpqMLRhAi/zPmW46"
    "NFhC48HcKrfaUic93+qkbe1t4omIuiwBHLu4a+fOjIXXg5CCkwqLLNhmrwRozdAoh48coWef"
    "eUazjG1nSnPYVfBmIr9W2sawbcu5fPmyuC1DywytUsDoQH/T3NxsdXFlYUtysIEKh8pt2bIl"
    "p+cQ8F12SG/H/fdbXew02I4c7DLDqbpmvFAPxOPEEDioSHdNBgvSKtiuz4EqM/twPezsk9vZ"
    "ZjV0tRy+ON3IN2lglELJSVQB5rDNBLKnWcw8xRLP4tYs0jPykHEuD717WnWR49Y56KgH/cMB"
    "6vxqiqZmMo9O+EoLqH2tl9qaS0zLF4jhy63cOvtLXeR4fT7RAYWXbvaCjJbGYqJYiI58NpDx"
    "nl1bV1BLU3ZijJ7HATlYzwdHVA90kYMj8e9MTtLy0lLDyVEisJamMnIVRGjfx11pvz27u4Oa"
    "VpYpisfIKRM+oHrr9m2qrq7WF5eeh1tbWx14wwcyY2QB1SylbVq5jF56bgvNTd1MBnzHdSXL"
    "eo0EP9sNViDOcIN89MSn21qrqa2l0bExMUNGEaRGaCBgaYWXXvzWLgrM3hI/8V3pNIZRBEkn"
    "/+A71TCtohe6ycHrSa5cuSJmzMjjUNQsRkeSjf46+t53nxU/8d2oLSBqyOFTFxcvXDDktS2G"
    "OKE4aAjzM+vWrRO9br0vb8i2UFEOuL+2plK19ajXDeATgyAGhtGXXV1pE3taYYgTivfG4Dhh"
    "nDqFiSuj+yCl0LpqVSu4KkOZMdt66fJl8chio96jY9gIAd4bA0vl3LlzYg3iJOGa2hUyZm2c"
    "0rJmgpeF9y+YYUVZ0WKwlsHI9+cYOraGjOHNUxhIbGlpEU1tqBl+yq3S02zNbnU8zWxnAHEH"
    "E8Tw6XGshbjA+hioMlu/eQrgGTx16pRw6eJFcV0CzmRDQZQ4Zby1mQUucD57me1e7D2C440p"
    "+uHhYbF8u3fvzkltynkVlb7tcOLOnaz3o9CPPfqo6S/UO/jRR4qcxor/97cdSqG2AFiXgMPw"
    "gjk8slgKkIPOHMTome/PBWw3nwOYubMt/25qldBqSWlNK0+OCmhxQrUiT45KWLXt0G6w3TR1"
    "HvPIk2Nj5MmxMfLk2Bh5cmwMW5Jjl5NxrYbtyJFug8w1pFsg9S5jygVs5+fo2QapFgteqNfY"
    "aHXR02BL/YFtkOtaW015oR520WGC8Ok9e2wnC9tliEPLNki1QKvxr1hBHR0dtpTD/wDriTgZ"
    "SBhbDwAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_dock_pane_top = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAGcAAABlCAYAAABQif3yAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzoyMTozMiArMDEwMExUiZ4AAAAHdElNRQfZAxkQKSNpU8hr"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAEFhJREFUeNrtXWlsXNUV"
    "Pm8W22OPYzu24yXxEscxzk621kDaAGVTFVqxCoRaxJ9WlSr6j1+V2p+tVLX9U1URUlNVXdgK"
    "EhRCgYKgSShtFpw4qx3I6iReEie2x57tvZ7vzVz7eebNzNtm3kPyJ109+828e885313Oucsb"
    "iTyISCSiHDzyOf3peIKGp+SildMa9tH31wVoZXvbi21tbT9wW+9MSG4LkInp6Wnl8Rc/J2XN"
    "nXRfn0JdIYlCfL+MJS3ja4Cvfr76DOancEoi8R8Jvkb5OsvXKU6DEYU+/UQi3xcHaPdj7S8x"
    "QU+7rb8WAbcFyMR/j/STtKqPfnFHkqoUifxszYAPZPDfTIwkpWqUmVoFgtD+ZAVJoQSI4hvb"
    "JYUeu8dHL8z00dD5z57ir3iKHKMVsGTYcyxOnTskKkumjFpMgKRgUqa6h1Lleg2eI2dsRqGm"
    "ComKN9IsBMppDfnUcr0Gz5GziHl4bswBUJuVHAmQyFyXp+j8LcYhtbxSNVOT8GTLwcCtKGlC"
    "cE0bT0kzZLYDUpSFSc7436vwZMsBGXE2mo+vki/loamMpK+Skr5nEHKa0KQiPLa0ay0vbEFe"
    "gyfJgbsrswVlad6YPjajTCk/WnWlTdR4lQC1lShz+Qm3mtSy/G6rrAtvkiOn3Fw/SEmnpOZz"
    "lRwTLUd0ZSIYVVtNOikWuslSwZPkoLtJLqjhCwNPswOldvyaD0ZTZah5erRf8yQ5MFxc03Ik"
    "zXiDq3oxUd0XEJJulXE5lZBfwqNNx5PkJLj/iSdT82gQEC1lriuT0/9bcQjSLVJc0ULVLBdb"
    "jnGkxgSFr0gStyApVfPF6CCZdwiSmi5NzRctSE5l4lFuik/O4NCQcvXKFYpGozQxMVFw8N1z"
    "gY2WSNVqdezxpQyrOgWa6NNnsuVox5lk2jlIpLtM0XJefe21vOKhyNraWiovL6fmlhZa3d1d"
    "1Fn9opCze/fu3q3btp0cHRmheCxGa9aupbJgkMLhcMFn9/z2E3rpukJN3K8tLZeoOihRlV+i"
    "CvZ2y5iooC81O+03YRYxCx1jdqJ8neYbk3GiGzE45xL9jfPayd977NFHC+Y1NTVF8Xicrl27"
    "Rnv37lUaly2jbVu3FoUkx8k5evSocvHSJWpuaqItmzdbymOWW84UG66cI1AI6FfdLYkUf8rj"
    "MkOO6NJATpTJmeUmM8PkRNjjmI4paqwTjyeNZcYQFayuro56e3tpeHiY3n7nHaVtxQrauHGj"
    "oyQ5Ss7hw4eVmZkZevCBB8jnsz4zFOVaHWGCKlm6crYbNx61GxNdGRwF2SQ58MxinFc0nWaS"
    "qTJAdtI4N1lobW2l5uZmOnTokKr/li1bHCPIsbm1I0eOKKHKStq+fbstYlRwTZ7mqj7Do/Ys"
    "J9T4WDKV4rL5pD7LA4varaXzRIpwGRG+2iFHNSLrC72hP+zglE0dIefosWNKgkfx23p6nJEq"
    "keraoolUbVdTOi5BDyScBW2C9xXmJpaU9T9X3XNZ04I0ZZBNcgSgP+wAeziRnyPkXOYx5vbb"
    "b3dGwzRkTVIKJHR33+0I0IrpS+rVJxV+Rpu/k4AdYA8nYJucg4cOKRs2bCC/353JQzgG326V"
    "6PjJL+gnL/xaveJ/M96co/KwHWAP2MVuXrbJGR0dVQdFt7BxaYCuXJugn//yVaqsblWv+B/3"
    "3QLsAbvYhS1yTp06pazq6nLNCJvrAzR58Sr97FfvU3Vdx1zC/7iPz90C7AL72MnDFjlXORBr"
    "bGx0RfmeGj9dPzdOL77yBYVr27MS7uPz2/h7bvRwDWyXEQ7C7cBW1ZqanKRQKFRyxTurfRQd"
    "jtAHn82oXVku4PNvJqepu62KTtxIlFTGKnarb926ZSsPW+REYzEKBoPOa+bL36SvRhS6t6uK"
    "WpsqC2YVrpToo7HcvnKxNlHALrCPHdgiR+bATjIzd28ADSGJqhCzlPlyGm6Wg8qP2eAhA9LP"
    "jKema/RQwc9XBX1UnS7Xacg21yI8t2Tw3PoAfXTMT8u/wcbnCh8OSBxcEoXYNy73pyY+A+m5"
    "tYQB3bGVd0mZxMGnRBWyQuX8fNCnUJlfoUbmrIpJqd8r0fc2e84U3iNn51130LqDn9Kfj/fR"
    "mq8ptLrSR7VMSpjJCLGhy/mKjjRgYm4NDSfGCZs6p5nQCU7XufWdmeUAeh9Rr/wf+taOO9xW"
    "PQuOkKM4vPnr7ef76P1/H6CX35NpKFK8NeTVPB79tNdH9z9zp6M6ONXVe67lCNz/jTs5uS2F"
    "u/Dkjs+vOpxqhbZbDgRxulv7qsOpbm0ul4GBAeXcuXM0Mztr+GFEwGZnCCoqKqijvZ3Wrl1b"
    "IlPZx4kTJ+j8hQs0a8I2MOzI6CgtW7bM8DMhtk1nZyetX79eEnnQ62+8oWzatImWt7ZSWVmZ"
    "4cwwuQdyzLScGAdml4eHqb+/n77z8MNZn2N9/tjAgJo3ZnidjqMyEQgEqH7pUhhE9/M333qL"
    "rNgGcgv7WLHNo488IklYGKoOh6mjo8O0Yii8oaHBklHOnz+vTm+sW7duwf19+/ereXavWmV/"
    "RdUAUBkGBwfVvzMJOn78OC1ZssSSbayQo7XN5NQU+c59+SUtX7686EbIxIoVK+gcC6EFdrZg"
    "D8I67vKw/QhTIMVOlZWVtHr1ahodG8uSEfK5ZhvmJYD5HzTtUgNlxqLRBV0i/nZjBhktNJlI"
    "ZHXPkM8t24CXRVfaw3AtCFVdcFoYE7jtkGe2HLfkEXLYIsdOjJPPC1O7tyJ7aWb1LOVzAnPk"
    "WMlIsfhcTgUyxp9SQ69MOxXQqn1ExQwIAaysPSj8jFHhMeiK76JwvZYh8rG7DmLWEPnk19pG"
    "yF1IPqEb7GNWF61tfFqjmIUZYs4Px2g25iv4nBOt0awOotx8nwOQH3oUir+EfpZ6I81zgcwb"
    "pjKiwoZElH/q7E06fDJOO7++lFrqKct9zmeQUiJft4bafP1WkvYfvsWxWJB6V9VQssA+XisV"
    "Tduj2BpzxBiR69lAIEgjY5P08WfD5AvWLVBWSZ9k1iOq1OTkLDerBUg0PZNgfUZpaY2fljVU"
    "UyIRz5exLV3mujUrSU73qXpJknx04dII/fGV/1FMs55spJXKmrGsVCkfcUIeAegDvaAf9MzU"
    "XWsfKzYVZfm0AphNuQRAhDs+PkF7/vLBgrPkipJRETIqhhg8rcpjJWUSkU++OX7SR7OhH/SE"
    "vnqV1ooe2hZsu+VkCoA+8/Tgl/Sb3/1V4xkrJIbdzNqhV3tL2XJyyaK9N/+deT1EZYOe0Fd4"
    "cYUqrhF5BNQxB1PVMQt7rDBJOT09ndUtdLa30vM/eop+/4d/ZtUMrImIgVT8P9ddsAyKetIs"
    "XjJ3Gp4XykO5mes1Qj7IheUCWQ5l6QM9a2uqFmwgBFHIF/ZBMgM4UMIbVMmBsQp5HnoQz2WS"
    "Mzk5SQ31dfTcM/fRy28ey1I4sw8XELUHeZaKHCPjXy55oF9DfQ3duHFjQT4idrJq1yxX2hI5"
    "eQTHWkb7imZ69snt9MZ7F+c8O3wfB4y0TV9rCK1BSoFcXYr4DPcg79zsNN8LBnz0JOsFb+3a"
    "tatZBIMctICkRT2EHAE7xpBztByB4eHLVFNTw/FNixrnKEp2y9F71mqNs4tcsszLjE2Iftqy"
    "pUXdjAj99CBiFdmCHtoA114QmqPGaYEm39q4hCLREIVZoWgkviDO0Ws5pdw0kumIZHw4px/G"
    "Jey77u0KsT6yqlcuiCkYK3pkudLFBlY4u1fITMyIqqQwSrar6u6igZ4rLQC5IT/0gD6lQEm2"
    "RqFp37x5M+fzc3+nbpRE8UKy6Olnxqt1oqK5vuMz15KB67J4AK6QM2eEHHNrrkCvB3CZLNdb"
    "TibMmEMMvHZWTeHyxtlVdus0eD4EhJKlhtYh0N4zChFLIHJHHGIVCR4PsU+sesmSrPLd7uQC"
    "5awcBmz416WIyucCNC5T78ii0WqCfLC3bf+BA7m7H82qpU+vAqbd3RompkvnVDjkc8s24CXQ"
    "uXKl+noqnJ0Xc0xGgagZyYzgKBxGxduWGnPsFjXSVcFgeIcbrvfec0/OKH1gYEDdONje3p71"
    "PGT/14cfUktLi24ZkO/ayAi18ucJnX1t+YwsbGNm3xvkxV7yy5cvq3umAxs3bJD+/vrrCjLB"
    "24/M7AeeZeNgu6qZKBhKDl+5QidPnqQdO3Ys+AyCof+H4QrJge9gRybkRg3XGzMg39jYGPX1"
    "9eme+kYgGYlE1MqiB+wE3bdvHwW5jKamJsO2EeTEuLLDPkaBxqHa5tQpvPttvnr29/crFy5e"
    "NLWTHqcM6mpr1Tkko8BL8eq5Rvaw4nq4dOmS+n6DgIEBuoINDkIxj6fXepFHkA2aa2Y4XFVF"
    "y9jojQX2e58ZHKRxJjkWN/ZLIYKc8fFxU6cMoEt7Wxs2zs+fMrAKvHbx7p07TU+LG4ERQ5QV"
    "45i9AwAxaDF7332Xnnj8ccs29pwrLeBVw5cSi3ulPQzPtpyhoSH1WIaVFVqjwACP8aa7u9tt"
    "dXXhSXJwgAovldu6dasp79EsxEkylLfjrrvcVjsLniMHp8zwVl0rp8nMAsSv5HgCASrKXZ3D"
    "g3QLnhtz0JWV+uV6OL2md7LNbdhqOWJzeqHN4GaAQMzIm6hmowpNzxYuM1QuUWVFfm8W5cUN"
    "xjBGIOxh90yrLXLKbU462sGFK7N06PgkTU7nnp2orvLTxtvCtK678Ku/nILYFgWyy22Ol7bI"
    "CVdXqwEoIttSb8jo6QwRyTF695OLOb9z97Y26ukqTIzT60ggB/v5zEzd6MEWOXgl/sTNm7S8"
    "qspxcowYrKerhgL+BL36j/6sz57YtYm6OmoM5ePkkomYUB2/ft3U1I1uXnYe7u3tlfALHxDG"
    "SQXNbF3t6qin557cSjOTV+cS/sd9I9thnYSYU4MXiJll2MdOfra9tabmZvU1IhDIKYLMGA0E"
    "LK0L07NP302zkXH1iv+NLmM4RZB28Q+xE2ax7cI2Ofh5krNnz6qCOfk6FDObv1FkZ3sL/fiH"
    "T6hX/O/UERAz5IilizOnTzvysy2OBKF40RDWZ9asWaNG3fl2gRolxuzKI77f3NRg2nu0GwaI"
    "hUEQA8fo8/7+rIU9q3AkCMXvxlSxU4C3TmHhyukxyCis7lq1CtGVQWestg4ODamvLHbqd3Qc"
    "myHA78bAU8Hrr1CDBEm4Z3aHTKkOTlnZFyB0EeMLVlihK1oM9jI4+fs5js6tQTD88hQmEnt6"
    "elRXG92MWH83Ygy7W52sQJRZaL1fBJggRiyPYy/EaR5j0JV5+penACHgwYMHlcEzZ9R9CXit"
    "FRQxEpSJ1lYqCIOL1ctC38XZIwTeWKK/wmEE9Nu1a1dRalPRq6j21w5vTEwU/D6UfujBBx2d"
    "68oHseMFL70zEjTWfdV/7VALswpgXwJehgcySwGQg8EcxNhZ7y8GPLeeA5TyZJuTM+pOw7Pk"
    "lOpMaK7zqV6AJ8mxEoRaxSI5JuHWsUOvwXPL1IuYxyI5HsYiOR7GIjkexiI5HoYnyfHSm3Hd"
    "hOfI0R6DLDYyj/l5DZ6Lc+wcgzSLzGN+XoMn+w8cg1zT22v6GKRZgHycosMCIY75ua13Jjwn"
    "kICVY5BmkXnMz2v4P+EM9joepX/9AAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_down = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB8AAAAgCAYAAADqgqNBAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo1MTo0MyArMDEwMMndnrAAAAAHdElNRQfZAxkQNALaVrQp"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAhJJREFUeNrtl01v2kAQ"
    "ht81FgECjUQUyeKjBrfi0EOJktxzg0uOSaWe0lNP/Wk99lBy7A+oSiO1ORE+BChSTjGfBuPs"
    "rATCNSkmyHtpX2ll2czOs+OdWTMMXIPBwKnVaqjX6xiORghK0UgEuVwOhmEgFosx1u/3ncrV"
    "FYrFItKpFMLhcGBwy7LQ7nRQrVZRLpXAfl5fO4l4HLquBwb9U41GA2avB6V+e4t0Oi0NTMpk"
    "MiCuOuavQlXVtRNGFs+NobPWLhphiO783YZ4gut3tc3OEN9/9fDQt5+0ebEbwttCHG9eR335"
    "9A0v5LhDx0LlW+tJm6OTLAr59WDHcTaDiwXk96AqNj5/+eH57fzsEIa+t4k7KMur8TMMPYkP"
    "744xMO8Wg+7puZ/5HrhfMI3ZbIb9ZByX708xHt6LK93Tc78+XHu+alXrlNdT+PTxgpepBtu2"
    "fc8nu1AotB18Op1C0w7EdRMxxrwJtyn8uXOW9ezIt5ErctlwT+SUrTKkKIo7cvrUTSYTKXDK"
    "dEo6V+RULrLkipxeuSy4p9QILmvP5yfhAi4z4VbCZZXaMkfZws/W+g//R+Hz4046fIe3R3S6"
    "0YEftChIOtuJR1zRLvHiQ4r3afRxCbLeCRzhzWK73Rb/gNRXvGP8WqmILkLTtEAbRQqu0+3i"
    "980NyuUyxGabpila5GarhVGALTJF/TKbFS1yIpFgj6VqglrJraorAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_down_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB8AAAAgCAYAAADqgqNBAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo1NDo1OSArMDEwMEcuCiQAAAAHdElNRQfZAxkQNxVyqGIt"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAABENJREFUeNrtV02IHEUU"
    "/qq6529nFnezLtGNEEk0O5NZI4GoQaLxoCJ4NgjBgAe9K/5c9SToQbx6UaJgQLyJXgIRDUkk"
    "t+iS1YDgwSWHMGOyO7Mz0z/l97qqZ3vGnd0ZYb1oDY9XXT39vve+eu9VtwJHo9H4+ufrK8+f"
    "XQ6xuh5jt8ZCReNM3Ue9uvjl3NzcKUXgH06fvX7C1B7H08cNDpQUSvxjXlGofWqPWo8JYCiR"
    "CCchdZe6Q71OudE2uPy9gv7tEj57qXpeXbh4yXzQfAzvnTQoGwWPKL4WMM4JrERgZdwhDgh/"
    "sRExCMURLhjOu1rjrW8M3tz3I/QnPwW4/4RCPrIPjRpaWad2Er2Nl+JELoox+xwguP6tDYOD"
    "RYW4sz1wnjzeaW3nnh2VKQXDvYpH/FUYWShpLBPXH4fGPCNaudHC+ctNNG6HI/+35y4fTx6b"
    "wZGlaYTRznb91BszQmR0aKhWrUDo+fSrX0YaO/XsImqHp9HK+GcyOq2jOM6CG0kGByhabmo7"
    "ly1kHqJNg/X6PF7xAnz48Xd/A37t1adwqDqP9cAM2jIZ+0NbkVSQgAUuI6VE0lLpZ2xs9Z2e"
    "waHFBbz7xjNYa/7eF7mWdbkfG/QlGpqL/SDeZEDbyPlQbKx2YuhRMocTt367F+PevTN45+0X"
    "0F5bTbRcy3r/WQzZyNplJIO0x7YMPIp2ks2XpM4zJXQr9FCvHcBH77+OBw7ux83OYJmmVKcM"
    "JlE7SbekD57SnaUs21iGu5s8vLoBzNy3P9HDI7vnm83GYqg0w7MJF2QiV8YhO52oLep2Y0Q5"
    "DQA6VgO332IvNNnIaSSIbB/3XaR9qmN3PUF/jV3kUZrA8WbCqeFSs3tiqEXY043tUHG6O2rr"
    "yEcNM1QtiV1hwLW9NNtt5KH1Ktl7bR9Mki6lHtv37K0iz+5zWr6h29KByM81DPaS9z0Fhemc"
    "QpnHWdGzbTWn7enmTQCenmI9onepW1xYC4Amy1Hx9wVtnUzBO4x8nTcKSicLXpKuPCA8m7GT"
    "gKeUC3iX4NKaNwjeZka3erbWgyDajLwb2PY5xasC1xl8QnNKtSRiPCG4ZHaPtrpOpDIEQ4KJ"
    "ogztkuotulrmYpEbnReqo836NhOCJ22UKD2JPpLorbRDY50bAA8t9V1Kj1T3tHt9cm8xySEz"
    "IXjax/sMOIxkDIDDlQV2Pl7HAd9KUtvZMe574a6M/8H/q+D63/Mii+Pfzc+jMmugwka+2w4U"
    "WdjlnMY054Lrv/xQDheuedj3RIQSi7/C7lLJASV2mIJnDxb/H/T2gC2xyN5e4PM5HpF5vqnM"
    "c71M0LlvFc4c9eEfXTq8Ur96pfr58nHUHjV4cEpjhqAVgvHDgocNHYDteOOCy6nGMwT8KEGL"
    "rP5JadCjX/mu98dFoBpfwbGHl2z3bDab5uq1ZZxbiXGztXufyPeUNV6sajxypI7Z2Vn1F7X+"
    "m7ZM/KBNAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_down_focus_single = aero_down_focus

#----------------------------------------------------------------------
aero_down_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB8AAAAgCAYAAADqgqNBAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo1MTo0MyArMDEwMMndnrAAAAAHdElNRQfZAxkQNALaVrQp"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAhJJREFUeNrtl01v2kAQ"
    "ht81FgECjUQUyeKjBrfi0EOJktxzg0uOSaWe0lNP/Wk99lBy7A+oSiO1ORE+BChSTjGfBuPs"
    "rATCNSkmyHtpX2ll2czOs+OdWTMMXIPBwKnVaqjX6xiORghK0UgEuVwOhmEgFosx1u/3ncrV"
    "FYrFItKpFMLhcGBwy7LQ7nRQrVZRLpXAfl5fO4l4HLquBwb9U41GA2avB6V+e4t0Oi0NTMpk"
    "MiCuOuavQlXVtRNGFs+NobPWLhphiO783YZ4gut3tc3OEN9/9fDQt5+0ebEbwttCHG9eR335"
    "9A0v5LhDx0LlW+tJm6OTLAr59WDHcTaDiwXk96AqNj5/+eH57fzsEIa+t4k7KMur8TMMPYkP"
    "744xMO8Wg+7puZ/5HrhfMI3ZbIb9ZByX708xHt6LK93Tc78+XHu+alXrlNdT+PTxgpepBtu2"
    "fc8nu1AotB18Op1C0w7EdRMxxrwJtyn8uXOW9ezIt5ErctlwT+SUrTKkKIo7cvrUTSYTKXDK"
    "dEo6V+RULrLkipxeuSy4p9QILmvP5yfhAi4z4VbCZZXaMkfZws/W+g//R+Hz4046fIe3R3S6"
    "0YEftChIOtuJR1zRLvHiQ4r3afRxCbLeCRzhzWK73Rb/gNRXvGP8WqmILkLTtEAbRQqu0+3i"
    "980NyuUyxGabpila5GarhVGALTJF/TKbFS1yIpFgj6VqglrJraorAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAYAAACGVs+MAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo0NDo0MCArMDEwMN+SkKkAAAAHdElNRQfZAxkQMBKjjWFJ"
    "AAAACXBIWXMAAAsRAAALEQF/ZF+RAAAABGdBTUEAALGPC/xhBQAAAkJJREFUeNrtV02P0lAU"
    "PS2lUEIlkxlHpCAEZ89Ol27M8A/czMK4duO/caeJiSZu3SgTN25M3DhBFkMmDhQJEK0apnwM"
    "0wK1t+Z1YOqyr2w8yWuT95qcc9+97/UeAS6m06nTarWg6zrOZzPwhJJMolQqoVwuI5VKCcJk"
    "MnFqh4eoVCrQcjnIssxVgGVZ6PX7qNfrqO7vQ/jSaDhqOo1isciV+Co6nQ5G4zFEvd2GpmmR"
    "khPy+TyIW7xwt0SSpMgFECdxi5EzX8HGBDiOs1kBDH7ymaKoIAjCpQAiXy6XXAlFUfR4aBA5"
    "EyBGET2R630LM+tvxpmQNQG8BpE3T8/w8cjEb3MREMe1BuLxOL4bY3z4NIAob/nzq1x+DYQt"
    "IBaLodM18PpNA0p6Fwn5kpzqjXZmTUCYRUiR//x1hucv3yOl3lhbY4Gyd+g7QJGffG3jxau3"
    "SCg7gXUWLH3nC6BfJI2wUC4V8OTxAZ4+qwXWiGexWPgp8J40EeYwTRM72xk8OrgfEMC+CRzD"
    "sEUYhoFi4ToePriDuBTzBdD20zqrOWl1Mmz0ej1kMhncu3sTn5u2XwORHEOG4XAIbfcazm0F"
    "aUXExdQO3oS8MXZbrz1t6ZL/gG3ba2uRtEKUYirMf2Hj/cB/AZ4A1hxsREDCdUKrVyNvULD0"
    "HyBO4vackXsokXNtGR0R3t0RkSddf0iX1Hw+h3TbNYnvajXPKGSzWe7ekILsDwY4bjZRrVbh"
    "JX80Gnnu+Fu3ixlnd0zR3yoUPHesqqrwB18A5ik1mQXQAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_left_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAYAAACGVs+MAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo0NjozNCArMDEwMCXtbZ4AAAAHdElNRQfZAxkQLw561jOY"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAABAVJREFUeNrtV02IHEUY"
    "fVXTO70/M+yOExNd4oIRkgljDIiyQZR4FD0rQlDw6E1RDwkoIqiHXLzlKK4Iwb2peFDJHgxx"
    "dS+LcTMhhw0qJkvG7Jjsz8xOd1f5qqu6p9eNMB2Y9WLBm6+nf+p79X2vvqoSYFtdXf3ql8bl"
    "52aWQlxbVxhkmyxJvFz3UK8dmq1Wqy8IOv/+xEzjSV17AsePaTw0KjDCF4cFUKQtEB6vJSz6"
    "bWYYERFqoEvbpW3TXm1rfDsvIBsX8OlLte/E3PkL+vTqNN4/rlGCQEE6hzGEta5TkYOATsCf"
    "SBtCGqGy9wJ2+vo5jbcqP0J+fDHA/qcEisqyHnSL6MTjz+GnBYxv+SdDso/x1rvgPBudvb6A"
    "8Z0nrQNpXsJIZaxBNt/a/c8bJf0vME3pDAGlbG4ieikYLUgrPOV6MULU4i5EqK0j7XyYazMz"
    "RGYkXsImhbAvpIJ0Q8/jHM55MmLl+out6hFMCUR8OyCksiMX0kYj7gV26CInCZVxbvofKQhs"
    "0Jq6IPkkISKTFKQRcB9plWGtt+ujH8QRcBgfEmj+3sYe1hVTY0J3PyUQhYiLhHkQa8Hlalvo"
    "7hITRYErl5r44txNrNyMUGQkEpKZFLBUKiu2AjKhduKLLXKKkB9MjQn89kcLs18vo+Dvi++b"
    "gQZRTwtecjMk3UiaHAlb97VlGidfO2306dy8N+krNK5cx+kz51GamMKo77TB3Ea6Nw1lEoFA"
    "WSKR00SaBpU/Dff4EteuN/HOB5/dUZyh01hKwITEpMDAEAl0EpV/6KIPDDPHlxYX8eprH94x"
    "Oqb/bmT7TFMw09SodgJUWJ/HKZoSpWqmjU9BDMWrI1dJt0L20w7Wj+LMRyfxxtuf7Hi2fFvh"
    "V+45vuTYp9IUBMAaZ8IGmW0SbaKjLLZULzr9ovFXhMn778V7p07sIGD62wyxvQ6ABDZC+6BD"
    "bEUWXYdA5UOH33yzAhw++ADeffMZ+MVCSsD013YzIUMgIgHFkWt+TFBJW6TYpQ2IxOaB6efz"
    "qwHWS+N4/tkDGC95lgCfbdJXkNUA1E7RKbcoZStknqacKBeaIer7q5jurGGC+8Em05Msfr0I"
    "DLgttRRGDpQxe4Ob3s3tQ/F2g4BJ7Q90fivYuaP4z3dE/xOQye9uMjG+ksrg7RkRGKMwy0W5"
    "KyR8yr7M+r5GPRrf3itHhjC3WODhJILPyVv27FowSgy7tWAo51pgmqkBoVtlhyPEffmePX+U"
    "6bg8h/iM6D16pH6jvjC/9+zSMTw4rXGIZ8MJeivTMS/hmzOiMCTypSl2Trulbeldp71NIsu8"
    "cfEnoHZrHo8dfdjuMVqtll74eQlnLyusbAz2gHbfmMSLNYnHH6mjUqmIvwGdqbciWIcx6wAA"
    "AABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_left_focus_single = aero_left_focus

#----------------------------------------------------------------------
aero_left_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAYAAACGVs+MAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo0NDo0MCArMDEwMN+SkKkAAAAHdElNRQfZAxkQMBKjjWFJ"
    "AAAACXBIWXMAAAsRAAALEQF/ZF+RAAAABGdBTUEAALGPC/xhBQAAAkJJREFUeNrtV02P0lAU"
    "PS2lUEIlkxlHpCAEZ89Ol27M8A/czMK4duO/caeJiSZu3SgTN25M3DhBFkMmDhQJEK0apnwM"
    "0wK1t+Z1YOqyr2w8yWuT95qcc9+97/UeAS6m06nTarWg6zrOZzPwhJJMolQqoVwuI5VKCcJk"
    "MnFqh4eoVCrQcjnIssxVgGVZ6PX7qNfrqO7vQ/jSaDhqOo1isciV+Co6nQ5G4zFEvd2GpmmR"
    "khPy+TyIW7xwt0SSpMgFECdxi5EzX8HGBDiOs1kBDH7ymaKoIAjCpQAiXy6XXAlFUfR4aBA5"
    "EyBGET2R630LM+tvxpmQNQG8BpE3T8/w8cjEb3MREMe1BuLxOL4bY3z4NIAob/nzq1x+DYQt"
    "IBaLodM18PpNA0p6Fwn5kpzqjXZmTUCYRUiR//x1hucv3yOl3lhbY4Gyd+g7QJGffG3jxau3"
    "SCg7gXUWLH3nC6BfJI2wUC4V8OTxAZ4+qwXWiGexWPgp8J40EeYwTRM72xk8OrgfEMC+CRzD"
    "sEUYhoFi4ToePriDuBTzBdD20zqrOWl1Mmz0ej1kMhncu3sTn5u2XwORHEOG4XAIbfcazm0F"
    "aUXExdQO3oS8MXZbrz1t6ZL/gG3ba2uRtEKUYirMf2Hj/cB/AZ4A1hxsREDCdUKrVyNvULD0"
    "HyBO4vackXsokXNtGR0R3t0RkSddf0iX1Hw+h3TbNYnvajXPKGSzWe7ekILsDwY4bjZRrVbh"
    "JX80Gnnu+Fu3ixlnd0zR3yoUPHesqqrwB18A5ik1mQXQAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAYAAACGVs+MAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo0NToxOCArMDEwMEtfu5QAAAAHdElNRQfZAxkQLyM/CW/t"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAkpJREFUeNrtVz2PEkEY"
    "fnbZQ+AgGD+R5YSAxVkRLfwF5vgH11xlbeNPsbE2Ftf4C+RiY2OijeGu8GIusEjgiJ4Ej689"
    "YHedd8zgsBgt3Fkan+TNZnY3eZ55v2ZeDQzj8dir1+uwLAsT24ZKxGMxFAoFFItFJBIJTRuN"
    "Rl714ADlchlmNotoNKpUwHQ6RbvTQa1WQ2VnB9rh0ZGXSiaRz+eVEvvRbDYxGA6hW40GTNMM"
    "lZyQy+VA3PoFc4lhGKELIE7i1kNn9mFtAjzPW68AgUXwhaKwoGnaLwFE7rru4gOZWKsiFwJ0"
    "/+7tqQ6rw7JTVxcd4hOchvyCVPXOHbz9cA57soHtUhqO4yjxgMBSDogPo4mDN+/OcCVt4Ob1"
    "JGazmTJvLEIgu4Uwmzt48fI9mq2vPBzyP/9qlF9LZeh/KeP5/mucffuOSCTC/wnCBOcfPSDj"
    "6bN9fDppBOYJucJ4DtARSfbzKI6vCHjyeA+X05sYstMrCJA3RZVxAZTpwvx4tPcQ166m0ev1"
    "Ak2+lTIkctk1G0YEu7sPeBV0u91AyQmCyxALEiBUbcYjuH/vFnsC7XY7cHK5yS01Iqr3ZELH"
    "3VIc5g0X/X4/cHKx4d+ehiTgYvwFd0w3sIT7G1auQiRCZefzY+33gf8CuAD5eAxdwCXWfqkH"
    "qLyAyKDNUismTuLmkxErSmTZWEbZr/puSOQxNh9Sg5vP5zBKbEh8Va3yQSGTySifDWmTndNT"
    "fDw+RqVSAQ/+YDDg0/HnVgu24umYdn97a4tPx6lUSvsBjEDOU65zEi4AAAAASUVORK5CYII=")

#----------------------------------------------------------------------
aero_right_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAYAAACGVs+MAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo0ODo0NiArMDEwMKZ+RR0AAAAHdElNRQfZAxkQMQU5RdXP"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAA/ZJREFUeNrtV09oVEcY"
    "/83sy27UfZhtNLWxKNaDK6sNlJZIabHgpdB7KYiCR28W7EEPIkLbgz1481hIaSt4a6UUWkyh"
    "Imm9hKbpSg7pIUVjotnGJG5235uZft+bmc1bk8A+NTn1W743b98bvt9vvn9vRoBkbm7uxp/V"
    "ux8Mjce4t6ixkdJflDhZCVApH7je29v7oSDwX48PVd8x5bdx9IjB/q0CW2hitwDyNOZIA7qX"
    "sNqp8DIUaWyAJo1NGus0/l03+GlEQFZv46sT5Z/F8K3b5vLcID49alCEQE46wESFHZ1RkYGA"
    "8UoXZZiQQazts4iMfnzT4JPSb5BfjkV49V2BvLasN1oUgQR0OfieAGPLh+SSl8nfZhPA097p"
    "KwgwdpawbogEnpFOjazpeBv3P6uXzDrKok2KgNY2NopQcpwL0iaedlY4EY14hiQ0Fsg4DL7n"
    "yhCplQSeTUuFndBKSLf0LOBw4H7F2tlLRr1CsEVA0eyIVNLLAi19K9VhnWvHOOc7UllI6BQ4"
    "21euHLkvSHrjiUgfAp7I9d9H/n44VUdPl1hhbdrzoxM1ZrV6W7FfmyegYiRNIp8TmH6k8N3N"
    "R5j4axalvGwj8TyqUupJrhDgdqktCZb5xRjXf5jEvw9q2EutudXNMgKyPT96jVgV2kNgX1Jc"
    "Ur2w0VS4+MWPqE5Mob+giAS9z6j84/jrVC7ERrcW0+aByJXi03Lhs69x7/4sXqLszOIBg7Xd"
    "7xPRpD3ALklCsE6nOX3mc1RHR9FNOaLWMLiWxs5e7O4jF+amsuoXm5Th0KxB73JEEwMMyNXF"
    "dvXKOQQ7dmFiXnVchp5IRC5oENgy/VmiZJ+n7zKtA9/T2ve0+kAELNDLZY1VH/1L54+j/5Wd"
    "+GVGZWrF3tVRAm71CWEsKQuq0x4AEWB2DdV6gkI+h7Nn38ee3SXcmIptvDJ0Ik8gcbu2thMi"
    "ZIr3HJFqI6CIgKaJtvNtLwY4duw1LBS349vJJgJC9puULASiBNwkMW/QAw4Dd1jpynGFgKvR"
    "Wfo+9+yUGBwIgd0hRmbipDXL9LehQ1mvCTEOL0alq8DLP080vpmOkd8XYqzWecI9j6zakEzX"
    "NW49iFGPs6TcCySw2fI/Aemvm8mEsXLuPtixRWAblURI3/7NIFGgwg+7JBYoxxk7OHW4C8Oj"
    "OTqcKBSoaEMq0iIpb8u6iSbNRRedkHLP0Ih8K+6mimZbhcCeP0ICDoeRnBGDNw5XZip3Rvqu"
    "jR/BvkGDA7QB6SG0kPeGBFjgM6JgEtnClIDT2OAzIZFYpPExEZmkB2O/A+X5Ebw5cMjuM2u1"
    "mrnzxziu3dWYXtrYA9qubRIflSXeer2CUqkk/gNN/sDRnOMoBAAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_right_focus_single = aero_right_focus

#----------------------------------------------------------------------
aero_right_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAYAAACGVs+MAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo0NToxOCArMDEwMEtfu5QAAAAHdElNRQfZAxkQLyM/CW/t"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAkpJREFUeNrtVz2PEkEY"
    "fnbZQ+AgGD+R5YSAxVkRLfwF5vgH11xlbeNPsbE2Ftf4C+RiY2OijeGu8GIusEjgiJ4Ej689"
    "YHedd8zgsBgt3Fkan+TNZnY3eZ55v2ZeDQzj8dir1+uwLAsT24ZKxGMxFAoFFItFJBIJTRuN"
    "Rl714ADlchlmNotoNKpUwHQ6RbvTQa1WQ2VnB9rh0ZGXSiaRz+eVEvvRbDYxGA6hW40GTNMM"
    "lZyQy+VA3PoFc4lhGKELIE7i1kNn9mFtAjzPW68AgUXwhaKwoGnaLwFE7rru4gOZWKsiFwJ0"
    "/+7tqQ6rw7JTVxcd4hOchvyCVPXOHbz9cA57soHtUhqO4yjxgMBSDogPo4mDN+/OcCVt4Ob1"
    "JGazmTJvLEIgu4Uwmzt48fI9mq2vPBzyP/9qlF9LZeh/KeP5/mucffuOSCTC/wnCBOcfPSDj"
    "6bN9fDppBOYJucJ4DtARSfbzKI6vCHjyeA+X05sYstMrCJA3RZVxAZTpwvx4tPcQ166m0ev1"
    "Ak2+lTIkctk1G0YEu7sPeBV0u91AyQmCyxALEiBUbcYjuH/vFnsC7XY7cHK5yS01Iqr3ZELH"
    "3VIc5g0X/X4/cHKx4d+ehiTgYvwFd0w3sIT7G1auQiRCZefzY+33gf8CuAD5eAxdwCXWfqkH"
    "qLyAyKDNUismTuLmkxErSmTZWEbZr/puSOQxNh9Sg5vP5zBKbEh8Va3yQSGTySifDWmTndNT"
    "fDw+RqVSAQ/+YDDg0/HnVgu24umYdn97a4tPx6lUSvsBjEDOU65zEi4AAAAASUVORK5CYII=")

#----------------------------------------------------------------------
aero_tab = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAMAAACxiD++AAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFq6ysra6urq+vr7CwsLGxsbKysrOzs7S0tLS0tLW1tba2tre3t7i4uLm5uru7vL29"
    "v8DAwMDAwsPDxMXFxsbGycrKzc3Nzc7Ozs/P09TU19fX2dnZ2tra29vb3Nzc3N3d3t7e4ODg"
    "4uLi4+Pj4+Tk5OTk5OXl5ubm5+fn6Ojo6enp6+vr7Ozs7e3t7e7u7+/v8fHx8vLy8/Pz9PT0"
    "9fX19vb29vf3+Pj4+fn5+vr6+/v7/Pz8/f39/v7+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAA0PbvAwAAABh0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjM2"
    "qefiJQAAAP9JREFUOE+t0tlSwjAUgOFjZQuxuOBSFURSSOyq0qYNEd//tUzCaIeLk9743Zyb"
    "f5LOSUH3AC3vyEWIuIw06KvHRmGqKIJ3+u1RzaD0BpL+S3DwfIO5oqAHDxPk1LOpr9oGe0/h"
    "ArXHmSCjLbpIpSobyBa3o5DSWqJaF+xqlPykEE/LHFWmU2AkS1GZCdYkFajkjZhAxCghCLwS"
    "zlCcE1j1BpOeE176gqU/mMBy3F0Rb/mpZENh0QWxyJNTfD6HRXfFthgNndFgcJzDa2aCv0WZ"
    "tUj7blLdP9nZ6PCZATtPft+qjELt/vAm/HCzCNYmuA2O5xqzmzOwAuIG0AfGfgDFvqY+8bKe"
    "lgAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_tab_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAIAAAAJNFjbAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "ABh0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjM2qefiJQAABPtJREFUSEu9ldtPI2UYxovR"
    "jZd65Z3xxv/AO2/0wnihiZpodgV21cSsiyYbs8ZkiQQSDUaynBaIB0ACLOsegJaWlkNpObSW"
    "XQ5dlgUqPQ3DtPRIW9pO5/DNtPGZFjeVte2F4uTtxcz3e96n7/t+802VJEkqlapx2LQXE589"
    "80xVVRVu//319FO5F587c/Xc6yoYXOrW983vzrqOrExqPcBuRTLOQ94T5/cSApMU/EnxIFUh"
    "wIAEDxW0jyKZRSr+Vv3d724YFYPaDn2Iyy5H5I2Y/MeR7EllaTbrz2QDXC7E5yJ8LlopwIAE"
    "DxW0yOBOylOO8CedOlUikfio0wAD239tYPEkatu0qng8/j8ZWCPyg5i8cyS78y3y/dWicL5L"
    "5QNMoUVQQYsMzqR8XEEsHr/QaQhksosheS0qbyVkZzJLpbP7yhgUTYjLQV8+wOQHkIMKWmTA"
    "LJcKLSoYYDimgHw/Ij9U5qxMiU5nGTZ3AI+M4lE+wIAEDxW0yLCdkBeODWIxGDCsPOUn1jBZ"
    "P5TyRcjelEynZaawnSoFGJDgoYIWGTZjktkTUyo4PDw832nA2iRDFoNkNSptxpXNin1GpeX9"
    "dNaX9ygfYECChwpaZNiISXPuWM1jAyolj9NkLkCWIxJGjQLxRzwpeS9d6FWFAAMSPFTQIsPa"
    "oTRbbADnmx5iYMhSUFqJKpPYgQdeOgw8P4/yAQYkeKigRYZ7EWnala8gGo2iRVgbdAvafdGc"
    "L8KOSaBRCdmFOtCrVIUAAxI8VNAigzVE9LtFBljrdQpjtDjrJ5aQhEngj6BYNLTgUT6U7EcK"
    "DxW0yLAQJLqCQTgcru00bMXk6zvCTY+oY4g5INnC0nq+Udv5OlBf+QADEjxU0CKD0U/UO48N"
    "Ogy2kPTGdPKilW20cx3b/K9O4bZXnKDFKYYANR+Q+dKBVTAgwUMFLTK0bPENJqamVavy+Xy1"
    "7YbFgPSKNnl2gb2ywjVv8j0OYdAl3qZEDU30DJn2kZnSgVUwIMFDBS0yNG3wXxvzBgzD1LQb"
    "5vzSy2PJt43sJRvXYOdbt4RfdsVht3iXUpS6fTJZOrAKBiR4qKBFhqtr/JUZprp1QkXTdE27"
    "Hv/ihd8SrxlSF5bYr1YzzQ+5rh2+3ymMeIQ7XnF8T1SXDqyCAQkeKmiR4fI9rq7YAG/A8yOJ"
    "VydT1Qvsl/cz325wndt8764w7BJuecRRShwrHVgFAxI8VNAiw+c27jNDvgKKolDBKRp4vd7T"
    "NfCcuoHHc0oV1GEG1yZUbrf7w7YKM8A+0dGifp/8Y2AHT9BklCI33GLvrti+JTTa+QY7V6dz"
    "fdyhrWyALYhNvIrzi8mUiqX9zDzNGilW706P7aZGHMn+9eC7Tepv+iZVLperfIvUlLgWlc61"
    "6j5o0TwZ7/+gQTz5vLZVU//zxO82m2JQ3aaf9ZGX7iTenEl9amXr1zMtj7gfHfwgXgKvoHwk"
    "9pK1rdp0Op0qunDL87zJZFpZWSl+zrKsKIqDQ0MWiwXHhGLw3vdqq5//YjnTZOe6d/ght/Lq"
    "4vAyHSjfHxyQP5kcl7vVhJDc3680yw4NDeGje+J5MBjs6u52OByKAX5N/bp3mtVnr2lLxcUu"
    "3a1R9fWurvaOjuLo7unp6+8/8RC3AwMDJrMZh9CxwfLyslqj0ZW+jHNzFqt1XK0eHRsrDo1G"
    "ozcYTjzE7fT0tP3BA2TH9Sf2aVnapn4zWAAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_tab_focus_single = aero_tab_focus

#----------------------------------------------------------------------
aero_tab_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAfCAMAAACxiD++AAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFq6ysra6urq+vr7CwsLGxsbKysrOzs7S0tLS0tLW1tba2tre3t7i4uLm5uru7vL29"
    "v8DAwMDAwsPDxMXFxsbGycrKzc3Nzc7Ozs/P09TU19fX2dnZ2tra29vb3Nzc3N3d3t7e4ODg"
    "4uLi4+Pj4+Tk5OTk5OXl5ubm5+fn6Ojo6enp6+vr7Ozs7e3t7e7u7+/v8fHx8vLy8/Pz9PT0"
    "9fX19vb29vf3+Pj4+fn5+vr6+/v7/Pz8/f39/v7+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAA0PbvAwAAABh0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjM2"
    "qefiJQAAAP9JREFUOE+t0tlSwjAUgOFjZQuxuOBSFURSSOyq0qYNEd//tUzCaIeLk9743Zyb"
    "f5LOSUH3AC3vyEWIuIw06KvHRmGqKIJ3+u1RzaD0BpL+S3DwfIO5oqAHDxPk1LOpr9oGe0/h"
    "ArXHmSCjLbpIpSobyBa3o5DSWqJaF+xqlPykEE/LHFWmU2AkS1GZCdYkFajkjZhAxCghCLwS"
    "zlCcE1j1BpOeE176gqU/mMBy3F0Rb/mpZENh0QWxyJNTfD6HRXfFthgNndFgcJzDa2aCv0WZ"
    "tUj7blLdP9nZ6PCZATtPft+qjELt/vAm/HCzCNYmuA2O5xqzmzOwAuIG0AfGfgDFvqY+8bKe"
    "lgAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_up = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB8AAAAgCAYAAADqgqNBAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo1MToxNCArMDEwMESarloAAAAHdElNRQfZAxkQMyBAd2MK"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAh9JREFUeNrFl0tv2kAU"
    "hY+NBXbAElS0QTwColKX4Q+gbvmDXXXVriq160olq7b7Rk2zICsejWyUqkmQgEIMxvWxZAti"
    "0eCoHo40ssZj+5vrO3fmXgmuut2u4zb0+33MZjPEJU3TUKvVUK/X2SRlOp067ZMTNBoNNJtN"
    "JJPJ2OCWZcEwTXw/OwO50o/zc0fPZFCtVmOD3tdgMMB4MoHc7/VQKpWEgalyuQxy5Tv3VyiK"
    "IhROHrmyUOo97QXuOM7+4L4CZ/uziVuSJG3CCRYFX5+AcDg5iURiP3Ba7bOE+3xde/H5huWi"
    "4SHLV6uVEKAsy5uW86hbLBZC4FzpoVCzbVsI3OcFcP5yUfBQqBEuyufkhFb7Y+BMubheHguX"
    "fXiURjH7sSw7yIKivh/Ao4g+KxQK6A1MvHr9wbuyv35a7arI8Gw2i+ubCd6++4KUlveu7PN+"
    "rPBcLoer33d48/4bDvTDoLHP+xyPop0zR13XYfxaov3VhJZ5Fhr/+NlE62UFh090jMfj/wdP"
    "p9O4uk3itDNB6iC/9bnTjoXjFxmUnu42AQ/+0GKZz+c4KuaQz6kPflBTJYxuRrtZnnJjlbsb"
    "N/xtsc7x2+thkIH8S6M/9tbdkkbyGxwn1yuX3OBDsVj0Dpc4j1aCVVWFYRhYLpdQnrsV46d2"
    "26siGK9xFoo0zhwO0bm4QKvVgudsd3F4JfLPy0vPv3GJVh9VKl6J7EaP9Be4+2JJRD7+lAAA"
    "AABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_up_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB8AAAAgCAYAAADqgqNBAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo1NTo1MyArMDEwMAycPlQAAAAHdElNRQfZAxkQOBMcU9vX"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAABFhJREFUeNq1V82LHEUU"
    "/1VNz863yWyUyCSaEPzYuGtkwY8QYwLiQfTgwYsgBPMXeDJXvYmo+Qc8KEFIULyJHhQWNcSE"
    "3KLrLgqLoMYVkplIdmZ2PrrL36uqnulOsu50YB68ed3V3fV771fvvZpSoDSbzS9/Xll9+czy"
    "EFc3IkxLGlWNE/MBjj17RBljPlQE/uH1MytHzcEjeOGwwYGSQokvzigqbUCbo9UTAhhqKMqL"
    "IW2PdpN2g/pbx+DH7xX02gWcPblwWi2dv2Debz2Dd48bVIxCjiiBFjBeE1iJwumkIg4If5ER"
    "NRiKIxxgtOhpjVNfGby15xL0xz8NsP+owkzoPpqmiBP5MEL9RUBw9bWuwe6iwvRWOi2C0yhp"
    "CO6kSzkVCWJvzBYqopBtScwdruM8sHj+wkYuiWGMBxTrHxrvQdZcMCat0S33qcgFbMBBTau0"
    "y3CL6K0yfmxCibzDoYkz3pdelGbA0U53Ir4RqfHLmq9FcHVmSy1D+GbEphnNF5cdLFYuAR65"
    "MsgJqNcwMZkFzxB5THXcbGzUXk1iGS240BGmPEw3lqwlkcyfcbNxGHbOKEW7W/M4cpVYb7Em"
    "I+0pQM/qIHIq8w1NMnLyMwhdHw98pCOqI39/NwnnGY2tMKwwLjUL7tbE0Iqyp1Ot5/HqqOwJ"
    "FyYot/MKA5EZMTOOfOi8smuv3Yc26RLdRWeMPLnOoU++oV/SVOTnmuzv5H22oFDLK1S4nRVZ"
    "DTN0JK/d7pbLAB7vYn2i92jbHLg5AFp9KV6Fs5zreAy+ycg3+KDADiMDOZuuCibnMjYLeEy5"
    "gPcIvsmQuwTvMKPbfWNrfTAIx5H36FWHDpR5V+A4g7c0x1RLIkYZwSWz+5yr57UbOgwJJgwT"
    "tEuqt+lqhYNFLvSMUB2O69tkBB/adm1IuwBL9E47ZMA6lwIfOup71D6p7mv/98m3VvHC3AIu"
    "tzuYI//2zG27WJy8cW1bBjyGFQ8+al5RQs02Ksvxyr4Ae9t/WqvV9t8k548l858JYeOlhsLy"
    "yhrePHXaWrnPUg13DX5oNsDf/9zAO+99jnKtYa3cy/hUwRd3Bbj5xzre/uAb1Or7Rir3Mi7P"
    "s8jEbz+yI4fm79fxyRdrqO588LbnH322hjdezePRvbP4pRVONOdE4PtrGr2rHXx7qWup3krk"
    "+bGwjYceqNCB4bbzOnD9//yv86Tx/IEKGrvL205YLSssXds68iROcC+PRxXmf5WNfCsHpEF8"
    "xwlLE/DUve7a6Z2kyO8reY0arwU3OPl4HktXctjzHCenw1V2l2oeKLF2Cjm3scQNZzjByUKO"
    "WvfwoDdgSyyytxf4fZ5b5Az/qdxHnyoE3fW1wonFAMHiwmOr85cvzn26fBgHnzZ4uKyxk6BV"
    "gvFgwc2GDsB1vEnEdjj+cA8BDyVo0+Eb1CbZ+5Unxr/OA3PRRTz5xILrnq1Wy1y+soxzqxHW"
    "29M7ON1f0XhtTuOpQ/Oo1+vqPxxtdiUOpmR7AAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
aero_up_focus_single = aero_up_focus

#----------------------------------------------------------------------
aero_up_single = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB8AAAAgCAYAAADqgqNBAAAALHRFWHRDcmVhdGlvbiBUaW1l"
    "AG1lciAyNSBtYXIgMjAwOSAxNzo1MToxNCArMDEwMESarloAAAAHdElNRQfZAxkQMyBAd2MK"
    "AAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC/xhBQAAAh9JREFUeNrFl0tv2kAU"
    "hY+NBXbAElS0QTwColKX4Q+gbvmDXXXVriq160olq7b7Rk2zICsejWyUqkmQgEIMxvWxZAti"
    "0eCoHo40ssZj+5vrO3fmXgmuut2u4zb0+33MZjPEJU3TUKvVUK/X2SRlOp067ZMTNBoNNJtN"
    "JJPJ2OCWZcEwTXw/OwO50o/zc0fPZFCtVmOD3tdgMMB4MoHc7/VQKpWEgalyuQxy5Tv3VyiK"
    "IhROHrmyUOo97QXuOM7+4L4CZ/uziVuSJG3CCRYFX5+AcDg5iURiP3Ba7bOE+3xde/H5huWi"
    "4SHLV6uVEKAsy5uW86hbLBZC4FzpoVCzbVsI3OcFcP5yUfBQqBEuyufkhFb7Y+BMubheHguX"
    "fXiURjH7sSw7yIKivh/Ao4g+KxQK6A1MvHr9wbuyv35a7arI8Gw2i+ubCd6++4KUlveu7PN+"
    "rPBcLoer33d48/4bDvTDoLHP+xyPop0zR13XYfxaov3VhJZ5Fhr/+NlE62UFh090jMfj/wdP"
    "p9O4uk3itDNB6iC/9bnTjoXjFxmUnu42AQ/+0GKZz+c4KuaQz6kPflBTJYxuRrtZnnJjlbsb"
    "N/xtsc7x2+thkIH8S6M/9tbdkkbyGxwn1yuX3OBDsVj0Dpc4j1aCVVWFYRhYLpdQnrsV46d2"
    "26siGK9xFoo0zhwO0bm4QKvVgudsd3F4JfLPy0vPv3GJVh9VKl6J7EaP9Be4+2JJRD7+lAAA"
    "AABJRU5ErkJggg==")

#----------------------------------------------------------------------
aero_denied = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAADxklEQVQ4jbWUzWuUVxTGn3Pe"
    "+955k8nMJE5m0vqRZCaUYomG0uJGjDR0UXBRUj+6Kqg7kSy6SBf5A7ropiB07aK4qIsWIYsu"
    "ioXBQoRKqWhJ1eq0sWqSmWQyk8y8H/e+p4t8oJ2YuPHA2dzD+fHwnHMuiQheR/BroQJQOxWv"
    "Z7N9cRB8nAA+dIEBAIiAvwPgJ04kro1Vq/Mv66XtrCgVi9osLEx1K/V57+HD6a5Dh8B9fSDH"
    "ga1WsXr7Niq3btVrUfS1yue/HH34MNwV/HM+n1HN5vd7+/vHsmfPQu3bt60i8+wZli5fxr/l"
    "8nXT2fnJBwsLK8/XX/B4ZnhYqWbzyv5icaz34kXwnj2IrYUoBXge4HkQpRBbC85kkL1wAfuH"
    "hsZUs3llZnhYvRQclMvnsqnUidTp04DWoEwGnE6DEwmQ44AcB5xIgNNpUCYDaI3UqVPIplIn"
    "gnL53LbgmULB9YCp9LFjcHM5KM8D+z6o0QD+l9RogH0fyvPg5nLIHD8OD5iaKRTcTd6W/KhS"
    "OZJOJgc7R0ag4ngd8gqhAHSOjMArlQbrlcoRAL+8oJhFjiaLRWhmrN29ixYzfNdF6LqIXBdG"
    "a1itEWsNaA24LoQZ5s4duAC6hobAIkfbFDOQ78jlQPU6zNIS3jh/Hqz1jmolDFE7eRIqk4GX"
    "zYKBfDtYJGDfB9VqkNXVV7IBAOT+fYjrrs9DJGgDE/Ns+OABkExCBQHmL10CM4OMAVkLAkAb"
    "3hEAIgJZC7YW9OgRwnodzDy7xds8kF97et70iMrFfF6T1gAzEEWAMburBvBwcTH0RQbfX15+"
    "Cjw3vIOl0tMgiq7VVlbA9Tq4VgOvrYGDYNes1esIoujawVLpaZtiAPitu/sta8yt/o6OVI/a"
    "8X/aimVj8E+r1XCUeu/dWu3+tmAA+D2dHvetvdqtlDrgOEgQbQsMRDBnLWrGGM9xzozU6z88"
    "X28D29VV/LF370d+HH/bFOntIkKGCJuLFwJYEcGqCDqJKh7zZ+88efKj09WFHcFbtuTzOW61"
    "vghEPo1EDtiNdweASzSnib6Tjo6vum/eXCwUCm39dO/ePUxMTDizs7Oq0WjoMAy1tVbHceyK"
    "iJsFOs4wv32AqF8AzMXx3FWRP5cAn4hCZo6YOdRah8lkMhwYGDCTk5NGzc/PY21tDcYYiuOY"
    "RIQ30gGgKiL4xpi/AJSxvsIWAIjIAaBEJBYRx1rLxhhqtVqoVqu0rRXT09N048YNPH78mKrV"
    "KjWbTfi+TwDgeZ4kEgn09vZKX1+fjI6OYnx8vA3yHxWIwp50Lj49AAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
auinotebook_preview = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0"
    "RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAJXSURBVHjahFJRSBNxGP/d/+52"
    "W66ildPKJB9EMSwjFSNoUkS+GYg9pi9R9tJeopcgC3yKYvRUMHA+VBJUmpQPQSySKINqEGSB"
    "Np3aNjs3N8+7285d/7sxa9yw3/G777v/932/+76PP6PrOgw8D876dYImWJAEZPpW8l89nYea"
    "i8KGgMHRYPitvgkCw0G9qaNXD4x80Qs1BknRnzaBEfX1e+G758PQaEgvnP8VULA5lCS8/T7T"
    "NUQK4ApO4j/1l3s6N/zA8MiGTxiGgUGowGwkhqkfc5Bl1SKwlM6i90y75dzsoKX9fNPLF2Mt"
    "sZVGuMt3YPDpK7jsDnj7uiEIfH6ClAjF5rAKHD1xcW99a927C5e6hP3luwCGwONpRjwm4tqA"
    "H7du9pmJDG9HrsSeSE3dvmdnz512tFZVQaGjaCyBjedRubscxzva8PrNJzNR0xmsKsQq4KzY"
    "fqDW7UY8o4KjxRzLmpYlBLUNNZj48BVRMQlWA7I5yTqCvcyuq+s0qmkQiC1/QeiTo1ajNpWS"
    "oMoMVJVyXbZ2sDj9S5sMh2l7CjJUJGswq0HNZBCNLmEhPA0xsQpJUSHJJUZILCbuxuZF7fv8"
    "ApbTaaysrSEpSVgURdy//RDJxAp2RvzgMgkQzbpEziVEbgQfBeuXPY1dqcMS4W08cnIWY0Pj"
    "iIXjuNI2A0dsDmXyT3yUTtESZ5EAU3CuDvhD7ydDB1mWg6zQWelSj2ydwbE9v1Fd4TQZmHLj"
    "yTfBzP88PsgUCZTCne4qFycID7Zt4TuqK50TFaTmZMP1x5l/c/4IMABbKBvEcRELXgAAAABJ"
    "RU5ErkJggg==")

#----------------------------------------------------------------------
whidbey_down = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACsAAAAeCAMAAACCNBfsAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAaHWVZ3egZ3e1cYCncYa0dpC4cYXGcpDBc5fWd6Dld6Pwi5OzgJbUkJjQkqHC"
    "hafggqfwh7Dwk6Xgl7fwoKjWp7fXsbbWoLfnoLjwpMLwscHnsMfxtdD0wMHg5eTo5/D49/f3"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAverH2wAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAF4SURBVDhPbZTpYoIwEITRGqAQ1ChqOFrx/R8y3SObq8yvsHwZhglaOdH7HZbJIp1W"
    "YW7t7w68LOcwDaxd5+lhC3q18zwOMhTWIjtZ+3wGfFmWFYZjgJl9vWC/1x30AI2zzExzIcqz"
    "a2RxC2Ak2n4zJmEx1TgaY8R7AtHsdgMS1IivJRZHyN5lA6PMEgwZ2JVYs23bxwuWG3PGdF3X"
    "ImvtBO/KqAl38ytgO+WqMz1SDDz7KXaCbatU5YYARt+SbUHg61zT9/iMHsQZKHBI9A1S6njk"
    "fpuCRTjmJVQBymfxlfuCc5IX0cMhnhvCMYO8KCdCV0L9GbMz8Fhqous1ugbWw/32k2oDtFUn"
    "do2sz1ywqWvCElz6pq4pS3CRVxooMvjqsI2+v5LwXCVrljfrGclhqH2v5e+Nr6VnYltgBct7"
    "iDDExm+grvm0ouL/QwrjN1CHXvczYAz0xF5Pp9w168zfAhjeH9gSle8hnWutldL6H7rHOq2P"
    "agd1f/M7VhKuYPh3AAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
whidbey_down_single = whidbey_down

#----------------------------------------------------------------------
whidbey_down_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACsAAAAeCAMAAACCNBfsAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagcHiYZ3egcHilUHjRQXLwR4DwU4Pw"
    "YIfTcYXGcIjVc5fWZpHxcJj3d6PwgJbUkJjAkJjQkqHChafggqfwh7Dgh7Dwl7fwoKjAqLDI"
    "sLDIl8D4pMLw4Of35/D4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAQS37pgAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAGeSURBVDhPfdOLUsIwEAVQCCixFSggVfBFQWpVjKJo+f8fi3ezSZq2jDsDhHB62Wyh"
    "o319Vctg9V2tO34p5H0bHw5D4Xe9FULK5bKhb6UcDs/cprNdMYiprhee30khaStx2NpudwCb"
    "JHG8WAhbEkU0cZgtUge0iYrjCEUuilheOWysS2U9GpluGJJ1mKyg1LHZn6NYNNYUCWuozSjr"
    "FVxnLGQUjZPJlLJKCk7piar0Nk2zS90RAhINVDZN5yUeNZuhbjq6BzmZomYoICr/Yr5mtcry"
    "fL2mfnvjSd2anvkSsqBZUazN2XS/YVNLrc2Qut3yHAj/10OWFwVRtrpPvZo5cL+28A7fnxfv"
    "G6Ps74GwsfXCsXKkMnWWko39DKukAbjUygKfskFqYLnnKvcHdQT9sA0EPdgD1ts9Vr2G/fpp"
    "pDMeAg3gWe2fgn9V9d+0yW5edCylQurnwJejZ/7VPJpZ7V+C1PBsFrPFXAul6rSRi2S2uFmq"
    "kdrK1frcWOq1kXrC6osHulnq963Wa3Nm9kOySrVpq1/yr5vNbtdK1foPGIxy6qmqIg0AAAAA"
    "SUVORK5CYII=")

#----------------------------------------------------------------------
whidbey_down_focus_single = whidbey_down_focus

#----------------------------------------------------------------------
whidbey_dock_pane = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAF0AAABdCAMAAADwr5rxAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAaHWVcHiYZ3egZ3e1cHilcYCncYa0dpC4ZobHcYXGcpDBc5fWcZjgd6Dld6Pw"
    "i5Ozl6e3q62xgIjQgpXEgJbUkJjAkJjQgJjggKDXkqHCk6TWhafggqfwh7Dwk6Xgk7Tkl7fw"
    "oKjAoKjWqLDIp7fXsLDIsbbWoLfnoLjwsLjjl8D4pMLwscHnsMfxtdD0wMHg6tTN4Njk5eTo"
    "4Of35/D48Ofh9/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAA1jVbdgAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAdFSURBVGhDtZpxe6I4EMbtbQVXrHJuaY8KWq/XW3Sr196u8v0/GTfzThICRIh9nssf"
    "u4rw42UyM5kJHVVXjDQah/EV51ejK05+SKMwjK/BX0Gfzu9ms2kY3PgL8qd/nc/vCB+GN/54"
    "b/p0sVjMaRA+9Mb70hku9GvUe9IBV3TC+9rejy5wTfdX70VneJ7LHRaLu7uIPNPL9j50hp+a"
    "w9NzPOhQfvrHHqeZn/phOmzeofvZfpA+zTFa2rNsFk2GPWeIruB5y+5En00mg1E7QNfw/CSP"
    "oEaZ51kWDavvpxu4phOWB+hJMqi+l17DFb0sBa+eJB3KOX30xLIFeAQXvKYTvtf2PfTVbrtd"
    "6xsonrKMoafhJAwu5/vL9NWO6Rp/iZ5OJsFlfI/2onh7oxvQYKOsaeALjTV944fK2DFn489o"
    "ryqmA69NDrtjWPSwZyHs9RlWr+h5Qzt9UdqzPvhATTBMn/Uu4QOxut9r24vFdzSUvUh+lk37"
    "6wMXfVNf8sF0mdrt9nGF8YbB3ppNl/WpK8eNHPTNxuCXHx/a9q+vZz3exZvW6+m5NPhi58B3"
    "6Yfj2zYRHcuSgOI5Bi0fDgeiT/nT8oxTi2K3U1dZz9ChH5gu+GXJ9HNRvP/dgoOfyEGox/Tn"
    "nVlo04kNm34DHPRfv7psxuujywqm4rBo41t0Vs4uvl4/PXHUNLj7/f6VRvte5RJTjxBo4Zv0"
    "A3sDxw2d+EeTcnzd4qnIdR43zZ/EbSUjNfEN+oHppFsiEZOmxn5/ZJOBvt1uNivrNyvk2nib"
    "fmA6W0W0Z6FGkL0sNvLYt0L/aKeLtnqLTvCD2FzRNR53VelSZ8l1IfhfdqqDbRaWcWo6nWZs"
    "zrk1SZLVvww40oBeZTG9oDwbOm6pDy8svKHzA9Y2Z3oUgU5WOSIXdOjAv/Nv1hLJ5aZRr+lQ"
    "XhNYevSEZye6ZJo2PZNpd9ANXtFFuYtOM0p50UnP4Dm2VeQZavVCZ6cqudziCOL/szSKYkh7"
    "hReu62UJv/MyS8+HM2AZuUwNgwcdTlVSkasrrppOgSL0Rg2ME9l6uD8/cqmWd643T0Y90xEO"
    "azku48RzCu0vau1z0lNEhJu++Epkoks4dOhjPPaL+Hl+gf4upmlplzaIPGdUIbewXls7OTvo"
    "xktbdK6auNyAWz266fOHaoQ4ZKNpOl940vRXHQN99BU9XMkzqylo3+7u0nTEdkHkKzoKRUNH"
    "tccxeoEOwxs6XQqK0GdRNFoVKkqEDo+8lk4Syq2UsDWd2ubxKHtm5dzVid1Fe5bOjCx4kUt7"
    "mohf8QPCMg3ttGERjp4z1Yk27O5HV15r6MbuVF1S2xbHo+pRNblNf88SaN9sVIpyaSfDYhnU"
    "dEQK7A54ELO/f6VJqC2joknF4bmfPgadw4UtY+hmo4Vj9ZanWNtd07PsRfmDuYqTgc43nAei"
    "e8TEu4OuWh7kGcb70kViKfR7phdvVA808gw34thHkBzJ+EZHSquH5NfzN5p1ZU+S/kM3fZxE"
    "owBnCF2lWFAivcWi8jvUYydDBujAZ0JX7XD5Q0yTMT0EnVf6emHh9FC3anptgu3nc5ueppC2"
    "0nfT//OdqRcOA5HeoVsbFGZdFbxFJ3/7C3ShyTPoz/C4PwHnhau+rLmxVdcEwNunRdEYNcFK"
    "8Wv6jO4cBL8DfuC1xbqssbVi1TOMN6chHoSu1Ws6ByLZBfDzObEX8yRqNvd2LaZsLzt3k8lY"
    "1g8aDw+Ukc3gfatAzMJjapTnOdEb2yqNOtLgSdwkMHBWGEIxxmQS/iYTqvAyGSmN9rZEswZW"
    "eJkaC0Af4/ieBrPHY6kWWniCh+0NoVb9DjzbPLhZNhH07f4+CIK4heYbT0V7d0ui3XvcSvLk"
    "QEbXROPnz859zFGOLGptZhRDru2UTt9EeB3ISj31TQ784fBIRwVeVTQtrq2gbs93G0Vfvtg9"
    "3/Ft92KqdXWfI1cpVCspOOMnjg3QLr0aRwpOxuGOj+i7orD6JarnqVugEE2sfnXs2khx0CsD"
    "r6rv33U3w/3MZvNCQ/dP3EI+1c2pa5fGRbfa2e/SApohXbw6RmFk0a2rzMd+ujRclAI0XnYh"
    "pBRH1ujfhuil6yZX6LTEmlEnl158H91uFVVtr+t7ne0o9iKXSdSxHjpvLJieqLmXar5xaPfs"
    "Ll2mP8IMWqRzTy/PSTplzIvqe7Qndit3gc4581Paq4p23lHpYP+dH6K5lyoZSce1U3+vz0xb"
    "dMZLgcD/AB5aode9Qb+/S5VmtEsDUNMH334MxKqpcxw+4/HWbIAuNSbXgc3RLIo+4zNyjeBR"
    "ZdbjRKuFKec+F03qqrpCtuieb/uGLGNXyDbdR7mugXsezlUhn06D3iJED+2qvkcDpCpUvzdl"
    "nnTVnSg6vavxfT/spb1Wz9qpnPN7Q+mrXTsmF1I+78j0PHpq13jOLR7v966mV6jS0BX0vAJq"
    "OZ+3dlLP8UnDH+7nkUpRHMf/399CVFUcf7nu7zj+A8yummsi9EdGAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
whidbey_dock_pane_bottom = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAF0AAABdCAMAAADwr5rxAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagaHWVcHiYZ3egZ3e1cHilUHjRQXLw"
    "cYCncYa0dpC4R4DwU4PwZobHYIfTcYXGcIjVcpDBc5fWZpHxcZjgcJj3d6Dld6Pwi5Ozl6e3"
    "q62xgIjQgpXEgJbUkJjAkJjQgJjggKDXkqHCk6TWhafggqfwh7Dgh7Dwk6Xgk7Tkl7fwoKjA"
    "oKjWqLDIp7fXsLDIsbbWoLfnoLjwsLjjl8D4pMLwscHnsMfxtdD0wMHg6tTN4Njk5eTo4Of3"
    "5/D48Ofh9/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAaHenigAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAejSURBVGhDpZkLe9o2FIYpTVeWrG3Srmy9stk0LTPJMKMhmYM9KOuSERqydAX8//+H"
    "dy6SLF+QRXeepwtg+9XnT+fotlqyRQRey+1vcX9S2+Lm08Bz3f42+C3ond5xt9txnRf2guzp"
    "b3u9Y8C77gt7vDW94/t+DwLwrjXelo5wpm+j3pJOcEEHvK33dnSGS7q9eis6wqOIW/D942MP"
    "MtPKexs6wlfZsMwcCzopX/2jx6prp76aTp4X6HbeV9I7EUVOexh2vXZ15lTRBTzK+Q70brtd"
    "WbUVdAmPVvwKIuIoCkOvWr2ZruCSDlgMog+HleqN9BQu6HHMePEmQdWYY6IPNS+IB3DGSzrg"
    "jd4b6KOr6XQsGxA84YyiB27bdTaP95vpoyukS/wmetBuO5vxBu2z2fU1NACBpowh6AvEGL7h"
    "S4WYmN3W12hPEqQTXlpOvlNodNcwERpzBtULepTRDl+E9tAEr1gTVNO7xim8olbnc+k9O34F"
    "IfwC+WHYMa8PyuiT9JHPSOeunU7PRhTXFJitYWeQ3joqaaiEPpko/ODzZ+n9xcVaxi1n03jc"
    "WccKP7sqwRfpi5vr6ZB1DGIAcuYoNH9YLIDewU+DNd06m11diae0dyjQF0hn/CBG+no2u73M"
    "wYk/5B9JPXV/VOiFPB3Y5Ol7ghN9uSyyES9/HSRkFZZFHp+jo3JM8fH4/ByrJsOdz+cXEPm2"
    "4gF1PZVADp+lLzAbsG7gxt+zlJuLKb0VpM7ZJHuJ05ZHpCw+Q18gHXRzJVKniZjPb9Ayok+n"
    "k8lIu6aVXB6v0xdIR1dYe+hKBPilsWkcez+TF/XhIq9eowN8wZ4LusRTq2K4lKPkeMb4pT7U"
    "kTe+Zk5Kh9uU5zi2DofD0b8IuIEgvcIxOaF8UHRqUv7sa3hFxxdMPUe65xEdXLmhsaBAJ/wt"
    "XtOmSFxuKvWSTspTAkr3zundgc4jTZ4ecreX0BVe0Fl5GR16FMbFUnpImaO7wu+Qqmc6JlWM"
    "yy2sIPwbBp7XJ2kXlIXjdFqi6zjNwvvRHeQMPyZC4YlOSRXDIleuuFI6FArTM2tguhHdo/bx"
    "lWMxveN6c6XUI53KYcy/c6ywT0n7RzH3ldIDqohyuv8WyEDncijQW/TaHznPow30W7Ymp523"
    "QZA5tYTGFtSra4dkJ7rK0hwdV0243KC0Oiun906TGtUhmibp+OBK0i9kDZjoI3i5GHtWUmj7"
    "dnwcBDX0hSpf0GmhqOi02sMa3UAn4xUdHiUK07ueVxvNRJUwnTJyWzpIiKe8hE3psG1u1cIP"
    "qBx3dew7aw+DrpJFWVSmPRhyXuELkjMZ7XBg4dY+hGInmvHdji6yVtGV77C6hG1bv19LzsQm"
    "N5vv4ZC0TyZiiCrTDsbSNCjpVCnkO8GdPub7W+iE1BlRTaIO12Z6i+hYLuiMoquDFqzV19jF"
    "0ndJD8OPIh/UUzgYyPEGxwHvhGritoQutjw0ziDels4SY6afIH12DeuBzDiDG3E6R+AxEvGZ"
    "HSnMHjy+rt9Drws/QfonuenDQdRz6A6miyGWKJ48YhHjO6mnkwwOohM+ZLrYDsef2JoQ6S7R"
    "caZPJxYcHtKtmpybyPteT6cHAUkbydbkX2wZ9sKuw9ILdO2AQs2rjNfokG9/EZ1p/A7yM2Xc"
    "nwTHiSt9LHuwla4JCK/f5nktWhOMBD+ld6Flx/mN4AucW7THMkcr2noG8eo2qgemS/WSjoUI"
    "vhB8vR7qk/nQy27u9bWY8J5P7trtFs8fEKenMCKrwHMrh23B6CjlUQT0zLFKZh2p8CCu7Sg4"
    "KnRJMUW77b7kDhV47owAIn8skV0DCzx3jQaAj/3+CQSyWy1eLeTwAHfzB0K59Tvh0XPnxSCL"
    "gG8nJ47j9HNobLjD2otHEvm9x2sePLGQadcE8UVZrLf3hdIVKwu2Nl2oobLjlMK+CfCykIX6"
    "ekPvAdHC5eWDOtNp3wTdUnYUVNzzvfa8V6+0PV+93mg8f56z6WWj8eDBPaSLLaXbbZccgBbp"
    "ScsTcDBnvb5Tv7+H8cMz1cCrRr2BP+3f0/arrbKDlBJ6ouBJ8vedO/eBvr+/t/fsWV1EAwLh"
    "+/v3ztPNadkpTRld286C8vuIgdjb24VA8u4us78HvHZvyUczXSpn/sOH5BGjkV6JN9LrqPwR"
    "kZ5CMDP32XjKYaITXOhcZkNryTOYY6ADe3f30f7BY9S7RPFN/A/GUtGbzcPvNuM30+t1YIMt"
    "Kb3ZfLqEfxn6IcSPG/EG7XeBffAY4gkEYDHUH3qVN28Oj47evfsa7Uly99FBlk7ecyNIB/ih"
    "7xvg5lO3nRy9KeCCfgjKu8ZjN3O+7xidOTzy/f91preDnlPOsO8i4Bu4cuR/zZme3kuIJ3o2"
    "oEOPQHnFgWH1/wEFPNFx6lexxGSpVC7XkaaxaKeUbqPchp6Q96n2TxArgP9RZYtaA5vHUcRn"
    "bV9ZeJ6usM10Vt98wgmDyfJrNP2l4hm6XDF7CATiZTZih0aRFdySjup5/PqZMlEe5Vbpt9Oe"
    "AJ7pkOewhSie+Ja3Y0tPdpgOBRrZKrf1HZV9Q3T03Fb5NvTk25+wQKPrsyq30+vWzsAjSI+i"
    "LeC2OcNyTjudc219VP0O/wGW4JFYg7jH7QAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
whidbey_dock_pane_center = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAF0AAABdCAMAAADwr5rxAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAGDeAJUqQIEOkIkewJFKlJlayMlSiMle1K2G0LmnSNnDgR2OkQ2O1UGagUHCo"
    "VXSzaHWVZ3egZ3e1cHilQ2TAQHDAQnLSVnfFQXfgcYCncYa0dpC4VYTTRIDjVYbgZobHYIfT"
    "ZpPXcYXGcpDBc5fWYIjgYZHgcZjgd6Dld6Pwi5Ozq62xgIjQgJbUkJjAkJjQgJjggKDXkqHC"
    "k6TWlrDXhafggqfwh7Dwk6Xgk7Tkl7fwoKjWqLDIp7fXsLDIsbbWoLfnoLjwsLjjpMLwscHn"
    "sMfxtdD0wMHg6tTN4Njk5eTo4Of35/D48Ofh9/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAXehG6QAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAdqSURBVGhDtZoNW9pIEMc5emrB651VUDRUpEkqb5d6SBOUXq9Q8dprke//aXLzsrvZ"
    "hGWz+NzN87RCzP74M5mZzGyspDvYOGh4wx3OTys7nPx+HHjecBf8DnS/3wtD37t47S7InX7V"
    "7/cA73mv3fHOdH8wGPTBAO85413pCGf6Luod6QQXdMC7+t6NznBJd1fvREd4kvAnDAa9XgCR"
    "6eR7FzrCV3lzjBwHOilf/a3bKnRTX04nn2/Q3XxfSvcTsoL2OA6DdnnklNEFPCn4Hehhu12a"
    "tSV0CU9W/BWErZMkjoNy9Xa6gks6YNGIHkWl6q30DC7o6zXjxTcZl9UcGz3SfEE8gDNe0gFv"
    "9b2FPlnMZlP5AYInPKPoY6/tXWyv99vpkwXSJX4bfdxuX2zHW7TP5w8P8AFg6JQpGL0Bm8I7"
    "/FIxBmbYeI72NEU64aXLye9kGt2z3AitMYPqBT3JaYc3Qntsg5f0BOX00HoLL8nVL1+k79nj"
    "CzDhL5Afx769PzDR77Il35DOl3Y2u5mQPZBhtMb+KDt1YvggA/3uTuFH375J33/69CTtK0fT"
    "dOo/rRV+vjDgN+nLx4dZxDpGawBy5Cg0v1guge7jq9ETnTqfLxZilfYdNuhLpDN+tEb603z+"
    "9a8CnPgRHyT1dPmTjatQpAObfPo7wYn+48cmG/Hy6CglV2FaFPEFOirHEJ9Ob28xazRuFIYt"
    "sjjOf9p6RJeeUqCAz9OXGA2YN3DiHzrjw4du66zT6VyCNZvNdzk+hy1XpDw+R18iHXRzJtJF"
    "Y4uvrrpdgBP98vJds9vNfqmlXBGv05dIR6+w9tiThLet62tkn50h+xzs8GVL/lIvF0X1Gh3g"
    "S/a5oEt8+PYtws/AFP2wxfgfeqkj3ww052R0OE35HGtrFEWTfxBwDUZ6NauDnSq6LNNM1/CK"
    "jl8w8znSg4DoEcDZG0U64b9indBukdhuKvWSTsqVV+iOH9zSBe0C3Eiv/3yFJxjoCi/orNxE"
    "73YBbqbXiS5vAJn+TD3TMajW2G5hBuHPeBwEQ1wbtjrklfuCoePrtVDgsV3QujWFJzoF1Rqa"
    "XNlxafSOoOO1zeye6TWkf8KvvBa3d+w3V8r3SKd0mPJxthVeU9Q+adno9Rco3kwfXAEZ6JwO"
    "G/QG6nKhg+cL2nkMgsippFRbUK+uHYKd6G/edDoUiPcmz9TrB3jSjZnef59WqLag0yQd262V"
    "pLfedC5L6RMImzXEPK1EjTS+9XrjcQX9Qpkv6NQoKnqzc8lZZNOu6LBUo4dBUJnMRV1hOkXk"
    "rnRIqPWMW9iMDmNzoxLfo3Kc6tjvrD0eh1Qhm5BI27XX9qt06YnOSzW673mV+1hMojm/P4+u"
    "/A7dJYxtw2ElvRFDbj7e44i0d09F9TL5vba/f6Rrp0yhq0rwiyHG+xVc4swzIpugijnQq0TH"
    "dEHPKLraaMFcPcEAkn6X9Dj+CAs/NM/PMedVzMhyg3Vg/6A6xhpsoIuRh+oM4rfSD/P0Q3qP"
    "dQbolEzzB+gHcnUGB3HaR+AaifjcRAp3j3iCS3svqV5J7Z37jL63R9IFXZRYogRyi0XUd1JP"
    "OxlsRCc8weuQTmwd/gGH9gUd7/SyjcCF+vaQvDeR7/t9nT4mZZNXzC8asKsBnrBB1zYo1H2V"
    "8RodEvnPrfRaDei/ERwb8GxZfmMr6wkIr58WBA3qCU5Pi7qJXf2V4Eu8X2rLclsrWj+DeHUa"
    "5QPTnwr0GhjQCQ4tQ+bzJImC/HCv92LC97xz1243qMKjvXpVq0n9NchQpRx/6SvlRM9tq+T6"
    "SIUPcfdFwZ8mk9oLVMxksJ+OKEnZfAywOB6DFbcl8j2wwPOlydbDq/DgYG8P/6Funa3wAPeK"
    "G0KF/p3w6POL16McHfQfHR1Uq9W9XwIKRM2GpB7gG1sSxdnjhIsnJjJNTWDfvxdo2lG8Y8Bo"
    "E0IOmbZTNuYmwMtEFuphbjLgl8sbOMrwNPXMG1mbM99JEBwf6zPf48Pi47zAf8QuJUK6GCm9"
    "sG3YAN2kp41AwME5OPEBfTGfa/Mq9PmPcBAmQ21ebZg2Ugz0VMHT9PNn3odAgyn57iPYjBta"
    "bKz922w4Ne3SmOjaOPuZR0BlPMWLY5BGGl1bpV7a6TxwQXmQeN6F4FacqoZ9G8JKl0Mu0++0"
    "75AVFyveRtdHRdHby/5eVjvIvcDkEnHMQseNBTUT5fdS1TtMbcvu0nb6TW6SM+7pJQlIh4K+"
    "Vb1Fe6SPclvoAdiztKcp7LxTp0P77+jp/F4qVySZ10b91pjxC3TEczeF/xHc01Jv8wPs8c5d"
    "mtLOA0BGL336UZKrqs8xxIzDU7MSOveY2AfmLd8UPSdmeA3jqcvMbAV3C9XOPS+bxKqsQ9bo"
    "jk/7yjyjd8g63UW57IEtX87UIa9WpdHCRAftor+nAYhbl//0OZ+cTgQdntW4Ph920p6pR+XQ"
    "zrk9oXT0jApMbKRcnpHJ6+ioXcY91haH53s701Pq0mgOtTwCKgSfs3ZQj/kJ5g53i0ihaDgc"
    "/n9/C5Gmw+Hxbn/H8S+cD8xcYY4GnAAAAABJRU5ErkJggg==")

#----------------------------------------------------------------------
whidbey_dock_pane_left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAF0AAABdCAMAAADwr5rxAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagaHWVcHiYZ3egZ3e1cHilUHjRQXLw"
    "cYCncYa0dpC4R4DwU4PwZobHYIfTcYXGcIjVcpDBc5fWZpHxcZjgcJj3d6Dld6Pwi5Ozl6e3"
    "q62xgIjQgpXEgJbUkJjAkJjQgKDXkqHCk6TWhafggqfwh7Dgh7Dwk6Xgk7Tkl7fwoKjAoKjW"
    "qLDIp7fXsLDIsbbWoLfnoLjwsLjjl8D4pMLwscHnsMfxtdD0wMHg6tTN4Njk5eTo4Of35/D4"
    "8Ofh9/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAA+wCLtAAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAeDSURBVGhDtZr/f9JGGMdprZPJnHSKm9OKI4DG0K5kWAptGIw5FGqpdQL5//+Q7Ply"
    "d7kkR3L4ms8PWmjyzifP3T33PM+1FO1gQ6/u+DtcH5V2uPh86DmOvwt+B7p7etLpuE7jmb0g"
    "e/qr09MTwDvOM3u8Nd3tdrunYIB3rPG2dIQzfRf1lnSCCzrgbX1vR2e4pNurt6IjfDTiJ3S7"
    "JycezEwr39vQEb5OmuXMsaCT8vUn3dYdO/XFdPJ5hm7n+0K6OyJLaQ+CjtcsnjlFdAEfpfwO"
    "9E6zWbhqC+gSPlrzKwgLR6Mg8IrV59MVXNIBi0b0fr9QfS49hgt6GDJevMmwKObk0fuaL4gH"
    "cMZLOuBzfZ9Dv1xMp2P5AMETnlH0odN0Gtvj/Xb65QLpEr+NPmw2G9vxOdrn8+treAAYOmUM"
    "Rh/AxvAJXyrAidmpf432KEI64aXLye9kGt3J2Qhz5wyqF/RRQjt8ENqDPHhBTlBM7+Ru4QVr"
    "9epK+p49vgAT/gL5QeDm5wcm+n58y2ek89BOp4NLsmsynK2B24svvTQ8yEC/s6/wvc+fpe9n"
    "s420W55N47G7CRV+vjDgs/Q7D+/fE/heCECeOQrNPyyXQHfxp96GNM/ni0U/oz5DP3iIdML3"
    "QqRv5vPb9yk48fv8Jamn4R9lRiFNPzg8rCJ+j+BEX62ybMTLb3sRuQqXRRqfogP88BDo9/b2"
    "LnDVJLhXV1czsPSzwh4NPS2BFD5JP3j0E1j1YeUeqE9SbmZTmikwdQaT5K942nJESuIT9INH"
    "TK9WAL+n46+ubm54HqJNJpcaX1tyabxOBzjR0fWofl8ilkudTXHs7Vz+Ug8XafUaHeFEl+ol"
    "frlcgmy5pjhKjueMX+mhjnzT1ZwT0w8eVcHwCfg/eqdc/hsBN2BMVNGeMH8pOj1Q7jNdDa/o"
    "oDxDr/+LMw/gpDtDJ/wt/k7bIjHdVOolHd2SpFcrv9K7A50jTZoe0FrdGOgKL+jkcyMdRhTi"
    "opEe0MzRvcLvEKtnOsJXutXQ7yRtRrNwHG9LIaVltO9xLCDPhPw1m8ITnZSv4M1XT9BqtRXS"
    "f8ZbYaEwPZEDfxJ0ws/QaaHY3jHfXCv1SP+OmCl65elTvPWd2PuM9KGznd59BWSgf0/wtPYK"
    "wYHO+/YW+i27JqWdyyCYOaXo5csamK79SW1V/fE+rVRc/DRXUnTMmjDduMCLBmb66XlUOm+3"
    "k3T0vaLPbOiX8HIhjizmgOh3Kt9OTobDknt8nKCvVjiq1Qprp2wvRzs5XtEBr9E7npem07Tc"
    "lQ4SwimnsDEdyuZ66WLUPW63flN+B+3o90qZtctlbvL7sO/58gXJMwnt0LBwgD46Pm614lHd"
    "ge6l6MrvkF1C2eb7pWhwDeqBv/qorSapfTIRIcqkHRxL2yAODmqnzJ5GleANH+f7ACLDcbtt"
    "pG/y6XWi44JL0FWjBddqf4r4BL1WuV8+Eo5XmjAYyHiDUcY7q+Mltwa6KHkozvTRNxl62Uhn"
    "B4RMP8NL5teQDyTiDBbi1EfgGAnqf1+vtSBZk47fvA107R9l0RcMPc9rULBgOsVIESk92WIR"
    "8R0KMJ45HCNrSC8/x3sDpotyOPzIrgmQ7hAd9lxtY8HwEJdqcm96MwXntFtM5m21Un5PvkE2"
    "1DD0FPyfDdgsPUPXGhRqX33TpXmp6LhrM13ydDrNONrTl7hxyX01qVz6HX3v/onqdfqDB/8Q"
    "XvBjegdmeqPxB8GXuLdo9ERrRctnoFWi06uVB/uYEyj1ko4LEfxC8M2mr2/mfS9Z3Ou5mBvg"
    "qmo9Qbc/flyt3uX7N5vz875m2LdqsFvQXKV8NAJ6oq2SyCNJfatFdA2OCh1STNZsOs95QAWe"
    "B2YIlm5LJHNgUk/0JBwwvn8Ghux6nSJjGg9wJ90QSuXvLvqG4b0kAj6dnTUaDT+Fxge7rD3b"
    "kkjXHp0O8GHW38Xag/lfvmSeo77FlQWlTQfWkKmdkqmbmE5RQqiHusmAXy4H8C3DowiGxdQK"
    "ytZ8r1+320dcvXHNd3O9eKeydfGcGywJIFcScMQ3DQ1QQ736uv2DLA1B/Rzpi/lcq5cgn4dq"
    "AZZoX6tX66ZGioEe/RLXnR8+yGoG65nJ5B2YrJ+whLyILzV1aUz0+I7oA1RLXCuxcRUvvoNl"
    "pNG1u9SP+XQuuCAESDp3ITiZp+CS34bIpcsil+mwxSqLg0suPo+ul4q08bCJ9J2kQ0bnmVwi"
    "vsuhY2NBJkupXqrqrGLCmNNd2k4fkBtk5Db29FA7Rsyt6nO0w1Ye2xY6xsyv0g67FZ90cP+d"
    "8oxEL5XTuSOxro36c+eMm6IjnhME/IfgTh68oKf3IqmdC4CYXnj6UbBWER97Rg0Day/qYOs5"
    "gXngST08wXB2UKi8mB4xvps+96C0oPDMqcAz8ELs+/SJ0P90ZsP4DN1GuYVnhPpvdlYm1FMB"
    "LTJUu5MyO+3S94IOZzW258PFo0ozVc571A7pnN0Jpa12oR5Phq3OyOTasdQu8RhbLM73dqZH"
    "L1A3VQU5R0CpBW+tHdTj+gSzh+/0txC+73+7v4WIIt8/2u3vOP4D32mBB1S/lsMAAAAASUVO"
    "RK5CYII=")

#----------------------------------------------------------------------
whidbey_dock_pane_right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAF0AAABdCAMAAADwr5rxAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagaHWVcHiYZ3egZ3e1cHilUHjRQXLw"
    "cYCncYa0dpC4R4DwU4PwZobHYIfTcYXGcIjVcpDBc5fWZpHxcZjgcJj3d6Dld6Pwi5Ozl6e3"
    "q62xgIjQgpXEgJbUkJjAkJjQgJjggKDXkqHCk6TWhafggqfwh7Dgh7Dwk6Xgk7Tkl7fwoKjA"
    "oKjWqLDIp7fXsLDIsbbWoLfnoLjwsLjjl8D4pMLwscHnsMfxtdD0wMHg6tTN4Njk5eTo4Of3"
    "5/D48Ofh9/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAaHenigAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAe+SURBVGhDtZr/W9pWFMYtW1en67RzunWdpUvQlgWdMCoyJFkotbaRCrMryP//f2Tn"
    "yz25N19ILn2enV8Qkn7y5s2555570414jRh4dbezxvnxxhonXww81+2sg1+D3jw7bbWarvPM"
    "XpA9/eXZ2SngXfeZPd6a3my322cQgHet8bZ0hDN9HfWWdIIrOuBtvbejM1zo9uqt6AgPAr5C"
    "u3166kFmWnlvQ0f4Ih2WmWNBJ+WLf8xYtOzUV9PJ8xzdzvtKejOgyGj3/ZbXqM6cKrqCBxnf"
    "gd5qNCpHbQVd4MGCb0HFMgh836tWX05P4EIHLAbRe71K9aV0DVf05ZLx6k4GVTWnjN4zvCAe"
    "wBkvdMCXel9CH96Mx6FcQPGUMwl94DZcZ3W9X00f3iBd8Kvog0bDWY0v0R5Ft7dwAQg0JYSg"
    "LxAhfMOb8jExW/Uv0R7HSCe8WE6+Uxh0t2QiLM0ZVK/oQUo7fFHa/TJ4RU9QTW+VTuEVY3Uy"
    "Ee/Z8RsI5RfI9/1meX9QRB/pf/IJ6fxox+P+kOKWArPVb3b1qT8XXKiAPhol+O6nT+L99fW9"
    "xB1nUxg275cJ/rvjV3l8nj6d3Y57fGJ3CUDOnATNf0ynQG/iX917OjU6Pn6Vx+foU6QzvrtE"
    "+n0U3b3PwInf4x9JfbR/cHzSzj3iLB3Y5OlrghN9Ps+zES+/duO7h/tMz+IzdFSOKR6Gl5c4"
    "alLcyWRyDZG91rL7cBfjGPiZHErTp5gNOG5grPyVpsyux3RXkDr9UfoQw3ePgJ5J0RR9inTQ"
    "zSORHpqKyWSGlhF9PB6NhsYxgP9IdMSn1Zv0KdLRFdbuu4IAvww21bHXkRxEONEPjtCblHqD"
    "DvApe67ogqerqnIpVTKMGD+vPd5mY3b3ITLqNR3yOvEca2uv1xv+i4AZBOlVjsmE8gYPvnv8"
    "eFvhmX7S/ls/2oSO4097jnTPIzq4MqNakKMT/v2mST86Anz7dxm1QiflmoDSvUu6d6BzpcnS"
    "fXrsSGfxqB28B/xY8IrOyovo8EShLhbSfcqcXzc3t5lMgeqDQJUSpmMdX2K7hSMIP/2B53VI"
    "+jVlYainJTqO0yzcH51RQ/pcx2LxR6AqFdGpDi6hyZWOS9OhAjM91QPTiege0jc3t7b350r7"
    "PAw/zsEcVo90moFC7EM1HZ4pab9Sc18hfUAj4jBHh7xk9UDnCp6j1+m2rzjPgxX0O7EmpR1H"
    "VRD0kU61BfsrUzskO9GTLM3QsWvCdoPSCo1P0Skvg9t+vEHjEEe+0PEfLoR+LWOgmn5wMIeU"
    "Ad9D+OTMudxAX2jkKzo1igmduj0coyvoZDxrBzJgFf03rGhAH0ZqlDCdMnJd+hbSKSWFjvl/"
    "ctLc8N+gclzVse+s3R+0SNYQnyi1v+mMJN8HPc6rGtH3Te1Cf+OrlWjKdzu6ytra1ve75Ln2"
    "nSra8cVG3FeL3HS++z3SPhqVaG95Hk2DRFeFQPmO9BcvMN9fwgpdO0M+LGQc3pfT60R/ipVA"
    "j9VwvkcV51seq89x70J8F7rvXynj+Rflu9QbrAPeOY2Jpzk6wb9RlYDwtnSeO5ZMP0f6T1CA"
    "M9r39va+ljrD6lMrUpg9uL7ev4anrrV/lEUfFlHPoTOwvJs1cj4XuHTYpJ52MjiITnif6Wo5"
    "vPzI1vhId4n+i8yrwNzDWQQ/STn7jkHen52Z9MGApA3lavKJV4a1sOuw9CK6guvVAeMNOuTb"
    "O6Izje9B/sb9K+ctHq4n86rWLnBj7UF4TW8BvU49wVDxNR2POc6fePAtzHvKmoSewM2VDeIT"
    "OqzlXJfpol7ocAi2ZxgOQ6n26BHyf6AwPDd9N7znnbtGo87zB8TFBVTkJHDfymFbEvzO7pMn"
    "iq6V66dqPlqEw/5FAgdGzyXFFI2G+ys/UI4HD7T6JFvSOZPKHN5zNADwZ6dzDoHsep27BY1H"
    "c3bIG0lFlYmZ/p0eLXruPOumEfDt/NxxnE4GjRdG9Vs7TyBMW4x8l97sOTrAOxe0aoL4/Dl3"
    "neRXHFmwtHlQAzpYn4HnV8OAh4Sg3UalHtZNBfjptA+/MjyOIXO2dnay8IK19nPPOzzkW+E1"
    "3+z25irp1tV1ZtilQK+k4IAH+ldiQPJZsF6tewpO6iOk30SRsV6Cfh5WCzCf94z1aq2Whxfu"
    "EyTwOP7wQVYzuJ4Zja4gZP0Es1bzUsut5ZRn8j1//AMvAZPgVbz6DWZ7g14At9rjgBIgeN6F"
    "4Facqkb5NoTF/gxCaKVn3INeKZTiy+jG7gxOHjKlqvadpMPY84osKR6r5plRRGsONTVJ9eSJ"
    "Sr7h0C7ZXVqtvU9GCKZwTw+1Y8Vcqb7EmV6C1mrT+5FBgDXzi7THMey8U6dD++94E+m9VK5I"
    "Mq4L9ZfmTDNDR7z2neCuMfTyFyjfdeMuLdFOm9fJU7V481Sxp5f0Oen9d/pm8dasgi59Tvad"
    "Da6ZLN7bVNEVnrpMHQuAyyxQMpgs3q/qDtmgWymvrJHSiGS1Wym3ouc75MXCwvNst7TSQcmc"
    "dlt1qHZvyuy0y+oE8h7p8K7G9v1wZc7oNgpHFdE9oJdlij5mSZe8x9pS+ZZpfbrCY22xeL8n"
    "fFvt4D3qplVBySugjGH2dMRDrgDdznPrjFS4Tqfz//1fiDjudA7X+38c/wE5II6oZulXWgAA"
    "AABJRU5ErkJggg==")

#----------------------------------------------------------------------
whidbey_dock_pane_top = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAF0AAABdCAMAAADwr5rxAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagaHWVcHiYZ3egZ3e1cHilUHjRQXLw"
    "cYCncYa0dpC4R4DwU4PwZobHYIfTcYXGcIjVcpDBc5fWZpHxcZjgcJj3d6Dld6Pwi5Ozl6e3"
    "q62xgIjQgpXEgJbUkJjAkJjQgJjggKDXkqHCk6TWhafggqfwh7Dgh7Dwk6Xgk7Tkl7fwoKjA"
    "oKjWqLDIp7fXsLDIsbbWoLfnoLjwsLjjl8D4pMLwscHnsMfxtdD0wMHg6tTN4Njk5eTo4Of3"
    "5/D48Ofh9/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAaHenigAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAe1SURBVGhDpZkNexJHEMcxrTVNao3G0PoSaXmJ4l1soBhCCUdBmkaPCDFWCN//e1z/"
    "M7O7t/fC3aHzPMqFu/3t/2ZnZmeTUrCBnZ83m2cbPB+UNni4NxweHx/9tsGIDei92bBF9B+L"
    "44vTu6T8AFb+oTC+ML07gfIjppe/L4ovSofy1nGjIfT9oviC9O6kBZ83flf0ovhi9NccLY2y"
    "sv39gvhC9NeT4R/HR5q+Xwa9GL4IvQmvLBcRK4gvQG/+DZcvP8JG2hYF1efTSflxY2HIdLHY"
    "gxVwTi696VGCptLz8Xl0Ud4oR90u2vOXNodOyjlYFjoa+VPT89Rn010ol+xXdP1Bq/oI9jA7"
    "azPprguX23T4R7QbejY+i/6q1YJXpLYwlZ0foz/4LqOkZdBfvaJgaZQzPbP3IAu/nv7rEYxi"
    "g+xgIfVrgX+44FV99HAP7J2dra216jO0/3RULkfpPAP9p+lg37u3Hp65r/oHByE9GvDy/e4u"
    "2Bnw7F3bD+kQbGbS1w/y4Dk9wd29vcePtc5dtp9/1rOQ8jt3MjfBnFwlPLtgd2dnG7YD291V"
    "88Et2fBU7eNQz2fgiU3kLWVPnhBflHfCRwcpb5GifTw2+M5n4Mkf21vbh7fanvzCPoLy25XB"
    "+9MUfJI+v55NuqKjswLw7v3729vPDVounj6ld6Grzi0/6vvTqRplvUOCPie64Dsrot9u3X//"
    "PgbHj5VthgPP8BkGDZtx58TpYNODo7cMZ/ri3yQb3/yjv+0EN77QE/gYnZTjuclodH4OONON"
    "XV1dXcLic606V7PZdDoaDRP4KH0O4TPaOPHgX1HK9eWE32oy6fXG0VtXRJ/QmDg+Qp8THbqZ"
    "PmxGZF+Ty5g+mYzHA+see4X8ksTb9DnRySui3atpBPxlsQk1euvrm+JzQ4/43qIDPhefK7rG"
    "86x4d8tGI1/wC7CnfEtpH7asyAnpeMz4fOh5XrfbHfxHgGsY61Ue05h3hs7TGrqFN3R6wdDn"
    "RHccpsMr1ywuQWf8Dd3TZPpstUK8prPykEDSnXN+d9Dl1eN0T5Y9hW7wii7K0+hY0ekauseR"
    "Y3tF3iFUL3Ra9tUSRhlEn17fcdos7ZIDYkQ3lNH9JSB4P36CPSPDlBk80zmoVp8+faJBZCEd"
    "iSJ03LVM0Rl/Sa+8kmQaLpmi8UTngB3J95qONWXtFyqYU+l9zoh0euslyKBLOiToFX7tC4nz"
    "4Rr6jbgmph3SW60TxH0p4Npi3klpR7Az3URpjL5iv7suh1UvnX5yFpQ4D8lp2jM0cKnplzoH"
    "sugDvNyKVlZTWiewN2/6/RL5hTNf0VcR+gB+4ThfQ2fHGzqGMkXoruOUBr7KEqFzRIbai9Eh"
    "YTXheLXorlurlLx3pByrENHu9V0ji5ciTXu/K3FFEtgzEe1us1YrvfOYbejivWJ0FbWGbvzu"
    "wmq1drsU9Jgd0iWbvC5rH49ViUrTDsfyNqjpJptaDK+2Kd5fYhFS6JLm2fQK0yldyDOG/obg"
    "z55xNgUvaIm131UlQAm+UPFgRlEl0MWGqoxzyjlxk0KvgS65KviidJG4Evop0f0Z+oFInXFE"
    "uaIz3qpxqJEw2ZnfYtXVakH6R1pzolMRdar8hNBViWWKU6syXHeprB4mYynLQWe8J/ShTL76"
    "KK7xiF5jOu304cZC5UErN3Tx/cmJTe/3WdpAz6Y/aWbPA1ukJ+jkF9XymX1V8BYd8cYt3kBo"
    "8g76miOOe705bVzhMFt5qF1Fjv2Y41S4Jxgofkh3MXO1+ifD57S3WMMs5TadnWMe43wQulav"
    "6ZSI8AvDb2+79mbedep1iRYxuxdTvicPuW69XpH9A3Z2hopsDMsJn5sWuGmUD4egq2hJ0vXS"
    "EhyPGTgprLFitnq99lwWVKwpi9GHRZVHtSvfE5yCygLgst0+hRG7UpFuIYYHvBZVHqeLevJ5"
    "9VknisBPp6fVarUdQ9PErB5wlaHpfueiIMWTloZPTbAvXxLzmG8ps3C0cZFDgJs4T1tV/g54"
    "nchKve/zzh+z+byHbwQeBFiWuM/jMSMzvnCcw0O5ZPX+9Wx6Ybp1Ncc1dSmo0QpO+HpCecLv"
    "xKw4Cg484ESf+r51XkI/j9MCUrRrnVcr1Wro77WewQ0DD4IPH/Rphs4z4/EFTJ+f6Ah5HhJT"
    "4Hl/mfggR0Bj1FmZ8xPSyKInlad6xnpMjkQoARqPZnuqW3GuGokDcGSSzN9x6EOu0LHFGguL"
    "SyY+i24f5lRvr/t7Xe2Qe06aS9R3GXT6xYI5E+neW21UFv2kth6/nt6LnOQUXW2rZi5IR8Vc"
    "i8/Qjr/ShLaGTjXzq7QHAX5/zZ0O7eZMl0aUtnD6TyqSzutU/Zkx04zRCS8NgqKjcFmpVyxX"
    "w6ekSzPa5QAQ0pMlNzZBzu/0TJ+TEjNwS0rhKp5NVDGlz2lFOjXq1aKtxZqoydGu8dxlhrYE"
    "3LRzX5dNalTYIVv0QsrzqphsJ7pDtulFlBeiJzvk5TI3WuTFc/1u1PPxR3WokXbum/yu8Rz3"
    "RO92sYVa7dw308X3mu6kbdCbVwJrhIp7qi1prcXXxrseJ3gqXPF27ts9Q4FJuvlUkLb7p09R"
    "KGZkKHdpsOLwYhGphLXbbTqeZ3gifmsD7UHQbh/WNoEH/wMcYo64Ex2PFwAAAABJRU5ErkJg"
    "gg==")

#----------------------------------------------------------------------
whidbey_left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB4AAAArCAMAAABYWciOAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAaHWVZ3egZ3e1cHilcYCncYa0dpC4ZobHcYXGcpDBc5fWd6Dld6Pwi5OzgIjQ"
    "gJbUkJjQgJjggKDXkqHCk6TWhafggqfwh7Dwk6Xgk7Tkl7fwoKjWqLDIoLfnpMLwscHnsMfx"
    "tdD04Njk5/D49/f3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAQ3JLMwAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAF4SURBVDhPfdTbdoIwEAVQL6htAi0tElBaoVb+/xPTM5M7wc6LLvc6GTIJbnRel/DT"
    "ZkUvwXOefsahdqGMJ2LvSwaO4P7d5BdMWejQ9+dzzhOiY4/quu4z44kYSebudbH4REwLm7Q6"
    "Jr2hk+lrGR4e7Rb17ZRSdV23v55vxL4vsRCBOesXRrquBbZm0yb7jIHD/EDNKPpUjRBvbmOU"
    "Heb7/f6g/aISJhz6R8J4MJvmbM6FGSrPmRaM09i0YZ4zDdHxTN8909I8RMtzyu3NztgwbyxK"
    "qytlq6pK0qqROC/0vipGzx0v7ll/MAY2Y1G1SWv9UpXlCvNlpiPZlyjX2w4VJ/rlZk7+D3Oe"
    "DsoXwqoNV5HzKHtidJlUC3eXifuXZcxNE91U4xFLIb6jm8oeWIKLcFPN/jxLKY/HhM3+TUl5"
    "OhU48eQN9Y6VTwe6D+kLbJ0W3m5X3m926ntgXb7+eg/z2ZzJhcuusN4Lsds9/WfSuhBes94U"
    "C6r/AM3yZVcU56/qAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
whidbey_left_single = whidbey_left

#----------------------------------------------------------------------
whidbey_left_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB4AAAArCAMAAABYWciOAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagcHiYZ3egcHilUHjRQXLwR4DwU4Pw"
    "YIfTcYXGcIjVc5fWZpHxcJj3d6PwgJbUkJjAkJjQkqHChafggqfwh7Dgh7Dwl7fwoKjAqLDI"
    "sLDIl8D4pMLw4Of35/D4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAQS37pgAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAGNSURBVDhPfdRrW8IgFAdwLyuXZLIUy67D6dK0pd3w+38xOuewAYOMN3ue/fbnwHZG"
    "R8ej5251Yu33nMfcHw8H1iNOxsiNh5xkGUfvmqIBg2YZ8KBrvM3J5BoGH7NBnW9xMjHMGTjl"
    "fQYlxvKYh/V5jErc5MEdJxMOAx/BKxZI0w/LkI340aZx5jZzdmdrU92TjKr8IbB2szHKqv1+"
    "r2Y4hFDINzWf082A2Xxu+II0TDNU4KcnAcNPz4TiV0P6pp1XKduM9R0XZdlipXBpnNXpgGl3"
    "Hu+qdSnzZ1sb0libpab2rqrKMs/d0tqstz+QhwfUt/dabFrrbYXzy1OsNwf0Fgs2TB+ad77B"
    "6SNOba9B/uV49D6ZqIvX3bJp1m++mEBO710rLg8wv8wNmVZj6ZdrxeWatmcZW9FjXbxj3ufR"
    "6NPr8wLyHnM28vtc6+INX08+w9LTKednwS9I+TwnJg3+UMoTGw3/7wKndxqyXq3gAdg9ZaO0"
    "1oab8yo+mRYLKe1p9se5tpCX/7G+dUfhL8vucupsrDz0AAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
whidbey_left_focus_single = whidbey_left_focus

#----------------------------------------------------------------------
whidbey_right = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB4AAAArCAMAAABYWciOAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAaHWVcHilcYCncYa0dpC4ZobHcYXGcpDBc5fWcZjgd6Dld6Pwi5OzgJbUkJjA"
    "kJjQgKDXk6TWhafggqfwh7Dwl7fwp7fXoLfnoLjwsLjjpMLwscHntdD0wMHg4Of35/D49/f3"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAWZqHkAAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAFySURBVDhPddPbeoIwDABglDqoFDcVGBVw8P4PyXJoQ0sxN+L3m0NDzVaJx/YoT5k8"
    "9fbAhfve2luS77kfhq5rir077pkTZ34Ng7Vt2yRO/ELuUPeOTIWxdOrA3Fc46p/9AVobsgnm"
    "Z0b1xRsTeLa+EV1f+jCBQ+8DlnzgsDBX2fLxYFR8WeYtxJF/u65tF95KM0/TNEv+ZzZfkElL"
    "TbKhuDEVnJ/4Z1+cufpmfsBwC47newNV1fV6v8cMTqMx67Jkhs0s3YIRsNbqHDCePczWhVIx"
    "S28NoVRdRyxrMaR5zZPjdcDJha+opxOf+33ACthtrR/glkY7LzmXs5npjbn3VqqcFHmE2i0E"
    "934+fd9PjKXdvylbR7yn/q7FuVB8HOF9uMJUOsjF3retb9PcysuFZ+aA0QrJJXYzC6/Fk+IO"
    "Eee628IOquJcx5wP6nYV9cYvGpYBKucNRqNHpfW+r9+580uS63vjD855vvXcF4fvB7r+A9+i"
    "Xf4K/oDaAAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
whidbey_right_single = whidbey_right

#----------------------------------------------------------------------
whidbey_right_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAAB4AAAArCAMAAABYWciOAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagcHiYZ3egcHilUHjRQXLwR4DwU4Pw"
    "YIfTcYXGcIjVc5fWZpHxcJj3d6PwgJbUkJjAkJjQkqHChafggqfwh7Dgh7Dwl7fwoKjAqLDI"
    "sLDIl8D4pMLw4Of35/D4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAQS37pgAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAGXSURBVDhPdZTZVoNADEDpaC2CFSqC1hVaxWoVqdv0/39szDIraF7gcHuTTCankbJx"
    "6V7tW2TfTprVmDvcNKsxt7ismnbzOPQ1npaMh5zxNMdo4Afr0CfMNK8Bv4UcMdBzwshDHzBS"
    "wlWN6QM/UmKecu68hBj40ed8nmrOuN28u/qR+op9XNfANw+mf8asow31ge8Mh9au4zhlRIF+"
    "1z2zjwcTiKWL/f6p2zFHHMdJWkpty77/lpCffcQ3IwzHY5+GitkDG8fTddv/MB2v+9n6dlVJ"
    "aBxq9/Dk/l+95IDgu8b3eD0GJ1ibTmYwzqFt12wTLn07xKc51XW16XqaF20D1jPVtRHf3XHn"
    "Sxyqm1ovC5r+MZ97OcJEj/TULuA+B3ZRFIdm5njd/o1JaSgmvzK7Bh8LXAt8kku1/8KaAr61"
    "u+ZsQ1X0Aauks1tsKdhCzGb4gzMKr66uTTzLFwuNnctjmUycb3t2m6om7JPtu3qZyE+yBURI"
    "+UogvwAM5QfUYOw/ybIhtVghPuBUXrg/LiHG1NmwcSNXqV+4tHLqnJPo+QAAAABJRU5ErkJg"
    "gg==")

#----------------------------------------------------------------------
whidbey_right_focus_single = whidbey_right_focus

#----------------------------------------------------------------------
whidbey_up = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACsAAAAeCAMAAACCNBfsAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAaHWVcHilcYCncYa0dpC4ZobHcYXGcpDBc5fWcZjgd6Dld6Pwi5OzgJbUkJjA"
    "kJjQgKDXk6TWhafggqfwh7Dwl7fwp7fXoLfnoLjwsLjjpMLwscHntdD0wMHg4Of35/D49/f3"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAWZqHkAAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAFmSURBVDhPhdTtdoMgDAZgW3GKWjsL2i/X2vu/SJaEBBXcWf6Jz3l5i9bMpdNXR3Xa"
    "Wc/StXNfKXXawaktm1rrUuWHJCWxX01TA1bqkODYlm3bNjCAVYwji9TbneStJcoWcNR5Yz0V"
    "mySvLVJrvW/buq7g7NadVxbpvJ3taSyWUuef9cx6kxwsdU3sprPY0tJEucboqginwZapjfqC"
    "1UUhT9BboXb28Twfa42pQjLZQMUCwiHbdZKMdqFsPx+PeZee3w2w3WpXugvUY7GAsXPmLvdx"
    "HITzXe4QbK8Klbvsckcr+C/bF0WeZ+52ez6Bw+D2AwxdwAxwhRsaPDp9hA4OLWGpSn1pVlZh"
    "X8Cg2dpNLlxwrgFKFpP/sRqZf26Ph3T2Te8w3AyijSlJ8fuA1v/Acfy+0Dxp8DyZig2dr9fw"
    "WXj5ExoGnxpy5TSi78c0gRUacvE0XjvfsGnqwuryH3q/d6hz07L6CxOEXf5LAPv7AAAAAElF"
    "TkSuQmCC")

#----------------------------------------------------------------------
whidbey_up_single = whidbey_up

#----------------------------------------------------------------------
whidbey_up_focus = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACsAAAAeCAMAAACCNBfsAAAAAXNSR0IArs4c6QAAAARnQU1B"
    "AACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAA"
    "AwBQTFRFAAAAECBXFC9vECiQBS2oIDKMIDigC0CVJUqQIkewJFKlJlayMEiwMlSiK2G0JFTR"
    "LmnSKGHmKHDoInDwMGjgNnDgNXLwSFeKQFizR2OkUGagcHiYZ3egcHilUHjRQXLwR4DwU4Pw"
    "YIfTcYXGcIjVc5fWZpHxcJj3d6PwgJbUkJjAkJjQkqHChafggqfwh7Dgh7Dwl7fwoKjAqLDI"
    "sLDIl8D4pMLw4Of35/D4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
    "AAAAAAAAAAAAAAAAAAAAAAAAQS37pgAAAQB0Uk5T////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////////////////////////////////////////////////////////"
    "////////////////////AFP3ByUAAAAYdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My4zNqnn"
    "4iUAAAGTSURBVDhPfdQNV4IwFAZgpEyCVBRZaR8OUcI0yrLw//8xuvfuy22e7jkKZz68uxtg"
    "0Pm135fl24XxwB/bNU1VFS/+D77d/TY12lsPe3aLqTkUu3Gxa7cHSC3IsmsHOxZS64pzYTMH"
    "23Z7qKFXvpTWwZZd0w5wJivLbHxu14fmtSqUzRhYC5/ZEuY/tVbZ2NjyA1o9/UB9qmrtZG0x"
    "teKtdnjSplCmDWXLd7xZF63G0opUzux2Ra5eoLCYShvQqv2io7IymewGUsV9lVYdcG1TqAnd"
    "QbSbDbR6bqETkastYbCruob5xTNAhpp27PgK7WqFG8DZvz2kY8DBQwGF68XKW/HUtPCBE1rb"
    "dJKCjOMwDLq7gjHbkscvZUEOBiGtLc+NtTdYjCcJyFDsQ2cshOnr1PlYUmH7aTqbqYyEajRS"
    "12Bqr6f2V2CaLInjCCqGShJ5NTRAVOQSRokulDWfozap2gLGmaMwetIv7/yeulGpxnb94TCK"
    "Hp23fLHAedSgeS/C4fHo/y89R5qqfhF9+xJGvszoH5Xccuo6pVT3AAAAAElFTkSuQmCC")

#----------------------------------------------------------------------
whidbey_up_focus_single = whidbey_up_focus

#----------------------------------------------------------------------

whidbey_denied = aero_denied

#----------------------------------------------------------------------

# ------------------------ #
# - AuiToolBar Constants - #
# ------------------------ #

ITEM_CONTROL = wx.ITEM_MAX
""" The item in the AuiToolBar is a control. """
ITEM_LABEL = ITEM_CONTROL + 1
""" The item in the AuiToolBar is a text label. """
ITEM_SPACER = ITEM_CONTROL + 2
""" The item in the AuiToolBar is a spacer. """
ITEM_SEPARATOR = wx.ITEM_SEPARATOR
""" The item in the AuiToolBar is a separator. """
ITEM_CHECK = wx.ITEM_CHECK
""" The item in the AuiToolBar is a toolbar check item. """
ITEM_NORMAL = wx.ITEM_NORMAL
""" The item in the AuiToolBar is a standard toolbar item. """
ITEM_RADIO = wx.ITEM_RADIO
""" The item in the AuiToolBar is a toolbar radio item. """
ID_RESTORE_FRAME = wx.ID_HIGHEST + 10000
""" Identifier for restoring a minimized pane. """

BUTTON_DROPDOWN_WIDTH = 10
""" Width of the drop-down button in AuiToolBar. """

DISABLED_TEXT_GREY_HUE = 153.0
""" Hue text colour for the disabled text in AuiToolBar. """
DISABLED_TEXT_COLOUR = wx.Colour(DISABLED_TEXT_GREY_HUE,
                                 DISABLED_TEXT_GREY_HUE,
                                 DISABLED_TEXT_GREY_HUE)
""" Text colour for the disabled text in AuiToolBar. """

AUI_TB_TEXT             = 1 << 0
""" Shows the text in the toolbar buttons; by default only icons are shown. """
AUI_TB_NO_TOOLTIPS      = 1 << 1
""" Don't show tooltips on `AuiToolBar` items. """
AUI_TB_NO_AUTORESIZE    = 1 << 2
""" Do not auto-resize the `AuiToolBar`. """
AUI_TB_GRIPPER          = 1 << 3
""" Shows a gripper on the `AuiToolBar`. """
AUI_TB_OVERFLOW         = 1 << 4
""" The `AuiToolBar` can contain overflow items. """
AUI_TB_VERTICAL         = 1 << 5
""" The `AuiToolBar` is vertical. """
AUI_TB_HORZ_LAYOUT      = 1 << 6
""" Shows the text and the icons alongside, not vertically stacked.
This style must be used with ``AUI_TB_TEXT``. """
AUI_TB_PLAIN_BACKGROUND = 1 << 7
""" Don't draw a gradient background on the toolbar. """
AUI_TB_CLOCKWISE        = 1 << 8
AUI_TB_COUNTERCLOCKWISE = 1 << 9

AUI_TB_HORZ_TEXT        = AUI_TB_HORZ_LAYOUT | AUI_TB_TEXT
""" Combination of ``AUI_TB_HORZ_LAYOUT`` and ``AUI_TB_TEXT``. """
AUI_TB_VERT_TEXT        = AUI_TB_VERTICAL | AUI_TB_CLOCKWISE | AUI_TB_TEXT

AUI_TB_DEFAULT_STYLE    = 0
""" `AuiToolBar` default style. """

# AuiToolBar settings
AUI_TBART_SEPARATOR_SIZE = 0
""" Separator size in AuiToolBar. """
AUI_TBART_GRIPPER_SIZE = 1
""" Gripper size in AuiToolBar. """
AUI_TBART_OVERFLOW_SIZE = 2
""" Overflow button size in AuiToolBar. """

# AuiToolBar text orientation
AUI_TBTOOL_TEXT_LEFT = 0     # unused/unimplemented
""" Text in AuiToolBar items is aligned left. """
AUI_TBTOOL_TEXT_RIGHT = 1
""" Text in AuiToolBar items is aligned right. """
AUI_TBTOOL_TEXT_TOP = 2      # unused/unimplemented
""" Text in AuiToolBar items is aligned top. """
AUI_TBTOOL_TEXT_BOTTOM = 3
""" Text in AuiToolBar items is aligned bottom. """

# AuiToolBar tool orientation
AUI_TBTOOL_HORIZONTAL = 0             # standard
AUI_TBTOOL_VERT_CLOCKWISE = 1         # rotation of 90 on the right
AUI_TBTOOL_VERT_COUNTERCLOCKWISE = 2  # rotation of 90 on the left


# --------------------- #
# - AuiMDI* Constants - #
# --------------------- #

wxWINDOWCLOSE = 4001
""" Identifier for the AuiMDI "close window" menu. """
wxWINDOWCLOSEALL = 4002
""" Identifier for the AuiMDI "close all windows" menu. """
wxWINDOWNEXT = 4003
""" Identifier for the AuiMDI "next window" menu. """
wxWINDOWPREV = 4004
""" Identifier for the AuiMDI "previous window" menu. """

# ----------------------------- #
# - AuiDockingGuide Constants - #
# ----------------------------- #

colourTargetBorder = wx.Colour(180, 180, 180)
colourTargetShade = wx.Colour(206, 206, 206)
colourTargetBackground = wx.Colour(224, 224, 224)
colourIconBorder = wx.Colour(82, 65, 156)
colourIconBackground = wx.Colour(255, 255, 255)
colourIconDockingPart1 = wx.Colour(215, 228, 243)
colourIconDockingPart2 = wx.Colour(180, 201, 225)
colourIconShadow = wx.Colour(198, 198, 198)
colourIconArrow = wx.Colour(77, 79, 170)
colourHintBackground = wx.Colour(0, 64, 255)
guideSizeX, guideSizeY = 29, 32
aeroguideSizeX, aeroguideSizeY = 31, 32
whidbeySizeX, whidbeySizeY = 43, 30

# ------------------------------- #
# - AuiSwitcherDialog Constants - #
# ------------------------------- #

SWITCHER_TEXT_MARGIN_X = 4
SWITCHER_TEXT_MARGIN_Y = 1

########NEW FILE########
__FILENAME__ = aui_switcherdialog
"""
Description
===========

The idea of `SwitcherDialog` is to make it easier to implement keyboard
navigation in AUI and other applications that have multiple panes and
tabs.

A key combination with a modifier (such as ``Ctrl`` + ``Tab``) shows the
dialog, and the user holds down the modifier whilst navigating with
``Tab`` and arrow keys before releasing the modifier to dismiss the dialog
and activate the selected pane.

The switcher dialog is a multi-column menu with no scrolling, implemented
by the :class:`MultiColumnListCtrl` class. You can have headings for your items
for logical grouping, and you can force a column break if you need to.

The modifier used for invoking and dismissing the dialog can be customised,
as can the colours, number of rows, and the key used for cycling through
the items. So you can use different keys on different platforms if
required (especially since ``Ctrl`` + ``Tab`` is reserved on some platforms).

Items are shown as names and optional 16x16 images.


Base Functionalities
====================

To use the dialog, you set up the items in a `SwitcherItems` object,
before passing this to the `SwitcherDialog` instance.

Call :meth:`SwitcherItems.AddItem` and optionally :meth:`SwitcherItems.AddGroup`
to add items and headings. These functions take a label (to be displayed to the user),
an identifying name, an integer id, and a bitmap. The name and id are purely for
application-defined identification. You may also set a description to be displayed
when each item is selected; and you can set a window pointer for convenience when
activating the desired window after the dialog returns.

Have created the dialog, you call :meth:`~Dialog.ShowModal`, and if the return value is
``wx.ID_OK``, retrieve the selection from the dialog and activate the pane.

The sample code below shows a generic method of finding panes and notebook
tabs within the current :class:`~lib.agw.aui.framemanager.AuiManager`, and using the pane name or notebook
tab position to display the pane.

The only other code to add is a menu item with the desired accelerator,
whose modifier matches the one you pass to :meth:`SwitcherDialog.SetModifierKey` 
(the default being ``wx.WXK_CONTROL``).


Usage
=====

Menu item::

    if wx.Platform == "__WXMAC__":
        switcherAccel = "Alt+Tab"
    elif wx.Platform == "__WXGTK__":
        switcherAccel = "Ctrl+/"
    else:
        switcherAccel = "Ctrl+Tab"

    view_menu.Append(ID_SwitchPane, _("S&witch Window...") + "\t" + switcherAccel)


Event handler::

    def OnSwitchPane(self, event):

        items = SwitcherItems()
        items.SetRowCount(12)

        # Add the main windows and toolbars, in two separate columns
        # We'll use the item 'id' to store the notebook selection, or -1 if not a page

        for k in xrange(2):
            if k == 0:
                items.AddGroup(_("Main Windows"), "mainwindows")
            else:
                items.AddGroup(_("Toolbars"), "toolbars").BreakColumn()

            for pane in self._mgr.GetAllPanes():
                name = pane.name
                caption = pane.caption

                toolbar = isinstance(info.window, wx.ToolBar) or isinstance(info.window, aui.AuiToolBar)
                if caption and (toolBar  and k == 1) or (not toolBar and k == 0):
                    items.AddItem(caption, name, -1).SetWindow(pane.window)

        # Now add the wxAuiNotebook pages

        items.AddGroup(_("Notebook Pages"), "pages").BreakColumn()

        for pane in self._mgr.GetAllPanes():
            nb = pane.window
            if isinstance(nb, aui.AuiNotebook):
                for j in xrange(nb.GetPageCount()):

                    name = nb.GetPageText(j)
                    win = nb.GetPage(j)

                    items.AddItem(name, name, j, nb.GetPageBitmap(j)).SetWindow(win)

        # Select the focused window

        idx = items.GetIndexForFocus()
        if idx != wx.NOT_FOUND:
            items.SetSelection(idx)

        if wx.Platform == "__WXMAC__":
            items.SetBackgroundColour(wx.WHITE)
        
        # Show the switcher dialog

        dlg = SwitcherDialog(items, wx.GetApp().GetTopWindow())

        # In GTK+ we can't use Ctrl+Tab; we use Ctrl+/ instead and tell the switcher
        # to treat / in the same was as tab (i.e. cycle through the names)

        if wx.Platform == "__WXGTK__":
            dlg.SetExtraNavigationKey(wxT('/'))

        if wx.Platform == "__WXMAC__":
            dlg.SetBackgroundColour(wx.WHITE)
            dlg.SetModifierKey(wx.WXK_ALT)

        ans = dlg.ShowModal()

        if ans == wx.ID_OK and dlg.GetSelection() != -1:
            item = items.GetItem(dlg.GetSelection())

            if item.GetId() == -1:
                info = self._mgr.GetPane(item.GetName())
                info.Show()
                self._mgr.Update()
                info.window.SetFocus()

            else:
                nb = item.GetWindow().GetParent()
                win = item.GetWindow();
                if isinstance(nb, aui.AuiNotebook):
                    nb.SetSelection(item.GetId())
                    win.SetFocus()


"""

import wx

import auibook
from aui_utilities import FindFocusDescendant
from aui_constants import SWITCHER_TEXT_MARGIN_X, SWITCHER_TEXT_MARGIN_Y


# Define a translation function
_ = wx.GetTranslation

    
class SwitcherItem(object):
    """ An object containing information about one item. """
    
    def __init__(self, item=None):
        """ Default class constructor. """

        self._id = 0
        self._isGroup = False
        self._breakColumn = False
        self._rowPos = 0
        self._colPos = 0
        self._window = None
        self._description = ""

        self._textColour = wx.NullColour
        self._bitmap = wx.NullBitmap
        self._font = wx.NullFont
        
        if item:
            self.Copy(item)


    def Copy(self, item):
        """
        Copy operator between 2 :class:`SwitcherItem` instances.

        :param `item`: another instance of :class:`SwitcherItem`.
        """

        self._id = item._id
        self._name = item._name
        self._title = item._title
        self._isGroup = item._isGroup
        self._breakColumn = item._breakColumn
        self._rect = item._rect
        self._font = item._font
        self._textColour = item._textColour
        self._bitmap = item._bitmap
        self._description = item._description
        self._rowPos = item._rowPos
        self._colPos = item._colPos
        self._window = item._window


    def SetTitle(self, title):

        self._title = title
        return self
    

    def GetTitle(self):
        
        return self._title


    def SetName(self, name):

        self._name = name
        return self

    
    def GetName(self):

        return self._name


    def SetDescription(self, descr):

        self._description = descr
        return self


    def GetDescription(self):

        return self._description
    

    def SetId(self, id):

        self._id = id
        return self

    
    def GetId(self):

        return self._id


    def SetIsGroup(self, isGroup):

        self._isGroup = isGroup
        return self

    
    def GetIsGroup(self):

        return self._isGroup
    

    def BreakColumn(self, breakCol=True):

        self._breakColumn = breakCol
        return self

    
    def GetBreakColumn(self):

        return self._breakColumn


    def SetRect(self, rect):

        self._rect = rect
        return self

    
    def GetRect(self):
        
        return self._rect


    def SetTextColour(self, colour):

        self._textColour = colour
        return self

    
    def GetTextColour(self):

        return self._textColour
    

    def SetFont(self, font):

        self._font = font
        return self

    
    def GetFont(self):

        return self._font
    

    def SetBitmap(self, bitmap):

        self._bitmap = bitmap
        return self

    
    def GetBitmap(self):

        return self._bitmap


    def SetRowPos(self, pos):

        self._rowPos = pos
        return self

    
    def GetRowPos(self):

        return self._rowPos
    

    def SetColPos(self, pos):

        self._colPos = pos
        return self

    
    def GetColPos(self):

        return self._colPos
    

    def SetWindow(self, win):

        self._window = win
        return self
    

    def GetWindow(self):

        return self._window

    
class SwitcherItems(object):
    """ An object containing switcher items. """

    def __init__(self, items=None):
        """ Default class constructor. """

        self._selection = -1
        self._rowCount = 10
        self._columnCount = 0

        self._backgroundColour = wx.NullColour
        self._textColour = wx.NullColour
        self._selectionColour = wx.NullColour
        self._selectionOutlineColour = wx.NullColour
        self._itemFont = wx.NullFont

        self._items = []        
        
        if wx.Platform == "__WXMSW__":
            # If on Windows XP/Vista, use more appropriate colours
            self.SetSelectionOutlineColour(wx.Colour(49, 106, 197))
            self.SetSelectionColour(wx.Colour(193, 210, 238))

        if items:
            self.Copy(items)
            

    def Copy(self, items):
        """
        Copy operator between 2 :class:`SwitcherItems`.

        :param `items`: another instance of :class:`SwitcherItems`.
        """
        
        self.Clear()

        for item in items._items:
            self._items.append(item)
        
        self._selection = items._selection
        self._rowCount = items._rowCount
        self._columnCount = items._columnCount

        self._backgroundColour = items._backgroundColour
        self._textColour = items._textColour
        self._selectionColour = items._selectionColour
        self._selectionOutlineColour = items._selectionOutlineColour
        self._itemFont = items._itemFont


    def AddItem(self, titleOrItem, name=None, id=0, bitmap=wx.NullBitmap):

        if isinstance(titleOrItem, SwitcherItem):
            self._items.append(titleOrItem)
            return self._items[-1]
        
        item = SwitcherItem()
        item.SetTitle(titleOrItem)
        item.SetName(name)
        item.SetId(id)
        item.SetBitmap(bitmap)

        self._items.append(item)
        return self._items[-1]


    def AddGroup(self, title, name, id=0, bitmap=wx.NullBitmap):

        item = self.AddItem(title, name, id, bitmap)
        item.SetIsGroup(True)

        return item


    def Clear(self):

        self._items = []


    def FindItemByName(self, name):

        for i in xrange(len(self._items)):
            if self._items[i].GetName() == name:
                return i
        
        return wx.NOT_FOUND


    def FindItemById(self, id):

        for i in xrange(len(self._items)):
            if self._items[i].GetId() == id:
                return i
        
        return wx.NOT_FOUND


    def SetSelection(self, sel):

        self._selection = sel


    def SetSelectionByName(self, name):

        idx = self.FindItemByName(name)
        if idx != wx.NOT_FOUND:
            self.SetSelection(idx)


    def GetSelection(self):

        return self._selection
    

    def GetItem(self, i):

        return self._items[i]


    def GetItemCount(self):

        return len(self._items)
    

    def SetRowCount(self, rows):

        self._rowCount = rows

        
    def GetRowCount(self):

        return self._rowCount


    def SetColumnCount(self, cols):

        self._columnCount = cols

        
    def GetColumnCount(self):

        return self._columnCount
    

    def SetBackgroundColour(self, colour):

        self._backgroundColour = colour

        
    def GetBackgroundColour(self):

        return self._backgroundColour
    

    def SetTextColour(self, colour):

        self._textColour = colour

        
    def GetTextColour(self):

        return self._textColour
    

    def SetSelectionColour(self, colour):

        self._selectionColour = colour

        
    def GetSelectionColour(self):

        return self._selectionColour
    

    def SetSelectionOutlineColour(self, colour):

        self._selectionOutlineColour = colour

        
    def GetSelectionOutlineColour(self):

        return self._selectionOutlineColour
    

    def SetItemFont(self, font):

        self._itemFont = font

        
    def GetItemFont(self):

        return self._itemFont 
    

    def PaintItems(self, dc, win):

        backgroundColour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DFACE)
        standardTextColour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT)
        selectionColour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_HIGHLIGHT)
        selectionOutlineColour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT)
        standardFont = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        groupFont = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        groupFont.SetWeight(wx.BOLD)

        if self.GetBackgroundColour().IsOk():
            backgroundColour = self.GetBackgroundColour()

        if self.GetTextColour().IsOk():
            standardTextColour = self.GetTextColour()

        if self.GetSelectionColour().IsOk():
            selectionColour = self.GetSelectionColour()

        if self.GetSelectionOutlineColour().IsOk():
            selectionOutlineColour = self.GetSelectionOutlineColour()

        if self.GetItemFont().IsOk():
        
            standardFont = self.GetItemFont()   
            groupFont = wx.Font(standardFont.GetPointSize(), standardFont.GetFamily(), standardFont.GetStyle(),
                                wx.BOLD, standardFont.GetUnderlined(), standardFont.GetFaceName())
        
        textMarginX = SWITCHER_TEXT_MARGIN_X

        dc.SetLogicalFunction(wx.COPY)
        dc.SetBrush(wx.Brush(backgroundColour))
        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.DrawRectangleRect(win.GetClientRect())
        dc.SetBackgroundMode(wx.TRANSPARENT)

        for i in xrange(len(self._items)):
            item = self._items[i]
            if i == self._selection:
                dc.SetPen(wx.Pen(selectionOutlineColour))
                dc.SetBrush(wx.Brush(selectionColour))
                dc.DrawRectangleRect(item.GetRect())
            
            clippingRect = wx.Rect(*item.GetRect())
            clippingRect.Deflate(1, 1)

            dc.SetClippingRect(clippingRect)

            if item.GetTextColour().IsOk():
                dc.SetTextForeground(item.GetTextColour())
            else:
                dc.SetTextForeground(standardTextColour)
            
            if item.GetFont().IsOk():
                dc.SetFont(item.GetFont())
            else:
                if item.GetIsGroup():
                    dc.SetFont(groupFont)
                else:
                    dc.SetFont(standardFont)
            
            w, h = dc.GetTextExtent(item.GetTitle())
            x = item.GetRect().x

            x += textMarginX

            if not item.GetIsGroup():
                if item.GetBitmap().IsOk() and item.GetBitmap().GetWidth() <= 16 \
                   and item.GetBitmap().GetHeight() <= 16:
                    x -= textMarginX
                    dc.DrawBitmap(item.GetBitmap(), x, item.GetRect().y + \
                                  (item.GetRect().height - item.GetBitmap().GetHeight())/2,
                                  True)
                    x += 16 + textMarginX
                #x += textMarginX
            
            y = item.GetRect().y + (item.GetRect().height - h)/2
            dc.DrawText(item.GetTitle(), x, y)
            dc.DestroyClippingRegion()
    

    def CalculateItemSize(self, dc):

        # Start off allowing for an icon
        sz = wx.Size(150, 16)
        standardFont = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        groupFont = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        groupFont.SetWeight(wx.BOLD)

        textMarginX = SWITCHER_TEXT_MARGIN_X
        textMarginY = SWITCHER_TEXT_MARGIN_Y
        maxWidth = 300
        maxHeight = 40

        if self.GetItemFont().IsOk():
            standardFont = self.GetItemFont()   

        for item in self._items:
            if item.GetFont().IsOk():
                dc.SetFont(item.GetFont())
            else:
                if item.GetIsGroup():
                    dc.SetFont(groupFont)
                else:
                    dc.SetFont(standardFont)

            w, h = dc.GetTextExtent(item.GetTitle())
            w += 16 + 2*textMarginX

            if w > sz.x:
                sz.x = min(w, maxWidth)
            if h > sz.y:
                sz.y = min(h, maxHeight)
        
        if sz == wx.Size(16, 16):
            sz = wx.Size(100, 25)
        else:
            sz.x += textMarginX*2
            sz.y += textMarginY*2
        
        return sz


    def GetIndexForFocus(self):

        for i, item in enumerate(self._items):        
            if item.GetWindow():
            
                if FindFocusDescendant(item.GetWindow()):
                    return i
            
        return wx.NOT_FOUND


class MultiColumnListCtrl(wx.PyControl):
    """ A control for displaying several columns (not scrollable). """

    def __init__(self, parent, aui_manager, id=wx.ID_ANY, pos=wx.DefaultPosition, size=wx.DefaultSize,
                 style=0, validator=wx.DefaultValidator, name="MultiColumnListCtrl"):

        wx.PyControl.__init__(self, parent, id, pos, size, style, validator, name)

        self._overallSize = wx.Size(200, 100)
        self._modifierKey = wx.WXK_CONTROL
        self._extraNavigationKey = 0
        self._aui_manager = aui_manager
        
        self.SetInitialSize(size)
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)

        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_MOUSE_EVENTS, self.OnMouseEvent)
        self.Bind(wx.EVT_CHAR, self.OnChar)
        self.Bind(wx.EVT_KEY_DOWN, self.OnKey)
        self.Bind(wx.EVT_KEY_UP, self.OnKey)


    def __del__(self):

        self._aui_manager.HideHint()

        
    def DoGetBestSize(self):

        return self._overallSize


    def OnEraseBackground(self, event):
        
        pass


    def OnPaint(self, event):

        dc = wx.AutoBufferedPaintDC(self)
        rect = self.GetClientRect()

        if self._items.GetColumnCount() == 0:
            self.CalculateLayout(dc)

        if self._items.GetColumnCount() == 0:
            return

        self._items.PaintItems(dc, self)


    def OnMouseEvent(self, event):

        if event.LeftDown():
            self.SetFocus()
    

    def OnChar(self, event):

        event.Skip()        


    def OnKey(self, event):

        if event.GetEventType() == wx.wxEVT_KEY_UP:
            if event.GetKeyCode() == self.GetModifierKey():
                topLevel = wx.GetTopLevelParent(self)
                closeEvent = wx.CloseEvent(wx.wxEVT_CLOSE_WINDOW, topLevel.GetId())
                closeEvent.SetEventObject(topLevel)
                closeEvent.SetCanVeto(False)
                
                topLevel.GetEventHandler().ProcessEvent(closeEvent)
                return
                
            event.Skip()
            return

        keyCode = event.GetKeyCode()
        
        if keyCode in [wx.WXK_ESCAPE, wx.WXK_RETURN]:
            if keyCode == wx.WXK_ESCAPE:
                self._items.SetSelection(-1)

            topLevel = wx.GetTopLevelParent(self)
            closeEvent = wx.CloseEvent(wx.wxEVT_CLOSE_WINDOW, topLevel.GetId())
            closeEvent.SetEventObject(topLevel)
            closeEvent.SetCanVeto(False)
            
            topLevel.GetEventHandler().ProcessEvent(closeEvent)
            return
        
        elif keyCode in [wx.WXK_TAB, self.GetExtraNavigationKey()]:
            if event.ShiftDown():
            
                self._items.SetSelection(self._items.GetSelection() - 1)
                if self._items.GetSelection() < 0:
                    self._items.SetSelection(self._items.GetItemCount() - 1)

                self.AdvanceToNextSelectableItem(-1)
            
            else:
            
                self._items.SetSelection(self._items.GetSelection() + 1)
                if self._items.GetSelection() >= self._items.GetItemCount():
                    self._items.SetSelection(0)

                self.AdvanceToNextSelectableItem(1)
            
            self.GenerateSelectionEvent()
            self.Refresh()
        
        elif keyCode in [wx.WXK_DOWN, wx.WXK_NUMPAD_DOWN]:
            self._items.SetSelection(self._items.GetSelection() + 1)
            if self._items.GetSelection() >= self._items.GetItemCount():
                self._items.SetSelection(0)
            
            self.AdvanceToNextSelectableItem(1)
            self.GenerateSelectionEvent()
            self.Refresh()
        
        elif keyCode in [wx.WXK_UP, wx.WXK_NUMPAD_UP]:
            self._items.SetSelection(self._items.GetSelection() - 1)
            if self._items.GetSelection() < 0:
                self._items.SetSelection(self._items.GetItemCount() - 1)
            
            self.AdvanceToNextSelectableItem(-1)
            self.GenerateSelectionEvent()
            self.Refresh()
        
        elif keyCode in [wx.WXK_HOME, wx.WXK_NUMPAD_HOME]:
            self._items.SetSelection(0)
            self.AdvanceToNextSelectableItem(1)
            self.GenerateSelectionEvent()
            self.Refresh()
        
        elif keyCode in [wx.WXK_END, wx.WXK_NUMPAD_END]:
            self._items.SetSelection(self._items.GetItemCount() - 1)
            self.AdvanceToNextSelectableItem(-1)
            self.GenerateSelectionEvent()
            self.Refresh()
        
        elif keyCode in [wx.WXK_LEFT, wx.WXK_NUMPAD_LEFT]:
            item = self._items.GetItem(self._items.GetSelection())

            row = item.GetRowPos()
            newCol = item.GetColPos() - 1
            if newCol < 0:
                newCol = self._items.GetColumnCount() - 1

            # Find the first item from the end whose row matches and whose column is equal or lower
            for i in xrange(self._items.GetItemCount()-1, -1, -1):
                item2 = self._items.GetItem(i)
                if item2.GetColPos() == newCol and item2.GetRowPos() <= row:
                    self._items.SetSelection(i)
                    break

            self.AdvanceToNextSelectableItem(-1)
            self.GenerateSelectionEvent()
            self.Refresh()
        
        elif keyCode in [wx.WXK_RIGHT, wx.WXK_NUMPAD_RIGHT]:
            item = self._items.GetItem(self._items.GetSelection())

            row = item.GetRowPos()
            newCol = item.GetColPos() + 1
            if newCol >= self._items.GetColumnCount():
                newCol = 0

            # Find the first item from the end whose row matches and whose column is equal or lower
            for i in xrange(self._items.GetItemCount()-1, -1, -1):
                item2 = self._items.GetItem(i)
                if item2.GetColPos() == newCol and item2.GetRowPos() <= row:
                    self._items.SetSelection(i)
                    break

            self.AdvanceToNextSelectableItem(1)
            self.GenerateSelectionEvent()
            self.Refresh()
        
        else:
            event.Skip()


    def AdvanceToNextSelectableItem(self, direction):

        if self._items.GetItemCount() < 2:
            return

        if self._items.GetSelection() == -1:
            self._items.SetSelection(0)

        oldSel = self._items.GetSelection()

        while 1:
        
            if self._items.GetItem(self._items.GetSelection()).GetIsGroup():
            
                self._items.SetSelection(self._items.GetSelection() + direction)
                if self._items.GetSelection() == -1:
                    self._items.SetSelection(self._items.GetItemCount()-1)
                elif self._items.GetSelection() == self._items.GetItemCount():
                    self._items.SetSelection(0)
                if self._items.GetSelection() == oldSel:
                    break
            
            else:
                break

        self.SetTransparency()
        selection = self._items.GetItem(self._items.GetSelection()).GetWindow()
        pane = self._aui_manager.GetPane(selection)

        if not pane.IsOk():
            if isinstance(selection.GetParent(), auibook.AuiNotebook):
                self.SetTransparency(selection)
                self._aui_manager.ShowHint(selection.GetScreenRect())
                wx.CallAfter(self.SetFocus)
                self.SetFocus()
                return
            else:
                self._aui_manager.HideHint()
                return
        if not pane.IsShown():
            self._aui_manager.HideHint()
            return

        self.SetTransparency(selection)
        self._aui_manager.ShowHint(selection.GetScreenRect())
        # NOTE: this is odd but it is the only way for the focus to
        #       work correctly on wxMac...
        wx.CallAfter(self.SetFocus)
        self.SetFocus()        
    

    def SetTransparency(self, selection=None):

        if not self.GetParent().CanSetTransparent():
            return
        
        if selection is not None:
            intersects = False
            if selection.GetScreenRect().Intersects(self.GetParent().GetScreenRect()):
                intersects = True
                self.GetParent().SetTransparent(200)
                return

        self.GetParent().SetTransparent(255)


    def GenerateSelectionEvent(self):

        event = wx.CommandEvent(wx.wxEVT_COMMAND_LISTBOX_SELECTED, self.GetId())
        event.SetEventObject(self)
        event.SetInt(self._items.GetSelection())
        self.GetEventHandler().ProcessEvent(event)


    def CalculateLayout(self, dc=None):

        if dc is None:
            dc = wx.ClientDC(self)

        if self._items.GetSelection() == -1:
            self._items.SetSelection(0)

        columnCount = 1

        # Spacing between edge of window or between columns
        xMargin = 4
        yMargin = 4

        # Inter-row spacing
        rowSpacing = 2

        itemSize = self._items.CalculateItemSize(dc)
        self._overallSize = wx.Size(350, 200)

        currentRow = 0
        x = xMargin
        y = yMargin

        breaking = False
        i = 0
        
        while 1:
        
            oldOverallSize = self._overallSize
            item = self._items.GetItem(i)
            
            item.SetRect(wx.Rect(x, y, itemSize.x, itemSize.y))
            item.SetColPos(columnCount-1)
            item.SetRowPos(currentRow)

            if item.GetRect().GetBottom() > self._overallSize.y:
                self._overallSize.y = item.GetRect().GetBottom() + yMargin

            if item.GetRect().GetRight() > self._overallSize.x:
                self._overallSize.x = item.GetRect().GetRight() + xMargin

            currentRow += 1

            y += rowSpacing + itemSize.y
            stopBreaking = breaking

            if currentRow > self._items.GetRowCount() or (item.GetBreakColumn() and not breaking and currentRow != 1):
                currentRow = 0
                columnCount += 1
                x += xMargin + itemSize.x
                y = yMargin

                # Make sure we don't orphan a group
                if item.GetIsGroup() or (item.GetBreakColumn() and not breaking):
                    self._overallSize = oldOverallSize

                    if item.GetBreakColumn():
                        breaking = True

                    # Repeat the last item, in the next column
                    i -= 1
                
            if stopBreaking:
                breaking = False

            i += 1
            
            if i >= self._items.GetItemCount():
                break
            
        self._items.SetColumnCount(columnCount)
        self.InvalidateBestSize()


    def SetItems(self, items):
        
        self._items = items

        
    def GetItems(self):

        return self._items

 
    def SetExtraNavigationKey(self, keyCode):
        """
        Set an extra key that can be used to cycle through items,
        in case not using the ``Ctrl`` + ``Tab`` combination.
        """

        self._extraNavigationKey = keyCode


    def GetExtraNavigationKey(self):

        return self._extraNavigationKey


    def SetModifierKey(self, modifierKey):
        """
        Set the modifier used to invoke the dialog, and therefore to test for release.
        """

        self._modifierKey = modifierKey

        
    def GetModifierKey(self):

        return self._modifierKey

    

class SwitcherDialog(wx.Dialog):
    """
    SwitcherDialog shows a :class:`Dialog` with a list of panes and tabs for the user to choose.
    ``Ctrl`` + ``Tab`` cycles through them.
    """

    def __init__(self, items, parent, aui_manager, id=wx.ID_ANY, title=_("Pane Switcher"), pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=wx.STAY_ON_TOP|wx.DIALOG_NO_PARENT|wx.BORDER_SIMPLE):
        """ Default class constructor. """
        
        self._switcherBorderStyle = (style & wx.BORDER_MASK)
        if self._switcherBorderStyle == wx.BORDER_NONE:
            self._switcherBorderStyle = wx.BORDER_SIMPLE

        style &= wx.BORDER_MASK
        style |= wx.BORDER_NONE

        wx.Dialog.__init__(self, parent, id, title, pos, size, style)

        self._listCtrl = MultiColumnListCtrl(self, aui_manager,
                                             style=wx.WANTS_CHARS|wx.NO_BORDER)
        self._listCtrl.SetItems(items)
        self._listCtrl.CalculateLayout()

        self._descriptionCtrl = wx.html.HtmlWindow(self, size=(-1, 100), style=wx.BORDER_NONE)
        self._descriptionCtrl.SetBackgroundColour(self.GetBackgroundColour())

        if wx.Platform == "__WXGTK__":
            fontSize = 11
            self._descriptionCtrl.SetStandardFonts(fontSize)

        sizer = wx.BoxSizer(wx.VERTICAL)
        self.SetSizer(sizer)
        sizer.Add(self._listCtrl, 1, wx.ALL|wx.EXPAND, 10)
        sizer.Add(self._descriptionCtrl, 0, wx.ALL|wx.EXPAND, 10)
        sizer.SetSizeHints(self)

        self._listCtrl.SetFocus()

        self.Centre(wx.BOTH)

        if self._listCtrl.GetItems().GetSelection() == -1:
            self._listCtrl.GetItems().SetSelection(0)

        self._listCtrl.AdvanceToNextSelectableItem(1)

        self.ShowDescription(self._listCtrl.GetItems().GetSelection())

        self.Bind(wx.EVT_CLOSE, self.OnCloseWindow)
        self.Bind(wx.EVT_ACTIVATE, self.OnActivate)
        self.Bind(wx.EVT_LISTBOX, self.OnSelectItem)
        self.Bind(wx.EVT_PAINT, self.OnPaint)

        # Attributes
        self._closing = False
        if wx.Platform == "__WXMSW__":
            self._borderColour = wx.Colour(49, 106, 197)
        else:
            self._borderColour = wx.BLACK

        self._aui_manager = aui_manager
        

    def OnCloseWindow(self, event):

        if self._closing:
            return

        if self.IsModal():
            self._closing = True

            if self.GetSelection() == -1:
                self.EndModal(wx.ID_CANCEL)
            else:
                self.EndModal(wx.ID_OK)
    
        self._aui_manager.HideHint()


    def GetSelection(self):

        return self._listCtrl.GetItems().GetSelection()


    def OnActivate(self, event):

        if not event.GetActive():
            if not self._closing:
                self._closing = True
                self.EndModal(wx.ID_CANCEL)
            

    def OnPaint(self, event):

        dc = wx.PaintDC(self)

        if self._switcherBorderStyle == wx.BORDER_SIMPLE:
        
            dc.SetPen(wx.Pen(self._borderColour))
            dc.SetBrush(wx.TRANSPARENT_BRUSH)

            rect = self.GetClientRect()
            dc.DrawRectangleRect(rect)

            # Draw border around the HTML control
            rect = wx.Rect(*self._descriptionCtrl.GetRect())
            rect.Inflate(1, 1)
            dc.DrawRectangleRect(rect)

    
    def OnSelectItem(self, event):

        self.ShowDescription(event.GetSelection())


    # Convert a colour to a 6-digit hex string
    def ColourToHexString(self, col):

        hx = '%02x%02x%02x' % tuple([int(c) for c in col])
        return hx


    def ShowDescription(self, i):

        item = self._listCtrl.GetItems().GetItem(i)
        colour = self._listCtrl.GetItems().GetBackgroundColour()
        
        if not colour.IsOk():
            colour = self.GetBackgroundColour()

        backgroundColourHex = self.ColourToHexString(colour)
        html = _("<body bgcolor=\"#") + backgroundColourHex + _("\"><b>") + item.GetTitle() + _("</b>")

        if item.GetDescription():
            html += _("<p>")
            html += item.GetDescription()
        
        html += _("</body>")
        self._descriptionCtrl.SetPage(html)


    def SetExtraNavigationKey(self, keyCode):

        self._extraNavigationKey = keyCode
        if self._listCtrl:
            self._listCtrl.SetExtraNavigationKey(keyCode)


    def GetExtraNavigationKey(self):

        return self._extraNavigationKey
    
        
    def SetModifierKey(self, modifierKey):

        self._modifierKey = modifierKey
        if self._listCtrl:
            self._listCtrl.SetModifierKey(modifierKey)


    def GetModifierKey(self):

        return self._modifierKey        


    def SetBorderColour(self, colour):

        self._borderColour = colour

        
########NEW FILE########
__FILENAME__ = aui_utilities
"""
This module contains some common functions used by :mod:`lib.agw.aui` to
manipulate colours, bitmaps, text, gradient shadings and custom dragging images
for :class:`~lib.agw.aui.auibook.AuiNotebook` tabs.
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx

from aui_constants import *


if wx.Platform == "__WXMAC__":
    import Carbon.Appearance
    
    
def BlendColour(fg, bg, alpha):
    """
    Blends the two colour component `fg` and `bg` into one colour component, adding
    an optional alpha channel.

    :param Colour `fg`: the first colour component;
    :param Colour `bg`: the second colour component;
    :param integer `alpha`: an optional transparency value.
    """
    
    result = bg + (alpha*(fg - bg))
    
    if result < 0.0:
        result = 0.0
    if result > 255:
        result = 255
        
    return result


def StepColour(c, ialpha):
    """
    Darken/lighten the input colour `c`.

    :param Colour `c`: a colour to darken/lighten;
    :param integer `ialpha`: a transparency value.
    """
    
    if ialpha == 100:
        return c
        
    r, g, b = c.Red(), c.Green(), c.Blue()

    # ialpha is 0..200 where 0 is completely black
    # and 200 is completely white and 100 is the same
    # convert that to normal alpha 0.0 - 1.0
    ialpha = min(ialpha, 200)
    ialpha = max(ialpha, 0)
    alpha = (ialpha - 100.0)/100.0

    if ialpha > 100:
    
        # blend with white
        bg = 255
        alpha = 1.0 - alpha  # 0 = transparent fg 1 = opaque fg
    
    else:
    
        # blend with black
        bg = 0
        alpha = 1.0 + alpha  # 0 = transparent fg 1 = opaque fg
    
    r = BlendColour(r, bg, alpha)
    g = BlendColour(g, bg, alpha)
    b = BlendColour(b, bg, alpha)

    return wx.Colour(r, g, b)


def LightContrastColour(c):
    """
    Creates a new, lighter colour based on the input colour `c`.

    :param Colour `c`: the input colour to analyze.
    """

    amount = 120

    # if the colour is especially dark, then
    # make the contrast even lighter
    if c.Red() < 128 and c.Green() < 128 and c.Blue() < 128:
        amount = 160

    return StepColour(c, amount)


def ChopText(dc, text, max_size):
    """
    Chops the input `text` if its size does not fit in `max_size`, by cutting the
    text and adding ellipsis at the end.

    :param `dc`: a :class:`DC` device context;
    :param string `text`: the text to chop;
    :param integer `max_size`: the maximum size in which the text should fit.
    """
    
    # first check if the text fits with no problems
    x, y, dummy = dc.GetMultiLineTextExtent(text)
    
    if x <= max_size:
        return text

    textLen = len(text)
    last_good_length = 0
    
    for i in xrange(textLen, -1, -1):
        s = text[0:i]
        s += "..."

        x, y = dc.GetTextExtent(s)
        last_good_length = i
        
        if x < max_size:
            break

    ret = text[0:last_good_length] + "..."    
    return ret


def BitmapFromBits(bits, w, h, colour):
    """
    A utility function that creates a masked bitmap from raw bits (XBM format).

    :param string `bits`: the raw bits of the bitmap;
    :param integer `w`: the bitmap width;
    :param integer `h`: the bitmap height;
    :param Colour `colour`: the colour which will replace all white pixels in the
     raw bitmap.
    """

    img = wx.BitmapFromBits(bits, w, h).ConvertToImage()
    img.Replace(0, 0, 0, 123, 123, 123)
    img.Replace(255, 255, 255, colour.Red(), colour.Green(), colour.Blue())
    img.SetMaskColour(123, 123, 123)
    return wx.BitmapFromImage(img)


def IndentPressedBitmap(rect, button_state):
    """
    Indents the input rectangle `rect` based on the value of `button_state`.

    :param Rect `rect`: the button bitmap rectangle;
    :param integer `button_state`: the button state.
    """

    if button_state == AUI_BUTTON_STATE_PRESSED:
        rect.x += 1
        rect.y += 1

    return rect


def GetBaseColour():
    """
    Returns the face shading colour on push buttons/backgrounds,
    mimicking as closely as possible the platform UI colours.
    """

    if wx.Platform == "__WXMAC__":

        if hasattr(wx, 'MacThemeColour'):
            base_colour = wx.MacThemeColour(Carbon.Appearance.kThemeBrushToolbarBackground)
        else:
            brush = wx.Brush(wx.BLACK)
            brush.MacSetTheme(Carbon.Appearance.kThemeBrushToolbarBackground)
            base_colour = brush.GetColour()

    else:
        
        base_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DFACE)

    # the base_colour is too pale to use as our base colour,
    # so darken it a bit
    if ((255-base_colour.Red()) +
        (255-base_colour.Green()) +
        (255-base_colour.Blue()) < 60):
    
        base_colour = StepColour(base_colour, 92)
    
    return base_colour


def MakeDisabledBitmap(bitmap):
    """
    Convert the given image (in place) to a grayed-out version, appropriate for a 'disabled' appearance.

    :param Bitmap `bitmap`: the bitmap to gray-out.
    """

    anImage = bitmap.ConvertToImage()    
    factor = 0.7        # 0 < f < 1.  Higher Is Grayer
    
    if anImage.HasMask():
        maskColour = (anImage.GetMaskRed(), anImage.GetMaskGreen(), anImage.GetMaskBlue())
    else:
        maskColour = None
        
    data = map(ord, list(anImage.GetData()))

    for i in range(0, len(data), 3):
        
        pixel = (data[i], data[i+1], data[i+2])
        pixel = MakeGray(pixel, factor, maskColour)

        for x in range(3):
            data[i+x] = pixel[x]

    anImage.SetData(''.join(map(chr, data)))
    
    return anImage.ConvertToBitmap()


def MakeGray(rgbTuple, factor, maskColour):
    """
    Make a pixel grayed-out.

    If the pixel matches the `maskColour`, it won't be changed.

    :param tuple `rgbTuple`: a tuple representing a pixel colour;
    :param integer `factor`: a graying-out factor;
    :param Colour `maskColour`: a colour mask.
    """

    if rgbTuple != maskColour:
        r, g, b = rgbTuple
        return map(lambda x: int((230 - x) * factor) + x, (r, g, b))
    else:
        return rgbTuple


def Clip(a, b, c):
    """
    Clips the value in `a` based on the extremes `b` and `c`.

    :param `a`: the value to analyze;
    :param `b`: a minimum value;
    :param `c`: a maximum value.
    """

    return ((a < b and [b]) or [(a > c and [c] or [a])[0]])[0]


def LightColour(colour, percent):
    """
    Brighten input `colour` by `percent`.

    :param Colour `colour`: the colour to be brightened;
    :param integer `percent`: brightening percentage.
    """
    
    end_colour = wx.WHITE
    
    rd = end_colour.Red() - colour.Red()
    gd = end_colour.Green() - colour.Green()
    bd = end_colour.Blue() - colour.Blue()

    high = 100

    # We take the percent way of the colour from colour -. white
    i = percent
    r = colour.Red() + ((i*rd*100)/high)/100
    g = colour.Green() + ((i*gd*100)/high)/100
    b = colour.Blue() + ((i*bd*100)/high)/100
    return wx.Colour(r, g, b)


def PaneCreateStippleBitmap():
    """
    Creates a stipple bitmap to be used in a :class:`Brush`.
    
    This is used to draw sash resize hints.
    """

    data = [0, 0, 0, 192, 192, 192, 192, 192, 192, 0, 0, 0]
    img = wx.EmptyImage(2, 2)
    counter = 0
    
    for ii in xrange(2):
        for jj in xrange(2):
            img.SetRGB(ii, jj, data[counter], data[counter+1], data[counter+2])
            counter = counter + 3
    
    return img.ConvertToBitmap()


def DrawMACCloseButton(colour, backColour=None):
    """
    Draws the wxMAC tab close button using :class:`GraphicsContext`.

    :param Colour `colour`: the colour to use to draw the circle;
    :param Colour `backColour`: the optional background colour for the circle.
    """

    bmp = wx.EmptyBitmapRGBA(16, 16)
    dc = wx.MemoryDC()
    dc.SelectObject(bmp)

    gc = wx.GraphicsContext.Create(dc)    
    gc.SetBrush(wx.Brush(colour))
    path = gc.CreatePath()
    path.AddCircle(6.5, 7, 6.5)
    path.CloseSubpath()
    gc.FillPath(path)
    
    path = gc.CreatePath()
    if backColour is not None:
        pen = wx.Pen(backColour, 2)
    else:
        pen = wx.Pen("white", 2)
        
    pen.SetCap(wx.CAP_BUTT)
    pen.SetJoin(wx.JOIN_BEVEL)
    gc.SetPen(pen)
    path.MoveToPoint(3.5, 4)
    path.AddLineToPoint(9.5, 10)
    path.MoveToPoint(3.5, 10)
    path.AddLineToPoint(9.5, 4)
    path.CloseSubpath()
    gc.DrawPath(path)

    dc.SelectObject(wx.NullBitmap)
    return bmp


def DarkenBitmap(bmp, caption_colour, new_colour):
    """
    Darkens the input bitmap on wxMAC using the input colour.
    
    :param Bitmap `bmp`: the bitmap to be manipulated;
    :param Colour `caption_colour`: the colour of the pane caption;
    :param Colour `new_colour`: the colour used to darken the bitmap.
    """

    image = bmp.ConvertToImage()
    red = caption_colour.Red()/float(new_colour.Red())
    green = caption_colour.Green()/float(new_colour.Green())
    blue = caption_colour.Blue()/float(new_colour.Blue())
    image = image.AdjustChannels(red, green, blue)
    return image.ConvertToBitmap()

    
def DrawGradientRectangle(dc, rect, start_colour, end_colour, direction, offset=0, length=0):
    """
    Draws a gradient-shaded rectangle.

    :param `dc`: a :class:`DC` device context;
    :param Rect `rect`: the rectangle in which to draw the gradient;
    :param Colour `start_colour`: the first colour of the gradient;
    :param Colour `end_colour`: the second colour of the gradient;
    :param integer `direction`: the gradient direction (horizontal or vertical).
    """
    
    if direction == AUI_GRADIENT_VERTICAL:
        dc.GradientFillLinear(rect, start_colour, end_colour, wx.SOUTH)
    else:
        dc.GradientFillLinear(rect, start_colour, end_colour, wx.EAST)
        

def FindFocusDescendant(ancestor):
    """
    Find a window with the focus, that is also a descendant of the given window.
    This is used to determine the window to initially send commands to.

    :param Window `ancestor`: the window to check for ancestry.    
    """

    # Process events starting with the window with the focus, if any.
    focusWin = wx.Window.FindFocus()
    win = focusWin

    # Check if this is a descendant of this frame.
    # If not, win will be set to NULL.
    while win:
        if win == ancestor:
            break
        else:
            win = win.GetParent()

    if win is None:
        focusWin = None

    return focusWin


def GetLabelSize(dc, label, vertical):
    """
    Returns the :class:`~lib.agw.aui.auibar.AuiToolBar` item label size.

    :param string `label`: the toolbar tool label;
    :param bool `vertical`: whether the toolbar tool orientation is vertical or not.
    """

    text_width = text_height = 0

    # get the text height
    dummy, text_height = dc.GetTextExtent("ABCDHgj")
    # get the text width
    if label.strip():
        text_width, dummy = dc.GetTextExtent(label)

    if vertical:
        tmp = text_height
        text_height = text_width
        text_width = tmp

    return wx.Size(text_width, text_height)


#---------------------------------------------------------------------------
# TabDragImage implementation
# This class handles the creation of a custom image when dragging
# AuiNotebook tabs
#---------------------------------------------------------------------------

class TabDragImage(wx.DragImage):
    """
    This class handles the creation of a custom image in case of drag and drop of a notebook tab.
    """

    def __init__(self, notebook, page, button_state, tabArt):
        """
        Default class constructor.
        
        For internal use: do not call it in your code!

        :param `notebook`: an instance of :class:`~lib.agw.aui.auibook.AuiNotebook`;
        :param `page`: the dragged :class:`~lib.agw.aui.auibook.AuiNotebookPage` page;
        :param integer `button_state`: the state of the close button on the tab;
        :param `tabArt`: an instance of :class:`~lib.agw.aui.tabart.AuiDefaultTabArt` or one of its derivations.
        """

        self._backgroundColour = wx.NamedColour("pink")        
        self._bitmap = self.CreateBitmap(notebook, page, button_state, tabArt)
        wx.DragImage.__init__(self, self._bitmap)


    def CreateBitmap(self, notebook, page, button_state, tabArt):
        """
        Actually creates the drag and drop bitmap.

        :param `notebook`: an instance of :class:`~lib.agw.aui.auibook.AuiNotebook`;
        :param `page`: the dragged :class:`~lib.agw.aui.auibook.AuiNotebookPage` page;
        :param integer `button_state`: the state of the close button on the tab;
        :param `tabArt`: an instance of :class:`~lib.agw.aui.tabart.AuiDefaultTabArt` or one of its derivations.
        """

        control = page.control
        memory = wx.MemoryDC(wx.EmptyBitmap(1, 1))

        tab_size, x_extent = tabArt.GetTabSize(memory, notebook, page.caption, page.bitmap, page.active,
                                               button_state, control)
            
        tab_width, tab_height = tab_size
        rect = wx.Rect(0, 0, tab_width, tab_height)

        bitmap = wx.EmptyBitmap(tab_width+1, tab_height+1)
        memory.SelectObject(bitmap)

        if wx.Platform == "__WXMAC__":
            memory.SetBackground(wx.TRANSPARENT_BRUSH)
        else:
            memory.SetBackground(wx.Brush(self._backgroundColour))
            
        memory.SetBackgroundMode(wx.TRANSPARENT)
        memory.Clear()

        paint_control = wx.Platform != "__WXMAC__"
        tabArt.DrawTab(memory, notebook, page, rect, button_state, paint_control=paint_control)
        
        memory.SetBrush(wx.TRANSPARENT_BRUSH)
        memory.SetPen(wx.BLACK_PEN)
        memory.DrawRoundedRectangle(0, 0, tab_width+1, tab_height+1, 2)

        memory.SelectObject(wx.NullBitmap)
        
        # Gtk and Windows unfortunatly don't do so well with transparent
        # drawing so this hack corrects the image to have a transparent
        # background.
        if wx.Platform != '__WXMAC__':
            timg = bitmap.ConvertToImage()
            if not timg.HasAlpha():
                timg.InitAlpha()
            for y in xrange(timg.GetHeight()):
                for x in xrange(timg.GetWidth()):
                    pix = wx.Colour(timg.GetRed(x, y),
                                    timg.GetGreen(x, y),
                                    timg.GetBlue(x, y))
                    if pix == self._backgroundColour:
                        timg.SetAlpha(x, y, 0)
            bitmap = timg.ConvertToBitmap()
        return bitmap        


def GetDockingImage(direction, useAero, center):
    """
    Returns the correct name of the docking bitmap depending on the input parameters.

    :param bool `useAero`: whether :class:`~lib.agw.aui.framemanager.AuiManager` is using
     Aero-style or Whidbey-style docking images or not;
    :param bool `center`: whether we are looking for the center diamond-shaped bitmap or not. 
    """

    suffix = (center and [""] or ["_single"])[0]
    prefix = ""
    if useAero == 2:
        # Whidbey docking guides
        prefix = "whidbey_"
    elif useAero == 1:
        # Aero docking style
        prefix = "aero_"
        
    if direction == wx.TOP:
        bmp_unfocus = eval("%sup%s"%(prefix, suffix)).GetBitmap()
        bmp_focus = eval("%sup_focus%s"%(prefix, suffix)).GetBitmap()
    elif direction == wx.BOTTOM:
        bmp_unfocus = eval("%sdown%s"%(prefix, suffix)).GetBitmap()
        bmp_focus = eval("%sdown_focus%s"%(prefix, suffix)).GetBitmap()
    elif direction == wx.LEFT:
        bmp_unfocus = eval("%sleft%s"%(prefix, suffix)).GetBitmap()
        bmp_focus = eval("%sleft_focus%s"%(prefix, suffix)).GetBitmap()
    elif direction == wx.RIGHT:
        bmp_unfocus = eval("%sright%s"%(prefix, suffix)).GetBitmap()
        bmp_focus = eval("%sright_focus%s"%(prefix, suffix)).GetBitmap()
    else:
        bmp_unfocus = eval("%stab%s"%(prefix, suffix)).GetBitmap()
        bmp_focus = eval("%stab_focus%s"%(prefix, suffix)).GetBitmap()

    return bmp_unfocus, bmp_focus


def TakeScreenShot(rect):
    """
    Takes a screenshot of the screen at given position and size (`rect`).

    :param Rect `rect`: the screen rectangle for which we want to take a screenshot.
    """

    # Create a DC for the whole screen area
    dcScreen = wx.ScreenDC()

    # Create a Bitmap that will later on hold the screenshot image
    # Note that the Bitmap must have a size big enough to hold the screenshot
    # -1 means using the current default colour depth
    bmp = wx.EmptyBitmap(rect.width, rect.height)

    # Create a memory DC that will be used for actually taking the screenshot
    memDC = wx.MemoryDC()

    # Tell the memory DC to use our Bitmap
    # all drawing action on the memory DC will go to the Bitmap now
    memDC.SelectObject(bmp)

    # Blit (in this case copy) the actual screen on the memory DC
    # and thus the Bitmap
    memDC.Blit( 0,            # Copy to this X coordinate
                0,            # Copy to this Y coordinate
                rect.width,   # Copy this width
                rect.height,  # Copy this height
                dcScreen,     # From where do we copy?
                rect.x,       # What's the X offset in the original DC?
                rect.y        # What's the Y offset in the original DC?
                )

    # Select the Bitmap out of the memory DC by selecting a new
    # uninitialized Bitmap
    memDC.SelectObject(wx.NullBitmap)

    return bmp


def RescaleScreenShot(bmp, thumbnail_size=200):
    """
    Rescales a bitmap to be `thumbnail_size` pixels wide (or tall) at maximum.

    :param Bitmap `bmp`: the bitmap to rescale;
    :param integer `thumbnail_size`: the maximum size of every page thumbnail.
    """

    bmpW, bmpH = bmp.GetWidth(), bmp.GetHeight()
    img = bmp.ConvertToImage()

    newW, newH = bmpW, bmpH
    
    if bmpW > bmpH:
        if bmpW > thumbnail_size:
            ratio = bmpW/float(thumbnail_size)
            newW, newH = int(bmpW/ratio), int(bmpH/ratio)
            img.Rescale(newW, newH, wx.IMAGE_QUALITY_HIGH)
    else:
        if bmpH > thumbnail_size:
            ratio = bmpH/float(thumbnail_size)
            newW, newH = int(bmpW/ratio), int(bmpH/ratio)
            img.Rescale(newW, newH, wx.IMAGE_QUALITY_HIGH)

    newBmp = img.ConvertToBitmap()
    otherBmp = wx.EmptyBitmap(newW+5, newH+5)    

    memDC = wx.MemoryDC()
    memDC.SelectObject(otherBmp)
    memDC.SetBackground(wx.WHITE_BRUSH)
    memDC.Clear()
    
    memDC.SetPen(wx.TRANSPARENT_PEN)

    pos = 0
    for i in xrange(5, 0, -1):
        brush = wx.Brush(wx.Colour(50*i, 50*i, 50*i))
        memDC.SetBrush(brush)
        memDC.DrawRoundedRectangle(0, 0, newW+5-pos, newH+5-pos, 2)
        pos += 1

    memDC.DrawBitmap(newBmp, 0, 0, True)
     
    # Select the Bitmap out of the memory DC by selecting a new
    # uninitialized Bitmap
    memDC.SelectObject(wx.NullBitmap)

    return otherBmp


def GetSlidingPoints(rect, size, direction):
    """
    Returns the point at which the sliding in and out of a minimized pane begins.

    :param Rect `rect`: the :class:`~lib.agw.aui.auibar.AuiToolBar` tool screen rectangle;
    :param Size `size`: the pane window size;
    :param integer `direction`: the pane docking direction.
    """

    if direction == AUI_DOCK_LEFT:
        startX, startY = rect.x + rect.width + 2, rect.y
    elif direction == AUI_DOCK_TOP:
        startX, startY = rect.x, rect.y + rect.height + 2
    elif direction == AUI_DOCK_RIGHT:
        startX, startY = rect.x - size.x - 2, rect.y
    elif direction == AUI_DOCK_BOTTOM:
        startX, startY = rect.x, rect.y - size.y - 2
    else:
        raise Exception("How did we get here?")

    caption_height = wx.SystemSettings.GetMetric(wx.SYS_CAPTION_Y)
    frame_border_x = wx.SystemSettings.GetMetric(wx.SYS_FRAMESIZE_X)
    frame_border_y = wx.SystemSettings.GetMetric(wx.SYS_FRAMESIZE_Y)
    
    stopX = size.x + caption_height + frame_border_x
    stopY = size.x + frame_border_y
    
    return startX, startY, stopX, stopY


def CopyAttributes(newArt, oldArt):
    """
    Copies pens, brushes, colours and fonts from the old tab art to the new one.

    :param `newArt`: the new instance of :class:`~lib.agw.aui.tabart.AuiDefaultTabArt`;
    :param `oldArt`: the old instance of :class:`~lib.agw.aui.tabart.AuiDefaultTabArt`.
    """    
    
    attrs = dir(oldArt)

    for attr in attrs:
        if attr.startswith("_") and (attr.endswith("_colour") or attr.endswith("_font") or \
                                     attr.endswith("_font") or attr.endswith("_brush") or \
                                     attr.endswith("Pen") or attr.endswith("_pen")):
            setattr(newArt, attr, getattr(oldArt, attr))

    return newArt            


########NEW FILE########
__FILENAME__ = dockart
"""
Dock art provider code - a dock provider provides all drawing functionality to
the AUI dock manager. This allows the dock manager to have a plugable look-and-feel.

By default, a :class:`~lib.agw.aui.framemanager` uses an instance of this class called :mod:`~lib.agw.aui.dockart`
which provides bitmap art and a colour scheme that is adapted to the major platforms'
look. You can either derive from that class to alter its behaviour or write a
completely new dock art class. Call :meth:`AuiManager.SetArtProvider() <lib.agw.aui.framemanager.AuiManager.SetArtProvider>`
to make use this new dock art.
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx
import types

from aui_utilities import BitmapFromBits, StepColour, ChopText, GetBaseColour
from aui_utilities import DrawGradientRectangle, DrawMACCloseButton
from aui_utilities import DarkenBitmap, LightContrastColour
from aui_constants import *

optionActive = 2**14
""" Indicates that a pane is active and should display an active caption (if present). """

_ctypes = False

# Try to import winxptheme for ModernDockArt
if wx.Platform == "__WXMSW__":
    try:
        import ctypes
        import winxptheme
        _ctypes = True
    except ImportError:
        pass

# -- AuiDefaultDockArt class implementation --

class AuiDefaultDockArt(object):
    """
    Dock art provider code - a dock provider provides all drawing functionality to the AUI dock manager.
    This allows the dock manager to have a plugable look-and-feel.

    By default, a :class:`~lib.agw.aui.framemanager.AuiManager` uses an instance of this class called
    :class:`AuiDefaultDockArt` which provides bitmap art and a colour scheme that is adapted to the major
    platforms' look. You can either derive from that class to alter its behaviour or
    write a completely new dock art class.

    Call :meth:`AuiManager.SetArtProvider() <lib.agw.aui.framemanager.AuiManager.SetArtProvider>`
    to make use this new dock art.


    **Metric Ordinals**

    These are the possible pane dock art settings for :class:`AuiDefaultDockArt`:

    ================================================  ======================================
    Metric Ordinal Constant                           Description
    ================================================  ======================================
    ``AUI_DOCKART_SASH_SIZE``                         Customizes the sash size
    ``AUI_DOCKART_CAPTION_SIZE``                      Customizes the caption size
    ``AUI_DOCKART_GRIPPER_SIZE``                      Customizes the gripper size
    ``AUI_DOCKART_PANE_BORDER_SIZE``                  Customizes the pane border size
    ``AUI_DOCKART_PANE_BUTTON_SIZE``                  Customizes the pane button size
    ``AUI_DOCKART_BACKGROUND_COLOUR``                 Customizes the background colour
    ``AUI_DOCKART_BACKGROUND_GRADIENT_COLOUR``        Customizes the background gradient colour
    ``AUI_DOCKART_SASH_COLOUR``                       Customizes the sash colour
    ``AUI_DOCKART_ACTIVE_CAPTION_COLOUR``             Customizes the active caption colour
    ``AUI_DOCKART_ACTIVE_CAPTION_GRADIENT_COLOUR``    Customizes the active caption gradient colour
    ``AUI_DOCKART_INACTIVE_CAPTION_COLOUR``           Customizes the inactive caption colour
    ``AUI_DOCKART_INACTIVE_CAPTION_GRADIENT_COLOUR``  Customizes the inactive gradient caption colour
    ``AUI_DOCKART_ACTIVE_CAPTION_TEXT_COLOUR``        Customizes the active caption text colour
    ``AUI_DOCKART_INACTIVE_CAPTION_TEXT_COLOUR``      Customizes the inactive caption text colour
    ``AUI_DOCKART_BORDER_COLOUR``                     Customizes the border colour
    ``AUI_DOCKART_GRIPPER_COLOUR``                    Customizes the gripper colour
    ``AUI_DOCKART_CAPTION_FONT``                      Customizes the caption font
    ``AUI_DOCKART_GRADIENT_TYPE``                     Customizes the gradient type (no gradient, vertical or horizontal)
    ``AUI_DOCKART_DRAW_SASH_GRIP``                    Draw a sash grip on the sash
    ``AUI_DOCKART_HINT_WINDOW_COLOUR``                Customizes the hint window background colour (currently light blue)
    ================================================  ======================================


    **Gradient Types**

    These are the possible gradient dock art settings for :class:`AuiDefaultDockArt`:

    ============================================  ======================================
    Gradient Constant                             Description
    ============================================  ======================================
    ``AUI_GRADIENT_NONE``                         No gradient on the captions
    ``AUI_GRADIENT_VERTICAL``                     Vertical gradient on the captions
    ``AUI_GRADIENT_HORIZONTAL``                   Horizontal gradient on the captions
    ============================================  ======================================


    **Button States**

    These are the possible pane button / :class:`~lib.agw.aui.auibook.AuiNotebook` button /
    :class:`~lib.agw.aui.auibar.AuiToolBar` button states:

    ============================================  ======================================
    Button State Constant                         Description
    ============================================  ======================================
    ``AUI_BUTTON_STATE_NORMAL``                   Normal button state
    ``AUI_BUTTON_STATE_HOVER``                    Hovered button state
    ``AUI_BUTTON_STATE_PRESSED``                  Pressed button state
    ``AUI_BUTTON_STATE_DISABLED``                 Disabled button state
    ``AUI_BUTTON_STATE_HIDDEN``                   Hidden button state
    ``AUI_BUTTON_STATE_CHECKED``                  Checked button state
    ============================================  ======================================


    **Button Identifiers**

    These are the possible pane button / :class:`~lib.agw.aui.auibook.AuiNotebook` button /
    :class:`~lib.agw.aui.auibar.AuiToolBar` button identifiers:

    ============================================  ======================================
    Button Identifier                             Description
    ============================================  ======================================
    ``AUI_BUTTON_CLOSE``                          Shows a close button on the pane
    ``AUI_BUTTON_MAXIMIZE_RESTORE``               Shows a maximize/restore button on the pane
    ``AUI_BUTTON_MINIMIZE``                       Shows a minimize button on the pane
    ``AUI_BUTTON_PIN``                            Shows a pin button on the pane
    ``AUI_BUTTON_OPTIONS``                        Shows an option button on the pane (not implemented)
    ``AUI_BUTTON_WINDOWLIST``                     Shows a window list button on the pane (for :class:`~lib.agw.aui.auibook.AuiNotebook`)
    ``AUI_BUTTON_LEFT``                           Shows a left button on the pane (for :class:`~lib.agw.aui.auibook.AuiNotebook`)
    ``AUI_BUTTON_RIGHT``                          Shows a right button on the pane (for :class:`~lib.agw.aui.auibook.AuiNotebook`)
    ``AUI_BUTTON_UP``                             Shows an up button on the pane (not implemented)
    ``AUI_BUTTON_DOWN``                           Shows a down button on the pane (not implemented)
    ``AUI_BUTTON_CUSTOM1``                        Shows a custom button on the pane (not implemented)
    ``AUI_BUTTON_CUSTOM2``                        Shows a custom button on the pane (not implemented)
    ``AUI_BUTTON_CUSTOM3``                        Shows a custom button on the pane (not implemented)
    ============================================  ======================================

    """

    def __init__(self):
        """ Default class constructor. """

        self.Init()

        isMac = wx.Platform == "__WXMAC__"

        if isMac:
            self._caption_font = wx.SMALL_FONT
        else:
            self._caption_font = wx.Font(8, wx.DEFAULT, wx.NORMAL, wx.NORMAL, False)

        self.SetDefaultPaneBitmaps(isMac)
        self._restore_bitmap = wx.BitmapFromXPMData(restore_xpm)

        # default metric values
        self._sash_size = 4

        if isMac:
            # This really should be implemented in wx.SystemSettings
            # There is no way to do this that I am aware outside of using
            # the cocoa python bindings. 8 pixels looks correct on my system
            # so hard coding it for now.

            # How do I translate this?!? Not sure of the below implementation...
            # SInt32 height;
            # GetThemeMetric( kThemeMetricSmallPaneSplitterHeight , &height );
            # self._sash_size = height;

            self._sash_size = 8 # Carbon.Appearance.kThemeMetricPaneSplitterHeight

        elif wx.Platform == "__WXGTK__":
            self._sash_size = wx.RendererNative.Get().GetSplitterParams(wx.GetTopLevelWindows()[0]).widthSash

        else:
            self._sash_size = 4

        self._caption_size = 19
        self._border_size = 1
        self._button_size = 14
        self._gripper_size = 9
        self._gradient_type = AUI_GRADIENT_VERTICAL
        self._draw_sash = False


    def Init(self):
        """ Initializes the dock art. """

        self.SetDefaultColours()

        isMac = wx.Platform == "__WXMAC__"

        if isMac:
            self._active_caption_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_HIGHLIGHT)
        else:
            self._active_caption_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_ACTIVECAPTION)

        self._active_caption_gradient_colour = LightContrastColour(wx.SystemSettings.GetColour(wx.SYS_COLOUR_HIGHLIGHT))
        self._active_caption_text_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_HIGHLIGHTTEXT)
        self._inactive_caption_text_colour = wx.BLACK


    def SetDefaultColours(self, base_colour=None):
        """
        Sets the default colours, which are calculated from the given base colour.

        :param `base_colour`: an instance of :class:`Colour`. If defaulted to ``None``, a colour
         is generated accordingly to the platform and theme.
        """

        if base_colour is None:
            base_colour = GetBaseColour()

        darker1_colour = StepColour(base_colour, 85)
        darker2_colour = StepColour(base_colour, 75)
        darker3_colour = StepColour(base_colour, 60)
        darker4_colour = StepColour(base_colour, 40)

        self._background_colour = base_colour
        self._background_gradient_colour = StepColour(base_colour, 180)

        self._inactive_caption_colour = darker1_colour
        self._inactive_caption_gradient_colour = StepColour(base_colour, 97)

        self._sash_brush = wx.Brush(base_colour)
        self._background_brush = wx.Brush(base_colour)
        self._border_pen = wx.Pen(darker2_colour)
        self._gripper_brush = wx.Brush(base_colour)
        self._gripper_pen1 = wx.Pen(darker4_colour)
        self._gripper_pen2 = wx.Pen(darker3_colour)
        self._gripper_pen3 = wx.WHITE_PEN

        self._hint_background_colour = colourHintBackground


    def GetMetric(self, id):
        """
        Gets the value of a certain setting.

        :param integer `id`: can be one of the size values in `Metric Ordinals`.
        """


        if id == AUI_DOCKART_SASH_SIZE:
            return self._sash_size
        elif id == AUI_DOCKART_CAPTION_SIZE:
            return self._caption_size
        elif id == AUI_DOCKART_GRIPPER_SIZE:
            return self._gripper_size
        elif id == AUI_DOCKART_PANE_BORDER_SIZE:
            return self._border_size
        elif id == AUI_DOCKART_PANE_BUTTON_SIZE:
            return self._button_size
        elif id == AUI_DOCKART_GRADIENT_TYPE:
            return self._gradient_type
        elif id == AUI_DOCKART_DRAW_SASH_GRIP:
            return self._draw_sash
        else:
            raise Exception("Invalid Metric Ordinal.")


    def SetMetric(self, id, new_val):
        """
        Sets the value of a certain setting using `new_val`

        :param integer `id`: can be one of the size values in `Metric Ordinals`;
        :param `new_val`: the new value of the setting.
        """

        if id == AUI_DOCKART_SASH_SIZE:
            self._sash_size = new_val
        elif id == AUI_DOCKART_CAPTION_SIZE:
            self._caption_size = new_val
        elif id == AUI_DOCKART_GRIPPER_SIZE:
            self._gripper_size = new_val
        elif id == AUI_DOCKART_PANE_BORDER_SIZE:
            self._border_size = new_val
        elif id == AUI_DOCKART_PANE_BUTTON_SIZE:
            self._button_size = new_val
        elif id == AUI_DOCKART_GRADIENT_TYPE:
            self._gradient_type = new_val
        elif id == AUI_DOCKART_DRAW_SASH_GRIP:
            self._draw_sash = new_val
        else:
            raise Exception("Invalid Metric Ordinal.")


    def GetColor(self, id):
        """
        Gets the colour of a certain setting.

        :param integer `id`: can be one of the colour values in `Metric Ordinals`.
        """

        if id == AUI_DOCKART_BACKGROUND_COLOUR:
            return self._background_brush.GetColour()
        elif id == AUI_DOCKART_BACKGROUND_GRADIENT_COLOUR:
            return self._background_gradient_colour
        elif id == AUI_DOCKART_SASH_COLOUR:
            return self._sash_brush.GetColour()
        elif id == AUI_DOCKART_INACTIVE_CAPTION_COLOUR:
            return self._inactive_caption_colour
        elif id == AUI_DOCKART_INACTIVE_CAPTION_GRADIENT_COLOUR:
            return self._inactive_caption_gradient_colour
        elif id == AUI_DOCKART_INACTIVE_CAPTION_TEXT_COLOUR:
            return self._inactive_caption_text_colour
        elif id == AUI_DOCKART_ACTIVE_CAPTION_COLOUR:
            return self._active_caption_colour
        elif id == AUI_DOCKART_ACTIVE_CAPTION_GRADIENT_COLOUR:
            return self._active_caption_gradient_colour
        elif id == AUI_DOCKART_ACTIVE_CAPTION_TEXT_COLOUR:
            return self._active_caption_text_colour
        elif id == AUI_DOCKART_BORDER_COLOUR:
            return self._border_pen.GetColour()
        elif id == AUI_DOCKART_GRIPPER_COLOUR:
            return self._gripper_brush.GetColour()
        elif id == AUI_DOCKART_HINT_WINDOW_COLOUR:
            return self._hint_background_colour
        else:
            raise Exception("Invalid Colour Ordinal.")


    def SetColor(self, id, colour):
        """
        Sets the colour of a certain setting.

        :param integer `id`: can be one of the colour values in `Metric Ordinals`;
        :param `colour`: the new value of the setting.
        :type `colour`: :class:`Colour` or tuple or integer
        """

        if isinstance(colour, basestring):
            colour = wx.NamedColour(colour)
        elif isinstance(colour, types.TupleType):
            colour = wx.Colour(*colour)
        elif isinstance(colour, types.IntType):
            colour = wx.ColourRGB(colour)

        if id == AUI_DOCKART_BACKGROUND_COLOUR:
            self._background_brush.SetColour(colour)
        elif id == AUI_DOCKART_BACKGROUND_GRADIENT_COLOUR:
            self._background_gradient_colour = colour
        elif id == AUI_DOCKART_SASH_COLOUR:
            self._sash_brush.SetColour(colour)
        elif id == AUI_DOCKART_INACTIVE_CAPTION_COLOUR:
            self._inactive_caption_colour = colour
            if not self._custom_pane_bitmaps and wx.Platform == "__WXMAC__":
                # No custom bitmaps for the pane close button
                # Change the MAC close bitmap colour
                self._inactive_close_bitmap = DrawMACCloseButton(wx.WHITE, colour)

        elif id == AUI_DOCKART_INACTIVE_CAPTION_GRADIENT_COLOUR:
            self._inactive_caption_gradient_colour = colour
        elif id == AUI_DOCKART_INACTIVE_CAPTION_TEXT_COLOUR:
            self._inactive_caption_text_colour = colour
        elif id == AUI_DOCKART_ACTIVE_CAPTION_COLOUR:
            self._active_caption_colour = colour
            if not self._custom_pane_bitmaps and wx.Platform == "__WXMAC__":
                # No custom bitmaps for the pane close button
                # Change the MAC close bitmap colour
                self._active_close_bitmap = DrawMACCloseButton(wx.WHITE, colour)

        elif id == AUI_DOCKART_ACTIVE_CAPTION_GRADIENT_COLOUR:
            self._active_caption_gradient_colour = colour
        elif id == AUI_DOCKART_ACTIVE_CAPTION_TEXT_COLOUR:
            self._active_caption_text_colour = colour
        elif id == AUI_DOCKART_BORDER_COLOUR:
            self._border_pen.SetColour(colour)
        elif id == AUI_DOCKART_GRIPPER_COLOUR:
            self._gripper_brush.SetColour(colour)
            self._gripper_pen1.SetColour(StepColour(colour, 40))
            self._gripper_pen2.SetColour(StepColour(colour, 60))
        elif id == AUI_DOCKART_HINT_WINDOW_COLOUR:
            self._hint_background_colour = colour
        else:
            raise Exception("Invalid Colour Ordinal.")


    GetColour = GetColor
    SetColour = SetColor

    def SetFont(self, id, font):
        """
        Sets a font setting.

        :param integer `id`: must be ``AUI_DOCKART_CAPTION_FONT``;
        :param `font`: an instance of :class:`Font`.
        """

        if id == AUI_DOCKART_CAPTION_FONT:
            self._caption_font = font


    def GetFont(self, id):
        """
        Gets a font setting.

        :param integer `id`: must be ``AUI_DOCKART_CAPTION_FONT``, otherwise :class:`NullFont` is returned.
        """

        if id == AUI_DOCKART_CAPTION_FONT:
            return self._caption_font

        return wx.NullFont


    def DrawSash(self, dc, window, orient, rect):
        """
        Draws a sash between two windows.

        :param `dc`: a :class:`DC` device context;
        :param `window`: an instance of :class:`Window`;
        :param integer `orient`: the sash orientation;
        :param Rect `rect`: the sash rectangle.
        """

        # AG: How do we make this work?!?
        # RendererNative does not use the sash_brush chosen by the user
        # and the rect.GetSize() is ignored as the sash is always drawn
        # 3 pixel wide
        # wx.RendererNative.Get().DrawSplitterSash(window, dc, rect.GetSize(), pos, orient)

        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.SetBrush(self._sash_brush)
        dc.DrawRectangle(rect.x, rect.y, rect.width, rect.height)

        draw_sash = self.GetMetric(AUI_DOCKART_DRAW_SASH_GRIP)
        if draw_sash:
            self.DrawSashGripper(dc, orient, rect)


    def DrawBackground(self, dc, window, orient, rect):
        """
        Draws a background.

        :param `dc`: a :class:`DC` device context;
        :param `window`: an instance of :class:`Window`;
        :param integer `orient`: the gradient (if any) orientation;
        :param Rect `rect`: the background rectangle.
        """

        dc.SetPen(wx.TRANSPARENT_PEN)
        if wx.Platform == "__WXMAC__":
            # we have to clear first, otherwise we are drawing a light striped pattern
            # over an already darker striped background
            dc.SetBrush(wx.WHITE_BRUSH)
            dc.DrawRectangle(rect.x, rect.y, rect.width, rect.height)

        DrawGradientRectangle(dc, rect, self._background_brush.GetColour(),
                              self._background_gradient_colour,
                              AUI_GRADIENT_HORIZONTAL, rect.x, 700)


    def DrawBorder(self, dc, window, rect, pane):
        """
        Draws the pane border.

        :param `dc`: a :class:`DC` device context;
        :param `window`: an instance of :class:`Window`;
        :param Rect `rect`: the border rectangle;
        :param `pane`: the pane for which the border is drawn.
        """

        drect = wx.Rect(*rect)

        dc.SetPen(self._border_pen)
        dc.SetBrush(wx.TRANSPARENT_BRUSH)

        border_width = self.GetMetric(AUI_DOCKART_PANE_BORDER_SIZE)

        if pane.IsToolbar():

            for ii in xrange(0, border_width):

                dc.SetPen(wx.WHITE_PEN)
                dc.DrawLine(drect.x, drect.y, drect.x+drect.width, drect.y)
                dc.DrawLine(drect.x, drect.y, drect.x, drect.y+drect.height)
                dc.SetPen(self._border_pen)
                dc.DrawLine(drect.x, drect.y+drect.height-1,
                            drect.x+drect.width, drect.y+drect.height-1)
                dc.DrawLine(drect.x+drect.width-1, drect.y,
                            drect.x+drect.width-1, drect.y+drect.height)
                drect.Deflate(1, 1)

        else:

            for ii in xrange(0, border_width):

                dc.DrawRectangle(drect.x, drect.y, drect.width, drect.height)
                drect.Deflate(1, 1)


    def DrawCaptionBackground(self, dc, rect, pane):
        """
        Draws the text caption background in the pane.

        :param `dc`: a :class:`DC` device context;
        :param Rect `rect`: the text caption rectangle;
        :param `pane`: the pane for which the text background is drawn.
        """

        active = pane.state & optionActive

        if self._gradient_type == AUI_GRADIENT_NONE:
            if active:
                dc.SetBrush(wx.Brush(self._active_caption_colour))
            else:
                dc.SetBrush(wx.Brush(self._inactive_caption_colour))

            dc.DrawRectangle(rect.x, rect.y, rect.width, rect.height)

        else:

            switch_gradient = pane.HasCaptionLeft()
            gradient_type = self._gradient_type
            if switch_gradient:
                gradient_type = (self._gradient_type == AUI_GRADIENT_HORIZONTAL and [AUI_GRADIENT_VERTICAL] or \
                                 [AUI_GRADIENT_HORIZONTAL])[0]

            if active:
                if wx.Platform == "__WXMAC__":
                    DrawGradientRectangle(dc, rect, self._active_caption_colour,
                                          self._active_caption_gradient_colour,
                                          gradient_type)
                else:
                    DrawGradientRectangle(dc, rect, self._active_caption_gradient_colour,
                                          self._active_caption_colour,
                                          gradient_type)
            else:
                if wx.Platform == "__WXMAC__":
                    DrawGradientRectangle(dc, rect, self._inactive_caption_gradient_colour,
                                          self._inactive_caption_colour,
                                          gradient_type)
                else:
                    DrawGradientRectangle(dc, rect, self._inactive_caption_colour,
                                          self._inactive_caption_gradient_colour,
                                          gradient_type)


    def DrawIcon(self, dc, rect, pane):
        """
        Draws the icon in the pane caption area.

        :param `dc`: a :class:`DC` device context;
        :param Rect `rect`: the pane caption rectangle;
        :param `pane`: the pane for which the icon is drawn.
        """

        # Draw the icon centered vertically
        if pane.icon.Ok():
            if pane.HasCaptionLeft():
                bmp = wx.ImageFromBitmap(pane.icon).Rotate90(clockwise=False)
                dc.DrawBitmap(bmp.ConvertToBitmap(), rect.x+(rect.width-pane.icon.GetWidth())/2, rect.y+rect.height-2-pane.icon.GetHeight(), True)
            else:
                dc.DrawBitmap(pane.icon, rect.x+2, rect.y+(rect.height-pane.icon.GetHeight())/2, True)


    def DrawCaption(self, dc, window, text, rect, pane):
        """
        Draws the text in the pane caption.

        :param `dc`: a :class:`DC` device context;
        :param `window`: an instance of :class:`Window`;
        :param string `text`: the text to be displayed;
        :param Rect `rect`: the pane caption rectangle;
        :param `pane`: the pane for which the text is drawn.
        """

        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.SetFont(self._caption_font)

        self.DrawCaptionBackground(dc, rect, pane)

        if pane.state & optionActive:
            dc.SetTextForeground(self._active_caption_text_colour)
        else:
            dc.SetTextForeground(self._inactive_caption_text_colour)

        w, h = dc.GetTextExtent("ABCDEFHXfgkj")

        clip_rect = wx.Rect(*rect)
        btns = pane.CountButtons()

        captionLeft = pane.HasCaptionLeft()
        variable = (captionLeft and [rect.height] or [rect.width])[0]

        variable -= 3      # text offset
        variable -= 2      # button padding

        caption_offset = 0
        if pane.icon:
            if captionLeft:
                caption_offset += pane.icon.GetHeight() + 3
            else:
                caption_offset += pane.icon.GetWidth() + 3

            self.DrawIcon(dc, rect, pane)

        variable -= caption_offset
        variable -= btns*(self._button_size + self._border_size)
        draw_text = ChopText(dc, text, variable)

        if captionLeft:
            dc.DrawRotatedText(draw_text, rect.x+(rect.width/2)-(h/2)-1, rect.y+rect.height-3-caption_offset, 90)
        else:
            dc.DrawText(draw_text, rect.x+3+caption_offset, rect.y+(rect.height/2)-(h/2)-1)


    def RequestUserAttention(self, dc, window, text, rect, pane):
        """
        Requests the user attention by intermittently highlighting the pane caption.

        :param `dc`: a :class:`DC` device context;
        :param `window`: an instance of :class:`Window`;
        :param string `text`: the text to be displayed;
        :param Rect `rect`: the pane caption rectangle;
        :param `pane`: the pane for which we want to attract the user attention.
        """

        state = pane.state
        pane.state &= ~optionActive

        for indx in xrange(6):
            active = (indx%2 == 0 and [True] or [False])[0]
            if active:
                pane.state |= optionActive
            else:
                pane.state &= ~optionActive

            self.DrawCaptionBackground(dc, rect, pane)
            self.DrawCaption(dc, window, text, rect, pane)
            wx.SafeYield()
            wx.MilliSleep(350)

        pane.state = state


    def DrawGripper(self, dc, window, rect, pane):
        """
        Draws a gripper on the pane.

        :param `dc`: a :class:`DC` device context;
        :param `window`: an instance of :class:`Window`;
        :param Rect `rect`: the pane caption rectangle;
        :param `pane`: the pane for which the gripper is drawn.
        """

        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.SetBrush(self._gripper_brush)

        dc.DrawRectangle(rect.x, rect.y, rect.width, rect.height)

        if not pane.HasGripperTop():
            y = 4
            while 1:
                dc.SetPen(self._gripper_pen1)
                dc.DrawPoint(rect.x+3, rect.y+y)
                dc.SetPen(self._gripper_pen2)
                dc.DrawPoint(rect.x+3, rect.y+y+1)
                dc.DrawPoint(rect.x+4, rect.y+y)
                dc.SetPen(self._gripper_pen3)
                dc.DrawPoint(rect.x+5, rect.y+y+1)
                dc.DrawPoint(rect.x+5, rect.y+y+2)
                dc.DrawPoint(rect.x+4, rect.y+y+2)
                y = y + 4
                if y > rect.GetHeight() - 4:
                    break
        else:
            x = 4
            while 1:
                dc.SetPen(self._gripper_pen1)
                dc.DrawPoint(rect.x+x, rect.y+3)
                dc.SetPen(self._gripper_pen2)
                dc.DrawPoint(rect.x+x+1, rect.y+3)
                dc.DrawPoint(rect.x+x, rect.y+4)
                dc.SetPen(self._gripper_pen3)
                dc.DrawPoint(rect.x+x+1, rect.y+5)
                dc.DrawPoint(rect.x+x+2, rect.y+5)
                dc.DrawPoint(rect.x+x+2, rect.y+4)
                x = x + 4
                if x > rect.GetWidth() - 4:
                    break


    def DrawPaneButton(self, dc, window, button, button_state, _rect, pane):
        """
        Draws a pane button in the pane caption area.

        :param `dc`: a :class:`DC` device context;
        :param `window`: an instance of :class:`Window`;
        :param integer `button`: the button to be drawn;
        :param integer `button_state`: the pane button state;
        :param Rect `_rect`: the pane caption rectangle;
        :param `pane`: the pane for which the button is drawn.
        """

        if not pane:
            return

        if button == AUI_BUTTON_CLOSE:
            if pane.state & optionActive:
                bmp = self._active_close_bitmap
            else:
                bmp = self._inactive_close_bitmap

        elif button == AUI_BUTTON_PIN:
            if pane.state & optionActive:
                bmp = self._active_pin_bitmap
            else:
                bmp = self._inactive_pin_bitmap

        elif button == AUI_BUTTON_MAXIMIZE_RESTORE:
            if pane.IsMaximized():
                if pane.state & optionActive:
                    bmp = self._active_restore_bitmap
                else:
                    bmp = self._inactive_restore_bitmap
            else:
                if pane.state & optionActive:
                    bmp = self._active_maximize_bitmap
                else:
                    bmp = self._inactive_maximize_bitmap

        elif button == AUI_BUTTON_MINIMIZE:
            if pane.state & optionActive:
                bmp = self._active_minimize_bitmap
            else:
                bmp = self._inactive_minimize_bitmap

        isVertical = pane.HasCaptionLeft()

        rect = wx.Rect(*_rect)

        if isVertical:
            old_x = rect.x
            rect.x = rect.x + (rect.width/2) - (bmp.GetWidth()/2)
            rect.width = old_x + rect.width - rect.x - 1
        else:
            old_y = rect.y
            rect.y = rect.y + (rect.height/2) - (bmp.GetHeight()/2)
            rect.height = old_y + rect.height - rect.y - 1

        if button_state == AUI_BUTTON_STATE_PRESSED:
            rect.x += 1
            rect.y += 1

        if button_state in [AUI_BUTTON_STATE_HOVER, AUI_BUTTON_STATE_PRESSED]:

            if pane.state & optionActive:

                dc.SetBrush(wx.Brush(StepColour(self._active_caption_colour, 120)))
                dc.SetPen(wx.Pen(StepColour(self._active_caption_colour, 70)))

            else:

                dc.SetBrush(wx.Brush(StepColour(self._inactive_caption_colour, 120)))
                dc.SetPen(wx.Pen(StepColour(self._inactive_caption_colour, 70)))

            if wx.Platform != "__WXMAC__":
                # draw the background behind the button
                dc.DrawRectangle(rect.x, rect.y, 15, 15)
            else:
                # Darker the bitmap a bit
                bmp = DarkenBitmap(bmp, self._active_caption_colour, StepColour(self._active_caption_colour, 110))

        if isVertical:
            bmp = wx.ImageFromBitmap(bmp).Rotate90(clockwise=False).ConvertToBitmap()

        # draw the button itself
        dc.DrawBitmap(bmp, rect.x, rect.y, True)


    def DrawSashGripper(self, dc, orient, rect):
        """
        Draws a sash gripper on a sash between two windows.

        :param `dc`: a :class:`DC` device context;
        :param integer `orient`: the sash orientation;
        :param Rect `rect`: the sash rectangle.
        """

        dc.SetBrush(self._gripper_brush)

        if orient == wx.HORIZONTAL:  # horizontal sash

            x = rect.x + int((1.0/4.0)*rect.width)
            xend = rect.x + int((3.0/4.0)*rect.width)
            y = rect.y + (rect.height/2) - 1

            while 1:
                dc.SetPen(self._gripper_pen3)
                dc.DrawRectangle(x, y, 2, 2)
                dc.SetPen(self._gripper_pen2)
                dc.DrawPoint(x+1, y+1)
                x = x + 5

                if x >= xend:
                    break

        else:

            y = rect.y + int((1.0/4.0)*rect.height)
            yend = rect.y + int((3.0/4.0)*rect.height)
            x = rect.x + (rect.width/2) - 1

            while 1:
                dc.SetPen(self._gripper_pen3)
                dc.DrawRectangle(x, y, 2, 2)
                dc.SetPen(self._gripper_pen2)
                dc.DrawPoint(x+1, y+1)
                y = y + 5

                if y >= yend:
                    break


    def SetDefaultPaneBitmaps(self, isMac):
        """
        Assigns the default pane bitmaps.

        :param bool `isMac`: whether we are on wxMAC or not.
        """

        if isMac:
            self._inactive_close_bitmap = DrawMACCloseButton(wx.WHITE, self._inactive_caption_colour)
            self._active_close_bitmap = DrawMACCloseButton(wx.WHITE, self._active_caption_colour)
        else:
            self._inactive_close_bitmap = BitmapFromBits(close_bits, 16, 16, self._inactive_caption_text_colour)
            self._active_close_bitmap = BitmapFromBits(close_bits, 16, 16, self._active_caption_text_colour)

        if isMac:
            self._inactive_maximize_bitmap = BitmapFromBits(max_bits, 16, 16, wx.WHITE)
            self._active_maximize_bitmap = BitmapFromBits(max_bits, 16, 16, wx.WHITE)
        else:
            self._inactive_maximize_bitmap = BitmapFromBits(max_bits, 16, 16, self._inactive_caption_text_colour)
            self._active_maximize_bitmap = BitmapFromBits(max_bits, 16, 16, self._active_caption_text_colour)

        if isMac:
            self._inactive_restore_bitmap = BitmapFromBits(restore_bits, 16, 16, wx.WHITE)
            self._active_restore_bitmap = BitmapFromBits(restore_bits, 16, 16, wx.WHITE)
        else:
            self._inactive_restore_bitmap = BitmapFromBits(restore_bits, 16, 16, self._inactive_caption_text_colour)
            self._active_restore_bitmap = BitmapFromBits(restore_bits, 16, 16, self._active_caption_text_colour)

        if isMac:
            self._inactive_minimize_bitmap = BitmapFromBits(minimize_bits, 16, 16, wx.WHITE)
            self._active_minimize_bitmap = BitmapFromBits(minimize_bits, 16, 16, wx.WHITE)
        else:
            self._inactive_minimize_bitmap = BitmapFromBits(minimize_bits, 16, 16, self._inactive_caption_text_colour)
            self._active_minimize_bitmap = BitmapFromBits(minimize_bits, 16, 16, self._active_caption_text_colour)

        self._inactive_pin_bitmap = BitmapFromBits(pin_bits, 16, 16, self._inactive_caption_text_colour)
        self._active_pin_bitmap = BitmapFromBits(pin_bits, 16, 16, self._active_caption_text_colour)

        self._custom_pane_bitmaps = False


    def SetCustomPaneBitmap(self, bmp, button, active, maximize=False):
        """
        Sets a custom button bitmap for the pane button.

        :param Bitmap `bmp`: the actual bitmap to set;
        :param integer `button`: the button identifier;
        :param bool `active`: whether it is the bitmap for the active button or not;
        :param bool `maximize`: used to distinguish between the maximize and restore bitmaps.
        """

        if bmp.GetWidth() > 16 or bmp.GetHeight() > 16:
            raise Exception("The input bitmap is too big")

        if button == AUI_BUTTON_CLOSE:
            if active:
                self._active_close_bitmap = bmp
            else:
                self._inactive_close_bitmap = bmp

            if wx.Platform == "__WXMAC__":
                self._custom_pane_bitmaps = True

        elif button == AUI_BUTTON_PIN:
            if active:
                self._active_pin_bitmap = bmp
            else:
                self._inactive_pin_bitmap = bmp

        elif button == AUI_BUTTON_MAXIMIZE_RESTORE:
            if maximize:
                if active:
                    self._active_maximize_bitmap = bmp
                else:
                    self._inactive_maximize_bitmap = bmp
            else:
                if active:
                    self._active_restore_bitmap = bmp
                else:
                    self._inactive_restore_bitmap = bmp

        elif button == AUI_BUTTON_MINIMIZE:
            if active:
                self._active_minimize_bitmap = bmp
            else:
                self._inactive_minimize_bitmap = bmp


if _ctypes:
    class RECT(ctypes.Structure):
        """ Used to handle :class:`ModernDockArt` on Windows XP/Vista/7. """
        _fields_ = [('left', ctypes.c_ulong),('top', ctypes.c_ulong),('right', ctypes.c_ulong),('bottom', ctypes.c_ulong)]

        def dump(self):
            """ Dumps `self` as a :class:`Rect`. """
            return map(int, (self.left, self.top, self.right, self.bottom))


    class SIZE(ctypes.Structure):
        """ Used to handle :class:`ModernDockArt` on Windows XP/Vista/7. """
        _fields_ = [('x', ctypes.c_long),('y', ctypes.c_long)]


class ModernDockArt(AuiDefaultDockArt):
    """
    ModernDockArt is a custom `AuiDockArt` class, that implements a look similar to Firefox and other recents applications.

    Is uses the `winxptheme <http://sourceforge.net/projects/pywin32/>`_ module and
    XP themes whenever possible, so it should look good even if the user has a custom theme.

    :note: This dock art is Windows only and will only work if you have installed
     Mark Hammond's `pywin32` module (http://sourceforge.net/projects/pywin32/).
    """

    def __init__(self, win):
        """
        Default class constructor.

        :param Window `win`: the window managed by :class:`~lib.agw.aui.framemanager.AuiManager`.
        """

        AuiDefaultDockArt.__init__(self)

        self.win = win

        # Get the size of a small close button (themed)
        hwnd = self.win.GetHandle()
        self.usingTheme = False

        if _ctypes:
            self.hTheme1 = winxptheme.OpenThemeData(hwnd, "Window")
            self.usingTheme = True

        if not self.hTheme1:
            self.usingTheme = False

        self._button_size = 13

        self._button_border_size = 3
        self._caption_text_indent = 6
        self._caption_size = 22

        # We only highlight the active pane with the caption text being in bold.
        # So we do not want a special colour for active elements.
        self._active_close_bitmap = self._inactive_close_bitmap

        self.Init()


    def Init(self):
        """ Initializes the dock art. """

        AuiDefaultDockArt.Init(self)

        self._active_caption_colour = self._inactive_caption_colour
        self._active_caption_text_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_CAPTIONTEXT)
        self._inactive_caption_text_colour = self._active_caption_text_colour


    def DrawCaption(self, dc, window, text, rect, pane):
        """
        Draws the text in the pane caption.

        :param `dc`: a :class:`DC` device context;
        :param `window`: an instance of :class:`Window`;
        :param string `text`: the text to be displayed;
        :param Rect `rect`: the pane caption rectangle;
        :param `pane`: the pane for which the text is drawn.
        """

        dc.SetPen(wx.TRANSPARENT_PEN)
        self.DrawCaptionBackground(dc, rect, pane)

        active = ((pane.state & optionActive) and [True] or [False])[0]

        self._caption_font.SetWeight(wx.FONTWEIGHT_BOLD)
        dc.SetFont(self._caption_font)

        if active:
            dc.SetTextForeground(self._active_caption_text_colour)
        else:
            dc.SetTextForeground(self._inactive_caption_text_colour)

        w, h = dc.GetTextExtent("ABCDEFHXfgkj")

        clip_rect = wx.Rect(*rect)
        btns = pane.CountButtons()

        captionLeft = pane.HasCaptionLeft()
        variable = (captionLeft and [rect.height] or [rect.width])[0]

        variable -= 3      # text offset
        variable -= 2      # button padding

        caption_offset = 0
        if pane.icon:
            if captionLeft:
                caption_offset += pane.icon.GetHeight() + 3
            else:
                caption_offset += pane.icon.GetWidth() + 3

            self.DrawIcon(dc, rect, pane)

        diff = -2
        if self.usingTheme:
            diff = -1

        variable -= caption_offset
        variable -= btns*(self._button_size + self._button_border_size)
        draw_text = ChopText(dc, text, variable)

        if captionLeft:
            dc.DrawRotatedText(draw_text, rect.x+(rect.width/2)-(h/2)-diff, rect.y+rect.height-3-caption_offset, 90)
        else:
            dc.DrawText(draw_text, rect.x+3+caption_offset, rect.y+(rect.height/2)-(h/2)-diff)


    def DrawCaptionBackground(self, dc, rect, pane):
        """
        Draws the text caption background in the pane.

        :param `dc`: a :class:`DC` device context;
        :param Rect `rect`: the text caption rectangle;
        :param `pane`: the pane for which we are drawing the caption background.
        """

        dc.SetBrush(self._background_brush)
        dc.DrawRectangle(rect.x, rect.y, rect.width, rect.height)

        active = ((pane.state & optionActive) and [True] or [False])[0]

        if self.usingTheme:

            rectangle = wx.Rect()

            rc = RECT(rectangle.x, rectangle.y, rectangle.width, rectangle.height)

            # If rect x/y values are negative rc.right/bottom values will overflow and winxptheme.DrawThemeBackground
            # will raise a TypeError. Ensure they are never negative.
            rect.x = max(0, rect.x)
            rect.y = max(0, rect.y)

            rc.top = rect.x
            rc.left = rect.y
            rc.right = rect.x + rect.width
            rc.bottom = rect.y + rect.height

            if active:
                winxptheme.DrawThemeBackground(self.hTheme1, dc.GetHDC(), 5, 1, (rc.top, rc.left, rc.right, rc.bottom), None)
            else:
                winxptheme.DrawThemeBackground(self.hTheme1, dc.GetHDC(), 5, 2, (rc.top, rc.left, rc.right, rc.bottom), None)

        else:

            AuiDefaultDockArt.DrawCaptionBackground(self, dc, rect, pane)


    def RequestUserAttention(self, dc, window, text, rect, pane):
        """
        Requests the user attention by intermittently highlighting the pane caption.

        :param `dc`: a :class:`DC` device context;
        :param `window`: an instance of :class:`Window`;
        :param string `text`: the text to be displayed;
        :param Rect `rect`: the pane caption rectangle;
        :param `pane`: the pane for which the text is drawn.
        """

        state = pane.state
        pane.state &= ~optionActive

        for indx in xrange(6):
            active = (indx%2 == 0 and [True] or [False])[0]
            if active:
                pane.state |= optionActive
            else:
                pane.state &= ~optionActive

            self.DrawCaptionBackground(dc, rect, pane)
            self.DrawCaption(dc, window, text, rect, pane)
            wx.SafeYield()
            wx.MilliSleep(350)

        pane.state = state


    def DrawPaneButton(self, dc, window, button, button_state, rect, pane):
        """
        Draws a pane button in the pane caption area.

        :param `dc`: a :class:`DC` device context;
        :param `window`: an instance of :class:`Window`;
        :param integer `button`: the button to be drawn;
        :param integer `button_state`: the pane button state;
        :param Rect `rect`: the pane caption rectangle;
        :param `pane`: the pane for which the button is drawn.
        """

        if self.usingTheme:

            hTheme = self.hTheme1

            # Get the real button position (compensating for borders)
            drect = wx.Rect(rect.x, rect.y, self._button_size, self._button_size)

            # Draw the themed close button
            rc = RECT(0, 0, 0, 0)
            if pane.HasCaptionLeft():
                rc.top = rect.x + self._button_border_size
                rc.left = int(rect.y + 1.5*self._button_border_size)
                rc.right = rect.x + self._button_size + self._button_border_size
                rc.bottom = int(rect.y + self._button_size + 1.5*self._button_border_size)
            else:
                rc.top = rect.x - self._button_border_size
                rc.left = int(rect.y + 1.5*self._button_border_size)
                rc.right = rect.x + self._button_size- self._button_border_size
                rc.bottom = int(rect.y + self._button_size + 1.5*self._button_border_size)

            if button == AUI_BUTTON_CLOSE:
                btntype = 19

            elif button == AUI_BUTTON_PIN:
                btntype = 23

            elif button == AUI_BUTTON_MAXIMIZE_RESTORE:
                if not pane.IsMaximized():
                    btntype = 17
                else:
                    btntype = 21
            else:
                btntype = 15

            state = 4 # CBS_DISABLED

            if pane.state & optionActive:

                if button_state == AUI_BUTTON_STATE_NORMAL:
                    state = 1 # CBS_NORMAL

                elif button_state == AUI_BUTTON_STATE_HOVER:
                    state = 2 # CBS_HOT

                elif button_state == AUI_BUTTON_STATE_PRESSED:
                    state = 3 # CBS_PUSHED

                else:
                    raise Exception("ERROR: Unknown State.")

            else: # inactive pane

                if button_state == AUI_BUTTON_STATE_NORMAL:
                    state = 5 # CBS_NORMAL

                elif button_state == AUI_BUTTON_STATE_HOVER:
                    state = 6 # CBS_HOT

                elif button_state == AUI_BUTTON_STATE_PRESSED:
                    state = 7 # CBS_PUSHED

                else:
                    raise Exception("ERROR: Unknown State.")

            try:
                winxptheme.DrawThemeBackground(hTheme, dc.GetHDC(), btntype, state, (rc.top, rc.left, rc.right, rc.bottom), None)
            except TypeError:
                return

        else:

            # Fallback to default closebutton if themes are not enabled
            rect2 = wx.Rect(rect.x-4, rect.y+2, rect.width, rect.height)
            AuiDefaultDockArt.DrawPaneButton(self, dc, window, button, button_state, rect2, pane)


########NEW FILE########
__FILENAME__ = framemanager
# --------------------------------------------------------------------------- #
# AUI Library wxPython IMPLEMENTATION
#
# Original C++ Code From Kirix (wxAUI). You Can Find It At:
#
#    License: wxWidgets license
#
# http:#www.kirix.com/en/community/opensource/wxaui/about_wxaui.html
#
# Current wxAUI Version Tracked: wxWidgets 2.9.4 SVN HEAD
#
#
# Python Code By:
#
# Andrea Gavana, @ 23 Dec 2005
# Latest Revision: 25 Apr 2012, 21.00 GMT
#
# For All Kind Of Problems, Requests Of Enhancements And Bug Reports, Please
# Write To Me At:
#
# andrea.gavana@gmail.com
# andrea.gavana@maerskoil.com
#
# Or, Obviously, To The wxPython Mailing List!!!
#
# End Of Comments
# --------------------------------------------------------------------------- #

"""
Description
===========

`framemanager.py` is the central module of the AUI class framework.

:class:`AuiManager` manages the panes associated with it for a particular :class:`Frame`, using
a pane's :class:`AuiPaneInfo` information to determine each pane's docking and floating
behavior. AuiManager uses wxPython' sizer mechanism to plan the layout of each frame.
It uses a replaceable dock art class to do all drawing, so all drawing is localized
in one area, and may be customized depending on an application's specific needs.

AuiManager works as follows: the programmer adds panes to the class, or makes
changes to existing pane properties (dock position, floating state, show state, etc...).
To apply these changes, AuiManager's :meth:`AuiManager.Update() <AuiManager.Update>` function is called. This batch
processing can be used to avoid flicker, by modifying more than one pane at a time,
and then "committing" all of the changes at once by calling `Update()`.

Panes can be added quite easily::

    text1 = wx.TextCtrl(self, -1)
    text2 = wx.TextCtrl(self, -1)
    self._mgr.AddPane(text1, AuiPaneInfo().Left().Caption("Pane Number One"))
    self._mgr.AddPane(text2, AuiPaneInfo().Bottom().Caption("Pane Number Two"))

    self._mgr.Update()


Later on, the positions can be modified easily. The following will float an
existing pane in a tool window::

    self._mgr.GetPane(text1).Float()


Layers, Rows and Directions, Positions
======================================

Inside AUI, the docking layout is figured out by checking several pane parameters.
Four of these are important for determining where a pane will end up.

**Direction** - Each docked pane has a direction, `Top`, `Bottom`, `Left`, `Right`, or `Center`.
This is fairly self-explanatory. The pane will be placed in the location specified
by this variable.

**Position** - More than one pane can be placed inside of a "dock". Imagine two panes
being docked on the left side of a window. One pane can be placed over another.
In proportionally managed docks, the pane position indicates it's sequential position,
starting with zero. So, in our scenario with two panes docked on the left side, the
top pane in the dock would have position 0, and the second one would occupy position 1.

**Row** - A row can allow for two docks to be placed next to each other. One of the most
common places for this to happen is in the toolbar. Multiple toolbar rows are allowed,
the first row being in row 0, and the second in row 1. Rows can also be used on
vertically docked panes.

**Layer** - A layer is akin to an onion. Layer 0 is the very center of the managed pane.
Thus, if a pane is in layer 0, it will be closest to the center window (also sometimes
known as the "content window"). Increasing layers "swallow up" all layers of a lower
value. This can look very similar to multiple rows, but is different because all panes
in a lower level yield to panes in higher levels. The best way to understand layers
is by running the AUI sample (`AUI.py`).
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx
import time
import types
import warnings

import auibar
import auibook
import tabmdi
import dockart
import tabart

from aui_utilities import Clip, PaneCreateStippleBitmap, GetDockingImage, GetSlidingPoints

from aui_constants import *

# Define this as a translation function
_ = wx.GetTranslation

_winxptheme = False
if wx.Platform == "__WXMSW__":
    try:
        import winxptheme
        _winxptheme = True
    except ImportError:
        pass

# wxPython version string
_VERSION_STRING = wx.VERSION_STRING

# AUI Events
wxEVT_AUI_PANE_BUTTON = wx.NewEventType()
wxEVT_AUI_PANE_CLOSE = wx.NewEventType()
wxEVT_AUI_PANE_MAXIMIZE = wx.NewEventType()
wxEVT_AUI_PANE_RESTORE = wx.NewEventType()
wxEVT_AUI_RENDER = wx.NewEventType()
wxEVT_AUI_FIND_MANAGER = wx.NewEventType()
wxEVT_AUI_PANE_MINIMIZE = wx.NewEventType()
wxEVT_AUI_PANE_MIN_RESTORE = wx.NewEventType()
wxEVT_AUI_PANE_FLOATING = wx.NewEventType()
wxEVT_AUI_PANE_FLOATED = wx.NewEventType()
wxEVT_AUI_PANE_DOCKING = wx.NewEventType()
wxEVT_AUI_PANE_DOCKED = wx.NewEventType()
wxEVT_AUI_PANE_ACTIVATED = wx.NewEventType()
wxEVT_AUI_PERSPECTIVE_CHANGED = wx.NewEventType()

EVT_AUI_PANE_BUTTON = wx.PyEventBinder(wxEVT_AUI_PANE_BUTTON, 0)
""" Fires an event when the user left-clicks on a pane button. """
EVT_AUI_PANE_CLOSE = wx.PyEventBinder(wxEVT_AUI_PANE_CLOSE, 0)
""" A pane in `AuiManager` has been closed. """
EVT_AUI_PANE_MAXIMIZE = wx.PyEventBinder(wxEVT_AUI_PANE_MAXIMIZE, 0)
""" A pane in `AuiManager` has been maximized. """
EVT_AUI_PANE_RESTORE = wx.PyEventBinder(wxEVT_AUI_PANE_RESTORE, 0)
""" A pane in `AuiManager` has been restored from a maximized state. """
EVT_AUI_RENDER = wx.PyEventBinder(wxEVT_AUI_RENDER, 0)
""" Fires an event every time the AUI frame is being repainted. """
EVT_AUI_FIND_MANAGER = wx.PyEventBinder(wxEVT_AUI_FIND_MANAGER, 0)
""" Used to find which AUI manager is controlling a certain pane. """
EVT_AUI_PANE_MINIMIZE = wx.PyEventBinder(wxEVT_AUI_PANE_MINIMIZE, 0)
""" A pane in `AuiManager` has been minimized. """
EVT_AUI_PANE_MIN_RESTORE = wx.PyEventBinder(wxEVT_AUI_PANE_MIN_RESTORE, 0)
""" A pane in `AuiManager` has been restored from a minimized state. """
EVT_AUI_PANE_FLOATING = wx.PyEventBinder(wxEVT_AUI_PANE_FLOATING, 0)
""" A pane in `AuiManager` is about to be floated. """
EVT_AUI_PANE_FLOATED = wx.PyEventBinder(wxEVT_AUI_PANE_FLOATED, 0)
""" A pane in `AuiManager` has been floated. """
EVT_AUI_PANE_DOCKING = wx.PyEventBinder(wxEVT_AUI_PANE_DOCKING, 0)
""" A pane in `AuiManager` is about to be docked. """
EVT_AUI_PANE_DOCKED = wx.PyEventBinder(wxEVT_AUI_PANE_DOCKED, 0)
""" A pane in `AuiManager` has been docked. """
EVT_AUI_PANE_ACTIVATED = wx.PyEventBinder(wxEVT_AUI_PANE_ACTIVATED, 0)
""" A pane in `AuiManager` has been activated. """
EVT_AUI_PERSPECTIVE_CHANGED = wx.PyEventBinder(wxEVT_AUI_PERSPECTIVE_CHANGED, 0)
""" The layout in `AuiManager` has been changed. """

# ---------------------------------------------------------------------------- #

class AuiDockInfo(object):
    """ A class to store all properties of a dock. """

    def __init__(self):
        """
        Default class constructor.
        Used internally, do not call it in your code!
        """

        object.__init__(self)

        self.dock_direction = 0
        self.dock_layer = 0
        self.dock_row = 0
        self.size = 0
        self.min_size = 0
        self.resizable = True
        self.fixed = False
        self.toolbar = False
        self.rect = wx.Rect()
        self.panes = []


    def IsOk(self):
        """
        Returns whether a dock is valid or not.

        In order to be valid, a dock needs to have a non-zero `dock_direction`.
        """

        return self.dock_direction != 0


    def IsHorizontal(self):
        """ Returns whether the dock is horizontal or not. """

        return self.dock_direction in [AUI_DOCK_TOP, AUI_DOCK_BOTTOM]


    def IsVertical(self):
        """ Returns whether the dock is vertical or not. """

        return self.dock_direction in [AUI_DOCK_LEFT, AUI_DOCK_RIGHT, AUI_DOCK_CENTER]


# ---------------------------------------------------------------------------- #

class AuiDockingGuideInfo(object):
    """ A class which holds information about VS2005 docking guide windows. """

    def __init__(self, other=None):
        """
        Default class constructor.
        Used internally, do not call it in your code!

        :param `other`: another instance of :class:`AuiDockingGuideInfo`.
        """

        if other:
            self.Assign(other)
        else:
            # window representing the docking target
            self.host = None
            # dock direction (top, bottom, left, right, center)
            self.dock_direction = AUI_DOCK_NONE


    def Assign(self, other):
        """
        Assigns the properties of the `other` :class:`AuiDockingGuideInfo` to `self`.

        :param `other`: another instance of :class:`AuiDockingGuideInfo`.
        """

        self.host = other.host
        self.dock_direction = other.dock_direction


    def Host(self, h):
        """
        Hosts a docking guide window.

        :param `h`: an instance of :class:`AuiDockingGuideWindow` or :class:`AuiDockingHintWindow`.
        """

        self.host = h
        return self


    def Left(self):
        """ Sets the guide window to left docking. """

        self.dock_direction = AUI_DOCK_LEFT
        return self


    def Right(self):
        """ Sets the guide window to right docking. """

        self.dock_direction = AUI_DOCK_RIGHT
        return self


    def Top(self):
        """ Sets the guide window to top docking. """

        self.dock_direction = AUI_DOCK_TOP
        return self


    def Bottom(self):
        """ Sets the guide window to bottom docking. """

        self.dock_direction = AUI_DOCK_BOTTOM
        return self


    def Center(self):
        """ Sets the guide window to center docking. """

        self.dock_direction = AUI_DOCK_CENTER
        return self


    def Centre(self):
        """ Sets the guide window to centre docking. """

        self.dock_direction = AUI_DOCK_CENTRE
        return self


# ---------------------------------------------------------------------------- #

class AuiDockUIPart(object):
    """ A class which holds attributes for a UI part in the interface. """

    typeCaption = 0
    typeGripper = 1
    typeDock = 2
    typeDockSizer = 3
    typePane = 4
    typePaneSizer = 5
    typeBackground = 6
    typePaneBorder = 7
    typePaneButton = 8

    def __init__(self):
        """
        Default class constructor.
        Used internally, do not call it in your code!
        """

        self.orientation = wx.VERTICAL
        self.type = 0
        self.rect = wx.Rect()


# ---------------------------------------------------------------------------- #

class AuiPaneButton(object):
    """ A simple class which describes the caption pane button attributes. """

    def __init__(self, button_id):
        """
        Default class constructor.
        Used internally, do not call it in your code!

        :param integer `button_id`: the pane button identifier.
        """

        self.button_id = button_id


# ---------------------------------------------------------------------------- #

# event declarations/classes

class AuiManagerEvent(wx.PyCommandEvent):
    """ A specialized command event class for events sent by :class:`AuiManager`. """

    def __init__(self, eventType, id=1):
        """
        Default class constructor.

        :param integer `eventType`: the event kind;
        :param integer `id`: the event identification number.
        """

        wx.PyCommandEvent.__init__(self, eventType, id)

        self.manager = None
        self.pane = None
        self.button = 0
        self.veto_flag = False
        self.canveto_flag = True
        self.dc = None


    def SetManager(self, mgr):
        """
        Associates a :class:`AuiManager` to the current event.

        :param `mgr`: an instance of :class:`AuiManager`.
        """

        self.manager = mgr


    def SetDC(self, pdc):
        """
        Associates a :class:`DC` device context to this event.

        :param `pdc`: a :class:`DC` device context object.
        """

        self.dc = pdc


    def SetPane(self, p):
        """
        Associates a :class:`AuiPaneInfo` instance to this event.

        :param `p`: a :class:`AuiPaneInfo` instance.
        """

        self.pane = p


    def SetButton(self, b):
        """
        Associates a :class:`AuiPaneButton` instance to this event.

        :param `b`: a :class:`AuiPaneButton` instance.
        """

        self.button = b


    def GetManager(self):
        """ Returns the associated :class:`AuiManager` (if any). """

        return self.manager


    def GetDC(self):
        """ Returns the associated :class:`DC` device context (if any). """

        return self.dc


    def GetPane(self):
        """ Returns the associated :class:`AuiPaneInfo` structure (if any). """

        return self.pane


    def GetButton(self):
        """ Returns the associated :class:`AuiPaneButton` instance (if any). """

        return self.button


    def Veto(self, veto=True):
        """
        Prevents the change announced by this event from happening.

        It is in general a good idea to notify the user about the reasons for
        vetoing the change because otherwise the applications behaviour (which
        just refuses to do what the user wants) might be quite surprising.

        :param bool `veto`: ``True`` to veto the event, ``False`` otherwise.
        """

        self.veto_flag = veto


    def GetVeto(self):
        """ Returns whether the event has been vetoed or not. """

        return self.veto_flag


    def SetCanVeto(self, can_veto):
        """
        Sets whether the event can be vetoed or not.

        :param bool `can_veto`: ``True`` if the event can be vetoed, ``False`` otherwise.
        """

        self.canveto_flag = can_veto


    def CanVeto(self):
        """ Returns whether the event can be vetoed and has been vetoed. """

        return  self.canveto_flag and self.veto_flag


# ---------------------------------------------------------------------------- #

class AuiPaneInfo(object):
    """
    AuiPaneInfo specifies all the parameters for a pane. These parameters specify where
    the pane is on the screen, whether it is docked or floating, or hidden. In addition,
    these parameters specify the pane's docked position, floating position, preferred
    size, minimum size, caption text among many other parameters.
    """

    optionFloating         = 2**0
    optionHidden           = 2**1
    optionLeftDockable     = 2**2
    optionRightDockable    = 2**3
    optionTopDockable      = 2**4
    optionBottomDockable   = 2**5
    optionFloatable        = 2**6
    optionMovable          = 2**7
    optionResizable        = 2**8
    optionPaneBorder       = 2**9
    optionCaption          = 2**10
    optionGripper          = 2**11
    optionDestroyOnClose   = 2**12
    optionToolbar          = 2**13
    optionActive           = 2**14
    optionGripperTop       = 2**15
    optionMaximized        = 2**16
    optionDockFixed        = 2**17
    optionNotebookDockable = 2**18
    optionMinimized        = 2**19
    optionLeftSnapped      = 2**20
    optionRightSnapped     = 2**21
    optionTopSnapped       = 2**22
    optionBottomSnapped    = 2**23
    optionFlyOut           = 2**24
    optionCaptionLeft      = 2**25

    buttonClose            = 2**26
    buttonMaximize         = 2**27
    buttonMinimize         = 2**28
    buttonPin              = 2**29

    buttonCustom1          = 2**30
    buttonCustom2          = 2**31
    buttonCustom3          = 2**32

    savedHiddenState       = 2**33    # used internally
    actionPane             = 2**34    # used internally
    wasMaximized           = 2**35    # used internally
    needsRestore           = 2**36    # used internally


    def __init__(self):
        """ Default class constructor. """

        self.window = None
        self.frame = None
        self.state = 0
        self.dock_direction = AUI_DOCK_LEFT
        self.dock_layer = 0
        self.dock_row = 0
        self.dock_pos = 0
        self.minimize_mode = AUI_MINIMIZE_POS_SMART
        self.floating_pos = wx.Point(-1, -1)
        self.floating_size = wx.Size(-1, -1)
        self.best_size = wx.Size(-1, -1)
        self.min_size = wx.Size(-1, -1)
        self.max_size = wx.Size(-1, -1)
        self.dock_proportion = 0
        self.caption = ""
        self.buttons = []
        self.name = ""
        self.icon = wx.NullIcon
        self.rect = wx.Rect()
        self.notebook_id = -1
        self.transparent = 255
        self.needsTransparency = False
        self.previousDockPos = None
        self.previousDockSize = 0
        self.snapped = 0
        self.minimize_target = None

        self.DefaultPane()


    def dock_direction_get(self):
        """
        Getter for the `dock_direction`.

        :see: :meth:`~AuiPaneInfo.dock_direction_set` for a set of valid docking directions.
        """

        if self.IsMaximized():
            return AUI_DOCK_CENTER
        else:
            return self._dock_direction


    def dock_direction_set(self, value):
        """
        Setter for the `dock_direction`.

        :param integer `value`: the docking direction. This can be one of the following bits:

        ============================ ======= =============================================
        Dock Flag                     Value  Description
        ============================ ======= =============================================
        ``AUI_DOCK_NONE``                  0 No docking direction.
        ``AUI_DOCK_TOP``                   1 Top docking direction.
        ``AUI_DOCK_RIGHT``                 2 Right docking direction.
        ``AUI_DOCK_BOTTOM``                3 Bottom docking direction.
        ``AUI_DOCK_LEFT``                  4 Left docking direction.
        ``AUI_DOCK_CENTER``                5 Center docking direction.
        ``AUI_DOCK_CENTRE``                5 Centre docking direction.
        ``AUI_DOCK_NOTEBOOK_PAGE``         6 Automatic AuiNotebooks docking style.
        ============================ ======= =============================================

        """

        self._dock_direction = value

    dock_direction = property(dock_direction_get, dock_direction_set)

    def IsOk(self):
        """
        Returns ``True`` if the :class:`AuiPaneInfo` structure is valid.

        :note: A pane structure is valid if it has an associated window.
        """

        return self.window != None


    def IsMaximized(self):
        """ Returns ``True`` if the pane is maximized. """

        return self.HasFlag(self.optionMaximized)


    def IsMinimized(self):
        """ Returns ``True`` if the pane is minimized. """

        return self.HasFlag(self.optionMinimized)


    def IsFixed(self):
        """ Returns ``True`` if the pane cannot be resized. """

        return not self.HasFlag(self.optionResizable)


    def IsResizeable(self):
        """ Returns ``True`` if the pane can be resized. """

        return self.HasFlag(self.optionResizable)


    def IsShown(self):
        """ Returns ``True`` if the pane is currently shown. """

        return not self.HasFlag(self.optionHidden)


    def IsFloating(self):
        """ Returns ``True`` if the pane is floating. """

        return self.HasFlag(self.optionFloating)


    def IsDocked(self):
        """ Returns ``True`` if the pane is docked. """

        return not self.HasFlag(self.optionFloating)


    def IsToolbar(self):
        """ Returns ``True`` if the pane contains a toolbar. """

        return self.HasFlag(self.optionToolbar)


    def IsTopDockable(self):
        """
        Returns ``True`` if the pane can be docked at the top
        of the managed frame.
        """

        return self.HasFlag(self.optionTopDockable)


    def IsBottomDockable(self):
        """
        Returns ``True`` if the pane can be docked at the bottom
        of the managed frame.
        """

        return self.HasFlag(self.optionBottomDockable)


    def IsLeftDockable(self):
        """
        Returns ``True`` if the pane can be docked at the left
        of the managed frame.
        """

        return self.HasFlag(self.optionLeftDockable)


    def IsRightDockable(self):
        """
        Returns ``True`` if the pane can be docked at the right
        of the managed frame.
        """

        return self.HasFlag(self.optionRightDockable)


    def IsDockable(self):
        """ Returns ``True`` if the pane can be docked. """

        return self.IsTopDockable() or self.IsBottomDockable() or self.IsLeftDockable() or \
               self.IsRightDockable() or self.IsNotebookDockable()


    def IsFloatable(self):
        """
        Returns ``True`` if the pane can be undocked and displayed as a
        floating window.
        """

        return self.HasFlag(self.optionFloatable)


    def IsMovable(self):
        """
        Returns ``True`` if the docked frame can be undocked or moved to
        another dock position.
        """

        return self.HasFlag(self.optionMovable)


    def IsDestroyOnClose(self):
        """
        Returns ``True`` if the pane should be destroyed when it is closed.

        Normally a pane is simply hidden when the close button is clicked. Calling :meth:`~AuiPaneInfo.DestroyOnClose`
        with a ``True`` input parameter will cause the window to be destroyed when the user clicks
        the pane's close button.
        """

        return self.HasFlag(self.optionDestroyOnClose)


    def IsNotebookDockable(self):
        """
        Returns ``True`` if a pane can be docked on top to another to create a
        :class:`~lib.agw.aui.auibook.AuiNotebook`.
        """

        return self.HasFlag(self.optionNotebookDockable)


    def IsTopSnappable(self):
        """ Returns ``True`` if the pane can be snapped at the top of the managed frame. """

        return self.HasFlag(self.optionTopSnapped)


    def IsBottomSnappable(self):
        """ Returns ``True`` if the pane can be snapped at the bottom of the managed frame. """

        return self.HasFlag(self.optionBottomSnapped)


    def IsLeftSnappable(self):
        """ Returns ``True`` if the pane can be snapped on the left of the managed frame. """

        return self.HasFlag(self.optionLeftSnapped)


    def IsRightSnappable(self):
        """ Returns ``True`` if the pane can be snapped on the right of the managed frame. """

        return self.HasFlag(self.optionRightSnapped)


    def IsSnappable(self):
        """ Returns ``True`` if the pane can be snapped. """

        return self.IsTopSnappable() or self.IsBottomSnappable() or self.IsLeftSnappable() or \
               self.IsRightSnappable()


    def IsFlyOut(self):
        """ Returns ``True`` if the floating pane has a "fly-out" effect. """

        return self.HasFlag(self.optionFlyOut)


    def HasCaption(self):
        """ Returns ``True`` if the pane displays a caption. """

        return self.HasFlag(self.optionCaption)


    def HasCaptionLeft(self):
        """ Returns ``True`` if the pane displays a caption on the left (rotated by 90 degrees). """

        return self.HasFlag(self.optionCaptionLeft)


    def HasGripper(self):
        """ Returns ``True`` if the pane displays a gripper. """

        return self.HasFlag(self.optionGripper)


    def HasBorder(self):
        """ Returns ``True`` if the pane displays a border. """

        return self.HasFlag(self.optionPaneBorder)


    def HasCloseButton(self):
        """ Returns ``True`` if the pane displays a button to close the pane. """

        return self.HasFlag(self.buttonClose)


    def HasMaximizeButton(self):
        """ Returns ``True`` if the pane displays a button to maximize the pane. """

        return self.HasFlag(self.buttonMaximize)


    def HasMinimizeButton(self):
        """ Returns ``True`` if the pane displays a button to minimize the pane. """

        return self.HasFlag(self.buttonMinimize)


    def GetMinimizeMode(self):
        """
        Returns the minimization style for this pane.

        Possible return values are:

        ============================== ========= ==============================
        Minimize Mode Flag             Hex Value Description
        ============================== ========= ==============================
        ``AUI_MINIMIZE_POS_SMART``          0x01 Minimizes the pane on the closest tool bar
        ``AUI_MINIMIZE_POS_TOP``            0x02 Minimizes the pane on the top tool bar
        ``AUI_MINIMIZE_POS_LEFT``           0x03 Minimizes the pane on its left tool bar
        ``AUI_MINIMIZE_POS_RIGHT``          0x04 Minimizes the pane on its right tool bar
        ``AUI_MINIMIZE_POS_BOTTOM``         0x05 Minimizes the pane on its bottom tool bar
        ``AUI_MINIMIZE_POS_TOOLBAR``        0x06 Minimizes the pane on a target :class:`~lib.agw.aui.auibar.AuiToolBar`
        ``AUI_MINIMIZE_POS_MASK``           0x17 Mask to filter the position flags
        ``AUI_MINIMIZE_CAPT_HIDE``           0x0 Hides the caption of the minimized pane
        ``AUI_MINIMIZE_CAPT_SMART``         0x08 Displays the caption in the best rotation (horizontal or clockwise)
        ``AUI_MINIMIZE_CAPT_HORZ``          0x10 Displays the caption horizontally
        ``AUI_MINIMIZE_CAPT_MASK``          0x18 Mask to filter the caption flags
        ============================== ========= ==============================

        The flags can be filtered with the following masks:

        ============================== ========= ==============================
        Minimize Mask Flag             Hex Value Description
        ============================== ========= ==============================
        ``AUI_MINIMIZE_POS_MASK``           0x17 Filters the position flags
        ``AUI_MINIMIZE_CAPT_MASK``          0x18 Filters the caption flags
        ============================== ========= ==============================

        """

        return self.minimize_mode


    def HasPinButton(self):
        """ Returns ``True`` if the pane displays a button to float the pane. """

        return self.HasFlag(self.buttonPin)


    def HasGripperTop(self):
        """ Returns ``True`` if the pane displays a gripper at the top. """

        return self.HasFlag(self.optionGripperTop)


    def Window(self, w):
        """
        Associate a :class:`Window` derived window to this pane.

        This normally does not need to be specified, as the window pointer is
        automatically assigned to the :class:`AuiPaneInfo` structure as soon as it is
        added to the manager.

        :param `w`: a :class:`Window` derived window.
        """

        self.window = w
        return self


    def Name(self, name):
        """
        Sets the name of the pane so it can be referenced in lookup functions.

        If a name is not specified by the user, a random name is assigned to the pane
        when it is added to the manager.

        :param `name`: a string specifying the pane name.

        .. warning::

           If you are using :meth:`AuiManager.SavePerspective` and :meth:`AuiManager.LoadPerspective`,
           you will have to specify a name for your pane using :meth:`~AuiPaneInfo.Name`, as perspectives
           containing randomly generated names can not be properly restored.
        """

        self.name = name
        return self


    def Caption(self, caption):
        """
        Sets the caption of the pane.

        :param string `caption`: a string specifying the pane caption.
        """

        self.caption = caption
        return self


    def Left(self):
        """
        Sets the pane dock position to the left side of the frame.

        :note: This is the same thing as calling :meth:`~AuiPaneInfo.Direction` with ``AUI_DOCK_LEFT`` as
         parameter.
        """

        self.dock_direction = AUI_DOCK_LEFT
        return self


    def Right(self):
        """
        Sets the pane dock position to the right side of the frame.

        :note: This is the same thing as calling :meth:`~AuiPaneInfo.Direction` with ``AUI_DOCK_RIGHT`` as
         parameter.
        """

        self.dock_direction = AUI_DOCK_RIGHT
        return self


    def Top(self):
        """
        Sets the pane dock position to the top of the frame.

        :note: This is the same thing as calling :meth:`~AuiPaneInfo.Direction` with ``AUI_DOCK_TOP`` as
         parameter.
        """

        self.dock_direction = AUI_DOCK_TOP
        return self


    def Bottom(self):
        """
        Sets the pane dock position to the bottom of the frame.

        :note: This is the same thing as calling :meth:`~AuiPaneInfo.Direction` with ``AUI_DOCK_BOTTOM`` as
         parameter.
        """

        self.dock_direction = AUI_DOCK_BOTTOM
        return self


    def Center(self):
        """
        Sets the pane to the center position of the frame.

        The centre pane is the space in the middle after all border panes (left, top,
        right, bottom) are subtracted from the layout.

        :note: This is the same thing as calling :meth:`~AuiPaneInfo.Direction` with ``AUI_DOCK_CENTER`` as
         parameter.
        """

        self.dock_direction = AUI_DOCK_CENTER
        return self


    def Centre(self):
        """
        Sets the pane to the center position of the frame.

        The centre pane is the space in the middle after all border panes (left, top,
        right, bottom) are subtracted from the layout.

        :note: This is the same thing as calling :meth:`~AuiPaneInfo.Direction` with ``AUI_DOCK_CENTRE`` as
         parameter.
        """

        self.dock_direction = AUI_DOCK_CENTRE
        return self


    def Direction(self, direction):
        """
        Determines the direction of the docked pane. It is functionally the
        same as calling :meth:`Left`, :meth:`Right`, :meth:`Top` or :meth:`Bottom`,
        except that docking direction may be specified programmatically via the parameter `direction`.

        :param integer `direction`: the direction of the docked pane.

        :see: :meth:`dock_direction_set` for a list of valid docking directions.
        """

        self.dock_direction = direction
        return self


    def Layer(self, layer):
        """
        Determines the layer of the docked pane.

        The dock layer is similar to an onion, the inner-most layer being layer 0. Each
        shell moving in the outward direction has a higher layer number. This allows for
        more complex docking layout formation.

        :param integer `layer`: the layer of the docked pane.
        """

        self.dock_layer = layer
        return self


    def Row(self, row):
        """
        Determines the row of the docked pane.

        :param integer `row`: the row of the docked pane.
        """

        self.dock_row = row
        return self


    def Position(self, pos):
        """
        Determines the position of the docked pane.

        :param integer `pos`: the position of the docked pane.
        """

        self.dock_pos = pos
        return self


    def MinSize(self, arg1=None, arg2=None):
        """
        Sets the minimum size of the pane.

        This method is split in 2 versions depending on the input type. If `arg1` is
        a :class:`Size` object, then :meth:`~AuiPaneInfo.MinSize1` is called. Otherwise, :meth:`~AuiPaneInfo.MinSize2` is called.

        :param `arg1`: a :class:`Size` object, a (x, y) tuple or or a `x` coordinate.
        :param `arg2`: a `y` coordinate (only if `arg1` is a `x` coordinate, otherwise unused).
        """

        if isinstance(arg1, wx.Size):
            ret = self.MinSize1(arg1)
        elif isinstance(arg1, types.TupleType):
            ret = self.MinSize1(wx.Size(*arg1))
        elif isinstance(arg1, types.IntType) and arg2 is not None:
            ret = self.MinSize2(arg1, arg2)
        else:
            raise Exception("Invalid argument passed to `MinSize`: arg1=%s, arg2=%s"%(repr(arg1), repr(arg2)))

        return ret


    def MinSize1(self, size):
        """
        Sets the minimum size of the pane.

        :see: :meth:`MinSize` for an explanation of input parameters.
        """
        self.min_size = size
        return self


    def MinSize2(self, x, y):
        """
        Sets the minimum size of the pane.

        :see: :meth:`MinSize` for an explanation of input parameters.
        """

        self.min_size = wx.Size(x, y)
        return self


    def MaxSize(self, arg1=None, arg2=None):
        """
        Sets the maximum size of the pane.

        This method is split in 2 versions depending on the input type. If `arg1` is
        a :class:`Size` object, then :meth:`~AuiPaneInfo.MaxSize1` is called. Otherwise, :meth:`~AuiPaneInfo.MaxSize2` is called.

        :param `arg1`: a :class:`Size` object, a (x, y) tuple or a `x` coordinate.
        :param `arg2`: a `y` coordinate (only if `arg1` is a `x` coordinate, otherwise unused).
        """

        if isinstance(arg1, wx.Size):
            ret = self.MaxSize1(arg1)
        elif isinstance(arg1, types.TupleType):
            ret = self.MaxSize1(wx.Size(*arg1))
        elif isinstance(arg1, types.IntType) and arg2 is not None:
            ret = self.MaxSize2(arg1, arg2)
        else:
            raise Exception("Invalid argument passed to `MaxSize`: arg1=%s, arg2=%s"%(repr(arg1), repr(arg2)))

        return ret


    def MaxSize1(self, size):
        """
        Sets the maximum size of the pane.

        :see: :meth:`MaxSize` for an explanation of input parameters.
        """

        self.max_size = size
        return self


    def MaxSize2(self, x, y):
        """
        Sets the maximum size of the pane.

        :see: :meth:`MaxSize` for an explanation of input parameters.
        """

        self.max_size.Set(x,y)
        return self


    def BestSize(self, arg1=None, arg2=None):
        """
        Sets the ideal size for the pane. The docking manager will attempt to use
        this size as much as possible when docking or floating the pane.

        This method is split in 2 versions depending on the input type. If `arg1` is
        a :class:`Size` object, then :meth:`BestSize1` is called. Otherwise, :meth:`BestSize2` is called.

        :param `arg1`: a :class:`Size` object, a (x, y) tuple or a `x` coordinate.
        :param `arg2`: a `y` coordinate (only if `arg1` is a `x` coordinate, otherwise unused).
        """

        if isinstance(arg1, wx.Size):
            ret = self.BestSize1(arg1)
        elif isinstance(arg1, types.TupleType):
            ret = self.BestSize1(wx.Size(*arg1))
        elif isinstance(arg1, types.IntType) and arg2 is not None:
            ret = self.BestSize2(arg1, arg2)
        else:
            raise Exception("Invalid argument passed to `BestSize`: arg1=%s, arg2=%s"%(repr(arg1), repr(arg2)))

        return ret


    def BestSize1(self, size):
        """
        Sets the best size of the pane.

        :see: :meth:`BestSize` for an explanation of input parameters.
        """

        self.best_size = size
        return self


    def BestSize2(self, x, y):
        """
        Sets the best size of the pane.

        :see: :meth:`BestSize` for an explanation of input parameters.
        """

        self.best_size.Set(x,y)
        return self


    def FloatingPosition(self, pos):
        """
        Sets the position of the floating pane.

        :param `pos`: a :class:`Point` or a tuple indicating the pane floating position.
        """

        self.floating_pos = wx.Point(*pos)
        return self


    def FloatingSize(self, size):
        """
        Sets the size of the floating pane.

        :param `size`: a :class:`Size` or a tuple indicating the pane floating size.
        """

        self.floating_size = wx.Size(*size)
        return self


    def Maximize(self):
        """ Makes the pane take up the full area."""

        return self.SetFlag(self.optionMaximized, True)


    def Minimize(self):
        """
        Makes the pane minimized in a :class:`~lib.agw.aui.auibar.AuiToolBar`.

        Clicking on the minimize button causes a new :class:`~lib.agw.aui.auibar.AuiToolBar` to be created
        and added to the frame manager, (currently the implementation is such that
        panes at West will have a toolbar at the right, panes at South will have
        toolbars at the bottom etc...) and the pane is hidden in the manager.

        Clicking on the restore button on the newly created toolbar will result in the
        toolbar being removed and the original pane being restored.
        """

        return self.SetFlag(self.optionMinimized, True)


    def MinimizeMode(self, mode):
        """
        Sets the expected minimized mode if the minimize button is visible.

        :param integer `mode`: the minimized pane can have a specific position in the work space:

        ============================== ========= ==============================
        Minimize Mode Flag             Hex Value Description
        ============================== ========= ==============================
        ``AUI_MINIMIZE_POS_SMART``          0x01 Minimizes the pane on the closest tool bar
        ``AUI_MINIMIZE_POS_TOP``            0x02 Minimizes the pane on the top tool bar
        ``AUI_MINIMIZE_POS_LEFT``           0x03 Minimizes the pane on its left tool bar
        ``AUI_MINIMIZE_POS_RIGHT``          0x04 Minimizes the pane on its right tool bar
        ``AUI_MINIMIZE_POS_BOTTOM``         0x05 Minimizes the pane on its bottom tool bar
        ``AUI_MINIMIZE_POS_TOOLBAR``        0x06 Minimizes the pane on a target :class:`~lib.agw.aui.auibar.AuiToolBar`
        ============================== ========= ==============================

        The caption of the minimized pane can be displayed in different modes:

        ============================== ========= ==============================
        Caption Mode Flag              Hex Value Description
        ============================== ========= ==============================
        ``AUI_MINIMIZE_CAPT_HIDE``           0x0 Hides the caption of the minimized pane
        ``AUI_MINIMIZE_CAPT_SMART``         0x08 Displays the caption in the best rotation (horizontal in the top and in
                                                 the bottom tool bar or clockwise in the right and in the left tool bar)
        ``AUI_MINIMIZE_CAPT_HORZ``          0x10 Displays the caption horizontally
        ============================== ========= ==============================

        .. note::

           In order to use the ``AUI_MINIMIZE_POS_TOOLBAR`` flag, the instance of :class:`AuiManager`
           you pass as an input for :meth:`MinimizeTarget` **must** have a real name and not the randomly
           generated one. Remember to set the :meth:`Name` property of the toolbar pane before calling this method.

        """

        self.minimize_mode = mode
        return self


    def MinimizeTarget(self, toolbarPane):
        """
        Minimizes the panes using a :class:`AuiPaneInfo` as a target. As :class:`AuiPaneInfo` properties
        need to be copied back and forth every time the perspective has changed, we
        only store the toobar **name**.

        :param `toolbarPane`: an instance of :class:`AuiPaneInfo`, containing a :class:`~lib.agw.aui.auibar.AuiToolBar`.

        .. note::

           In order to use this functionality (and with the ``AUI_MINIMIZE_POS_TOOLBAR``
           flag set), the instance of :class:`AuiPaneInfo` you pass as an input **must** have a real
           name and not the randomly generated one. Remember to set the :meth:`Name` property of
           the toolbar pane before calling this method.

        """

        self.minimize_target = toolbarPane.name
        return self


    def Restore(self):
        """ Is the reverse of :meth:`Maximize` and :meth:`Minimize`."""

        return self.SetFlag(self.optionMaximized or self.optionMinimized, False)


    def Fixed(self):
        """
        Forces a pane to be fixed size so that it cannot be resized.
        After calling :meth:`Fixed`, :meth:`IsFixed` will return ``True``.
        """

        return self.SetFlag(self.optionResizable, False)


    def Resizable(self, resizable=True):
        """
        Allows a pane to be resizable if `resizable` is ``True``, and forces
        it to be a fixed size if `resizeable` is ``False``.

        If `resizable` is ``False``, this is simply an antonym for :meth:`Fixed`.

        :param bool `resizable`: whether the pane will be resizeable or not.
        """

        return self.SetFlag(self.optionResizable, resizable)


    def Transparent(self, alpha):
        """
        Makes the pane transparent when floating.

        :param integer `alpha`: a value between 0 and 255 for pane transparency.
        """

        if alpha < 0 or alpha > 255:
            raise Exception("Invalid transparency value (%s)"%repr(alpha))

        self.transparent = alpha
        self.needsTransparency = True


    def Dock(self):
        """ Indicates that a pane should be docked. It is the opposite of :meth:`Float`. """

        if self.IsNotebookPage():
            self.notebook_id = -1
            self.dock_direction = AUI_DOCK_NONE

        return self.SetFlag(self.optionFloating, False)


    def Float(self):
        """ Indicates that a pane should be floated. It is the opposite of :meth:`Dock`. """

        if self.IsNotebookPage():
            self.notebook_id = -1
            self.dock_direction = AUI_DOCK_NONE

        return self.SetFlag(self.optionFloating, True)


    def Hide(self):
        """
        Indicates that a pane should be hidden.

        Calling :meth:`Show(False) <Show>` achieve the same effect.
        """

        return self.SetFlag(self.optionHidden, True)


    def Show(self, show=True):
        """
        Indicates that a pane should be shown.

        :param bool `show`: whether the pane should be shown or not.
        """

        return self.SetFlag(self.optionHidden, not show)


    # By defaulting to 1000, the tab will get placed at the end
    def NotebookPage(self, id, tab_position=1000):
        """
        Forces a pane to be a notebook page, so that the pane can be
        docked on top to another to create a :class:`~lib.agw.aui.auibook.AuiNotebook`.

        :param integer `id`: the notebook id;
        :param integer `tab_position`: the tab number of the pane once docked in a notebook.
        """

        # Remove any floating frame
        self.Dock()
        self.notebook_id = id
        self.dock_pos = tab_position
        self.dock_row = 0
        self.dock_layer = 0
        self.dock_direction = AUI_DOCK_NOTEBOOK_PAGE

        return self


    def NotebookControl(self, id):
        """
        Forces a pane to be a notebook control (:class:`~lib.agw.aui.auibook.AuiNotebook`).

        :param integer `id`: the notebook id.
        """

        self.notebook_id = id
        self.window = None
        self.buttons = []

        if self.dock_direction == AUI_DOCK_NOTEBOOK_PAGE:
            self.dock_direction = AUI_DOCK_NONE

        return self


    def HasNotebook(self):
        """ Returns whether a pane has a :class:`~lib.agw.aui.auibook.AuiNotebook` or not. """

        return self.notebook_id >= 0


    def IsNotebookPage(self):
        """ Returns whether the pane is a notebook page in a :class:`~lib.agw.aui.auibook.AuiNotebook`. """

        return self.notebook_id >= 0 and self.dock_direction == AUI_DOCK_NOTEBOOK_PAGE


    def IsNotebookControl(self):
        """ Returns whether the pane is a notebook control (:class:`~lib.agw.aui.auibook.AuiNotebook`). """

        return not self.IsNotebookPage() and self.HasNotebook()


    def SetNameFromNotebookId(self):
        """ Sets the pane name once docked in a :class:`~lib.agw.aui.auibook.AuiNotebook` using the notebook id. """

        if self.notebook_id >= 0:
            self.name = "__notebook_%d"%self.notebook_id

        return self


    def CaptionVisible(self, visible=True, left=False):
        """
        Indicates that a pane caption should be visible. If `visible` is ``False``, no pane
        caption is drawn.

        :param bool `visible`: whether the caption should be visible or not;
        :param bool `left`: whether the caption should be drawn on the left (rotated by 90 degrees) or not.
        """

        if left:
            self.SetFlag(self.optionCaption, False)
            return self.SetFlag(self.optionCaptionLeft, visible)

        self.SetFlag(self.optionCaptionLeft, False)
        return self.SetFlag(self.optionCaption, visible)


    def PaneBorder(self, visible=True):
        """
        Indicates that a border should be drawn for the pane.

        :param bool `visible`: whether the pane border should be visible or not.
        """

        return self.SetFlag(self.optionPaneBorder, visible)


    def Gripper(self, visible=True):
        """
        Indicates that a gripper should be drawn for the pane.

        :param bool `visible`: whether the gripper should be visible or not.
        """

        return self.SetFlag(self.optionGripper, visible)


    def GripperTop(self, attop=True):
        """
        Indicates that a gripper should be drawn at the top of the pane.

        :param bool `attop`: whether the gripper should be drawn at the top or not.
        """

        return self.SetFlag(self.optionGripperTop, attop)


    def CloseButton(self, visible=True):
        """
        Indicates that a close button should be drawn for the pane.

        :param bool `visible`: whether the close button should be visible or not.
        """

        return self.SetFlag(self.buttonClose, visible)


    def MaximizeButton(self, visible=True):
        """
        Indicates that a maximize button should be drawn for the pane.

        :param bool `visible`: whether the maximize button should be visible or not.
        """

        return self.SetFlag(self.buttonMaximize, visible)


    def MinimizeButton(self, visible=True):
        """
        Indicates that a minimize button should be drawn for the pane.

        :param bool `visible`: whether the minimize button should be visible or not.
        """

        return self.SetFlag(self.buttonMinimize, visible)


    def PinButton(self, visible=True):
        """
        Indicates that a pin button should be drawn for the pane.

        :param bool `visible`: whether the pin button should be visible or not.
        """

        return self.SetFlag(self.buttonPin, visible)


    def DestroyOnClose(self, b=True):
        """
        Indicates whether a pane should be destroyed when it is closed.

        Normally a pane is simply hidden when the close button is clicked. Setting
        `b` to ``True`` will cause the window to be destroyed when the user clicks
        the pane's close button.

        :param bool `b`: whether the pane should be destroyed when it is closed or not.
        """

        return self.SetFlag(self.optionDestroyOnClose, b)


    def TopDockable(self, b=True):
        """
        Indicates whether a pane can be docked at the top of the frame.

        :param bool `b`: whether the pane can be docked at the top or not.
        """

        return self.SetFlag(self.optionTopDockable, b)


    def BottomDockable(self, b=True):
        """
        Indicates whether a pane can be docked at the bottom of the frame.

        :param bool `b`: whether the pane can be docked at the bottom or not.
        """

        return self.SetFlag(self.optionBottomDockable, b)


    def LeftDockable(self, b=True):
        """
        Indicates whether a pane can be docked on the left of the frame.

        :param bool `b`: whether the pane can be docked at the left or not.
        """

        return self.SetFlag(self.optionLeftDockable, b)


    def RightDockable(self, b=True):
        """
        Indicates whether a pane can be docked on the right of the frame.

        :param bool `b`: whether the pane can be docked at the right or not.
        """

        return self.SetFlag(self.optionRightDockable, b)


    def Floatable(self, b=True):
        """
        Sets whether the user will be able to undock a pane and turn it
        into a floating window.

        :param bool `b`: whether the pane can be floated or not.
        """

        return self.SetFlag(self.optionFloatable, b)


    def Movable(self, b=True):
        """
        Indicates whether a pane can be moved.

        :param bool `b`: whether the pane can be moved or not.
        """

        return self.SetFlag(self.optionMovable, b)


    def NotebookDockable(self, b=True):
        """
        Indicates whether a pane can be docked in an automatic :class:`~lib.agw.aui.auibook.AuiNotebook`.

        :param bool `b`: whether the pane can be docked in a notebook or not.
        """

        return self.SetFlag(self.optionNotebookDockable, b)


    def DockFixed(self, b=True):
        """
        Causes the containing dock to have no resize sash. This is useful
        for creating panes that span the entire width or height of a dock, but should
        not be resizable in the other direction.

        :param bool `b`: whether the pane will have a resize sash or not.
        """

        return self.SetFlag(self.optionDockFixed, b)


    def Dockable(self, b=True):
        """
        Specifies whether a frame can be docked or not. It is the same as specifying
        :meth:`TopDockable` . :meth:`BottomDockable` . :meth:`LeftDockable` . :meth:`RightDockable` .

        :param bool `b`: whether the frame can be docked or not.
        """

        return self.TopDockable(b).BottomDockable(b).LeftDockable(b).RightDockable(b)


    def TopSnappable(self, b=True):
        """
        Indicates whether a pane can be snapped at the top of the main frame.

        :param bool `b`: whether the pane can be snapped at the top of the main frame or not.
        """

        return self.SetFlag(self.optionTopSnapped, b)


    def BottomSnappable(self, b=True):
        """
        Indicates whether a pane can be snapped at the bottom of the main frame.

        :param bool `b`: whether the pane can be snapped at the bottom of the main frame or not.
        """

        return self.SetFlag(self.optionBottomSnapped, b)


    def LeftSnappable(self, b=True):
        """
        Indicates whether a pane can be snapped on the left of the main frame.

        :param bool `b`: whether the pane can be snapped at the left of the main frame or not.
        """

        return self.SetFlag(self.optionLeftSnapped, b)


    def RightSnappable(self, b=True):
        """
        Indicates whether a pane can be snapped on the right of the main frame.

        :param bool `b`: whether the pane can be snapped at the right of the main frame or not.
        """

        return self.SetFlag(self.optionRightSnapped, b)


    def Snappable(self, b=True):
        """
        Indicates whether a pane can be snapped on the main frame. This is
        equivalent as calling :meth:`TopSnappable` . :meth:`BottomSnappable` . :meth:`LeftSnappable` . :meth:`RightSnappable` .

        :param bool `b`: whether the pane can be snapped on the main frame or not.
        """

        return self.TopSnappable(b).BottomSnappable(b).LeftSnappable(b).RightSnappable(b)


    def FlyOut(self, b=True):
        """
        Indicates whether a pane, when floating, has a "fly-out" effect
        (i.e., floating panes which only show themselves when moused over).

        :param bool `b`: whether the pane can be snapped on the main frame or not.
        """

        return self.SetFlag(self.optionFlyOut, b)


    # Copy over the members that pertain to docking position
    def SetDockPos(self, source):
        """
        Copies the `source` pane members that pertain to docking position to `self`.

        :param AuiPaneInfo `source`: the source pane from where to copy the attributes.
        """

        self.dock_direction = source.dock_direction
        self.dock_layer = source.dock_layer
        self.dock_row = source.dock_row
        self.dock_pos = source.dock_pos
        self.dock_proportion = source.dock_proportion
        self.floating_pos = wx.Point(*source.floating_pos)
        self.floating_size = wx.Size(*source.floating_size)
        self.rect = wx.Rect(*source.rect)

        return self


    def DefaultPane(self):
        """ Specifies that the pane should adopt the default pane settings. """

        state = self.state
        state |= self.optionTopDockable | self.optionBottomDockable | \
                 self.optionLeftDockable | self.optionRightDockable | \
                 self.optionNotebookDockable | \
                 self.optionFloatable | self.optionMovable | self.optionResizable | \
                 self.optionCaption | self.optionPaneBorder | self.buttonClose

        self.state = state
        return self


    def CentrePane(self):
        """
        Specifies that the pane should adopt the default center pane settings.

        Centre panes usually do not have caption bars. This function provides an easy way of
        preparing a pane to be displayed in the center dock position.
        """

        return self.CenterPane()


    def CenterPane(self):
        """
        Specifies that the pane should adopt the default center pane settings.

        Centre panes usually do not have caption bars. This function provides an easy way of
        preparing a pane to be displayed in the center dock position.
        """

        self.state = 0
        return self.Center().PaneBorder().Resizable()


    def ToolbarPane(self):
        """ Specifies that the pane should adopt the default toolbar pane settings. """

        self.DefaultPane()
        state = self.state

        state |= (self.optionToolbar | self.optionGripper)
        state &= ~(self.optionResizable | self.optionCaption | self.optionCaptionLeft | self.buttonClose)

        if self.dock_layer == 0:
            self.dock_layer = 10

        self.state = state

        return self


    def Icon(self, icon):
        """
        Specifies whether an icon is drawn on the left of the caption text when
        the pane is docked. If `icon` is ``None`` or :class:`NullIcon`, no icon is drawn on
        the caption space.

        :param icon: an icon to draw on the caption space, or ``None``.
        :type `icon`: :class:`Icon` or ``None``
        """

        if icon is None:
            icon = wx.NullIcon

        self.icon = icon
        return self


    def SetFlag(self, flag, option_state):
        """
        Turns the property given by `flag` on or off with the `option_state`
        parameter.

        :param integer `flag`: the property to set;
        :param bool `option_state`: either ``True`` or ``False``.
        """

        state = self.state

        if option_state:
            state |= flag
        else:
            state &= ~flag

        self.state = state

        if flag in [self.buttonClose, self.buttonMaximize, self.buttonMinimize, self.buttonPin]:
            self.ResetButtons()

        return self


    def HasFlag(self, flag):
        """
        Returns ``True`` if the the property specified by flag is active for the pane.

        :param integer `flag`: the property to check for activity.
        """

        return (self.state & flag and [True] or [False])[0]


    def ResetButtons(self):
        """
        Resets all the buttons and recreates them from scratch depending on the
        :class:`AuiManager` flags.
        """

        floating = self.HasFlag(self.optionFloating)
        self.buttons = []

        if not floating and self.HasMinimizeButton():
            button = AuiPaneButton(AUI_BUTTON_MINIMIZE)
            self.buttons.append(button)

        if not floating and self.HasMaximizeButton():
            button = AuiPaneButton(AUI_BUTTON_MAXIMIZE_RESTORE)
            self.buttons.append(button)

        if not floating and self.HasPinButton():
            button = AuiPaneButton(AUI_BUTTON_PIN)
            self.buttons.append(button)

        if self.HasCloseButton():
            button = AuiPaneButton(AUI_BUTTON_CLOSE)
            self.buttons.append(button)


    def CountButtons(self):
        """ Returns the number of visible buttons in the docked pane. """

        n = 0

        if self.HasCaption() or self.HasCaptionLeft():
            if isinstance(wx.GetTopLevelParent(self.window), AuiFloatingFrame):
                return 1

            if self.HasCloseButton():
                n += 1
            if self.HasMaximizeButton():
                n += 1
            if self.HasMinimizeButton():
                n += 1
            if self.HasPinButton():
                n += 1

        return n


    def IsHorizontal(self):
        """ Returns ``True`` if the pane `dock_direction` is horizontal. """

        return self.dock_direction in [AUI_DOCK_TOP, AUI_DOCK_BOTTOM]

    def IsVertical(self):
        """ Returns ``True`` if the pane `dock_direction` is vertical. """

        return self.dock_direction in [AUI_DOCK_LEFT, AUI_DOCK_RIGHT]


# Null AuiPaneInfo reference
NonePaneInfo = AuiPaneInfo()
""" Null :class:`AuiPaneInfo` reference, an invalid instance of :class:`AuiPaneInfo`. """


# ---------------------------------------------------------------------------- #

class AuiDockingGuide(wx.Frame):
    """ Base class for :class:`AuiSingleDockingGuide` and :class:`AuiCenterDockingGuide`."""

    def __init__(self, parent, id=wx.ID_ANY, title="", pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=wx.FRAME_TOOL_WINDOW | wx.STAY_ON_TOP |
                 wx.FRAME_NO_TASKBAR | wx.NO_BORDER, name="AuiDockingGuide"):
        """
        Default class constructor. Used internally, do not call it in your code!

        :param `parent`: the :class:`AuiManager` parent;
        :param integer `id`: the window identifier. It may take a value of -1 to indicate a default value.
        :param string `title`: the caption to be displayed on the frame's title bar.
        :param Point `pos`: the window position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform.
        :param Size `size`: the window size. A value of (-1, -1) indicates a default size, chosen by
         either the windowing system or wxPython, depending on platform.
        :param integer `style`: the window style.
        :param string `name`: the name of the window. This parameter is used to associate a name with the
         item, allowing the application user to set Motif resource values for individual windows.
        """

        wx.Frame.__init__(self, parent, id, title, pos, size, style, name=name)


    def HitTest(self, x, y):
        """
        To be overridden by parent classes.

        :param integer `x`: the `x` mouse position;
        :param integer `y`: the `y` mouse position.
        """

        return 0


    def ValidateNotebookDocking(self, valid):
        """
        To be overridden by parent classes.

        :param bool `valid`: whether a pane can be docked on top to another to form an automatic
         :class:`~lib.agw.aui.auibook.AuiNotebook`.
        """

        return 0

# ============================================================================
# implementation
# ============================================================================

# ---------------------------------------------------------------------------
# AuiDockingGuideWindow
# ---------------------------------------------------------------------------

class AuiDockingGuideWindow(wx.Window):
    """ Target class for :class:`AuiDockingGuide` and :class:`AuiCenterDockingGuide`. """

    def __init__(self, parent, rect, direction=0, center=False, useAero=False):
        """
        Default class constructor. Used internally, do not call it in your code!

        :param `parent`: the :class:`AuiManager` parent;
        :param Rect `rect`: the window rect;
        :param integer `direction`: one of ``wx.TOP``, ``wx.BOTTOM``, ``wx.LEFT``, ``wx.RIGHT``,
         ``wx.CENTER``;
        :param bool `center`: whether the calling class is a :class:`AuiCenterDockingGuide`;
        :param bool `useAero`: whether to use the new Aero-style bitmaps or Whidbey-style bitmaps
         for the docking guide.
        """

        wx.Window.__init__(self, parent, -1, rect.GetPosition(), rect.GetSize(), wx.NO_BORDER)

        self._direction = direction
        self._center = center
        self._valid = True
        self._useAero = useAero

        self._bmp_unfocus, self._bmp_focus = GetDockingImage(direction, useAero, center)

        self._currentImage = self._bmp_unfocus
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)

        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_PAINT, self.OnPaint)


    def SetValid(self, valid):
        """
        Sets the docking direction as valid or invalid.

        :param bool `valid`: whether the docking direction is allowed or not.
        """

        self._valid = valid


    def IsValid(self):
        """ Returns whether the docking direction is valid. """

        return self._valid


    def OnEraseBackground(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for :class:`AuiDockingGuideWindow`.

        :param `event`: a :class:`EraseEvent` to be processed.

        :note: This is intentionally empty to reduce flickering while drawing.
        """

        pass


    def DrawBackground(self, dc):
        """
        Draws the docking guide background.

        :param `dc`: a :class:`DC` device context object.
        """

        rect = self.GetClientRect()

        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.SetBrush(wx.Brush(colourTargetBackground))
        dc.DrawRectangleRect(rect)

        dc.SetPen(wx.Pen(colourTargetBorder))

        left = rect.GetLeft()
        top = rect.GetTop()
        right = rect.GetRight()
        bottom = rect.GetBottom()

        if self._direction != wx.CENTER:

            if not self._center or self._direction != wx.BOTTOM:
                dc.DrawLine(left, top, right+1, top)
            if not self._center or self._direction != wx.RIGHT:
                dc.DrawLine(left, top, left, bottom+1)
            if not self._center or self._direction != wx.LEFT:
                dc.DrawLine(right, top, right, bottom+1)
            if not self._center or self._direction != wx.TOP:
                dc.DrawLine(left, bottom, right+1, bottom)

            dc.SetPen(wx.Pen(colourTargetShade))

            if self._direction != wx.RIGHT:
                dc.DrawLine(left + 1, top + 1, left + 1, bottom)
            if self._direction != wx.BOTTOM:
                dc.DrawLine(left + 1, top + 1, right, top + 1)


    def DrawDottedLine(self, dc, point, length, vertical):
        """
        Draws a dotted line (not used if the docking guide images are ok).

        :param `dc`: a :class:`DC` device context object;
        :param `point`: a :class:`Point` where to start drawing the dotted line;
        :param integer `length`: the length of the dotted line;
        :param bool `vertical`: whether it is a vertical docking guide window or not.
        """

        for i in xrange(0, length, 2):
            dc.DrawPoint(point.x, point.y)
            if vertical:
                point.y += 2
            else:
                point.x += 2


    def DrawIcon(self, dc):
        """
        Draws the docking guide icon (not used if the docking guide images are ok).

        :param `dc`: a :class:`DC` device context object.
        """

        rect = wx.Rect(*self.GetClientRect())
        point = wx.Point()
        length = 0

        rect.Deflate(4, 4)
        dc.SetPen(wx.Pen(colourIconBorder))
        dc.SetBrush(wx.Brush(colourIconBackground))
        dc.DrawRectangleRect(rect)

        right1 = rect.GetRight() + 1
        bottom1 = rect.GetBottom() + 1

        dc.SetPen(wx.Pen(colourIconShadow))
        dc.DrawLine(rect.x + 1, bottom1, right1 + 1, bottom1)
        dc.DrawLine(right1, rect.y + 1, right1, bottom1 + 1)

        rect.Deflate(1, 1)

        if self._direction == wx.TOP:
            rect.height -= rect.height / 2
            point = rect.GetBottomLeft()
            length = rect.width

        elif self._direction == wx.LEFT:
            rect.width -= rect.width / 2
            point = rect.GetTopRight()
            length = rect.height

        elif self._direction == wx.RIGHT:
            rect.x += rect.width / 2
            rect.width -= rect.width / 2
            point = rect.GetTopLeft()
            length = rect.height

        elif self._direction == wx.BOTTOM:
            rect.y += rect.height / 2
            rect.height -= rect.height / 2
            point = rect.GetTopLeft()
            length = rect.width

        elif self._direction == wx.CENTER:
            rect.Deflate(1, 1)
            point = rect.GetTopLeft()
            length = rect.width

        dc.GradientFillLinear(rect, colourIconDockingPart1,
                              colourIconDockingPart2, self._direction)

        dc.SetPen(wx.Pen(colourIconBorder))

        if self._direction == wx.CENTER:
            self.DrawDottedLine(dc, rect.GetTopLeft(), rect.width, False)
            self.DrawDottedLine(dc, rect.GetTopLeft(), rect.height, True)
            self.DrawDottedLine(dc, rect.GetBottomLeft(), rect.width, False)
            self.DrawDottedLine(dc, rect.GetTopRight(), rect.height, True)

        elif self._direction in [wx.TOP, wx.BOTTOM]:
            self.DrawDottedLine(dc, point, length, False)

        else:
            self.DrawDottedLine(dc, point, length, True)


    def DrawArrow(self, dc):
        """
        Draws the docking guide arrow icon (not used if the docking guide images are ok).

        :param `dc`: a :class:`DC` device context object.
        """

        rect = self.GetClientRect()
        point = wx.Point()

        point.x = (rect.GetLeft() + rect.GetRight()) / 2
        point.y = (rect.GetTop() + rect.GetBottom()) / 2
        rx, ry = wx.Size(), wx.Size()

        if self._direction == wx.TOP:
            rx = wx.Size(1, 0)
            ry = wx.Size(0, 1)

        elif self._direction == wx.LEFT:
            rx = wx.Size(0, -1)
            ry = wx.Size(1, 0)

        elif self._direction == wx.RIGHT:
            rx = wx.Size(0, 1)
            ry = wx.Size(-1, 0)

        elif self._direction == wx.BOTTOM:
            rx = wx.Size(-1, 0)
            ry = wx.Size(0, -1)

        point.x += ry.x*3
        point.y += ry.y*3

        dc.SetPen(wx.Pen(colourIconArrow))

        for i in xrange(4):
            pt1 = wx.Point(point.x - rx.x*i, point.y - rx.y*i)
            pt2 = wx.Point(point.x + rx.x*(i+1), point.y + rx.y*(i+1))
            dc.DrawLinePoint(pt1, pt2)
            point.x += ry.x
            point.y += ry.y


    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for :class:`AuiDockingGuideWindow`.

        :param `event`: a :class:`PaintEvent` to be processed.
        """

        dc = wx.AutoBufferedPaintDC(self)
        if self._currentImage.IsOk() and self._valid:
            dc.DrawBitmap(self._currentImage, 0, 0, True)
        else:
            self.Draw(dc)


    def Draw(self, dc):
        """
        Draws the whole docking guide window (not used if the docking guide images are ok).

        :param `dc`: a :class:`DC` device context object.
        """

        self.DrawBackground(dc)

        if self._valid:
            self.DrawIcon(dc)
            self.DrawArrow(dc)


    def UpdateDockGuide(self, pos):
        """
        Updates the docking guide images depending on the mouse position, using focused
        images if the mouse is inside the docking guide or unfocused images if it is
        outside.

        :param `pos`: a :class:`Point` mouse position.
        """

        inside = self.GetScreenRect().Contains(pos)

        if inside:
            image = self._bmp_focus
        else:
            image = self._bmp_unfocus

        if image != self._currentImage:
            self._currentImage = image
            self.Refresh()
            self.Update()


# ---------------------------------------------------------------------------
# AuiSingleDockingGuide
# ---------------------------------------------------------------------------

class AuiSingleDockingGuide(AuiDockingGuide):
    """ A docking guide window for single docking hint (not diamond-shaped HUD). """

    def __init__(self, parent, direction=0):
        """
        Default class constructor. Used internally, do not call it in your code!

        :param `parent`: the :class:`AuiManager` parent;
        :param integer `direction`: one of ``wx.TOP``, ``wx.BOTTOM``, ``wx.LEFT``, ``wx.RIGHT``.
        """

        self._direction = direction

        style = wx.FRAME_TOOL_WINDOW | wx.STAY_ON_TOP | \
                wx.FRAME_NO_TASKBAR | wx.NO_BORDER

        # Use of FRAME_SHAPED on wxMac causes the frame to be visible
        # breaking the docking hints.
        if wx.Platform != '__WXMAC__':
            style |= wx.FRAME_SHAPED

        AuiDockingGuide.__init__(self, parent, style=style, name="auiSingleDockTarget")

        self.Hide()

        useAero = GetManager(self.GetParent()).GetAGWFlags() & AUI_MGR_AERO_DOCKING_GUIDES
        useWhidbey = GetManager(self.GetParent()).GetAGWFlags() & AUI_MGR_WHIDBEY_DOCKING_GUIDES

        self._useAero = useAero or useWhidbey
        self._valid = True

        if useAero:
            sizeX, sizeY = aeroguideSizeX, aeroguideSizeY
        elif useWhidbey:
            sizeX, sizeY = whidbeySizeX, whidbeySizeY
        else:
            sizeX, sizeY = guideSizeX, guideSizeY

        if direction not in [wx.TOP, wx.BOTTOM]:
            sizeX, sizeY = sizeY, sizeX

        if self._useAero:
            self.CreateShapesWithStyle(useWhidbey)

            if wx.Platform == "__WXGTK__":
                self.Bind(wx.EVT_WINDOW_CREATE, self.SetGuideShape)
            else:
                self.SetGuideShape()

            self.SetSize(self.region.GetBox().GetSize())
        else:
            self.SetSize((sizeX, sizeY))

        self.rect = wx.Rect(0, 0, sizeX, sizeY)

        if self._useAero:
            useAero = (useWhidbey and [2] or [1])[0]
        else:
            useAero = 0

        self.target = AuiDockingGuideWindow(self, self.rect, direction, False, useAero)


    def CreateShapesWithStyle(self, useWhidbey):
        """
        Creates the docking guide window shape based on which docking bitmaps are used.

        :param bool `useWhidbey`: if ``True``, use Whidbey-style bitmaps; if ``False``, use the
         Aero-style bitmaps.
         """

        sizeX, sizeY = aeroguideSizeX, aeroguideSizeY
        if useWhidbey:
            sizeX, sizeY = whidbeySizeX, whidbeySizeY

        if self._direction not in [wx.TOP, wx.BOTTOM]:
            sizeX, sizeY = sizeY, sizeX

        useAero = (useWhidbey and [2] or [1])[0]
        bmp, dummy = GetDockingImage(self._direction, useAero, False)
        region = wx.RegionFromBitmap(bmp)

        self.region = region


    def AeroMove(self, pos):
        """
        Moves the docking window to the new position. Overridden in children classes.

        :param Point `pos`: the new docking guide position.
        """

        pass


    def SetGuideShape(self, event=None):
        """
        Sets the correct shape for the docking guide window.

        :param `event`: on wxGTK, a :class:`WindowCreateEvent` event to process.
        """

        self.SetShape(self.region)

        if event is not None:
            # Skip the event on wxGTK
            event.Skip()
            wx.CallAfter(wx.SafeYield, self, True)


    def SetShape(self, region):
        """
        If the platform supports it, sets the shape of the window to that depicted by `region`.
        The system will not display or respond to any mouse event for the pixels that lie
        outside of the region. To reset the window to the normal rectangular shape simply call
        :meth:`SetShape` again with an empty region.

        :param Region `region`: the shape of the frame.

        :note: Overridden for wxMAC.
        """

        if wx.Platform == '__WXMAC__':
            # HACK so we don't crash when SetShape is called
            return
        else:
            super(AuiSingleDockingGuide, self).SetShape(region)


    def SetValid(self, valid):
        """
        Sets the docking direction as valid or invalid.

        :param bool `valid`: whether the docking direction is allowed or not.
        """

        self._valid = valid


    def IsValid(self):
        """ Returns whether the docking direction is valid. """

        return self._valid


    def UpdateDockGuide(self, pos):
        """
        Updates the docking guide images depending on the mouse position, using focused
        images if the mouse is inside the docking guide or unfocused images if it is
        outside.

        :param Point `pos`: the mouse position.
        """

        self.target.UpdateDockGuide(pos)


    def HitTest(self, x, y):
        """
        Checks if the mouse position is inside the target window rect.

        :param integer `x`: the `x` mouse position;
        :param integer `y`: the `y` mouse position.
        """

        if self.target.GetScreenRect().Contains((x, y)):
            return wx.ALL

        return -1


# ---------------------------------------------------------------------------
# AuiCenterDockingGuide
# ---------------------------------------------------------------------------

class AuiCenterDockingGuide(AuiDockingGuide):
    """ A docking guide window for multiple docking hint (diamond-shaped HUD). """

    def __init__(self, parent):
        """
        Default class constructor.
        Used internally, do not call it in your code!

        :param `parent`: the :class:`AuiManager` parent.
        """

        AuiDockingGuide.__init__(self, parent, style=wx.FRAME_TOOL_WINDOW | wx.STAY_ON_TOP |
                                 wx.FRAME_NO_TASKBAR | wx.NO_BORDER | wx.FRAME_SHAPED,
                                 name="auiCenterDockTarget")

        self.Hide()

        self.CreateShapesWithStyle()
        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)

        if wx.Platform == "__WXGTK__":
            self.Bind(wx.EVT_WINDOW_CREATE, self.SetGuideShape)
        else:
            self.SetGuideShape()

        self.SetSize(self.region.GetBox().GetSize())

        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_PAINT, self.OnPaint)


    def CreateShapesWithStyle(self):
        """ Creates the docking guide window shape based on which docking bitmaps are used. """

        useAero = (GetManager(self.GetParent()).GetAGWFlags() & AUI_MGR_AERO_DOCKING_GUIDES) != 0
        useWhidbey = (GetManager(self.GetParent()).GetAGWFlags() & AUI_MGR_WHIDBEY_DOCKING_GUIDES) != 0

        self._useAero = 0
        if useAero:
            self._useAero = 1
        elif useWhidbey:
            self._useAero = 2

        if useAero:
            sizeX, sizeY = aeroguideSizeX, aeroguideSizeY
        elif useWhidbey:
            sizeX, sizeY = whidbeySizeX, whidbeySizeY
        else:
            sizeX, sizeY = guideSizeX, guideSizeY

        rectLeft = wx.Rect(0, sizeY, sizeY, sizeX)
        rectTop = wx.Rect(sizeY, 0, sizeX, sizeY)
        rectRight = wx.Rect(sizeY+sizeX, sizeY, sizeY, sizeX)
        rectBottom = wx.Rect(sizeY, sizeX + sizeY, sizeX, sizeY)
        rectCenter = wx.Rect(sizeY, sizeY, sizeX, sizeX)

        if not self._useAero:

            self.targetLeft = AuiDockingGuideWindow(self, rectLeft, wx.LEFT, True, useAero)
            self.targetTop = AuiDockingGuideWindow(self, rectTop, wx.TOP, True, useAero)
            self.targetRight = AuiDockingGuideWindow(self, rectRight, wx.RIGHT, True, useAero)
            self.targetBottom = AuiDockingGuideWindow(self, rectBottom, wx.BOTTOM, True, useAero)
            self.targetCenter = AuiDockingGuideWindow(self, rectCenter, wx.CENTER, True, useAero)


            # top-left diamond
            tld = [wx.Point(rectTop.x, rectTop.y+rectTop.height-8),
                   wx.Point(rectLeft.x+rectLeft.width-8, rectLeft.y),
                   rectTop.GetBottomLeft()]
            # bottom-left diamond
            bld = [wx.Point(rectLeft.x+rectLeft.width-8, rectLeft.y+rectLeft.height),
                   wx.Point(rectBottom.x, rectBottom.y+8),
                   rectBottom.GetTopLeft()]
            # top-right diamond
            trd = [wx.Point(rectTop.x+rectTop.width, rectTop.y+rectTop.height-8),
                   wx.Point(rectRight.x+8, rectRight.y),
                   rectRight.GetTopLeft()]
            # bottom-right diamond
            brd = [wx.Point(rectRight.x+8, rectRight.y+rectRight.height),
                   wx.Point(rectBottom.x+rectBottom.width, rectBottom.y+8),
                   rectBottom.GetTopRight()]

            self._triangles = [tld[0:2], bld[0:2],
                               [wx.Point(rectTop.x+rectTop.width-1, rectTop.y+rectTop.height-8),
                                wx.Point(rectRight.x+7, rectRight.y)],
                               [wx.Point(rectRight.x+7, rectRight.y+rectRight.height),
                                wx.Point(rectBottom.x+rectBottom.width-1, rectBottom.y+8)]]

            region = wx.Region()
            region.UnionRect(rectLeft)
            region.UnionRect(rectTop)
            region.UnionRect(rectRight)
            region.UnionRect(rectBottom)
            region.UnionRect(rectCenter)
            region.UnionRegion(wx.RegionFromPoints(tld))
            region.UnionRegion(wx.RegionFromPoints(bld))
            region.UnionRegion(wx.RegionFromPoints(trd))
            region.UnionRegion(wx.RegionFromPoints(brd))

        elif useAero:

            self._aeroBmp = aero_dock_pane.GetBitmap()
            region = wx.RegionFromBitmap(self._aeroBmp)

            self._allAeroBmps = [aero_dock_pane_left.GetBitmap(), aero_dock_pane_top.GetBitmap(),
                                 aero_dock_pane_right.GetBitmap(), aero_dock_pane_bottom.GetBitmap(),
                                 aero_dock_pane_center.GetBitmap(), aero_dock_pane.GetBitmap()]
            self._deniedBitmap = aero_denied.GetBitmap()
            self._aeroRects = [rectLeft, rectTop, rectRight, rectBottom, rectCenter]
            self._valid = True

        elif useWhidbey:

            self._aeroBmp = whidbey_dock_pane.GetBitmap()
            region = wx.RegionFromBitmap(self._aeroBmp)

            self._allAeroBmps = [whidbey_dock_pane_left.GetBitmap(), whidbey_dock_pane_top.GetBitmap(),
                                 whidbey_dock_pane_right.GetBitmap(), whidbey_dock_pane_bottom.GetBitmap(),
                                 whidbey_dock_pane_center.GetBitmap(), whidbey_dock_pane.GetBitmap()]
            self._deniedBitmap = whidbey_denied.GetBitmap()
            self._aeroRects = [rectLeft, rectTop, rectRight, rectBottom, rectCenter]
            self._valid = True


        self.region = region


    def SetGuideShape(self, event=None):
        """
        Sets the correct shape for the docking guide window.

        :param `event`: on wxGTK, a :class:`WindowCreateEvent` event to process.
        """

        self.SetShape(self.region)

        if event is not None:
            # Skip the event on wxGTK
            event.Skip()
            wx.CallAfter(wx.SafeYield, self, True)


    def UpdateDockGuide(self, pos):
        """
        Updates the docking guides images depending on the mouse position, using focused
        images if the mouse is inside the docking guide or unfocused images if it is
        outside.

        :param Point `pos`: the mouse position.
        """

        if not self._useAero:
            for target in self.GetChildren():
                target.UpdateDockGuide(pos)
        else:
            lenRects = len(self._aeroRects)
            for indx, rect in enumerate(self._aeroRects):
                if rect.Contains(pos):
                    if self._allAeroBmps[indx] != self._aeroBmp:
                        if indx < lenRects - 1 or (indx == lenRects - 1 and self._valid):
                            self._aeroBmp = self._allAeroBmps[indx]
                            self.Refresh()
                        else:
                            self._aeroBmp = self._allAeroBmps[-1]
                            self.Refresh()

                    return

            if self._aeroBmp != self._allAeroBmps[-1]:
                self._aeroBmp = self._allAeroBmps[-1]
                self.Refresh()


    def HitTest(self, x, y):
        """
        Checks if the mouse position is inside the target windows rect.

        :param integer `x`: the `x` mouse position;
        :param integer `y`: the `y` mouse position.
        """

        if not self._useAero:
            if self.targetLeft.GetScreenRect().Contains((x, y)):
                return wx.LEFT
            if self.targetTop.GetScreenRect().Contains((x, y)):
                return wx.UP
            if self.targetRight.GetScreenRect().Contains((x, y)):
                return wx.RIGHT
            if self.targetBottom.GetScreenRect().Contains((x, y)):
                return wx.DOWN
            if self.targetCenter.IsValid() and self.targetCenter.GetScreenRect().Contains((x, y)):
                return wx.CENTER
        else:
            constants = [wx.LEFT, wx.UP, wx.RIGHT, wx.DOWN, wx.CENTER]
            lenRects = len(self._aeroRects)
            for indx, rect in enumerate(self._aeroRects):
                if rect.Contains((x, y)):
                    if indx < lenRects or (indx == lenRects-1 and self._valid):
                        return constants[indx]

        return -1


    def ValidateNotebookDocking(self, valid):
        """
        Sets whether a pane can be docked on top of another to create an automatic
        :class:`~lib.agw.aui.auibook.AuiNotebook`.

        :param bool `valid`: whether a pane can be docked on top to another to form an automatic
         :class:`~lib.agw.aui.auibook.AuiNotebook`.
        """

        if not self._useAero:
            if self.targetCenter.IsValid() != valid:
                self.targetCenter.SetValid(valid)
                self.targetCenter.Refresh()
        else:
            if self._valid != valid:
                self._valid = valid
                self.Refresh()


    def AeroMove(self, pos):
        """
        Moves the docking guide window to the new position.

        :param Point `pos`: the new docking guide position.
        """

        if not self._useAero:
            return

        useWhidbey = (GetManager(self.GetParent()).GetAGWFlags() & AUI_MGR_WHIDBEY_DOCKING_GUIDES) != 0

        if useWhidbey:
            sizeX, sizeY = whidbeySizeX, whidbeySizeY
        else:
            sizeX, sizeY = aeroguideSizeX, aeroguideSizeY

        size = self.GetSize()

        leftRect, topRect, rightRect, bottomRect, centerRect = self._aeroRects
        thePos = pos + wx.Point((size.x-sizeY)/2, (size.y-sizeX)/2)

        centerRect.SetPosition(thePos)

        leftRect.SetPosition(thePos + wx.Point(-sizeY, 0))
        topRect.SetPosition(thePos + wx.Point(0, -sizeY))
        rightRect.SetPosition(thePos + wx.Point(sizeX, 0))
        bottomRect.SetPosition(thePos + wx.Point(0, sizeX))


    def OnEraseBackground(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for :class:`AuiCenterDockingGuide`.

        :param `event`: :class:`EraseEvent` to be processed.

        :note: This is intentionally empty to reduce flickering while drawing.
        """

        pass


    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for :class:`AuiCenterDockingGuide`.

        :param `event`: a :class:`PaintEvent` to be processed.
        """

        dc = wx.AutoBufferedPaintDC(self)

        if self._useAero:
            dc.SetBrush(wx.TRANSPARENT_BRUSH)
            dc.SetPen(wx.TRANSPARENT_PEN)
        else:
            dc.SetBrush(wx.Brush(colourTargetBackground))
            dc.SetPen(wx.Pen(colourTargetBorder))

        rect = self.GetClientRect()
        dc.DrawRectangle(rect.x, rect.y, rect.width, rect.height)

        if self._useAero:
            dc.DrawBitmap(self._aeroBmp, 0, 0, True)
            if not self._valid:
                diff = (self._useAero == 2 and [1] or [0])[0]
                bmpX, bmpY = self._deniedBitmap.GetWidth(), self._deniedBitmap.GetHeight()
                xPos, yPos = (rect.x + (rect.width)/2 - bmpX/2), (rect.y + (rect.height)/2 - bmpY/2)
                dc.DrawBitmap(self._deniedBitmap, xPos+1, yPos+diff, True)

            return

        dc.SetPen(wx.Pen(colourTargetBorder, 2))
        for pts in self._triangles:
            dc.DrawLinePoint(pts[0], pts[1])


# ----------------------------------------------------------------------------
# AuiDockingHintWindow
# ----------------------------------------------------------------------------

class AuiDockingHintWindow(wx.Frame):
    """ The original wxAUI docking window hint. """

    def __init__(self, parent, id=wx.ID_ANY, title="", pos=wx.DefaultPosition,
                 size=wx.Size(1, 1), style=wx.FRAME_TOOL_WINDOW | wx.FRAME_FLOAT_ON_PARENT |
                 wx.FRAME_NO_TASKBAR | wx.NO_BORDER | wx.FRAME_SHAPED,
                 name="auiHintWindow"):
        """
        Default class constructor. Used internally, do not call it in your code!

        :param `parent`: the :class:`AuiManager` parent;
        :param integer `id`: the window identifier. It may take a value of -1 to indicate a default value.
        :param string `title`: the caption to be displayed on the frame's title bar;
        :param Point `pos`: the window position. A value of (-1, -1) indicates a default position,
         chosen by either the windowing system or wxPython, depending on platform;
        :param Size `size`: the window size. A value of (-1, -1) indicates a default size, chosen by
         either the windowing system or wxPython, depending on platform;
        :param integer `style`: the window style;
        :param string `name`: the name of the window. This parameter is used to associate a name with the
         item, allowing the application user to set Motif resource values for individual windows.
        """
        if wx.Platform == '__WXMAC__' and style & wx.FRAME_SHAPED:
            # Having the shaped frame causes the frame to not be visible
            # with the transparent style hints.
            style -= wx.FRAME_SHAPED

        wx.Frame.__init__(self, parent, id, title, pos, size, style, name=name)

        self._blindMode = False

        self._art = parent.GetEventHandler().GetArtProvider()
        background = self._art.GetColour(AUI_DOCKART_HINT_WINDOW_COLOUR)
        self.SetBackgroundColour(background)

        # Can't set background colour on a frame on wxMac
        # so add a panel to set the colour on.
        if wx.Platform == '__WXMAC__':
            sizer = wx.BoxSizer(wx.HORIZONTAL)
            self.panel = wx.Panel(self)
            sizer.Add(self.panel, 1, wx.EXPAND)
            self.SetSizer(sizer)
            self.panel.SetBackgroundColour(background)
        else:
            self.Bind(wx.EVT_PAINT, self.OnPaint)

        self.Bind(wx.EVT_SIZE, self.OnSize)


    def MakeVenetianBlinds(self):
        """
        Creates the "venetian blind" effect if :class:`AuiManager` has the ``AUI_MGR_VENETIAN_BLINDS_HINT``
        flag set.
        """

        amount = 128
        size = self.GetClientSize()
        region = wx.Region(0, 0, size.x, 1)

        for y in xrange(size.y):

            # Reverse the order of the bottom 4 bits
            j = (y & 8 and [1] or [0])[0] | (y & 4 and [2] or [0])[0] | \
                (y & 2 and [4] or [0])[0] | (y & 1 and [8] or [0])[0]

            if 16*j+8 < amount:
                region.Union(0, y, size.x, 1)

        self.SetShape(region)


    def SetBlindMode(self, agwFlags):
        """
        Sets whether venetian blinds or transparent hints will be shown as docking hint.
        This depends on the :class:`AuiManager` flags.

        :param integer `agwFlags`: the :class:`AuiManager` flags.
        """

        self._blindMode = (agwFlags & AUI_MGR_VENETIAN_BLINDS_HINT) != 0

        if self._blindMode or not self.CanSetTransparent():
            self.MakeVenetianBlinds()
            self.SetTransparent(255)

        else:
            self.SetShape(wx.Region())
            if agwFlags & AUI_MGR_HINT_FADE == 0:
                self.SetTransparent(80)
            else:
                self.SetTransparent(0)


    def SetShape(self, region):
        """
        If the platform supports it, sets the shape of the window to that depicted by `region`.
        The system will not display or respond to any mouse event for the pixels that lie
        outside of the region. To reset the window to the normal rectangular shape simply call
        :meth:`SetShape` again with an empty region.

        :param Region `region`: the shape of the frame.

        :note: Overridden for wxMAC.
        """

        if wx.Platform == '__WXMAC__':
            # HACK so we don't crash when SetShape is called
            return
        else:
            super(AuiDockingHintWindow, self).SetShape(region)


    def Show(self, show=True):
        """
        Show the hint window.

        :param bool `show`: whether to show or hide the hint docking window.
        """

        background = self._art.GetColour(AUI_DOCKART_HINT_WINDOW_COLOUR)

        if wx.Platform == '__WXMAC__':
            self.panel.SetBackgroundColour(background)
        else:
            self.SetBackgroundColour(background)

        super(AuiDockingHintWindow, self).Show(show)
        self.Refresh()

        if wx.Platform == '__WXMAC__':
            # Need to manually do layout since its a borderless frame.
            self.Layout()


    def OnSize(self, event):
        """
        Handles the ``wx.EVT_SIZE`` event for :class:`AuiDockingHintWindow`.

        :param `event`: a :class:`SizeEvent` to be processed.
        """

        if self._blindMode or not self.CanSetTransparent():
            self.MakeVenetianBlinds()

        self.Refresh()


    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for :class:`AuiDockingHintWindow`.

        :param `event`: an instance of :class:`PaintEvent` to be processed.
        """

        rect = wx.RectPS(wx.Point(0, 0), self.GetSize())

        dc = wx.PaintDC(self)
        event.Skip()

        dc.SetBrush(wx.TRANSPARENT_BRUSH)
        dc.SetPen(wx.Pen(wx.Colour(60, 60, 60), 5))
        rect.Deflate(1, 1)
        dc.DrawRectangleRect(rect)


# ---------------------------------------------------------------------------- #

# -- AuiFloatingFrame class implementation --

class AuiFloatingFrame(wx.MiniFrame):
    """ AuiFloatingFrame is the frame class that holds floating panes. """

    def __init__(self, parent, owner_mgr, pane=None, id=wx.ID_ANY, title="",
                 style=wx.FRAME_TOOL_WINDOW | wx.FRAME_FLOAT_ON_PARENT |
                 wx.FRAME_NO_TASKBAR | wx.CLIP_CHILDREN):
        """
        Default class constructor. Used internally, do not call it in your code!

        :param `parent`: the :class:`AuiManager` parent;
        :param `owner_mgr`: the :class:`AuiManager` that manages the floating pane;
        :param `pane`: the :class:`AuiPaneInfo` pane that is about to float;
        :param integer `id`: the window identifier. It may take a value of -1 to indicate a default value.
        :param string `title`: the caption to be displayed on the frame's title bar.
        :param integer `style`: the window style.
        """

        if pane and pane.IsResizeable():
            style |= wx.RESIZE_BORDER
        if pane:
            self._is_toolbar = pane.IsToolbar()

        self._useNativeMiniframes = False
        if AuiManager_UseNativeMiniframes(owner_mgr):
            # On wxMac we always use native miniframes
            self._useNativeMiniframes = True
            # windows does not support min/max boxes nor toggling the state
            # of the close button. The only way to toggle that button is to
            # toggle the system menu style. But the close box flag needs to
            # be set from the beginning.
            if wx.Platform == '__WXMSW__':
                style |= wx.CAPTION | wx.CLOSE_BOX
                if pane.HasCloseButton():
                    style |= wx.SYSTEM_MENU
            else:
                style |= wx.CAPTION | wx.SYSTEM_MENU
                if pane.HasCloseButton():
                    style |= wx.CLOSE_BOX
                if pane.HasMaximizeButton():
                    style |= wx.MAXIMIZE_BOX
                if pane.HasMinimizeButton():
                    style |= wx.MINIMIZE_BOX

        wx.MiniFrame.__init__(self, parent, id, title, pos=pane.floating_pos,
                              size=pane.floating_size, style=style, name="auiFloatingFrame")

        self._fly_timer = wx.Timer(self, wx.ID_ANY)
        self._check_fly_timer = wx.Timer(self, wx.ID_ANY)

        self.Bind(wx.EVT_CLOSE, self.OnClose)
        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_ACTIVATE, self.OnActivate)
        self.Bind(wx.EVT_TIMER, self.OnCheckFlyTimer, self._check_fly_timer)
        self.Bind(wx.EVT_TIMER, self.OnFlyTimer, self._fly_timer)
        self.Bind(EVT_AUI_FIND_MANAGER, self.OnFindManager)

        if self._useNativeMiniframes:
            self.Bind(wx.EVT_MOVE, self.OnMoveEvent)
            self.Bind(wx.EVT_MOVING, self.OnMoveEvent)
            self.Bind(wx.EVT_IDLE, self.OnIdle)
            self._useNativeMiniframes = True
            self.SetExtraStyle(wx.WS_EX_PROCESS_IDLE)
        else:
            self.Bind(wx.EVT_MOVE, self.OnMove)

        self._fly = False
        self._send_size = True
        self._alpha_amount = 255

        self._owner_mgr = owner_mgr
        self._moving = False
        self._lastDirection = None
        self._transparent = 255

        self._last_rect = wx.Rect()
        self._last2_rect = wx.Rect()
        self._last3_rect = wx.Rect()

        self._mgr = AuiManager()
        self._mgr.SetManagedWindow(self)
        self._mgr.SetArtProvider(owner_mgr.GetArtProvider())
        self._mgr.SetAGWFlags(owner_mgr.GetAGWFlags())


    def CopyAttributes(self, pane):
        """
        Copies all the attributes of the input `pane` into another :class:`AuiPaneInfo`.

        :param `pane`: the source :class:`AuiPaneInfo` from where to copy attributes.
        """

        contained_pane = AuiPaneInfo()

        contained_pane.name = pane.name
        contained_pane.caption = pane.caption
        contained_pane.window = pane.window
        contained_pane.frame = pane.frame
        contained_pane.state = pane.state
        contained_pane.dock_direction = pane.dock_direction
        contained_pane.dock_layer = pane.dock_layer
        contained_pane.dock_row = pane.dock_row
        contained_pane.dock_pos = pane.dock_pos
        contained_pane.best_size = wx.Size(*pane.best_size)
        contained_pane.min_size = wx.Size(*pane.min_size)
        contained_pane.max_size = wx.Size(*pane.max_size)
        contained_pane.floating_pos = wx.Point(*pane.floating_pos)
        contained_pane.floating_size = wx.Size(*pane.floating_size)
        contained_pane.dock_proportion = pane.dock_proportion
        contained_pane.buttons = pane.buttons
        contained_pane.rect = wx.Rect(*pane.rect)
        contained_pane.icon = pane.icon
        contained_pane.notebook_id = pane.notebook_id
        contained_pane.transparent = pane.transparent
        contained_pane.snapped = pane.snapped
        contained_pane.minimize_mode = pane.minimize_mode
        contained_pane.minimize_target = pane.minimize_target

        return contained_pane


    def SetPaneWindow(self, pane):
        """
        Sets all the properties of a pane.

        :param `pane`: the :class:`AuiPaneInfo` to analyze.
        """

        self._is_toolbar = pane.IsToolbar()
        self._pane_window = pane.window

        if isinstance(pane.window, auibar.AuiToolBar):
            pane.window.SetAuiManager(self._mgr)

        self._pane_window.Reparent(self)

        contained_pane = self.CopyAttributes(pane)

        contained_pane.Dock().Center().Show(). \
                       CaptionVisible(False). \
                       PaneBorder(False). \
                       Layer(0).Row(0).Position(0)

        if not contained_pane.HasGripper() and not self._useNativeMiniframes:
            contained_pane.CaptionVisible(True)

        indx = self._owner_mgr._panes.index(pane)

        # Carry over the minimum size
        pane_min_size = pane.window.GetMinSize()

        # if the best size is smaller than the min size
        # then set the min size to the best size as well
        pane_best_size = contained_pane.best_size
        if pane_best_size.IsFullySpecified() and (pane_best_size.x < pane_min_size.x or \
                                                  pane_best_size.y < pane_min_size.y):

            pane_min_size = pane_best_size
            self._pane_window.SetMinSize(pane_min_size)

        # if the frame window's max size is greater than the min size
        # then set the max size to the min size as well
        cur_max_size = self.GetMaxSize()
        if cur_max_size.IsFullySpecified() and  (cur_max_size.x < pane_min_size.x or \
                                                 cur_max_size.y < pane_min_size.y):
            self.SetMaxSize(pane_min_size)

        art_provider = self._mgr.GetArtProvider()
        caption_size = art_provider.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        button_size = art_provider.GetMetric(AUI_DOCKART_PANE_BUTTON_SIZE) + \
                      4*art_provider.GetMetric(AUI_DOCKART_PANE_BORDER_SIZE)

        min_size = pane.window.GetMinSize()

        if min_size.y < caption_size or min_size.x < button_size:
            new_x, new_y = min_size.x, min_size.y
            if min_size.y < caption_size:
                new_y = (pane.IsResizeable() and [2*wx.SystemSettings.GetMetric(wx.SYS_EDGE_Y)+caption_size] or [1])[0]
            if min_size.x < button_size:
                new_x = (pane.IsResizeable() and [2*wx.SystemSettings.GetMetric(wx.SYS_EDGE_X)+button_size] or [1])[0]

            self.SetMinSize((new_x, new_y))
        else:
            self.SetMinSize(min_size)

        self._mgr.AddPane(self._pane_window, contained_pane)
        self._mgr.Update()

        if pane.min_size.IsFullySpecified():
            # because SetSizeHints() calls Fit() too (which sets the window
            # size to its minimum allowed), we keep the size before calling
            # SetSizeHints() and reset it afterwards...
            tmp = self.GetSize()
            self.GetSizer().SetSizeHints(self)
            self.SetSize(tmp)

        self.SetTitle(pane.caption)

        if pane.floating_size != wx.Size(-1, -1):
            self.SetSize(pane.floating_size)
        else:
            size = pane.best_size
            if size == wx.Size(-1, -1):
                size = pane.min_size
            if size == wx.Size(-1, -1):
                size = self._pane_window.GetSize()
            if self._owner_mgr and pane.HasGripper():
                if pane.HasGripperTop():
                    size.y += self._owner_mgr._art.GetMetric(AUI_DOCKART_GRIPPER_SIZE)
                else:
                    size.x += self._owner_mgr._art.GetMetric(AUI_DOCKART_GRIPPER_SIZE)

            if not self._useNativeMiniframes:
                size.y += self._owner_mgr._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)

            pane.floating_size = size

            self.SetClientSize(size)

        self._owner_mgr._panes[indx] = pane

        self._fly_step = abs(pane.floating_size.y - \
                             (caption_size + 2*wx.SystemSettings.GetMetric(wx.SYS_EDGE_Y)))/10

        self._floating_size = wx.Size(*self.GetSize())

        if pane.IsFlyOut():
            self._check_fly_timer.Start(50)


    def GetOwnerManager(self):
        """ Returns the :class:`AuiManager` that manages the pane. """

        return self._owner_mgr


    def OnSize(self, event):
        """
        Handles the ``wx.EVT_SIZE`` event for :class:`AuiFloatingFrame`.

        :param `event`: a :class:`SizeEvent` to be processed.
        """

        if self._owner_mgr and self._send_size:
            self._owner_mgr.OnFloatingPaneResized(self._pane_window, event.GetSize())


    def OnClose(self, event):
        """
        Handles the ``wx.EVT_CLOSE`` event for :class:`AuiFloatingFrame`.

        :param `event`: a :class:`CloseEvent` to be processed.
        """

        if self._owner_mgr:
            self._owner_mgr.OnFloatingPaneClosed(self._pane_window, event)

        if not event.GetVeto():
            self._mgr.DetachPane(self._pane_window)

            if isinstance(self._pane_window, auibar.AuiToolBar):
                self._pane_window.SetAuiManager(self._owner_mgr)

            # if we do not do this, then we can crash...
            if self._owner_mgr and self._owner_mgr._action_window == self:
                self._owner_mgr._action_window = None

            self._mgr.UnInit()
            self.Destroy()


    def OnActivate(self, event):
        """
        Handles the ``wx.EVT_ACTIVATE`` event for :class:`AuiFloatingFrame`.

        :param `event`: a :class:`ActivateEvent` to be processed.
        """

        if self._owner_mgr and event.GetActive():
            self._owner_mgr.OnFloatingPaneActivated(self._pane_window)


    def OnMove(self, event):
        """
        Handles the ``wx.EVT_MOVE`` event for :class:`AuiFloatingFrame`.

        :param `event`: a :class:`MoveEvent` to be processed.

        .. note::

           This event is not processed on wxMAC or if :class:`AuiManager` is not using the
           ``AUI_MGR_USE_NATIVE_MINIFRAMES`` style.

        """

        if self._owner_mgr:
            self._owner_mgr.OnFloatingPaneMoved(self._pane_window, event)


    def OnMoveEvent(self, event):
        """
        Handles the ``wx.EVT_MOVE`` and ``wx.EVT_MOVING`` events for :class:`AuiFloatingFrame`.

        :param `event`: a :class:`MoveEvent` to be processed.

        .. note::

           This event is only processed on wxMAC or if :class:`AuiManager` is using the
           ``AUI_MGR_USE_NATIVE_MINIFRAMES`` style.
        """

        win_rect = self.GetRect()

        if win_rect == self._last_rect:
            return

        # skip the first move event
        if self._last_rect.IsEmpty():
            self._last_rect = wx.Rect(*win_rect)
            return

        # As on OSX moving windows are not getting all move events, only sporadically, this difference
        # is almost always big on OSX, so avoid this early exit opportunity
        if wx.Platform != '__WXMAC__':
            # skip if moving too fast to avoid massive redraws and
            # jumping hint windows
            if abs(win_rect.x - self._last_rect.x) > 3 or abs(win_rect.y - self._last_rect.y) > 3:
                self._last3_rect = wx.Rect(*self._last2_rect)
                self._last2_rect = wx.Rect(*self._last_rect)
                self._last_rect = wx.Rect(*win_rect)

                # However still update the internally stored position to avoid
                # snapping back to the old one later.
                if self._owner_mgr:
                    self._owner_mgr.GetPane(self._pane_window).floating_pos = win_rect.GetPosition()

                return

        # prevent frame redocking during resize
        if self._last_rect.GetSize() != win_rect.GetSize():
            self._last3_rect = wx.Rect(*self._last2_rect)
            self._last2_rect = wx.Rect(*self._last_rect)
            self._last_rect = wx.Rect(*win_rect)
            return

        dir = wx.ALL

        horiz_dist = abs(win_rect.x - self._last3_rect.x)
        vert_dist = abs(win_rect.y - self._last3_rect.y)

        if vert_dist >= horiz_dist:
            if win_rect.y < self._last3_rect.y:
                dir = wx.NORTH
            else:
                dir = wx.SOUTH
        else:
            if win_rect.x < self._last3_rect.x:
                dir = wx.WEST
            else:
                dir = wx.EAST

        self._last3_rect = wx.Rect(*self._last2_rect)
        self._last2_rect = wx.Rect(*self._last_rect)
        self._last_rect = wx.Rect(*win_rect)

        if _VERSION_STRING < "2.9":
            leftDown = wx.GetMouseState().LeftDown()
        else:
            leftDown = wx.GetMouseState().LeftIsDown()

        if not leftDown:
            return

        if not self._moving:
            self.OnMoveStart(event)
            self._moving = True

        if self._last3_rect.IsEmpty():
            return

        if event.GetEventType() == wx.wxEVT_MOVING:
            self.OnMoving(event.GetRect(), dir)
        else:
            self.OnMoving(wx.RectPS(event.GetPosition(), self.GetSize()), dir)


    def OnIdle(self, event):
        """
        Handles the ``wx.EVT_IDLE`` event for :class:`AuiFloatingFrame`.

        :param `event`: a :class:`IdleEvent` event to be processed.

        .. note::

           This event is only processed on wxMAC if :class:`AuiManager` is using the
           ``AUI_MGR_USE_NATIVE_MINIFRAMES`` style.

        """

        if self._moving:
            if _VERSION_STRING < "2.9":
                leftDown = wx.GetMouseState().LeftDown()
            else:
                leftDown = wx.GetMouseState().LeftIsDown()

            if not leftDown:
                self._moving = False
                self.OnMoveFinished()
            else:
                event.RequestMore()


    def OnMoveStart(self, event):
        """
        The user has just started moving the floating pane.

        :param `event`: an instance of :class:`MouseEvent`.

        .. note::

           This event is only processed on wxMAC if :class:`AuiManager` is using the
           ``AUI_MGR_USE_NATIVE_MINIFRAMES`` style.

        """

        # notify the owner manager that the pane has started to move
        if self._owner_mgr:
            if self._owner_mgr._from_move:
                return
            self._owner_mgr._action_window = self._pane_window
            point = wx.GetMousePosition()
            action_offset = point - self.GetPosition()

            if self._is_toolbar:
                self._owner_mgr._toolbar_action_offset = action_offset
                self._owner_mgr.OnMotion_DragToolbarPane(point)
            else:
                self._owner_mgr._action_offset = action_offset
                self._owner_mgr.OnMotion_DragFloatingPane(point)


    def OnMoving(self, rect, direction):
        """
        The user is moving the floating pane.

        :param Rect `rect`: the pane client rectangle;
        :param integer `direction`: the direction in which the pane is moving, can be one of
         ``wx.NORTH``, ``wx.SOUTH``, ``wx.EAST`` or ``wx.WEST``.

        .. note::

           This event is only processed on wxMAC if :class:`AuiManager` is using the
           ``AUI_MGR_USE_NATIVE_MINIFRAMES`` style.
        """

        # notify the owner manager that the pane is moving
        self.OnMoveStart(None)
        self._lastDirection = direction


    def OnMoveFinished(self):
        """
        The user has just finished moving the floating pane.

        .. note::

           This method is used only on wxMAC if :class:`AuiManager` is using the
           ``AUI_MGR_USE_NATIVE_MINIFRAMES`` style.

        """

        # notify the owner manager that the pane has finished moving
        if self._owner_mgr:
            self._owner_mgr._action_window = self._pane_window
            point = wx.GetMousePosition()
            if self._is_toolbar:
                self._owner_mgr.OnLeftUp_DragToolbarPane(point)
            else:
                self._owner_mgr.OnLeftUp_DragFloatingPane(point)

            self._owner_mgr.OnFloatingPaneMoved(self._pane_window, point)


    def OnCheckFlyTimer(self, event):
        """
        Handles the ``wx.EVT_TIMER`` event for :class:`AuiFloatingFrame`.

        :param `event`: a :class:`TimerEvent` to be processed.

        :note: This is used solely for "fly-out" panes.
        """

        if self._owner_mgr:
            pane = self._mgr.GetPane(self._pane_window)
            if pane.IsFlyOut():
                if self.IsShownOnScreen():
                    self.FlyOut()


    def OnFindManager(self, event):
        """
        Handles the ``EVT_AUI_FIND_MANAGER`` event for :class:`AuiFloatingFrame`.

        :param `event`: a :class:`AuiManagerEvent` event to be processed.
        """

        event.SetManager(self._owner_mgr)


    def FlyOut(self):
        """ Starts the flying in and out of a floating pane. """

        if self._fly_timer.IsRunning():
            return

        if _VERSION_STRING < "2.9":
            leftDown = wx.GetMouseState().LeftDown()
        else:
            leftDown = wx.GetMouseState().LeftIsDown()

        if leftDown:
            return

        rect = wx.Rect(*self.GetScreenRect())
        rect.Inflate(10, 10)

        if rect.Contains(wx.GetMousePosition()):
            if not self._fly:
                return
            self._send_size = False
            self._fly_timer.Start(5)
        else:
            if self._fly:
                return
            self._send_size = False
            self._fly_timer.Start(5)


    def OnFlyTimer(self, event):
        """
        Handles the ``wx.EVT_TIMER`` event for :class:`AuiFloatingFrame`.

        :param `event`: a :class:`TimerEvent` to be processed.
        """

        current_size = self.GetClientSize()
        floating_size = wx.Size(*self._owner_mgr.GetPane(self._pane_window).floating_size)

        if floating_size.y == -1:
            floating_size = self._floating_size

        if not self._fly:
            min_size = self._mgr.GetArtProvider().GetMetric(AUI_DOCKART_CAPTION_SIZE)

            if wx.Platform != "__WXMSW__":
                min_size += 2*wx.SystemSettings.GetMetric(wx.SYS_EDGE_Y)

            if current_size.y - self._fly_step <= min_size:
                self.SetClientSize((current_size.x, min_size))
                self._fly = True
                self._fly_timer.Stop()
                self._send_size = True
            else:
                self.SetClientSize((current_size.x, current_size.y-self._fly_step))

        else:
            if current_size.y + self._fly_step >= floating_size.y:
                self.SetClientSize((current_size.x, floating_size.y))
                self._fly = False
                self._fly_timer.Stop()
                self._send_size = True
            else:
                self.SetClientSize((current_size.x, current_size.y+self._fly_step))

        self.Update()
        self.Refresh()


    def FadeOut(self):
        """ Actually starts the fading out of the floating pane. """

        while 1:
            self._alpha_amount -= 10
            if self._alpha_amount <= 0:
                self._alpha_amount = 255
                return

            self.SetTransparent(self._alpha_amount)
            wx.SafeYield()
            wx.MilliSleep(15)


# -- static utility functions --

def DrawResizeHint(dc, rect):
    """
    Draws a resize hint while a sash is dragged.

    :param Rect `rect`: a rectangle which specifies the sash dimensions.
    """

    if wx.Platform == "__WXMSW__" and wx.App.GetComCtl32Version() >= 600:
        if wx.GetOsVersion()[1] > 5:
            # Windows Vista
            dc.SetPen(wx.Pen("black", 2, wx.SOLID))
            dc.SetBrush(wx.TRANSPARENT_BRUSH)
        else:
            # Draw the nice XP style splitter
            dc.SetPen(wx.TRANSPARENT_PEN)
            dc.SetBrush(wx.BLACK_BRUSH)
        dc.SetLogicalFunction(wx.INVERT)
        dc.DrawRectangleRect(rect)
        dc.SetLogicalFunction(wx.COPY)
    else:
        stipple = PaneCreateStippleBitmap()
        brush = wx.BrushFromBitmap(stipple)
        dc.SetBrush(brush)
        dc.SetPen(wx.TRANSPARENT_PEN)

        dc.SetLogicalFunction(wx.XOR)
        dc.DrawRectangleRect(rect)


def CopyDocksAndPanes(src_docks, src_panes):
    """
    This utility function creates shallow copies of
    the dock and pane info. :class:`AuiManager` usually contain pointers
    to :class:`AuiPaneInfo` classes, thus this function is necessary to reliably
    reconstruct that relationship in the new dock info and pane info arrays.

    :param `src_docks`: a list of :class:`AuiDockInfo` classes;
    :param `src_panes`: a list of :class:`AuiPaneInfo` classes.
    """

    dest_docks = src_docks
    dest_panes = src_panes

    for ii in xrange(len(dest_docks)):
        dock = dest_docks[ii]
        for jj in xrange(len(dock.panes)):
            for kk in xrange(len(src_panes)):
                if dock.panes[jj] == src_panes[kk]:
                    dock.panes[jj] = dest_panes[kk]

    return dest_docks, dest_panes


def CopyDocksAndPanes2(src_docks, src_panes):
    """
    This utility function creates full copies of
    the dock and pane info. :class:`AuiManager` usually contain pointers
    to :class:`AuiPaneInfo` classes, thus this function is necessary to reliably
    reconstruct that relationship in the new dock info and pane info arrays.

    :param `src_docks`: a list of :class:`AuiDockInfo` classes;
    :param `src_panes`: a list of :class:`AuiPaneInfo` classes.
    """

    dest_docks = []

    for ii in xrange(len(src_docks)):
        dest_docks.append(AuiDockInfo())
        dest_docks[ii].dock_direction = src_docks[ii].dock_direction
        dest_docks[ii].dock_layer = src_docks[ii].dock_layer
        dest_docks[ii].dock_row = src_docks[ii].dock_row
        dest_docks[ii].size = src_docks[ii].size
        dest_docks[ii].min_size = src_docks[ii].min_size
        dest_docks[ii].resizable = src_docks[ii].resizable
        dest_docks[ii].fixed = src_docks[ii].fixed
        dest_docks[ii].toolbar = src_docks[ii].toolbar
        dest_docks[ii].panes = src_docks[ii].panes
        dest_docks[ii].rect = wx.Rect(*src_docks[ii].rect)

    dest_panes = []

    for ii in xrange(len(src_panes)):
        dest_panes.append(AuiPaneInfo())
        dest_panes[ii].name = src_panes[ii].name
        dest_panes[ii].caption = src_panes[ii].caption
        dest_panes[ii].window = src_panes[ii].window
        dest_panes[ii].frame = src_panes[ii].frame
        dest_panes[ii].state = src_panes[ii].state
        dest_panes[ii].dock_direction = src_panes[ii].dock_direction
        dest_panes[ii].dock_layer = src_panes[ii].dock_layer
        dest_panes[ii].dock_row = src_panes[ii].dock_row
        dest_panes[ii].dock_pos = src_panes[ii].dock_pos
        dest_panes[ii].best_size = wx.Size(*src_panes[ii].best_size)
        dest_panes[ii].min_size = wx.Size(*src_panes[ii].min_size)
        dest_panes[ii].max_size = wx.Size(*src_panes[ii].max_size)
        dest_panes[ii].floating_pos = wx.Point(*src_panes[ii].floating_pos)
        dest_panes[ii].floating_size = wx.Size(*src_panes[ii].floating_size)
        dest_panes[ii].dock_proportion = src_panes[ii].dock_proportion
        dest_panes[ii].buttons = src_panes[ii].buttons
        dest_panes[ii].rect = wx.Rect(*src_panes[ii].rect)
        dest_panes[ii].icon = src_panes[ii].icon
        dest_panes[ii].notebook_id = src_panes[ii].notebook_id
        dest_panes[ii].transparent = src_panes[ii].transparent
        dest_panes[ii].snapped = src_panes[ii].snapped
        dest_panes[ii].minimize_mode = src_panes[ii].minimize_mode
        dest_panes[ii].minimize_target = src_panes[ii].minimize_target

    for ii in xrange(len(dest_docks)):
        dock = dest_docks[ii]
        for jj in xrange(len(dock.panes)):
            for kk in xrange(len(src_panes)):
                if dock.panes[jj] == src_panes[kk]:
                    dock.panes[jj] = dest_panes[kk]

        dest_docks[ii] = dock

    return dest_docks, dest_panes


def GetMaxLayer(docks, dock_direction):
    """
    This is an internal function which returns
    the highest layer inside the specified dock.

    :param `docks`: a list of :class:`AuiDockInfo`;
    :param `dock_direction`: the :class:`AuiDockInfo` docking direction to analyze.
    """

    max_layer = 0

    for dock in docks:
        if dock.dock_direction == dock_direction and dock.dock_layer > max_layer and not dock.fixed:
            max_layer = dock.dock_layer

    return max_layer


def GetMaxRow(panes, dock_direction, dock_layer):
    """
    This is an internal function which returns
    the highest layer inside the specified dock.

    :param `panes`: a list of :class:`AuiPaneInfo`;
    :param integer `dock_direction`: the :class:`AuiDockInfo` docking direction to analyze;
    :param integer `dock_layer`: the :class:`AuiDockInfo` layer to analyze.
    """

    max_row = 0

    for pane in panes:
        if pane.dock_direction == dock_direction and pane.dock_layer == dock_layer and \
           pane.dock_row > max_row:
            max_row = pane.dock_row

    return max_row


def DoInsertDockLayer(panes, dock_direction, dock_layer):
    """
    This is an internal function that inserts a new dock
    layer by incrementing all existing dock layer values by one.

    :param `panes`: a list of :class:`AuiPaneInfo`;
    :param integer `dock_direction`: the :class:`AuiDockInfo` docking direction to analyze;
    :param integer `dock_layer`: the :class:`AuiDockInfo` layer to analyze.
    """

    for ii in xrange(len(panes)):
        pane = panes[ii]
        if not pane.IsFloating() and pane.dock_direction == dock_direction and pane.dock_layer >= dock_layer:
            pane.dock_layer = pane.dock_layer + 1

        panes[ii] = pane

    return panes


def DoInsertDockRow(panes, dock_direction, dock_layer, dock_row):
    """
    This is an internal function that inserts a new dock
    row by incrementing all existing dock row values by one.

    :param `panes`: a list of :class:`AuiPaneInfo`;
    :param integer `dock_direction`: the :class:`AuiDockInfo` docking direction to analyze;
    :param integer `dock_layer`: the :class:`AuiDockInfo` layer to analyze;
    :param integer `dock_row`: the :class:`AuiDockInfo` row to analyze.
    """

    for pane in panes:
        if not pane.IsFloating() and pane.dock_direction == dock_direction and \
           pane.dock_layer == dock_layer and pane.dock_row >= dock_row:
            pane.dock_row += 1

    return panes


def DoInsertPane(panes, dock_direction, dock_layer, dock_row, dock_pos):
    """
    This is an internal function that inserts a new pane
    by incrementing all existing dock position values by one.

    :param `panes`: a list of :class:`AuiPaneInfo`;
    :param integer `dock_direction`: the :class:`AuiDockInfo` docking direction to analyze;
    :param integer `dock_layer`: the :class:`AuiDockInfo` layer to analyze.
    :param integer `dock_row`: the :class:`AuiDockInfo` row to analyze;
    :param integer `dock_pos`: the :class:`AuiDockInfo` position to analyze.
    """

    for ii in xrange(len(panes)):
        pane = panes[ii]
        if not pane.IsFloating() and pane.dock_direction == dock_direction and \
           pane.dock_layer == dock_layer and  pane.dock_row == dock_row and \
           pane.dock_pos >= dock_pos:
            pane.dock_pos = pane.dock_pos + 1

        panes[ii] = pane

    return panes


def FindDocks(docks, dock_direction, dock_layer=-1, dock_row=-1, reverse=False):
    """
    This is an internal function that returns a list of docks which meet
    the specified conditions in the parameters and returns a sorted array
    (sorted by layer and then row).

    :param `docks`: a list of :class:`AuiDockInfo`;
    :param integer `dock_direction`: the :class:`AuiDockInfo` docking direction to analyze;
    :param integer `dock_layer`: the :class:`AuiDockInfo` layer to analyze.
    :param integer `dock_row`: the :class:`AuiDockInfo` row to analyze;
    """

    matchDocks = [(d.dock_layer, d.dock_row, d.dock_direction, d) for d in docks if \
                  (dock_direction == -1 or dock_direction == d.dock_direction) and \
                  ((dock_layer == -1 or dock_layer == d.dock_layer) and \
                  (dock_row == -1 or dock_row == d.dock_row))]

    arr = [x[-1] for x in sorted(matchDocks, reverse=reverse)]

    return arr


def FindOppositeDocks(docks, dock_direction):
    """
    This is an internal function that returns a list of docks
    which is related to the opposite direction.

    :param `docks`: a list of :class:`AuiDockInfo`;
    :param integer `dock_direction`: the :class:`AuiDockInfo` docking direction to analyze;
    """

    if dock_direction == AUI_DOCK_LEFT:
        arr = FindDocks(docks, AUI_DOCK_RIGHT, -1, -1)
    elif dock_direction == AUI_DOCK_TOP:
        arr = FindDocks(docks, AUI_DOCK_BOTTOM, -1, -1)
    elif dock_direction == AUI_DOCK_RIGHT:
        arr = FindDocks(docks, AUI_DOCK_LEFT, -1, -1)
    elif dock_direction == AUI_DOCK_BOTTOM:
        arr = FindDocks(docks, AUI_DOCK_TOP, -1, -1)

    return arr


def FindPaneInDock(dock, window):
    """
    This method looks up a specified window pointer inside a dock.
    If found, the corresponding :class:`AuiDockInfo` pointer is returned, otherwise ``None``.

    :param `dock`: a :class:`AuiDockInfo` structure;
    :param Window `window`: the window associated to the pane we are seeking.
    """

    for p in dock.panes:
        if p.window == window:
            return p

    return None


def GetToolBarDockOffsets(docks):
    """
    Returns the toolbar dock offsets (top-left and bottom-right).

    :param `docks`: a list of :class:`AuiDockInfo` to analyze.
    """

    top_left = wx.Size(0, 0)
    bottom_right = wx.Size(0, 0)

    for dock in docks:
        if dock.toolbar:
            dock_direction = dock.dock_direction
            if dock_direction == AUI_DOCK_LEFT:
                top_left.x += dock.rect.width
                bottom_right.x += dock.rect.width

            elif dock_direction == AUI_DOCK_TOP:
                top_left.y += dock.rect.height
                bottom_right.y += dock.rect.height

            elif dock_direction == AUI_DOCK_RIGHT:
                bottom_right.x += dock.rect.width

            elif dock_direction == AUI_DOCK_BOTTOM:
                bottom_right.y += dock.rect.height

    return top_left, bottom_right


def GetInternalFrameRect(window, docks):
    """
    Returns the window rectangle excluding toolbars.

    :param `window`: a :class:`Window` derived window;
    :param `docks`: a list of :class:`AuiDockInfo` structures.
    """

    frameRect = wx.Rect()

    frameRect.SetTopLeft(window.ClientToScreen(window.GetClientAreaOrigin()))
    frameRect.SetSize(window.GetClientSize())

    top_left, bottom_right = GetToolBarDockOffsets(docks)

    # make adjustments for toolbars
    frameRect.x += top_left.x
    frameRect.y += top_left.y
    frameRect.width -= bottom_right.x
    frameRect.height -= bottom_right.y

    return frameRect


def CheckOutOfWindow(window, pt):
    """
    Checks if a point is outside the window rectangle.

    :param `window`: a :class:`Window` derived window;
    :param `pt`: a :class:`Point` object.
    """

    auiWindowMargin = 30
    marginRect = wx.Rect(*window.GetClientRect())
    marginRect.Inflate(auiWindowMargin, auiWindowMargin)

    return not marginRect.Contains(pt)


def CheckEdgeDrop(window, docks, pt):
    """
    Checks on which edge of a window the drop action has taken place.

    :param `window`: a :class:`Window` derived window;
    :param `docks`: a list of :class:`AuiDockInfo` structures;
    :param `pt`: a :class:`Point` object.
    """

    screenPt = window.ClientToScreen(pt)
    clientSize = window.GetClientSize()
    frameRect = GetInternalFrameRect(window, docks)

    if screenPt.y >= frameRect.GetTop() and screenPt.y < frameRect.GetBottom():
        if pt.x < auiLayerInsertOffset and pt.x > auiLayerInsertOffset - auiLayerInsertPixels:
            return wx.LEFT

        if pt.x >= clientSize.x - auiLayerInsertOffset and \
           pt.x < clientSize.x - auiLayerInsertOffset + auiLayerInsertPixels:
            return wx.RIGHT

    if screenPt.x >= frameRect.GetLeft() and screenPt.x < frameRect.GetRight():
        if pt.y < auiLayerInsertOffset and pt.y > auiLayerInsertOffset - auiLayerInsertPixels:
            return wx.TOP

        if pt.y >= clientSize.y - auiLayerInsertOffset and \
           pt.y < clientSize.y - auiLayerInsertOffset + auiLayerInsertPixels:
            return wx.BOTTOM

    return -1


def RemovePaneFromDocks(docks, pane, exc=None):
    """
    Removes a pane window from all docks
    with a possible exception specified by parameter `exc`.

    :param `docks`: a list of :class:`AuiDockInfo` structures;
    :param AuiPaneInfo `pane`: the pane to be removed;
    :param AuiPaneInfo `exc`: the possible pane exception.
    """

    for ii in xrange(len(docks)):
        d = docks[ii]
        if d == exc:
            continue
        pi = FindPaneInDock(d, pane.window)
        if pi:
            d.panes.remove(pi)

        docks[ii] = d

    return docks


def RenumberDockRows(docks):
    """
    Takes a dock and assigns sequential numbers
    to existing rows.  Basically it takes out the gaps so if a
    dock has rows with numbers 0, 2, 5, they will become 0, 1, 2.

    :param `docks`: a list of :class:`AuiDockInfo` structures.
    """

    for ii in xrange(len(docks)):
        dock = docks[ii]
        dock.dock_row = ii
        for jj in xrange(len(dock.panes)):
            dock.panes[jj].dock_row = ii

        docks[ii] = dock

    return docks


def SetActivePane(panes, active_pane):
    """
    Sets the active pane, as well as cycles through
    every other pane and makes sure that all others' active flags
    are turned off.

    :param `panes`: a list of :class:`AuiPaneInfo` structures;
    :param AuiPaneInfo `active_pane`: the pane to be made active (if found).
    """

    for pane in panes:
        pane.state &= ~AuiPaneInfo.optionActive

    for pane in panes:
        if pane.window == active_pane and not pane.IsNotebookPage():
            pane.state |= AuiPaneInfo.optionActive
            return True, panes

    return False, panes


def ShowDockingGuides(guides, show):
    """
    Shows or hide the docking guide windows.

    :param `guides`: a list of :class:`AuiDockingGuide` classes;
    :param bool `show`: whether to show or hide the docking guide windows.
    """

    for target in guides:

        if show and not target.host.IsShown():
            target.host.Show()
            target.host.Update()

        elif not show and target.host.IsShown():
            target.host.Hide()


def RefreshDockingGuides(guides):
    """
    Refreshes the docking guide windows.

    :param `guides`: a list of :class:`AuiDockingGuide` classes;
    """

    for target in guides:
        if target.host.IsShown():
            target.host.Refresh()


def PaneSortFunc(p1, p2):
    """
    This function is used to sort panes by dock position.

    :param AuiPaneInfo `p1`: the first pane instance to compare;
    :param AuiPaneInfo `p2`: the second pane instance to compare.
    """

    return (p1.dock_pos < p2.dock_pos and [-1] or [1])[0]


def GetNotebookRoot(panes, notebook_id):
    """
    Returns the :class:`~lib.agw.aui.auibook.AuiNotebook` which has the specified `notebook_id`.

    :param `panes`: a list of :class:`AuiPaneInfo` instances;
    :param integer `notebook_id`: the target notebook id.
    """

    for paneInfo in panes:
        if paneInfo.IsNotebookControl() and paneInfo.notebook_id == notebook_id:
            return paneInfo

    return None


def EscapeDelimiters(s):
    """
    Changes ``;`` into ``\`` and ``|`` into ``\|`` in the input string.

    :param string `s`: the string to be analyzed.

    :note: This is an internal functions which is used for saving perspectives.
    """

    result = s.replace(";", "\\")
    result = result.replace("|", "|\\")

    return result


def IsDifferentDockingPosition(pane1, pane2):
    """
    Returns whether `pane1` and `pane2` are in a different docking position
    based on pane status, docking direction, docking layer and docking row.

    :param `pane1`: a :class:`AuiPaneInfo` instance;
    :param `pane2`: another :class:`AuiPaneInfo` instance.
    """

    return pane1.IsFloating() != pane2.IsFloating() or \
           pane1.dock_direction != pane2.dock_direction or \
           pane1.dock_layer != pane2.dock_layer or \
           pane1.dock_row != pane2.dock_row


# Convenience function
def AuiManager_HasLiveResize(manager):
    """
    Static function which returns if the input `manager` should have "live resize"
    behaviour.

    :param `manager`: an instance of :class:`AuiManager`.

    .. note::

       This method always returns ``True`` on wxMAC as this platform doesn't have
       the ability to use :class:`ScreenDC` to draw sashes.

    """

    # With Core Graphics on Mac, it's not possible to show sash feedback,
    # so we'll always use live update instead.

    if wx.Platform == "__WXMAC__":
        return True
    else:
        return (manager.GetAGWFlags() & AUI_MGR_LIVE_RESIZE) == AUI_MGR_LIVE_RESIZE


# Convenience function
def AuiManager_UseNativeMiniframes(manager):
    """
    Static function which returns if the input `manager` should use native :class:`MiniFrame` as
    floating panes.

    :param `manager`: an instance of :class:`AuiManager`.

    .. note::

       This method always returns ``True`` on wxMAC as this platform doesn't have
       the ability to use custom drawn miniframes.

    """

    # With Core Graphics on Mac, it's not possible to show sash feedback,
    # so we'll always use live update instead.

    if wx.Platform == "__WXMAC__":
        return True
    else:
        return (manager.GetAGWFlags() & AUI_MGR_USE_NATIVE_MINIFRAMES) == AUI_MGR_USE_NATIVE_MINIFRAMES


def GetManager(window):
    """
    This function will return the aui manager for a given window.

    :param Window `window`: this parameter should be any child window or grand-child
     window (and so on) of the frame/window managed by :class:`AuiManager`. The window
     does not need to be managed by the manager itself, nor does it even need
     to be a child or sub-child of a managed window. It must however be inside
     the window hierarchy underneath the managed window.
    """

    if not isinstance(wx.GetTopLevelParent(window), AuiFloatingFrame):
        if isinstance(window, auibar.AuiToolBar):
            return window.GetAuiManager()

    evt = AuiManagerEvent(wxEVT_AUI_FIND_MANAGER)
    evt.SetManager(None)
    evt.ResumePropagation(wx.EVENT_PROPAGATE_MAX)

    if not window.GetEventHandler().ProcessEvent(evt):
        return None

    return evt.GetManager()


# ---------------------------------------------------------------------------- #

class AuiManager(wx.EvtHandler):
    """
    AuiManager manages the panes associated with it for a particular :class:`Frame`,
    using a pane's :class:`AuiManager` information to determine each pane's docking and
    floating behavior. :class:`AuiManager` uses wxPython's sizer mechanism to plan the
    layout of each frame. It uses a replaceable dock art class to do all drawing,
    so all drawing is localized in one area, and may be customized depending on an
    applications' specific needs.

    :class:`AuiManager` works as follows: the programmer adds panes to the class, or makes
    changes to existing pane properties (dock position, floating state, show state, etc...).
    To apply these changes, the :meth:`AuiManager.Update() <AuiManager.Update>` function is called. This batch
    processing can be used to avoid flicker, by modifying more than one pane at a time,
    and then "committing" all of the changes at once by calling `Update()`.

    Panes can be added quite easily::

        text1 = wx.TextCtrl(self, -1)
        text2 = wx.TextCtrl(self, -1)
        self._mgr.AddPane(text1, AuiPaneInfo().Left().Caption("Pane Number One"))
        self._mgr.AddPane(text2, AuiPaneInfo().Bottom().Caption("Pane Number Two"))

        self._mgr.Update()


    Later on, the positions can be modified easily. The following will float an
    existing pane in a tool window::

        self._mgr.GetPane(text1).Float()


    **Layers, Rows and Directions, Positions:**

    Inside AUI, the docking layout is figured out by checking several pane parameters.
    Four of these are important for determining where a pane will end up.

    **Direction** - Each docked pane has a direction, `Top`, `Bottom`, `Left`, `Right`, or `Center`.
    This is fairly self-explanatory. The pane will be placed in the location specified
    by this variable.

    **Position** - More than one pane can be placed inside of a "dock". Imagine two panes
    being docked on the left side of a window. One pane can be placed over another.
    In proportionally managed docks, the pane position indicates it's sequential position,
    starting with zero. So, in our scenario with two panes docked on the left side, the
    top pane in the dock would have position 0, and the second one would occupy position 1.

    **Row** - A row can allow for two docks to be placed next to each other. One of the most
    common places for this to happen is in the toolbar. Multiple toolbar rows are allowed,
    the first row being in row 0, and the second in row 1. Rows can also be used on
    vertically docked panes.

    **Layer** - A layer is akin to an onion. Layer 0 is the very center of the managed pane.
    Thus, if a pane is in layer 0, it will be closest to the center window (also sometimes
    known as the "content window"). Increasing layers "swallow up" all layers of a lower
    value. This can look very similar to multiple rows, but is different because all panes
    in a lower level yield to panes in higher levels. The best way to understand layers
    is by running the AUI sample (`AUI.py`).
    """

    def __init__(self, managed_window=None, agwFlags=None):
        """
        Default class constructor.

        :param Window `managed_window`: specifies the window which should be managed;
        :param integer `agwFlags`: specifies options which allow the frame management behavior to be
         modified. `agwFlags` can be a combination of the following style bits:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_MGR_ALLOW_FLOATING``           Allow floating of panes
         ``AUI_MGR_ALLOW_ACTIVE_PANE``        If a pane becomes active, "highlight" it in the interface
         ``AUI_MGR_TRANSPARENT_DRAG``         If the platform supports it, set transparency on a floating pane while it is dragged by the user
         ``AUI_MGR_TRANSPARENT_HINT``         If the platform supports it, show a transparent hint window when the user is about to dock a floating pane
         ``AUI_MGR_VENETIAN_BLINDS_HINT``     Show a "venetian blind" effect when the user is about to dock a floating pane
         ``AUI_MGR_RECTANGLE_HINT``           Show a rectangle hint effect when the user is about to dock a floating pane
         ``AUI_MGR_HINT_FADE``                If the platform supports it, the hint window will fade in and out
         ``AUI_MGR_NO_VENETIAN_BLINDS_FADE``  Disables the "venetian blind" fade in and out
         ``AUI_MGR_LIVE_RESIZE``              Live resize when the user drag a sash
         ``AUI_MGR_ANIMATE_FRAMES``           Fade-out floating panes when they are closed (all platforms which support frames transparency)
                                              and show a moving rectangle when they are docked (Windows < Vista and GTK only)
         ``AUI_MGR_AERO_DOCKING_GUIDES``      Use the new Aero-style bitmaps as docking guides
         ``AUI_MGR_PREVIEW_MINIMIZED_PANES``  Slide in and out minimized panes to preview them
         ``AUI_MGR_WHIDBEY_DOCKING_GUIDES``   Use the new Whidbey-style bitmaps as docking guides
         ``AUI_MGR_SMOOTH_DOCKING``           Performs a "smooth" docking of panes (a la PyQT)
         ``AUI_MGR_USE_NATIVE_MINIFRAMES``    Use miniframes with native caption bar as floating panes instead or custom drawn caption bars (forced on wxMAC)
         ``AUI_MGR_AUTONB_NO_CAPTION``        Panes that merge into an automatic notebook will not have the pane caption visible
         ==================================== ==================================

         Default value for `agwFlags` is:
         ``AUI_MGR_DEFAULT`` = ``AUI_MGR_ALLOW_FLOATING`` | ``AUI_MGR_TRANSPARENT_HINT`` | ``AUI_MGR_HINT_FADE`` | ``AUI_MGR_NO_VENETIAN_BLINDS_FADE``

         .. note::

            If using the ``AUI_MGR_USE_NATIVE_MINIFRAMES``, double-clicking on a
            floating pane caption will not re-dock the pane, but simply maximize it (if
            :meth:`AuiPaneInfo.MaximizeButton` has been set to ``True``) or do nothing.

        """

        wx.EvtHandler.__init__(self)

        self._action = actionNone
        self._action_window = None
        self._hover_button = None
        self._art = dockart.AuiDefaultDockArt()
        self._hint_window = None
        self._active_pane = None
        self._has_maximized = False
        self._has_minimized = False

        self._frame = None
        self._dock_constraint_x = 0.3
        self._dock_constraint_y = 0.3
        self._reserved = None

        self._panes = []
        self._docks = []
        self._uiparts = []

        self._guides = []
        self._notebooks = []

        self._masterManager = None
        self._currentDragItem = -1
        self._lastknowndocks = {}

        self._hint_fadetimer = wx.Timer(self, wx.ID_ANY)
        self._hint_fademax = 50
        self._last_hint = wx.Rect()

        self._from_move = False
        self._last_rect = wx.Rect()

        if agwFlags is None:
            agwFlags = AUI_MGR_DEFAULT

        self._agwFlags = agwFlags
        self._is_docked = (False, wx.RIGHT, wx.TOP, 0)
        self._snap_limits = (15, 15)

        if wx.Platform == "__WXMSW__":
            self._animation_step = 30.0
        else:
            self._animation_step = 5.0

        self._hint_rect = wx.Rect()

        self._preview_timer = wx.Timer(self, wx.ID_ANY)
        self._sliding_frame = None

        self._autoNBTabArt = tabart.AuiDefaultTabArt()
        self._autoNBStyle = AUI_NB_DEFAULT_STYLE | AUI_NB_BOTTOM | \
                            AUI_NB_SUB_NOTEBOOK | AUI_NB_TAB_EXTERNAL_MOVE
        self._autoNBStyle -= AUI_NB_DRAW_DND_TAB

        if managed_window:
            self.SetManagedWindow(managed_window)

        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_SET_CURSOR, self.OnSetCursor)
        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_DCLICK, self.OnLeftDClick)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.Bind(wx.EVT_MOTION, self.OnMotion)
        self.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow)
        self.Bind(wx.EVT_CHILD_FOCUS, self.OnChildFocus)
        self.Bind(wx.EVT_MOUSE_CAPTURE_LOST, self.OnCaptureLost)
        self.Bind(wx.EVT_TIMER, self.OnHintFadeTimer, self._hint_fadetimer)
        self.Bind(wx.EVT_TIMER, self.SlideIn, self._preview_timer)
        self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroy)

        self.Bind(wx.EVT_MOVE, self.OnMove)
        self.Bind(wx.EVT_SYS_COLOUR_CHANGED, self.OnSysColourChanged)

        self.Bind(EVT_AUI_PANE_BUTTON, self.OnPaneButton)
        self.Bind(EVT_AUI_RENDER, self.OnRender)
        self.Bind(EVT_AUI_FIND_MANAGER, self.OnFindManager)
        self.Bind(EVT_AUI_PANE_MIN_RESTORE, self.OnRestoreMinimizedPane)
        self.Bind(EVT_AUI_PANE_DOCKED, self.OnPaneDocked)

        self.Bind(auibook.EVT_AUINOTEBOOK_BEGIN_DRAG, self.OnTabBeginDrag)
        self.Bind(auibook.EVT_AUINOTEBOOK_PAGE_CLOSE, self.OnTabPageClose)
        self.Bind(auibook.EVT_AUINOTEBOOK_PAGE_CHANGED, self.OnTabSelected)


    def CreateFloatingFrame(self, parent, pane_info):
        """
        Creates a floating frame for the windows.

        :param Window `parent`: the floating frame parent;
        :param `pane_info`: the :class:`AuiPaneInfo` class with all the pane's information.
        """

        return AuiFloatingFrame(parent, self, pane_info)


    def CanDockPanel(self, p):
        """
        Returns whether a pane can be docked or not.

        :param `p`: the :class:`AuiPaneInfo` class with all the pane's information.
        """

        # is the pane dockable?
        if not p.IsDockable():
            return False

        # if a key modifier is pressed while dragging the frame,
        # don't dock the window
        return not (wx.GetKeyState(wx.WXK_CONTROL) or wx.GetKeyState(wx.WXK_ALT))


    def GetPaneByWidget(self, window):
        """
        This version of :meth:`GetPane` looks up a pane based on a 'pane window'.

        :param `window`: a :class:`Window` derived window.

        :see: :meth:`~AuiManager.GetPane`
        """

        for p in self._panes:
            if p.window == window:
                return p

        return NonePaneInfo


    def GetPaneByName(self, name):
        """
        This version of :meth:`GetPane` looks up a pane based on a 'pane name'.

        :param string `name`: the pane name.

        :see: :meth:`GetPane`
        """

        for p in self._panes:
            if p.name == name:
                return p

        return NonePaneInfo


    def GetPane(self, item):
        """
        Looks up a :class:`AuiPaneInfo` structure based on the supplied window pointer. Upon failure,
        :meth:`GetPane` returns an empty :class:`AuiPaneInfo`, a condition which can be checked
        by calling :meth:`AuiPaneInfo.IsOk() <AuiPaneInfo.IsOk>`.

        The pane info's structure may then be modified. Once a pane's info is modified, :meth:`Update`
        must be called to realize the changes in the UI.

        :param `item`: either a pane name or a :class:`Window`.
        """

        if isinstance(item, basestring):
            return self.GetPaneByName(item)
        else:
            return self.GetPaneByWidget(item)


    def GetAllPanes(self):
        """ Returns a reference to all the pane info structures. """

        return self._panes


    def ShowPane(self, window, show):
        """
        Shows or hides a pane based on the window passed as input.

        :param Window `window`: any subclass or derivation of :class:`Window`;
        :param bool `show`: ``True`` to show the pane, ``False`` otherwise.
        """

        p = self.GetPane(window)

        if p.IsOk():
            if p.IsNotebookPage():
                if show:

                    notebook = self._notebooks[p.notebook_id]
                    id = notebook.GetPageIndex(p.window)
                    if id >= 0:
                        notebook.SetSelection(id)
                    self.ShowPane(notebook, True)

            else:
                p.Show(show)

            if p.frame:
                p.frame.Raise()

            self.Update()


    def HitTest(self, x, y):
        """
        This is an internal function which determines
        which UI item the specified coordinates are over.

        :param integer `x`: specifies a x position in client coordinates;
        :param integer `y`: specifies a y position in client coordinates.
        """

        result = None

        for item in self._uiparts:
            # we are not interested in typeDock, because this space
            # isn't used to draw anything, just for measurements
            # besides, the entire dock area is covered with other
            # rectangles, which we are interested in.
            if item.type == AuiDockUIPart.typeDock:
                continue

            # if we already have a hit on a more specific item, we are not
            # interested in a pane hit.  If, however, we don't already have
            # a hit, returning a pane hit is necessary for some operations
            if item.type in [AuiDockUIPart.typePane, AuiDockUIPart.typePaneBorder] and result:
                continue

            # if the point is inside the rectangle, we have a hit
            if item.rect.Contains((x, y)):
                result = item

        return result


    def PaneHitTest(self, panes, pt):
        """
        Similar to :meth:`HitTest`, but it checks in which :class:`AuiManager` rectangle the
        input point belongs to.

        :param `panes`: a list of :class:`AuiPaneInfo` instances;
        :param Point `pt`: the mouse position.
        """

        for paneInfo in panes:
            if paneInfo.IsDocked() and paneInfo.IsShown() and paneInfo.rect.Contains(pt):
                return paneInfo

        return NonePaneInfo


    # SetAGWFlags() and GetAGWFlags() allow the owner to set various
    # options which are global to AuiManager

    def SetAGWFlags(self, agwFlags):
        """
        This method is used to specify :class:`AuiManager` 's settings flags.

        :param integer `agwFlags`: specifies options which allow the frame management behavior
         to be modified. `agwFlags` can be one of the following style bits:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_MGR_ALLOW_FLOATING``           Allow floating of panes
         ``AUI_MGR_ALLOW_ACTIVE_PANE``        If a pane becomes active, "highlight" it in the interface
         ``AUI_MGR_TRANSPARENT_DRAG``         If the platform supports it, set transparency on a floating pane while it is dragged by the user
         ``AUI_MGR_TRANSPARENT_HINT``         If the platform supports it, show a transparent hint window when the user is about to dock a floating pane
         ``AUI_MGR_VENETIAN_BLINDS_HINT``     Show a "venetian blind" effect when the user is about to dock a floating pane
         ``AUI_MGR_RECTANGLE_HINT``           Show a rectangle hint effect when the user is about to dock a floating pane
         ``AUI_MGR_HINT_FADE``                If the platform supports it, the hint window will fade in and out
         ``AUI_MGR_NO_VENETIAN_BLINDS_FADE``  Disables the "venetian blind" fade in and out
         ``AUI_MGR_LIVE_RESIZE``              Live resize when the user drag a sash
         ``AUI_MGR_ANIMATE_FRAMES``           Fade-out floating panes when they are closed (all platforms which support frames transparency)
                                              and show a moving rectangle when they are docked (Windows < Vista and GTK only)
         ``AUI_MGR_AERO_DOCKING_GUIDES``      Use the new Aero-style bitmaps as docking guides
         ``AUI_MGR_PREVIEW_MINIMIZED_PANES``  Slide in and out minimized panes to preview them
         ``AUI_MGR_WHIDBEY_DOCKING_GUIDES``   Use the new Whidbey-style bitmaps as docking guides
         ``AUI_MGR_SMOOTH_DOCKING``           Performs a "smooth" docking of panes (a la PyQT)
         ``AUI_MGR_USE_NATIVE_MINIFRAMES``    Use miniframes with native caption bar as floating panes instead or custom drawn caption bars (forced on wxMAC)
         ``AUI_MGR_AUTONB_NO_CAPTION``        Panes that merge into an automatic notebook will not have the pane caption visible
         ==================================== ==================================

         .. note::

            If using the ``AUI_MGR_USE_NATIVE_MINIFRAMES``, double-clicking on a
            floating pane caption will not re-dock the pane, but simply maximize it (if
            :meth:`AuiPaneInfo.MaximizeButton` has been set to ``True``) or do nothing.

        """

        self._agwFlags = agwFlags

        if len(self._guides) > 0:
            self.CreateGuideWindows()

        if self._hint_window and agwFlags & AUI_MGR_RECTANGLE_HINT == 0:
            self.CreateHintWindow()


    def GetAGWFlags(self):
        """
        Returns the current manager's flags.

        :see: :meth:`SetAGWFlags` for a list of possible :class:`AuiManager` flags.
        """

        return self._agwFlags


    def SetManagedWindow(self, managed_window):
        """
        Called to specify the frame or window which is to be managed by :class:`AuiManager`.
        Frame management is not restricted to just frames. Child windows or custom
        controls are also allowed.

        :param Window `managed_window`: specifies the window which should be managed by
         the AUI manager.
        """

        if not managed_window:
            raise Exception("Specified managed window must be non-null. ")

        self.UnInit()

        self._frame = managed_window
        self._frame.PushEventHandler(self)

        # if the owner is going to manage an MDI parent frame,
        # we need to add the MDI client window as the default
        # center pane

        if isinstance(self._frame, wx.MDIParentFrame):
            mdi_frame = self._frame
            client_window = mdi_frame.GetClientWindow()

            if not client_window:
                raise Exception("Client window is None!")

            self.AddPane(client_window, AuiPaneInfo().Name("mdiclient").
                         CenterPane().PaneBorder(False))

        elif isinstance(self._frame, tabmdi.AuiMDIParentFrame):

            mdi_frame = self._frame
            client_window = mdi_frame.GetClientWindow()

            if not client_window:
                raise Exception("Client window is None!")

            self.AddPane(client_window, AuiPaneInfo().Name("mdiclient").
                         CenterPane().PaneBorder(False))


    def GetManagedWindow(self):
        """ Returns the window being managed by :class:`AuiManager`. """

        return self._frame


    def SetFrame(self, managed_window):
        """
        Called to specify the frame or window which is to be managed by :class:`AuiManager`.
        Frame management is not restricted to just frames. Child windows or custom
        controls are also allowed.

        :param Window `managed_window`: specifies the window which should be managed by
         the AUI manager.

        .. deprecated:: 0.6
           This method is now deprecated, use :meth:`SetManagedWindow` instead.
        """

        DeprecationWarning("This method is deprecated, use SetManagedWindow instead.")
        return self.SetManagedWindow(managed_window)


    def GetFrame(self):
        """
        Returns the window being managed by :class:`AuiManager`.

        .. deprecated:: 0.6
           This method is now deprecated, use :meth:`GetManagedWindow` instead.
        """

        DeprecationWarning("This method is deprecated, use GetManagedWindow instead.")
        return self._frame


    def CreateGuideWindows(self):
        """ Creates the VS2005 HUD guide windows. """

        self.DestroyGuideWindows()

        self._guides.append(AuiDockingGuideInfo().Left().
                            Host(AuiSingleDockingGuide(self._frame, wx.LEFT)))
        self._guides.append(AuiDockingGuideInfo().Top().
                            Host(AuiSingleDockingGuide(self._frame, wx.TOP)))
        self._guides.append(AuiDockingGuideInfo().Right().
                            Host(AuiSingleDockingGuide(self._frame, wx.RIGHT)))
        self._guides.append(AuiDockingGuideInfo().Bottom().
                            Host(AuiSingleDockingGuide(self._frame, wx.BOTTOM)))
        self._guides.append(AuiDockingGuideInfo().Centre().
                            Host(AuiCenterDockingGuide(self._frame)))


    def DestroyGuideWindows(self):
        """ Destroys the VS2005 HUD guide windows. """

        for guide in self._guides:
            if guide.host:
                guide.host.Destroy()

        self._guides = []


    def CreateHintWindow(self):
        """ Creates the standard wxAUI hint window. """

        self.DestroyHintWindow()

        self._hint_window = AuiDockingHintWindow(self._frame)
        self._hint_window.SetBlindMode(self._agwFlags)


    def DestroyHintWindow(self):
        """ Destroys the standard wxAUI hint window. """

        if self._hint_window:

            self._hint_window.Destroy()
            self._hint_window = None


    def UnInit(self):
        """
        Uninitializes the framework and should be called before a managed frame or
        window is destroyed. :meth:`UnInit` is usually called in the managed :class:`Frame` / :class:`Window`
        destructor.

        It is necessary to call this function before the managed frame or window is
        destroyed, otherwise the manager cannot remove its custom event handlers
        from a window.
        """

        if not self._frame:
            return

        for klass in [self._frame] + list(self._frame.GetChildren()):
            handler = klass.GetEventHandler()
            if klass is not handler:
                if isinstance(handler, AuiManager):
                    klass.RemoveEventHandler(handler)


    def OnDestroy(self, event) :

        if self._frame == event.GetEventObject():
            self.UnInit();


    def GetArtProvider(self):
        """ Returns the current art provider being used. """

        return self._art


    def ProcessMgrEvent(self, event):
        """
        Process the AUI events sent to the manager.

        :param `event`: the event to process, an instance of :class:`AuiManagerEvent`.
        """

        # first, give the owner frame a chance to override
        if self._frame:
            if self._frame.GetEventHandler().ProcessEvent(event):
                return

        self.ProcessEvent(event)


    def FireEvent(self, evtType, pane, canVeto=False):
        """
        Fires one of the ``EVT_AUI_PANE_FLOATED`` / ``FLOATING`` / ``DOCKING`` / ``DOCKED`` / ``ACTIVATED`` event.

        :param integer `evtType`: one of the aforementioned events;
        :param `pane`: the :class:`AuiPaneInfo` instance associated to this event;
        :param bool `canVeto`: whether the event can be vetoed or not.
        """

        event = AuiManagerEvent(evtType)
        event.SetPane(pane)
        event.SetCanVeto(canVeto)
        self.ProcessMgrEvent(event)

        return event


    def CanUseModernDockArt(self):
        """
        Returns whether :class:`dockart` can be used (Windows XP / Vista / 7 only,
        requires Mark Hammonds's `pywin32 <http://sourceforge.net/projects/pywin32/>`_ package).
        """

        if not _winxptheme:
            return False

        # Get the size of a small close button (themed)
        hwnd = self._frame.GetHandle()
        hTheme = winxptheme.OpenThemeData(hwnd, "Window")

        if not hTheme:
            return False

        return True


    def SetArtProvider(self, art_provider):
        """
        Instructs :class:`AuiManager` to use art provider specified by the parameter
        `art_provider` for all drawing calls. This allows plugable look-and-feel
        features.

        :param `art_provider`: a AUI dock art provider.

        :note: The previous art provider object, if any, will be deleted by :class:`AuiManager`.
        """

        # delete the last art provider, if any
        del self._art

        # assign the new art provider
        self._art = art_provider

        for pane in self.GetAllPanes():
            if pane.IsFloating() and pane.frame:
                pane.frame._mgr.SetArtProvider(art_provider)
                pane.frame._mgr.Update()


    def AddPane(self, window, arg1=None, arg2=None, target=None):
        """
        Tells the frame manager to start managing a child window. There
        are four versions of this function. The first verison allows the full spectrum
        of pane parameter possibilities (:meth:`AddPane1`). The second version is used for
        simpler user interfaces which do not require as much configuration (:meth:`AddPane2`).
        The :meth:`AddPane3` version allows a drop position to be specified, which will determine
        where the pane will be added. The :meth:`AddPane4` version allows to turn the target
        :class:`AuiPaneInfo` pane into a notebook and the added pane into a page.

        In your code, simply call :meth:`AddPane`.

        :param Window `window`: the child window to manage;
        :param `arg1`: a :class:`AuiPaneInfo` or an integer value (direction);
        :param `arg2`: a :class:`AuiPaneInfo` or a :class:`Point` (drop position);
        :param `target`: a :class:`AuiPaneInfo` to be turned into a notebook
         and new pane added to it as a page. (additionally, target can be any pane in
         an existing notebook)
         """

        if target in self._panes:
            return self.AddPane4(window, arg1, target)

        if type(arg1) == type(1):
            # This Is Addpane2
            if arg1 is None:
                arg1 = wx.LEFT
            if arg2 is None:
                arg2 = ""
            return self.AddPane2(window, arg1, arg2)
        else:
            if isinstance(arg2, wx.Point):
                return self.AddPane3(window, arg1, arg2)
            else:
                return self.AddPane1(window, arg1)


    def AddPane1(self, window, pane_info):
        """ See comments on :meth:`AddPane`. """

        # check if the pane has a valid window
        if not window:
            return False

        # check if the pane already exists
        if self.GetPane(pane_info.window).IsOk():
            return False

        # check if the pane name already exists, this could reveal a
        # bug in the library user's application
        already_exists = False
        if pane_info.name != "" and self.GetPane(pane_info.name).IsOk():
            warnings.warn("A pane with the name '%s' already exists in the manager!"%pane_info.name)
            already_exists = True

        # if the new pane is docked then we should undo maximize
        if pane_info.IsDocked():
            self.RestoreMaximizedPane()

        self._panes.append(pane_info)
        pinfo = self._panes[-1]

        # set the pane window
        pinfo.window = window

        # if the pane's name identifier is blank, create a random string
        if pinfo.name == "" or already_exists:
            pinfo.name = ("%s%08x%08x%08x")%(pinfo.window.GetName(), time.time(),
                                             time.clock(), len(self._panes))

        # set initial proportion (if not already set)
        if pinfo.dock_proportion == 0:
            pinfo.dock_proportion = 100000

        floating = isinstance(self._frame, AuiFloatingFrame)

        pinfo.buttons = []

        if not floating and pinfo.HasMinimizeButton():
            button = AuiPaneButton(AUI_BUTTON_MINIMIZE)
            pinfo.buttons.append(button)

        if not floating and pinfo.HasMaximizeButton():
            button = AuiPaneButton(AUI_BUTTON_MAXIMIZE_RESTORE)
            pinfo.buttons.append(button)

        if not floating and pinfo.HasPinButton():
            button = AuiPaneButton(AUI_BUTTON_PIN)
            pinfo.buttons.append(button)

        if pinfo.HasCloseButton():
            button = AuiPaneButton(AUI_BUTTON_CLOSE)
            pinfo.buttons.append(button)

        if pinfo.HasGripper():
            if isinstance(pinfo.window, auibar.AuiToolBar):
                # prevent duplicate gripper -- both AuiManager and AuiToolBar
                # have a gripper control.  The toolbar's built-in gripper
                # meshes better with the look and feel of the control than ours,
                # so turn AuiManager's gripper off, and the toolbar's on.

                tb = pinfo.window
                pinfo.SetFlag(AuiPaneInfo.optionGripper, False)
                tb.SetGripperVisible(True)

        if pinfo.window:
            if pinfo.best_size == wx.Size(-1, -1):
                pinfo.best_size = pinfo.window.GetClientSize()

            if isinstance(pinfo.window, wx.ToolBar):
                # GetClientSize() doesn't get the best size for
                # a toolbar under some newer versions of wxWidgets,
                # so use GetBestSize()
                pinfo.best_size = pinfo.window.GetBestSize()

                # this is needed for Win2000 to correctly fill toolbar backround
                # it should probably be repeated once system colour change happens
                if wx.Platform == "__WXMSW__" and pinfo.window.UseBgCol():
                    pinfo.window.SetBackgroundColour(self.GetArtProvider().GetColour(AUI_DOCKART_BACKGROUND_COLOUR))

            if pinfo.min_size != wx.Size(-1, -1):
                if pinfo.best_size.x < pinfo.min_size.x:
                    pinfo.best_size.x = pinfo.min_size.x
                if pinfo.best_size.y < pinfo.min_size.y:
                    pinfo.best_size.y = pinfo.min_size.y

        self._panes[-1] = pinfo
        if isinstance(window, auibar.AuiToolBar):
            window.SetAuiManager(self)

        return True


    def AddPane2(self, window, direction, caption):
        """ See comments on :meth:`AddPane`. """

        pinfo = AuiPaneInfo()
        pinfo.Caption(caption)

        if direction == wx.TOP:
            pinfo.Top()
        elif direction == wx.BOTTOM:
            pinfo.Bottom()
        elif direction == wx.LEFT:
            pinfo.Left()
        elif direction == wx.RIGHT:
            pinfo.Right()
        elif direction == wx.CENTER:
            pinfo.CenterPane()

        return self.AddPane(window, pinfo)


    def AddPane3(self, window, pane_info, drop_pos):
        """ See comments on :meth:`AddPane`. """

        if not self.AddPane(window, pane_info):
            return False

        pane = self.GetPane(window)
        indx = self._panes.index(pane)

        ret, pane = self.DoDrop(self._docks, self._panes, pane, drop_pos, wx.Point(0, 0))
        self._panes[indx] = pane

        return True


    def AddPane4(self, window, pane_info, target):
        """ See comments on :meth:`AddPane`. """

        if not self.AddPane(window, pane_info):
            return False

        paneInfo = self.GetPane(window)

        if not paneInfo.IsNotebookDockable():
            return self.AddPane1(window, pane_info)
        if not target.IsNotebookDockable() and not target.IsNotebookControl():
            return self.AddPane1(window, pane_info)

        if not target.HasNotebook():
            self.CreateNotebookBase(self._panes, target)

        # Add new item to notebook
        paneInfo.NotebookPage(target.notebook_id)

        # we also want to remove our captions sometimes
        self.RemoveAutoNBCaption(paneInfo)
        self.UpdateNotebook()

        return True


    def InsertPane(self, window, pane_info, insert_level=AUI_INSERT_PANE):
        """
        This method is used to insert either a previously unmanaged pane window
        into the frame manager, or to insert a currently managed pane somewhere else.
        :meth:`InsertPane` will push all panes, rows, or docks aside and insert the window
        into the position specified by `pane_info`.

        Because `pane_info` can specify either a pane, dock row, or dock layer, the
        `insert_level` parameter is used to disambiguate this. The parameter `insert_level`
        can take a value of ``AUI_INSERT_PANE``, ``AUI_INSERT_ROW`` or ``AUI_INSERT_DOCK``.

        :param Window `window`: the window to be inserted and managed;
        :param `pane_info`: the insert location for the new window;
        :param integer `insert_level`: the insertion level of the new pane.
        """

        if not window:
            raise Exception("Invalid window passed to InsertPane.")

        # shift the panes around, depending on the insert level
        if insert_level == AUI_INSERT_PANE:
            self._panes = DoInsertPane(self._panes, pane_info.dock_direction,
                                       pane_info.dock_layer, pane_info.dock_row,
                                       pane_info.dock_pos)

        elif insert_level == AUI_INSERT_ROW:
            self._panes = DoInsertDockRow(self._panes, pane_info.dock_direction,
                                          pane_info.dock_layer, pane_info.dock_row)

        elif insert_level == AUI_INSERT_DOCK:
            self._panes = DoInsertDockLayer(self._panes, pane_info.dock_direction,
                                            pane_info.dock_layer)

        # if the window already exists, we are basically just moving/inserting the
        # existing window.  If it doesn't exist, we need to add it and insert it
        existing_pane = self.GetPane(window)
        indx = self._panes.index(existing_pane)

        if not existing_pane.IsOk():

            return self.AddPane(window, pane_info)

        else:

            if pane_info.IsFloating():
                existing_pane.Float()
                if pane_info.floating_pos != wx.Point(-1, -1):
                    existing_pane.FloatingPosition(pane_info.floating_pos)
                if pane_info.floating_size != wx.Size(-1, -1):
                    existing_pane.FloatingSize(pane_info.floating_size)
            else:
                # if the new pane is docked then we should undo maximize
                self.RestoreMaximizedPane()

                existing_pane.Direction(pane_info.dock_direction)
                existing_pane.Layer(pane_info.dock_layer)
                existing_pane.Row(pane_info.dock_row)
                existing_pane.Position(pane_info.dock_pos)

            self._panes[indx] = existing_pane

        return True


    def DetachPane(self, window):
        """
        Tells the :class:`AuiManager` to stop managing the pane specified
        by `window`. The window, if in a floated frame, is reparented to the frame
        managed by :class:`AuiManager`.

        :param Window `window`: the window to be un-managed.
        """

        for p in self._panes:
            if p.window == window:
                if p.frame:
                    # we have a floating frame which is being detached. We need to
                    # reparent it to self._frame and destroy the floating frame

                    # reduce flicker
                    p.window.SetSize((1, 1))
                    if p.frame.IsShown():
                        p.frame.Show(False)

                    if self._action_window == p.frame:
                        self._action_window = None

                    # reparent to self._frame and destroy the pane
                    p.window.Reparent(self._frame)
                    p.frame.SetSizer(None)
                    p.frame.Destroy()
                    p.frame = None

                elif p.IsNotebookPage():
                    notebook = self._notebooks[p.notebook_id]
                    id = notebook.GetPageIndex(p.window)
                    notebook.RemovePage(id)

                # make sure there are no references to this pane in our uiparts,
                # just in case the caller doesn't call Update() immediately after
                # the DetachPane() call.  This prevets obscure crashes which would
                # happen at window repaint if the caller forgets to call Update()
                counter = 0
                for pi in xrange(len(self._uiparts)):
                    part = self._uiparts[counter]
                    if part.pane == p:
                        self._uiparts.pop(counter)
                        counter -= 1

                    counter += 1

                self._panes.remove(p)
                return True

        return False


    def ClosePane(self, pane_info):
        """
        Destroys or hides the pane depending on its flags.

        :param `pane_info`: a :class:`AuiPaneInfo` instance.
        """
        # if we were maximized, restore
        if pane_info.IsMaximized():
            self.RestorePane(pane_info)

        if pane_info.frame:
            if self._agwFlags & AUI_MGR_ANIMATE_FRAMES:
                pane_info.frame.FadeOut()

        # first, hide the window
        if pane_info.window and pane_info.window.IsShown():
            pane_info.window.Show(False)

        # make sure that we are the parent of this window
        if pane_info.window and pane_info.window.GetParent() != self._frame:
            pane_info.window.Reparent(self._frame)

        # if we have a frame, destroy it
        if pane_info.frame:
            pane_info.frame.Destroy()
            pane_info.frame = None

        elif pane_info.IsNotebookPage():
            # if we are a notebook page, remove ourselves...
            # the  code would index out of bounds
            # if the last page of a sub-notebook was closed
            # because the notebook would be deleted, before this
            # code is executed.
            # This code just prevents an out-of bounds error.
            if self._notebooks:
                nid = pane_info.notebook_id
                if nid >= 0 and nid < len(self._notebooks):
                    notebook = self._notebooks[nid]
                    page_idx = notebook.GetPageIndex(pane_info.window)
                    if page_idx >= 0:
                        notebook.RemovePage(page_idx)

        # now we need to either destroy or hide the pane
        to_destroy = 0
        if pane_info.IsDestroyOnClose():
            to_destroy = pane_info.window
            self.DetachPane(to_destroy)
        else:
            if isinstance(pane_info.window, auibar.AuiToolBar) and pane_info.IsFloating():
                tb = pane_info.window
                if pane_info.dock_direction in [AUI_DOCK_LEFT, AUI_DOCK_RIGHT]:
                    tb.SetAGWWindowStyleFlag(tb.GetAGWWindowStyleFlag() | AUI_TB_VERTICAL)

            #pane_info.Dock().Hide()
            # We don't want to dock the pane when it's closed. Just hide 
            # it so that if it's currently floated, it's re-floated the
            # next time it is shown.
            pane_info.Hide()

        if pane_info.IsNotebookControl():

            notebook = self._notebooks[pane_info.notebook_id]
            while notebook.GetPageCount():
                window = notebook.GetPage(0)
                notebook.RemovePage(0)
                info = self.GetPane(window)
                if info.IsOk():
                    info.notebook_id = -1
                    info.dock_direction = AUI_DOCK_NONE
                    # Note: this could change our paneInfo reference ...
                    self.ClosePane(info)

        if to_destroy:
            to_destroy.Destroy()


    def MaximizePane(self, pane_info, savesizes=True):
        """
        Maximizes the input pane.

        :param `pane_info`: a :class:`AuiPaneInfo` instance.
        :param bool `savesizes`: whether to save previous dock sizes.
        """

        if savesizes:
            self.SavePreviousDockSizes(pane_info)

        for p in self._panes:

            # save hidden state
            p.SetFlag(p.savedHiddenState, p.HasFlag(p.optionHidden))

            if not p.IsToolbar() and not p.IsFloating():
                p.Restore()

                # hide the pane, because only the newly
                # maximized pane should show
                p.Hide()

        pane_info.previousDockPos = pane_info.dock_pos

        # mark ourselves maximized
        pane_info.Maximize()
        pane_info.Show()
        self._has_maximized = True

        # last, show the window
        if pane_info.window and not pane_info.window.IsShown():
            pane_info.window.Show(True)


    def SavePreviousDockSizes(self, pane_info):
        """
        Stores the previous dock sizes, to be used in a "restore" action later.

        :param `pane_info`: a :class:`AuiPaneInfo` instance.
        """

        for d in self._docks:
            if not d.toolbar:
                for p in d.panes:
                    p.previousDockSize = d.size
                    if pane_info is not p:
                        p.SetFlag(p.needsRestore, True)


    def RestorePane(self, pane_info):
        """
        Restores the input pane from a previous maximized or minimized state.

        :param `pane_info`: a :class:`AuiPaneInfo` instance.
        """

        # restore all the panes
        for p in self._panes:
            if not p.IsToolbar():
                p.SetFlag(p.optionHidden, p.HasFlag(p.savedHiddenState))

        pane_info.SetFlag(pane_info.needsRestore, True)

        # mark ourselves non-maximized
        pane_info.Restore()
        self._has_maximized = False
        self._has_minimized = False

        # last, show the window
        if pane_info.window and not pane_info.window.IsShown():
            pane_info.window.Show(True)


    def RestoreMaximizedPane(self):
        """ Restores the current maximized pane (if any). """

        # restore all the panes
        for p in self._panes:
            if p.IsMaximized():
                self.RestorePane(p)
                break


    def ActivatePane(self, window):
        """
        Activates the pane to which `window` is associated.

        :param `window`: a :class:`Window` derived window.
        """

        if self.GetAGWFlags() & AUI_MGR_ALLOW_ACTIVE_PANE:
            while window:
                ret, self._panes = SetActivePane(self._panes, window)
                if ret:
                    break

                window = window.GetParent()

            self.RefreshCaptions()
            self.FireEvent(wxEVT_AUI_PANE_ACTIVATED, window, canVeto=False)


    def CreateNotebook(self):
        """
        Creates an automatic :class:`~lib.agw.aui.auibook.AuiNotebook` when a pane is docked on
        top of another pane.
        """

        notebook = auibook.AuiNotebook(self._frame, -1, wx.Point(0, 0), wx.Size(0, 0), agwStyle=self._autoNBStyle)

        # This is so we can get the tab-drag event.
        notebook.GetAuiManager().SetMasterManager(self)
        notebook.SetArtProvider(self._autoNBTabArt.Clone())
        self._notebooks.append(notebook)

        return notebook


    def SetAutoNotebookTabArt(self, art):
        """
        Sets the default tab art provider for automatic notebooks.

        :param `art`: a tab art provider.
        """

        for nb in self._notebooks:
            nb.SetArtProvider(art.Clone())
            nb.Refresh()
            nb.Update()

        self._autoNBTabArt = art


    def GetAutoNotebookTabArt(self):
        """ Returns the default tab art provider for automatic notebooks. """

        return self._autoNBTabArt


    def SetAutoNotebookStyle(self, agwStyle):
        """
        Sets the default AGW-specific window style for automatic notebooks.

        :param integer `agwStyle`: the underlying :class:`~lib.agw.aui.auibook.AuiNotebook` window style.
         This can be a combination of the following bits:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet.
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet.
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close :class:`~lib.agw.aui.auibook.AuiNotebook` tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by :class:`AuiManager` to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less
                                              full screen, tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ``AUI_NB_ORDER_BY_ACCESS``           Tab navigation order by last access time for the tabs
         ``AUI_NB_NO_TAB_FOCUS``              Don't draw tab focus rectangle
         ==================================== ==================================

        """

        for nb in self._notebooks:
            nb.SetAGWWindowStyleFlag(agwStyle)
            nb.Refresh()
            nb.Update()

        self._autoNBStyle = agwStyle


    def GetAutoNotebookStyle(self):
        """
        Returns the default AGW-specific window style for automatic notebooks.

        :see: :meth:`SetAutoNotebookStyle` method for a list of possible styles.
        """

        return self._autoNBStyle


    def SavePaneInfo(self, pane):
        """
        This method is similar to :meth:`SavePerspective`, with the exception
        that it only saves information about a single pane. It is used in
        combination with :meth:`LoadPaneInfo`.

        :param `pane`: a :class:`AuiPaneInfo` instance to save.
        """

        result = "name=" + EscapeDelimiters(pane.name) + ";"
        result += "caption=" + EscapeDelimiters(pane.caption) + ";"

        result += "state=%u;"%pane.state
        result += "dir=%d;"%pane.dock_direction
        result += "layer=%d;"%pane.dock_layer
        result += "row=%d;"%pane.dock_row
        result += "pos=%d;"%pane.dock_pos
        result += "prop=%d;"%pane.dock_proportion
        result += "bestw=%d;"%pane.best_size.x
        result += "besth=%d;"%pane.best_size.y
        result += "minw=%d;"%pane.min_size.x
        result += "minh=%d;"%pane.min_size.y
        result += "maxw=%d;"%pane.max_size.x
        result += "maxh=%d;"%pane.max_size.y
        result += "floatx=%d;"%pane.floating_pos.x
        result += "floaty=%d;"%pane.floating_pos.y
        result += "floatw=%d;"%pane.floating_size.x
        result += "floath=%d;"%pane.floating_size.y
        result += "notebookid=%d;"%pane.notebook_id
        result += "transparent=%d"%pane.transparent

        return result


    def LoadPaneInfo(self, pane_part, pane):
        """
        This method is similar to to :meth:`LoadPerspective`, with the exception that
        it only loads information about a single pane. It is used in combination
        with :meth:`SavePaneInfo`.

        :param string `pane_part`: the string to analyze;
        :param `pane`: the :class:`AuiPaneInfo` structure in which to load `pane_part`.
        """

        # replace escaped characters so we can
        # split up the string easily
        pane_part = pane_part.replace("\\|", "\a")
        pane_part = pane_part.replace("\\;", "\b")

        options = pane_part.split(";")
        for items in options:

            val_name, value = items.split("=")
            val_name = val_name.strip()

            if val_name == "name":
                pane.name = value
            elif val_name == "caption":
                pane.caption = value
            elif val_name == "state":
                pane.state = int(value)
            elif val_name == "dir":
                pane.dock_direction = int(value)
            elif val_name == "layer":
                pane.dock_layer = int(value)
            elif val_name == "row":
                pane.dock_row = int(value)
            elif val_name == "pos":
                pane.dock_pos = int(value)
            elif val_name == "prop":
                pane.dock_proportion = int(value)
            elif val_name == "bestw":
                pane.best_size.x = int(value)
            elif val_name == "besth":
                pane.best_size.y = int(value)
                pane.best_size = wx.Size(pane.best_size.x, pane.best_size.y)
            elif val_name == "minw":
                pane.min_size.x = int(value)
            elif val_name == "minh":
                pane.min_size.y = int(value)
                pane.min_size = wx.Size(pane.min_size.x, pane.min_size.y)
            elif val_name == "maxw":
                pane.max_size.x = int(value)
            elif val_name == "maxh":
                pane.max_size.y = int(value)
                pane.max_size = wx.Size(pane.max_size.x, pane.max_size.y)
            elif val_name == "floatx":
                pane.floating_pos.x = int(value)
            elif val_name == "floaty":
                pane.floating_pos.y = int(value)
                pane.floating_pos = wx.Point(pane.floating_pos.x, pane.floating_pos.y)
            elif val_name == "floatw":
                pane.floating_size.x = int(value)
            elif val_name == "floath":
                pane.floating_size.y = int(value)
                pane.floating_size = wx.Size(pane.floating_size.x, pane.floating_size.y)
            elif val_name == "notebookid":
                pane.notebook_id = int(value)
            elif val_name == "transparent":
                pane.transparent = int(value)
            else:
                raise Exception("Bad perspective string")

        # replace escaped characters so we can
        # split up the string easily
        pane.name = pane.name.replace("\a", "|")
        pane.name = pane.name.replace("\b", ";")
        pane.caption = pane.caption.replace("\a", "|")
        pane.caption = pane.caption.replace("\b", ";")
        pane_part = pane_part.replace("\a", "|")
        pane_part = pane_part.replace("\b", ";")

        return pane


    def SavePerspective(self):
        """
        Saves the entire user interface layout into an encoded string, which can then
        be stored by the application (probably using :class:`Config`).

        When a perspective is restored using :meth:`LoadPerspective`, the entire user
        interface will return to the state it was when the perspective was saved.
        """

        result = "layout2|"

        for pane in self._panes:
            result += self.SavePaneInfo(pane) + "|"

        for dock in self._docks:
            result = result + ("dock_size(%d,%d,%d)=%d|")%(dock.dock_direction,
                                                           dock.dock_layer,
                                                           dock.dock_row,
                                                           dock.size)
        return result


    def LoadPerspective(self, layout, update=True, restorecaption=False):
        """
        Loads a layout which was saved with :meth:`SavePerspective`.

        If the `update` flag parameter is ``True``, :meth:`Update` will be
        automatically invoked, thus realizing the saved perspective on screen.

        :param string `layout`: a string which contains a saved AUI layout;
        :param bool `update`: whether to update immediately the window or not;
        :param bool `restorecaption`: ``False``, restore from persist storage,
         otherwise use the caption defined in code.
        """

        input = layout

        # check layout string version
        #    'layout1' = wxAUI 0.9.0 - wxAUI 0.9.2
        #    'layout2' = wxAUI 0.9.2 (wxWidgets 2.8)
        index = input.find("|")
        part = input[0:index].strip()
        input = input[index+1:]

        if part != "layout2":
            return False

        # mark all panes currently managed as docked and hidden
        saveCapt = {} # see restorecaption param
        for pane in self._panes:
            pane.Dock().Hide()
            saveCapt[pane.name] = pane.caption

        # clear out the dock array; this will be reconstructed
        self._docks = []

        # replace escaped characters so we can
        # split up the string easily
        input = input.replace("\\|", "\a")
        input = input.replace("\\;", "\b")

        while 1:

            pane = AuiPaneInfo()
            index = input.find("|")
            pane_part = input[0:index].strip()
            input = input[index+1:]

            # if the string is empty, we're done parsing
            if pane_part == "":
                break

            if pane_part[0:9] == "dock_size":
                index = pane_part.find("=")
                val_name = pane_part[0:index]
                value = pane_part[index+1:]

                index = val_name.find("(")
                piece = val_name[index+1:]
                index = piece.find(")")
                piece = piece[0:index]

                vals = piece.split(",")
                dir = int(vals[0])
                layer = int(vals[1])
                row = int(vals[2])
                size = int(value)

                dock = AuiDockInfo()
                dock.dock_direction = dir
                dock.dock_layer = layer
                dock.dock_row = row
                dock.size = size
                self._docks.append(dock)

                continue

            # Undo our escaping as LoadPaneInfo needs to take an unescaped
            # name so it can be called by external callers
            pane_part = pane_part.replace("\a", "|")
            pane_part = pane_part.replace("\b", ";")

            pane = self.LoadPaneInfo(pane_part, pane)

            p = self.GetPane(pane.name)
            # restore pane caption from code
            if restorecaption:
                if pane.name in saveCapt:
                    pane.Caption(saveCapt[pane.name])

            if not p.IsOk():
                if pane.IsNotebookControl():
                    # notebook controls - auto add...
                    self._panes.append(pane)
                    indx = self._panes.index(pane)
                else:
                    # the pane window couldn't be found
                    # in the existing layout -- skip it
                    continue

            else:
                indx = self._panes.index(p)
            pane.window = p.window
            pane.frame = p.frame
            pane.buttons = p.buttons
            self._panes[indx] = pane

            if isinstance(pane.window, auibar.AuiToolBar) and (pane.IsFloatable() or pane.IsDockable()):
                pane.window.SetGripperVisible(True)

        for p in self._panes:
            if p.IsMinimized():
                self.MinimizePane(p, False)

        if update:
            self.Update()

        return True


    def GetPanePositionsAndSizes(self, dock):
        """
        Returns all the panes positions and sizes in a dock.

        :param `dock`: a :class:`AuiDockInfo` instance.
        """

        caption_size = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        pane_border_size = self._art.GetMetric(AUI_DOCKART_PANE_BORDER_SIZE)
        gripper_size = self._art.GetMetric(AUI_DOCKART_GRIPPER_SIZE)

        positions = []
        sizes = []

        action_pane = -1
        pane_count = len(dock.panes)

        # find the pane marked as our action pane
        for pane_i in xrange(pane_count):
            pane = dock.panes[pane_i]
            if pane.HasFlag(AuiPaneInfo.actionPane):
                if action_pane != -1:
                    raise Exception("Too many action panes!")
                action_pane = pane_i

        # set up each panes default position, and
        # determine the size (width or height, depending
        # on the dock's orientation) of each pane
        for pane in dock.panes:
            positions.append(pane.dock_pos)
            size = 0

            if pane.HasBorder():
                size += pane_border_size*2

            if dock.IsHorizontal():
                if pane.HasGripper() and not pane.HasGripperTop():
                    size += gripper_size

                if pane.HasCaptionLeft():
                    size += caption_size

                size += pane.best_size.x

            else:
                if pane.HasGripper() and pane.HasGripperTop():
                    size += gripper_size

                if pane.HasCaption() and not pane.HasCaptionLeft():
                    size += caption_size

                size += pane.best_size.y

            sizes.append(size)

        # if there is no action pane, just return the default
        # positions (as specified in pane.pane_pos)
        if action_pane == -1:
            return positions, sizes

        offset = 0
        for pane_i in xrange(action_pane-1, -1, -1):
            amount = positions[pane_i+1] - (positions[pane_i] + sizes[pane_i])
            if amount >= 0:
                offset += amount
            else:
                positions[pane_i] -= -amount

            offset += sizes[pane_i]

        # if the dock mode is fixed, make sure none of the panes
        # overlap we will bump panes that overlap
        offset = 0
        for pane_i in xrange(action_pane, pane_count):
            amount = positions[pane_i] - offset
            if amount >= 0:
                offset += amount
            else:
                positions[pane_i] += -amount

            offset += sizes[pane_i]

        return positions, sizes


    def LayoutAddPane(self, cont, dock, pane, uiparts, spacer_only):
        """
        Adds a pane into the existing layout (in an existing dock).

        :param `cont`: a :class:`Sizer` object;
        :param `dock`: the :class:`AuiDockInfo` structure in which to add the pane;
        :param `pane`: the :class:`AuiPaneInfo` instance to add to the dock;
        :param `uiparts`: a list of UI parts in the interface;
        :param bool `spacer_only`: whether to add a simple spacer or a real window.
        """

        sizer_item = wx.SizerItem()
        caption_size = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        gripper_size = self._art.GetMetric(AUI_DOCKART_GRIPPER_SIZE)
        pane_border_size = self._art.GetMetric(AUI_DOCKART_PANE_BORDER_SIZE)
        pane_button_size = self._art.GetMetric(AUI_DOCKART_PANE_BUTTON_SIZE)

        # find out the orientation of the item (orientation for panes
        # is the same as the dock's orientation)

        if dock.IsHorizontal():
            orientation = wx.HORIZONTAL
        else:
            orientation = wx.VERTICAL

        # this variable will store the proportion
        # value that the pane will receive
        pane_proportion = pane.dock_proportion

        horz_pane_sizer = wx.BoxSizer(wx.HORIZONTAL)
        vert_pane_sizer = wx.BoxSizer(wx.VERTICAL)

        if pane.HasGripper():

            part = AuiDockUIPart()
            if pane.HasGripperTop():
                sizer_item = vert_pane_sizer.Add((1, gripper_size), 0, wx.EXPAND)
            else:
                sizer_item = horz_pane_sizer.Add((gripper_size, 1), 0, wx.EXPAND)

            part.type = AuiDockUIPart.typeGripper
            part.dock = dock
            part.pane = pane
            part.button = None
            part.orientation = orientation
            part.cont_sizer = horz_pane_sizer
            part.sizer_item = sizer_item
            uiparts.append(part)

        button_count = len(pane.buttons)
        button_width_total = button_count*pane_button_size
        if button_count >= 1:
            button_width_total += 3

        caption, captionLeft = pane.HasCaption(), pane.HasCaptionLeft()
        button_count = len(pane.buttons)

        if captionLeft:
            caption_sizer = wx.BoxSizer(wx.VERTICAL)

            # add pane buttons to the caption
            dummy_parts = []
            for btn_id in xrange(len(pane.buttons)-1, -1, -1):
                sizer_item = caption_sizer.Add((caption_size, pane_button_size), 0, wx.EXPAND)
                part = AuiDockUIPart()
                part.type = AuiDockUIPart.typePaneButton
                part.dock = dock
                part.pane = pane
                part.button = pane.buttons[btn_id]
                part.orientation = orientation
                part.cont_sizer = caption_sizer
                part.sizer_item = sizer_item
                dummy_parts.append(part)

            sizer_item = caption_sizer.Add((caption_size, 1), 1, wx.EXPAND)
            vert_pane_sizer = wx.BoxSizer(wx.HORIZONTAL)

            # create the caption sizer
            part = AuiDockUIPart()

            part.type = AuiDockUIPart.typeCaption
            part.dock = dock
            part.pane = pane
            part.button = None
            part.orientation = orientation
            part.cont_sizer = vert_pane_sizer
            part.sizer_item = sizer_item
            caption_part_idx = len(uiparts)
            uiparts.append(part)
            uiparts.extend(dummy_parts)

        elif caption:

            caption_sizer = wx.BoxSizer(wx.HORIZONTAL)
            sizer_item = caption_sizer.Add((1, caption_size), 1, wx.EXPAND)

            # create the caption sizer
            part = AuiDockUIPart()

            part.type = AuiDockUIPart.typeCaption
            part.dock = dock
            part.pane = pane
            part.button = None
            part.orientation = orientation
            part.cont_sizer = vert_pane_sizer
            part.sizer_item = sizer_item
            caption_part_idx = len(uiparts)
            uiparts.append(part)

            # add pane buttons to the caption
            for button in pane.buttons:
                sizer_item = caption_sizer.Add((pane_button_size, caption_size), 0, wx.EXPAND)
                part = AuiDockUIPart()
                part.type = AuiDockUIPart.typePaneButton
                part.dock = dock
                part.pane = pane
                part.button = button
                part.orientation = orientation
                part.cont_sizer = caption_sizer
                part.sizer_item = sizer_item
                uiparts.append(part)

        if caption or captionLeft:
            # if we have buttons, add a little space to the right
            # of them to ease visual crowding
            if button_count >= 1:
                if captionLeft:
                    caption_sizer.Add((caption_size, 3), 0, wx.EXPAND)
                else:
                    caption_sizer.Add((3, caption_size), 0, wx.EXPAND)

            # add the caption sizer
            sizer_item = vert_pane_sizer.Add(caption_sizer, 0, wx.EXPAND)
            uiparts[caption_part_idx].sizer_item = sizer_item

        # add the pane window itself
        if spacer_only or not pane.window:
            sizer_item = vert_pane_sizer.Add((1, 1), 1, wx.EXPAND)
        else:
            sizer_item = vert_pane_sizer.Add(pane.window, 1, wx.EXPAND)
            vert_pane_sizer.SetItemMinSize(pane.window, (1, 1))

        part = AuiDockUIPart()
        part.type = AuiDockUIPart.typePane
        part.dock = dock
        part.pane = pane
        part.button = None
        part.orientation = orientation
        part.cont_sizer = vert_pane_sizer
        part.sizer_item = sizer_item
        uiparts.append(part)

        # determine if the pane should have a minimum size if the pane is
        # non-resizable (fixed) then we must set a minimum size. Alternatively,
        # if the pane.min_size is set, we must use that value as well

        min_size = pane.min_size
        if pane.IsFixed():
            if min_size == wx.Size(-1, -1):
                min_size = pane.best_size
                pane_proportion = 0

        if min_size != wx.Size(-1, -1):
            vert_pane_sizer.SetItemMinSize(len(vert_pane_sizer.GetChildren())-1, (min_size.x, min_size.y))

        # add the vertical/horizontal sizer (caption, pane window) to the
        # horizontal sizer (gripper, vertical sizer)
        horz_pane_sizer.Add(vert_pane_sizer, 1, wx.EXPAND)

        # finally, add the pane sizer to the dock sizer
        if pane.HasBorder():
            # allowing space for the pane's border
            sizer_item = cont.Add(horz_pane_sizer, pane_proportion,
                                  wx.EXPAND | wx.ALL, pane_border_size)
            part = AuiDockUIPart()
            part.type = AuiDockUIPart.typePaneBorder
            part.dock = dock
            part.pane = pane
            part.button = None
            part.orientation = orientation
            part.cont_sizer = cont
            part.sizer_item = sizer_item
            uiparts.append(part)
        else:
            sizer_item = cont.Add(horz_pane_sizer, pane_proportion, wx.EXPAND)

        return uiparts


    def LayoutAddDock(self, cont, dock, uiparts, spacer_only):
        """
        Adds a dock into the existing layout.

        :param `cont`: a :class:`Sizer` object;
        :param `dock`: the :class:`AuiDockInfo` structure to add to the layout;
        :param `uiparts`: a list of UI parts in the interface;
        :param bool `spacer_only`: whether to add a simple spacer or a real window.
        """

        sizer_item = wx.SizerItem()
        part = AuiDockUIPart()

        sash_size = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)

        # WHAT IS THIS?! I DON'T EVEN...
        #orientation = (dock.IsHorizontal() and [wx.HORIZONTAL] or [wx.VERTICAL])[0]
        orientation = wx.HORIZONTAL if dock.IsHorizontal() else wx.VERTICAL

        # resizable bottom and right docks have a sash before them
        if not self._has_maximized and not dock.fixed and \
           dock.dock_direction in [AUI_DOCK_BOTTOM, AUI_DOCK_RIGHT]:

            sizer_item = cont.Add((sash_size, sash_size), 0, wx.EXPAND)

            part.type = AuiDockUIPart.typeDockSizer
            part.orientation = orientation
            part.dock = dock
            part.pane = None
            part.button = None
            part.cont_sizer = cont
            part.sizer_item = sizer_item
            uiparts.append(part)

        # create the sizer for the dock
        dock_sizer = wx.BoxSizer(orientation)

        # add each pane to the dock
        has_maximized_pane = False
        pane_count = len(dock.panes)

        if dock.fixed:

            # figure out the real pane positions we will
            # use, without modifying the each pane's pane_pos member
            pane_positions, pane_sizes = self.GetPanePositionsAndSizes(dock)

            offset = 0
            for pane_i in xrange(pane_count):

                pane = dock.panes[pane_i]
                pane_pos = pane_positions[pane_i]

                if pane.IsMaximized():
                    has_maximized_pane = True

                amount = pane_pos - offset
                if amount > 0:

                    if dock.IsVertical():
                        sizer_item = dock_sizer.Add((1, amount), 0, wx.EXPAND)
                    else:
                        sizer_item = dock_sizer.Add((amount, 1), 0, wx.EXPAND)

                    part = AuiDockUIPart()
                    part.type = AuiDockUIPart.typeBackground
                    part.dock = dock
                    part.pane = None
                    part.button = None
                    part.orientation = (orientation==wx.HORIZONTAL and \
                                        [wx.VERTICAL] or [wx.HORIZONTAL])[0]
                    part.cont_sizer = dock_sizer
                    part.sizer_item = sizer_item
                    uiparts.append(part)

                    offset = offset + amount

                uiparts = self.LayoutAddPane(dock_sizer, dock, pane, uiparts, spacer_only)

                offset = offset + pane_sizes[pane_i]

            # at the end add a very small stretchable background area
            sizer_item = dock_sizer.Add((0, 0), 1, wx.EXPAND)
            part = AuiDockUIPart()
            part.type = AuiDockUIPart.typeBackground
            part.dock = dock
            part.pane = None
            part.button = None
            part.orientation = orientation
            part.cont_sizer = dock_sizer
            part.sizer_item = sizer_item
            uiparts.append(part)

        else:

            for pane_i in xrange(pane_count):

                pane = dock.panes[pane_i]

                if pane.IsMaximized():
                    has_maximized_pane = True

                # if this is not the first pane being added,
                # we need to add a pane sizer
                if not self._has_maximized and pane_i > 0:
                    sizer_item = dock_sizer.Add((sash_size, sash_size), 0, wx.EXPAND)
                    part = AuiDockUIPart()
                    part.type = AuiDockUIPart.typePaneSizer
                    part.dock = dock
                    part.pane = dock.panes[pane_i-1]
                    part.button = None
                    part.orientation = (orientation==wx.HORIZONTAL and \
                                        [wx.VERTICAL] or [wx.HORIZONTAL])[0]
                    part.cont_sizer = dock_sizer
                    part.sizer_item = sizer_item
                    uiparts.append(part)

                uiparts = self.LayoutAddPane(dock_sizer, dock, pane, uiparts, spacer_only)

        if dock.dock_direction == AUI_DOCK_CENTER or has_maximized_pane:
            sizer_item = cont.Add(dock_sizer, 1, wx.EXPAND)
        else:
            sizer_item = cont.Add(dock_sizer, 0, wx.EXPAND)

        part = AuiDockUIPart()
        part.type = AuiDockUIPart.typeDock
        part.dock = dock
        part.pane = None
        part.button = None
        part.orientation = orientation
        part.cont_sizer = cont
        part.sizer_item = sizer_item
        uiparts.append(part)

        if dock.IsHorizontal():
            cont.SetItemMinSize(dock_sizer, (0, dock.size))
        else:
            cont.SetItemMinSize(dock_sizer, (dock.size, 0))

        #  top and left docks have a sash after them
        if not self._has_maximized and not dock.fixed and \
           dock.dock_direction in [AUI_DOCK_TOP, AUI_DOCK_LEFT]:

            sizer_item = cont.Add((sash_size, sash_size), 0, wx.EXPAND)

            part = AuiDockUIPart()
            part.type = AuiDockUIPart.typeDockSizer
            part.dock = dock
            part.pane = None
            part.button = None
            part.orientation = orientation
            part.cont_sizer = cont
            part.sizer_item = sizer_item
            uiparts.append(part)

        return uiparts


    def LayoutAll(self, panes, docks, uiparts, spacer_only=False, oncheck=True):
        """
        Layouts all the UI structures in the interface.

        :param `panes`: a list of :class:`AuiPaneInfo` instances;
        :param `docks`: a list of :class:`AuiDockInfo` classes;
        :param `uiparts`: a list of UI parts in the interface;
        :param bool `spacer_only`: whether to add a simple spacer or a real window;
        :param bool `oncheck`: whether to store the results in a class member or not.
        """
        container = wx.BoxSizer(wx.VERTICAL)

        pane_border_size = self._art.GetMetric(AUI_DOCKART_PANE_BORDER_SIZE)
        caption_size = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        cli_size = self._frame.GetClientSize()

        # empty all docks out
        for dock in docks:
            dock.panes = []
            if dock.fixed:
                # always reset fixed docks' sizes, because
                # the contained windows may have been resized
                dock.size = 0

        dock_count = len(docks)

        # iterate through all known panes, filing each
        # of them into the appropriate dock. If the
        # pane does not exist in the dock, add it
        for p in panes:

            # don't layout hidden panes.
            if p.IsShown():

                # find any docks with the same dock direction, dock layer, and
                # dock row as the pane we are working on
                arr = FindDocks(docks, p.dock_direction, p.dock_layer, p.dock_row)

                if arr:
                    dock = arr[0]

                else:
                    # dock was not found, so we need to create a new one
                    d = AuiDockInfo()
                    d.dock_direction = p.dock_direction
                    d.dock_layer = p.dock_layer
                    d.dock_row = p.dock_row
                    docks.append(d)
                    dock = docks[-1]

                    if p.HasFlag(p.needsRestore) and not p.HasFlag(p.wasMaximized):

                        isHor = dock.IsHorizontal()
                        sashSize = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)

                        # get the sizes of any docks that might
                        # overlap with our restored dock

                        # make list of widths or heights from the size in the dock rects
                        sizes = [d.rect[2:][isHor] for \
                                 d in docks if d.IsOk() and \
                                 (d.IsHorizontal() == isHor) and \
                                 not d.toolbar and \
                                 d.dock_direction != AUI_DOCK_CENTER]

                        frameRect = GetInternalFrameRect(self._frame, self._docks)

                        # set max size allowing for sashes and absolute minimum
                        maxsize = frameRect[2:][isHor] - sum(sizes) - (len(sizes)*10) - (sashSize*len(sizes))
                        dock.size = min(p.previousDockSize,maxsize)

                    else:
                        dock.size = 0

                if p.HasFlag(p.wasMaximized):
                    self.MaximizePane(p, savesizes=False)
                    p.SetFlag(p.wasMaximized, False)

                if p.HasFlag(p.needsRestore):
                    if p.previousDockPos is not None:
                        DoInsertPane(dock.panes, dock.dock_direction, dock.dock_layer, dock.dock_row, p.previousDockPos)
                        p.dock_pos = p.previousDockPos
                        p.previousDockPos = None
                    p.SetFlag(p.needsRestore, False)

                if p.IsDocked():
                    # remove the pane from any existing docks except this one
                    docks = RemovePaneFromDocks(docks, p, dock)

                    # pane needs to be added to the dock,
                    # if it doesn't already exist
                    if not FindPaneInDock(dock, p.window):
                        dock.panes.append(p)
                else:
                    # remove the pane from any existing docks
                    docks = RemovePaneFromDocks(docks, p)

        # remove any empty docks
        docks = [dock for dock in docks if dock.panes]

        dock_count = len(docks)
        # configure the docks further
        for ii, dock in enumerate(docks):
            # sort the dock pane array by the pane's
            # dock position (dock_pos), in ascending order
            dock.panes.sort(PaneSortFunc)
            dock_pane_count = len(dock.panes)

            # for newly created docks, set up their initial size
            if dock.size == 0:
                size = 0
                for pane in dock.panes:
                    pane_size = pane.best_size
                    if pane_size == wx.Size(-1, -1):
                        pane_size = pane.min_size
                    if pane_size == wx.Size(-1, -1) and pane.window:
                        pane_size = pane.window.GetSize()
                    if dock.IsHorizontal():
                        size = max(pane_size.y, size)
                    else:
                        size = max(pane_size.x, size)

                # add space for the border (two times), but only
                # if at least one pane inside the dock has a pane border
                for pane in dock.panes:
                    if pane.HasBorder():
                        size = size + pane_border_size*2
                        break

                # if pane is on the top or bottom, add the caption height,
                # but only if at least one pane inside the dock has a caption
                if dock.IsHorizontal():
                    for pane in dock.panes:
                        if pane.HasCaption() and not pane.HasCaptionLeft():
                            size = size + caption_size
                            break
                else:
                    for pane in dock.panes:
                        if pane.HasCaptionLeft() and not pane.HasCaption():
                            size = size + caption_size
                            break

                # new dock's size may not be more than the dock constraint
                # parameter specifies.  See SetDockSizeConstraint()
                max_dock_x_size = int(self._dock_constraint_x*float(cli_size.x))
                max_dock_y_size = int(self._dock_constraint_y*float(cli_size.y))
                if cli_size <= wx.Size(20, 20):
                    max_dock_x_size = 10000
                    max_dock_y_size = 10000

                if dock.IsHorizontal():
                    size = min(size, max_dock_y_size)
                else:
                    size = min(size, max_dock_x_size)

                # absolute minimum size for a dock is 10 pixels
                if size < 10:
                    size = 10

                dock.size = size

            # determine the dock's minimum size
            plus_border = False
            plus_caption = False
            plus_caption_left = False
            dock_min_size = 0
            for pane in dock.panes:
                if pane.min_size != wx.Size(-1, -1):
                    if pane.HasBorder():
                        plus_border = True
                    if pane.HasCaption():
                        plus_caption = True
                    if pane.HasCaptionLeft():
                        plus_caption_left = True
                    if dock.IsHorizontal():
                        if pane.min_size.y > dock_min_size:
                            dock_min_size = pane.min_size.y
                    else:
                        if pane.min_size.x > dock_min_size:
                            dock_min_size = pane.min_size.x

            if plus_border:
                dock_min_size += pane_border_size*2
            if plus_caption and dock.IsHorizontal():
                dock_min_size += caption_size
            if plus_caption_left and dock.IsVertical():
                dock_min_size += caption_size

            dock.min_size = dock_min_size

            # if the pane's current size is less than it's
            # minimum, increase the dock's size to it's minimum
            if dock.size < dock.min_size:
                dock.size = dock.min_size

            # determine the dock's mode (fixed or proportional)
            # determine whether the dock has only toolbars
            action_pane_marked = False
            dock.fixed = True
            dock.toolbar = True
            for pane in dock.panes:
                if not pane.IsFixed():
                    dock.fixed = False
                if not pane.IsToolbar():
                    dock.toolbar = False
                if pane.HasFlag(AuiPaneInfo.optionDockFixed):
                    dock.fixed = True
                if pane.HasFlag(AuiPaneInfo.actionPane):
                    action_pane_marked = True

            # if the dock mode is proportional and not fixed-pixel,
            # reassign the dock_pos to the sequential 0, 1, 2, 3
            # e.g. remove gaps like 1, 2, 30, 500
            if not dock.fixed:
                for jj in xrange(dock_pane_count):
                    pane = dock.panes[jj]
                    pane.dock_pos = jj

            # if the dock mode is fixed, and none of the panes
            # are being moved right now, make sure the panes
            # do not overlap each other.  If they do, we will
            # adjust the panes' positions
            if dock.fixed and not action_pane_marked:
                pane_positions, pane_sizes = self.GetPanePositionsAndSizes(dock)
                offset = 0
                for jj in xrange(dock_pane_count):
                    pane = dock.panes[jj]
                    pane.dock_pos = pane_positions[jj]
                    amount = pane.dock_pos - offset
                    if amount >= 0:
                        offset += amount
                    else:
                        pane.dock_pos += -amount

                    offset += pane_sizes[jj]
                    dock.panes[jj] = pane

            if oncheck:
                self._docks[ii] = dock

        # shrink docks if needed
##        docks = self.SmartShrink(docks, AUI_DOCK_TOP)
##        docks = self.SmartShrink(docks, AUI_DOCK_LEFT)

        if oncheck:
            self._docks = docks

        # discover the maximum dock layer
        max_layer = 0
        dock_count = len(docks)

        for ii in xrange(dock_count):
            max_layer = max(max_layer, docks[ii].dock_layer)

        # clear out uiparts
        uiparts = []

        # create a bunch of box sizers,
        # from the innermost level outwards.
        cont = None
        middle = None

        if oncheck:
            docks = self._docks

        for layer in xrange(max_layer+1):
            # find any docks in this layer
            arr = FindDocks(docks, -1, layer, -1)
            # if there aren't any, skip to the next layer
            if not arr:
                continue

            old_cont = cont

            # create a container which will hold this layer's
            # docks (top, bottom, left, right)
            cont = wx.BoxSizer(wx.VERTICAL)

            # find any top docks in this layer
            arr = FindDocks(docks, AUI_DOCK_TOP, layer, -1)
            for row in arr:
                uiparts = self.LayoutAddDock(cont, row, uiparts, spacer_only)

            # fill out the middle layer (which consists
            # of left docks, content area and right docks)

            middle = wx.BoxSizer(wx.HORIZONTAL)

            # find any left docks in this layer
            arr = FindDocks(docks, AUI_DOCK_LEFT, layer, -1)
            for row in arr:
                uiparts = self.LayoutAddDock(middle, row, uiparts, spacer_only)

            # add content dock (or previous layer's sizer
            # to the middle
            if not old_cont:
                # find any center docks
                arr = FindDocks(docks, AUI_DOCK_CENTER, -1, -1)
                if arr:
                    for row in arr:
                       uiparts = self.LayoutAddDock(middle, row, uiparts, spacer_only)

                elif not self._has_maximized:
                    # there are no center docks, add a background area
                    sizer_item = middle.Add((1, 1), 1, wx.EXPAND)
                    part = AuiDockUIPart()
                    part.type = AuiDockUIPart.typeBackground
                    part.pane = None
                    part.dock = None
                    part.button = None
                    part.cont_sizer = middle
                    part.sizer_item = sizer_item
                    uiparts.append(part)
            else:
                middle.Add(old_cont, 1, wx.EXPAND)

            # find any right docks in this layer
            arr = FindDocks(docks, AUI_DOCK_RIGHT, layer, -1, reverse=True)
            for row in arr:
                uiparts = self.LayoutAddDock(middle, row, uiparts, spacer_only)

            if len(middle.GetChildren()) > 0:
                cont.Add(middle, 1, wx.EXPAND)

            # find any bottom docks in this layer
            arr = FindDocks(docks, AUI_DOCK_BOTTOM, layer, -1, reverse=True)
            for row in arr:
                    uiparts = self.LayoutAddDock(cont, row, uiparts, spacer_only)

        if not cont:
            # no sizer available, because there are no docks,
            # therefore we will create a simple background area
            cont = wx.BoxSizer(wx.VERTICAL)
            sizer_item = cont.Add((1, 1), 1, wx.EXPAND)
            part = AuiDockUIPart()
            part.type = AuiDockUIPart.typeBackground
            part.pane = None
            part.dock = None
            part.button = None
            part.cont_sizer = middle
            part.sizer_item = sizer_item
            uiparts.append(part)

        if oncheck:
            self._uiparts = uiparts
            self._docks = docks

        container.Add(cont, 1, wx.EXPAND)

        if oncheck:
            return container
        else:
            return container, panes, docks, uiparts


    def SetDockSizeConstraint(self, width_pct, height_pct):
        """
        When a user creates a new dock by dragging a window into a docked position,
        often times the large size of the window will create a dock that is unwieldly
        large.

        :class:`AuiManager` by default limits the size of any new dock to 1/3 of the window
        size. For horizontal docks, this would be 1/3 of the window height. For vertical
        docks, 1/3 of the width. Calling this function will adjust this constraint value.

        The numbers must be between 0.0 and 1.0. For instance, calling :meth:`SetDockSizeConstraint`
        with (0.5, 0.5) will cause new docks to be limited to half of the size of the entire
        managed window.

        :param float `width_pct`: a number representing the `x` dock size constraint;
        :param float `width_pct`: a number representing the `y` dock size constraint.
        """

        self._dock_constraint_x = max(0.0, min(1.0, width_pct))
        self._dock_constraint_y = max(0.0, min(1.0, height_pct))


    def GetDockSizeConstraint(self):
        """
        Returns the current dock constraint values.

        :see: :meth:`SetDockSizeConstraint`
        """

        return self._dock_constraint_x, self._dock_constraint_y


    def Update(self):
        """
        This method is called after any number of changes are made to any of the
        managed panes. :meth:`Update` must be invoked after :meth:`AddPane`
        or :meth:`InsertPane` are called in order to "realize" or "commit" the changes.

        In addition, any number of changes may be made to :class:`AuiManager` structures
        (retrieved with :meth:`GetPane`), but to realize the changes, :meth:`Update`
        must be called. This construction allows pane flicker to be avoided by updating
        the whole layout at one time.
        """
        self._hover_button = None
        self._action_part = None

        # destroy floating panes which have been
        # redocked or are becoming non-floating
        for p in self._panes:
            if p.IsFloating() or not p.frame:
                continue

            # because the pane is no longer in a floating, we need to
            # reparent it to self._frame and destroy the floating frame
            # reduce flicker
            p.window.SetSize((1, 1))

            # the following block is a workaround for bug #1531361
            # (see wxWidgets sourceforge page).  On wxGTK (only), when
            # a frame is shown/hidden, a move event unfortunately
            # also gets fired.  Because we may be dragging around
            # a pane, we need to cancel that action here to prevent
            # a spurious crash.
            if self._action_window == p.frame:
                if self._frame.HasCapture():
                    self._frame.ReleaseMouse()
                self._action = actionNone
                self._action_window = None

            # hide the frame
            if p.frame.IsShown():
                p.frame.Show(False)

            if self._action_window == p.frame:
                self._action_window = None

            # reparent to self._frame and destroy the pane
            p.window.Reparent(self._frame)
            if isinstance(p.window, auibar.AuiToolBar):
                p.window.SetAuiManager(self)

            if p.frame:
                p.frame.SetSizer(None)
                p.frame.Destroy()
            p.frame = None

        # Only the master manager should create/destroy notebooks...
        if not self._masterManager:
            self.UpdateNotebook()

        # delete old sizer first
        self._frame.SetSizer(None)

        # create a layout for all of the panes
        sizer = self.LayoutAll(self._panes, self._docks, self._uiparts, False)

        # hide or show panes as necessary,
        # and float panes as necessary

        pane_count = len(self._panes)

        for ii in xrange(pane_count):
            p = self._panes[ii]
            pFrame = p.frame
            if p.IsFloating():
                if pFrame is None:
                    # we need to create a frame for this
                    # pane, which has recently been floated
                    frame = self.CreateFloatingFrame(self._frame, p)

                    # on MSW and Mac, if the owner desires transparent dragging, and
                    # the dragging is happening right now, then the floating
                    # window should have this style by default
                    if self._action in [actionDragFloatingPane, actionDragToolbarPane] and \
                       self._agwFlags & AUI_MGR_TRANSPARENT_DRAG:
                        frame.SetTransparent(150)

                    if p.IsToolbar():
                        bar = p.window
                        if isinstance(bar, auibar.AuiToolBar):
                            bar.SetGripperVisible(False)
                            agwStyle = bar.GetAGWWindowStyleFlag()
                            bar.SetAGWWindowStyleFlag(agwStyle & ~AUI_TB_VERTICAL)
                            bar.Realize()

                        s = p.window.GetMinSize()
                        p.BestSize(s)
                        p.FloatingSize(wx.DefaultSize)

                    frame.SetPaneWindow(p)
                    p.needsTransparency = True
                    p.frame = pFrame = frame
                    if p.IsShown() and not frame.IsShown():
                        frame.Show()
                        frame.Update()
                else:

                    # frame already exists, make sure it's position
                    # and size reflect the information in AuiPaneInfo
                    if pFrame.GetPosition() != p.floating_pos or pFrame.GetSize() != p.floating_size:
                        pFrame.SetDimensions(p.floating_pos.x, p.floating_pos.y,
                                             p.floating_size.x, p.floating_size.y, wx.SIZE_USE_EXISTING)

                    # update whether the pane is resizable or not
                    style = p.frame.GetWindowStyleFlag()
                    if p.IsFixed():
                        style &= ~wx.RESIZE_BORDER
                    else:
                        style |= wx.RESIZE_BORDER

                    # update the close button
                    if p.HasCloseButton():
                       style |= wx.CLOSE_BOX
                       if wx.Platform == '__WXMSW__':
                           style |= wx.SYSTEM_MENU
                    else:
                       style &= ~wx.CLOSE_BOX
                       if wx.Platform == '__WXMSW__':
                           style &= ~wx.SYSTEM_MENU

                    p.frame.SetWindowStyleFlag(style)

                    if pFrame.IsShown() != p.IsShown():
                        p.needsTransparency = True
                        pFrame.Show(p.IsShown())

                if pFrame.GetTitle() != p.caption:
                    pFrame.SetTitle(p.caption)
                if p.icon.IsOk():
                    pFrame.SetIcon(wx.IconFromBitmap(p.icon))

            else:

                if p.IsToolbar():
                    #self.SwitchToolBarOrientation(p)
                    p.best_size = p.window.GetBestSize()

                if p.window and not p.IsNotebookPage() and p.window.IsShown() != p.IsShown():
                    p.window.Show(p.IsShown())

            if pFrame and p.needsTransparency:
                if pFrame.IsShown() and pFrame._transparent != p.transparent:
                    pFrame.SetTransparent(p.transparent)
                    pFrame._transparent = p.transparent

                p.needsTransparency = False

            # if "active panes" are no longer allowed, clear
            # any optionActive values from the pane states
            if self._agwFlags & AUI_MGR_ALLOW_ACTIVE_PANE == 0:
                p.state &= ~AuiPaneInfo.optionActive

            self._panes[ii] = p

        old_pane_rects = []
        pane_count = len(self._panes)

        for p in self._panes:
            r = wx.Rect()
            if p.window and p.IsShown() and p.IsDocked():
                r = p.rect

            old_pane_rects.append(r)

        # apply the new sizer
        self._frame.SetSizer(sizer)
        self._frame.SetAutoLayout(False)
        self.DoFrameLayout()

        # now that the frame layout is done, we need to check
        # the new pane rectangles against the old rectangles that
        # we saved a few lines above here.  If the rectangles have
        # changed, the corresponding panes must also be updated
        for ii in xrange(pane_count):
            p = self._panes[ii]
            if p.window and p.IsShown() and p.IsDocked():
                if p.rect != old_pane_rects[ii]:
                    p.window.Refresh()
                    p.window.Update()

        if wx.Platform == "__WXMAC__":
            self._frame.Refresh()
        else:
            self.Repaint()

        if not self._masterManager:
            e = self.FireEvent(wxEVT_AUI_PERSPECTIVE_CHANGED, None, canVeto=False)


    def UpdateNotebook(self):
        """ Updates the automatic :class:`~lib.agw.aui.auibook.AuiNotebook` in the layout (if any exists). """

        # Workout how many notebooks we need.
        max_notebook = -1

        # destroy floating panes which have been
        # redocked or are becoming non-floating
        for paneInfo in self._panes:
            if max_notebook < paneInfo.notebook_id:
                max_notebook = paneInfo.notebook_id

        # We are the master of our domain
        extra_notebook = len(self._notebooks)
        max_notebook += 1

        for i in xrange(extra_notebook, max_notebook):
            self.CreateNotebook()

        # Remove pages from notebooks that no-longer belong there ...
        for nb, notebook in enumerate(self._notebooks):
            pages = notebook.GetPageCount()
            pageCounter, allPages = 0, pages

            # Check each tab ...
            for page in xrange(pages):

                if page >= allPages:
                    break

                window = notebook.GetPage(pageCounter)
                paneInfo = self.GetPane(window)
                if paneInfo.IsOk() and paneInfo.notebook_id != nb:
                    notebook.RemovePage(pageCounter)
                    window.Hide()
                    window.Reparent(self._frame)
                    pageCounter -= 1
                    allPages -= 1

                pageCounter += 1

            notebook.DoSizing()

        # Add notebook pages that aren't there already...
        for paneInfo in self._panes:
            if paneInfo.IsNotebookPage():

                title = (paneInfo.caption == "" and [paneInfo.name] or [paneInfo.caption])[0]

                notebook = self._notebooks[paneInfo.notebook_id]
                page_id = notebook.GetPageIndex(paneInfo.window)

                if page_id < 0:

                    paneInfo.window.Reparent(notebook)
                    notebook.AddPage(paneInfo.window, title, True, paneInfo.icon)

                # Update title and icon ...
                else:

                    notebook.SetPageText(page_id, title)
                    notebook.SetPageBitmap(page_id, paneInfo.icon)

                notebook.DoSizing()

            # Wire-up newly created notebooks
            elif paneInfo.IsNotebookControl() and not paneInfo.window:
                paneInfo.window = self._notebooks[paneInfo.notebook_id]

        # Delete empty notebooks, and convert notebooks with 1 page to
        # normal panes...
        remap_ids = [-1]*len(self._notebooks)
        nb_idx = 0

        for nb, notebook in enumerate(self._notebooks):
            if notebook.GetPageCount() == 1:

                # Convert notebook page to pane...
                window = notebook.GetPage(0)
                child_pane = self.GetPane(window)
                notebook_pane = self.GetPane(notebook)
                if child_pane.IsOk() and notebook_pane.IsOk():

                    child_pane.SetDockPos(notebook_pane)
                    child_pane.window.Hide()
                    child_pane.window.Reparent(self._frame)
                    child_pane.frame = None
                    child_pane.notebook_id = -1
                    if notebook_pane.IsFloating():
                        child_pane.Float()

                    self.DetachPane(notebook)

                    notebook.RemovePage(0)
                    notebook.Destroy()

                else:

                    raise Exception("Odd notebook docking")

            elif notebook.GetPageCount() == 0:

                self.DetachPane(notebook)
                notebook.Destroy()

            else:

                # Correct page ordering. The original wxPython code
                # for this did not work properly, and would misplace
                # windows causing errors.
                notebook.Freeze()
                self._notebooks[nb_idx] = notebook
                pages = notebook.GetPageCount()
                selected = notebook.GetPage(notebook.GetSelection())

                # Take each page out of the notebook, group it with
                # its current pane, and sort the list by pane.dock_pos
                # order
                pages_and_panes = []
                for idx in reversed(range(pages)):
                    page = notebook.GetPage(idx)
                    pane = self.GetPane(page)
                    pages_and_panes.append((page, pane))
                    notebook.RemovePage(idx)
                sorted_pnp = sorted(pages_and_panes, key=lambda tup: tup[1].dock_pos)

                # Grab the attributes from the panes which are ordered
                # correctly, and copy those attributes to the original
                # panes. (This avoids having to change the ordering
                # of self._panes) Then, add the page back into the notebook
                sorted_attributes = [self.GetAttributes(tup[1])
                                     for tup in sorted_pnp]
                for attrs, tup in zip(sorted_attributes, pages_and_panes):
                    pane = tup[1]
                    self.SetAttributes(pane, attrs)
                    notebook.AddPage(pane.window, pane.caption)

                notebook.SetSelection(notebook.GetPageIndex(selected), True)
                notebook.DoSizing()
                notebook.Thaw()

                # It's a keeper.
                remap_ids[nb] = nb_idx
                nb_idx += 1

        # Apply remap...
        nb_count = len(self._notebooks)

        if nb_count != nb_idx:

            self._notebooks = self._notebooks[0:nb_idx]
            for p in self._panes:
                if p.notebook_id >= 0:
                    p.notebook_id = remap_ids[p.notebook_id]
                    if p.IsNotebookControl():
                        p.SetNameFromNotebookId()

        # Make sure buttons are correct ...
        for notebook in self._notebooks:
            want_max = True
            want_min = True
            want_close = True

            pages = notebook.GetPageCount()
            for page in xrange(pages):

                win = notebook.GetPage(page)
                pane = self.GetPane(win)
                if pane.IsOk():

                    if not pane.HasCloseButton():
                        want_close = False
                    if not pane.HasMaximizeButton():
                        want_max = False
                    if not pane.HasMinimizeButton():
                        want_min = False

            notebook_pane = self.GetPane(notebook)
            if notebook_pane.IsOk():
                if notebook_pane.HasMinimizeButton() != want_min:
                    if want_min:
                        button = AuiPaneButton(AUI_BUTTON_MINIMIZE)
                        notebook_pane.state |= AuiPaneInfo.buttonMinimize
                        notebook_pane.buttons.append(button)

                    # todo: remove min/max

                if notebook_pane.HasMaximizeButton() != want_max:
                    if want_max:
                        button = AuiPaneButton(AUI_BUTTON_MAXIMIZE_RESTORE)
                        notebook_pane.state |= AuiPaneInfo.buttonMaximize
                        notebook_pane.buttons.append(button)

                    # todo: remove min/max

                if notebook_pane.HasCloseButton() != want_close:
                    if want_close:
                        button = AuiPaneButton(AUI_BUTTON_CLOSE)
                        notebook_pane.state |= AuiPaneInfo.buttonClose
                        notebook_pane.buttons.append(button)

                    # todo: remove close


    def SmartShrink(self, docks, direction):
        """
        Used to intelligently shrink the docks' size (if needed).

        :param `docks`: a list of :class:`AuiDockInfo` instances;
        :param integer `direction`: the direction in which to shrink.
        """

        sashSize = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)
        caption_size = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        clientSize = self._frame.GetClientSize()
        ourDocks = FindDocks(docks, direction, -1, -1)
        oppositeDocks = FindOppositeDocks(docks, direction)
        oppositeSize = self.GetOppositeDockTotalSize(docks, direction)
        ourSize = 0

        for dock in ourDocks:
            ourSize += dock.size

            if not dock.toolbar:
                ourSize += sashSize

        shrinkSize = ourSize + oppositeSize

        if direction == AUI_DOCK_TOP or direction == AUI_DOCK_BOTTOM:
            shrinkSize -= clientSize.y
        else:
            shrinkSize -= clientSize.x

        if shrinkSize <= 0:
            return docks

        # Combine arrays
        for dock in oppositeDocks:
            ourDocks.append(dock)

        oppositeDocks = []

        for dock in ourDocks:
            if dock.toolbar or not dock.resizable:
                continue

            dockRange = dock.size - dock.min_size

            if dock.min_size == 0:
                dockRange -= sashSize
                if direction == AUI_DOCK_TOP or direction == AUI_DOCK_BOTTOM:
                    dockRange -= caption_size

            if dockRange >= shrinkSize:

                dock.size -= shrinkSize
                return docks

            else:

                dock.size -= dockRange
                shrinkSize -= dockRange

        return docks


    def UpdateDockingGuides(self, paneInfo):
        """
        Updates the docking guide windows positions and appearance.

        :param `paneInfo`: a :class:`AuiPaneInfo` instance.
        """

        if len(self._guides) == 0:
            self.CreateGuideWindows()

        captionSize = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        frameRect = GetInternalFrameRect(self._frame, self._docks)
        mousePos = wx.GetMousePosition()

        for indx, guide in enumerate(self._guides):

            pt = wx.Point()
            guide_size = guide.host.GetSize()
            if not guide.host:
                raise Exception("Invalid docking host")

            direction = guide.dock_direction

            if direction == AUI_DOCK_LEFT:
                pt.x = frameRect.x + guide_size.x / 2 + 16
                pt.y = frameRect.y + frameRect.height / 2

            elif direction == AUI_DOCK_TOP:
                pt.x = frameRect.x + frameRect.width / 2
                pt.y = frameRect.y + guide_size.y / 2 + 16

            elif direction == AUI_DOCK_RIGHT:
                pt.x = frameRect.x + frameRect.width - guide_size.x / 2 - 16
                pt.y = frameRect.y + frameRect.height / 2

            elif direction == AUI_DOCK_BOTTOM:
                pt.x = frameRect.x + frameRect.width / 2
                pt.y = frameRect.y + frameRect.height - guide_size.y / 2 - 16

            elif direction == AUI_DOCK_CENTER:
                rc = paneInfo.window.GetScreenRect()
                pt.x = rc.x + rc.width / 2
                pt.y = rc.y + rc.height / 2
                if paneInfo.HasCaption():
                    pt.y -= captionSize / 2
                elif paneInfo.HasCaptionLeft():
                    pt.x -= captionSize / 2

            # guide will be centered around point 'pt'
            targetPosition = wx.Point(pt.x - guide_size.x / 2, pt.y - guide_size.y / 2)

            if guide.host.GetPosition() != targetPosition:
                guide.host.Move(targetPosition)

            guide.host.AeroMove(targetPosition)

            if guide.dock_direction == AUI_DOCK_CENTER:
                guide.host.ValidateNotebookDocking(paneInfo.IsNotebookDockable())

            guide.host.UpdateDockGuide(mousePos)

        paneInfo.window.Lower()


    def DoFrameLayout(self):
        """
        This is an internal function which invokes :meth:`Sizer.Layout() <Sizer.Layout>`
        on the frame's main sizer, then measures all the various UI items
        and updates their internal rectangles.

        :note: This should always be called instead of calling
         `self._managed_window.Layout()` directly.
        """

        self._frame.Layout()

        for part in self._uiparts:
            # get the rectangle of the UI part
            # originally, this code looked like this:
            #    part.rect = wx.Rect(part.sizer_item.GetPosition(),
            #                       part.sizer_item.GetSize())
            # this worked quite well, with one exception: the mdi
            # client window had a "deferred" size variable
            # that returned the wrong size.  It looks like
            # a bug in wx, because the former size of the window
            # was being returned.  So, we will retrieve the part's
            # rectangle via other means

            part.rect = part.sizer_item.GetRect()
            flag = part.sizer_item.GetFlag()
            border = part.sizer_item.GetBorder()

            if flag & wx.TOP:
                part.rect.y -= border
                part.rect.height += border
            if flag & wx.LEFT:
                part.rect.x -= border
                part.rect.width += border
            if flag & wx.BOTTOM:
                part.rect.height += border
            if flag & wx.RIGHT:
                part.rect.width += border

            if part.type == AuiDockUIPart.typeDock:
                part.dock.rect = part.rect
            if part.type == AuiDockUIPart.typePane:
                part.pane.rect = part.rect


    def GetPanePart(self, wnd):
        """
        Looks up the pane border UI part of the
        pane specified. This allows the caller to get the exact rectangle
        of the pane in question, including decorations like caption and border.

        :param Window `wnd`: the window to which the pane border belongs to.
        """

        for part in self._uiparts:
            if part.type == AuiDockUIPart.typePaneBorder and \
               part.pane and part.pane.window == wnd:
                return part

        for part in self._uiparts:
            if part.type == AuiDockUIPart.typePane and \
               part.pane and part.pane.window == wnd:
                return part

        return None


    def GetDockPixelOffset(self, test):
        """
        This is an internal function which returns a dock's offset in pixels from
        the left side of the window (for horizontal docks) or from the top of the
        window (for vertical docks).

        This value is necessary for calculating fixed-pane/toolbar offsets
        when they are dragged.

        :param `test`: a fake :class:`AuiPaneInfo` for testing purposes.
        """

        # the only way to accurately calculate the dock's
        # offset is to actually run a theoretical layout
        docks, panes = CopyDocksAndPanes2(self._docks, self._panes)
        panes.append(test)

        sizer, panes, docks, uiparts = self.LayoutAll(panes, docks, [], True, False)
        client_size = self._frame.GetClientSize()
        sizer.SetDimension(0, 0, client_size.x, client_size.y)
        sizer.Layout()

        for part in uiparts:
            pos = part.sizer_item.GetPosition()
            size = part.sizer_item.GetSize()
            part.rect = wx.RectPS(pos, size)
            if part.type == AuiDockUIPart.typeDock:
                part.dock.rect = part.rect

        sizer.Destroy()

        for dock in docks:
            if test.dock_direction == dock.dock_direction and \
               test.dock_layer == dock.dock_layer and  \
               test.dock_row == dock.dock_row:

                if dock.IsVertical():
                    return dock.rect.y
                else:
                    return dock.rect.x

        return 0


    def GetPartnerDock(self, dock):
        """
        Returns the partner dock for the input dock.

        :param `dock`: a :class:`AuiDockInfo` instance.
        """

        for layer in xrange(dock.dock_layer, -1, -1):

            bestDock = None

            for tmpDock in self._docks:

                if tmpDock.dock_layer != layer:
                    continue

                if tmpDock.dock_direction != dock.dock_direction:
                    continue

                if tmpDock.dock_layer < dock.dock_layer:

                    if not bestDock or tmpDock.dock_row < bestDock.dock_row:
                        bestDock = tmpDock

                elif tmpDock.dock_row > dock.dock_row:

                    if not bestDock or tmpDock.dock_row > bestDock.dock_row:
                        bestDock = tmpDock

            if bestDock:
                return bestDock

        return None


    def GetPartnerPane(self, dock, pane):
        """
        Returns the partner pane for the input pane. They both need to live
        in the same :class:`AuiDockInfo`.

        :param `dock`: a :class:`AuiDockInfo` instance;
        :param `pane`: a :class:`AuiPaneInfo` class.
        """

        panePosition = -1

        for i, tmpPane in enumerate(dock.panes):
            if tmpPane.window == pane.window:
                panePosition = i
            elif not tmpPane.IsFixed() and panePosition != -1:
                return tmpPane

        return None


    def GetTotalPixSizeAndProportion(self, dock):
        """
        Returns the dimensions and proportion of the input dock.

        :param `dock`: the :class:`AuiDockInfo` structure to analyze.
        """

        totalPixsize = 0
        totalProportion = 0

        # determine the total proportion of all resizable panes,
        # and the total size of the dock minus the size of all
        # the fixed panes
        for tmpPane in dock.panes:

            if tmpPane.IsFixed():
                continue

            totalProportion += tmpPane.dock_proportion

            if dock.IsHorizontal():
                totalPixsize += tmpPane.rect.width
            else:
                totalPixsize += tmpPane.rect.height

##            if tmpPane.min_size.IsFullySpecified():
##
##                if dock.IsHorizontal():
##                    totalPixsize -= tmpPane.min_size.x
##                else:
##                    totalPixsize -= tmpPane.min_size.y

        return totalPixsize, totalProportion


    def GetOppositeDockTotalSize(self, docks, direction):
        """
        Returns the dimensions of the dock which lives opposite of the input dock.

        :param `docks`: a list of :class:`AuiDockInfo` structures to analyze;
        :param integer `direction`: the direction in which to look for the opposite dock.
        """

        sash_size = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)
        caption_size = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        pane_border_size = self._art.GetMetric(AUI_DOCKART_PANE_BORDER_SIZE)
        minSizeMax = 0
        result = sash_size
        vertical = False

        if direction in [AUI_DOCK_TOP, AUI_DOCK_BOTTOM]:
            vertical = True

        # Get minimum size of the most inner area
        for tmpDock in docks:

            if tmpDock.dock_layer != 0:
                continue

            if tmpDock.dock_direction != AUI_DOCK_CENTER and tmpDock.IsVertical() != vertical:
                continue

            for tmpPane in tmpDock.panes:

                minSize = pane_border_size*2 - sash_size

                if vertical:
                    minSize += tmpPane.min_size.y + caption_size
                else:
                    minSize += tmpPane.min_size.x

                if minSize > minSizeMax:
                    minSizeMax = minSize

        result += minSizeMax

        # Get opposite docks
        oppositeDocks = FindOppositeDocks(docks, direction)

        # Sum size of the opposite docks and their sashes
        for dock in oppositeDocks:
            result += dock.size
            # if it's not a toolbar add the sash_size too
            if not dock.toolbar:
                result += sash_size

        return result


    def CalculateDockSizerLimits(self, dock):
        """
        Calculates the minimum and maximum sizes allowed for the input dock.

        :param `dock`: the :class:`AuiDockInfo` structure to analyze.
        """

        docks, panes = CopyDocksAndPanes2(self._docks, self._panes)

        sash_size = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)
        caption_size = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
        opposite_size = self.GetOppositeDockTotalSize(docks, dock.dock_direction)

        for tmpDock in docks:

            if tmpDock.dock_direction == dock.dock_direction and \
               tmpDock.dock_layer == dock.dock_layer and \
               tmpDock.dock_row == dock.dock_row:

                tmpDock.size = 1
                break

        sizer, panes, docks, uiparts = self.LayoutAll(panes, docks, [], True, False)
        client_size = self._frame.GetClientSize()
        sizer.SetDimension(0, 0, client_size.x, client_size.y)
        sizer.Layout()

        for part in uiparts:

            part.rect = wx.RectPS(part.sizer_item.GetPosition(), part.sizer_item.GetSize())
            if part.type == AuiDockUIPart.typeDock:
                part.dock.rect = part.rect

        sizer.Destroy()
        new_dock = None

        for tmpDock in docks:
            if tmpDock.dock_direction == dock.dock_direction and \
               tmpDock.dock_layer == dock.dock_layer and \
               tmpDock.dock_row == dock.dock_row:

                new_dock = tmpDock
                break

        partnerDock = self.GetPartnerDock(dock)

        if partnerDock:
            partnerRange = partnerDock.size - partnerDock.min_size
            if partnerDock.min_size == 0:
                partnerRange -= sash_size
                if dock.IsHorizontal():
                    partnerRange -= caption_size

            direction = dock.dock_direction

            if direction == AUI_DOCK_LEFT:
                minPix = new_dock.rect.x + new_dock.rect.width
                maxPix = dock.rect.x + dock.rect.width
                maxPix += partnerRange

            elif direction == AUI_DOCK_TOP:
                minPix = new_dock.rect.y + new_dock.rect.height
                maxPix = dock.rect.y + dock.rect.height
                maxPix += partnerRange

            elif direction == AUI_DOCK_RIGHT:
                minPix = dock.rect.x - partnerRange - sash_size
                maxPix = new_dock.rect.x - sash_size

            elif direction == AUI_DOCK_BOTTOM:
                minPix = dock.rect.y - partnerRange - sash_size
                maxPix = new_dock.rect.y - sash_size

            return minPix, maxPix

        direction = new_dock.dock_direction

        if direction == AUI_DOCK_LEFT:
            minPix = new_dock.rect.x + new_dock.rect.width
            maxPix = client_size.x - opposite_size - sash_size

        elif direction == AUI_DOCK_TOP:
            minPix = new_dock.rect.y + new_dock.rect.height
            maxPix = client_size.y - opposite_size - sash_size

        elif direction == AUI_DOCK_RIGHT:
            minPix = opposite_size
            maxPix = new_dock.rect.x - sash_size

        elif direction == AUI_DOCK_BOTTOM:
            minPix = opposite_size
            maxPix = new_dock.rect.y - sash_size

        return minPix, maxPix


    def CalculatePaneSizerLimits(self, dock, pane):
        """
        Calculates the minimum and maximum sizes allowed for the input pane.

        :param `dock`: the :class:`AuiDockInfo` structure to which `pane` belongs to;
        :param `pane`: a :class:`AuiPaneInfo` class for which calculation are requested.
        """

        if pane.IsFixed():
            if dock.IsHorizontal():
                minPix = maxPix = pane.rect.x + 1 + pane.rect.width
            else:
                minPix = maxPix = pane.rect.y + 1 + pane.rect.height

            return minPix, maxPix

        totalPixsize, totalProportion = self.GetTotalPixSizeAndProportion(dock)
        partnerPane = self.GetPartnerPane(dock, pane)

        if dock.IsHorizontal():

            minPix = pane.rect.x + 1
            maxPix = pane.rect.x + 1 + pane.rect.width

            if pane.min_size.IsFullySpecified():
                minPix += pane.min_size.x
            else:
                minPix += 1

            if partnerPane:
                maxPix += partnerPane.rect.width

                if partnerPane.min_size.IsFullySpecified():
                    maxPix -= partnerPane.min_size.x - 1

            else:
                minPix = maxPix

        else:

            minPix = pane.rect.y + 1
            maxPix = pane.rect.y + 1 + pane.rect.height

            if pane.min_size.IsFullySpecified():
                minPix += pane.min_size.y
            else:
                minPix += 1

            if partnerPane:
                maxPix += partnerPane.rect.height

                if partnerPane.min_size.IsFullySpecified():
                    maxPix -= partnerPane.min_size.y - 1

            else:
                minPix = maxPix

        return minPix, maxPix


    def CheckMovableSizer(self, part):
        """
        Checks if a UI part can be actually resized.

        :param AuiDockUIPart `part`: a UI part.
        """

        # a dock may not be resized if it has a single
        # pane which is not resizable
        if part.type == AuiDockUIPart.typeDockSizer and part.dock and \
           len(part.dock.panes) == 1 and part.dock.panes[0].IsFixed():

            return False

        if part.pane:

            # panes that may not be resized should be ignored here
            minPix, maxPix = self.CalculatePaneSizerLimits(part.dock, part.pane)

            if minPix == maxPix:
                return False

        return True


    def PaneFromTabEvent(self, event):
        """
        Returns a :class:`AuiPaneInfo` from a :class:`~lib.agw.aui.auibook.AuiNotebook` event.

        :param `event`: a :class:`~lib.agw.aui.auibook.AuiNotebookEvent` event.
        """

        obj = event.GetEventObject()

        if obj and isinstance(obj, auibook.AuiTabCtrl):

            page_idx = obj.GetActivePage()

            if page_idx >= 0:
                page = obj.GetPage(page_idx)
                window = page.window
                if window:
                    return self.GetPane(window)

        elif obj and isinstance(obj, auibook.AuiNotebook):

            page_idx = event.GetSelection()

            if page_idx >= 0:
                window = obj.GetPage(page_idx)
                if window:
                    return self.GetPane(window)

        return NonePaneInfo


    def OnTabBeginDrag(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_BEGIN_DRAG`` event.

        :param `event`: a :class:`~lib.agw.aui.auibook.AuiNotebookEvent` event to be processed.
        """

        if self._masterManager:
            self._masterManager.OnTabBeginDrag(event)

        else:
            paneInfo = self.PaneFromTabEvent(event)

            if paneInfo.IsOk():

                # It's one of ours!
                self._action = actionDragFloatingPane
                mouse = wx.GetMousePosition()

                # set initial float position - may have to think about this
                # offset a bit more later ...
                self._action_offset = wx.Point(20, 10)
                self._toolbar_action_offset = wx.Point(20, 10)

                paneInfo.floating_pos = mouse - self._action_offset
                paneInfo.dock_pos = AUI_DOCK_NONE
                paneInfo.notebook_id = -1

                tab = event.GetEventObject()

                if tab.HasCapture():
                    tab.ReleaseMouse()

                # float the window
                if paneInfo.IsMaximized():
                    self.RestorePane(paneInfo)
                paneInfo.Float()
                self.Update()

                self._action_window = paneInfo.window

                self._frame.CaptureMouse()
                event.SetDispatched(True)

            else:

                # not our window
                event.Skip()


    def OnTabPageClose(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_PAGE_CLOSE`` event.

        :param `event`: a :class:`~lib.agw.aui.auibook.AuiNotebookEvent` event to be processed.
        """

        if self._masterManager:
            self._masterManager.OnTabPageClose(event)

        else:

            p = self.PaneFromTabEvent(event)
            if p.IsOk():

                # veto it because we will call "RemovePage" ourselves
                event.Veto()

                # Now ask the app if they really want to close...
                # fire pane close event
                e = AuiManagerEvent(wxEVT_AUI_PANE_CLOSE)
                e.SetPane(p)
                e.SetCanVeto(True)
                self.ProcessMgrEvent(e)

                if e.GetVeto():
                    return

                self.ClosePane(p)
                self.Update()
            else:
                event.Skip()


    def OnTabSelected(self, event):
        """
        Handles the ``EVT_AUINOTEBOOK_PAGE_CHANGED`` event.

        :param `event`: a :class:`~lib.agw.aui.auibook.AuiNotebookEvent` event to be processed.
        """

        if self._masterManager:
            self._masterManager.OnTabSelected(event)
            return

        obj = event.GetEventObject()

        if obj and isinstance(obj, auibook.AuiNotebook):

            notebook = obj
            page = notebook.GetPage(event.GetSelection())
            paneInfo = self.GetPane(page)

            if paneInfo.IsOk():
                notebookRoot = GetNotebookRoot(self._panes, paneInfo.notebook_id)
                if notebookRoot:

                    notebookRoot.Caption(paneInfo.caption)
                    self.RefreshCaptions()

        event.Skip()


    def GetNotebooks(self):
        """ Returns all the automatic :class:`~lib.agw.aui.auibook.AuiNotebook` in the :class:`AuiManager`. """

        if self._masterManager:
            return self._masterManager.GetNotebooks()

        return self._notebooks


    def SetMasterManager(self, manager):
        """
        Sets the master manager for an automatic :class:`~lib.agw.aui.auibook.AuiNotebook`.

        :param `manager`: an instance of :class:`AuiManager`.
        """

        self._masterManager = manager


    def ProcessDockResult(self, target, new_pos):
        """
        This is a utility function used by :meth:`DoDrop` - it checks
        if a dock operation is allowed, the new dock position is copied into
        the target info. If the operation was allowed, the function returns ``True``.

        :param `target`: the :class:`AuiPaneInfo` instance to be docked;
        :param integer `new_pos`: the new docking position if the docking operation is allowed.
        """

        allowed = False
        direction = new_pos.dock_direction

        if direction == AUI_DOCK_TOP:
            allowed = target.IsTopDockable()
        elif direction == AUI_DOCK_BOTTOM:
            allowed = target.IsBottomDockable()
        elif direction == AUI_DOCK_LEFT:
            allowed = target.IsLeftDockable()
        elif direction == AUI_DOCK_RIGHT:
            allowed = target.IsRightDockable()

        if allowed:
            target = new_pos

            if target.IsToolbar():
                self.SwitchToolBarOrientation(target)

        return allowed, target


    def SwitchToolBarOrientation(self, pane):
        """
        Switches the toolbar orientation from vertical to horizontal and vice-versa.
        This is especially useful for vertical docked toolbars once they float.

        :param `pane`: an instance of :class:`AuiPaneInfo`, which may have a :class:`~lib.agw.aui.auibar.AuiToolBar`
         window associated with it.
        """
        if not isinstance(pane.window, auibar.AuiToolBar):
            return pane

        if pane.IsFloating():
            return pane

        toolBar = pane.window
        direction = pane.dock_direction
        vertical = direction in [AUI_DOCK_LEFT, AUI_DOCK_RIGHT]

        agwStyle = toolBar.GetAGWWindowStyleFlag()
        new_agwStyle = agwStyle

        if vertical:
            new_agwStyle |= AUI_TB_VERTICAL
        else:
            new_agwStyle &= ~(AUI_TB_VERTICAL)

        if agwStyle != new_agwStyle:
            toolBar.SetAGWWindowStyleFlag(new_agwStyle)
        if not toolBar.GetGripperVisible():
            toolBar.SetGripperVisible(True)

        s = pane.window.GetMinSize()
        pane.BestSize(s)
        if new_agwStyle != agwStyle:
            toolBar.Realize()

        return pane


    def DoDrop(self, docks, panes, target, pt, offset=wx.Point(0, 0)):
        """
        This is an important function. It basically takes a mouse position,
        and determines where the panes new position would be. If the pane is to be
        dropped, it performs the drop operation using the specified dock and pane
        arrays. By specifying copy dock and pane arrays when calling, a "what-if"
        scenario can be performed, giving precise coordinates for drop hints.

        :param `docks`: a list of :class:`AuiDockInfo` classes;
        :param `panes`: a list of :class:`AuiPaneInfo` instances;
        :param Point `pt`: a mouse position to check for a drop operation;
        :param Point `offset`: a possible offset from the input point `pt`.
        """

        if target.IsToolbar():
            return self.DoDropToolbar(docks, panes, target, pt, offset)
        elif target.IsFloating():
            return self.DoDropFloatingPane(docks, panes, target, pt)
        else:
            return self.DoDropNonFloatingPane(docks, panes, target, pt)


    def CopyTarget(self, target):
        """
        Copies all the attributes of the input `target` into another :class:`AuiPaneInfo`.

        :param `target`: the source :class:`AuiPaneInfo` from where to copy attributes.
        """

        drop = AuiPaneInfo()
        drop.name = target.name
        drop.caption = target.caption
        drop.window = target.window
        drop.frame = target.frame
        drop.state = target.state
        drop.dock_direction = target.dock_direction
        drop.dock_layer = target.dock_layer
        drop.dock_row = target.dock_row
        drop.dock_pos = target.dock_pos
        drop.best_size = wx.Size(*target.best_size)
        drop.min_size = wx.Size(*target.min_size)
        drop.max_size = wx.Size(*target.max_size)
        drop.floating_pos = wx.Point(*target.floating_pos)
        drop.floating_size = wx.Size(*target.floating_size)
        drop.dock_proportion = target.dock_proportion
        drop.buttons = target.buttons
        drop.rect = wx.Rect(*target.rect)
        drop.icon = target.icon
        drop.notebook_id = target.notebook_id
        drop.transparent = target.transparent
        drop.snapped = target.snapped
        drop.minimize_mode = target.minimize_mode
        drop.minimize_target = target.minimize_target

        return drop


    def DoDropToolbar(self, docks, panes, target, pt, offset):
        """
        Handles the situation in which the dropped pane contains a toolbar.

        :param `docks`: a list of :class:`AuiDockInfo` classes;
        :param `panes`: a list of :class:`AuiPaneInfo` instances;
        :param AuiPaneInfo `target`: the target pane containing the toolbar;
        :param Point `pt`: a mouse position to check for a drop operation;
        :param Point `offset`: a possible offset from the input point `pt`.
        """

        drop = self.CopyTarget(target)

        # The result should always be shown
        drop.Show()

        # Check to see if the toolbar has been dragged out of the window
        if CheckOutOfWindow(self._frame, pt):
            if self._agwFlags & AUI_MGR_ALLOW_FLOATING and drop.IsFloatable():
                drop.Float()

            return self.ProcessDockResult(target, drop)

        # Allow directional change when the cursor leaves this rect
        safeRect = wx.Rect(*target.rect)
        if target.IsHorizontal():
            safeRect.Inflate(100, 50)
        else:
            safeRect.Inflate(50, 100)

        # Check to see if the toolbar has been dragged to edge of the frame
        dropDir = CheckEdgeDrop(self._frame, docks, pt)

        if dropDir != -1:

            if dropDir == wx.LEFT:
                drop.Dock().Left().Layer(auiToolBarLayer).Row(0). \
                    Position(pt.y - self.GetDockPixelOffset(drop) - offset.y)

            elif dropDir == wx.RIGHT:
                drop.Dock().Right().Layer(auiToolBarLayer).Row(0). \
                    Position(pt.y - self.GetDockPixelOffset(drop) - offset.y)

            elif dropDir == wx.TOP:
                drop.Dock().Top().Layer(auiToolBarLayer).Row(0). \
                    Position(pt.x - self.GetDockPixelOffset(drop) - offset.x)

            elif dropDir == wx.BOTTOM:
                drop.Dock().Bottom().Layer(auiToolBarLayer).Row(0). \
                    Position(pt.x - self.GetDockPixelOffset(drop) - offset.x)

            if not target.IsFloating() and safeRect.Contains(pt) and \
               target.dock_direction != drop.dock_direction:
                return False, target

            return self.ProcessDockResult(target, drop)

        # If the windows is floating and out of the client area, do nothing
        if drop.IsFloating() and not self._frame.GetClientRect().Contains(pt):
            return False, target

        # Ok, can't drop on edge - check internals ...

        clientSize = self._frame.GetClientSize()
        x = Clip(pt.x, 0, clientSize.x - 1)
        y = Clip(pt.y, 0, clientSize.y - 1)
        part = self.HitTest(x, y)

        if not part or not part.dock:
            return False, target

        dock = part.dock

        # toolbars may only be moved in and to fixed-pane docks,
        # otherwise we will try to float the pane.  Also, the pane
        # should float if being dragged over center pane windows
        if not dock.fixed or dock.dock_direction == AUI_DOCK_CENTER:

            if (self._agwFlags & AUI_MGR_ALLOW_FLOATING and drop.IsFloatable()) or \
               dock.dock_direction not in [AUI_DOCK_CENTER, AUI_DOCK_NONE]:
                if drop.IsFloatable():
                    drop.Float()

            return self.ProcessDockResult(target, drop)

        # calculate the offset from where the dock begins
        # to the point where the user dropped the pane
        dockDropOffset = 0
        if dock.IsHorizontal():
            dockDropOffset = pt.x - dock.rect.x - offset.x
        else:
            dockDropOffset = pt.y - dock.rect.y - offset.y

        drop.Dock().Direction(dock.dock_direction).Layer(dock.dock_layer). \
            Row(dock.dock_row).Position(dockDropOffset)

        if (pt.y <= dock.rect.GetTop() + 2 and dock.IsHorizontal()) or \
           (pt.x <= dock.rect.GetLeft() + 2 and dock.IsVertical()):

            if dock.dock_direction in [AUI_DOCK_TOP, AUI_DOCK_LEFT]:
                row = drop.dock_row
                panes = DoInsertDockRow(panes, dock.dock_direction, dock.dock_layer, dock.dock_row)
                drop.dock_row = row

            else:
                panes = DoInsertDockRow(panes, dock.dock_direction, dock.dock_layer, dock.dock_row+1)
                drop.dock_row = dock.dock_row + 1

        if (pt.y >= dock.rect.GetBottom() - 2 and dock.IsHorizontal()) or \
           (pt.x >= dock.rect.GetRight() - 2 and dock.IsVertical()):

            if dock.dock_direction in [AUI_DOCK_TOP, AUI_DOCK_LEFT]:
                panes = DoInsertDockRow(panes, dock.dock_direction, dock.dock_layer, dock.dock_row+1)
                drop.dock_row = dock.dock_row+1

            else:
                row = drop.dock_row
                panes = DoInsertDockRow(panes, dock.dock_direction, dock.dock_layer, dock.dock_row)
                drop.dock_row = row

        if not target.IsFloating() and safeRect.Contains(pt) and \
           target.dock_direction != drop.dock_direction:
            return False, target

        return self.ProcessDockResult(target, drop)


    def DoDropFloatingPane(self, docks, panes, target, pt):
        """
        Handles the situation in which the dropped pane contains a normal window.

        :param `docks`: a list of :class:`AuiDockInfo` classes;
        :param `panes`: a list of :class:`AuiPaneInfo` instances;
        :param AuiPaneInfo `target`: the target pane containing the window;
        :param Point `pt`: a mouse position to check for a drop operation.
        """
        screenPt = self._frame.ClientToScreen(pt)
        paneInfo = self.PaneHitTest(panes, pt)

        if paneInfo.IsMaximized():
            return False, target

        if paneInfo.window is None:
            return False, target

        # search the dock guides.
        # reverse order to handle the center first.
        for i in xrange(len(self._guides)-1, -1, -1):
            guide = self._guides[i]

            # do hit testing on the guide
            dir = guide.host.HitTest(screenPt.x, screenPt.y)

            if dir == -1:  # point was outside of the dock guide
                continue

            if dir == wx.ALL:   # target is a single dock guide
                return self.DoDropLayer(docks, target, guide.dock_direction)

            elif dir == wx.CENTER:

                if not target.IsNotebookDockable():
                    continue
                if not paneInfo.IsNotebookDockable() and not paneInfo.IsNotebookControl():
                    continue

                if not paneInfo.HasNotebook():

                    # Add a new notebook pane with the original as a tab...
                    self.CreateNotebookBase(panes, paneInfo)

                # Add new item to notebook
                target.NotebookPage(paneInfo.notebook_id)

            else:

                drop_pane = False
                drop_row = False

                insert_dir = paneInfo.dock_direction
                insert_layer = paneInfo.dock_layer
                insert_row = paneInfo.dock_row
                insert_pos = paneInfo.dock_pos

                if insert_dir == AUI_DOCK_CENTER:

                    insert_layer = 0
                    if dir == wx.LEFT:
                        insert_dir = AUI_DOCK_LEFT
                    elif dir == wx.UP:
                        insert_dir = AUI_DOCK_TOP
                    elif dir == wx.RIGHT:
                        insert_dir = AUI_DOCK_RIGHT
                    elif dir == wx.DOWN:
                        insert_dir = AUI_DOCK_BOTTOM

                if insert_dir == AUI_DOCK_LEFT:

                    drop_pane = (dir == wx.UP   or dir == wx.DOWN)
                    drop_row  = (dir == wx.LEFT or dir == wx.RIGHT)
                    if dir == wx.RIGHT:
                        insert_row += 1
                    elif dir == wx.DOWN:
                        insert_pos += 1

                elif insert_dir == AUI_DOCK_RIGHT:

                    drop_pane = (dir == wx.UP   or dir == wx.DOWN)
                    drop_row  = (dir == wx.LEFT or dir == wx.RIGHT)
                    if dir == wx.LEFT:
                        insert_row += 1
                    elif dir == wx.DOWN:
                        insert_pos += 1

                elif insert_dir == AUI_DOCK_TOP:

                    drop_pane = (dir == wx.LEFT or dir == wx.RIGHT)
                    drop_row  = (dir == wx.UP   or dir == wx.DOWN)
                    if dir == wx.DOWN:
                        insert_row += 1
                    elif dir == wx.RIGHT:
                        insert_pos += 1

                elif insert_dir == AUI_DOCK_BOTTOM:

                    drop_pane = (dir == wx.LEFT or dir == wx.RIGHT)
                    drop_row  = (dir == wx.UP   or dir == wx.DOWN)
                    if dir == wx.UP:
                        insert_row += 1
                    elif dir == wx.RIGHT:
                        insert_pos += 1

                if paneInfo.dock_direction == AUI_DOCK_CENTER:
                    insert_row = GetMaxRow(panes, insert_dir, insert_layer) + 1

                if drop_pane:
                    return self.DoDropPane(panes, target, insert_dir, insert_layer, insert_row, insert_pos)

                if drop_row:
                    return self.DoDropRow(panes, target, insert_dir, insert_layer, insert_row)

            return True, target

        return False, target


    def DoDropNonFloatingPane(self, docks, panes, target, pt):
        """
        Handles the situation in which the dropped pane is not floating.

        :param `docks`: a list of :class:`AuiDockInfo` classes;
        :param `panes`: a list of :class:`AuiPaneInfo` instances;
        :param AuiPaneInfo `target`: the target pane containing the toolbar;
        :param Point `pt`: a mouse position to check for a drop operation.
        """

        screenPt = self._frame.ClientToScreen(pt)
        clientSize = self._frame.GetClientSize()
        frameRect = GetInternalFrameRect(self._frame, self._docks)

        drop = self.CopyTarget(target)

        # The result should always be shown
        drop.Show()

        part = self.HitTest(pt.x, pt.y)

        if not part:
            return False, target

        if part.type == AuiDockUIPart.typeDockSizer:

            if len(part.dock.panes) != 1:
                return False, target

            part = self.GetPanePart(part.dock.panes[0].window)
            if not part:
                return False, target

        if not part.pane:
            return False, target

        part = self.GetPanePart(part.pane.window)
        if not part:
            return False, target

        insert_dock_row = False
        insert_row = part.pane.dock_row
        insert_dir = part.pane.dock_direction
        insert_layer = part.pane.dock_layer

        direction = part.pane.dock_direction

        if direction == AUI_DOCK_TOP:
            if pt.y >= part.rect.y and pt.y < part.rect.y+auiInsertRowPixels:
                insert_dock_row = True

        elif direction == AUI_DOCK_BOTTOM:
            if pt.y > part.rect.y+part.rect.height-auiInsertRowPixels and \
               pt.y <= part.rect.y + part.rect.height:
                insert_dock_row = True

        elif direction == AUI_DOCK_LEFT:
            if pt.x >= part.rect.x and pt.x < part.rect.x+auiInsertRowPixels:
                insert_dock_row = True

        elif direction == AUI_DOCK_RIGHT:
            if pt.x > part.rect.x+part.rect.width-auiInsertRowPixels and \
               pt.x <= part.rect.x+part.rect.width:
                insert_dock_row = True

        elif direction == AUI_DOCK_CENTER:

                # "new row pixels" will be set to the default, but
                # must never exceed 20% of the window size
                new_row_pixels_x = auiNewRowPixels
                new_row_pixels_y = auiNewRowPixels

                if new_row_pixels_x > (part.rect.width*20)/100:
                    new_row_pixels_x = (part.rect.width*20)/100

                if new_row_pixels_y > (part.rect.height*20)/100:
                    new_row_pixels_y = (part.rect.height*20)/100

                # determine if the mouse pointer is in a location that
                # will cause a new row to be inserted.  The hot spot positions
                # are along the borders of the center pane

                insert_layer = 0
                insert_dock_row = True
                pr = part.rect

                if pt.x >= pr.x and pt.x < pr.x + new_row_pixels_x:
                    insert_dir = AUI_DOCK_LEFT
                elif pt.y >= pr.y and pt.y < pr.y + new_row_pixels_y:
                    insert_dir = AUI_DOCK_TOP
                elif pt.x >= pr.x + pr.width - new_row_pixels_x and pt.x < pr.x + pr.width:
                    insert_dir = AUI_DOCK_RIGHT
                elif pt.y >= pr.y+ pr.height - new_row_pixels_y and pt.y < pr.y + pr.height:
                    insert_dir = AUI_DOCK_BOTTOM
                else:
                    return False, target

                insert_row = GetMaxRow(panes, insert_dir, insert_layer) + 1

        if insert_dock_row:

            panes = DoInsertDockRow(panes, insert_dir, insert_layer, insert_row)
            drop.Dock().Direction(insert_dir).Layer(insert_layer). \
                Row(insert_row).Position(0)

            return self.ProcessDockResult(target, drop)

        # determine the mouse offset and the pane size, both in the
        # direction of the dock itself, and perpendicular to the dock

        if part.orientation == wx.VERTICAL:

            offset = pt.y - part.rect.y
            size = part.rect.GetHeight()

        else:

            offset = pt.x - part.rect.x
            size = part.rect.GetWidth()

        drop_position = part.pane.dock_pos

        # if we are in the top/left part of the pane,
        # insert the pane before the pane being hovered over
        if offset <= size/2:

            drop_position = part.pane.dock_pos
            panes = DoInsertPane(panes,
                                 part.pane.dock_direction,
                                 part.pane.dock_layer,
                                 part.pane.dock_row,
                                 part.pane.dock_pos)

        # if we are in the bottom/right part of the pane,
        # insert the pane before the pane being hovered over
        if offset > size/2:

            drop_position = part.pane.dock_pos+1
            panes = DoInsertPane(panes,
                                 part.pane.dock_direction,
                                 part.pane.dock_layer,
                                 part.pane.dock_row,
                                 part.pane.dock_pos+1)


        drop.Dock(). \
                     Direction(part.dock.dock_direction). \
                     Layer(part.dock.dock_layer).Row(part.dock.dock_row). \
                     Position(drop_position)

        return self.ProcessDockResult(target, drop)


    def DoDropLayer(self, docks, target, dock_direction):
        """
        Handles the situation in which `target` is a single dock guide.

        :param `docks`: a list of :class:`AuiDockInfo` classes;
        :param AuiPaneInfo `target`: the target pane;
        :param integer `dock_direction`: the docking direction.
        """

        drop = self.CopyTarget(target)

        if dock_direction == AUI_DOCK_LEFT:
            drop.Dock().Left()
            drop_new_layer = max(max(GetMaxLayer(docks, AUI_DOCK_LEFT),
                                     GetMaxLayer(docks, AUI_DOCK_BOTTOM)),
                                 GetMaxLayer(docks, AUI_DOCK_TOP)) + 1

        elif dock_direction == AUI_DOCK_TOP:
            drop.Dock().Top()
            drop_new_layer = max(max(GetMaxLayer(docks, AUI_DOCK_TOP),
                                     GetMaxLayer(docks, AUI_DOCK_LEFT)),
                                 GetMaxLayer(docks, AUI_DOCK_RIGHT)) + 1

        elif dock_direction == AUI_DOCK_RIGHT:
            drop.Dock().Right()
            drop_new_layer = max(max(GetMaxLayer(docks, AUI_DOCK_RIGHT),
                                     GetMaxLayer(docks, AUI_DOCK_TOP)),
                                 GetMaxLayer(docks, AUI_DOCK_BOTTOM)) + 1

        elif dock_direction == AUI_DOCK_BOTTOM:
            drop.Dock().Bottom()
            drop_new_layer = max(max(GetMaxLayer(docks, AUI_DOCK_BOTTOM),
                                     GetMaxLayer(docks, AUI_DOCK_LEFT)),
                                 GetMaxLayer(docks, AUI_DOCK_RIGHT)) + 1

        else:
            return False, target


        drop.Dock().Layer(drop_new_layer)
        return self.ProcessDockResult(target, drop)


    def DoDropPane(self, panes, target, dock_direction, dock_layer, dock_row, dock_pos):
        """
        Drop a pane in the interface.

        :param `panes`: a list of :class:`AuiPaneInfo` classes;
        :param AuiPaneInfo `target`: the target pane;
        :param integer `dock_direction`: the docking direction;
        :param integer `dock_layer`: the docking layer;
        :param integer `dock_row`: the docking row;
        :param integer `dock_pos`: the docking position.
        """

        drop = self.CopyTarget(target)
        panes = DoInsertPane(panes, dock_direction, dock_layer, dock_row, dock_pos)

        drop.Dock().Direction(dock_direction).Layer(dock_layer).Row(dock_row).Position(dock_pos)
        return self.ProcessDockResult(target, drop)


    def DoDropRow(self, panes, target, dock_direction, dock_layer, dock_row):
        """
        Insert a row in the interface before dropping.

        :param `panes`: a list of :class:`AuiPaneInfo` classes;
        :param AuiPaneInfo `target`: the target pane;
        :param integer `dock_direction`: the docking direction;
        :param integer `dock_layer`: the docking layer;
        :param integer `dock_row`: the docking row.
        """

        drop = self.CopyTarget(target)
        panes = DoInsertDockRow(panes, dock_direction, dock_layer, dock_row)

        drop.Dock().Direction(dock_direction).Layer(dock_layer).Row(dock_row).Position(0)
        return self.ProcessDockResult(target, drop)


    def ShowHint(self, rect):
        """
        Shows the AUI hint window.

        :param Rect `rect`: the hint rect calculated in advance.
        """

        if rect == self._last_hint:
            return

        if self._agwFlags & AUI_MGR_RECTANGLE_HINT and wx.Platform != "__WXMAC__":

            if self._last_hint != rect:
                # remove the last hint rectangle
                self._last_hint = wx.Rect(*rect)
                self._frame.Refresh()
                self._frame.Update()

            screendc = wx.ScreenDC()
            clip = wx.Region(1, 1, 10000, 10000)

            # clip all floating windows, so we don't draw over them
            for pane in self._panes:
                if pane.IsFloating() and pane.frame.IsShown():

                    rect2 = wx.Rect(*pane.frame.GetRect())
                    if wx.Platform == "__WXGTK__":
                        # wxGTK returns the client size, not the whole frame size
                        rect2.width += 15
                        rect2.height += 35
                        rect2.Inflate(5, 5)

                    clip.SubtractRect(rect2)

            # As we can only hide the hint by redrawing the managed window, we
            # need to clip the region to the managed window too or we get
            # nasty redrawn problems.
            clip.IntersectRect(self._frame.GetRect())
            screendc.SetClippingRegionAsRegion(clip)

            stipple = PaneCreateStippleBitmap()
            brush = wx.BrushFromBitmap(stipple)
            screendc.SetBrush(brush)
            screendc.SetPen(wx.TRANSPARENT_PEN)
            screendc.DrawRectangle(rect.x, rect.y, 5, rect.height)
            screendc.DrawRectangle(rect.x+5, rect.y, rect.width-10, 5)
            screendc.DrawRectangle(rect.x+rect.width-5, rect.y, 5, rect.height)
            screendc.DrawRectangle(rect.x+5, rect.y+rect.height-5, rect.width-10, 5)
            RefreshDockingGuides(self._guides)

            return

        if not self._hint_window:
            self.CreateHintWindow()

        if self._hint_window:
            self._hint_window.SetRect(rect)
            self._hint_window.Show()

        self._hint_fadeamt = self._hint_fademax

        if self._agwFlags & AUI_MGR_HINT_FADE:
            self._hint_fadeamt = 0
            self._hint_window.SetTransparent(self._hint_fadeamt)

        if self._action == actionDragFloatingPane and self._action_window:
            self._action_window.SetFocus()

        if self._hint_fadeamt != self._hint_fademax: #  Only fade if we need to
            # start fade in timer
            self._hint_fadetimer.Start(5)

        self._last_hint = wx.Rect(*rect)


    def HideHint(self):
        """ Hides a transparent window hint if there is one. """

        # hides a transparent window hint if there is one
        if self._hint_window:
            self._hint_window.Hide()

        self._hint_fadetimer.Stop()
        self._last_hint = wx.Rect()


    def IsPaneButtonVisible(self, part):
        """
        Returns whether a pane button in the pane caption is visible.

        :param AuiDockUIPart `part`: the UI part to analyze.
        """

        captionRect = wx.Rect()

        for temp_part in self._uiparts:
            if temp_part.pane == part.pane and \
               temp_part.type == AuiDockUIPart.typeCaption:
                captionRect = temp_part.rect
                break

        return captionRect.ContainsRect(part.rect)


    def DrawPaneButton(self, dc, part, pt):
        """
        Draws a pane button in the caption (convenience function).

        :param `dc`: a :class:`DC` device context object;
        :param AuiDockUIPart `part`: the UI part to analyze;
        :param Point `pt`: the mouse location.
        """

        if not self.IsPaneButtonVisible(part):
            return

        state = AUI_BUTTON_STATE_NORMAL

        if part.rect.Contains(pt):

            if _VERSION_STRING < "2.9":
                leftDown = wx.GetMouseState().LeftDown()
            else:
                leftDown = wx.GetMouseState().LeftIsDown()

            if leftDown:
                state = AUI_BUTTON_STATE_PRESSED
            else:
                state = AUI_BUTTON_STATE_HOVER

        self._art.DrawPaneButton(dc, self._frame, part.button.button_id,
                                 state, part.rect, part.pane)


    def RefreshButton(self, part):
        """
        Refreshes a pane button in the caption.

        :param AuiDockUIPart `part`: the UI part to analyze.
        """

        rect = wx.Rect(*part.rect)
        rect.Inflate(2, 2)
        self._frame.Refresh(True, rect)
        self._frame.Update()


    def RefreshCaptions(self):
        """ Refreshes all pane captions. """

        for part in self._uiparts:
            if part.type == AuiDockUIPart.typeCaption:
                self._frame.Refresh(True, part.rect)
                self._frame.Update()


    def CalculateHintRect(self, pane_window, pt, offset):
        """
        Calculates the drop hint rectangle.

        The method first calls :meth:`DoDrop` to determine the exact position the pane would
        be at were if dropped. If the pane would indeed become docked at the
        specified drop point, the the rectangle hint will be returned in
        screen coordinates. Otherwise, an empty rectangle is returned.

        :param Window `pane_window`: it is the window pointer of the pane being dragged;
        :param Point `pt`: is the mouse position, in client coordinates;
        :param Point `offset`: describes the offset that the mouse is from the upper-left
         corner of the item being dragged.
        """

        # we need to paint a hint rectangle to find out the exact hint rectangle,
        # we will create a new temporary layout and then measure the resulting
        # rectangle we will create a copy of the docking structures (self._docks)
        # so that we don't modify the real thing on screen

        rect = wx.Rect()
        pane = self.GetPane(pane_window)

        attrs = self.GetAttributes(pane)
        hint = AuiPaneInfo()
        hint = self.SetAttributes(hint, attrs)

        if hint.name != "__HINT__":
            self._oldname = hint.name

        hint.name = "__HINT__"
        hint.PaneBorder(True)
        hint.Show()

        if not hint.IsOk():
            hint.name = self._oldname
            return rect

        docks, panes = CopyDocksAndPanes2(self._docks, self._panes)

        # remove any pane already there which bears the same window
        # this happens when you are moving a pane around in a dock
        for ii in xrange(len(panes)):
            if panes[ii].window == pane_window:
                docks = RemovePaneFromDocks(docks, panes[ii])
                panes.pop(ii)
                break

        # find out where the new pane would be
        allow, hint = self.DoDrop(docks, panes, hint, pt, offset)

        if not allow:
            return rect

        panes.append(hint)

        sizer, panes, docks, uiparts = self.LayoutAll(panes, docks, [], True, False)

        client_size = self._frame.GetClientSize()
        sizer.SetDimension(0, 0, client_size.x, client_size.y)
        sizer.Layout()

        sought = "__HINT__"

        # For a notebook page, actually look for the notebook itself.
        if hint.IsNotebookPage():
            id = hint.notebook_id
            for pane in panes:
                if pane.IsNotebookControl() and pane.notebook_id==id:
                    sought = pane.name
                    break

        for part in uiparts:
            if part.pane and part.pane.name == sought:
                rect.Union(wx.RectPS(part.sizer_item.GetPosition(),
                                     part.sizer_item.GetSize()))

        sizer.Destroy()

        # check for floating frame ...
        if rect.IsEmpty():
            for p in panes:
                if p.name == sought and p.IsFloating():
                    return wx.RectPS(p.floating_pos, p.floating_size)

        if rect.IsEmpty():
            return rect

        # actually show the hint rectangle on the screen
        rect.x, rect.y = self._frame.ClientToScreen((rect.x, rect.y))
        if self._frame.GetLayoutDirection() == wx.Layout_RightToLeft:
            # Mirror rectangle in RTL mode
            rect.x -= rect.GetWidth()

        return rect


    def DrawHintRect(self, pane_window, pt, offset):
        """
        Calculates the hint rectangle by calling :meth:`CalculateHintRect`. If there is a
        rectangle, it shows it by calling :meth:`ShowHint`, otherwise it hides any hint
        rectangle currently shown.

        :param Window `pane_window`: it is the window pointer of the pane being dragged;
        :param Point `pt`: is the mouse position, in client coordinates;
        :param Point `offset`: describes the offset that the mouse is from the upper-left
         corner of the item being dragged.
        """

        rect = self.CalculateHintRect(pane_window, pt, offset)

        if rect.IsEmpty():
            self.HideHint()
            self._hint_rect = wx.Rect()
        else:
            self.ShowHint(rect)
            self._hint_rect = wx.Rect(*rect)


    def GetPartSizerRect(self, uiparts):
        """
        Returns the rectangle surrounding the specified UI parts.

        :param list `uiparts`: list of :class:`AuiDockUIPart` parts.
        """

        rect = wx.Rect()

        for part in self._uiparts:
            if part.pane and part.pane.name == "__HINT__":
                rect.Union(wx.RectPS(part.sizer_item.GetPosition(),
                                     part.sizer_item.GetSize()))

        return rect


    def GetAttributes(self, pane):
        """
        Returns all the attributes of a :class:`AuiPaneInfo`.

        :param `pane`: a :class:`AuiPaneInfo` instance.
        """

        attrs = []
        attrs.extend([pane.window, pane.frame, pane.state, pane.dock_direction,
                      pane.dock_layer, pane.dock_pos, pane.dock_row, pane.dock_proportion,
                      pane.floating_pos, pane.floating_size, pane.best_size,
                      pane.min_size, pane.max_size, pane.caption, pane.name,
                      pane.buttons, pane.rect, pane.icon, pane.notebook_id,
                      pane.transparent, pane.snapped, pane.minimize_mode, pane.minimize_target])

        return attrs


    def SetAttributes(self, pane, attrs):
        """
        Sets all the attributes contained in `attrs` to a :class:`AuiPaneInfo`.

        :param `pane`: a :class:`AuiPaneInfo` instance;
        :param list `attrs`: a list of attributes.
        """

        pane.window = attrs[0]
        pane.frame = attrs[1]
        pane.state = attrs[2]
        pane.dock_direction = attrs[3]
        pane.dock_layer = attrs[4]
        pane.dock_pos = attrs[5]
        pane.dock_row = attrs[6]
        pane.dock_proportion = attrs[7]
        pane.floating_pos = attrs[8]
        pane.floating_size = attrs[9]
        pane.best_size = attrs[10]
        pane.min_size = attrs[11]
        pane.max_size = attrs[12]
        pane.caption = attrs[13]
        pane.name = attrs[14]
        pane.buttons = attrs[15]
        pane.rect = attrs[16]
        pane.icon = attrs[17]
        pane.notebook_id = attrs[18]
        pane.transparent = attrs[19]
        pane.snapped = attrs[20]
        pane.minimize_mode = attrs[21]
        pane.minimize_target = attrs[22]

        return pane


    def OnFloatingPaneResized(self, wnd, size):
        """
        Handles the resizing of a floating pane.

        :param Window `wnd`: the window managed by the pane;
        :param Size `size`: the new pane floating size.
        """

        # try to find the pane
        pane = self.GetPane(wnd)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        if pane.frame:
            indx = self._panes.index(pane)
            pane.floating_pos = pane.frame.GetPosition()
            pane.floating_size = size
            self._panes[indx] = pane
            if pane.IsSnappable():
                self.SnapPane(pane, pane.floating_pos, pane.floating_size, True)


    def OnFloatingPaneClosed(self, wnd, event):
        """
        Handles the close event of a floating pane.

        :param Window `wnd`: the window managed by the pane;
        :param `event`: a :class:`CloseEvent` to be processed.
        """

        # try to find the pane
        pane = self.GetPane(wnd)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        # fire pane close event
        e = AuiManagerEvent(wxEVT_AUI_PANE_CLOSE)
        e.SetPane(pane)
        e.SetCanVeto(event.CanVeto())
        self.ProcessMgrEvent(e)

        if e.GetVeto():
            event.Veto()
            return
        else:
            # close the pane, but check that it
            # still exists in our pane array first
            # (the event handler above might have removed it)

            check = self.GetPane(wnd)
            if check.IsOk():
                self.ClosePane(pane)


    def OnFloatingPaneActivated(self, wnd):
        """
        Handles the activation event of a floating pane.

        :param Window `wnd`: the window managed by the pane.
        """

        pane = self.GetPane(wnd)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        if self.GetAGWFlags() & AUI_MGR_ALLOW_ACTIVE_PANE:
            ret, self._panes = SetActivePane(self._panes, wnd)
            self.RefreshCaptions()
            self.FireEvent(wxEVT_AUI_PANE_ACTIVATED, wnd, canVeto=False)


    def OnFloatingPaneMoved(self, wnd, eventOrPt):
        """
        Handles the move event of a floating pane.

        :param Window `wnd`: the window managed by the pane;
        :param `eventOrPt`: a :class:`MoveEvent` to be processed or an instance of :class:`Point`.
        """

        pane = self.GetPane(wnd)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        if not pane.IsSnappable():
            return

        if isinstance(eventOrPt, wx.Point):
            pane_pos = wx.Point(*eventOrPt)
        else:
            pane_pos = eventOrPt.GetPosition()

        pane_size = pane.floating_size

        self.SnapPane(pane, pane_pos, pane_size, False)


    def SnapPane(self, pane, pane_pos, pane_size, toSnap=False):
        """
        Snaps a floating pane to one of the main frame sides.

        :param `pane`: a :class:`AuiPaneInfo` instance;
        :param Point `pane_pos`: the new pane floating position;
        :param Size `pane_size`: the new pane floating size;
        :param bool `toSnap`: a bool variable to check if :meth:`SnapPane` was called from
         a move event.
        """

        if self._from_move:
            return

        managed_window = self.GetManagedWindow()
        wnd_pos = managed_window.GetPosition()
        wnd_size = managed_window.GetSize()
        snapX, snapY = self._snap_limits

        if not toSnap:
            pane.snapped = 0
            if pane.IsLeftSnappable():
                # Check if we can snap to the left
                diff = wnd_pos.x - (pane_pos.x + pane_size.x)
                if -snapX <= diff <= snapX:
                    pane.snapped = wx.LEFT
                    pane.floating_pos = wx.Point(wnd_pos.x-pane_size.x, pane_pos.y)
            elif pane.IsTopSnappable():
                # Check if we can snap to the top
                diff = wnd_pos.y - (pane_pos.y + pane_size.y)
                if -snapY <= diff <= snapY:
                    pane.snapped = wx.TOP
                    pane.floating_pos = wx.Point(pane_pos.x, wnd_pos.y-pane_size.y)
            elif pane.IsRightSnappable():
                # Check if we can snap to the right
                diff = pane_pos.x - (wnd_pos.x + wnd_size.x)
                if -snapX <= diff <= snapX:
                    pane.snapped = wx.RIGHT
                    pane.floating_pos = wx.Point(wnd_pos.x + wnd_size.x, pane_pos.y)
            elif pane.IsBottomSnappable():
                # Check if we can snap to the bottom
                diff = pane_pos.y - (wnd_pos.y + wnd_size.y)
                if -snapY <= diff <= snapY:
                    pane.snapped = wx.BOTTOM
                    pane.floating_pos = wx.Point(pane_pos.x, wnd_pos.y + wnd_size.y)

        self.RepositionPane(pane, wnd_pos, wnd_size)


    def RepositionPane(self, pane, wnd_pos, wnd_size):
        """
        Repositions a pane after the main frame has been moved/resized.

        :param `pane`: a :class:`AuiPaneInfo` instance;
        :param Point `wnd_pos`: the main frame position;
        :param Size `wnd_size`: the main frame size.
        """

        pane_pos = pane.floating_pos
        pane_size = pane.floating_size

        snap = pane.snapped
        if snap == wx.LEFT:
            floating_pos = wx.Point(wnd_pos.x - pane_size.x, pane_pos.y)
        elif snap == wx.TOP:
            floating_pos = wx.Point(pane_pos.x, wnd_pos.y - pane_size.y)
        elif snap == wx.RIGHT:
            floating_pos = wx.Point(wnd_pos.x + wnd_size.x, pane_pos.y)
        elif snap == wx.BOTTOM:
            floating_pos = wx.Point(pane_pos.x, wnd_pos.y + wnd_size.y)

        if snap:
            if pane_pos != floating_pos:
                pane.floating_pos = floating_pos
                self._from_move = True
                pane.frame.SetPosition(pane.floating_pos)
                self._from_move = False


    def OnGripperClicked(self, pane_window, start, offset):
        """
        Handles the mouse click on the pane gripper.

        :param Window `pane_window`: the window managed by the pane;
        :param Point `start`: the mouse-click position;
        :param Point `offset`: an offset point from the `start` position.
        """

        # try to find the pane
        paneInfo = self.GetPane(pane_window)

        if not paneInfo.IsOk():
            raise Exception("Pane window not found")

        if self.GetAGWFlags() & AUI_MGR_ALLOW_ACTIVE_PANE:
            # set the caption as active
            ret, self._panes = SetActivePane(self._panes, pane_window)
            self.RefreshCaptions()
            self.FireEvent(wxEVT_AUI_PANE_ACTIVATED, pane_window, canVeto=False)

        self._action_part = None
        self._action_pane = paneInfo
        self._action_window = pane_window
        self._action_start = start
        self._action_offset = offset
        self._toolbar_action_offset = wx.Point(*self._action_offset)

        self._frame.CaptureMouse()

        if paneInfo.IsDocked():
            self._action = actionClickCaption
        else:
            if paneInfo.IsToolbar():
                self._action = actionDragToolbarPane
            else:
                self._action = actionDragFloatingPane

            if paneInfo.frame:

                windowPt = paneInfo.frame.GetRect().GetTopLeft()
                originPt = paneInfo.frame.ClientToScreen(wx.Point())
                self._action_offset += originPt - windowPt
                self._toolbar_action_offset = wx.Point(*self._action_offset)

                if self._agwFlags & AUI_MGR_TRANSPARENT_DRAG:
                    paneInfo.frame.SetTransparent(150)

            if paneInfo.IsToolbar():
                self._frame.SetCursor(wx.StockCursor(wx.CURSOR_SIZING))


    def OnRender(self, event):
        """
        Draws all of the pane captions, sashes, backgrounds, captions, grippers, pane borders and buttons.
        It renders the entire user interface. It binds the ``EVT_AUI_RENDER`` event.

        :param `event`: an instance of :class:`AuiManagerEvent`.
        """

        # if the frame is about to be deleted, don't bother
        if not self._frame or self._frame.IsBeingDeleted():
            return

        if not self._frame.GetSizer():
            return

        mouse = wx.GetMouseState()
        mousePos = wx.Point(mouse.GetX(), mouse.GetY())
        point = self._frame.ScreenToClient(mousePos)
        art = self._art

        dc = event.GetDC()

        for part in self._uiparts:

            # don't draw hidden pane items or items that aren't windows
            if part.sizer_item and ((not part.sizer_item.IsWindow() and \
                                     not part.sizer_item.IsSpacer() and \
                                     not part.sizer_item.IsSizer()) or \
                                    not part.sizer_item.IsShown()):

                continue

            ptype = part.type

            # Let's not allocate a list inside a loop, inside a paint event...
            #if ptype in [AuiDockUIPart.typesDockSizer, AuiDockUIPart.typePaneSizer]:
            if ptype == AuiDockUIPart.typeDockSizer or ptype == AuiDockUIPart.typePaneSizer:
                art.DrawSash(dc, self._frame, part.orientation, part.rect)

            elif ptype == AuiDockUIPart.typeBackground:
                art.DrawBackground(dc, self._frame, part.orientation, part.rect)

            elif ptype == AuiDockUIPart.typeCaption:
                art.DrawCaption(dc, self._frame, part.pane.caption, part.rect, part.pane)

            elif ptype == AuiDockUIPart.typeGripper:
                art.DrawGripper(dc, self._frame, part.rect, part.pane)

            elif ptype == AuiDockUIPart.typePaneBorder:
                art.DrawBorder(dc, self._frame, part.rect, part.pane)

            elif ptype == AuiDockUIPart.typePaneButton:
                self.DrawPaneButton(dc, part, point)


    def Repaint(self, dc=None):
        """
        Repaints the entire frame decorations (sashes, borders, buttons and so on).
        It renders the entire user interface.

        :param `dc`: if not ``None``, an instance of :class:`PaintDC`.
        """

        w, h = self._frame.GetClientSize()

        # Figure out which dc to use; if one
        # has been specified, use it, otherwise
        # make a client dc
        if dc is None:
            client_dc = wx.ClientDC(self._frame)
            dc = client_dc

        # If the frame has a toolbar, the client area
        # origin will not be (0, 0).
        pt = self._frame.GetClientAreaOrigin()
        if pt.x != 0 or pt.y != 0:
            dc.SetDeviceOrigin(pt.x, pt.y)

        # Render all the items
        self.Render(dc)


    def Render(self, dc):
        """
        Fires a render event, which is normally handled by :meth:`OnRender`. This allows the
        render function to be overridden via the render event.

        This can be useful for painting custom graphics in the main window.
        Default behavior can be invoked in the overridden function by calling
        :meth:`OnRender`.

        :param `dc`: a :class:`DC` device context object.
        """

        e = AuiManagerEvent(wxEVT_AUI_RENDER)
        e.SetManager(self)
        e.SetDC(dc)
        self.ProcessMgrEvent(e)


    def OnCaptionDoubleClicked(self, pane_window):
        """
        Handles the mouse double click on the pane caption.

        :param Window `pane_window`: the window managed by the pane.
        """

        # try to find the pane
        paneInfo = self.GetPane(pane_window)
        if not paneInfo.IsOk():
            raise Exception("Pane window not found")

        if not paneInfo.IsFloatable() or not paneInfo.IsDockable() or \
           self._agwFlags & AUI_MGR_ALLOW_FLOATING == 0:
            return

        indx = self._panes.index(paneInfo)
        win_rect = None

        if paneInfo.IsFloating():
            if paneInfo.name.startswith("__floating__"):
                # It's a floating tab from a AuiNotebook
                notebook = paneInfo.window.__aui_notebook__
                notebook.ReDockPage(paneInfo)
                self.Update()
                return
            else:

                e = self.FireEvent(wxEVT_AUI_PANE_DOCKING, paneInfo, canVeto=True)
                if e.GetVeto():
                    self.HideHint()
                    ShowDockingGuides(self._guides, False)
                    return

                win_rect = paneInfo.frame.GetRect()
                paneInfo.Dock()
                if paneInfo.IsToolbar():
                    paneInfo = self.SwitchToolBarOrientation(paneInfo)

                e = self.FireEvent(wxEVT_AUI_PANE_DOCKED, paneInfo, canVeto=False)

        else:

            e = self.FireEvent(wxEVT_AUI_PANE_FLOATING, paneInfo, canVeto=True)
            if e.GetVeto():
                return

            # float the window
            if paneInfo.IsMaximized():
                self.RestorePane(paneInfo)

            if paneInfo.floating_pos == wx.Point(-1, -1):
                captionSize = self._art.GetMetric(AUI_DOCKART_CAPTION_SIZE)
                paneInfo.floating_pos = pane_window.GetScreenPosition()
                paneInfo.floating_pos.y -= captionSize

            paneInfo.Float()
            e = self.FireEvent(wxEVT_AUI_PANE_FLOATED, paneInfo, canVeto=False)

        self._panes[indx] = paneInfo
        self.Update()

        if win_rect and self._agwFlags & AUI_MGR_ANIMATE_FRAMES:
            paneInfo = self.GetPane(pane_window)
            pane_rect = paneInfo.window.GetScreenRect()
            self.AnimateDocking(win_rect, pane_rect)


    def OnPaint(self, event):
        """
        Handles the ``wx.EVT_PAINT`` event for :class:`AuiManager`.

        :param `event`: an instance of :class:`PaintEvent` to be processed.
        """

        dc = wx.PaintDC(self._frame)
        self.Repaint(dc)


    def OnEraseBackground(self, event):
        """
        Handles the ``wx.EVT_ERASE_BACKGROUND`` event for :class:`AuiManager`.

        :param `event`: :class:`EraseEvent` to be processed.

        :note: This is intentionally empty (excluding wxMAC) to reduce
         flickering while drawing.
        """

        if wx.Platform == "__WXMAC__":
            event.Skip()


    def OnSize(self, event):
        """
        Handles the ``wx.EVT_SIZE`` event for :class:`AuiManager`.

        :param `event`: a :class:`SizeEvent` to be processed.
        """

        skipped = False
        if isinstance(self._frame, AuiFloatingFrame) and self._frame.IsShownOnScreen():
            skipped = True
            event.Skip()

        if self._frame:

            self.DoFrameLayout()
            if wx.Platform == "__WXMAC__":
                self._frame.Refresh()
            else:
                self.Repaint()

            if isinstance(self._frame, wx.MDIParentFrame) or isinstance(self._frame, tabmdi.AuiMDIClientWindow) \
               or isinstance(self._frame, tabmdi.AuiMDIParentFrame):
                # for MDI parent frames, this event must not
                # be "skipped".  In other words, the parent frame
                # must not be allowed to resize the client window
                # after we are finished processing sizing changes
                return

        if not skipped:
            event.Skip()

        # For the snap to screen...
        self.OnMove(None)


    def OnFindManager(self, event):
        """
        Handles the ``EVT_AUI_FIND_MANAGER`` event for :class:`AuiManager`.

        :param `event`: a :class:`AuiManagerEvent` event to be processed.
        """

        # Initialize to None
        event.SetManager(None)

        if not self._frame:
            return

        # See it this window wants to overwrite
        self._frame.ProcessEvent(event)

        # if no, it must be us
        if not event.GetManager():
           event.SetManager(self)


    def OnSetCursor(self, event):
        """
        Handles the ``wx.EVT_SET_CURSOR`` event for :class:`AuiManager`.

        :param `event`: a :class:`SetCursorEvent` to be processed.
        """

        # determine cursor
        part = self.HitTest(event.GetX(), event.GetY())
        cursor = wx.NullCursor

        if part:
            if part.type in [AuiDockUIPart.typeDockSizer, AuiDockUIPart.typePaneSizer]:

                if not self.CheckMovableSizer(part):
                    return

                if part.orientation == wx.VERTICAL:
                    cursor = wx.StockCursor(wx.CURSOR_SIZEWE)
                else:
                    cursor = wx.StockCursor(wx.CURSOR_SIZENS)

            elif part.type == AuiDockUIPart.typeGripper:
                cursor = wx.StockCursor(wx.CURSOR_SIZING)

        event.SetCursor(cursor)


    def UpdateButtonOnScreen(self, button_ui_part, event):
        """
        Updates/redraws the UI part containing a pane button.

        :param AuiDockUIPart `button_ui_part`: the UI part the button belongs to;
        :param `event`: a :class:`MouseEvent` to be processed.
        """

        hit_test = self.HitTest(*event.GetPosition())

        if not hit_test or not button_ui_part:
            return

        state = AUI_BUTTON_STATE_NORMAL

        if hit_test == button_ui_part:
            if event.LeftDown():
                state = AUI_BUTTON_STATE_PRESSED
            else:
                state = AUI_BUTTON_STATE_HOVER
        else:
            if event.LeftDown():
                state = AUI_BUTTON_STATE_HOVER

        # now repaint the button with hover state
        cdc = wx.ClientDC(self._frame)

        # if the frame has a toolbar, the client area
        # origin will not be (0,0).
        pt = self._frame.GetClientAreaOrigin()
        if pt.x != 0 or pt.y != 0:
            cdc.SetDeviceOrigin(pt.x, pt.y)

        if hit_test.pane:
            self._art.DrawPaneButton(cdc, self._frame,
                      button_ui_part.button.button_id,
                      state,
                      button_ui_part.rect, hit_test.pane)


    def OnLeftDown(self, event):
        """
        Handles the ``wx.EVT_LEFT_DOWN`` event for :class:`AuiManager`.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        part = self.HitTest(*event.GetPosition())

        if not part:
            event.Skip()
            return

        self._currentDragItem = -1

        if part.type in [AuiDockUIPart.typeDockSizer, AuiDockUIPart.typePaneSizer]:

            if not self.CheckMovableSizer(part):
                return

            self._action = actionResize
            self._action_part = part
            self._action_pane = None
            self._action_rect = wx.Rect()
            self._action_start = wx.Point(event.GetX(), event.GetY())
            self._action_offset = wx.Point(event.GetX() - part.rect.x,
                                           event.GetY() - part.rect.y)

            # draw the resize hint
            rect = wx.RectPS(self._frame.ClientToScreen(part.rect.GetPosition()),
                             part.rect.GetSize())

            self._action_rect = wx.Rect(*rect)

            if not AuiManager_HasLiveResize(self):
                if wx.Platform == "__WXMAC__":
                    dc = wx.ClientDC(self._frame)
                else:
                    dc = wx.ScreenDC()

                DrawResizeHint(dc, rect)

            self._frame.CaptureMouse()

        elif part.type == AuiDockUIPart.typePaneButton:
            if self.IsPaneButtonVisible(part):
                self._action = actionClickButton
                self._action_part = part
                self._action_pane = None
                self._action_start = wx.Point(*event.GetPosition())
                self._frame.CaptureMouse()

                self.RefreshButton(part)

        elif part.type in [AuiDockUIPart.typeCaption, AuiDockUIPart.typeGripper]:

            # if we are managing a AuiFloatingFrame window, then
            # we are an embedded AuiManager inside the AuiFloatingFrame.
            # We want to initiate a toolbar drag in our owner manager
            if isinstance(part.pane.window.GetParent(), AuiFloatingFrame):
                rootManager = GetManager(part.pane.window)
            else:
                rootManager = self

            offset = wx.Point(event.GetX() - part.rect.x, event.GetY() - part.rect.y)
            rootManager.OnGripperClicked(part.pane.window, event.GetPosition(), offset)

        if wx.Platform != "__WXMAC__":
            event.Skip()


    def OnLeftDClick(self, event):
        """
        Handles the ``wx.EVT_LEFT_DCLICK`` event for :class:`AuiManager`.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        part = self.HitTest(event.GetX(), event.GetY())

        if part and part.type == AuiDockUIPart.typeCaption:
            if isinstance(part.pane.window.GetParent(), AuiFloatingFrame):
                rootManager = GetManager(part.pane.window)
            else:
                rootManager = self

            rootManager.OnCaptionDoubleClicked(part.pane.window)

        elif part and part.type in [AuiDockUIPart.typeDockSizer, AuiDockUIPart.typePaneSizer]:
            # Handles double click on AuiNotebook sashes to unsplit
            sash_size = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)
            for child in part.cont_sizer.GetChildren():
                if child.IsSizer():
                    win = child.GetSizer().GetContainingWindow()
                    if isinstance(win, auibook.AuiNotebook):
                        win.UnsplitDClick(part, sash_size, event.GetPosition())
                        break

        event.Skip()


    def DoEndResizeAction(self, event):
        """
        Ends a resize action, or for live update, resizes the sash.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        clientPt = event.GetPosition()
        screenPt = self._frame.ClientToScreen(clientPt)

        return self.RestrictResize(clientPt, screenPt, createDC=False)


    def RestrictResize(self, clientPt, screenPt, createDC):
        """ Common method between :meth:`DoEndResizeAction` and :meth:`OnLeftUp_Resize`. """

        dock = self._action_part.dock
        pane = self._action_part.pane

        if createDC:
            if wx.Platform == "__WXMAC__":
                dc = wx.ClientDC(self._frame)
            else:
                dc = wx.ScreenDC()

            DrawResizeHint(dc, self._action_rect)
            self._action_rect = wx.Rect()

        newPos = clientPt - self._action_offset

        if self._action_part.type == AuiDockUIPart.typeDockSizer:
            minPix, maxPix = self.CalculateDockSizerLimits(dock)
        else:
            if not self._action_part.pane:
                return
            minPix, maxPix = self.CalculatePaneSizerLimits(dock, pane)

        if self._action_part.orientation == wx.HORIZONTAL:
            newPos.y = Clip(newPos.y, minPix, maxPix)
        else:
            newPos.x = Clip(newPos.x, minPix, maxPix)

        if self._action_part.type == AuiDockUIPart.typeDockSizer:

            partnerDock = self.GetPartnerDock(dock)
            sash_size = self._art.GetMetric(AUI_DOCKART_SASH_SIZE)
            new_dock_size = 0
            direction = dock.dock_direction

            if direction == AUI_DOCK_LEFT:
                new_dock_size = newPos.x - dock.rect.x

            elif direction == AUI_DOCK_TOP:
                new_dock_size = newPos.y - dock.rect.y

            elif direction == AUI_DOCK_RIGHT:
                new_dock_size = dock.rect.x + dock.rect.width - newPos.x - sash_size

            elif direction == AUI_DOCK_BOTTOM:
                new_dock_size = dock.rect.y + dock.rect.height - newPos.y - sash_size

            deltaDockSize = new_dock_size - dock.size

            if partnerDock:
                if deltaDockSize > partnerDock.size - sash_size:
                    deltaDockSize = partnerDock.size - sash_size

                partnerDock.size -= deltaDockSize

            dock.size += deltaDockSize
            self.Update()

        else:

            # determine the new pixel size that the user wants
            # this will help us recalculate the pane's proportion
            if dock.IsHorizontal():
                oldPixsize = pane.rect.width
                newPixsize = oldPixsize + newPos.x - self._action_part.rect.x

            else:
                oldPixsize = pane.rect.height
                newPixsize = oldPixsize + newPos.y - self._action_part.rect.y

            totalPixsize, totalProportion = self.GetTotalPixSizeAndProportion(dock)
            partnerPane = self.GetPartnerPane(dock, pane)

            # prevent division by zero
            if totalPixsize <= 0 or totalProportion <= 0 or not partnerPane:
                return

            # adjust for the surplus
            while (oldPixsize > 0 and totalPixsize > 10 and \
                  oldPixsize*totalProportion/totalPixsize < pane.dock_proportion):

                totalPixsize -= 1

            # calculate the new proportion of the pane

            newProportion = newPixsize*totalProportion/totalPixsize
            newProportion = Clip(newProportion, 1, totalProportion)
            deltaProp = newProportion - pane.dock_proportion

            if partnerPane.dock_proportion - deltaProp < 1:
                deltaProp = partnerPane.dock_proportion - 1
                newProportion = pane.dock_proportion + deltaProp

            # borrow the space from our neighbor pane to the
            # right or bottom (depending on orientation)
            partnerPane.dock_proportion -= deltaProp
            pane.dock_proportion = newProportion

            self.Update()

        return True


    def OnLeftUp(self, event):
        """
        Handles the ``wx.EVT_LEFT_UP`` event for :class:`AuiManager`.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        if self._action == actionResize:
##            self._frame.Freeze()
            self.OnLeftUp_Resize(event)
##            self._frame.Thaw()

        elif self._action == actionClickButton:
            self.OnLeftUp_ClickButton(event)

        elif self._action == actionDragFloatingPane:
            self.OnLeftUp_DragFloatingPane(event)

        elif self._action == actionDragToolbarPane:
            self.OnLeftUp_DragToolbarPane(event)

        elif self._action == actionDragMovablePane:
            self.OnLeftUp_DragMovablePane(event)

        else:
            event.Skip()

        try:
            if self._frame.HasCapture():
                self._frame.ReleaseMouse()
        except wx.PyDeadObjectError:
            pass

        self._action = actionNone


    def OnMotion(self, event):
        """
        Handles the ``wx.EVT_MOTION`` event for :class:`AuiManager`.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        if self._action == actionResize:
            self.OnMotion_Resize(event)

        elif self._action == actionClickCaption:
            self.OnMotion_ClickCaption(event)

        elif self._action == actionDragFloatingPane:
            self.OnMotion_DragFloatingPane(event)

        elif self._action == actionDragToolbarPane:
            self.OnMotion_DragToolbarPane(event)

        elif self._action == actionDragMovablePane:
            self.OnMotion_DragMovablePane(event)

        else:
            self.OnMotion_Other(event)


    def OnLeaveWindow(self, event):
        """
        Handles the ``wx.EVT_LEAVE_WINDOW`` event for :class:`AuiManager`.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        if self._hover_button:
            self.RefreshButton(self._hover_button)
            self._hover_button = None


    def OnCaptureLost(self, event):
        """
        Handles the ``wx.EVT_MOUSE_CAPTURE_LOST`` event for :class:`AuiManager`.

        :param `event`: a :class:`MouseCaptureLostEvent` to be processed.
        """

        # cancel the operation in progress, if any
        if self._action != actionNone:
            self._action = actionNone
            self.HideHint()


    def OnHintFadeTimer(self, event):
        """
        Handles the ``wx.EVT_TIMER`` event for :class:`AuiManager`.

        :param `event`: a :class:`TimerEvent` to be processed.
        """

        if not self._hint_window or self._hint_fadeamt >= self._hint_fademax:
            self._hint_fadetimer.Stop()
            return

        self._hint_fadeamt += 4
        self._hint_window.SetTransparent(self._hint_fadeamt)


    def OnMove(self, event):
        """
        Handles the ``wx.EVT_MOVE`` event for :class:`AuiManager`.

        :param `event`: a :class:`MoveEvent` to be processed.
        """

        if event is not None:
            event.Skip()

        if isinstance(self._frame, AuiFloatingFrame) and self._frame.IsShownOnScreen():
            return

        docked, hAlign, vAlign, monitor = self._is_docked
        if docked:
            self.Snap()

        for pane in self._panes:
            if pane.IsSnappable():
                if pane.IsFloating() and pane.IsShown():
                    self.SnapPane(pane, pane.floating_pos, pane.floating_size, True)


    def OnSysColourChanged(self, event):
        """
        Handles the ``wx.EVT_SYS_COLOUR_CHANGED`` event for :class:`AuiManager`.

        :param `event`: a :class:`SysColourChangedEvent` to be processed.
        """

        # This event is probably triggered by a theme change
        # so we have to re-init the art provider.
        if self._art:
            self._art.Init()

        if self._frame:
            self.Update()
            self._frame.Refresh()


    def OnChildFocus(self, event):
        """
        Handles the ``wx.EVT_CHILD_FOCUS`` event for :class:`AuiManager`.

        :param `event`: a :class:`ChildFocusEvent` to be processed.
        """

        # when a child pane has it's focus set, we should change the
        # pane's active state to reflect this. (this is only true if
        # active panes are allowed by the owner)

        window = event.GetWindow()
        if isinstance(window, wx.Dialog):
            # Ignore EVT_CHILD_FOCUS events originating from dialogs not
            # managed by AUI
            rootManager = None
        elif isinstance(window.GetParent(), AuiFloatingFrame):
            rootManager = GetManager(window)
        else:
            rootManager = self

        if rootManager:
            rootManager.ActivatePane(window)

        event.Skip()


    def OnMotion_ClickCaption(self, event):
        """
        Sub-handler for the :meth:`OnMotion` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        clientPt = event.GetPosition()
        screenPt = self._frame.ClientToScreen(clientPt)

        drag_x_threshold = wx.SystemSettings.GetMetric(wx.SYS_DRAG_X)
        drag_y_threshold = wx.SystemSettings.GetMetric(wx.SYS_DRAG_Y)

        if not self._action_pane:
            return

        # we need to check if the mouse is now being dragged
        if not (abs(clientPt.x - self._action_start.x) > drag_x_threshold or \
                abs(clientPt.y - self._action_start.y) > drag_y_threshold):

            return

        # dragged -- we need to change the mouse action to 'drag'
        if self._action_pane.IsToolbar():
            self._action = actionDragToolbarPane
            self._action_window = self._action_pane.window

        elif self._action_pane.IsFloatable() and self._agwFlags & AUI_MGR_ALLOW_FLOATING:

            e = self.FireEvent(wxEVT_AUI_PANE_FLOATING, self._action_pane, canVeto=True)
            if e.GetVeto():
                return

            self._action = actionDragFloatingPane

            # set initial float position
            self._action_pane.floating_pos = screenPt - self._action_offset

            # float the window
            if self._action_pane.IsMaximized():
                self.RestorePane(self._action_pane)

            self._action_pane.Hide()
            self._action_pane.Float()
            if wx.Platform == "__WXGTK__":
                self._action_pane.Show()

            e = self.FireEvent(wxEVT_AUI_PANE_FLOATED, self._action_pane, canVeto=False)

            if not self._action_pane.frame:
                self.Update()

            self._action_window = self._action_pane.window

            # adjust action offset for window frame
            windowPt = self._action_pane.frame.GetRect().GetTopLeft()
            originPt = self._action_pane.frame.ClientToScreen(wx.Point())
            self._toolbar_action_offset = originPt - windowPt

            if self._agwFlags & AUI_MGR_USE_NATIVE_MINIFRAMES:
                originPt = windowPt + wx.Point(3, 3)

            self._action_offset += originPt - windowPt

            # action offset is used here to make it feel "natural" to the user
            # to drag a docked pane and suddenly have it become a floating frame.
            # Sometimes, however, the offset where the user clicked on the docked
            # caption is bigger than the width of the floating frame itself, so
            # in that case we need to set the action offset to a sensible value
            frame_size = self._action_pane.frame.GetSize()
            if self._action_offset.x > frame_size.x * 2 / 3:
                self._action_offset.x = frame_size.x / 2
            if self._action_offset.y > frame_size.y * 2 / 3:
                self._action_offset.y = frame_size.y / 2

            self.OnMotion_DragFloatingPane(event)
            if wx.Platform != "__WXGTK__":
                self._action_pane.Show()

            self.Update()

        elif self._action_pane.IsMovable():
            self._action = actionDragMovablePane
            self._action_window = self._action_pane.window


    def OnMotion_Resize(self, event):
        """
        Sub-handler for the :meth:`OnMotion` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        if AuiManager_HasLiveResize(self):
            if self._currentDragItem != -1:
                self._action_part = self._uiparts[self._currentDragItem]
            else:
                self._currentDragItem = self._uiparts.index(self._action_part)

            if self._frame.HasCapture():
                self._frame.ReleaseMouse()

            self.DoEndResizeAction(event)
            self._frame.CaptureMouse()
            return

        if not self._action_part or not self._action_part.dock or not self._action_part.orientation:
            return

        clientPt = event.GetPosition()
        screenPt = self._frame.ClientToScreen(clientPt)

        dock = self._action_part.dock
        pos = self._action_part.rect.GetPosition()

        if self._action_part.type == AuiDockUIPart.typeDockSizer:
            minPix, maxPix = self.CalculateDockSizerLimits(dock)
        else:
            if not self._action_part.pane:
                return

            pane = self._action_part.pane
            minPix, maxPix = self.CalculatePaneSizerLimits(dock, pane)

        if self._action_part.orientation == wx.HORIZONTAL:
            pos.y = Clip(clientPt.y - self._action_offset.y, minPix, maxPix)
        else:
            pos.x = Clip(clientPt.x - self._action_offset.x, minPix, maxPix)

        hintrect = wx.RectPS(self._frame.ClientToScreen(pos), self._action_part.rect.GetSize())

        if hintrect != self._action_rect:

            if wx.Platform == "__WXMAC__":
                dc = wx.ClientDC(self._frame)
            else:
                dc = wx.ScreenDC()

            DrawResizeHint(dc, self._action_rect)
            DrawResizeHint(dc, hintrect)
            self._action_rect = wx.Rect(*hintrect)


    def OnLeftUp_Resize(self, event):
        """
        Sub-handler for the :meth:`OnLeftUp` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        if self._currentDragItem != -1 and AuiManager_HasLiveResize(self):
            self._action_part = self._uiparts[self._currentDragItem]

            if self._frame.HasCapture():
                self._frame.ReleaseMouse()

            self.DoEndResizeAction(event)
            self._currentDragItem = -1
            return

        if not self._action_part or not self._action_part.dock:
            return

        clientPt = event.GetPosition()
        screenPt = self._frame.ClientToScreen(clientPt)

        return self.RestrictResize(clientPt, screenPt, createDC=True)


    def OnLeftUp_ClickButton(self, event):
        """
        Sub-handler for the :meth:`OnLeftUp` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        self._hover_button = None

        if self._action_part:
            self.RefreshButton(self._action_part)

            # make sure we're still over the item that was originally clicked
            if self._action_part == self.HitTest(*event.GetPosition()):

                # fire button-click event
                e = AuiManagerEvent(wxEVT_AUI_PANE_BUTTON)
                e.SetManager(self)
                e.SetPane(self._action_part.pane)
                e.SetButton(self._action_part.button.button_id)
                self.ProcessMgrEvent(e)


    def CheckPaneMove(self, pane):
        """
        Checks if a pane has moved by a visible amount.

        :param `pane`: an instance of :class:`AuiPaneInfo`.
        """

        win_rect = pane.frame.GetRect()
        win_rect.x, win_rect.y = pane.floating_pos

        if win_rect == self._last_rect:
            return False

        # skip the first move event
        if self._last_rect.IsEmpty():
            self._last_rect = wx.Rect(*win_rect)
            return False

        # skip if moving too fast to avoid massive redraws and
        # jumping hint windows
        if abs(win_rect.x - self._last_rect.x) > 10 or \
           abs(win_rect.y - self._last_rect.y) > 10:
            self._last_rect = wx.Rect(*win_rect)
            return False

        return True


    def OnMotion_DragFloatingPane(self, eventOrPt):
        """
        Sub-handler for the :meth:`OnMotion` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        isPoint = False
        if isinstance(eventOrPt, wx.Point):
            clientPt = self._frame.ScreenToClient(eventOrPt)
            screenPt = wx.Point(*eventOrPt)
            isPoint = True
        else:
            clientPt = eventOrPt.GetPosition()
            screenPt = self._frame.ClientToScreen(clientPt)

        framePos = wx.Point()

        # try to find the pane
        pane = self.GetPane(self._action_window)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        # update floating position
        if pane.IsFloating():
            diff = pane.floating_pos - (screenPt - self._action_offset)
            pane.floating_pos = screenPt - self._action_offset

        framePos = pane.floating_pos

        # Move the pane window
        if pane.frame:

            if diff.x != 0 or diff.y != 0:
                if wx.Platform == "__WXMSW__" and (self._agwFlags & AUI_MGR_TRANSPARENT_DRAG) == 0: # and not self.CheckPaneMove(pane):
                    # return
                    # HACK: Terrible hack on wxMSW (!)
                    pane.frame.SetTransparent(254)

                self._from_move = True
                pane.frame.Move(pane.floating_pos)
                self._from_move = False

            if self._agwFlags & AUI_MGR_TRANSPARENT_DRAG:
                pane.frame.SetTransparent(150)

        # calculate the offset from the upper left-hand corner
        # of the frame to the mouse pointer
        action_offset = screenPt - framePos

        # is the pane dockable?
        if not self.CanDockPanel(pane):
            self.HideHint()
            ShowDockingGuides(self._guides, False)
            return

        for paneInfo in self._panes:

            if not paneInfo.IsDocked() or not paneInfo.IsShown():
                continue
            if paneInfo.IsToolbar() or paneInfo.IsNotebookControl():
                continue
            if paneInfo.IsMaximized():
                continue

            if paneInfo.IsNotebookPage():

                notebookRoot = GetNotebookRoot(self._panes, paneInfo.notebook_id)

                if not notebookRoot or not notebookRoot.IsDocked():
                    continue

            rc = paneInfo.window.GetScreenRect()
            if rc.Contains(screenPt):
                if rc.height < 20 or rc.width < 20:
                    return

                self.UpdateDockingGuides(paneInfo)
                ShowDockingGuides(self._guides, True)
                break

        self.DrawHintRect(pane.window, clientPt, action_offset)


    def OnMotion_DragMovablePane(self, eventOrPt):
        """
        Sub-handler for the :meth:`OnMotion` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        # Try to find the pane.
        pane = self.GetPane(self._action_window)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        # Draw a hint for where the window will be moved.
        if isinstance(eventOrPt, wx.Point):
            pt = wx.Point(*eventOrPt)
        else:
            pt = eventOrPt.GetPosition()

        self.DrawHintRect(self._action_window, pt, wx.Point(0, 0))

        # Reduces flicker.
        self._frame.Update()


    def OnLeftUp_DragFloatingPane(self, eventOrPt):
        """
        Sub-handler for the :meth:`OnLeftUp` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        if isinstance(eventOrPt, wx.Point):
            clientPt = self._frame.ScreenToClient(eventOrPt)
            screenPt = wx.Point(*eventOrPt)
        else:
            clientPt = eventOrPt.GetPosition()
            screenPt = self._frame.ClientToScreen(clientPt)

        # try to find the pane
        paneInfo = self.GetPane(self._action_window)
        if not paneInfo.IsOk():
            raise Exception("Pane window not found")

        ret = False

        if paneInfo.frame:

            # calculate the offset from the upper left-hand corner
            # of the frame to the mouse pointer
            framePos = paneInfo.frame.GetPosition()
            action_offset = screenPt - framePos

            # is the pane dockable?
            if self.CanDockPanel(paneInfo):
                # do the drop calculation
                indx = self._panes.index(paneInfo)
                ret, paneInfo = self.DoDrop(self._docks, self._panes, paneInfo, clientPt, action_offset)

                if ret:
                    e = self.FireEvent(wxEVT_AUI_PANE_DOCKING, paneInfo, canVeto=True)
                    if e.GetVeto():
                        self.HideHint()
                        ShowDockingGuides(self._guides, False)
                        return

                    e = self.FireEvent(wxEVT_AUI_PANE_DOCKED, paneInfo, canVeto=False)

                    if self._agwFlags & AUI_MGR_SMOOTH_DOCKING:
                        self.SmoothDock(paneInfo)

                self._panes[indx] = paneInfo

        # if the pane is still floating, update it's floating
        # position (that we store)
        if paneInfo.IsFloating():
            paneInfo.floating_pos = paneInfo.frame.GetPosition()
            if paneInfo.frame._transparent != paneInfo.transparent or self._agwFlags & AUI_MGR_TRANSPARENT_DRAG:
                paneInfo.frame.SetTransparent(paneInfo.transparent)
                paneInfo.frame._transparent = paneInfo.transparent

        elif self._has_maximized:
            self.RestoreMaximizedPane()

        # reorder for dropping to a new notebook
        # (caution: this code breaks the reference!)
        tempPaneInfo = self.CopyTarget(paneInfo)
        self._panes.remove(paneInfo)
        self._panes.append(tempPaneInfo)

        if ret:
            self.Update()

        if tempPaneInfo.IsFloating():
            self.SnapPane(tempPaneInfo, tempPaneInfo.floating_pos, tempPaneInfo.floating_size, False)

        self.HideHint()
        ShowDockingGuides(self._guides, False)


    def OnLeftUp_DragMovablePane(self, event):
        """
        Sub-handler for the :meth:`OnLeftUp` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        # Try to find the pane.
        paneInfo = self.GetPane(self._action_window)
        if not paneInfo.IsOk():
            raise Exception("Pane window not found")

        # Hide the hint as it is no longer needed.
        self.HideHint()

        # is the pane dockable?
        if self.CanDockPanel(paneInfo):
            # Move the pane to new position.
            pt = event.GetPosition()
            # do the drop calculation
            indx = self._panes.index(paneInfo)
            ret, paneInfo = self.DoDrop(self._docks, self._panes, paneInfo, pt, wx.Point(0,0))

            if ret:
                e = self.FireEvent(wxEVT_AUI_PANE_DOCKING, paneInfo, canVeto=True)
                if e.GetVeto():
                    self.HideHint()
                    ShowDockingGuides(self._guides, False)
                    return

                e = self.FireEvent(wxEVT_AUI_PANE_DOCKED, paneInfo, canVeto=False)

                if self._agwFlags & AUI_MGR_SMOOTH_DOCKING:
                    self.SmoothDock(paneInfo)

            self._panes[indx] = paneInfo

            if ret:
                # Update the layout to realize new position and e.g. form notebooks if needed.
                self.Update()

        if self.GetAGWFlags() & AUI_MGR_ALLOW_ACTIVE_PANE:
            # Ensure active before doing actual display.
            ret, self._panes = SetActivePane(self._panes, paneInfo.window)

        # Make changes visible to user.
        self.Repaint()

        # Cancel the action and release the mouse.
        self._action = actionNone
        self._frame.ReleaseMouse()
        self._action_window = None


    def OnMotion_DragToolbarPane(self, eventOrPt):
        """
        Sub-handler for the :meth:`OnMotion` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        isPoint = False
        if isinstance(eventOrPt, wx.Point):
            clientPt = self._frame.ScreenToClient(eventOrPt)
            screenPt = wx.Point(*eventOrPt)
            isPoint = True
        else:
            clientPt = eventOrPt.GetPosition()
            screenPt = self._frame.ClientToScreen(clientPt)

        pane = self.GetPane(self._action_window)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        pane.state |= AuiPaneInfo.actionPane
        indx = self._panes.index(pane)

        ret = False
        wasFloating = pane.IsFloating()
        # is the pane dockable?
        if self.CanDockPanel(pane):
            # do the drop calculation
            ret, pane = self.DoDrop(self._docks, self._panes, pane, clientPt, self._action_offset)

        # update floating position
        if pane.IsFloating():
            pane.floating_pos = screenPt - self._toolbar_action_offset

        # move the pane window
        if pane.frame:
            if wx.Platform == "__WXMSW__" and (self._agwFlags & AUI_MGR_TRANSPARENT_DRAG) == 0: # and not self.CheckPaneMove(pane):
                # return
                # HACK: Terrible hack on wxMSW (!)
                pane.frame.SetTransparent(254)

            self._from_move = True
            pane.frame.Move(pane.floating_pos)
            self._from_move = False

            if self._agwFlags & AUI_MGR_TRANSPARENT_DRAG:
                pane.frame.SetTransparent(150)

        self._panes[indx] = pane
        if ret and wasFloating != pane.IsFloating() or (ret and not wasFloating):
            wx.CallAfter(self.Update)

        # when release the button out of the window.
        # TODO: a better fix is needed.

        if _VERSION_STRING < "2.9":
            leftDown = wx.GetMouseState().LeftDown()
        else:
            leftDown = wx.GetMouseState().LeftIsDown()

        if not leftDown:
            self._action = actionNone
            self.OnLeftUp_DragToolbarPane(eventOrPt)


    def OnMotion_Other(self, event):
        """
        Sub-handler for the :meth:`OnMotion` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        part = self.HitTest(*event.GetPosition())

        if part and part.type == AuiDockUIPart.typePaneButton \
           and self.IsPaneButtonVisible(part):
            if part != self._hover_button:

                if self._hover_button:
                    self.RefreshButton(self._hover_button)

                self._hover_button = part
                self.RefreshButton(part)

        else:

            if self._hover_button:
                self.RefreshButton(self._hover_button)
            else:
                event.Skip()

            self._hover_button = None


    def OnLeftUp_DragToolbarPane(self, eventOrPt):
        """
        Sub-handler for the :meth:`OnLeftUp` event.

        :param `event`: a :class:`MouseEvent` to be processed.
        """

        isPoint = False
        if isinstance(eventOrPt, wx.Point):
            clientPt = self._frame.ScreenToClient(eventOrPt)
            screenPt = wx.Point(*eventOrPt)
            isPoint = True
        else:
            clientPt = eventOrPt.GetPosition()
            screenPt = self._frame.ClientToScreen(clientPt)

        # try to find the pane
        pane = self.GetPane(self._action_window)
        if not pane.IsOk():
            raise Exception("Pane window not found")

        if pane.IsFloating():
            pane.floating_pos = pane.frame.GetPosition()
            if pane.frame._transparent != pane.transparent or self._agwFlags & AUI_MGR_TRANSPARENT_DRAG:
                pane.frame.SetTransparent(pane.transparent)
                pane.frame._transparent = pane.transparent

        # save the new positions
        docks = FindDocks(self._docks, pane.dock_direction, pane.dock_layer, pane.dock_row)
        if len(docks) == 1:
            dock = docks[0]
            pane_positions, pane_sizes = self.GetPanePositionsAndSizes(dock)

            for i in xrange(len(dock.panes)):
                dock.panes[i].dock_pos = pane_positions[i]

        pane.state &= ~AuiPaneInfo.actionPane
        self.Update()


    def OnPaneButton(self, event):
        """
        Handles the ``EVT_AUI_PANE_BUTTON`` event for :class:`AuiManager`.

        :param `event`: a :class:`AuiManagerEvent` event to be processed.
        """

        if not event.pane:
            raise Exception("Pane Info passed to AuiManager.OnPaneButton must be non-null")

        pane = event.pane

        if event.button == AUI_BUTTON_CLOSE:

            if isinstance(pane.window.GetParent(), AuiFloatingFrame):
                rootManager = GetManager(pane.window)
            else:
                rootManager = self

            if rootManager != self:
                self._frame.Close()
                return

            # fire pane close event
            e = AuiManagerEvent(wxEVT_AUI_PANE_CLOSE)
            e.SetManager(self)
            e.SetPane(event.pane)
            self.ProcessMgrEvent(e)

            if not e.GetVeto():

                # close the pane, but check that it
                # still exists in our pane array first
                # (the event handler above might have removed it)
                check = self.GetPane(pane.window)
                if check.IsOk():
                    # Use the checked pane, because the ui part which 
                    # emitted this event may actually have a pane that's 
                    # different from the panes in self._panes. This seems
                    # to be a fairly endemic problem with this framework.
                    self.ClosePane(check)

                self.Update()

        # mn this performs the minimizing of a pane
        elif event.button == AUI_BUTTON_MINIMIZE:
            e = AuiManagerEvent(wxEVT_AUI_PANE_MINIMIZE)
            e.SetManager(self)
            e.SetPane(event.pane)
            self.ProcessMgrEvent(e)

            if not e.GetVeto():
                self.MinimizePane(pane)

        elif event.button == AUI_BUTTON_MAXIMIZE_RESTORE and not pane.IsMaximized():

            # fire pane close event
            e = AuiManagerEvent(wxEVT_AUI_PANE_MAXIMIZE)
            e.SetManager(self)
            e.SetPane(event.pane)
            self.ProcessMgrEvent(e)

            if not e.GetVeto():

                self.MaximizePane(pane)
                self.Update()

        elif event.button == AUI_BUTTON_MAXIMIZE_RESTORE and pane.IsMaximized():

            # fire pane close event
            e = AuiManagerEvent(wxEVT_AUI_PANE_RESTORE)
            e.SetManager(self)
            e.SetPane(event.pane)
            self.ProcessMgrEvent(e)

            if not e.GetVeto():

                self.RestorePane(pane)
                self.Update()

        elif event.button == AUI_BUTTON_PIN:

            if self._agwFlags & AUI_MGR_ALLOW_FLOATING and pane.IsFloatable():
                e = self.FireEvent(wxEVT_AUI_PANE_FLOATING, pane, canVeto=True)
                if e.GetVeto():
                    return

                pane.Float()
                e = self.FireEvent(wxEVT_AUI_PANE_FLOATED, pane, canVeto=False)

            self.Update()


    def MinimizePane(self, paneInfo, mgrUpdate=True):
        """
        Minimizes a pane in a newly and automatically created :class:`~lib.agw.aui.auibar.AuiToolBar`.

        Clicking on the minimize button causes a new :class:`~lib.agw.aui.auibar.AuiToolBar` to be created
        and added to the frame manager (currently the implementation is such that
        panes at West will have a toolbar at the right, panes at South will have
        toolbars at the bottom etc...) and the pane is hidden in the manager.

        Clicking on the restore button on the newly created toolbar will result in the
        toolbar being removed and the original pane being restored.

        :param `paneInfo`: a :class:`AuiPaneInfo` instance for the pane to be minimized;
        :param bool `mgrUpdate`: ``True`` to call :meth:`Update` to realize the new layout,
         ``False`` otherwise.

        .. note::

           The `mgrUpdate` parameter is currently only used while loading perspectives using
           :meth:`LoadPerspective`, as minimized panes were not correctly taken into account before.

        """

        if not paneInfo.IsToolbar():

            if paneInfo.IsMinimized() and mgrUpdate:
                # We are already minimized
                return

            # Basically the idea is this.
            #
            # 1) create a toolbar, with a restore button
            #
            # 2) place the new toolbar in the toolbar area representative of the location of the pane
            #  (NORTH/SOUTH/EAST/WEST, central area always to the right)
            #
            # 3) Hide the minimizing pane

            # personalize the toolbar style

            tbStyle = AUI_TB_DEFAULT_STYLE
            posMask = paneInfo.minimize_mode & AUI_MINIMIZE_POS_MASK
            captMask = paneInfo.minimize_mode & AUI_MINIMIZE_CAPT_MASK
            dockDirection = paneInfo.dock_direction
            if captMask != 0:
                tbStyle |= AUI_TB_TEXT

            if posMask == AUI_MINIMIZE_POS_TOOLBAR:
                minimize_toolbar = self.GetPane(paneInfo.minimize_target)
                if not minimize_toolbar.IsOk():
                    posMask = AUI_MINIMIZE_POS_SMART
                    if paneInfo.dock_direction in [AUI_DOCK_TOP, AUI_DOCK_BOTTOM]:
                        tbStyle |= AUI_TB_HORZ_LAYOUT

                    elif paneInfo.dock_direction in [AUI_DOCK_LEFT, AUI_DOCK_RIGHT, AUI_DOCK_CENTER]:
                        tbStyle |= AUI_TB_VERTICAL
                        if captMask == AUI_MINIMIZE_CAPT_SMART:
                            tbStyle |= AUI_TB_CLOCKWISE
                else:
                    minimize_toolbar = minimize_toolbar.window

            elif posMask == AUI_MINIMIZE_POS_SMART:
                if paneInfo.dock_direction in [AUI_DOCK_TOP, AUI_DOCK_BOTTOM]:
                    tbStyle |= AUI_TB_HORZ_LAYOUT

                elif paneInfo.dock_direction in [AUI_DOCK_LEFT, AUI_DOCK_RIGHT, AUI_DOCK_CENTER]:
                    tbStyle |= AUI_TB_VERTICAL
                    if captMask == AUI_MINIMIZE_CAPT_SMART:
                        tbStyle |= AUI_TB_CLOCKWISE

            elif posMask in [AUI_MINIMIZE_POS_TOP, AUI_MINIMIZE_POS_BOTTOM]:
                tbStyle |= AUI_TB_HORZ_LAYOUT
                if posMask == AUI_MINIMIZE_POS_TOP:
                    dockDirection = AUI_DOCK_TOP
                else:
                    dockDirection = AUI_DOCK_BOTTOM

            else:
                tbStyle |= AUI_TB_VERTICAL
                if captMask == AUI_MINIMIZE_CAPT_SMART:
                    tbStyle |= AUI_TB_CLOCKWISE
                if posMask == AUI_MINIMIZE_POS_LEFT:
                    dockDirection = AUI_DOCK_LEFT
                elif posMask == AUI_MINIMIZE_POS_RIGHT:
                    dockDirection = AUI_DOCK_RIGHT
                elif posMask == AUI_MINIMIZE_POS_BOTTOM:
                    dockDirection = AUI_DOCK_BOTTOM

            # Create a new toolbar
            # give it the same name as the minimized pane with _min appended

            win_rect = paneInfo.window.GetScreenRect()

            if posMask != AUI_MINIMIZE_POS_TOOLBAR:
                minimize_toolbar = auibar.AuiToolBar(self.GetManagedWindow(), agwStyle=tbStyle)
                minimize_toolbar.Hide()
                minimize_toolbar.SetToolBitmapSize(wx.Size(16, 16))

            if paneInfo.icon and paneInfo.icon.IsOk():
                restore_bitmap = paneInfo.icon
            else:
                restore_bitmap = self._art._restore_bitmap

            if posMask == AUI_MINIMIZE_POS_TOOLBAR:
                xsize, ysize = minimize_toolbar.GetToolBitmapSize()
                if xsize != restore_bitmap.GetWidth():
                    img = restore_bitmap.ConvertToImage()
                    img.Rescale(xsize, ysize, wx.IMAGE_QUALITY_HIGH)
                    restore_bitmap = img.ConvertToBitmap()

            target = None
            if posMask == AUI_MINIMIZE_POS_TOOLBAR:
                target = paneInfo.name

            minimize_toolbar.AddSimpleTool(ID_RESTORE_FRAME, paneInfo.caption, restore_bitmap,
                                           _(u"Restore %s")%paneInfo.caption, target=target)
            minimize_toolbar.SetAuiManager(self)
            minimize_toolbar.Realize()
            toolpanelname = paneInfo.name + "_min"

            if paneInfo.IsMaximized():
                paneInfo.SetFlag(paneInfo.wasMaximized, True)

            if posMask != AUI_MINIMIZE_POS_TOOLBAR:

                if dockDirection == AUI_DOCK_TOP:
                    self.AddPane(minimize_toolbar, AuiPaneInfo(). \
                        Name(toolpanelname).Caption(paneInfo.caption). \
                        ToolbarPane().Top().BottomDockable(False). \
                        LeftDockable(False).RightDockable(False).DestroyOnClose())

                elif dockDirection == AUI_DOCK_BOTTOM:
                    self.AddPane(minimize_toolbar, AuiPaneInfo(). \
                        Name(toolpanelname).Caption(paneInfo.caption). \
                        ToolbarPane().Bottom().TopDockable(False). \
                        LeftDockable(False).RightDockable(False).DestroyOnClose())

                elif dockDirection == AUI_DOCK_LEFT:
                    self.AddPane(minimize_toolbar, AuiPaneInfo(). \
                        Name(toolpanelname).Caption(paneInfo.caption). \
                        ToolbarPane().Left().TopDockable(False). \
                        BottomDockable(False).RightDockable(False).DestroyOnClose())

                elif dockDirection in [AUI_DOCK_RIGHT, AUI_DOCK_CENTER]:
                    self.AddPane(minimize_toolbar, AuiPaneInfo(). \
                        Name(toolpanelname).Caption(paneInfo.caption). \
                        ToolbarPane().Right().TopDockable(False). \
                        LeftDockable(False).BottomDockable(False).DestroyOnClose())

            arr = FindDocks(self._docks, paneInfo.dock_direction, paneInfo.dock_layer, paneInfo.dock_row)

            if arr:
                dock = arr[0]
                paneInfo.previousDockSize = dock.size

            paneInfo.previousDockPos = paneInfo.dock_pos

            # mark ourselves minimized
            paneInfo.Minimize()
            paneInfo.Show(False)
            self._has_minimized = True
            # last, hide the window
            if paneInfo.window and paneInfo.window.IsShown():
                paneInfo.window.Show(False)

            minimize_toolbar.Show()

            if mgrUpdate:
                self.Update()
                if self._agwFlags & AUI_MGR_ANIMATE_FRAMES:
                    self.AnimateDocking(win_rect, minimize_toolbar.GetScreenRect())


    def OnRestoreMinimizedPane(self, event):
        """
        Handles the ``EVT_AUI_PANE_MIN_RESTORE`` event for :class:`AuiManager`.

        :param `event`: an instance of :class:`AuiManagerEvent` to be processed.
        """

        self.RestoreMinimizedPane(event.pane)


    def OnPaneDocked(self, event):
        """
        Handles the ``EVT_AUI_PANE_DOCKED`` event for :class:`AuiManager`.

        :param `event`: an instance of :class:`AuiManagerEvent` to be processed.
        """

        event.Skip()
        self.RemoveAutoNBCaption(event.GetPane())


    def CreateNotebookBase(self, panes, paneInfo):
        """
        Creates an auto-notebook base from a pane, and then add that pane as a page.

        :param list `panes`: set of panes to append new notebook base pane to
        :param AuiPaneInfo `paneInfo`: the pane to be converted to a new notebook.
        """

        # Create base notebook pane ...
        nbid = len(self._notebooks)

        baseInfo = AuiPaneInfo()
        baseInfo.SetDockPos(paneInfo).NotebookControl(nbid). \
            CloseButton(False).SetNameFromNotebookId(). \
            NotebookDockable(False).Floatable(paneInfo.IsFloatable())
        baseInfo.best_size = paneInfo.best_size
        panes.append(baseInfo)

        # add original pane as tab ...
        paneInfo.NotebookPage(nbid)


    def RemoveAutoNBCaption(self, pane):
        """
        Removes the caption on newly created automatic notebooks.

        :param `pane`: an instance of :class:`AuiPaneInfo` (the target notebook).
        """

        if self._agwFlags & AUI_MGR_AUTONB_NO_CAPTION == 0:
            return False

        def RemoveCaption():
            """ Sub-function used to remove the pane caption on automatic notebooks. """

            if pane.HasNotebook():
                notebook = self._notebooks[pane.notebook_id]
                self.GetPane(notebook).CaptionVisible(False).PaneBorder(False)
                self.Update()

        # it seems the notebook isnt created by this stage, so remove
        # the caption a moment later
        wx.CallAfter(RemoveCaption)
        return True


    def RestoreMinimizedPane(self, paneInfo):
        """
        Restores a previously minimized pane.

        :param `paneInfo`: a :class:`AuiPaneInfo` instance for the pane to be restored.
        """

        panename = paneInfo.name

        if paneInfo.minimize_mode & AUI_MINIMIZE_POS_TOOLBAR:
            pane = self.GetPane(panename)
            hasTarget = True
        else:
            panename = panename[0:-4]
            hasTarget = False

        pane = self.GetPane(panename)
        pane.SetFlag(pane.needsRestore, True)

        if not pane.IsOk():
            panename = paneInfo.name
            pane = self.GetPane(panename)
            paneInfo = self.GetPane(panename + "_min")
            if not paneInfo.IsOk():
                # Already minimized
                return

        if pane.IsOk():
            if not pane.IsMinimized():
                return


            if pane.HasFlag(pane.wasMaximized):
                self.SavePreviousDockSizes(pane)

            self.ShowPane(pane.window, True)
            pane.Show(True)
            self._has_minimized = False
            pane.SetFlag(pane.optionMinimized, False)

            if hasTarget:
                targetName = pane.minimize_target
                toolbarPane = self.GetPane(targetName)
                toolbar = toolbarPane.window
                item = toolbar.FindToolByLabel(pane.caption)
                toolbar.DeleteTool(item.id)
            else:
                paneInfo.window.Show(False)
                self.DetachPane(paneInfo.window)
                paneInfo.Show(False)
                paneInfo.Hide()

            self.Update()


    def AnimateDocking(self, win_rect, pane_rect):
        """
        Animates the minimization/docking of a pane a la Eclipse, using a :class:`ScreenDC`
        to draw a "moving docking rectangle" on the screen.

        :param Rect `win_rect`: the original pane screen rectangle;
        :param Rect `pane_rect`: the newly created toolbar/pane screen rectangle.

        :note: This functionality is not available on wxMAC as this platform doesn't have
         the ability to use :class:`ScreenDC` to draw on-screen and on Windows > Vista.
        """

        if wx.Platform == "__WXMAC__":
            # No wx.ScreenDC on the Mac...
            return
        if wx.Platform == "__WXMSW__" and wx.GetOsVersion()[1] > 5:
            # No easy way to handle this on Vista...
            return

        xstart, ystart = win_rect.x, win_rect.y
        xend, yend = pane_rect.x, pane_rect.y

        step = self.GetAnimationStep()

        wstep = int(abs(win_rect.width - pane_rect.width)/step)
        hstep = int(abs(win_rect.height - pane_rect.height)/step)
        xstep = int(win_rect.x - pane_rect.x)/step
        ystep = int(win_rect.y - pane_rect.y)/step

        dc = wx.ScreenDC()
        dc.SetLogicalFunction(wx.INVERT)
        dc.SetBrush(wx.TRANSPARENT_BRUSH)
        dc.SetPen(wx.LIGHT_GREY_PEN)

        for i in xrange(int(step)):
            width, height = win_rect.width - i*wstep, win_rect.height - i*hstep
            x, y = xstart - i*xstep, ystart - i*ystep
            new_rect = wx.Rect(x, y, width, height)
            dc.DrawRoundedRectangleRect(new_rect, 3)
            wx.SafeYield()
            wx.MilliSleep(10)
            dc.DrawRoundedRectangleRect(new_rect, 3)


    def SmoothDock(self, paneInfo):
        """
        This method implements a smooth docking effect for floating panes, similar to
        what the PyQT library does with its floating windows.

        :param `paneInfo`: an instance of :class:`AuiPaneInfo`.

        :note: The smooth docking effect can only be used if you set the ``AUI_MGR_SMOOTH_DOCKING``
         style to :class:`AuiManager`.
        """

        if paneInfo.IsToolbar():
            return

        if not paneInfo.frame or self._hint_rect.IsEmpty():
            return

        hint_rect = self._hint_rect
        win_rect = paneInfo.frame.GetScreenRect()

        xstart, ystart = win_rect.x, win_rect.y
        xend, yend = hint_rect.x, hint_rect.y

        step = self.GetAnimationStep()/3

        wstep = int((win_rect.width - hint_rect.width)/step)
        hstep = int((win_rect.height - hint_rect.height)/step)
        xstep = int((win_rect.x - hint_rect.x))/step
        ystep = int((win_rect.y - hint_rect.y))/step

        for i in xrange(int(step)):
            width, height = win_rect.width - i*wstep, win_rect.height - i*hstep
            x, y = xstart - i*xstep, ystart - i*ystep
            new_rect = wx.Rect(x, y, width, height)
            paneInfo.frame.SetRect(new_rect)
            wx.MilliSleep(10)


    def SetSnapLimits(self, x, y):
        """
        Modifies the snap limits used when snapping the `managed_window` to the screen
        (using :meth:`SnapToScreen`) or when snapping the floating panes to one side of the
        `managed_window` (using :meth:`SnapPane`).

        To change the limit after which the `managed_window` or the floating panes are
        automatically stickled to the screen border (or to the `managed_window` side),
        set these two variables. Default values are 15 pixels.

        :param integer `x`: the minimum horizontal distance below which the snap occurs;
        :param integer `y`: the minimum vertical distance below which the snap occurs.
        """

        self._snap_limits = (x, y)
        self.Snap()


    def Snap(self):
        """
        Snaps the main frame to specified position on the screen.

        :see: :meth:`SnapToScreen`
        """

        snap, hAlign, vAlign, monitor = self._is_docked
        if not snap:
            return

        managed_window = self.GetManagedWindow()
        snap_pos = self.GetSnapPosition()
        wnd_pos = managed_window.GetPosition()
        snapX, snapY = self._snap_limits

        if abs(snap_pos.x - wnd_pos.x) < snapX and abs(snap_pos.y - wnd_pos.y) < snapY:
            managed_window.SetPosition(snap_pos)


    def SnapToScreen(self, snap=True, monitor=0, hAlign=wx.RIGHT, vAlign=wx.TOP):
        """
        Snaps the main frame to specified position on the screen.

        :param bool `snap`: whether to snap the main frame or not;
        :param integer `monitor`: the monitor display in which snapping the window;
        :param integer `hAlign`: the horizontal alignment of the snapping position;
        :param integer `vAlign`: the vertical alignment of the snapping position.
        """

        if not snap:
            self._is_docked = (False, wx.RIGHT, wx.TOP, 0)
            return

        displayCount = wx.Display.GetCount()
        if monitor > displayCount:
            raise Exception("Invalid monitor selected: you only have %d monitors"%displayCount)

        self._is_docked = (True, hAlign, vAlign, monitor)
        self.GetManagedWindow().SetPosition(self.GetSnapPosition())


    def GetSnapPosition(self):
        """ Returns the main frame snapping position. """

        snap, hAlign, vAlign, monitor = self._is_docked

        display = wx.Display(monitor)
        area = display.GetClientArea()
        size = self.GetManagedWindow().GetSize()

        pos = wx.Point()
        if hAlign == wx.LEFT:
            pos.x = area.x
        elif hAlign == wx.CENTER:
            pos.x = area.x + (area.width - size.x)/2
        else:
            pos.x = area.x + area.width - size.x

        if vAlign == wx.TOP:
            pos.y = area.y
        elif vAlign == wx.CENTER:
            pos.y = area.y + (area.height - size.y)/2
        else:
            pos.y = area.y + area.height - size.y

        return pos


    def GetAnimationStep(self):
        """ Returns the animation step speed (a float) to use in :meth:`AnimateDocking`. """

        return self._animation_step


    def SetAnimationStep(self, step):
        """
        Sets the animation step speed (a float) to use in :meth:`AnimateDocking`.

        :param float `step`: the animation speed.
        """

        self._animation_step = float(step)


    def RequestUserAttention(self, pane_window):
        """
        Requests the user attention by intermittently highlighting the pane caption.

        :param Window `pane_window`: the window managed by the pane;
        """

        # try to find the pane
        paneInfo = self.GetPane(pane_window)
        if not paneInfo.IsOk():
            raise Exception("Pane window not found")

        dc = wx.ClientDC(self._frame)

        # if the frame is about to be deleted, don't bother
        if not self._frame or self._frame.IsBeingDeleted():
            return

        if not self._frame.GetSizer():
            return

        for part in self._uiparts:
            if part.pane == paneInfo:
                self._art.RequestUserAttention(dc, self._frame, part.pane.caption, part.rect, part.pane)
                self._frame.RefreshRect(part.rect, True)
                break


    def StartPreviewTimer(self, toolbar):
        """
        Starts a timer for sliding in and out a minimized pane.

        :param `toolbar`: the :class:`~lib.agw.aui.auibar.AuiToolBar` containing the minimized pane tool.
        """

        toolbar_pane = self.GetPane(toolbar)
        toolbar_name = toolbar_pane.name

        pane_name = toolbar_name[0:-4]

        self._sliding_pane = self.GetPane(pane_name)
        self._sliding_rect = toolbar.GetScreenRect()
        self._sliding_direction = toolbar_pane.dock_direction
        self._sliding_frame = None

        self._preview_timer.Start(1000, wx.TIMER_ONE_SHOT)


    def StopPreviewTimer(self):
        """ Stops a timer for sliding in and out a minimized pane. """

        if self._preview_timer.IsRunning():
            self._preview_timer.Stop()

        self.SlideOut()
        self._sliding_pane = None


    def SlideIn(self, event):
        """
        Handles the ``wx.EVT_TIMER`` event for :class:`AuiManager`.

        :param `event`: a :class:`TimerEvent` to be processed.

        :note: This is used solely for sliding in and out minimized panes.
        """

        window = self._sliding_pane.window
        self._sliding_frame = wx.MiniFrame(None, -1, title=_("Pane Preview"),
                                           style=wx.FRAME_TOOL_WINDOW | wx.STAY_ON_TOP |
                                           wx.FRAME_NO_TASKBAR | wx.CAPTION)
        window.Reparent(self._sliding_frame)
        self._sliding_frame.SetSize((0, 0))
        window.Show()
        self._sliding_frame.Show()

        size = window.GetBestSize()

        startX, startY, stopX, stopY = GetSlidingPoints(self._sliding_rect, size, self._sliding_direction)

        step = stopX/10
        window_size = 0

        for i in xrange(0, stopX, step):
            window_size = i
            self._sliding_frame.SetDimensions(startX, startY, window_size, stopY)
            self._sliding_frame.Refresh()
            self._sliding_frame.Update()
            wx.MilliSleep(10)

        self._sliding_frame.SetDimensions(startX, startY, stopX, stopY)
        self._sliding_frame.Refresh()
        self._sliding_frame.Update()


    def SlideOut(self):
        """
        Slides out a preview of a minimized pane.

        :note: This is used solely for sliding in and out minimized panes.
        """

        if not self._sliding_frame:
            return

        window = self._sliding_frame.GetChildren()[0]
        size = window.GetBestSize()

        startX, startY, stopX, stopY = GetSlidingPoints(self._sliding_rect, size, self._sliding_direction)

        step = stopX/10
        window_size = 0

        for i in xrange(stopX, 0, -step):
            window_size = i
            self._sliding_frame.SetDimensions(startX, startY, window_size, stopY)
            self._sliding_frame.Refresh()
            self._sliding_frame.Update()
            self._frame.RefreshRect(wx.Rect(startX+window_size, startY, step, stopY))
            self._frame.Update()
            wx.MilliSleep(10)

        self._sliding_frame.SetDimensions(startX, startY, 0, stopY)

        window.Hide()
        window.Reparent(self._frame)

        self._sliding_frame.Hide()
        self._sliding_frame.Destroy()
        self._sliding_frame = None
        self._sliding_pane = None


class AuiManager_DCP(AuiManager):
    """
    A class similar to :class:`AuiManager` but with a Dummy Center Pane (**DCP**).
    The code for this class is still flickery due to the call to :func:`CallAfter`
    and the double-update call.
    """

    def __init__(self, *args, **keys):
        """ See :meth:`AuiManager.__init__` for the class construction. """

        AuiManager.__init__(self, *args, **keys)
        self.hasDummyPane = False


    def _createDummyPane(self):
        """ Creates a Dummy Center Pane (**DCP**). """

        if self.hasDummyPane:
            return

        self.hasDummyPane = True
        dummy = wx.Panel(self.GetManagedWindow())
        info = AuiPaneInfo().CenterPane().NotebookDockable(True).Name('dummyCenterPane').DestroyOnClose(True)
        self.AddPane(dummy, info)


    def _destroyDummyPane(self):
        """ Destroys the Dummy Center Pane (**DCP**). """

        if not self.hasDummyPane:
            return

        self.hasDummyPane = False
        self.ClosePane(self.GetPane('dummyCenterPane'))


    def Update(self):
        """
        This method is called after any number of changes are made to any of the
        managed panes. :meth:`Update` must be invoked after :meth:`AuiManager.AddPane` or
        :meth:`AuiManager.InsertPane` are called in order to "realize" or "commit" the changes.

        In addition, any number of changes may be made to :class:`AuiManager` structures
        (retrieved with :meth:`AuiManager.GetPane`), but to realize the changes,
        :meth:`Update` must be called. This construction allows pane flicker to
        be avoided by updating the whole layout at one time.
        """
        AuiManager.Update(self)

        # check if there's already a center pane (except our dummy pane)
        dummyCenterPane = self.GetPane('dummyCenterPane')
        haveCenterPane = any((pane != dummyCenterPane) and (pane.dock_direction == AUI_DOCK_CENTER) and
                             not pane.IsFloating() and pane.IsShown() for pane in self.GetAllPanes())
        if haveCenterPane:
            if self.hasDummyPane:
                # there's our dummy pane and also another center pane, therefor let's remove our dummy
                def do():
                    self._destroyDummyPane()
                    self.Update()
                wx.CallAfter(do)
        else:
            # if we get here, there's no center pane, create our dummy
            if not self.hasDummyPane:
                self._createDummyPane()



########NEW FILE########
__FILENAME__ = tabart
"""
Tab art provider code - a tab provider provides all drawing functionality to
the :class:`~lib.agw.aui.auibook.AuiNotebook`. This allows the
:class:`~lib.agw.aui.auibook.AuiNotebook` to have a plugable look-and-feel.

By default, a :class:`~lib.agw.aui.auibook.AuiNotebook` uses an instance of this class
called :class:`AuiDefaultTabArt` which provides bitmap art and a colour scheme that is
adapted to the major platforms' look. You can either derive from that class to alter its
behaviour or write a completely new tab art class.
Call :meth:`AuiNotebook.SetArtProvider() <lib.agw.aui.auibook.AuiNotebook.SetArtProvider>`
to make use this new tab art.
"""

__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx

if wx.Platform == '__WXMAC__':
    import Carbon.Appearance

from aui_utilities import BitmapFromBits, StepColour, IndentPressedBitmap, ChopText
from aui_utilities import GetBaseColour, DrawMACCloseButton, LightColour, TakeScreenShot
from aui_utilities import CopyAttributes

from aui_constants import *


# -- GUI helper classes and functions --
class AuiCommandCapture(wx.PyEvtHandler):
    """ A class to handle the dropdown window menu. """

    def __init__(self):
        """ Default class constructor. """

        wx.PyEvtHandler.__init__(self)        
        self._last_id = 0


    def GetCommandId(self):
        """ Returns the event command identifier. """

        return self._last_id 


    def ProcessEvent(self, event):
        """
        Processes an event, searching event tables and calling zero or more suitable
        event handler function(s).

        :param `event`: the event to process.

        :note: Normally, your application would not call this function: it is called
         in the wxPython implementation to dispatch incoming user interface events
         to the framework (and application).
         However, you might need to call it if implementing new functionality (such as
         a new control) where you define new event types, as opposed to allowing the
         user to override functions.

         An instance where you might actually override the :meth:`ProcessEvent` function is where
         you want to direct event processing to event handlers not normally noticed by
         wxPython. For example, in the document/view architecture, documents and views
         are potential event handlers. When an event reaches a frame, :meth:`ProcessEvent` will
         need to be called on the associated document and view in case event handler
         functions are associated with these objects. 

         The normal order of event table searching is as follows:

         1. If the object is disabled (via a call to :meth:`EvtHandler.SetEvtHandlerEnabled`) the function
            skips to step (6).
         2. If the object is a :class:`Window`, :meth:`ProcessEvent` is recursively called on the window's 
            :class:`Validator`. If this returns ``True``, the function exits.
         3. wxWidgets `SearchEventTable` is called for this event handler. If this fails, the
            base class table is tried, and so on until no more tables exist or an appropriate
            function was found, in which case the function exits.
         4. The search is applied down the entire chain of event handlers (usually the chain
            has a length of one). If this succeeds, the function exits.
         5. If the object is a :class:`Window` and the event is a :class:`CommandEvent`, :meth:`ProcessEvent` is
            recursively applied to the parent window's event handler. If this returns ``True``,
            the function exits.
         6. Finally, :meth:`ProcessEvent` is called on the :class:`App` object.
        """
        
        if event.GetEventType() == wx.wxEVT_COMMAND_MENU_SELECTED:
            self._last_id = event.GetId()
            return True
        
        if self.GetNextHandler():
            return self.GetNextHandler().ProcessEvent(event)

        return False
    

class AuiDefaultTabArt(object):
    """
    Tab art provider code - a tab provider provides all drawing functionality to the :class:`~lib.agw.aui.auibook.AuiNotebook`.
    This allows the :class:`~lib.agw.aui.auibook.AuiNotebook` to have a plugable look-and-feel.

    By default, a :class:`~lib.agw.aui.auibook.AuiNotebook` uses an instance of this class called
    :class:`AuiDefaultTabArt` which provides bitmap art and a colour scheme that is adapted to the major platforms'
    look. You can either derive from that class to alter its behaviour or write a
    completely new tab art class. Call :meth:`AuiNotebook.SetArtProvider() <lib.agw.aui.auibook.AuiNotebook.SetArtProvider>` to make use this
    new tab art.
    """
    
    def __init__(self):
        """ Default class constructor. """

        self._normal_font = wx.SystemSettings_GetFont(wx.SYS_DEFAULT_GUI_FONT)
        self._selected_font = wx.SystemSettings_GetFont(wx.SYS_DEFAULT_GUI_FONT)
        self._selected_font.SetWeight(wx.BOLD)
        self._measuring_font = self._selected_font

        self._fixed_tab_width = 100
        self._tab_ctrl_height = 0
        self._buttonRect = wx.Rect()

        self.SetDefaultColours()

        if wx.Platform == "__WXMAC__":
            bmp_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DDKSHADOW)
            self._active_close_bmp = DrawMACCloseButton(bmp_colour)
            self._disabled_close_bmp = DrawMACCloseButton(wx.Colour(128, 128, 128))
        else:
            self._active_close_bmp = BitmapFromBits(nb_close_bits, 16, 16, wx.BLACK)
            self._disabled_close_bmp = BitmapFromBits(nb_close_bits, 16, 16, wx.Colour(128, 128, 128))

        self._hover_close_bmp = self._active_close_bmp
        self._pressed_close_bmp = self._active_close_bmp

        self._active_left_bmp = BitmapFromBits(nb_left_bits, 16, 16, wx.BLACK)
        self._disabled_left_bmp = BitmapFromBits(nb_left_bits, 16, 16, wx.Colour(128, 128, 128))

        self._active_right_bmp = BitmapFromBits(nb_right_bits, 16, 16, wx.BLACK)
        self._disabled_right_bmp = BitmapFromBits(nb_right_bits, 16, 16, wx.Colour(128, 128, 128))

        self._active_windowlist_bmp = BitmapFromBits(nb_list_bits, 16, 16, wx.BLACK)
        self._disabled_windowlist_bmp = BitmapFromBits(nb_list_bits, 16, 16, wx.Colour(128, 128, 128))

        if wx.Platform == "__WXMAC__":
            # Get proper highlight colour for focus rectangle from the
            # current Mac theme.  kThemeBrushFocusHighlight is
            # available on Mac OS 8.5 and higher
            if hasattr(wx, 'MacThemeColour'):
                c = wx.MacThemeColour(Carbon.Appearance.kThemeBrushFocusHighlight)
            else:
                brush = wx.Brush(wx.BLACK)
                brush.MacSetTheme(Carbon.Appearance.kThemeBrushFocusHighlight)
                c = brush.GetColour()
            self._focusPen = wx.Pen(c, 2, wx.SOLID)
        else:
            self._focusPen = wx.Pen(wx.BLACK, 1, wx.USER_DASH)
            self._focusPen.SetDashes([1, 1])
            self._focusPen.SetCap(wx.CAP_BUTT)
            
            
    def SetBaseColour(self, base_colour):
        """
        Sets a new base colour.

        :param `base_colour`: an instance of :class:`Colour`.
        """
        
        self._base_colour = base_colour
        self._base_colour_pen = wx.Pen(self._base_colour)
        self._base_colour_brush = wx.Brush(self._base_colour)


    def SetDefaultColours(self, base_colour=None):
        """
        Sets the default colours, which are calculated from the given base colour.

        :param `base_colour`: an instance of :class:`Colour`. If defaulted to ``None``, a colour
         is generated accordingly to the platform and theme.
        """

        if base_colour is None:
            base_colour = GetBaseColour()

        self.SetBaseColour( base_colour )
        self._border_colour = StepColour(base_colour, 75)
        self._border_pen = wx.Pen(self._border_colour)

        self._background_top_colour = StepColour(self._base_colour, 90)
        self._background_bottom_colour = StepColour(self._base_colour, 170)
        
        self._tab_top_colour = self._base_colour
        self._tab_bottom_colour = wx.WHITE
        self._tab_gradient_highlight_colour = wx.WHITE

        self._tab_inactive_top_colour = self._base_colour
        self._tab_inactive_bottom_colour = StepColour(self._tab_inactive_top_colour, 160)
        
        self._tab_text_colour = lambda page: page.text_colour
        self._tab_disabled_text_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT)


    def Clone(self):
        """ Clones the art object. """

        art = type(self)()
        art.SetNormalFont(self.GetNormalFont())
        art.SetSelectedFont(self.GetSelectedFont())
        art.SetMeasuringFont(self.GetMeasuringFont())

        art = CopyAttributes(art, self)
        return art


    def SetAGWFlags(self, agwFlags):
        """
        Sets the tab art flags.

        :param integer `agwFlags`: a combination of the following values:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet.
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet.
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close :class:`~lib.agw.aui.auibook.AuiNotebook` tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by :class:`~lib.agw.aui.framemanager.AuiManager` to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less
                                              full screen, tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ``AUI_NB_ORDER_BY_ACCESS``           Tab navigation order by last access time for the tabs
         ``AUI_NB_NO_TAB_FOCUS``              Don't draw tab focus rectangle
         ==================================== ==================================
        
        """

        self._agwFlags = agwFlags


    def GetAGWFlags(self):
        """
        Returns the tab art flags.

        :see: :meth:`~AuiDefaultTabArt.SetAGWFlags` for a list of possible return values.
        """

        return self._agwFlags
    
            
    def SetSizingInfo(self, tab_ctrl_size, tab_count, minMaxTabWidth):
        """
        Sets the tab sizing information.
        
        :param Size `tab_ctrl_size`: the size of the tab control area;
        :param integer `tab_count`: the number of tabs;
        :param tuple `minMaxTabWidth`: a tuple containing the minimum and maximum tab widths
         to be used when the ``AUI_NB_TAB_FIXED_WIDTH`` style is active.
        """
        
        self._fixed_tab_width = 100
        minTabWidth, maxTabWidth = minMaxTabWidth

        tot_width = tab_ctrl_size.x - self.GetIndentSize() - 4
        agwFlags = self.GetAGWFlags()
        
        if agwFlags & AUI_NB_CLOSE_BUTTON:
            tot_width -= self._active_close_bmp.GetWidth()
        if agwFlags & AUI_NB_WINDOWLIST_BUTTON:
            tot_width -= self._active_windowlist_bmp.GetWidth()

        if tab_count > 0:
            self._fixed_tab_width = tot_width/tab_count

        if self._fixed_tab_width < 100:
            self._fixed_tab_width = 100

        if self._fixed_tab_width > tot_width/2:
            self._fixed_tab_width = tot_width/2

        if self._fixed_tab_width > 220:
            self._fixed_tab_width = 220

        if minTabWidth > -1:
            self._fixed_tab_width = max(self._fixed_tab_width, minTabWidth)
        if maxTabWidth > -1:
            self._fixed_tab_width = min(self._fixed_tab_width, maxTabWidth)

        self._tab_ctrl_height = tab_ctrl_size.y
    

    def DrawBackground(self, dc, wnd, rect):
        """
        Draws the tab area background.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param Rect `rect`: the tab control rectangle.
        """

        self._buttonRect = wx.Rect()

        # draw background
        agwFlags = self.GetAGWFlags()
        if agwFlags & AUI_NB_BOTTOM:
            r = wx.Rect(rect.x, rect.y, rect.width+2, rect.height)

        # TODO: else if (agwFlags & AUI_NB_LEFT) 
        # TODO: else if (agwFlags & AUI_NB_RIGHT) 
        else: #for AUI_NB_TOP
            r = wx.Rect(rect.x, rect.y, rect.width+2, rect.height-3)

        dc.GradientFillLinear(r, self._background_top_colour, self._background_bottom_colour, wx.SOUTH)

        # draw base lines

        dc.SetPen(self._border_pen)
        y = rect.GetHeight()
        w = rect.GetWidth()

        if agwFlags & AUI_NB_BOTTOM:
            dc.SetBrush(wx.Brush(self._background_bottom_colour))
            dc.DrawRectangle(-1, 0, w+2, 4)

        # TODO: else if (agwFlags & AUI_NB_LEFT) 
        # TODO: else if (agwFlags & AUI_NB_RIGHT)
        
        else: # for AUI_NB_TOP
            dc.SetBrush(self._base_colour_brush)
            dc.DrawRectangle(-1, y-4, w+2, 4)


    def DrawTab(self, dc, wnd, page, in_rect, close_button_state, paint_control=False):
        """
        Draws a single tab.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param `page`: the tab control page associated with the tab;
        :param Rect `in_rect`: rectangle the tab should be confined to;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param bool `paint_control`: whether to draw the control inside a tab (if any) on a :class:`MemoryDC`.
        """

        # if the caption is empty, measure some temporary text
        caption = page.caption
        if not caption:
            caption = "Xj"

        dc.SetFont(self._selected_font)
        selected_textx, selected_texty, dummy = dc.GetMultiLineTextExtent(caption)

        dc.SetFont(self._normal_font)
        normal_textx, normal_texty, dummy = dc.GetMultiLineTextExtent(caption)

        control = page.control

        # figure out the size of the tab
        tab_size, x_extent = self.GetTabSize(dc, wnd, page.caption, page.bitmap,
                                             page.active, close_button_state, control)

        tab_height = self._tab_ctrl_height - 3
        tab_width = tab_size[0]
        tab_x = in_rect.x
        tab_y = in_rect.y + in_rect.height - tab_height

        caption = page.caption

        # select pen, brush and font for the tab to be drawn

        if page.active:
        
            dc.SetFont(self._selected_font)
            textx, texty = selected_textx, selected_texty
        
        else:
        
            dc.SetFont(self._normal_font)
            textx, texty = normal_textx, normal_texty

        if not page.enabled:
            dc.SetTextForeground(self._tab_disabled_text_colour)
            pagebitmap = page.dis_bitmap
        else:
            dc.SetTextForeground(self._tab_text_colour(page))
            pagebitmap = page.bitmap
            
        # create points that will make the tab outline

        clip_width = tab_width
        if tab_x + clip_width > in_rect.x + in_rect.width:
            clip_width = in_rect.x + in_rect.width - tab_x

        # since the above code above doesn't play well with WXDFB or WXCOCOA,
        # we'll just use a rectangle for the clipping region for now --
        dc.SetClippingRegion(tab_x, tab_y, clip_width+1, tab_height-3)

        border_points = [wx.Point() for i in xrange(6)]
        agwFlags = self.GetAGWFlags()
        
        if agwFlags & AUI_NB_BOTTOM:
        
            border_points[0] = wx.Point(tab_x,             tab_y)
            border_points[1] = wx.Point(tab_x,             tab_y+tab_height-6)
            border_points[2] = wx.Point(tab_x+2,           tab_y+tab_height-4)
            border_points[3] = wx.Point(tab_x+tab_width-2, tab_y+tab_height-4)
            border_points[4] = wx.Point(tab_x+tab_width,   tab_y+tab_height-6)
            border_points[5] = wx.Point(tab_x+tab_width,   tab_y)
        
        else: #if (agwFlags & AUI_NB_TOP) 
        
            border_points[0] = wx.Point(tab_x,             tab_y+tab_height-4)
            border_points[1] = wx.Point(tab_x,             tab_y+2)
            border_points[2] = wx.Point(tab_x+2,           tab_y)
            border_points[3] = wx.Point(tab_x+tab_width-2, tab_y)
            border_points[4] = wx.Point(tab_x+tab_width,   tab_y+2)
            border_points[5] = wx.Point(tab_x+tab_width,   tab_y+tab_height-4)
        
        # TODO: else if (agwFlags & AUI_NB_LEFT) 
        # TODO: else if (agwFlags & AUI_NB_RIGHT) 

        drawn_tab_yoff = border_points[1].y
        drawn_tab_height = border_points[0].y - border_points[1].y

        if page.active:
        
            # draw active tab

            # draw base background colour
            r = wx.Rect(tab_x, tab_y, tab_width, tab_height)
            dc.SetPen(self._base_colour_pen)
            dc.SetBrush(self._base_colour_brush)
            dc.DrawRectangle(r.x+1, r.y+1, r.width-1, r.height-4)

            # this white helps fill out the gradient at the top of the tab
            dc.SetPen( wx.Pen(self._tab_gradient_highlight_colour) )
            dc.SetBrush( wx.Brush(self._tab_gradient_highlight_colour) )
            dc.DrawRectangle(r.x+2, r.y+1, r.width-3, r.height-4)

            # these two points help the rounded corners appear more antialiased
            dc.SetPen(self._base_colour_pen)
            dc.DrawPoint(r.x+2, r.y+1)
            dc.DrawPoint(r.x+r.width-2, r.y+1)

            # set rectangle down a bit for gradient drawing
            r.SetHeight(r.GetHeight()/2)
            r.x += 2
            r.width -= 2
            r.y += r.height
            r.y -= 2

            # draw gradient background
            top_colour = self._tab_bottom_colour
            bottom_colour = self._tab_top_colour
            dc.GradientFillLinear(r, bottom_colour, top_colour, wx.NORTH)
        
        else:
        
            # draw inactive tab

            r = wx.Rect(tab_x, tab_y+1, tab_width, tab_height-3)

            # start the gradent up a bit and leave the inside border inset
            # by a pixel for a 3D look.  Only the top half of the inactive
            # tab will have a slight gradient
            r.x += 3
            r.y += 1
            r.width -= 4
            r.height /= 2
            r.height -= 1

            # -- draw top gradient fill for glossy look
            top_colour = self._tab_inactive_top_colour
            bottom_colour = self._tab_inactive_bottom_colour
            dc.GradientFillLinear(r, bottom_colour, top_colour, wx.NORTH)

            r.y += r.height
            r.y -= 1

            # -- draw bottom fill for glossy look
            top_colour = self._tab_inactive_bottom_colour
            bottom_colour = self._tab_inactive_bottom_colour
            dc.GradientFillLinear(r, top_colour, bottom_colour, wx.SOUTH)
        
        # draw tab outline
        dc.SetPen(self._border_pen)
        dc.SetBrush(wx.TRANSPARENT_BRUSH)
        dc.DrawPolygon(border_points)

        # there are two horizontal grey lines at the bottom of the tab control,
        # this gets rid of the top one of those lines in the tab control
        if page.active:
        
            if agwFlags & AUI_NB_BOTTOM:
                dc.SetPen(wx.Pen(self._background_bottom_colour))
                
            # TODO: else if (agwFlags & AUI_NB_LEFT) 
            # TODO: else if (agwFlags & AUI_NB_RIGHT) 
            else: # for AUI_NB_TOP
                dc.SetPen(self._base_colour_pen)
                
            dc.DrawLine(border_points[0].x+1,
                        border_points[0].y,
                        border_points[5].x,
                        border_points[5].y)
        
        text_offset = tab_x + 8
        close_button_width = 0

        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            close_button_width = self._active_close_bmp.GetWidth()

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                text_offset += close_button_width - 5
                
        bitmap_offset = 0
        
        if pagebitmap.IsOk():
        
            bitmap_offset = tab_x + 8
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT and close_button_width:
                bitmap_offset += close_button_width - 5

            # draw bitmap
            dc.DrawBitmap(pagebitmap,
                          bitmap_offset,
                          drawn_tab_yoff + (drawn_tab_height/2) - (pagebitmap.GetHeight()/2),
                          True)

            text_offset = bitmap_offset + pagebitmap.GetWidth()
            text_offset += 3 # bitmap padding

        else:

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT == 0 or not close_button_width:
                text_offset = tab_x + 8
        
        draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - close_button_width)

        ypos = drawn_tab_yoff + (drawn_tab_height)/2 - (texty/2) - 1

        offset_focus = text_offset     
        if control is not None:
            if control.GetPosition() != wx.Point(text_offset+1, ypos):
                control.SetPosition(wx.Point(text_offset+1, ypos))

            if not control.IsShown():
                control.Show()

            if paint_control:
                bmp = TakeScreenShot(control.GetScreenRect())
                dc.DrawBitmap(bmp, text_offset+1, ypos, True)
                
            controlW, controlH = control.GetSize()
            text_offset += controlW + 4
            textx += controlW + 4
            
        # draw tab text
        rectx, recty, dummy = dc.GetMultiLineTextExtent(draw_text)
        dc.DrawLabel(draw_text, wx.Rect(text_offset, ypos, rectx, recty))

        # draw focus rectangle
        if (agwFlags & AUI_NB_NO_TAB_FOCUS) == 0:
            self.DrawFocusRectangle(dc, page, wnd, draw_text, offset_focus, bitmap_offset, drawn_tab_yoff, drawn_tab_height, rectx, recty)
        
        out_button_rect = wx.Rect()
        
        # draw close button if necessary
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
        
            bmp = self._disabled_close_bmp

            if close_button_state == AUI_BUTTON_STATE_HOVER:
                bmp = self._hover_close_bmp
            elif close_button_state == AUI_BUTTON_STATE_PRESSED:
                bmp = self._pressed_close_bmp

            shift = (agwFlags & AUI_NB_BOTTOM and [1] or [0])[0]

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                rect = wx.Rect(tab_x + 4, tab_y + (tab_height - bmp.GetHeight())/2 - shift,
                               close_button_width, tab_height)
            else:
                rect = wx.Rect(tab_x + tab_width - close_button_width - 1,
                               tab_y + (tab_height - bmp.GetHeight())/2 - shift,
                               close_button_width, tab_height)

            rect = IndentPressedBitmap(rect, close_button_state)
            dc.DrawBitmap(bmp, rect.x, rect.y, True)

            out_button_rect = rect
        
        out_tab_rect = wx.Rect(tab_x, tab_y, tab_width, tab_height)

        dc.DestroyClippingRegion()

        return out_tab_rect, out_button_rect, x_extent
    

    def SetCustomButton(self, bitmap_id, button_state, bmp):
        """
        Sets a custom bitmap for the close, left, right and window list buttons.
        
        :param integer `bitmap_id`: the button identifier;
        :param integer `button_state`: the button state;
        :param Bitmap `bmp`: the custom bitmap to use for the button.
        """

        if bitmap_id == AUI_BUTTON_CLOSE:
            if button_state == AUI_BUTTON_STATE_NORMAL:
                self._active_close_bmp = bmp
                self._hover_close_bmp = self._active_close_bmp
                self._pressed_close_bmp = self._active_close_bmp
                self._disabled_close_bmp = self._active_close_bmp
                    
            elif button_state == AUI_BUTTON_STATE_HOVER:
                self._hover_close_bmp = bmp
            elif button_state == AUI_BUTTON_STATE_PRESSED:
                self._pressed_close_bmp = bmp
            else:
                self._disabled_close_bmp = bmp

        elif bitmap_id == AUI_BUTTON_LEFT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                self._disabled_left_bmp = bmp
            else:
                self._active_left_bmp = bmp

        elif bitmap_id == AUI_BUTTON_RIGHT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                self._disabled_right_bmp = bmp
            else:
                self._active_right_bmp = bmp

        elif bitmap_id == AUI_BUTTON_WINDOWLIST:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                self._disabled_windowlist_bmp = bmp
            else:
                self._active_windowlist_bmp = bmp
        

    def GetIndentSize(self):
        """ Returns the tabs indent size. """

        return 5


    def GetTabSize(self, dc, wnd, caption, bitmap, active, close_button_state, control=None):
        """
        Returns the tab size for the given caption, bitmap and button state.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param string `caption`: the tab text caption;
        :param Bitmap `bitmap`: the bitmap displayed on the tab;
        :param bool `active`: whether the tab is selected or not;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param Window `control`: a :class:`Window` instance inside a tab (or ``None``).
        """

        dc.SetFont(self._measuring_font)
        measured_textx, measured_texty, dummy = dc.GetMultiLineTextExtent(caption)

        # add padding around the text
        tab_width = measured_textx
        tab_height = measured_texty

        # if the close button is showing, add space for it
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            tab_width += self._active_close_bmp.GetWidth() + 3

        # if there's a bitmap, add space for it
        if bitmap.IsOk():
            tab_width += bitmap.GetWidth()
            tab_width += 3 # right side bitmap padding
            tab_height = max(tab_height, bitmap.GetHeight())
        
        # add padding
        tab_width += 16
        tab_height += 10

        agwFlags = self.GetAGWFlags()
        if agwFlags & AUI_NB_TAB_FIXED_WIDTH:
            tab_width = self._fixed_tab_width

        if control is not None:
            tab_width += control.GetSize().GetWidth() + 4
            
        x_extent = tab_width

        return (tab_width, tab_height), x_extent


    def DrawButton(self, dc, wnd, in_rect, button, orientation):
        """
        Draws a button on the tab or on the tab area, depending on the button identifier. 

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param Rect `in_rect`: rectangle the tab should be confined to;
        :param `button`: an instance of the button class;
        :param integer `orientation`: the tab orientation.
        """

        bitmap_id, button_state = button.id, button.cur_state
        
        if bitmap_id == AUI_BUTTON_CLOSE:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_close_bmp
            elif button_state & AUI_BUTTON_STATE_HOVER:
                bmp = self._hover_close_bmp
            elif button_state & AUI_BUTTON_STATE_PRESSED:
                bmp = self._pressed_close_bmp
            else:
                bmp = self._active_close_bmp

        elif bitmap_id == AUI_BUTTON_LEFT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_left_bmp
            else:
                bmp = self._active_left_bmp

        elif bitmap_id == AUI_BUTTON_RIGHT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_right_bmp
            else:
                bmp = self._active_right_bmp

        elif bitmap_id == AUI_BUTTON_WINDOWLIST:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_windowlist_bmp
            else:
                bmp = self._active_windowlist_bmp

        else:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = button.dis_bitmap
            else:
                bmp = button.bitmap
                
        if not bmp.IsOk():
            return

        rect = wx.Rect(*in_rect)

        if orientation == wx.LEFT:
        
            rect.SetX(in_rect.x)
            rect.SetY(((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2))
            rect.SetWidth(bmp.GetWidth())
            rect.SetHeight(bmp.GetHeight())
        
        else:
        
            rect = wx.Rect(in_rect.x + in_rect.width - bmp.GetWidth(),
                           ((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2),
                           bmp.GetWidth(), bmp.GetHeight())
        
        rect = IndentPressedBitmap(rect, button_state)
        dc.DrawBitmap(bmp, rect.x, rect.y, True)

        out_rect = rect

        if bitmap_id == AUI_BUTTON_RIGHT:
            self._buttonRect = wx.Rect(rect.x, rect.y, 30, rect.height)
        
        return out_rect


    def DrawFocusRectangle(self, dc, page, wnd, draw_text, text_offset, bitmap_offset, drawn_tab_yoff, drawn_tab_height, textx, texty):
        """
        Draws the focus rectangle on a tab.

        :param `dc`: a :class:`DC` device context;
        :param `page`: the page associated with the tab;
        :param `wnd`: a :class:`Window` instance object;
        :param string `draw_text`: the text that has been drawn on the tab;
        :param integer `text_offset`: the text offset on the tab;
        :param integer `bitmap_offset`: the bitmap offset on the tab;
        :param integer `drawn_tab_yoff`: the y offset of the tab text;
        :param integer `drawn_tab_height`: the height of the tab;
        :param integer `textx`: the x text extent;
        :param integer `texty`: the y text extent.
        """

        if self.GetAGWFlags() & AUI_NB_NO_TAB_FOCUS:
            return
        
        if page.active and wx.Window.FindFocus() == wnd:
        
            focusRectText = wx.Rect(text_offset, (drawn_tab_yoff + (drawn_tab_height)/2 - (texty/2)),
                                    textx, texty)

            if page.bitmap.IsOk():
                focusRectBitmap = wx.Rect(bitmap_offset, drawn_tab_yoff + (drawn_tab_height/2) - (page.bitmap.GetHeight()/2),
                                          page.bitmap.GetWidth(), page.bitmap.GetHeight())

            if page.bitmap.IsOk() and draw_text == "":
                focusRect = wx.Rect(*focusRectBitmap)
            elif not page.bitmap.IsOk() and draw_text != "":
                focusRect = wx.Rect(*focusRectText)
            elif page.bitmap.IsOk() and draw_text != "":
                focusRect = focusRectText.Union(focusRectBitmap)

            focusRect.Inflate(2, 2)

            dc.SetBrush(wx.TRANSPARENT_BRUSH)
            dc.SetPen(self._focusPen)
            dc.DrawRoundedRectangleRect(focusRect, 2)
        

    def GetBestTabCtrlSize(self, wnd, pages, required_bmp_size):
        """
        Returns the best tab control size.

        :param `wnd`: a :class:`Window` instance object;
        :param list `pages`: the pages associated with the tabs;
        :param Size `required_bmp_size`: the size of the bitmap on the tabs.
        """

        dc = wx.ClientDC(wnd)
        dc.SetFont(self._measuring_font)

        # sometimes a standard bitmap size needs to be enforced, especially
        # if some tabs have bitmaps and others don't.  This is important because
        # it prevents the tab control from resizing when tabs are added.

        measure_bmp = wx.NullBitmap
        
        if required_bmp_size.IsFullySpecified():
            measure_bmp = wx.EmptyBitmap(required_bmp_size.x,
                                         required_bmp_size.y)
        
        max_y = 0
        
        for page in pages:
        
            if measure_bmp.IsOk():
                bmp = measure_bmp
            else:
                bmp = page.bitmap

            # we don't use the caption text because we don't
            # want tab heights to be different in the case
            # of a very short piece of text on one tab and a very
            # tall piece of text on another tab
            s, x_ext = self.GetTabSize(dc, wnd, page.caption, bmp, True, AUI_BUTTON_STATE_HIDDEN, None)
            max_y = max(max_y, s[1])

            if page.control:
                controlW, controlH = page.control.GetSize()
                max_y = max(max_y, controlH+4)

        return max_y + 2


    def SetNormalFont(self, font):
        """
        Sets the normal font for drawing tab labels.

        :param Font `font`: the new font to use to draw tab labels in their normal, un-selected state.
        """

        self._normal_font = font


    def SetSelectedFont(self, font):
        """
        Sets the selected tab font for drawing tab labels.

        :param Font `font`: the new font to use to draw tab labels in their selected state.
        """

        self._selected_font = font


    def SetMeasuringFont(self, font):
        """
        Sets the font for calculating text measurements.

        :param Font `font`: the new font to use to measure tab labels text extents.
        """

        self._measuring_font = font


    def GetNormalFont(self):
        """ Returns the normal font for drawing tab labels. """

        return self._normal_font


    def GetSelectedFont(self):
        """ Returns the selected tab font for drawing tab labels. """

        return self._selected_font


    def GetMeasuringFont(self):
        """ Returns the font for calculating text measurements. """

        return self._measuring_font
    

    def ShowDropDown(self, wnd, pages, active_idx):
        """
        Shows the drop-down window menu on the tab area.

        :param `wnd`: a :class:`Window` derived window instance;
        :param list `pages`: the pages associated with the tabs;
        :param integer `active_idx`: the active tab index.
        """
        
        useImages = self.GetAGWFlags() & AUI_NB_USE_IMAGES_DROPDOWN
        menuPopup = wx.Menu()

        longest = 0
        for i, page in enumerate(pages):
        
            caption = page.caption

            # if there is no caption, make it a space.  This will prevent
            # an assert in the menu code.
            if caption == "":
                caption = " "

            # Save longest caption width for calculating menu width with
            width = wnd.GetTextExtent(caption)[0]
            if width > longest:
                longest = width

            if useImages:
                menuItem = wx.MenuItem(menuPopup, 1000+i, caption)
                if page.bitmap:
                    menuItem.SetBitmap(page.bitmap)

                menuPopup.AppendItem(menuItem)
                
            else:
                
                menuPopup.AppendCheckItem(1000+i, caption)
                
            menuPopup.Enable(1000+i, page.enabled)

        if active_idx != -1 and not useImages:
        
            menuPopup.Check(1000+active_idx, True)
        
        # find out the screen coordinate at the bottom of the tab ctrl
        cli_rect = wnd.GetClientRect()

        # Calculate the approximate size of the popupmenu for setting the
        # position of the menu when its shown.
        # Account for extra padding on left/right of text on mac menus
        if wx.Platform in ['__WXMAC__', '__WXMSW__']:
            longest += 32

        # Bitmap/Checkmark width + padding
        longest += 20

        if self.GetAGWFlags() & AUI_NB_CLOSE_BUTTON:
            longest += 16

        pt = wx.Point(cli_rect.x + cli_rect.GetWidth() - longest,
                     cli_rect.y + cli_rect.height)

        cc = AuiCommandCapture()
        wnd.PushEventHandler(cc)
        wnd.PopupMenu(menuPopup, pt)
        command = cc.GetCommandId()
        wnd.PopEventHandler(True)

        if command >= 1000:
            return command - 1000

        return -1


class AuiSimpleTabArt(object):
    """ A simple-looking implementation of a tab art. """

    def __init__(self):
        """ Default class constructor. """

        self._normal_font = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        self._selected_font = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
        self._selected_font.SetWeight(wx.BOLD)
        self._measuring_font = self._selected_font

        self._agwFlags = 0
        self._fixed_tab_width = 100

        base_colour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DFACE)

        background_colour = base_colour
        normaltab_colour = base_colour
        selectedtab_colour = wx.WHITE

        self._bkbrush = wx.Brush(background_colour)
        self._normal_bkbrush = wx.Brush(normaltab_colour)
        self._normal_bkpen = wx.Pen(normaltab_colour)
        self._selected_bkbrush = wx.Brush(selectedtab_colour)
        self._selected_bkpen = wx.Pen(selectedtab_colour)

        self._active_close_bmp = BitmapFromBits(nb_close_bits, 16, 16, wx.BLACK)
        self._disabled_close_bmp = BitmapFromBits(nb_close_bits, 16, 16, wx.Colour(128, 128, 128))

        self._active_left_bmp = BitmapFromBits(nb_left_bits, 16, 16, wx.BLACK)
        self._disabled_left_bmp = BitmapFromBits(nb_left_bits, 16, 16, wx.Colour(128, 128, 128))

        self._active_right_bmp = BitmapFromBits(nb_right_bits, 16, 16, wx.BLACK)
        self._disabled_right_bmp = BitmapFromBits(nb_right_bits, 16, 16, wx.Colour(128, 128, 128))

        self._active_windowlist_bmp = BitmapFromBits(nb_list_bits, 16, 16, wx.BLACK)
        self._disabled_windowlist_bmp = BitmapFromBits(nb_list_bits, 16, 16, wx.Colour(128, 128, 128))


    def Clone(self):
        """ Clones the art object. """

        art = type(self)()
        art.SetNormalFont(self.GetNormalFont())
        art.SetSelectedFont(self.GetSelectedFont())
        art.SetMeasuringFont(self.GetMeasuringFont())

        art = CopyAttributes(art, self)
        return art


    def SetAGWFlags(self, agwFlags):
        """
        Sets the tab art flags.

        :param integer `agwFlags`: a combination of the following values:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet.
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet.
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close :class:`~lib.agw.aui.auibook.AuiNotebook` tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by :class:`~lib.agw.aui.framemanager.AuiManager` to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less full
                                              screen, tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ``AUI_NB_ORDER_BY_ACCESS``           Tab navigation order by last access time for the tabs
         ``AUI_NB_NO_TAB_FOCUS``              Don't draw tab focus rectangle
         ==================================== ==================================
        
        """

        self._agwFlags = agwFlags


    def GetAGWFlags(self):
        """
        Returns the tab art flags.

        :see: :meth:`~AuiSimpleTabArt.SetAGWFlags` for a list of possible return values.
        """

        return self._agwFlags
    

    def SetSizingInfo(self, tab_ctrl_size, tab_count, minMaxTabWidth):
        """
        Sets the tab sizing information.
        
        :param Size `tab_ctrl_size`: the size of the tab control area;
        :param integer `tab_count`: the number of tabs;
        :param tuple `minMaxTabWidth`: a tuple containing the minimum and maximum tab widths
         to be used when the ``AUI_NB_TAB_FIXED_WIDTH`` style is active.
        """
        
        self._fixed_tab_width = 100
        minTabWidth, maxTabWidth = minMaxTabWidth

        tot_width = tab_ctrl_size.x - self.GetIndentSize() - 4

        if self._agwFlags & AUI_NB_CLOSE_BUTTON:
            tot_width -= self._active_close_bmp.GetWidth()
        if self._agwFlags & AUI_NB_WINDOWLIST_BUTTON:
            tot_width -= self._active_windowlist_bmp.GetWidth()

        if tab_count > 0:
            self._fixed_tab_width = tot_width/tab_count
        
        if self._fixed_tab_width < 100:
            self._fixed_tab_width = 100

        if self._fixed_tab_width > tot_width/2:
            self._fixed_tab_width = tot_width/2

        if self._fixed_tab_width > 220:
            self._fixed_tab_width = 220

        if minTabWidth > -1:
            self._fixed_tab_width = max(self._fixed_tab_width, minTabWidth)
        if maxTabWidth > -1:
            self._fixed_tab_width = min(self._fixed_tab_width, maxTabWidth)

        self._tab_ctrl_height = tab_ctrl_size.y
        

    def DrawBackground(self, dc, wnd, rect):
        """
        Draws the tab area background.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param Rect `rect`: the tab control rectangle.
        """
        
        # draw background
        dc.SetBrush(self._bkbrush)
        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.DrawRectangle(-1, -1, rect.GetWidth()+2, rect.GetHeight()+2)

        # draw base line
        dc.SetPen(wx.GREY_PEN)
        dc.DrawLine(0, rect.GetHeight()-1, rect.GetWidth(), rect.GetHeight()-1)


    def DrawTab(self, dc, wnd, page, in_rect, close_button_state, paint_control=False):
        """
        Draws a single tab.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param `page`: the tab control page associated with the tab;
        :param Rect `in_rect`: rectangle the tab should be confined to;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param bool `paint_control`: whether to draw the control inside a tab (if any) on a :class:`MemoryDC`.
        """
        
        # if the caption is empty, measure some temporary text
        caption = page.caption
        if caption == "":
            caption = "Xj"

        agwFlags = self.GetAGWFlags()
        
        dc.SetFont(self._selected_font)
        selected_textx, selected_texty, dummy = dc.GetMultiLineTextExtent(caption)

        dc.SetFont(self._normal_font)
        normal_textx, normal_texty, dummy = dc.GetMultiLineTextExtent(caption)

        control = page.control

        # figure out the size of the tab
        tab_size, x_extent = self.GetTabSize(dc, wnd, page.caption, page.bitmap,
                                             page.active, close_button_state, control)

        tab_height = tab_size[1]
        tab_width = tab_size[0]
        tab_x = in_rect.x
        tab_y = in_rect.y + in_rect.height - tab_height

        caption = page.caption
        # select pen, brush and font for the tab to be drawn

        if page.active:
        
            dc.SetPen(self._selected_bkpen)
            dc.SetBrush(self._selected_bkbrush)
            dc.SetFont(self._selected_font)
            textx = selected_textx
            texty = selected_texty
        
        else:
        
            dc.SetPen(self._normal_bkpen)
            dc.SetBrush(self._normal_bkbrush)
            dc.SetFont(self._normal_font)
            textx = normal_textx
            texty = normal_texty

        if not page.enabled:
            dc.SetTextForeground(wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT))
        else:
            dc.SetTextForeground(page.text_colour)
        
        # -- draw line --

        points = [wx.Point() for i in xrange(7)]
        points[0].x = tab_x
        points[0].y = tab_y + tab_height - 1
        points[1].x = tab_x + tab_height - 3
        points[1].y = tab_y + 2
        points[2].x = tab_x + tab_height + 3
        points[2].y = tab_y
        points[3].x = tab_x + tab_width - 2
        points[3].y = tab_y
        points[4].x = tab_x + tab_width
        points[4].y = tab_y + 2
        points[5].x = tab_x + tab_width
        points[5].y = tab_y + tab_height - 1
        points[6] = points[0]

        dc.SetClippingRect(in_rect)
        dc.DrawPolygon(points)

        dc.SetPen(wx.GREY_PEN)
        dc.DrawLines(points)

        close_button_width = 0
        
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
        
            close_button_width = self._active_close_bmp.GetWidth()
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                if control:
                    text_offset = tab_x + (tab_height/2) + close_button_width - (textx/2) - 2
                else:
                    text_offset = tab_x + (tab_height/2) + ((tab_width+close_button_width)/2) - (textx/2) - 2
            else:
                if control:
                    text_offset = tab_x + (tab_height/2) + close_button_width - (textx/2)
                else:
                    text_offset = tab_x + (tab_height/2) + ((tab_width-close_button_width)/2) - (textx/2)
        
        else:
        
            text_offset = tab_x + (tab_height/3) + (tab_width/2) - (textx/2)
            if control:
                if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                    text_offset = tab_x + (tab_height/3) - (textx/2) + close_button_width + 2
                else:
                    text_offset = tab_x + (tab_height/3) - (textx/2)
        
        # set minimum text offset
        if text_offset < tab_x + tab_height:
            text_offset = tab_x + tab_height

        # chop text if necessary
        if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x))
        else:
            draw_text = ChopText(dc, caption,
                                 tab_width - (text_offset-tab_x) - close_button_width)

        ypos = (tab_y + tab_height)/2 - (texty/2) + 1

        if control is not None:
            if control.GetPosition() != wx.Point(text_offset+1, ypos):
                control.SetPosition(wx.Point(text_offset+1, ypos))

            if not control.IsShown():
                control.Show()

            if paint_control:
                bmp = TakeScreenShot(control.GetScreenRect())
                dc.DrawBitmap(bmp, text_offset+1, ypos, True)
                
            controlW, controlH = control.GetSize()
            text_offset += controlW + 4

        # draw tab text
        rectx, recty, dummy = dc.GetMultiLineTextExtent(draw_text)
        dc.DrawLabel(draw_text, wx.Rect(text_offset, ypos, rectx, recty))

        # draw focus rectangle
        if page.active and wx.Window.FindFocus() == wnd and (agwFlags & AUI_NB_NO_TAB_FOCUS) == 0:
        
            focusRect = wx.Rect(text_offset, ((tab_y + tab_height)/2 - (texty/2) + 1),
                                selected_textx, selected_texty)

            focusRect.Inflate(2, 2)
            # TODO:
            # This should be uncommented when DrawFocusRect will become
            # available in wxPython
            # wx.RendererNative.Get().DrawFocusRect(wnd, dc, focusRect, 0)

        out_button_rect = wx.Rect()        
        # draw close button if necessary
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
        
            if page.active:
                bmp = self._active_close_bmp
            else:
                bmp = self._disabled_close_bmp

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                rect = wx.Rect(tab_x + tab_height - 2,
                               tab_y + (tab_height/2) - (bmp.GetHeight()/2) + 1,
                               close_button_width, tab_height - 1)
            else:                
                rect = wx.Rect(tab_x + tab_width - close_button_width - 1,
                               tab_y + (tab_height/2) - (bmp.GetHeight()/2) + 1,
                               close_button_width, tab_height - 1)
            
            self.DrawButtons(dc, rect, bmp, wx.WHITE, close_button_state)
            out_button_rect = wx.Rect(*rect)
        
        out_tab_rect = wx.Rect(tab_x, tab_y, tab_width, tab_height)
        dc.DestroyClippingRegion()

        return out_tab_rect, out_button_rect, x_extent  


    def DrawButtons(self, dc, _rect, bmp, bkcolour, button_state):
        """
        Convenience method to draw tab buttons.

        :param `dc`: a :class:`DC` device context;
        :param Rect `_rect`: the tab rectangle;
        :param Bitmap `bmp`: the tab bitmap;
        :param Colour `bkcolour`: the tab background colour;
        :param integer `button_state`: the state of the tab button.
        """

        rect = wx.Rect(*_rect)

        if button_state == AUI_BUTTON_STATE_PRESSED:
            rect.x += 1
            rect.y += 1

        if button_state in [AUI_BUTTON_STATE_HOVER, AUI_BUTTON_STATE_PRESSED]:
            dc.SetBrush(wx.Brush(StepColour(bkcolour, 120)))
            dc.SetPen(wx.Pen(StepColour(bkcolour, 75)))

            # draw the background behind the button
            dc.DrawRectangle(rect.x, rect.y, 15, 15)

        # draw the button itself
        dc.DrawBitmap(bmp, rect.x, rect.y, True)

    
    def GetIndentSize(self):
        """ Returns the tabs indent size. """
        
        return 0


    def GetTabSize(self, dc, wnd, caption, bitmap, active, close_button_state, control=None):
        """
        Returns the tab size for the given caption, bitmap and button state.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param string `caption`: the tab text caption;
        :param Bitmap `bitmap`: the bitmap displayed on the tab;
        :param bool `active`: whether the tab is selected or not;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param Window `control`: a :class:`Window` instance inside a tab (or ``None``).
        """
        
        dc.SetFont(self._measuring_font)
        measured_textx, measured_texty, dummy = dc.GetMultiLineTextExtent(caption)

        tab_height = measured_texty + 4
        tab_width = measured_textx + tab_height + 5

        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            tab_width += self._active_close_bmp.GetWidth()

        if self._agwFlags & AUI_NB_TAB_FIXED_WIDTH:
            tab_width = self._fixed_tab_width

        if control is not None:
            controlW, controlH = control.GetSize()
            tab_width += controlW + 4

        x_extent = tab_width - (tab_height/2) - 1

        return (tab_width, tab_height), x_extent


    def DrawButton(self, dc, wnd, in_rect, button, orientation):
        """
        Draws a button on the tab or on the tab area, depending on the button identifier. 

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param Rect `in_rect`: rectangle the tab should be confined to;
        :param `button`: an instance of the button class;
        :param integer `orientation`: the tab orientation.
        """

        bitmap_id, button_state = button.id, button.cur_state
        
        if bitmap_id == AUI_BUTTON_CLOSE:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_close_bmp
            else:
                bmp = self._active_close_bmp

        elif bitmap_id == AUI_BUTTON_LEFT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_left_bmp
            else:
                bmp = self._active_left_bmp

        elif bitmap_id == AUI_BUTTON_RIGHT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_right_bmp
            else:
                bmp = self._active_right_bmp

        elif bitmap_id == AUI_BUTTON_WINDOWLIST:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = self._disabled_windowlist_bmp
            else:
                bmp = self._active_windowlist_bmp

        else:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                bmp = button.dis_bitmap
            else:
                bmp = button.bitmap
            
        if not bmp.IsOk():
            return

        rect = wx.Rect(*in_rect)

        if orientation == wx.LEFT:
        
            rect.SetX(in_rect.x)
            rect.SetY(((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2))
            rect.SetWidth(bmp.GetWidth())
            rect.SetHeight(bmp.GetHeight())
        
        else:
        
            rect = wx.Rect(in_rect.x + in_rect.width - bmp.GetWidth(),
                           ((in_rect.y + in_rect.height)/2) - (bmp.GetHeight()/2),
                           bmp.GetWidth(), bmp.GetHeight())

        self.DrawButtons(dc, rect, bmp, wx.WHITE, button_state)

        out_rect = wx.Rect(*rect)
        return out_rect


    def ShowDropDown(self, wnd, pages, active_idx):
        """
        Shows the drop-down window menu on the tab area.

        :param `wnd`: a :class:`Window` derived window instance;
        :param list `pages`: the pages associated with the tabs;
        :param integer `active_idx`: the active tab index.
        """
        
        menuPopup = wx.Menu()
        useImages = self.GetAGWFlags() & AUI_NB_USE_IMAGES_DROPDOWN
        
        for i, page in enumerate(pages):

            if useImages:
                menuItem = wx.MenuItem(menuPopup, 1000+i, page.caption)
                if page.bitmap:
                    menuItem.SetBitmap(page.bitmap)

                menuPopup.AppendItem(menuItem)
                
            else:
                
                menuPopup.AppendCheckItem(1000+i, page.caption)
                
            menuPopup.Enable(1000+i, page.enabled)
        
        if active_idx != -1 and not useImages:
            menuPopup.Check(1000+active_idx, True)
        
        # find out where to put the popup menu of window
        # items.  Subtract 100 for now to center the menu
        # a bit, until a better mechanism can be implemented
        pt = wx.GetMousePosition()
        pt = wnd.ScreenToClient(pt)
        
        if pt.x < 100:
            pt.x = 0
        else:
            pt.x -= 100

        # find out the screen coordinate at the bottom of the tab ctrl
        cli_rect = wnd.GetClientRect()
        pt.y = cli_rect.y + cli_rect.height

        cc = AuiCommandCapture()
        wnd.PushEventHandler(cc)
        wnd.PopupMenu(menuPopup, pt)
        command = cc.GetCommandId()
        wnd.PopEventHandler(True)

        if command >= 1000:
            return command-1000

        return -1


    def GetBestTabCtrlSize(self, wnd, pages, required_bmp_size):
        """
        Returns the best tab control size.

        :param `wnd`: a :class:`Window` instance object;
        :param list `pages`: the pages associated with the tabs;
        :param Size `required_bmp_size`: the size of the bitmap on the tabs.
        """
        
        dc = wx.ClientDC(wnd)
        dc.SetFont(self._measuring_font)
        s, x_extent = self.GetTabSize(dc, wnd, "ABCDEFGHIj", wx.NullBitmap, True,
                                      AUI_BUTTON_STATE_HIDDEN, None)

        max_y = s[1]

        for page in pages:
            if page.control:
                controlW, controlH = page.control.GetSize()
                max_y = max(max_y, controlH+4)
                
            textx, texty, dummy = dc.GetMultiLineTextExtent(page.caption)
            max_y = max(max_y, texty)
        
        return max_y + 3


    def SetNormalFont(self, font):
        """
        Sets the normal font for drawing tab labels.

        :param Font `font`: the new font to use to draw tab labels in their normal, un-selected state.
        """
        
        self._normal_font = font


    def SetSelectedFont(self, font):
        """
        Sets the selected tab font for drawing tab labels.

        :param Font `font`: the new font to use to draw tab labels in their selected state.
        """
        
        self._selected_font = font


    def SetMeasuringFont(self, font):
        """
        Sets the font for calculating text measurements.

        :param Font `font`: the new font to use to measure tab labels text extents.
        """
        
        self._measuring_font = font


    def GetNormalFont(self):
        """ Returns the normal font for drawing tab labels. """

        return self._normal_font


    def GetSelectedFont(self):
        """ Returns the selected tab font for drawing tab labels. """

        return self._selected_font


    def GetMeasuringFont(self):
        """ Returns the font for calculating text measurements. """

        return self._measuring_font


    def SetCustomButton(self, bitmap_id, button_state, bmp):
        """
        Sets a custom bitmap for the close, left, right and window list buttons.
        
        :param integer `bitmap_id`: the button identifier;
        :param integer `button_state`: the button state;
        :param Bitmap `bmp`: the custom bitmap to use for the button.
        """
        
        if bitmap_id == AUI_BUTTON_CLOSE:
            if button_state == AUI_BUTTON_STATE_NORMAL:
                self._active_close_bmp = bmp
                self._hover_close_bmp = self._active_close_bmp
                self._pressed_close_bmp = self._active_close_bmp
                self._disabled_close_bmp = self._active_close_bmp
                    
            elif button_state == AUI_BUTTON_STATE_HOVER:
                self._hover_close_bmp = bmp
            elif button_state == AUI_BUTTON_STATE_PRESSED:
                self._pressed_close_bmp = bmp
            else:
                self._disabled_close_bmp = bmp

        elif bitmap_id == AUI_BUTTON_LEFT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                self._disabled_left_bmp = bmp
            else:
                self._active_left_bmp = bmp

        elif bitmap_id == AUI_BUTTON_RIGHT:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                self._disabled_right_bmp = bmp
            else:
                self._active_right_bmp = bmp

        elif bitmap_id == AUI_BUTTON_WINDOWLIST:
            if button_state & AUI_BUTTON_STATE_DISABLED:
                self._disabled_windowlist_bmp = bmp
            else:
                self._active_windowlist_bmp = bmp
    

class VC71TabArt(AuiDefaultTabArt):
    """ A class to draw tabs using the Visual Studio 2003 (VC71) style. """

    def __init__(self):
        """ Default class constructor. """

        AuiDefaultTabArt.__init__(self)


    def Clone(self):
        """ Clones the art object. """

        art = type(self)()
        art.SetNormalFont(self.GetNormalFont())
        art.SetSelectedFont(self.GetSelectedFont())
        art.SetMeasuringFont(self.GetMeasuringFont())

        art = CopyAttributes(art, self)
        return art


    def DrawTab(self, dc, wnd, page, in_rect, close_button_state, paint_control=False):
        """
        Draws a single tab.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param `page`: the tab control page associated with the tab;
        :param Rect `in_rect`: rectangle the tab should be confined to;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param bool `paint_control`: whether to draw the control inside a tab (if any) on a :class:`MemoryDC`.
        """
        
        # Visual studio 7.1 style
        # This code is based on the renderer included in FlatNotebook

        # figure out the size of the tab

        control = page.control
        tab_size, x_extent = self.GetTabSize(dc, wnd, page.caption, page.bitmap, page.active,
                                             close_button_state, control)

        tab_height = self._tab_ctrl_height - 3
        tab_width = tab_size[0]
        tab_x = in_rect.x
        tab_y = in_rect.y + in_rect.height - tab_height
        clip_width = tab_width

        if tab_x + clip_width > in_rect.x + in_rect.width - 4:
            clip_width = (in_rect.x + in_rect.width) - tab_x - 4
            
        dc.SetClippingRegion(tab_x, tab_y, clip_width + 1, tab_height - 3)
        agwFlags = self.GetAGWFlags()

        if agwFlags & AUI_NB_BOTTOM:
            tab_y -= 1

        dc.SetPen((page.active and [wx.Pen(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DHIGHLIGHT))] or \
                   [wx.Pen(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DSHADOW))])[0])
        dc.SetBrush((page.active and [wx.Brush(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DFACE))] or \
                     [wx.TRANSPARENT_BRUSH])[0])

        if page.active:

            tabH = tab_height - 2
            dc.DrawRectangle(tab_x, tab_y, tab_width, tabH)

            rightLineY1 = (agwFlags & AUI_NB_BOTTOM and [vertical_border_padding - 2] or \
                           [vertical_border_padding - 1])[0]
            rightLineY2 = tabH + 3
            dc.SetPen(wx.Pen(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DSHADOW)))
            dc.DrawLine(tab_x + tab_width - 1, rightLineY1 + 1, tab_x + tab_width - 1, rightLineY2)
            
            if agwFlags & AUI_NB_BOTTOM:
                dc.DrawLine(tab_x + 1, rightLineY2 - 3 , tab_x + tab_width - 1, rightLineY2 - 3)
                
            dc.SetPen(wx.Pen(wx.SystemSettings.GetColour(wx.SYS_COLOUR_3DDKSHADOW)))
            dc.DrawLine(tab_x + tab_width, rightLineY1, tab_x + tab_width, rightLineY2)
            
            if agwFlags & AUI_NB_BOTTOM:
                dc.DrawLine(tab_x, rightLineY2 - 2, tab_x + tab_width, rightLineY2 - 2)

        else:
        
            # We dont draw a rectangle for non selected tabs, but only
            # vertical line on the right
            blackLineY1 = (agwFlags & AUI_NB_BOTTOM and [vertical_border_padding + 2] or \
                           [vertical_border_padding + 1])[0]
            blackLineY2 = tab_height - 5
            dc.DrawLine(tab_x + tab_width, blackLineY1, tab_x + tab_width, blackLineY2)
        
        border_points = [0, 0]
        
        if agwFlags & AUI_NB_BOTTOM:
        
            border_points[0] = wx.Point(tab_x, tab_y)
            border_points[1] = wx.Point(tab_x, tab_y + tab_height - 6)
        
        else: # if (agwFlags & AUI_NB_TOP)
        
            border_points[0] = wx.Point(tab_x, tab_y + tab_height - 4)
            border_points[1] = wx.Point(tab_x, tab_y + 2)

        drawn_tab_yoff = border_points[1].y
        drawn_tab_height = border_points[0].y - border_points[1].y

        text_offset = tab_x + 8
        close_button_width = 0

        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            close_button_width = self._active_close_bmp.GetWidth()
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                text_offset += close_button_width - 5

        if not page.enabled:
            dc.SetTextForeground(wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT))
            pagebitmap = page.dis_bitmap
        else:
            dc.SetTextForeground(page.text_colour)
            pagebitmap = page.bitmap

        shift = 0
        if agwFlags & AUI_NB_BOTTOM:
            shift = (page.active and [1] or [2])[0]
            
        bitmap_offset = 0
        if pagebitmap.IsOk():
            bitmap_offset = tab_x + 8
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT and close_button_width:
                bitmap_offset += close_button_width - 5

            # draw bitmap
            dc.DrawBitmap(pagebitmap, bitmap_offset,
                          drawn_tab_yoff + (drawn_tab_height/2) - (pagebitmap.GetHeight()/2) + shift,
                          True)

            text_offset = bitmap_offset + pagebitmap.GetWidth()
            text_offset += 3 # bitmap padding
        
        else:
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT == 0 or not close_button_width:
                text_offset = tab_x + 8
        
        # if the caption is empty, measure some temporary text
        caption = page.caption

        if caption == "":
            caption = "Xj"

        if page.active:
            dc.SetFont(self._selected_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)
        else:
            dc.SetFont(self._normal_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)

        draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - close_button_width)

        ypos = drawn_tab_yoff + (drawn_tab_height)/2 - (texty/2) - 1 + shift

        offset_focus = text_offset
        
        if control is not None:
            if control.GetPosition() != wx.Point(text_offset+1, ypos):
                control.SetPosition(wx.Point(text_offset+1, ypos))

            if not control.IsShown():
                control.Show()

            if paint_control:
                bmp = TakeScreenShot(control.GetScreenRect())
                dc.DrawBitmap(bmp, text_offset+1, ypos, True)
                
            controlW, controlH = control.GetSize()
            text_offset += controlW + 4
            textx += controlW + 4

        # draw tab text
        rectx, recty, dummy = dc.GetMultiLineTextExtent(draw_text)
        dc.DrawLabel(draw_text, wx.Rect(text_offset, ypos, rectx, recty))

        out_button_rect = wx.Rect()

        # draw focus rectangle
        if (agwFlags & AUI_NB_NO_TAB_FOCUS) == 0:
            self.DrawFocusRectangle(dc, page, wnd, draw_text, offset_focus, bitmap_offset, drawn_tab_yoff+shift,
                                    drawn_tab_height+shift, rectx, recty)
                
        # draw 'x' on tab (if enabled)
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            close_button_width = self._active_close_bmp.GetWidth()

            bmp = self._disabled_close_bmp

            if close_button_state == AUI_BUTTON_STATE_HOVER:
                bmp = self._hover_close_bmp
            elif close_button_state == AUI_BUTTON_STATE_PRESSED:
                bmp = self._pressed_close_bmp

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                rect = wx.Rect(tab_x + 4,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + shift,
                               close_button_width, tab_height)
            else:
                rect = wx.Rect(tab_x + tab_width - close_button_width - 3,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + shift,
                               close_button_width, tab_height)

            # Indent the button if it is pressed down:
            rect = IndentPressedBitmap(rect, close_button_state)
            dc.DrawBitmap(bmp, rect.x, rect.y, True)

            out_button_rect = rect        

        out_tab_rect = wx.Rect(tab_x, tab_y, tab_width, tab_height)
        dc.DestroyClippingRegion()

        return out_tab_rect, out_button_rect, x_extent


class FF2TabArt(AuiDefaultTabArt):
    """ A class to draw tabs using the Firefox 2 (FF2) style. """

    def __init__(self):
        """ Default class constructor. """

        AuiDefaultTabArt.__init__(self)


    def Clone(self):
        """ Clones the art object. """

        art = type(self)()
        art.SetNormalFont(self.GetNormalFont())
        art.SetSelectedFont(self.GetSelectedFont())
        art.SetMeasuringFont(self.GetMeasuringFont())

        art = CopyAttributes(art, self)
        return art


    def GetTabSize(self, dc, wnd, caption, bitmap, active, close_button_state, control):
        """
        Returns the tab size for the given caption, bitmap and button state.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param string `caption`: the tab text caption;
        :param Bitmap `bitmap`: the bitmap displayed on the tab;
        :param bool `active`: whether the tab is selected or not;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param Window `control`: a :class:`Window` instance inside a tab (or ``None``).
        """
        
        tab_size, x_extent = AuiDefaultTabArt.GetTabSize(self, dc, wnd, caption, bitmap,
                                                         active, close_button_state, control)

        tab_width, tab_height = tab_size        

        # add some vertical padding
        tab_height += 2
        
        return (tab_width, tab_height), x_extent


    def DrawTab(self, dc, wnd, page, in_rect, close_button_state, paint_control=False):
        """
        Draws a single tab.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param `page`: the tab control page associated with the tab;
        :param Rect `in_rect`: rectangle the tab should be confined to;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param bool `paint_control`: whether to draw the control inside a tab (if any) on a :class:`MemoryDC`.
        """
        
        # Firefox 2 style

        control = page.control

        # figure out the size of the tab
        tab_size, x_extent = self.GetTabSize(dc, wnd, page.caption, page.bitmap,
                                             page.active, close_button_state, control)

        tab_height = self._tab_ctrl_height - 2
        tab_width = tab_size[0]
        tab_x = in_rect.x
        tab_y = in_rect.y + in_rect.height - tab_height

        clip_width = tab_width
        if tab_x + clip_width > in_rect.x + in_rect.width - 4:
            clip_width = (in_rect.x + in_rect.width) - tab_x - 4
            
        dc.SetClippingRegion(tab_x, tab_y, clip_width + 1, tab_height - 3)

        tabPoints = [wx.Point() for i in xrange(7)]
        
        adjust = 0
        if not page.active:
            adjust = 1

        agwFlags = self.GetAGWFlags()
        
        tabPoints[0].x = tab_x + 3
        tabPoints[0].y = (agwFlags & AUI_NB_BOTTOM and [3] or [tab_height - 2])[0]

        tabPoints[1].x = tabPoints[0].x
        tabPoints[1].y = (agwFlags & AUI_NB_BOTTOM and [tab_height - (vertical_border_padding + 2) - adjust] or \
                          [(vertical_border_padding + 2) + adjust])[0]

        tabPoints[2].x = tabPoints[1].x+2
        tabPoints[2].y = (agwFlags & AUI_NB_BOTTOM and [tab_height - vertical_border_padding - adjust] or \
                          [vertical_border_padding + adjust])[0]

        tabPoints[3].x = tab_x + tab_width - 2
        tabPoints[3].y = tabPoints[2].y

        tabPoints[4].x = tabPoints[3].x + 2
        tabPoints[4].y = tabPoints[1].y

        tabPoints[5].x = tabPoints[4].x
        tabPoints[5].y = tabPoints[0].y

        tabPoints[6].x = tabPoints[0].x
        tabPoints[6].y = tabPoints[0].y

        rr = wx.RectPP(tabPoints[2], tabPoints[5])
        self.DrawTabBackground(dc, rr, page.active, (agwFlags & AUI_NB_BOTTOM) == 0)

        dc.SetBrush(wx.TRANSPARENT_BRUSH)
        dc.SetPen(wx.Pen(wx.SystemSettings_GetColour(wx.SYS_COLOUR_BTNSHADOW)))

        # Draw the tab as rounded rectangle
        dc.DrawPolygon(tabPoints)

        if page.active:
            dc.DrawLine(tabPoints[0].x + 1, tabPoints[0].y, tabPoints[5].x , tabPoints[0].y)
        
        drawn_tab_yoff = tabPoints[1].y
        drawn_tab_height = tabPoints[0].y - tabPoints[2].y

        text_offset = tab_x + 8
        close_button_width = 0
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            close_button_width = self._active_close_bmp.GetWidth()
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                text_offset += close_button_width - 4

        if not page.enabled:
            dc.SetTextForeground(wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT))
            pagebitmap = page.dis_bitmap
        else:
            dc.SetTextForeground(page.text_colour)
            pagebitmap = page.bitmap

        shift = -1
        if agwFlags & AUI_NB_BOTTOM:
            shift = 2
        
        bitmap_offset = 0
        if pagebitmap.IsOk():
            bitmap_offset = tab_x + 8
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT and close_button_width:
                bitmap_offset += close_button_width - 4

            # draw bitmap
            dc.DrawBitmap(pagebitmap, bitmap_offset,
                          drawn_tab_yoff + (drawn_tab_height/2) - (pagebitmap.GetHeight()/2) + shift,
                          True)

            text_offset = bitmap_offset + pagebitmap.GetWidth()
            text_offset += 3 # bitmap padding
        
        else:
        
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT == 0 or not close_button_width:
                text_offset = tab_x + 8
        
        # if the caption is empty, measure some temporary text
        caption = page.caption
        if caption == "":
            caption = "Xj"

        if page.active:
            dc.SetFont(self._selected_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)
        else:
            dc.SetFont(self._normal_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)

        if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - close_button_width + 1)
        else:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - close_button_width)

        ypos = drawn_tab_yoff + drawn_tab_height/2 - texty/2 - 1 + shift

        offset_focus = text_offset
        
        if control is not None:
            if control.GetPosition() != wx.Point(text_offset+1, ypos):
                control.SetPosition(wx.Point(text_offset+1, ypos))

            if not control.IsShown():
                control.Show()

            if paint_control:
                bmp = TakeScreenShot(control.GetScreenRect())
                dc.DrawBitmap(bmp, text_offset+1, ypos, True)
                
            controlW, controlH = control.GetSize()
            text_offset += controlW + 4
            textx += controlW + 4
        
        # draw tab text
        rectx, recty, dummy = dc.GetMultiLineTextExtent(draw_text)
        dc.DrawLabel(draw_text, wx.Rect(text_offset, ypos, rectx, recty))

        # draw focus rectangle
        if (agwFlags & AUI_NB_NO_TAB_FOCUS) == 0:
            self.DrawFocusRectangle(dc, page, wnd, draw_text, offset_focus, bitmap_offset, drawn_tab_yoff+shift,
                                    drawn_tab_height, rectx, recty)
        
        out_button_rect = wx.Rect()
        # draw 'x' on tab (if enabled)
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
        
            close_button_width = self._active_close_bmp.GetWidth()
            bmp = self._disabled_close_bmp

            if close_button_state == AUI_BUTTON_STATE_HOVER:
                bmp = self._hover_close_bmp
            elif close_button_state == AUI_BUTTON_STATE_PRESSED:
                bmp = self._pressed_close_bmp

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                rect = wx.Rect(tab_x + 5,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + shift,
                               close_button_width, tab_height)
            else:
                rect = wx.Rect(tab_x + tab_width - close_button_width - 3,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + shift,
                               close_button_width, tab_height)

            # Indent the button if it is pressed down:
            rect = IndentPressedBitmap(rect, close_button_state)
            dc.DrawBitmap(bmp, rect.x, rect.y, True)
            out_button_rect = rect
        
        out_tab_rect = wx.Rect(tab_x, tab_y, tab_width, tab_height)
        dc.DestroyClippingRegion()
    
        return out_tab_rect, out_button_rect, x_extent


    def DrawTabBackground(self, dc, rect, focus, upperTabs):
        """
        Draws the tab background for the Firefox 2 style.
        This is more consistent with :class:`~lib.agw.flatnotebook.FlatNotebook` than before.

        :param `dc`: a :class:`DC` device context;
        :param Rect `rect`: rectangle the tab should be confined to;
        :param bool `focus`: whether the tab has focus or not;
        :param bool `upperTabs`: whether the style is ``AUI_NB_TOP`` or ``AUI_NB_BOTTOM``.
        """

        # Define the rounded rectangle base on the given rect
        # we need an array of 9 points for it
        regPts = [wx.Point() for indx in xrange(9)]

        if focus:
            if upperTabs:
                leftPt = wx.Point(rect.x, rect.y + (rect.height / 10)*8)
                rightPt = wx.Point(rect.x + rect.width - 2, rect.y + (rect.height / 10)*8)
            else:
                leftPt = wx.Point(rect.x, rect.y + (rect.height / 10)*5)
                rightPt = wx.Point(rect.x + rect.width - 2, rect.y + (rect.height / 10)*5)
        else:
            leftPt = wx.Point(rect.x, rect.y + (rect.height / 2))
            rightPt = wx.Point(rect.x + rect.width - 2, rect.y + (rect.height / 2))

        # Define the top region
        top = wx.RectPP(rect.GetTopLeft(), rightPt)
        bottom = wx.RectPP(leftPt, rect.GetBottomRight())

        topStartColour = wx.WHITE

        if not focus:
            topStartColour = LightColour(wx.SystemSettings_GetColour(wx.SYS_COLOUR_3DFACE), 50)

        topEndColour = wx.SystemSettings_GetColour(wx.SYS_COLOUR_3DFACE)
        bottomStartColour = topEndColour
        bottomEndColour = topEndColour

        # Incase we use bottom tabs, switch the colours
        if upperTabs:
            if focus:
                dc.GradientFillLinear(top, topStartColour, topEndColour, wx.SOUTH)
                dc.GradientFillLinear(bottom, bottomStartColour, bottomEndColour, wx.SOUTH)
            else:
                dc.GradientFillLinear(top, topEndColour , topStartColour, wx.SOUTH)
                dc.GradientFillLinear(bottom, bottomStartColour, bottomEndColour, wx.SOUTH)

        else:
            if focus:
                dc.GradientFillLinear(bottom, topEndColour, bottomEndColour, wx.SOUTH)
                dc.GradientFillLinear(top, topStartColour, topStartColour, wx.SOUTH)
            else:
                dc.GradientFillLinear(bottom, bottomStartColour, bottomEndColour, wx.SOUTH)
                dc.GradientFillLinear(top, topEndColour, topStartColour, wx.SOUTH)
        
        dc.SetBrush(wx.TRANSPARENT_BRUSH)


class VC8TabArt(AuiDefaultTabArt):
    """ A class to draw tabs using the Visual Studio 2005 (VC8) style. """

    def __init__(self):
        """ Default class constructor. """

        AuiDefaultTabArt.__init__(self)


    def Clone(self):
        """ Clones the art object. """

        art = type(self)()
        art.SetNormalFont(self.GetNormalFont())
        art.SetSelectedFont(self.GetSelectedFont())
        art.SetMeasuringFont(self.GetMeasuringFont())

        art = CopyAttributes(art, self)
        return art


    def SetSizingInfo(self, tab_ctrl_size, tab_count, minMaxTabWidth):
        """
        Sets the tab sizing information.
        
        :param Size `tab_ctrl_size`: the size of the tab control area;
        :param integer `tab_count`: the number of tabs;
        :param tuple `minMaxTabWidth`: a tuple containing the minimum and maximum tab widths
         to be used when the ``AUI_NB_TAB_FIXED_WIDTH`` style is active.
        """
        
        AuiDefaultTabArt.SetSizingInfo(self, tab_ctrl_size, tab_count, minMaxTabWidth)

        minTabWidth, maxTabWidth = minMaxTabWidth
        if minTabWidth > -1:
            self._fixed_tab_width = max(self._fixed_tab_width, minTabWidth)
        if maxTabWidth > -1:
            self._fixed_tab_width = min(self._fixed_tab_width, maxTabWidth)
        
        self._fixed_tab_width -= 5


    def GetTabSize(self, dc, wnd, caption, bitmap, active, close_button_state, control=None):
        """
        Returns the tab size for the given caption, bitmap and button state.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param string `caption`: the tab text caption;
        :param Bitmap `bitmap`: the bitmap displayed on the tab;
        :param bool `active`: whether the tab is selected or not;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param Window `control`: a :class:`Window` instance inside a tab (or ``None``).
        """
        
        tab_size, x_extent = AuiDefaultTabArt.GetTabSize(self, dc, wnd, caption, bitmap,
                                                         active, close_button_state, control)

        tab_width, tab_height = tab_size        

        # add some padding
        tab_width += 10

        if not bitmap.IsOk():
            tab_width += 5
            
        tab_height += 2

        return (tab_width, tab_height), x_extent


    def DrawTab(self, dc, wnd, page, in_rect, close_button_state, paint_control=False):
        """
        Draws a single tab.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param `page`: the tab control page associated with the tab;
        :param Rect `in_rect`: rectangle the tab should be confined to;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param bool `paint_control`: whether to draw the control inside a tab (if any) on a :class:`MemoryDC`.
        """
        
        # Visual Studio 8 style

        control = page.control

        # figure out the size of the tab
        tab_size, x_extent = self.GetTabSize(dc, wnd, page.caption, page.bitmap,
                                             page.active, close_button_state, control)

        tab_height = self._tab_ctrl_height - 1
        tab_width = tab_size[0]
        tab_x = in_rect.x
        tab_y = in_rect.y + in_rect.height - tab_height

        clip_width = tab_width + 3
        if tab_x + clip_width > in_rect.x + in_rect.width - 4:
            clip_width = (in_rect.x + in_rect.width) - tab_x - 4
        
        tabPoints = [wx.Point() for i in xrange(8)]

        # If we draw the first tab or the active tab, 
        # we draw a full tab, else we draw a truncated tab
        #
        #             X(2)                  X(3)
        #        X(1)                            X(4)
        #                                          
        #                                           X(5)
        #                                           
        # X(0),(7)                                  X(6)
        #
        #

        adjust = 0
        if not page.active:
            adjust = 1

        agwFlags = self.GetAGWFlags()
        tabPoints[0].x = (agwFlags & AUI_NB_BOTTOM and [tab_x] or [tab_x + adjust])[0]
        tabPoints[0].y = (agwFlags & AUI_NB_BOTTOM and [2] or [tab_height - 3])[0]

        tabPoints[1].x = tabPoints[0].x + tab_height - vertical_border_padding - 3 - adjust
        tabPoints[1].y = (agwFlags & AUI_NB_BOTTOM and [tab_height - (vertical_border_padding+2)] or \
                          [(vertical_border_padding+2)])[0]

        tabPoints[2].x = tabPoints[1].x + 4
        tabPoints[2].y = (agwFlags & AUI_NB_BOTTOM and [tab_height - vertical_border_padding] or \
                          [vertical_border_padding])[0]

        tabPoints[3].x = tabPoints[2].x + tab_width - tab_height + vertical_border_padding
        tabPoints[3].y = (agwFlags & AUI_NB_BOTTOM and [tab_height - vertical_border_padding] or \
                          [vertical_border_padding])[0]

        tabPoints[4].x = tabPoints[3].x + 1
        tabPoints[4].y = (agwFlags & AUI_NB_BOTTOM and [tabPoints[3].y - 1] or [tabPoints[3].y + 1])[0]

        tabPoints[5].x = tabPoints[4].x + 1
        tabPoints[5].y = (agwFlags & AUI_NB_BOTTOM and [(tabPoints[4].y - 1)] or [tabPoints[4].y + 1])[0]

        tabPoints[6].x = tabPoints[2].x + tab_width - tab_height + 2 + vertical_border_padding
        tabPoints[6].y = tabPoints[0].y

        tabPoints[7].x = tabPoints[0].x
        tabPoints[7].y = tabPoints[0].y

        self.FillVC8GradientColour(dc, tabPoints, page.active)        

        dc.SetBrush(wx.TRANSPARENT_BRUSH)

        dc.SetPen(wx.Pen(wx.SystemSettings.GetColour(wx.SYS_COLOUR_BTNSHADOW)))
        dc.DrawPolygon(tabPoints)

        if page.active:
            # Delete the bottom line (or the upper one, incase we use wxBOTTOM) 
            dc.SetPen(wx.WHITE_PEN)
            dc.DrawLine(tabPoints[0].x, tabPoints[0].y, tabPoints[6].x, tabPoints[6].y)

        dc.SetClippingRegion(tab_x, tab_y, clip_width + 2, tab_height - 3)            

        drawn_tab_yoff = tabPoints[1].y
        drawn_tab_height = tabPoints[0].y - tabPoints[2].y

        text_offset = tab_x + 20
        close_button_width = 0
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            close_button_width = self._active_close_bmp.GetWidth()
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                text_offset += close_button_width

        if not page.enabled:
            dc.SetTextForeground(wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT))
            pagebitmap = page.dis_bitmap
        else:
            dc.SetTextForeground(page.text_colour)
            pagebitmap = page.bitmap

        shift = 0
        if agwFlags & AUI_NB_BOTTOM:
            shift = (page.active and [1] or [2])[0]
        
        bitmap_offset = 0
        if pagebitmap.IsOk():
            bitmap_offset = tab_x + 20
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT and close_button_width:
                bitmap_offset += close_button_width

            # draw bitmap
            dc.DrawBitmap(pagebitmap, bitmap_offset,
                          drawn_tab_yoff + (drawn_tab_height/2) - (pagebitmap.GetHeight()/2) + shift,
                          True)

            text_offset = bitmap_offset + pagebitmap.GetWidth()
            text_offset += 3 # bitmap padding
        
        else:
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT == 0 or not close_button_width:
                text_offset = tab_x + tab_height
        
        # if the caption is empty, measure some temporary text
        caption = page.caption
        if caption == "":
            caption = "Xj"

        if page.active:
            dc.SetFont(self._selected_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)
        else:
            dc.SetFont(self._normal_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)

        if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x))
        else:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - close_button_width)

        ypos = drawn_tab_yoff + drawn_tab_height/2 - texty/2 - 1 + shift

        offset_focus = text_offset
        
        if control is not None:
            if control.GetPosition() != wx.Point(text_offset+1, ypos):
                control.SetPosition(wx.Point(text_offset+1, ypos))

            if not control.IsShown():
                control.Show()

            if paint_control:
                bmp = TakeScreenShot(control.GetScreenRect())
                dc.DrawBitmap(bmp, text_offset+1, ypos, True)
                
            controlW, controlH = control.GetSize()
            text_offset += controlW + 4
            textx += controlW + 4

        # draw tab text
        rectx, recty, dummy = dc.GetMultiLineTextExtent(draw_text)
        dc.DrawLabel(draw_text, wx.Rect(text_offset, ypos, rectx, recty))
        
        # draw focus rectangle
        if (agwFlags & AUI_NB_NO_TAB_FOCUS) == 0:
            self.DrawFocusRectangle(dc, page, wnd, draw_text, offset_focus, bitmap_offset, drawn_tab_yoff+shift,
                                    drawn_tab_height+shift, rectx, recty)
        
        out_button_rect = wx.Rect()
        # draw 'x' on tab (if enabled)
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
        
            close_button_width = self._active_close_bmp.GetWidth()
            bmp = self._disabled_close_bmp

            if close_button_state == AUI_BUTTON_STATE_HOVER:
                bmp = self._hover_close_bmp
            elif close_button_state == AUI_BUTTON_STATE_PRESSED:
                bmp = self._pressed_close_bmp
                
            if page.active:
                xpos = tab_x + tab_width - close_button_width + 3
            else:
                xpos = tab_x + tab_width - close_button_width - 5

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                rect = wx.Rect(tab_x + 20,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + shift,
                               close_button_width, tab_height)
            else:
                rect = wx.Rect(xpos,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + shift,
                               close_button_width, tab_height)

            # Indent the button if it is pressed down:
            rect = IndentPressedBitmap(rect, close_button_state)
            dc.DrawBitmap(bmp, rect.x, rect.y, True)
            out_button_rect = rect
        
        out_tab_rect = wx.Rect(tab_x, tab_y, x_extent, tab_height)
        dc.DestroyClippingRegion()

        return out_tab_rect, out_button_rect, x_extent
        

    def FillVC8GradientColour(self, dc, tabPoints, active):
        """
        Fills the tab with the Visual Studio 2005 gradient background.

        :param `dc`: a :class:`DC` device context;
        :param list `tabPoints`: a list of :class:`Point` objects describing the tab shape;
        :param bool `active`: whether the tab is selected or not.
        """

        xList = [pt.x for pt in tabPoints]
        yList = [pt.y for pt in tabPoints]
        
        minx, maxx = min(xList), max(xList)
        miny, maxy = min(yList), max(yList)

        rect = wx.Rect(minx, maxy, maxx-minx, miny-maxy+1)        
        region = wx.RegionFromPoints(tabPoints)

        if self._buttonRect.width > 0:
            buttonRegion = wx.Region(*self._buttonRect)
            region.XorRegion(buttonRegion)
        
        dc.SetClippingRegionAsRegion(region)

        if active:
            bottom_colour = top_colour = wx.WHITE
        else:
            bottom_colour = StepColour(self._base_colour, 90)
            top_colour = StepColour(self._base_colour, 170)

        dc.GradientFillLinear(rect, top_colour, bottom_colour, wx.SOUTH)
        dc.DestroyClippingRegion()
        

class ChromeTabArt(AuiDefaultTabArt):
    """
    A class to draw tabs using the Google Chrome browser style.
    It uses custom bitmap to render the tabs, so that the look and feel is as close
    as possible to the Chrome style.
    """

    def __init__(self):
        """ Default class constructor. """

        AuiDefaultTabArt.__init__(self)

        self.SetBitmaps(mirror=False)
        
        closeBmp = tab_close.GetBitmap()
        closeHBmp = tab_close_h.GetBitmap()
        closePBmp = tab_close_p.GetBitmap()

        self.SetCustomButton(AUI_BUTTON_CLOSE, AUI_BUTTON_STATE_NORMAL, closeBmp)
        self.SetCustomButton(AUI_BUTTON_CLOSE, AUI_BUTTON_STATE_HOVER, closeHBmp)
        self.SetCustomButton(AUI_BUTTON_CLOSE, AUI_BUTTON_STATE_PRESSED, closePBmp)
        

    def SetAGWFlags(self, agwFlags):
        """
        Sets the tab art flags.

        :param integer `agwFlags`: a combination of the following values:

         ==================================== ==================================
         Flag name                            Description
         ==================================== ==================================
         ``AUI_NB_TOP``                       With this style, tabs are drawn along the top of the notebook
         ``AUI_NB_LEFT``                      With this style, tabs are drawn along the left of the notebook. Not implemented yet.
         ``AUI_NB_RIGHT``                     With this style, tabs are drawn along the right of the notebook. Not implemented yet.
         ``AUI_NB_BOTTOM``                    With this style, tabs are drawn along the bottom of the notebook
         ``AUI_NB_TAB_SPLIT``                 Allows the tab control to be split by dragging a tab
         ``AUI_NB_TAB_MOVE``                  Allows a tab to be moved horizontally by dragging
         ``AUI_NB_TAB_EXTERNAL_MOVE``         Allows a tab to be moved to another tab control
         ``AUI_NB_TAB_FIXED_WIDTH``           With this style, all tabs have the same width
         ``AUI_NB_SCROLL_BUTTONS``            With this style, left and right scroll buttons are displayed
         ``AUI_NB_WINDOWLIST_BUTTON``         With this style, a drop-down list of windows is available
         ``AUI_NB_CLOSE_BUTTON``              With this style, a close button is available on the tab bar
         ``AUI_NB_CLOSE_ON_ACTIVE_TAB``       With this style, a close button is available on the active tab
         ``AUI_NB_CLOSE_ON_ALL_TABS``         With this style, a close button is available on all tabs
         ``AUI_NB_MIDDLE_CLICK_CLOSE``        Allows to close :class:`~lib.agw.aui.auibook.AuiNotebook` tabs by mouse middle button click
         ``AUI_NB_SUB_NOTEBOOK``              This style is used by :class:`~lib.agw.aui.framemanager.AuiManager` to create automatic AuiNotebooks
         ``AUI_NB_HIDE_ON_SINGLE_TAB``        Hides the tab window if only one tab is present
         ``AUI_NB_SMART_TABS``                Use Smart Tabbing, like ``Alt`` + ``Tab`` on Windows
         ``AUI_NB_USE_IMAGES_DROPDOWN``       Uses images on dropdown window list menu instead of check items
         ``AUI_NB_CLOSE_ON_TAB_LEFT``         Draws the tab close button on the left instead of on the right (a la Camino browser)
         ``AUI_NB_TAB_FLOAT``                 Allows the floating of single tabs. Known limitation: when the notebook is more or less full
                                              screen, tabs cannot be dragged far enough outside of the notebook to become floating pages
         ``AUI_NB_DRAW_DND_TAB``              Draws an image representation of a tab while dragging (on by default)
         ``AUI_NB_ORDER_BY_ACCESS``           Tab navigation order by last access time for the tabs
         ``AUI_NB_NO_TAB_FOCUS``              Don't draw tab focus rectangle
         ==================================== ==================================

        :note: Overridden from :class:`AuiDefaultTabArt`.
        """

        if agwFlags & AUI_NB_TOP:
            self.SetBitmaps(mirror=False)
        elif agwFlags & AUI_NB_BOTTOM:
            self.SetBitmaps(mirror=True)

        AuiDefaultTabArt.SetAGWFlags(self, agwFlags)            


    def SetBitmaps(self, mirror):
        """
        Assigns the tab custom bitmaps

        :param bool `mirror`: whether to vertically mirror the bitmap or not.
        """

        bmps = [tab_active_left.GetBitmap(), tab_active_center.GetBitmap(),
                tab_active_right.GetBitmap(), tab_inactive_left.GetBitmap(),
                tab_inactive_center.GetBitmap(), tab_inactive_right.GetBitmap()]

        if mirror:
            for indx, bmp in enumerate(bmps):
                img = bmp.ConvertToImage()
                img = img.Mirror(horizontally=False)
                bmps[indx] = img.ConvertToBitmap()
                
        self._leftActiveBmp = bmps[0]
        self._centerActiveBmp = bmps[1]
        self._rightActiveBmp = bmps[2]
        self._leftInactiveBmp = bmps[3]
        self._centerInactiveBmp = bmps[4]
        self._rightInactiveBmp = bmps[5]
            

    def Clone(self):
        """ Clones the art object. """

        art = type(self)()
        art.SetNormalFont(self.GetNormalFont())
        art.SetSelectedFont(self.GetSelectedFont())
        art.SetMeasuringFont(self.GetMeasuringFont())

        art = CopyAttributes(art, self)
        return art


    def SetSizingInfo(self, tab_ctrl_size, tab_count, minMaxTabWidth):
        """
        Sets the tab sizing information.
        
        :param Size `tab_ctrl_size`: the size of the tab control area;
        :param integer `tab_count`: the number of tabs;
        :param tuple `minMaxTabWidth`: a tuple containing the minimum and maximum tab widths
         to be used when the ``AUI_NB_TAB_FIXED_WIDTH`` style is active.
        """
        
        AuiDefaultTabArt.SetSizingInfo(self, tab_ctrl_size, tab_count, minMaxTabWidth)

        minTabWidth, maxTabWidth = minMaxTabWidth
        if minTabWidth > -1:
            self._fixed_tab_width = max(self._fixed_tab_width, minTabWidth)
        if maxTabWidth > -1:
            self._fixed_tab_width = min(self._fixed_tab_width, maxTabWidth)

        self._fixed_tab_width -= 5


    def GetTabSize(self, dc, wnd, caption, bitmap, active, close_button_state, control=None):
        """
        Returns the tab size for the given caption, bitmap and button state.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param string `caption`: the tab text caption;
        :param Bitmap `bitmap`: the bitmap displayed on the tab;
        :param bool `active`: whether the tab is selected or not;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param Window `control`: a :class:`Window` instance inside a tab (or ``None``).
        """
        
        tab_size, x_extent = AuiDefaultTabArt.GetTabSize(self, dc, wnd, caption, bitmap,
                                                         active, close_button_state, control)

        tab_width, tab_height = tab_size        

        # add some padding
        tab_width += self._leftActiveBmp.GetWidth()
        tab_height += 2

        tab_height = max(tab_height, self._centerActiveBmp.GetHeight())        

        return (tab_width, tab_height), x_extent


    def DrawTab(self, dc, wnd, page, in_rect, close_button_state, paint_control=False):
        """
        Draws a single tab.

        :param `dc`: a :class:`DC` device context;
        :param `wnd`: a :class:`Window` instance object;
        :param `page`: the tab control page associated with the tab;
        :param Rect `in_rect`: rectangle the tab should be confined to;
        :param integer `close_button_state`: the state of the close button on the tab;
        :param bool `paint_control`: whether to draw the control inside a tab (if any) on a :class:`MemoryDC`.
        """
        
        # Chrome tab style

        control = page.control
        # figure out the size of the tab
        tab_size, x_extent = self.GetTabSize(dc, wnd, page.caption, page.bitmap, page.active,
                                             close_button_state, control)

        agwFlags = self.GetAGWFlags()
        
        tab_height = self._tab_ctrl_height - 1
        tab_width = tab_size[0]
        tab_x = in_rect.x
        tab_y = in_rect.y + in_rect.height - tab_height
        clip_width = tab_width

        if tab_x + clip_width > in_rect.x + in_rect.width - 4:
            clip_width = (in_rect.x + in_rect.width) - tab_x - 4
            
        dc.SetClippingRegion(tab_x, tab_y, clip_width + 1, tab_height - 3)
        drawn_tab_yoff = 1

        if page.active:
            left = self._leftActiveBmp
            center = self._centerActiveBmp
            right = self._rightActiveBmp
        else:
            left = self._leftInactiveBmp
            center = self._centerInactiveBmp
            right = self._rightInactiveBmp

        dc.DrawBitmap(left, tab_x, tab_y)
        leftw = left.GetWidth()
        centerw = center.GetWidth()
        rightw = right.GetWidth()

        available = tab_x + tab_width - rightw
        posx = tab_x + leftw
        
        while 1:
            if posx >= available:
                break
            dc.DrawBitmap(center, posx, tab_y)
            posx += centerw

        dc.DrawBitmap(right, posx, tab_y)

        drawn_tab_height = center.GetHeight()
        text_offset = tab_x + leftw
        
        close_button_width = 0
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
            close_button_width = self._active_close_bmp.GetWidth()
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                text_offset += close_button_width

        if not page.enabled:
            dc.SetTextForeground(wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT))
            pagebitmap = page.dis_bitmap
        else:
            dc.SetTextForeground(page.text_colour)
            pagebitmap = page.bitmap
        
        bitmap_offset = 0
        if pagebitmap.IsOk():
            bitmap_offset = tab_x + leftw
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT and close_button_width:
                bitmap_offset += close_button_width

            # draw bitmap
            dc.DrawBitmap(pagebitmap, bitmap_offset,
                          drawn_tab_yoff + (drawn_tab_height/2) - (pagebitmap.GetHeight()/2),
                          True)

            text_offset = bitmap_offset + pagebitmap.GetWidth()
            text_offset += 3 # bitmap padding
        
        else:
        
            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT == 0 or not close_button_width:
                text_offset = tab_x + leftw
        
        # if the caption is empty, measure some temporary text
        caption = page.caption
        if caption == "":
            caption = "Xj"

        if page.active:
            dc.SetFont(self._selected_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)
        else:
            dc.SetFont(self._normal_font)
            textx, texty, dummy = dc.GetMultiLineTextExtent(caption)

        if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - leftw)
        else:
            draw_text = ChopText(dc, caption, tab_width - (text_offset-tab_x) - close_button_width - leftw)

        ypos = drawn_tab_yoff + drawn_tab_height/2 - texty/2 - 1

        if control is not None:
            if control.GetPosition() != wx.Point(text_offset+1, ypos):
                control.SetPosition(wx.Point(text_offset+1, ypos))

            if not control.IsShown():
                control.Show()

            if paint_control:
                bmp = TakeScreenShot(control.GetScreenRect())
                dc.DrawBitmap(bmp, text_offset+1, ypos, True)
                
            controlW, controlH = control.GetSize()
            text_offset += controlW + 4

        # draw tab text
        rectx, recty, dummy = dc.GetMultiLineTextExtent(draw_text)
        dc.DrawLabel(draw_text, wx.Rect(text_offset, ypos, rectx, recty))
                
        out_button_rect = wx.Rect()
        # draw 'x' on tab (if enabled)
        if close_button_state != AUI_BUTTON_STATE_HIDDEN:
        
            close_button_width = self._active_close_bmp.GetWidth()
            bmp = self._disabled_close_bmp

            if close_button_state == AUI_BUTTON_STATE_HOVER:
                bmp = self._hover_close_bmp
            elif close_button_state == AUI_BUTTON_STATE_PRESSED:
                bmp = self._pressed_close_bmp

            if agwFlags & AUI_NB_CLOSE_ON_TAB_LEFT:
                rect = wx.Rect(tab_x + leftw - 2,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + 1,
                               close_button_width, tab_height)
            else:
                rect = wx.Rect(tab_x + tab_width - close_button_width - rightw + 2,
                               drawn_tab_yoff + (drawn_tab_height / 2) - (bmp.GetHeight() / 2) + 1,
                               close_button_width, tab_height)

            if agwFlags & AUI_NB_BOTTOM:
                rect.y -= 1
                
            # Indent the button if it is pressed down:
            rect = IndentPressedBitmap(rect, close_button_state)
            dc.DrawBitmap(bmp, rect.x, rect.y, True)
            out_button_rect = rect
            
        out_tab_rect = wx.Rect(tab_x, tab_y, tab_width, tab_height)
        dc.DestroyClippingRegion()

        return out_tab_rect, out_button_rect, x_extent        



########NEW FILE########
__FILENAME__ = tabmdi
__author__ = "Andrea Gavana <andrea.gavana@gmail.com>"
__date__ = "31 March 2009"


import wx

import auibook
from aui_constants import *

_ = wx.GetTranslation

#-----------------------------------------------------------------------------
# AuiMDIParentFrame
#-----------------------------------------------------------------------------

class AuiMDIParentFrame(wx.Frame):

    def __init__(self, parent, id=wx.ID_ANY, title="", pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=wx.DEFAULT_FRAME_STYLE|wx.VSCROLL|wx.HSCROLL,
                 name="AuiMDIParentFrame"):

        wx.Frame.__init__(self, parent, id, title, pos, size, style, name=name)
        self.Init()

        self.Bind(wx.EVT_MENU, self.DoHandleMenu, id=wx.ID_ANY)

        # this style can be used to prevent a window from having the standard MDI
        # "Window" menu
        if not style & wx.FRAME_NO_WINDOW_MENU:
        
            self._pWindowMenu = wx.Menu()
            self._pWindowMenu.Append(wxWINDOWCLOSE,    _("Cl&ose"))
            self._pWindowMenu.Append(wxWINDOWCLOSEALL, _("Close All"))
            self._pWindowMenu.AppendSeparator()
            self._pWindowMenu.Append(wxWINDOWNEXT,     _("&Next"))
            self._pWindowMenu.Append(wxWINDOWPREV,     _("&Previous"))
    
        self._pClientWindow = self.OnCreateClient()


    def SetArtProvider(self, provider):

        if self._pClientWindow:
            self._pClientWindow.SetArtProvider(provider)
    

    def GetArtProvider(self):

        if not self._pClientWindow:
            return None

        return self._pClientWindow.GetArtProvider()


    def GetNotebook(self):

        return self._pClientWindow


    def SetWindowMenu(self, pMenu):

        # Replace the window menu from the currently loaded menu bar.
        pMenuBar = self.GetMenuBar()

        if self._pWindowMenu:
            self.RemoveWindowMenu(pMenuBar)
            del self._pWindowMenu
            self._pWindowMenu = None

        if pMenu:
            self._pWindowMenu = pMenu
            self.AddWindowMenu(pMenuBar)
        

    def GetWindowMenu(self):

        return self._pWindowMenu
    

    def SetMenuBar(self, pMenuBar):

        # Remove the Window menu from the old menu bar
        self.RemoveWindowMenu(self.GetMenuBar())

        # Add the Window menu to the new menu bar.
        self.AddWindowMenu(pMenuBar)

        wx.Frame.SetMenuBar(self, pMenuBar)


    def SetChildMenuBar(self, pChild):

        if not pChild:
        
            # No Child, set Our menu bar back.
            if self._pMyMenuBar:
                self.SetMenuBar(self._pMyMenuBar)
            else:
                self.SetMenuBar(self.GetMenuBar())

            # Make sure we know our menu bar is in use
            self._pMyMenuBar = None
        
        else:
        
            if pChild.GetMenuBar() == None:
                return

            # Do we need to save the current bar?
            if self._pMyMenuBar == None:
                self._pMyMenuBar = self.GetMenuBar()

            self.SetMenuBar(pChild.GetMenuBar())
    

    def ProcessEvent(self, event):

        # stops the same event being processed repeatedly
        if self._pLastEvt == event:
            return False
        
        self._pLastEvt = event

        # let the active child (if any) process the event first.
        res = False
        if self._pActiveChild and event.IsCommandEvent() and \
           event.GetEventObject() != self._pClientWindow and \
           event.GetEventType() not in [wx.wxEVT_ACTIVATE, wx.wxEVT_SET_FOCUS,
                                        wx.wxEVT_KILL_FOCUS, wx.wxEVT_CHILD_FOCUS,
                                        wx.wxEVT_COMMAND_SET_FOCUS, wx.wxEVT_COMMAND_KILL_FOCUS]:
        
            res = self._pActiveChild.GetEventHandler().ProcessEvent(event)
        
        if not res:
        
            # if the event was not handled this frame will handle it,
            # which is why we need the protection code at the beginning
            # of this method
            res = self.GetEventHandler().ProcessEvent(event)
        
        self._pLastEvt = None

        return res


    def GetActiveChild(self):

        return self._pActiveChild


    def SetActiveChild(self, pChildFrame):

        self._pActiveChild = pChildFrame


    def GetClientWindow(self):

        return self._pClientWindow


    def OnCreateClient(self):

        return AuiMDIClientWindow(self)


    def ActivateNext(self):

        if self._pClientWindow and self._pClientWindow.GetSelection() != wx.NOT_FOUND:
        
            active = self._pClientWindow.GetSelection() + 1
            if active >= self._pClientWindow.GetPageCount():
                active = 0

            self._pClientWindow.SetSelection(active)
        

    def ActivatePrevious(self):

        if self._pClientWindow and self._pClientWindow.GetSelection() != wx.NOT_FOUND:
        
            active = self._pClientWindow.GetSelection() - 1
            if active < 0:
                active = self._pClientWindow.GetPageCount() - 1

            self._pClientWindow.SetSelection(active)
    

    def Init(self):

        self._pLastEvt = None

        self._pClientWindow = None
        self._pActiveChild = None
        self._pWindowMenu = None
        self._pMyMenuBar = None


    def RemoveWindowMenu(self, pMenuBar):

        if pMenuBar and self._pWindowMenu:
        
            # Remove old window menu
            pos = pMenuBar.FindMenu(_("&Window"))
            if pos != wx.NOT_FOUND:            
                pMenuBar.Remove(pos)
            

    def AddWindowMenu(self, pMenuBar):

        if pMenuBar and self._pWindowMenu:
        
            pos = pMenuBar.FindMenu(wx.GetStockLabel(wx.ID_HELP, wx.STOCK_NOFLAGS))
            if pos == wx.NOT_FOUND:
                pMenuBar.Append(self._pWindowMenu, _("&Window"))
            else:
                pMenuBar.Insert(pos, self._pWindowMenu, _("&Window"))
    

    def DoHandleMenu(self, event):

        evId = event.GetId()
        
        if evId == wxWINDOWCLOSE:
            if self._pActiveChild:
                self._pActiveChild.Close()

        elif evId == wxWINDOWCLOSEALL:
            
            while self._pActiveChild:            
                if not self._pActiveChild.Close():
                    return # failure
                
        elif evId == wxWINDOWNEXT:
            self.ActivateNext()

        elif evId == wxWINDOWPREV:
            self.ActivatePrevious()

        else:
            event.Skip()

    
    def Tile(self, orient=wx.HORIZONTAL):

        client_window = self.GetClientWindow()
        if not client_window:
            raise Exception("Missing MDI Client Window")

        cur_idx = client_window.GetSelection()
        if cur_idx == -1:
            return

        if orient == wx.VERTICAL:
        
            client_window.Split(cur_idx, wx.LEFT)
        
        elif orient == wx.HORIZONTAL:
        
            client_window.Split(cur_idx, wx.TOP)
    

#-----------------------------------------------------------------------------
# AuiMDIChildFrame
#-----------------------------------------------------------------------------

class AuiMDIChildFrame(wx.PyPanel):

    def __init__(self, parent, id=wx.ID_ANY, title="", pos=wx.DefaultPosition,
                 size=wx.DefaultSize, style=wx.DEFAULT_FRAME_STYLE, name="AuiMDIChildFrame"):

        pClientWindow = parent.GetClientWindow()
        if pClientWindow is None:
            raise Exception("Missing MDI client window.")

        self.Init()
        
        # see comment in constructor
        if style & wx.MINIMIZE:
            self._activate_on_create = False

        cli_size = pClientWindow.GetClientSize()

        # create the window off-screen to prevent flicker
        wx.PyPanel.__init__(self, pClientWindow, id, wx.Point(cli_size.x+1, cli_size.y+1),
                            size, wx.NO_BORDER, name=name)

        self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
        self.Show(False)
        self.SetMDIParentFrame(parent)

        # this is the currently active child
        parent.SetActiveChild(self)
        self._title = title

        pClientWindow.AddPage(self, title, self._activate_on_create)
        pClientWindow.Refresh()

        self.Bind(wx.EVT_MENU_HIGHLIGHT_ALL, self.OnMenuHighlight)
        self.Bind(wx.EVT_ACTIVATE, self.OnActivate)
        self.Bind(wx.EVT_CLOSE, self.OnCloseWindow)


    def Init(self):

        # There are two ways to create an tabbed mdi child fram without
        # making it the active document.  Either Show(False) can be called
        # before Create() (as is customary on some ports with wxFrame-type
        # windows), or wx.MINIMIZE can be passed in the style flags.  Note that
        # AuiMDIChildFrame is not really derived from wxFrame, as MDIChildFrame
        # is, but those are the expected symantics.  No style flag is passed
        # onto the panel underneath.

        self._activate_on_create = True

        self._pMDIParentFrame = None
        self._pMenuBar = None
        
        self._mdi_currect = None
        self._mdi_newrect = wx.Rect()
        self._icon = None
        self._icon_bundle = None


    def Destroy(self):

        pParentFrame = self.GetMDIParentFrame()
        if not pParentFrame:
            raise Exception("Missing MDI Parent Frame")

        pClientWindow = pParentFrame.GetClientWindow()
        if not pClientWindow:
            raise Exception("Missing MDI Client Window")

        if pParentFrame.GetActiveChild() == self:
        
            # deactivate ourself
            event = wx.ActivateEvent(wx.wxEVT_ACTIVATE, False, self.GetId())
            event.SetEventObject(self)
            self.GetEventHandler().ProcessEvent(event)

            pParentFrame.SetActiveChild(None)
            pParentFrame.SetChildMenuBar(None)
        
        for pos in xrange(pClientWindow.GetPageCount()):
            if pClientWindow.GetPage(pos) == self:
                return pClientWindow.DeletePage(pos)

        return False


    def SetMenuBar(self, menu_bar):

        pOldMenuBar = self._pMenuBar
        self._pMenuBar = menu_bar

        if self._pMenuBar:
        
            pParentFrame = self.GetMDIParentFrame()
            if not pParentFrame:
                raise Exception("Missing MDI Parent Frame")

            self._pMenuBar.Reparent(pParentFrame)
            if pParentFrame.GetActiveChild() == self:
            
                # replace current menu bars
                if pOldMenuBar:
                    pParentFrame.SetChildMenuBar(None)
                    
                pParentFrame.SetChildMenuBar(self)
            

    def GetMenuBar(self):

        return self._pMenuBar


    def SetTitle(self, title):

        self._title = title

        pParentFrame = self.GetMDIParentFrame()
        if not pParentFrame:
            raise Exception("Missing MDI Parent Frame")
        
        pClientWindow = pParentFrame.GetClientWindow()
        if pClientWindow is not None:
        
            for pos in xrange(pClientWindow.GetPageCount()):
                if pClientWindow.GetPage(pos) == self:
                    pClientWindow.SetPageText(pos, self._title)
                    break


    def GetTitle(self):

        return self._title


    def SetIcons(self, icons):

        # get icon with the system icon size
        self.SetIcon(icons.GetIcon(-1))
        self._icon_bundle = icons


    def GetIcons(self):

        return self._icon_bundle


    def SetIcon(self, icon):

        pParentFrame = self.GetMDIParentFrame()
        if not pParentFrame:
            raise Exception("Missing MDI Parent Frame")

        self._icon = icon

        bmp = wx.BitmapFromIcon(self._icon)

        pClientWindow = pParentFrame.GetClientWindow()
        if pClientWindow is not None:
            idx = pClientWindow.GetPageIndex(self)
            if idx != -1:
                pClientWindow.SetPageBitmap(idx, bmp)
        

    def GetIcon(self):

        return self._icon


    def Activate(self):

        pParentFrame = self.GetMDIParentFrame()
        if not pParentFrame:
            raise Exception("Missing MDI Parent Frame")
        
        pClientWindow = pParentFrame.GetClientWindow()
        if pClientWindow is not None:
        
            for pos in xrange(pClientWindow.GetPageCount()):
                if pClientWindow.GetPage(pos) == self:
                    pClientWindow.SetSelection(pos)
                    break
            

    def OnMenuHighlight(self, event):

        if self._pMDIParentFrame:
    
            # we don't have any help text for this item,
            # but may be the MDI frame does?
            self._pMDIParentFrame.OnMenuHighlight(event)


    def OnActivate(self, event):

        # do nothing
        pass


    def OnCloseWindow(self, event):

        pParentFrame = self.GetMDIParentFrame()
        if pParentFrame:
            if pParentFrame.GetActiveChild() == self:
            
                pParentFrame.SetActiveChild(None)
                pParentFrame.SetChildMenuBar(None)
            
            pClientWindow = pParentFrame.GetClientWindow()
            idx = pClientWindow.GetPageIndex(self)
            
            if idx != wx.NOT_FOUND:
                pClientWindow.RemovePage(idx)

        self.Destroy()


    def SetMDIParentFrame(self, parentFrame):

        self._pMDIParentFrame = parentFrame


    def GetMDIParentFrame(self):

        return self._pMDIParentFrame


    def CreateStatusBar(self, number=1, style=1, winid=1, name=""):
        
        return None


    def GetStatusBar(self):

        return None
    

    def SetStatusText(self, text, number=0):

        pass

    
    def SetStatusWidths(self, widths_field):

        pass
    

    # no toolbar bars
    def CreateToolBar(self, style=1, winid=-1, name=""):
        
        return None

    
    def GetToolBar(self):

        return None
    

    # no maximize etc
    def Maximize(self, maximize=True):

        pass


    def Restore(self):
    
        pass

    
    def Iconize(self, iconize=True):

        pass

    
    def IsMaximized(self):

        return True

    
    def IsIconized(self):

        return False

    
    def ShowFullScreen(self, show=True, style=0):

        return False

    
    def IsFullScreen(self):

        return False        


    def IsTopLevel(self):

        return False


    # renamed from Show().
    def ActivateOnCreate(self, activate_on_create):

        self._activate_on_create = activate_on_create
        return True

    
    def Show(self, show=True):

        wx.PyPanel.Show(self, show)


    def ApplyMDIChildFrameRect(self):

        if self._mdi_currect != self._mdi_newrect:
            self.SetDimensions(*self._mdi_newrect)
            self._mdi_currect = wx.Rect(*self._mdi_newrect)


#-----------------------------------------------------------------------------
# AuiMDIClientWindow
#-----------------------------------------------------------------------------

class AuiMDIClientWindow(auibook.AuiNotebook):

    def __init__(self, parent, agwStyle=0):

        auibook.AuiNotebook.__init__(self, parent, wx.ID_ANY, wx.Point(0, 0), wx.Size(100, 100),
                                     agwStyle=AUI_NB_DEFAULT_STYLE|wx.NO_BORDER)

        caption_icon_size = wx.Size(wx.SystemSettings.GetMetric(wx.SYS_SMALLICON_X),
                                    wx.SystemSettings.GetMetric(wx.SYS_SMALLICON_Y))
        self.SetUniformBitmapSize(caption_icon_size)

        bkcolour = wx.SystemSettings.GetColour(wx.SYS_COLOUR_APPWORKSPACE)
        self.SetOwnBackgroundColour(bkcolour)

        self._mgr.GetArtProvider().SetColour(AUI_DOCKART_BACKGROUND_COLOUR, bkcolour)

        self.Bind(auibook.EVT_AUINOTEBOOK_PAGE_CHANGED, self.OnPageChanged)
        self.Bind(auibook.EVT_AUINOTEBOOK_PAGE_CLOSE, self.OnPageClose)
        self.Bind(wx.EVT_SIZE, self.OnSize)


    def SetSelection(self, nPage):

        return auibook.AuiNotebook.SetSelection(self, nPage)


    def PageChanged(self, old_selection, new_selection):

        # don't do anything if the page doesn't actually change
        if old_selection == new_selection:
            return

        # notify old active child that it has been deactivated
        if old_selection != -1 and old_selection < self.GetPageCount():
        
            old_child = self.GetPage(old_selection)
            if not old_child:
                raise Exception("AuiMDIClientWindow.PageChanged - null page pointer")

            event = wx.ActivateEvent(wx.wxEVT_ACTIVATE, False, old_child.GetId())
            event.SetEventObject(old_child)
            old_child.GetEventHandler().ProcessEvent(event)
        
        # notify new active child that it has been activated
        if new_selection != -1:
        
            active_child = self.GetPage(new_selection)
            if not active_child:
                raise Exception("AuiMDIClientWindow.PageChanged - null page pointer")

            event = wx.ActivateEvent(wx.wxEVT_ACTIVATE, True, active_child.GetId())
            event.SetEventObject(active_child)
            active_child.GetEventHandler().ProcessEvent(event)

            if active_child.GetMDIParentFrame():
                active_child.GetMDIParentFrame().SetActiveChild(active_child)
                active_child.GetMDIParentFrame().SetChildMenuBar(active_child)


    def OnPageClose(self, event):

        wnd = self.GetPage(event.GetSelection())
        wnd.Close()

        # regardless of the result of wnd.Close(), we've
        # already taken care of the close operations, so
        # suppress further processing
        event.Veto()


    def OnPageChanged(self, event):

        self.PageChanged(event.GetOldSelection(), event.GetSelection())


    def OnSize(self, event):

        auibook.AuiNotebook.OnSize(self, event)

        for pos in xrange(self.GetPageCount()):
            self.GetPage(pos).ApplyMDIChildFrameRect()

########NEW FILE########
__FILENAME__ = wx_widget
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx

from atom.api import Typed

from enaml.widgets.widget import ProxyWidget

from .wx_layout_request import wxEvtLayoutRequested
from .wx_resource_helpers import get_cached_wxcolor, get_cached_wxfont
from .wx_toolkit_object import WxToolkitObject


class WxWidget(WxToolkitObject, ProxyWidget):
    """ A Wx implementation of an Enaml ProxyWidget.

    """
    #: A reference to the toolkit widget created by the proxy.
    widget = Typed(wx.Window)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def create_widget(self):
        """ Creates the underlying wx.Window widget.

        """
        self.widget = wx.Window(self.parent_widget())

    def init_widget(self):
        """ Initialize the underlying widget.

        """
        super(WxWidget, self).init_widget()
        d = self.declaration
        if d.background:
            self.set_background(d.background)
        if d.foreground:
            self.set_foreground(d.foreground)
        if d.font:
            self.set_font(d.font)
        if -1 not in d.minimum_size:
            self.set_minimum_size(d.minimum_size)
        if -1 not in d.maximum_size:
            self.set_maximum_size(d.maximum_size)
        if d.tool_tip:
            self.set_tool_tip(d.tool_tip)
        if d.status_tip:
            self.set_status_tip(d.status_tip)
        self.set_enabled(d.enabled)
        self.set_visible(d.visible)

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def post_wx_layout_request(self):
        """ Post a wx layout request event to this widget's parent.

        This method should be called when the geometry of the widget has
        changed and the layout system should update the layout. This will
        post a wxEvtLayoutRequested event to the parent of this widget.

        """
        widget = self.widget
        if widget:
            parent = widget.GetParent()
            if parent:
                event = wxEvtLayoutRequested(widget.GetId())
                wx.PostEvent(parent, event)

    #--------------------------------------------------------------------------
    # ProxyWidget API
    #--------------------------------------------------------------------------
    def set_minimum_size(self, min_size):
        """ Sets the minimum size on the underlying widget.

        """
        self.widget.SetMinSize(wx.Size(*min_size))

    def set_maximum_size(self, max_size):
        """ Sets the maximum size on the underlying widget.

        """
        self.widget.SetMaxSize(wx.Size(*max_size))

    def set_enabled(self, enabled):
        """ Set the enabled state on the underlying widget.

        """
        self.widget.Enable(enabled)

    def set_visible(self, visible):
        """ Set the visibility state on the underlying widget.

        """
        self.widget.Show(visible)

    def set_background(self, background):
        """ Set the background color on the underlying widget.

        """
        if background is None:
            wxcolor = wx.NullColour
        else:
            wxcolor = get_cached_wxcolor(background)
        widget = self.widget
        widget.SetBackgroundColour(wxcolor)
        widget.Refresh()

    def set_foreground(self, foreground):
        """ Set the foreground color on the underlying widget.

        """
        if foreground is None:
            wxcolor = wx.NullColour
        else:
            wxcolor = get_cached_wxcolor(foreground)
        widget = self.widget
        widget.SetForegroundColour(wxcolor)
        widget.Refresh()

    def set_font(self, font):
        """ Set the font on the underlying widget.

        """
        if font is not None:
            wxfont = get_cached_wxfont(font)
        else:
            index = wx.SYS_DEFAULT_GUI_FONT
            wxfont = wx.SystemSettings.GetFont(index)
        widget = self.widget
        widget.SetFont(wxfont)
        widget.Refresh()

    def set_tool_tip(self, tool_tip):
        """ Set the tool tip of for this widget.

        """
        self.widget.SetToolTipString(tool_tip)

    def set_status_tip(self, status_tip):
        """ This is not supported on Wx.

        """
        pass

    def ensure_visible(self):
        """ Ensure the widget is visible.

        """
        self.widget.Show(True)

    def ensure_hidden(self):
        """ Ensure the widget is hidden.

        """
        self.widget.Show(False)

    def restyle(self):
        """ Stylesheets are not supported on Wx.

        """
        pass

########NEW FILE########
__FILENAME__ = wx_window
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import wx

from atom.api import Typed

from enaml.layout.geometry import Pos, Rect, Size
from enaml.widgets.window import ProxyWindow, CloseEvent

from .wx_action import wxAction
from .wx_container import WxContainer
from .wx_layout_request import EVT_COMMAND_LAYOUT_REQUESTED
from .wx_single_widget_sizer import wxSingleWidgetSizer
from .wx_widget import WxWidget


def finalize_close(d):
    """ Finalize the closing of the declaration object.

    This is performed as a deferred call so that the window may fully
    close before the declaration is potentially destroyed.

    """
    d.visible = False
    d.closed()
    if d.destroy_on_close:
        d.destroy()


class wxCustomWindow(wx.Frame):
    """ A custom wxFrame which manages a central widget.

    The window layout computes the min/max size of the window based
    on its central widget, unless the user explicitly changes them.

    """
    def __init__(self, *args, **kwargs):
        """ Initialize a wxCustomWindow.

        Parameters
        ----------
        *args, **kwargs
            The positional and keyword arguments needed to initialize
            a wxFrame.

        """
        super(wxCustomWindow, self).__init__(*args, **kwargs)
        self._central_widget = None
        self.SetSizer(wxSingleWidgetSizer())
        self.Bind(wx.EVT_MENU, self.OnMenu)
        self.Bind(wx.EVT_CLOSE, self.OnClose)

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def OnMenu(self, event):
        """ The event handler for the EVT_MENU event.

        This event handler will be called when an action is triggered
        in a Menu or a ToolBar.

        """
        action = wxAction.FindById(event.GetId())
        if action is not None:
            if action.IsCheckable():
                action.SetChecked(event.Checked())
            action.Trigger()

    def OnClose(self, event):
        """ The event handler for the EVT_CLOSE event.

        This event handler prevents the frame from being destroyed on
        close. Instead it just sets the visibility to False.

        """
        self.Hide()

    #--------------------------------------------------------------------------
    # Public API
    #--------------------------------------------------------------------------
    def UpdateClientSizeHints(self):
        """ Update the client size hints for the window.

        This will update the min and max sizes for the window according
        to the current window state. This method is called automatically
        when the central widget is changed.

        """
        sizer = self.GetSizer()
        min_w, min_h = self.ClientToWindowSize(sizer.CalcMin())
        max_w, max_h = self.ClientToWindowSize(sizer.CalcMax())
        self.SetSizeHints(min_w, min_h, max_w, max_h)
        cur_w, cur_h = self.GetSize()
        new_w = min(max_w, max(min_w, cur_w))
        new_h = min(max_h, max(min_h, cur_h))
        if cur_w != new_w or cur_h != new_h:
            self.SetSize(wx.Size(new_w, new_h))

    def GetCentralWidget(self):
        """ Returns the central widget for the window.

        Returns
        -------
        result : wxWindow or None
            The central widget of the window, or None if no widget
            was provided.

        """
        return self._central_widget

    def SetCentralWidget(self, widget):
        """ Set the central widget for this window.

        Parameters
        ----------
        widget : wxWindow
            The widget to use as the content of the window.

        """
        self._central_widget = widget
        self.GetSizer().Add(widget)
        self.UpdateClientSizeHints()


class WxWindow(WxWidget, ProxyWindow):
    """ A Wx implementation of an Enaml ProxyWindow.

    """
    #: A reference tot he toolkit widget created by the proxy.
    widget = Typed(wxCustomWindow)

    #--------------------------------------------------------------------------
    # Initialization API
    #--------------------------------------------------------------------------
    def creation_style(self):
        """ A convenience function for getting the creation style.

        """
        style = wx.DEFAULT_FRAME_STYLE
        if self.declaration.always_on_top:
            style |= wx.STAY_ON_TOP
        return style

    def create_widget(self):
        """ Create the underlying wxCustomWindow widget.

        """
        style = self.creation_style()
        self.widget = wxCustomWindow(self.parent_widget(), style=style)

    def init_widget(self):
        """ Initialize the window control.

        """
        super(WxWindow, self).init_widget()
        d = self.declaration
        if d.title:
            self.set_title(d.title)
        if -1 not in d.initial_size:
            self.widget.SetClientSize(wx.Size(*d.initial_size))
        if -1 not in d.initial_position:
            self.widget.Move(wx.Point(*d.initial_position))
        if d.icon:
            self.set_icon(d.icon)
        self.widget.Bind(wx.EVT_CLOSE, self.on_close)

    def init_layout(self):
        """ Perform layout initialization for the control.

        """
        super(WxWindow, self).init_layout()
        widget = self.widget
        widget.SetCentralWidget(self.central_widget())
        widget.Bind(EVT_COMMAND_LAYOUT_REQUESTED, self.on_layout_requested)

    #--------------------------------------------------------------------------
    # Utility Methods
    #--------------------------------------------------------------------------
    def central_widget(self):
        """ Find and return the central widget child for this widget.

        Returns
        -------
        result : wxWindow or None
            The central widget defined for this widget, or None if one
            is not defined.

        """
        d = self.declaration.central_widget()
        if d is not None:
            return d.proxy.widget or None

    #--------------------------------------------------------------------------
    # Child Events
    #--------------------------------------------------------------------------
    def child_removed(self, child):
        """ Handle the child removed event for a QtWindow.

        """
        if isinstance(child, WxContainer):
            self.widget.SetCentralWidget(self.central_widget())

    def child_added(self, child):
        """ Handle the child added event for a QtWindow.

        """
        if isinstance(child, WxContainer):
            self.widget.SetCentralWidget(self.central_widget())

    #--------------------------------------------------------------------------
    # Event Handlers
    #--------------------------------------------------------------------------
    def on_close(self, event):
        """ The event handler for the EVT_CLOSE event.

        """
        d = self.declaration
        d_event = CloseEvent()
        d.closing(d_event)
        if d_event.is_accepted():
            event.Skip()
            # Make sure the frame is not modal when closing, or no other
            # windows will be unblocked.
            self.widget.MakeModal(False)
            wx.CallAfter(finalize_close, d)
        else:
            event.Veto()

    def on_layout_requested(self, event):
        """ Handle the layout request event from the central widget.

        """
        # wx likes to send events after the widget is destroyed.
        if self.widget:
            self.widget.UpdateClientSizeHints()

    #--------------------------------------------------------------------------
    # ProxyWindow API
    #--------------------------------------------------------------------------
    def set_title(self, title):
        """ Set the title of the window.

        """
        self.widget.SetTitle(title)

    def set_modality(self, modality):
        """ Set the modality of the window.

        """
        if modality == 'non_modal':
            self.widget.MakeModal(False)
        else:
            self.widget.MakeModal(True)

    def set_icon(self, icon):
        """ This is not supported on Wx.

        """
        pass

    def position(self):
        """ Get the position of the of the window.

        """
        point = self.widget.GetPosition()
        return Pos(point.x, point.y)

    def set_position(self, pos):
        """ Set the position of the window.

        """
        self.widget.SetPosition(wx.Point(*pos))

    def size(self):
        """ Get the size of the window.

        """
        size = self.widget.GetClientSize()
        return Size(size.GetWidth(), size.GetHeight())

    def set_size(self, size):
        """ Set the size of the window.

        """
        size = wx.Size(*size)
        if size.IsFullySpecified():
            self.widget.SetClientSize(size)

    def geometry(self):
        """ Get the geometry of the window.

        """
        # Wx has no standard way of taking into account the size of
        # the window frame. I'm not spending time on a workaround.
        point = self.widget.GetPosition()
        size = self.widget.GetClientSize()
        return Rect(point.x, point.y, size.GetWidth(), size.GetHeight())

    def set_geometry(self, rect):
        """ Set the geometry of the window.

        """
        self.set_position(rect[:2])
        self.set_size(rect[2:])

    def frame_geometry(self):
        """ Get the geometry of the window.

        """
        r = self.widget.GetRect()
        return Rect(r.GetX(), r.GetY(), r.GetWidth(), r.GetHeight())

    def maximize(self):
        """ Maximize the window.

        """
        self.widget.Maximize(True)

    def is_maximized(self):
        """ Get whether the window is maximized.

        """
        return self.widget.IsMaximized()

    def minimize(self):
        """ Minimize the window.

        """
        self.widget.Iconize(True)

    def is_minimized(self):
        """ Get whether the window is minimized.

        """
        return self.widget.IsIconized()

    def restore(self):
        """ Restore the window after a minimize or maximize.

        """
        self.widget.Maximize(False)

    def send_to_front(self):
        """ Move the window to the top of the Z order.

        """
        self.widget.Raise()

    def send_to_back(self):
        """ Move the window to the bottom of the Z order.

        """
        self.widget.Lower()

    def activate_window(self):
        """ Activate the underlying window widget.

        """
        # wx makes no distinction between raise and activate
        self.widget.Raise()

    def center_on_screen(self):
        """ Center the window on the screen.

        """
        self.widget.CenterOnScreen()

    def center_on_widget(self, other):
        """ Center the window on another widget.

        """
        widget = self.widget
        rect = widget.GetRect()
        geo = other.proxy.widget.GetScreenRect()
        widget.Move(rect.CenterIn(geo).GetPosition())

    def close(self):
        """ Close the window

        """
        self.widget.Close()

    #--------------------------------------------------------------------------
    # Overrides
    #--------------------------------------------------------------------------
    def set_visible(self, visible):
        """ Set the visibility state on the underlying widget.

        This override sets the modality to false when hiding the window
        and enabled it when showing the window (if requested).

        """
        modality = self.declaration.modality
        self.widget.MakeModal(visible and modality != 'non_modal')
        self.widget.Show(visible)

    def ensure_visible(self):
        """ Ensure the widget is visible.

        This override forwards to the 'set_visible' method so that the
        window modality is handled properly.

        """
        self.set_visible(True)

    def ensure_hidden(self):
        """ Ensure the widget is hidden.

        This override forwards to the 'set_visible' method so that the
        window modality is handled properly.

        """
        self.set_visible(False)

########NEW FILE########
__FILENAME__ = employee
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import datetime

from atom.api import Atom, Unicode, Range, Bool, Value, Int, Tuple, observe
import enaml
from enaml.qt.qt_application import QtApplication


class Person(Atom):
    """ A simple class representing a person object.

    """
    last_name = Unicode()

    first_name = Unicode()

    age = Range(low=0)

    dob = Value(datetime.date(1970, 1, 1))

    debug = Bool(False)

    @observe('age')
    def debug_print(self, change):
        """ Prints out a debug message whenever the person's age changes.

        """
        if self.debug:
            templ = "{first} {last} is {age} years old."
            s = templ.format(
                first=self.first_name, last=self.last_name, age=self.age,
            )
            print s


class Employer(Person):
    """ An employer is a person who runs a company.

    """
    # The name of the company
    company_name = Unicode()


class Employee(Person):
    """ An employee is person with a boss and a phone number.

    """
    # The employee's boss
    boss = Value(Employer)

    # The employee's phone number as a tuple of 3 ints
    phone = Tuple(Int())

    # This method will be called automatically by atom when the
    # employee's phone number changes
    def _phone_changed(self, val):
        print 'received new phone number for %s: %s' % (self.first_name, val)


if __name__ == '__main__':
    # Create an employee with a boss
    boss_john = Employer(
        first_name='John', last_name='Paw', company_name="Packrat's Cats",
    )
    employee_mary = Employee(
        first_name='Mary', last_name='Sue', boss=boss_john,
        phone=(555, 555, 5555),
    )

    # Import our Enaml EmployeeView
    with enaml.imports():
        from employee_view import EmployeeView

    app = QtApplication()
    # Create a view and show it.
    view = EmployeeView(employee=employee_mary)
    view.show()

    app.start()

########NEW FILE########
__FILENAME__ = phone_validator
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import re

from enaml.validator import Validator


class PhoneNumberValidator(Validator):
    """ A really dumb phone number validator.

    """
    all_digits = re.compile(r'[0-9]{10}$')

    dashes = re.compile(r'([0-9]{3})\-([0-9]{3})\-([0-9]{4})$')

    proper = re.compile(r'\(([0-9]{3})\)\ ([0-9]{3})\-([0-9]{4})$')

    def validate(self, text):
        """ Validate the input text.

        The text must be in of the form: (555) 555-5555 in order to
        pass the standard validation. The fixup method will convert
        some alternative forms into a correct format.

        """
        return bool(self.proper.match(text))

    def fixup(self, text):
        """ Attempt to convert the given text into the proper format.

        This method is called by the backend when the current text is
        not valid, but can maybe be *made* to be valid by this method.
        The returned text is re-validated to test for viability.

        """
        match = self.dashes.match(text)
        if match:
            area = match.group(1)
            prefix = match.group(2)
            suffix = match.group(3)
            return u'(%s) %s-%s' % (area, prefix, suffix)
        match = self.all_digits.match(text)
        if match:
            area = text[:3]
            prefix = text[3:6]
            suffix = text[6:10]
            return u'(%s) %s-%s' % (area, prefix, suffix)
        return text

########NEW FILE########
__FILENAME__ = hello_world
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import enaml
from enaml.qt.qt_application import QtApplication


def main():
    with enaml.imports():
        from hello_world_view import Main

    app = QtApplication()

    view = Main(message="Hello World, from Python!")
    view.show()

    # Start the application event loop
    app.start()


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = person
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Atom, Unicode, Range, Bool, observe

import enaml
from enaml.qt.qt_application import QtApplication


class Person(Atom):
    """ A simple class representing a person object.

    """
    last_name = Unicode()

    first_name = Unicode()

    age = Range(low=0)

    debug = Bool(False)

    @observe('age')
    def debug_print(self, change):
        """ Prints out a debug message whenever the person's age changes.

        """
        if self.debug:
            templ = "{first} {last} is {age} years old."
            s = templ.format(
                first=self.first_name, last=self.last_name, age=self.age,
            )
            print s


if __name__ == '__main__':
    with enaml.imports():
        from person_view import PersonView

    john = Person(first_name='John', last_name='Doe', age=42)
    john.debug = True

    app = QtApplication()
    view = PersonView(person=john)
    view.show()

    app.start()

########NEW FILE########
__FILENAME__ = persistent_workspace
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
import cPickle

from atom.api import Unicode

from enaml.widgets.api import Container
from enaml.workbench.ui.api import Workspace

import enaml
with enaml.imports():
    from persistent_view import PersistentManifest, create_new_area


print 'Imported Persistent Workspace!'


#: Storage for the pickled dock area. This would be saved
#: to some persistent storage media in a real application.
PICKLED_DOCK_AREA = None


class PersistentWorkspace(Workspace):
    """ A custom Workspace class for the crash course example.

    """
    #: Storage for the plugin manifest's id.
    _manifest_id = Unicode()

    def start(self):
        """ Start the workspace instance.

        This method will create the container content and register the
        provided plugin with the workbench.

        """
        self.content = Container(padding=0)
        self.load_area()
        manifest = PersistentManifest()
        self._manifest_id = manifest.id
        self.workbench.register(manifest)

    def stop(self):
        """ Stop the workspace instance.

        This method will unregister the workspace's plugin that was
        registered on start.

        """
        self.save_area()
        self.workbench.unregister(self._manifest_id)

    def save_area(self):
        """ Save the dock area for the workspace.

        """
        global PICKLED_DOCK_AREA
        area = self.content.find('the_dock_area')
        PICKLED_DOCK_AREA = cPickle.dumps(area, -1)

    def load_area(self):
        """ Load the dock area into the workspace content.

        """
        if PICKLED_DOCK_AREA is not None:
            area = cPickle.loads(PICKLED_DOCK_AREA)
        else:
            area = create_new_area()
        area.set_parent(self.content)

########NEW FILE########
__FILENAME__ = sample
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
""" A simple example plugin application.

This example serves to demostrates the concepts described the accompanying
developer crash source document.

"""
from enaml.workbench.ui.api import UIWorkbench


if __name__ == '__main__':
    import enaml
    with enaml.imports():
        from sample_plugin import SampleManifest

    workbench = UIWorkbench()
    workbench.register(SampleManifest())
    workbench.run()

########NEW FILE########
__FILENAME__ = sample_workspace
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from atom.api import Subclass, Unicode

from enaml.widgets.api import Container
from enaml.workbench.api import PluginManifest
from enaml.workbench.ui.api import Workspace


print 'Imported Sample Workspace!'


class SampleWorkspace(Workspace):
    """ A custom Workspace class for the crash course example.

    This workspace class will instantiate the content and register an
    additional plugin with the workbench when it is started. The extra
    plugin can be used to add addtional functionality to the workbench
    window while this workspace is active. The plugin is unregistered
    when the workspace is stopped.

    """
    #: The enamldef'd Container to create when the workbench is started.
    content_def = Subclass(Container)

    #: The enamldef'd PluginManifest to register on start.
    manifest_def = Subclass(PluginManifest)

    #: Storage for the plugin manifest's id.
    _manifest_id = Unicode()

    def start(self):
        """ Start the workspace instance.

        This method will create the container content and register the
        provided plugin with the workbench.

        """
        self.content = self.content_def()
        manifest = self.manifest_def()
        self._manifest_id = manifest.id
        self.workbench.register(manifest)

    def stop(self):
        """ Stop the workspace instance.

        This method will unregister the workspace's plugin that was
        registered on start.

        """
        self.workbench.unregister(self._manifest_id)

########NEW FILE########
__FILENAME__ = test_alias
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from textwrap import dedent

from nose.tools import raises

from utils import compile_source


#------------------------------------------------------------------------------
# Alias Syntax
#------------------------------------------------------------------------------
def test_syntax_1():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias pb
        PushButton: pb:
            name = 'button'

    enamldef Main(Window):
        Content:
            name = 'content'

    """)
    compile_source(source, 'Main')


def test_syntax_2():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias pc: pb
        PushButton: pb:
            name = 'button'

    enamldef Main(Window):
        Content:
            name = 'content'

    """)
    compile_source(source, 'Main')


def test_syntax_3():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias pc: pb.text
        PushButton: pb:
            name = 'button'

    enamldef Main(Window):
        Content:
            name = 'content'

    """)
    compile_source(source, 'Main')


#------------------------------------------------------------------------------
# Bad Alias Syntax
#------------------------------------------------------------------------------
@raises(SyntaxError)
def test_bad_syntax_1():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias pb.text
        PushButton: pb:
            text = 'spam'

    enamldef Main(Window):
        Content:
            name = 'content'

    """)
    compile_source(source, 'Main')


@raises(SyntaxError)
def test_bad_syntax_2():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias pb text
        PushButton: pb:
            text = 'spam'

    enamldef Main(Window):
        Content:
            name = 'content'

    """)
    compile_source(source, 'Main')


@raises(SyntaxError)
def test_bad_syntax_3():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias pb: pb text
        PushButton: pb:
            text = 'spam'

    enamldef Main(Window):
        Content:
            name = 'content'

    """)
    compile_source(source, 'Main')


#------------------------------------------------------------------------------
# Alias References
#------------------------------------------------------------------------------
def test_ref_1():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias pb
        PushButton: pb:
            name = 'button'

    enamldef Main(Window):
        Content:
            name = 'content'

    """)
    main = compile_source(source, 'Main')()
    button = main.find('button')
    content = main.find('content')
    assert content.pb is button


def test_ref_2():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias pb: pb
        PushButton: pb:
            name = 'button'

    enamldef Main(Window):
        Content:
            name = 'content'

    """)
    main = compile_source(source, 'Main')()
    button = main.find('button')
    content = main.find('content')
    assert content.pb is button


def test_ref_3():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias foo: pb
        PushButton: pb:
            name = 'button'

    enamldef Main(Window):
        Content:
            name = 'content'

    """)
    main = compile_source(source, 'Main')()
    button = main.find('button')
    content = main.find('content')
    assert content.foo is button


def test_ref_4():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias pb: pb.text
        PushButton: pb:
            text = 'spam'

    enamldef Main(Window):
        Content:
            name = 'content'

    """)
    main = compile_source(source, 'Main')()
    content = main.find('content')
    assert content.pb == 'spam'


def test_ref_5():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Other(Container):
        alias slider
        Slider: slider:
            name = 'slider'

    enamldef Content(Container):
        alias other
        Other: other:
            pass

    enamldef Main(Window):
        Content:
            name = 'content'

    """)
    main = compile_source(source, 'Main')()
    slider = main.find('slider')
    content = main.find('content')
    assert content.other.slider is slider


def test_ref_6():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Other(Container):
        alias value: slider.value
        Slider: slider:
            value = 50

    enamldef Content(Container):
        alias other
        Other: other:
            pass

    enamldef Main(Window):
        Content:
            name = 'content'

    """)
    main = compile_source(source, 'Main')()
    content = main.find('content')
    assert content.other.value == 50


def test_ref_7():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Other(Container):
        alias value: slider.value
        Slider: slider:
            value = 50

    enamldef Content(Container):
        alias value: other.value
        Other: other:
            pass

    enamldef Main(Window):
        Content:
            name = 'content'

    """)
    main = compile_source(source, 'Main')()
    content = main.find('content')
    assert content.value == 50


def test_ref_8():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Other(Container):
        alias slider
        Slider: slider:
            value = 50

    enamldef Content(Container):
        alias value: other.slider.value
        Other: other:
            pass

    enamldef Main(Window):
        Content:
            name = 'content'

    """)
    main = compile_source(source, 'Main')()
    content = main.find('content')
    assert content.value == 50


#------------------------------------------------------------------------------
# Bad Alias Reference
#------------------------------------------------------------------------------
@raises(TypeError)
def test_bad_ref_1():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias pc
        PushButton: pb:
            text = 'spam'

    enamldef Main(Window):
        Content:
            name = 'content'

    """)
    compile_source(source, 'Main')


@raises(TypeError)
def test_bad_ref_2():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias pc: pd
        PushButton: pb:
            text = 'spam'

    enamldef Main(Window):
        Content:
            name = 'content'

    """)
    compile_source(source, 'Main')


@raises(TypeError)
def test_bad_ref_3():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias pc: pb.tex
        PushButton: pb:
            text = 'spam'

    enamldef Main(Window):
        Content:
            name = 'content'

    """)
    compile_source(source, 'Main')


@raises(TypeError)
def test_bad_ref_4():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias pc: pb.text.spam
        PushButton: pb:
            text = 'spam'

    enamldef Main(Window):
        Content:
            name = 'content'

    """)
    compile_source(source, 'Main')


@raises(TypeError)
def test_bar_ref_5():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Other(Container):
        alias value: slider.value
        Slider: slider:
            value = 50

    enamldef Content(Container):
        alias value: other.valued
        Other: other:
            pass

    enamldef Main(Window):
        Content:
            name = 'content'

    """)
    compile_source(source, 'Main')


@raises(TypeError)
def test_bad_ref_6():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Other(Container):
        alias slider
        Slider: slider:
            value = 50

    enamldef Content(Container):
        alias value: other.slider.valsue
        Other: other:
            pass

    enamldef Main(Window):
        Content:
            name = 'content'

    """)
    compile_source(source, 'Main')


#------------------------------------------------------------------------------
# Alias Binding
#------------------------------------------------------------------------------
def test_bind_1():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias pb: pb.text
        PushButton: pb:
            name = 'button'

    enamldef Main(Window):
        Content:
            pb = 'foo'

    """)
    main = compile_source(source, 'Main')()
    button = main.find('button')
    assert button.text == 'foo'


def test_bind_2():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Other(Container):
        alias slider
        Slider: slider:
            name = 'slider'

    enamldef Content(Container):
        alias value: other.slider.value
        Other: other:
            pass

    enamldef Main(Window):
        Content:
            value = 50

    """)
    main = compile_source(source, 'Main')()
    slider = main.find('slider')
    assert slider.value == 50


def test_bind_3():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Other(Container):
        alias value: slider.value
        Slider: slider:
            name = 'slider'
            value = 50

    enamldef Content(Container):
        alias value: other.value
        Other: other:
            pass

    enamldef Main(Window):
        Content:
            value = 42

    """)
    main = compile_source(source, 'Main')()
    slider = main.find('slider')
    assert slider.value == 42


#------------------------------------------------------------------------------
# Bad Alias Binding
#------------------------------------------------------------------------------
@raises(TypeError)
def test_bad_bind_1():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias pb
        PushButton: pb:
            name = 'button'

    enamldef Main(Window):
        Content:
            pb = 'foo'

    """)
    compile_source(source, 'Main')


@raises(TypeError)
def test_bad_bind_2():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias text: pb.text
        PushButton: pb:
            name = 'button'

    enamldef Main(Window):
        Content:
            txt = 'foo'

    """)
    compile_source(source, 'Main')


#------------------------------------------------------------------------------
# Extended Alias Binding
#------------------------------------------------------------------------------
def test_ex_bind_1():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias pb
        PushButton: pb:
            name = 'button'

    enamldef Main(Window):
        Content:
            pb.text = 'foo'

    """)
    main = compile_source(source, 'Main')()
    button = main.find('button')
    assert button.text == 'foo'


def test_ex_bind_2():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Other(Container):
        alias slider
        Slider: slider:
            name = 'slider'

    enamldef Content(Container):
        alias value: other.slider
        Other: other:
            pass

    enamldef Main(Window):
        Content:
            value.value = 50

    """)
    main = compile_source(source, 'Main')()
    slider = main.find('slider')
    assert slider.value == 50


def test_ex_bind_3():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Other(Container):
        alias slider
        Slider: slider:
            name = 'slider'

    enamldef Content(Container):
        alias value: other
        Other: other:
            pass

    enamldef Main(Window):
        Content:
            value.slider.value = 42

    """)
    main = compile_source(source, 'Main')()
    slider = main.find('slider')
    assert slider.value == 42


#------------------------------------------------------------------------------
# Bad Alias Binding
#------------------------------------------------------------------------------
@raises(TypeError)
def test_bad_ex_bind_1():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias pb
        PushButton: pb:
            name = 'button'

    enamldef Main(Window):
        Content:
            pbd.text = 'foo'

    """)
    compile_source(source, 'Main')


@raises(TypeError)
def test_bad_ex_bind_2():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias pb
        PushButton: pb:
            name = 'button'

    enamldef Main(Window):
        Content:
            pb.txt = 'foo'

    """)
    compile_source(source, 'Main')


@raises(TypeError)
def test_bad_ex_bind_3():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Other(Container):
        alias slider
        Slider: slider:
            name = 'slider'

    enamldef Content(Container):
        alias value: other.slider
        Other: other:
            pass

    enamldef Main(Window):
        Content:
            value.val = 50

    """)
    compile_source(source, 'Main')


#------------------------------------------------------------------------------
# Alias Ordering
#------------------------------------------------------------------------------
def test_ordering():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        Field: field:
            alias this_text: field.text
        alias text: field.this_text

    enamldef Main(Window):
        Content:
            pass

    """)
    compile_source(source, 'Main')


#------------------------------------------------------------------------------
# Bad Alias Ordering
#------------------------------------------------------------------------------
@raises(TypeError)
def test_bar_ordering():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias text: field.this_text
        Field: field:
            alias this_text: field.text

    enamldef Main(Window):
        Content:
            pass

    """)
    compile_source(source, 'Main')


#------------------------------------------------------------------------------
# Bad Alias Override
#------------------------------------------------------------------------------
@raises(TypeError)
def test_bad_override_1():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias background
        Field: background:
            pass

    enamldef Main(Window):
        Content:
            pass

    """)
    compile_source(source, 'Main')


@raises(TypeError)
def test_bad_override_2():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias foo
        Field: foo:
            pass

    enamldef Content2(Content):
        alias foo: bar
        Field: bar:
            pass

    enamldef Main(Window):
        Content2:
            pass

    """)
    compile_source(source, 'Main')


@raises(TypeError)
def test_bad_override_3():
    source = dedent("""\
    from enaml.widgets.api import *

    enamldef Content(Container):
        alias foo
        Field: foo:
            pass

    enamldef Content2(Content):
        attr foo

    enamldef Main(Window):
        Content2:
            pass

    """)
    compile_source(source, 'Main')

########NEW FILE########
__FILENAME__ = test_q_resource_helpers
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from enaml.fontext import Font
from enaml.qt.q_resource_helpers import QFont_from_Font


def test_QFont_from_Font():
    # Regression test for PySide: QFont_from_Font was raising a TypeError
    # in its call to qfont.setStyle(font.style).  This test passes if it
    # does not raise an exception.
    f = Font(family="bold")
    qf = QFont_from_Font(f)

########NEW FILE########
__FILENAME__ = test_stylesheet
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from textwrap import dedent

from utils import compile_source


def test_setter_data():
    source = dedent("""\
    from enaml.styling import Setter

    enamldef MySetter(Setter):
        field = 'background'
        value = 'blue'

    """)
    setter = compile_source(source, 'MySetter')()
    assert setter.field == u'background'
    assert setter.value == u'blue'


def test_style_data():
    source = dedent("""\
    from enaml.styling import Style

    enamldef MyStyle(Style):
        element = 'PushButton'
        style_class = 'button'
        object_name = 'pb1'
        pseudo_class = 'pressed'
        pseudo_element = 'menu-indicator'

    """)
    style = compile_source(source, 'MyStyle')()
    assert style.element == u'PushButton'
    assert style.style_class == u'button'
    assert style.object_name == u'pb1'
    assert style.pseudo_class == u'pressed'
    assert style.pseudo_element == u'menu-indicator'


def test_style_setters():
    source = dedent("""\
    from enaml.core.declarative import Declarative
    from enaml.styling import Style, Setter

    enamldef MyStyle(Style):
        Setter:
            pass
        Declarative:
            pass
        Setter:
            pass
        Declarative:
            pass
        Setter:
            pass

    """)
    style = compile_source(source, 'MyStyle')()
    assert len(style.setters()) == 3


def test_stylesheet_styles():
    source = dedent("""\
    from enaml.core.declarative import Declarative
    from enaml.styling import StyleSheet, Style

    enamldef Sheet(StyleSheet):
        Style:
            pass
        Declarative:
            pass
        Style:
            pass
        Declarative:
            pass
        Style:
            pass

    """)
    sheet = compile_source(source, 'Sheet')()
    assert len(sheet.styles()) == 3


def test_element_selector():
    from enaml.styling import StyleCache
    source = dedent("""\
    from enaml.widgets.api import Window, Container, PushButton, Field
    from enaml.styling import StyleSheet, Style, Setter

    enamldef Sheet(StyleSheet):
        Style:
            element = 'PushButton'
            Setter:
                field = 'background'
                value = 'blue'

    enamldef SubButton(PushButton):
        pass

    enamldef Main(Window):
        alias button
        alias subbutton
        alias field
        Sheet:
            pass
        Container:
            PushButton: button:
                pass
            SubButton: subbutton:
                pass
            Field: field:
                pass

    """)
    main = compile_source(source, 'Main')()
    assert len(StyleCache.styles(main.button)) == 1
    assert len(StyleCache.styles(main.subbutton)) == 1
    assert len(StyleCache.styles(main.field)) == 0


def test_class_selector():
    from enaml.styling import StyleCache
    source = dedent("""\
    from enaml.widgets.api import Window, Container, PushButton
    from enaml.styling import StyleSheet, Style, Setter

    enamldef Sheet(StyleSheet):
        Style:
            style_class = 'button'
            Setter:
                field = 'background'
                value = 'blue'

    enamldef Main(Window):
        alias button
        alias other
        Sheet:
            pass
        Container:
            PushButton: button:
                style_class = 'button'
            PushButton: other:
                pass

    """)
    main = compile_source(source, 'Main')()
    assert len(StyleCache.styles(main.button)) == 1
    assert len(StyleCache.styles(main.other)) == 0


def test_name_selector():
    from enaml.styling import StyleCache
    source = dedent("""\
    from enaml.widgets.api import Window, Container, PushButton
    from enaml.styling import StyleSheet, Style, Setter

    enamldef Sheet(StyleSheet):
        Style:
            object_name = 'button'
            Setter:
                field = 'background'
                value = 'blue'

    enamldef Main(Window):
        alias button
        alias other
        Sheet:
            pass
        Container:
            PushButton: button:
                name = 'button'
            PushButton: other:
                style_class = 'button'

    """)
    main = compile_source(source, 'Main')()
    assert len(StyleCache.styles(main.button)) == 1
    assert len(StyleCache.styles(main.other)) == 0


def _assert_setters(item, values):
    from enaml.styling import StyleCache
    styles = StyleCache.styles(item)
    setters = [s.setters() for s in styles]
    setters = sum(setters, [])
    assert len(setters) == len(values)
    for setter, (field, value) in zip(setters, values):
        assert setter.field == field
        assert setter.value == value


def test_specificity():
    source = dedent("""\
    from enaml.widgets.api import Window, Container, PushButton, Field, Slider
    from enaml.styling import StyleSheet, Style, Setter

    enamldef Sheet(StyleSheet):
        Style:
            style_class = 'yellow'
            Setter:
                field = 'background'
                value = 'yellow'
        Style:
            object_name = 'button'
            Setter:
                field = 'background'
                value = 'green'
        Style:
            style_class = 'strong, bold'
            Setter:
                field = 'font-weight'
                value = 'bold'
        Style:
            element = 'Field'
            style_class = 'gray-text'
            Setter:
                field = 'color'
                value = 'gray'
        Style:
            element = 'PushButton'
            Setter:
                field = 'background'
                value = 'red'
        Style:
            Setter:
                field = 'background'
                value = 'blue'

    enamldef Main(Window):
        alias one
        alias two
        alias three
        alias four
        alias five
        alias six
        alias seven
        alias eight
        alias nine
        Sheet:
            pass
        Container:
            PushButton: one:
                pass
            Field: two:
                pass
            Slider: three:
                pass
            PushButton: four:
                style_class = 'yellow'
            PushButton: five:
                style_class = 'yellow bold'
            Slider: six:
                name = 'button'
            Field: seven:
                style_class = 'gray-text'
            Field: eight:
                name = 'button'
            PushButton: nine:
                name = 'button'
                style_class = 'gray-text yellow strong'

    """)


    main = compile_source(source, 'Main')()
    _assert_setters(main.one, (
        ('background', 'blue'),
        ('background', 'red'),
    ))
    _assert_setters(main.two, (
        ('background', 'blue'),
    ))
    _assert_setters(main.three, (
        ('background', 'blue'),
    ))
    _assert_setters(main.four, (
        ('background', 'blue'),
        ('background', 'red'),
        ('background', 'yellow'),
    ))
    _assert_setters(main.five, (
        ('background', 'blue'),
        ('background', 'red'),
        ('background', 'yellow'),
        ('font-weight', 'bold'),
    ))
    _assert_setters(main.six, (
        ('background', 'blue'),
        ('background', 'green'),
    ))
    _assert_setters(main.seven, (
        ('background', 'blue'),
        ('color', 'gray'),
    ))
    _assert_setters(main.eight, (
        ('background', 'blue'),
        ('background', 'green'),
    ))
    _assert_setters(main.nine, (
        ('background', 'blue'),
        ('background', 'red'),
        ('background', 'yellow'),
        ('font-weight', 'bold'),
        ('background', 'green'),
    ))


def test_cascade():
    source = dedent("""\
    from enaml.widgets.api import Window, Container, PushButton
    from enaml.styling import StyleSheet, Style, Setter

    enamldef Sheet1(StyleSheet):
        Style:
            style_class = 'yellow'
            Setter:
                field = 'background'
                value = 'yellow'
        Style:
            element = 'PushButton'
            Setter:
                field = 'background'
                value = 'red'

    enamldef Sheet2(StyleSheet):
        Style:
            style_class = 'cyan'
            Setter:
                field = 'background'
                value = 'cyan'
        Style:
            element = 'PushButton'
            Setter:
                field = 'background'
                value = 'green'

    enamldef Sheet3(StyleSheet):
        Style:
            style_class = 'magenta'
            Setter:
                field = 'background'
                value = 'magenta'
        Style:
            element = 'PushButton'
            Setter:
                field = 'background'
                value = 'blue'

    enamldef Main(Window):
        alias one
        alias two
        alias three
        alias four
        alias five
        alias six
        alias seven
        alias eight
        alias nine
        alias ten
        alias eleven
        Sheet2:
            pass
        Container:
            PushButton: one:
                pass
            PushButton: two:
                style_class = 'yellow'
            PushButton: three:
                style_class = 'cyan'
            PushButton: four:
                Sheet3:
                    pass
            PushButton: five:
                style_class = 'yellow'
                Sheet3:
                    pass
            PushButton: six:
                style_class = 'cyan'
                Sheet3:
                    pass
            PushButton: seven:
                style_class = 'magenta'
                Sheet3:
                    pass
            Container:
                Sheet3:
                    pass
                PushButton: eight:
                    pass
                PushButton: nine:
                    style_class = 'yellow'
                PushButton: ten:
                    style_class = 'cyan'
                PushButton: eleven:
                    style_class = 'magenta'

    def init():
        from enaml.application import Application
        app = Application()
        app.style_sheet = Sheet1()
        return Main()

    """)
    main = compile_source(source, 'init')()
    _assert_setters(main.one, (
        ('background', 'red'),
        ('background', 'green'),
    ))
    _assert_setters(main.two, (
        ('background', 'red'),
        ('background', 'yellow'),
        ('background', 'green'),
    ))
    _assert_setters(main.three, (
        ('background', 'red'),
        ('background', 'green'),
        ('background', 'cyan'),
    ))
    _assert_setters(main.four, (
        ('background', 'red'),
        ('background', 'green'),
        ('background', 'blue'),
    ))
    _assert_setters(main.five, (
        ('background', 'red'),
        ('background', 'yellow'),
        ('background', 'green'),
        ('background', 'blue'),
    ))
    _assert_setters(main.six, (
        ('background', 'red'),
        ('background', 'green'),
        ('background', 'cyan'),
        ('background', 'blue'),
    ))
    _assert_setters(main.seven, (
        ('background', 'red'),
        ('background', 'green'),
        ('background', 'blue'),
        ('background', 'magenta'),
    ))
    _assert_setters(main.eight, (
        ('background', 'red'),
        ('background', 'green'),
        ('background', 'blue'),
    ))
    _assert_setters(main.nine, (
        ('background', 'red'),
        ('background', 'yellow'),
        ('background', 'green'),
        ('background', 'blue'),
    ))
    _assert_setters(main.ten, (
        ('background', 'red'),
        ('background', 'green'),
        ('background', 'cyan'),
        ('background', 'blue'),
    ))
    _assert_setters(main.eleven, (
        ('background', 'red'),
        ('background', 'green'),
        ('background', 'blue'),
        ('background', 'magenta'),
    ))


def _clear_cache():
    from enaml.styling import StyleCache
    StyleCache._item_style_sheets.clear()
    StyleCache._item_styles.clear()
    StyleCache._style_sheet_items.clear()
    StyleCache._style_items.clear()
    StyleCache._queried_items.clear()
    StyleCache._toolkit_setters.clear()


def _cache_items_empty():
    from enaml.styling import StyleCache
    if StyleCache._item_style_sheets:
        return False
    if StyleCache._item_styles:
        return False
    if StyleCache._queried_items:
        return False
    return True


def _cache_styles_empty():
    from enaml.styling import StyleCache
    if StyleCache._style_sheet_items:
        return False
    if StyleCache._style_items:
        return False
    return True


def _cache_tk_empty():
    from enaml.styling import StyleCache
    if StyleCache._toolkit_setters:
        return False
    return True


def test_cache_1():
    from enaml.application import Application
    from enaml.styling import StyleCache
    source = dedent("""\
    from enaml.widgets.api import Window, Container, PushButton
    from enaml.styling import StyleSheet, Style, Setter

    enamldef Sheet(StyleSheet):
        Style:
            element = 'PushButton'
            Setter:
                field = 'background'
                value = 'blue'

    enamldef Main(Window):
        alias button
        Sheet:
            pass
        Container:
            PushButton: button:
                pass

    """)
    _clear_cache()
    app = Application.instance()
    if app is not None:
        app.style_sheet = None
    main = compile_source(source, 'Main')()
    styles = StyleCache.styles(main.button)
    assert len(styles) == 1
    assert not _cache_items_empty()
    assert not _cache_styles_empty()
    main.destroy()
    assert _cache_items_empty()
    assert _cache_styles_empty()


def test_cache_2():
    from enaml.application import Application
    from enaml.styling import StyleCache
    source = dedent("""\
    from enaml.widgets.api import Window, Container, PushButton
    from enaml.styling import StyleSheet, Style, Setter

    enamldef Sheet(StyleSheet):
        Style:
            element = 'PushButton'
            Setter:
                field = 'background'
                value = 'blue'

    enamldef Main(Window):
        alias button
        Container:
            PushButton: button:
                pass

    def init():
        return Main(), Sheet()

    """)
    _clear_cache()
    main, sheet = compile_source(source, 'init')()
    app = Application.instance()
    if app is None:
        app = Application()
    app.style_sheet = sheet
    styles = StyleCache.styles(main.button)
    assert len(styles) == 1
    assert not _cache_items_empty()
    assert not _cache_styles_empty()
    main.destroy()
    assert _cache_items_empty()
    assert not _cache_styles_empty()
    sheet.destroy()
    assert _cache_styles_empty()
    assert app.style_sheet is None

########NEW FILE########
__FILENAME__ = test_template
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from textwrap import dedent

from nose.tools import raises

from utils import compile_source


#------------------------------------------------------------------------------
# Template Syntax
#------------------------------------------------------------------------------
def test_syntax_1():
    source = dedent("""\
    template Main():
        pass

    """)
    compile_source(source, 'Main')


def test_syntax_2():
    source = dedent("""\
    template Main(): pass

    """)
    compile_source(source, 'Main')


def test_syntax_3():
    source = dedent("""\
    template Main():
        const value = 12

    """)
    compile_source(source, 'Main')


def test_syntax_4():
    source = dedent("""\
    template Main(): const value = 12

    """)
    compile_source(source, 'Main')


def test_syntax_5():
    source = dedent("""\
    template Main(A):
        pass

    """)
    compile_source(source, 'Main')


def test_syntax_6():
    source = dedent("""\
    template Main(A, B):
        pass

    """)
    compile_source(source, 'Main')


def test_syntax_7():
    source = dedent("""\
    template Main(A, B, *C):
        pass

    """)
    compile_source(source, 'Main')


def test_syntax_8():
    source = dedent("""\
    template Main(A, B: 12):
        pass

    """)
    compile_source(source, 'Main')


def test_syntax_9():
    source = dedent("""\
    template Main(A, B: 12, *C):
        pass

    """)
    compile_source(source, 'Main')


def test_syntax_10():
    source = dedent("""\
    template Main(A=None):
        pass

    """)
    compile_source(source, 'Main')


def test_syntax_11():
    source = dedent("""\
    template Main(A, B=None):
        pass

    """)
    compile_source(source, 'Main')


def test_syntax_12():
    source = dedent("""\
    template Main(A, B=None, *C):
        pass

    """)
    compile_source(source, 'Main')


def test_syntax_13():
    source = dedent("""\
    template Main(A, B: 12, C=None):
        pass

    """)
    compile_source(source, 'Main')


def test_syntax_14():
    source = dedent("""\
    template Main(A, B: 12, C=None, *D):
        pass

    """)
    compile_source(source, 'Main')


def test_syntax_15():
    source = dedent("""\
    template Main(A, B, C):
        Field:
            pass
        PushButton:
            pass

    """)
    compile_source(source, 'Main')


def test_syntax_16():
    source = dedent("""\
    template Other(*Args):
        Slider:
            pass

    template Main(A, B, C):
        Field:
            pass
        PushButton:
            pass
        Other(A, B, C):
            pass

    """)
    compile_source(source, 'Main')



def test_syntax_17():
    source = dedent("""\
    template Other(*Args):
        Slider:
            pass

    template Main(A, B, C):
        Field:
            pass
        PushButton:
            pass
        Other(A, B, C): a:
            pass

    """)
    compile_source(source, 'Main')


def test_syntax_18():
    source = dedent("""\
    template Other(*Args):
        Slider:
            pass

    template Main(A, B, C):
        Field:
            pass
        PushButton:
            pass
        Other(A, B, C): a, b, c:
            pass

    """)
    compile_source(source, 'Main')


def test_syntax_19():
    source = dedent("""\
    template Other(*Args):
        Slider:
            pass

    template Main(A, B, C):
        Field:
            pass
        PushButton:
            pass
        Other(A, B, C): a, *b:
            pass

    """)
    compile_source(source, 'Main')


def test_syntax_20():
    source = dedent("""\
    template Other(*Args):
        Slider:
            pass

    template Main(A, B, C):
        Field:
            pass
        PushButton:
            pass
        Other(A, B, C): *all:
            pass

    """)
    compile_source(source, 'Main')


#------------------------------------------------------------------------------
# Bad Template Syntax
#------------------------------------------------------------------------------
@raises(SyntaxError)
def test_bad_syntax_1():
    source = dedent("""\
    template Main()
        pass

    """)
    compile_source(source, 'Main')


@raises(SyntaxError)
def test_bad_syntax_2():
    source = dedent("""\
    template Main() pass

    """)
    compile_source(source, 'Main')



@raises(SyntaxError)
def test_bad_syntax_3():
    source = dedent("""\
    template Main:
        pass

    """)
    compile_source(source, 'Main')


@raises(SyntaxError)
def test_bad_syntax_4():
    source = dedent("""\
    template Main: pass

    """)
    compile_source(source, 'Main')


@raises(SyntaxError)
def test_bad_syntax_5():
    source = dedent("""\
    template Main():
        const value

    """)
    compile_source(source, 'Main')


@raises(SyntaxError)
def test_bad_syntax_6():
    source = dedent("""\
    template Main():
        const value 12

    """)
    compile_source(source, 'Main')


@raises(SyntaxError)
def test_bad_syntax_7():
    source = dedent("""\
    template Main():
        attr value

    """)
    compile_source(source, 'Main')


@raises(SyntaxError)
def test_bad_syntax_8():
    source = dedent("""\
    template Main():
        event value

    """)
    compile_source(source, 'Main')


@raises(SyntaxError)
def test_bad_syntax_9():
    source = dedent("""\
    template Main():
        alias value

    """)
    compile_source(source, 'Main')


@raises(SyntaxError)
def test_bad_syntax_10():
    source = dedent("""\
    template Main(A B):
        pass

    """)
    compile_source(source, 'Main')


@raises(SyntaxError)
def test_bad_syntax_11():
    source = dedent("""\
    template Main(A=None, B):
        pass

    """)
    compile_source(source, 'Main')


@raises(SyntaxError)
def test_bad_syntax_12():
    source = dedent("""\
    template Main(A, B=None, C):
        pass

    """)
    compile_source(source, 'Main')


@raises(SyntaxError)
def test_bad_syntax_13():
    source = dedent("""\
    template Main(*C, A)
        pass

    """)
    compile_source(source, 'Main')


@raises(SyntaxError)
def test_bad_syntax_14():
    source = dedent("""\
    template Main(*C, A=None)
        pass

    """)
    compile_source(source, 'Main')


@raises(SyntaxError)
def test_bad_syntax_15():
    source = dedent("""\
    template Main():
        Foo(): a

    """)
    compile_source(source, 'Main')


@raises(SyntaxError)
def test_bad_syntax_16():
    source = dedent("""\
    template Main():
        Foo(): a, b

    """)
    compile_source(source, 'Main')


@raises(SyntaxError)
def test_bad_syntax_17():
    source = dedent("""\
    template Main():
        Foo(): a, *c

    """)
    compile_source(source, 'Main')


@raises(SyntaxError)
def test_bad_syntax_18():
    source = dedent("""\
    template Main():
        Field: a: pass
        Foo(): a: pass

    """)
    compile_source(source, 'Main')


@raises(SyntaxError)
def test_bad_syntax_19():
    source = dedent("""\
    template Main(Arg):
        const Arg = 12

    """)
    compile_source(source, 'Main')


@raises(SyntaxError)
def test_bad_syntax_20():
    source = dedent("""\
    template Main(Arg):
        const Args = 12
        Field: Args: pass

    """)
    compile_source(source, 'Main')


#------------------------------------------------------------------------------
# Template Instantiation
#------------------------------------------------------------------------------
def test_instantiation_1():
    source = dedent("""\
    from enaml.widgets.api import *

    template Main():
        Field: pass

    """)
    from enaml.widgets.api import Field
    main = compile_source(source, 'Main')
    items = main()()
    assert len(items) == 1
    assert all(isinstance(item, Field) for item in items)


def test_instantiation_2():
    source = dedent("""\
    from enaml.widgets.api import *

    template Main():
        Field: pass
        Field: pass
        Field: pass

    """)
    from enaml.widgets.api import Field
    main = compile_source(source, 'Main')
    items = main()()
    assert len(items) == 3
    assert all(isinstance(item, Field) for item in items)


def test_instantiation_3():
    source = dedent("""\
    from enaml.widgets.api import *

    template Main(Text):
        Field: text = Text

    """)
    main = compile_source(source, 'Main')
    field = main('foo')()[0]
    assert field.text == 'foo'


def test_instantiation_4():
    source = dedent("""\
    template Main(Content):
        Content: pass

    """)
    from enaml.widgets.api import Field
    main = compile_source(source, 'Main')
    item = main(Field)()[0]
    assert isinstance(item, Field)


def test_instantiation_5():
    source = dedent("""\
    template Main(Content):
        Content:
            text = 'foo'

    """)
    from enaml.widgets.api import Field
    main = compile_source(source, 'Main')
    item = main(Field)()[0]
    assert item.text == 'foo'


def test_instantiation_6():
    source = dedent("""\
    template ForEach(N, Item):
        ForEach(N - 1, Item):
            pass
        Item:
            pass

    template ForEach(N: 0, Item):
        pass

    template Main(N, Item):
        ForEach(N, Item):
            pass

    """)
    from enaml.widgets.api import Field
    main = compile_source(source, 'Main')
    items = main(10, Field)()
    assert len(items) == 10
    assert all(isinstance(item, Field) for item in items)


def test_instantiation_7():
    source = dedent("""\
    from enaml.widgets.api import *

    template Main(Content):
        Container:
            alias content
            Content: content:
                pass

    """)
    from enaml.widgets.api import Field
    main = compile_source(source, 'Main')
    item = main(Field)()[0]
    assert isinstance(item.content, Field)


def test_instantiation_8():
    source = dedent("""\
    from enaml.widgets.api import *

    template Main():
        Container:
            alias text: field.text
            Field: field:
                name = 'field'
                text = 'bar'

    """)
    main = compile_source(source, 'Main')
    item = main()()[0]
    field = item.find('field')
    assert field.text == 'bar'
    item.text = 'foo'
    assert field.text == 'foo'


def test_instantiation_9():
    source = dedent("""\
    from enaml.widgets.api import *

    template Main(Content):
        Label: pass

    template Main(Content: 12):
        Field: pass

    """)
    from enaml.widgets.api import Field, Label
    main = compile_source(source, 'Main')
    item = main(None)()[0]
    assert isinstance(item, Label)
    item = main(12)()[0]
    assert isinstance(item, Field)


def test_instantiation_10():
    source = dedent("""\
    from enaml.widgets.api import *

    template Spam():
        Field: pass
        Label: pass
        Field: pass

    enamldef Main(Window):
        alias a
        alias b
        alias c
        attr rest = rest
        Spam(): a, b, c:
            pass
        Spam(): *rest:
            pass

    """)
    from enaml.widgets.api import Field, Label
    main = compile_source(source, 'Main')()
    assert isinstance(main.a, Field)
    assert isinstance(main.b, Label)
    assert isinstance(main.c, Field)
    types = (Field, Label, Field)
    rtypes = tuple(type(r) for r in main.rest)
    assert rtypes == types


def test_instantiation_11():
    source = dedent("""\
    from enaml.widgets.api import *

    template Spam(Item=Field):
        Item: pass

    enamldef Main(Window):
        Spam():
            pass
        Spam(Label):
            pass

    """)
    from enaml.widgets.api import Field, Label
    main = compile_source(source, 'Main')()
    types = (Field, Label)
    rtypes = tuple(type(child) for child in main.children)
    assert rtypes == types


def test_instantiation_12():
    source = dedent("""\
    template Unroll(Item, *Items):
        Item: pass
        Unroll(*Items): pass

    template Unroll():
        pass

    """)
    from enaml.widgets.api import Field
    Unroll = compile_source(source, 'Unroll')
    items = Unroll(Field, Field, Field, Field, Field)()
    assert len(items) == 5


def test_instantiation_13():
    source = dedent("""\
    from enaml.widgets.api import *

    template Unroll(First, Second=Label, *Rest):
        First: pass
        Second: pass
        Unroll(*Rest): pass

    template Unroll():
        pass

    """)
    from enaml.widgets.api import Field, Label
    Unroll = compile_source(source, 'Unroll')
    items = Unroll(Field, Field, Field, Field, Field)()
    assert len(items) == 6
    assert isinstance(items[-1], Label)


def test_instantiation_14():
    source = dedent("""\
    from enaml.widgets.api import *

    template Other(Content):
        Content:
            pass

    template Invoke(Item, Arg):
        Item(Arg):
            pass

    template Main(Which):
        Invoke(Other, Which):
            pass

    """)
    from enaml.widgets.api import Field
    Main = compile_source(source, 'Main')
    item = Main(Field)()[0]
    assert isinstance(item, Field)


def test_instantiation_15():
    source = dedent("""\
    from enaml.widgets.api import *

    template Main():
        Field: pass
        Field: pass
        Field: pass

    """)
    from enaml.core.api import Declarative
    Main = compile_source(source, 'Main')
    parent = Declarative()
    Main()(parent)
    assert len(parent.children) == 3


def test_instantiation_16():
    source = dedent("""\
    template Main():
        const Value = 15

    """)
    Main = compile_source(source, 'Main')
    assert Main().Value == 15


def test_instantiation_17():
    source = dedent("""\
    template Main():
        const Value = 15

    """)
    Main = compile_source(source, 'Main')
    assert Main() is Main()


# regression: https://github.com/nucleic/enaml/issues/78
def test_instantiation_18():
    source = dedent("""\
    from enaml.widgets.api import *

    template Foo():
        Field:
            placeholder = 'foo'

    enamldef Main(Window):
        Container:
            Foo(): f:
                f.text = f.placeholder
    """)
    main = compile_source(source, 'Main')()
    field = main.children[0].children[0]
    assert field.text == u'foo'


#------------------------------------------------------------------------------
# Bad Template Instantiation
#------------------------------------------------------------------------------
@raises(NameError)
def test_bad_instantiation_1():
    source = dedent("""\
    from enaml.widgets.api import *

    template Other():
        Boo: pass

    enamldef Main(Window):
        Other(): pass

    """)
    compile_source(source, 'Main')


@raises(TypeError)
def test_bad_instantiation_2():
    source = dedent("""\
    from enaml.widgets.api import *

    template Other(A, B, C):
        Field: pass

    enamldef Main(Window):
        Other(): pass

    """)
    compile_source(source, 'Main')


@raises(TypeError)
def test_bad_instantiation_3():
    source = dedent("""\
    template Other(*A):
        pass

    template Other():
        pass

    """)
    compile_source(source, 'Main')


@raises(TypeError)
def test_bad_instantiation_4():
    source = dedent("""\
    template Other(A):
        pass

    template Other(A):
        pass

    """)
    compile_source(source, 'Main')


@raises(TypeError)
def test_bad_instantiation_5():
    source = dedent("""\
    from enaml.widgets.api import *

    template Other(A, B: 12):
        pass

    template Other(A: 0, B):
        pass

    enamldef Main(Window):
        Other(0, 12):
            pass

    """)
    compile_source(source, 'Main')


@raises(ValueError)
def test_bad_instantiation_6():
    source = dedent("""\
    from enaml.widgets.api import *

    template Foo():
        Field: pass
        Field: pass
        Field: pass

    enamldef Main(Window):
        Foo(): a:
            pass

    """)
    compile_source(source, 'Main')


@raises(ValueError)
def test_bad_instantiation_7():
    source = dedent("""\
    from enaml.widgets.api import *

    template Foo():
        Field: pass
        Field: pass
        Field: pass

    enamldef Main(Window):
        Foo(): a, b:
            pass

    """)
    compile_source(source, 'Main')


@raises(ValueError)
def test_bad_instantiation_8():
    source = dedent("""\
    from enaml.widgets.api import *

    template Foo():
        Field: pass
        Field: pass
        Field: pass

    enamldef Main(Window):
        Foo(): a, b, c, d:
            pass

    """)
    compile_source(source, 'Main')

########NEW FILE########
__FILENAME__ = utils
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from enaml.core.enaml_compiler import EnamlCompiler
from enaml.core.parser import parse


def compile_source(source, item, filename='<test>'):
    """ Compile Enaml source code and return the target item.

    Parameters
    ----------
    source : str
        The Enaml source code string to compile.

    item : str
        The name of the item in the resulting namespace to return.

    filename : str, optional
        The filename to use when compiling the code. The default
        is '<test>'.

    Returns
    -------
    result : object
        The named object from the resulting namespace.

    """
    ast = parse(source, filename)
    code = EnamlCompiler.compile(ast, filename)
    namespace = {}
    exec code in namespace
    return namespace[item]

########NEW FILE########
__FILENAME__ = lexer
#------------------------------------------------------------------------------
# Copyright (c) 2013, Nucleic Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
#------------------------------------------------------------------------------
from pygments.lexer import RegexLexer, bygroups
from pygments.lexers.agile import PythonLexer

from pygments.token import Text, Keyword, Name, Punctuation, Operator


ENAMLDEF_START = (
    r'^(enamldef)([ \t]+)([a-zA-Z_][a-zA-Z0-9_]*)([ \t]*)(\()',
    bygroups(Keyword, Text, Name.Class, Text, Punctuation),
    'enamldef_base',
)


ENAMLDEF_BASE = (
    r'(\s*)([a-zA-Z_][a-zA-Z0-9_]*)(\s*)',
    bygroups(Text, Text, Text),
    'enamldef_end',
)


ENAMLDEF_END = (
    r'(\))([ \t]*)(:)([ \t]*\n)',
    bygroups(Punctuation, Text, Punctuation, Text),
    '#pop:2',
)


ENAMLDEF_END_ID = (
    r'(\))([ \t]*)(:)([ \t]*)([a-zA-Z_][a-zA-Z0-9_]*)([ \t]*)(:)([ \t]*\n)',
    bygroups(Punctuation, Text, Punctuation, Text, Name.Entity, Text,
        Punctuation, Text),
    '#pop:2',
)


TEMPLATE_START = (
    r'^(template)([ \t]+)([a-zA-Z_][a-zA-Z0-9_]*)([ \t]*)(\()',
    bygroups(Keyword, Text, Name.Function, Text, Punctuation),
    'template_end',
)


TEMPLATE_END = (
    r'(.*?)(\))([ \t]*)(:)([ \t]*\n)',
    bygroups(Text, Punctuation, Text, Punctuation, Text),
    '#pop',
)


TEMPLATEINST_START = (
    r'^([ \t]+)([a-zA-Z_][a-zA-Z0-9_]*)([ \t]*)(\()',
    bygroups(Text, Name.Tag, Text, Punctuation),
    'templateinst_end',
)


TEMPLATEINST_END = (
    r'(.*?)(\))([ \t]*)(:)([ \t]*\n)',
    bygroups(Text, Punctuation, Text, Punctuation, Text),
    '#pop',
)


TEMPLATEINST_END_ID = (
    r'(.*?)(\))([ \t]*)(:)([ \t]*)(?=\*?[a-zA-Z_])',
    bygroups(Text, Punctuation, Text, Punctuation, Text),
    'templateinst_id',
)


TEMPLATEINST_ID_1 = (
    r'(\*)([a-zA-Z_][a-zA-Z0-9_]*)',
    bygroups(Punctuation, Name.Entity),
)


TEMPLATEINST_ID_2 = (
    r'[a-zA-Z_][a-zA-Z0-9_]*', Name.Entity
)


TEMPLATEINST_ID_3 = (
    r',', Punctuation
)


TEMPLATEINST_ID_4 = (
    r'\s*', Text
)


TEMPLATEINST_ID_END = (
    r'(:)([ \t]*\n)',
    bygroups(Punctuation, Text),
    '#pop:2',
)


CHILDDEF_START = (
    r'^([ \t]+)([a-zA-Z_][a-zA-Z0-9_]*)([ \t]*)(:)(?=[ \t]*[a-zA-Z_\n])',
    bygroups(Text, Name.Tag, Text, Punctuation),
    'childdef_end',
)


CHILDDEF_END = (
    r'[ \t]*\n', Text, '#pop',
)


CHILDDEF_END_ID = (
    r'([ \t]*)([a-zA-Z_][a-zA-Z0-9_]*)([ \t]*)(:)([ \t]*\n)',
    bygroups(Text, Name.Entity, Text, Punctuation, Text),
    '#pop',
)


ENAML_TOKENS = PythonLexer.tokens.copy()
ENAML_TOKENS['root'] = [
    ENAMLDEF_START,
    TEMPLATE_START,
    TEMPLATEINST_START,
    CHILDDEF_START,
    (r'(alias|attr|const|event)\b', Keyword),
    (r':=', Operator),
] + ENAML_TOKENS['root']


ENAML_TOKENS['enamldef_base'] = [
    ENAMLDEF_BASE,
]


ENAML_TOKENS['enamldef_end'] = [
    ENAMLDEF_END_ID,
    ENAMLDEF_END,
]


ENAML_TOKENS['template_end'] = [
    TEMPLATE_END,
]


ENAML_TOKENS['templateinst_end'] = [
    TEMPLATEINST_END_ID,
    TEMPLATEINST_END,
]


ENAML_TOKENS['templateinst_id'] = [
    TEMPLATEINST_ID_END,
    TEMPLATEINST_ID_1,
    TEMPLATEINST_ID_2,
    TEMPLATEINST_ID_3,
    TEMPLATEINST_ID_4,
]


ENAML_TOKENS['childdef_end'] = [
    CHILDDEF_END_ID,
    CHILDDEF_END,
]


class EnamlLexer(RegexLexer):
    """ For `Enaml <http://www.github.com/nucleic/enaml>`_ source code.

    """
    name = 'Enaml'
    aliases = ['enaml']
    filenames = ['*.enaml']
    mimetypes = ['text/x-enaml', 'application/x-enaml']
    tokens = ENAML_TOKENS

########NEW FILE########
