__FILENAME__ = constants
#
# Autogenerated by Thrift Compiler (0.5.0-en-262021)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *


########NEW FILE########
__FILENAME__ = ttypes
#
# Autogenerated by Thrift Compiler (0.5.0-en-262021)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class EDAMErrorCode(object):
  """
  Numeric codes indicating the type of error that occurred on the
  service.
  <dl>
    <dt>UNKNOWN</dt
      <dd>No information available about the error</dd>
    <dt>BAD_DATA_FORMAT</dt>
      <dd>The format of the request data was incorrect</dd>
    <dt>PERMISSION_DENIED</dt>
      <dd>Not permitted to perform action</dd>
    <dt>INTERNAL_ERROR</dt>
      <dd>Unexpected problem with the service</dd>
    <dt>DATA_REQUIRED</dt>
      <dd>A required parameter/field was absent</dd>
    <dt>LIMIT_REACHED</dt>
      <dd>Operation denied due to data model limit</dd>
    <dt>QUOTA_REACHED</dt>
      <dd>Operation denied due to user storage limit</dd>
    <dt>INVALID_AUTH</dt>
      <dd>Username and/or password incorrect</dd>
    <dt>AUTH_EXPIRED</dt>
      <dd>Authentication token expired</dd>
    <dt>DATA_CONFLICT</dt>
      <dd>Change denied due to data model conflict</dd>
    <dt>ENML_VALIDATION</dt>
      <dd>Content of submitted note was malformed</dd>
    <dt>SHARD_UNAVAILABLE</dt>
      <dd>Service shard with account data is temporarily down</dd>
    <dt>LEN_TOO_SHORT</dt>
      <dd>Operation denied due to data model limit, where something such
          as a string length was too short</dd>
    <dt>LEN_TOO_LONG</dt>
      <dd>Operation denied due to data model limit, where something such
          as a string length was too long</dd>
    <dt>TOO_FEW</dt>
      <dd>Operation denied due to data model limit, where there were
          too few of something.</dd>
    <dt>TOO_MANY</dt>
      <dd>Operation denied due to data model limit, where there were
          too many of something.</dd>
    <dt>UNSUPPORTED_OPERATION</dt>
      <dd>Operation denied because it is currently unsupported.</dd>
  </dl>
  """
  UNKNOWN = 1
  BAD_DATA_FORMAT = 2
  PERMISSION_DENIED = 3
  INTERNAL_ERROR = 4
  DATA_REQUIRED = 5
  LIMIT_REACHED = 6
  QUOTA_REACHED = 7
  INVALID_AUTH = 8
  AUTH_EXPIRED = 9
  DATA_CONFLICT = 10
  ENML_VALIDATION = 11
  SHARD_UNAVAILABLE = 12
  LEN_TOO_SHORT = 13
  LEN_TOO_LONG = 14
  TOO_FEW = 15
  TOO_MANY = 16
  UNSUPPORTED_OPERATION = 17

  _VALUES_TO_NAMES = {
    1: "UNKNOWN",
    2: "BAD_DATA_FORMAT",
    3: "PERMISSION_DENIED",
    4: "INTERNAL_ERROR",
    5: "DATA_REQUIRED",
    6: "LIMIT_REACHED",
    7: "QUOTA_REACHED",
    8: "INVALID_AUTH",
    9: "AUTH_EXPIRED",
    10: "DATA_CONFLICT",
    11: "ENML_VALIDATION",
    12: "SHARD_UNAVAILABLE",
    13: "LEN_TOO_SHORT",
    14: "LEN_TOO_LONG",
    15: "TOO_FEW",
    16: "TOO_MANY",
    17: "UNSUPPORTED_OPERATION",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 1,
    "BAD_DATA_FORMAT": 2,
    "PERMISSION_DENIED": 3,
    "INTERNAL_ERROR": 4,
    "DATA_REQUIRED": 5,
    "LIMIT_REACHED": 6,
    "QUOTA_REACHED": 7,
    "INVALID_AUTH": 8,
    "AUTH_EXPIRED": 9,
    "DATA_CONFLICT": 10,
    "ENML_VALIDATION": 11,
    "SHARD_UNAVAILABLE": 12,
    "LEN_TOO_SHORT": 13,
    "LEN_TOO_LONG": 14,
    "TOO_FEW": 15,
    "TOO_MANY": 16,
    "UNSUPPORTED_OPERATION": 17,
  }


class EDAMUserException(TException):
  """
  This exception is thrown by EDAM procedures when a call fails as a result of
  a problem that a user may be able to resolve.  For example, if the user
  attempts to add a note to their account which would exceed their storage
  quota, this type of exception may be thrown to indicate the source of the
  error so that they can choose an alternate action.
  
  This exception would not be used for internal system errors that do not
  reflect user actions, but rather reflect a problem within the service that
  the user cannot resolve.
  
  errorCode:  The numeric code indicating the type of error that occurred.
    must be one of the values of EDAMErrorCode.
  
  parameter:  If the error applied to a particular input parameter, this will
    indicate which parameter.
  
  Attributes:
   - errorCode
   - parameter
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'errorCode', None, None, ), # 1
    (2, TType.STRING, 'parameter', None, None, ), # 2
  )

  def __init__(self, errorCode=None, parameter=None,):
    self.errorCode = errorCode
    self.parameter = parameter

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.errorCode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.parameter = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EDAMUserException')
    if self.errorCode is not None:
      oprot.writeFieldBegin('errorCode', TType.I32, 1)
      oprot.writeI32(self.errorCode)
      oprot.writeFieldEnd()
    if self.parameter is not None:
      oprot.writeFieldBegin('parameter', TType.STRING, 2)
      oprot.writeString(self.parameter)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.errorCode is None:
      raise TProtocol.TProtocolException(message='Required field errorCode is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EDAMSystemException(TException):
  """
  This exception is thrown by EDAM procedures when a call fails as a result of
  an a problem in the service that could not be changed through user action.
  
  errorCode:  The numeric code indicating the type of error that occurred.
    must be one of the values of EDAMErrorCode.
  
  message:  This may contain additional information about the error
  
  Attributes:
   - errorCode
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'errorCode', None, None, ), # 1
    (2, TType.STRING, 'message', None, None, ), # 2
  )

  def __init__(self, errorCode=None, message=None,):
    self.errorCode = errorCode
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.errorCode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EDAMSystemException')
    if self.errorCode is not None:
      oprot.writeFieldBegin('errorCode', TType.I32, 1)
      oprot.writeI32(self.errorCode)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 2)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.errorCode is None:
      raise TProtocol.TProtocolException(message='Required field errorCode is unset!')
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class EDAMNotFoundException(TException):
  """
  This exception is thrown by EDAM procedures when a caller asks to perform
  an operation that does not exist.  This may be thrown based on an invalid
  primary identifier (e.g. a bad GUID), or when the caller refers to an object
  by another unique identifier (e.g. a User's email address).
  
  identifier:  the object identifier that was not found on the server.
  
  key:  the value passed from the client in the identifier, which was not
    found.  E.g. the GUID of an object that was not found.
  
  Attributes:
   - identifier
   - key
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'identifier', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
  )

  def __init__(self, identifier=None, key=None,):
    self.identifier = identifier
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.identifier = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('EDAMNotFoundException')
    if self.identifier is not None:
      oprot.writeFieldBegin('identifier', TType.STRING, 1)
      oprot.writeString(self.identifier)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

########NEW FILE########
__FILENAME__ = constants
#
# Autogenerated by Thrift Compiler (0.5.0-en-262021)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *

EDAM_ATTRIBUTE_LEN_MIN = 1
EDAM_ATTRIBUTE_LEN_MAX = 4096
EDAM_ATTRIBUTE_REGEX = "^[^\\p{Cc}\\p{Zl}\\p{Zp}]{1,4096}$"
EDAM_ATTRIBUTE_LIST_MAX = 100
EDAM_ATTRIBUTE_MAP_MAX = 100
EDAM_GUID_LEN_MIN = 36
EDAM_GUID_LEN_MAX = 36
EDAM_GUID_REGEX = "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$"
EDAM_EMAIL_LEN_MIN = 6
EDAM_EMAIL_LEN_MAX = 255
EDAM_EMAIL_LOCAL_REGEX = "^[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+(\\.[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+)*$"
EDAM_EMAIL_DOMAIN_REGEX = "^[A-Za-z0-9-]+(\\.[A-Za-z0-9-]+)*\\.([A-Za-z]{2,})$"
EDAM_EMAIL_REGEX = "^[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+(\\.[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+)*@[A-Za-z0-9-]+(\\.[A-Za-z0-9-]+)*\\.([A-Za-z]{2,})$"
EDAM_TIMEZONE_LEN_MIN = 1
EDAM_TIMEZONE_LEN_MAX = 32
EDAM_TIMEZONE_REGEX = "^([A-Za-z_-]+(/[A-Za-z_-]+)*)|(GMT(-|\\+)[0-9]{1,2}(:[0-9]{2})?)$"
EDAM_MIME_LEN_MIN = 3
EDAM_MIME_LEN_MAX = 255
EDAM_MIME_REGEX = "^[A-Za-z]+/[A-Za-z0-9._+-]+$"
EDAM_MIME_TYPE_GIF = "image/gif"
EDAM_MIME_TYPE_JPEG = "image/jpeg"
EDAM_MIME_TYPE_PNG = "image/png"
EDAM_MIME_TYPE_WAV = "audio/wav"
EDAM_MIME_TYPE_MP3 = "audio/mpeg"
EDAM_MIME_TYPE_AMR = "audio/amr"
EDAM_MIME_TYPE_MP4_VIDEO = "video/mp4"
EDAM_MIME_TYPE_INK = "application/vnd.evernote.ink"
EDAM_MIME_TYPE_PDF = "application/pdf"
EDAM_MIME_TYPE_DEFAULT = "application/octet-stream"
EDAM_MIME_TYPES = set([
  "image/gif",
  "image/jpeg",
  "image/png",
  "audio/wav",
  "audio/mpeg",
  "audio/amr",
  "application/vnd.evernote.ink",
  "application/pdf",
  "video/mp4",
])
EDAM_COMMERCE_SERVICE_GOOGLE = "Google"
EDAM_COMMERCE_SERVICE_PAYPAL = "Paypal"
EDAM_COMMERCE_SERVICE_GIFT = "Gift"
EDAM_COMMERCE_SERVICE_TRIALPAY = "TrialPay"
EDAM_COMMERCE_SERVICE_TRIAL = "Trial"
EDAM_COMMERCE_SERVICE_GROUP = "Group"
EDAM_COMMERCE_SERVICE_CYBERSOURCE = "CYBERSRC"
EDAM_COMMERCE_DEFAULT_CURRENCY_COUNTRY_CODE = "USD"
EDAM_SEARCH_QUERY_LEN_MIN = 0
EDAM_SEARCH_QUERY_LEN_MAX = 1024
EDAM_SEARCH_QUERY_REGEX = "^[^\\p{Cc}\\p{Zl}\\p{Zp}]{0,1024}$"
EDAM_HASH_LEN = 16
EDAM_USER_USERNAME_LEN_MIN = 1
EDAM_USER_USERNAME_LEN_MAX = 64
EDAM_USER_USERNAME_REGEX = "^[a-z0-9]([a-z0-9_-]{0,62}[a-z0-9])?$"
EDAM_USER_NAME_LEN_MIN = 1
EDAM_USER_NAME_LEN_MAX = 255
EDAM_USER_NAME_REGEX = "^[^\\p{Cc}\\p{Zl}\\p{Zp}]{1,255}$"
EDAM_TAG_NAME_LEN_MIN = 1
EDAM_TAG_NAME_LEN_MAX = 100
EDAM_TAG_NAME_REGEX = "^[^,\\p{Cc}\\p{Z}]([^,\\p{Cc}\\p{Zl}\\p{Zp}]{0,98}[^,\\p{Cc}\\p{Z}])?$"
EDAM_NOTE_TITLE_LEN_MIN = 1
EDAM_NOTE_TITLE_LEN_MAX = 255
EDAM_NOTE_TITLE_REGEX = "^[^\\p{Cc}\\p{Z}]([^\\p{Cc}\\p{Zl}\\p{Zp}]{0,253}[^\\p{Cc}\\p{Z}])?$"
EDAM_NOTE_CONTENT_LEN_MIN = 0
EDAM_NOTE_CONTENT_LEN_MAX = 5242880
EDAM_APPLICATIONDATA_NAME_LEN_MIN = 3
EDAM_APPLICATIONDATA_NAME_LEN_MAX = 32
EDAM_APPLICATIONDATA_VALUE_LEN_MIN = 0
EDAM_APPLICATIONDATA_VALUE_LEN_MAX = 4092
EDAM_APPLICATIONDATA_ENTRY_LEN_MAX = 4095
EDAM_APPLICATIONDATA_NAME_REGEX = "^[A-Za-z0-9_.-]{3,32}$"
EDAM_APPLICATIONDATA_VALUE_REGEX = "^[^\\p{Cc}]{0,4092}$"
EDAM_NOTEBOOK_NAME_LEN_MIN = 1
EDAM_NOTEBOOK_NAME_LEN_MAX = 100
EDAM_NOTEBOOK_NAME_REGEX = "^[^\\p{Cc}\\p{Z}]([^\\p{Cc}\\p{Zl}\\p{Zp}]{0,98}[^\\p{Cc}\\p{Z}])?$"
EDAM_NOTEBOOK_STACK_LEN_MIN = 1
EDAM_NOTEBOOK_STACK_LEN_MAX = 100
EDAM_NOTEBOOK_STACK_REGEX = "^[^\\p{Cc}\\p{Z}]([^\\p{Cc}\\p{Zl}\\p{Zp}]{0,98}[^\\p{Cc}\\p{Z}])?$"
EDAM_PUBLISHING_URI_LEN_MIN = 1
EDAM_PUBLISHING_URI_LEN_MAX = 255
EDAM_PUBLISHING_URI_REGEX = "^[a-zA-Z0-9.~_+-]{1,255}$"
EDAM_PUBLISHING_URI_PROHIBITED = set([
  "..",
])
EDAM_PUBLISHING_DESCRIPTION_LEN_MIN = 1
EDAM_PUBLISHING_DESCRIPTION_LEN_MAX = 200
EDAM_PUBLISHING_DESCRIPTION_REGEX = "^[^\\p{Cc}\\p{Z}]([^\\p{Cc}\\p{Zl}\\p{Zp}]{0,198}[^\\p{Cc}\\p{Z}])?$"
EDAM_SAVED_SEARCH_NAME_LEN_MIN = 1
EDAM_SAVED_SEARCH_NAME_LEN_MAX = 100
EDAM_SAVED_SEARCH_NAME_REGEX = "^[^\\p{Cc}\\p{Z}]([^\\p{Cc}\\p{Zl}\\p{Zp}]{0,98}[^\\p{Cc}\\p{Z}])?$"
EDAM_USER_PASSWORD_LEN_MIN = 6
EDAM_USER_PASSWORD_LEN_MAX = 64
EDAM_USER_PASSWORD_REGEX = "^[A-Za-z0-9!#$%&'()*+,./:;<=>?@^_`{|}~\\[\\]\\\\-]{6,64}$"
EDAM_NOTE_TAGS_MAX = 100
EDAM_NOTE_RESOURCES_MAX = 1000
EDAM_USER_TAGS_MAX = 100000
EDAM_USER_SAVED_SEARCHES_MAX = 100
EDAM_USER_NOTES_MAX = 100000
EDAM_USER_NOTEBOOKS_MAX = 250
EDAM_USER_RECENT_MAILED_ADDRESSES_MAX = 10
EDAM_USER_MAIL_LIMIT_DAILY_FREE = 50
EDAM_USER_MAIL_LIMIT_DAILY_PREMIUM = 200
EDAM_USER_UPLOAD_LIMIT_FREE = 62914560
EDAM_USER_UPLOAD_LIMIT_PREMIUM = 1073741824
EDAM_NOTE_SIZE_MAX_FREE = 26214400
EDAM_NOTE_SIZE_MAX_PREMIUM = 52428800
EDAM_RESOURCE_SIZE_MAX_FREE = 26214400
EDAM_RESOURCE_SIZE_MAX_PREMIUM = 52428800
EDAM_USER_LINKED_NOTEBOOK_MAX = 100
EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX = 250
EDAM_NOTE_CONTENT_CLASS_LEN_MIN = 3
EDAM_NOTE_CONTENT_CLASS_LEN_MAX = 32
EDAM_HELLO_APP_CONTENT_CLASS_PREFIX = "evernote.hello."
EDAM_FOOD_APP_CONTENT_CLASS_PREFIX = "evernote.food."
EDAM_NOTE_CONTENT_CLASS_REGEX = "^[A-Za-z0-9_.-]{3,32}$"
EDAM_CONTENT_CLASS_HELLO_ENCOUNTER = "evernote.hello.encounter"
EDAM_CONTENT_CLASS_HELLO_PROFILE = "evernote.hello.profile"
EDAM_CONTENT_CLASS_FOOD_MEAL = "evernote.food.meal"

########NEW FILE########
__FILENAME__ = ttypes
#
# Autogenerated by Thrift Compiler (0.5.0-en-262021)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None



########NEW FILE########
__FILENAME__ = constants
#
# Autogenerated by Thrift Compiler (0.5.0-en-262021)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *


########NEW FILE########
__FILENAME__ = NoteStore
#
# Autogenerated by Thrift Compiler (0.5.0-en-262021)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(object):
  """
  Service:  NoteStore
  <p>
  The NoteStore service is used by EDAM clients to exchange information
  about the collection of notes in an account.  This is primarily used for
  synchronization, but could also be used by a "thin" client without a full
  local cache.
  </p><p>
  All functions take an "authenticationToken" parameter, which is the
  value returned by the UserStore which permits access to the account.
  This parameter is mandatory for all functions.
  </p>
  
  Calls which require an authenticationToken may throw an EDAMUserException
  for the following reasons:
   <ul>
    <li> AUTH_EXPIRED "authenticationToken" - token has expired
    </li>
    <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
    </li>
    <li> DATA_REQUIRED "authenticationToken" - token is empty
    </li>
    <li> INVALID_AUTH "authenticationToken" - token signature is invalid
    </li>
  </ul>
  """
  def getSyncState(self, authenticationToken):
    """
    Asks the NoteStore to provide information about the status of the user
    account corresponding to the provided authentication token.
    
    Parameters:
     - authenticationToken
    """
    pass

  def getSyncStateWithMetrics(self, authenticationToken, clientMetrics):
    """
    Asks the NoteStore to provide information about the status of the user
    account corresponding to the provided authentication token.
    This version of 'getSyncState' allows the client to upload coarse-
    grained usage metrics to the service.
    
    @param clientMetrics  see the documentation of the ClientUsageMetrics
      structure for an explanation of the fields that clients can pass to
      the service.
    
    Parameters:
     - authenticationToken
     - clientMetrics
    """
    pass

  def getSyncChunk(self, authenticationToken, afterUSN, maxEntries, fullSyncOnly):
    """
    Asks the NoteStore to provide the state of the account in order of
    last modification.  This request retrieves one block of the server's
    state so that a client can make several small requests against a large
    account rather than getting the entire state in one big message.
    
    @param afterUSN
      The client can pass this value to ask only for objects that
      have been updated after a certain point.  This allows the client to
      receive updates after its last checkpoint rather than doing a full
      synchronization on every pass.  The default value of "0" indicates
      that the client wants to get objects from the start of the account.
    
    @param maxEntries
      The maximum number of modified objects that should be
      returned in the result SyncChunk. This can be used to limit the size
      of each individual message to be friendly for network transfer.
      Applications should not request more than 256 objects at a time,
      and must handle the case where the service returns less than the
      requested number of objects in a given request even though more
      objects are available on the service.
    
    @param fullSyncOnly
      If true, then the client only wants initial data for a full sync.
      In this case, the service will not return any expunged objects,
      and will not return any Resources, since these are also provided
      in their corresponding Notes.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "afterUSN" - if negative
      </li>
      <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - afterUSN
     - maxEntries
     - fullSyncOnly
    """
    pass

  def getFilteredSyncChunk(self, authenticationToken, afterUSN, maxEntries, filter):
    """
    Asks the NoteStore to provide the state of the account in order of
    last modification.  This request retrieves one block of the server's
    state so that a client can make several small requests against a large
    account rather than getting the entire state in one big message.
    This call gives more fine-grained control of the data that will
    be received by a client by omitting data elements that a client doesn't
    need. This may reduce network traffic and sync times.
    
    @param afterUSN
      The client can pass this value to ask only for objects that
      have been updated after a certain point.  This allows the client to
      receive updates after its last checkpoint rather than doing a full
      synchronization on every pass.  The default value of "0" indicates
      that the client wants to get objects from the start of the account.
    
    @param maxEntries
      The maximum number of modified objects that should be
      returned in the result SyncChunk.  This can be used to limit the size
      of each individual message to be friendly for network transfer.
    
    @param filter
      The caller must set some of the flags in this structure to specify which
      data types should be returned during the synchronization.  See
      the SyncChunkFilter structure for information on each flag.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "afterUSN" - if negative
      </li>
      <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - afterUSN
     - maxEntries
     - filter
    """
    pass

  def getLinkedNotebookSyncState(self, authenticationToken, linkedNotebook):
    """
    Asks the NoteStore to provide information about the status of a linked
    notebook that has been shared with the caller, or that is public to the
    world.
    This will return a result that is similar to getSyncState, but may omit
    SyncState.uploaded if the caller doesn't have permission to write to
    the linked notebook.
    
    This function must be called on the shard that owns the referenced
    notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
    same as LinkedNotebook.shardId.)
    
    @param authenticationToken
      This should be an authenticationToken for the guest who has received
      the invitation to the share.  (I.e. this should not be the result of
      NoteStore.authenticateToSharedNotebook)
    
    @param linkedNotebook
      This structure should contain identifying information and permissions
      to access the notebook in question.
    
    Parameters:
     - authenticationToken
     - linkedNotebook
    """
    pass

  def getLinkedNotebookSyncChunk(self, authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly):
    """
    Asks the NoteStore to provide information about the contents of a linked
    notebook that has been shared with the caller, or that is public to the
    world.
    This will return a result that is similar to getSyncChunk, but will only
    contain entries that are visible to the caller.  I.e. only that particular
    Notebook will be visible, along with its Notes, and Tags on those Notes.
    
    This function must be called on the shard that owns the referenced
    notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
    same as LinkedNotebook.shardId.)
    
    @param authenticationToken
      This should be an authenticationToken for the guest who has received
      the invitation to the share.  (I.e. this should not be the result of
      NoteStore.authenticateToSharedNotebook)
    
    @param linkedNotebook
      This structure should contain identifying information and permissions
      to access the notebook in question.  This must contain the valid fields
      for either a shared notebook (e.g. shareKey)
      or a public notebook (e.g. username, uri)
    
    @param afterUSN
      The client can pass this value to ask only for objects that
      have been updated after a certain point.  This allows the client to
      receive updates after its last checkpoint rather than doing a full
      synchronization on every pass.  The default value of "0" indicates
      that the client wants to get objects from the start of the account.
    
    @param maxEntries
      The maximum number of modified objects that should be
      returned in the result SyncChunk.  This can be used to limit the size
      of each individual message to be friendly for network transfer.
      Applications should not request more than 256 objects at a time,
      and must handle the case where the service returns less than the
      requested number of objects in a given request even though more
      objects are available on the service.
    
    @param fullSyncOnly
      If true, then the client only wants initial data for a full sync.
      In this case, the service will not return any expunged objects,
      and will not return any Resources, since these are also provided
      in their corresponding Notes.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "afterUSN" - if negative
      </li>
      <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "LinkedNotebook" - if the provided information doesn't match any
        valid notebook
      </li>
      <li> "LinkedNotebook.uri" - if the provided public URI doesn't match any
        valid notebook
      </li>
      <li> "SharedNotebook.id" - if the provided information indicates a
         shared notebook that no longer exists
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - linkedNotebook
     - afterUSN
     - maxEntries
     - fullSyncOnly
    """
    pass

  def listNotebooks(self, authenticationToken):
    """
    Returns a list of all of the notebooks in the account.
    
    Parameters:
     - authenticationToken
    """
    pass

  def getNotebook(self, authenticationToken, guid):
    """
    Returns the current state of the notebook with the provided GUID.
    The notebook may be active or deleted (but not expunged).
    
    @param guid
      The GUID of the notebook to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - tag not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def getDefaultNotebook(self, authenticationToken):
    """
    Returns the notebook that should be used to store new notes in the
    user's account when no other notebooks are specified.
    
    Parameters:
     - authenticationToken
    """
    pass

  def createNotebook(self, authenticationToken, notebook):
    """
    Asks the service to make a notebook with the provided name.
    
    @param notebook
      The desired fields for the notebook must be provided on this
      object.  The name of the notebook must be set, and either the 'active'
      or 'defaultNotebook' fields may be set by the client at creation.
      If a notebook exists in the account with the same name (via
      case-insensitive compare), this will throw an EDAMUserException.
    
    @return
      The newly created Notebook.  The server-side GUID will be
      saved in this object's 'guid' field.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri
      </li>
      <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long
      </li>
      <li> DATA_CONFLICT "Notebook.name" - name already in use
      </li>
      <li> DATA_CONFLICT "Publishing.uri" - if URI already in use
      </li>
      <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing
      </li>
      <li> LIMIT_REACHED "Notebook" - at max number of notebooks
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - notebook
    """
    pass

  def updateNotebook(self, authenticationToken, notebook):
    """
    Submits notebook changes to the service.  The provided data must include
    the notebook's guid field for identification.
    
    @param notebook
      The notebook object containing the requested changes.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri
      </li>
      <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long
      </li>
      <li> DATA_CONFLICT "Notebook.name" - name already in use
      </li>
      <li> DATA_CONFLICT "Publishing.uri" - if URI already in use
      </li>
      <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - notebook
    """
    pass

  def expungeNotebook(self, authenticationToken, guid):
    """
    Permanently removes the notebook from the user's account.
    After this action, the notebook is no longer available for undeletion, etc.
    If the notebook contains any Notes, they will be moved to the current
    default notebook and moved into the trash (i.e. Note.active=false).
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param guid
      The GUID of the notebook to delete.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
      </li>
      <li> LIMIT_REACHED "Notebook" - trying to expunge the last Notebook
      </li>
      <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def listTags(self, authenticationToken):
    """
    Returns a list of the tags in the account.  Evernote does not support
    the undeletion of tags, so this will only include active tags.
    
    Parameters:
     - authenticationToken
    """
    pass

  def listTagsByNotebook(self, authenticationToken, notebookGuid):
    """
    Returns a list of the tags that are applied to at least one note within
    the provided notebook.  If the notebook is public, the authenticationToken
    may be ignored.
    
    @param notebookGuid
       the GUID of the notebook to use to find tags
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - notebook not found by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - notebookGuid
    """
    pass

  def getTag(self, authenticationToken, guid):
    """
    Returns the current state of the Tag with the provided GUID.
    
    @param guid
      The GUID of the tag to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Tag.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Tag" - private Tag, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Tag.guid" - tag not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def createTag(self, authenticationToken, tag):
    """
    Asks the service to make a tag with a set of information.
    
    @param tag
      The desired list of fields for the tag are specified in this
      object.  The caller must specify the tag name, and may provide
      the parentGUID.
    
    @return
      The newly created Tag.  The server-side GUID will be
      saved in this object.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
      </li>
      <li> DATA_CONFLICT "Tag.name" - name already in use
      </li>
      <li> LIMIT_REACHED "Tag" - at max number of tags
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Tag.parentGuid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - tag
    """
    pass

  def updateTag(self, authenticationToken, tag):
    """
    Submits tag changes to the service.  The provided data must include
    the tag's guid field for identification.  The service will apply
    updates to the following tag fields:  name, parentGuid
    
    @param tag
      The tag object containing the requested changes.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
      </li>
      <li> DATA_CONFLICT "Tag.name" - name already in use
      </li>
      <li> DATA_CONFLICT "Tag.parentGuid" - can't set parent: circular
      </li>
      <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Tag.guid" - tag not found, by GUID
      </li>
      <li> "Tag.parentGuid" - parent not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - tag
    """
    pass

  def untagAll(self, authenticationToken, guid):
    """
    Removes the provided tag from every note that is currently tagged with
    this tag.  If this operation is successful, the tag will still be in
    the account, but it will not be tagged on any notes.
    
    This function is not indended for use by full synchronizing clients, since
    it does not provide enough result information to the client to reconcile
    the local state without performing a follow-up sync from the service.  This
    is intended for "thin clients" that need to efficiently support this as
    a UI operation.
    
    @param guid
      The GUID of the tag to remove from all notes.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
      </li>
      <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Tag.guid" - tag not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def expungeTag(self, authenticationToken, guid):
    """
    Permanently deletes the tag with the provided GUID, if present.
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param guid
      The GUID of the tag to delete.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
      </li>
      <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Tag.guid" - tag not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def listSearches(self, authenticationToken):
    """
    Returns a list of the searches in the account.  Evernote does not support
    the undeletion of searches, so this will only include active searches.
    
    Parameters:
     - authenticationToken
    """
    pass

  def getSearch(self, authenticationToken, guid):
    """
    Returns the current state of the search with the provided GUID.
    
    @param guid
      The GUID of the search to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "SavedSearch" - private Tag, user doesn't own
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def createSearch(self, authenticationToken, search):
    """
    Asks the service to make a saved search with a set of information.
    
    @param search
      The desired list of fields for the search are specified in this
      object.  The caller must specify the
      name, query, and format of the search.
    
    @return
      The newly created SavedSearch.  The server-side GUID will be
      saved in this object.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
      </li>
      <li> BAD_DATA_FORMAT "SavedSearch.format" - not a valid QueryFormat value
      </li>
      <li> DATA_CONFLICT "SavedSearch.name" - name already in use
      </li>
      <li> LIMIT_REACHED "SavedSearch" - at max number of searches
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - search
    """
    pass

  def updateSearch(self, authenticationToken, search):
    """
    Submits search changes to the service.  The provided data must include
    the search's guid field for identification.  The service will apply
    updates to the following search fields:  name, query, and format
    
    @param search
      The search object containing the requested changes.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
      </li>
      <li> BAD_DATA_FORMAT "SavedSearch.format" - not a valid QueryFormat value
      </li>
      <li> DATA_CONFLICT "SavedSearch.name" - name already in use
      </li>
      <li> PERMISSION_DENIED "SavedSearch" - user doesn't own tag
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "SavedSearch.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - search
    """
    pass

  def expungeSearch(self, authenticationToken, guid):
    """
    Permanently deletes the saved search with the provided GUID, if present.
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param guid
      The GUID of the search to delete.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the guid parameter is empty
      </li>
      <li> PERMISSION_DENIED "SavedSearch" - user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "SavedSearch.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def findNotes(self, authenticationToken, filter, offset, maxNotes):
    """
    Used to find a set of the notes from a user's account based on various
    criteria specified via a NoteFilter object.
    The Notes (and any embedded Resources) will have empty Data bodies for
    contents, resource data, and resource recognition fields.  These values
    must be retrieved individually.
    
    @param authenticationToken
      Must be a valid token for the user's account unless the NoteFilter
      'notebookGuid' is the GUID of a public notebook.
    
    @param filter
      The list of criteria that will constrain the notes to be returned.
    
    @param offset
      The numeric index of the first note to show within the sorted
      results.  The numbering scheme starts with "0".  This can be used for
      pagination.
    
    @param maxNotes
      The most notes to return in this query.  The service will return a set
      of notes that is no larger than this number, but may return fewer notes
      if needed.  The NoteList.totalNotes field in the return value will
      indicate whether there are more values available after the returned set.
    
    @return
      The list of notes that match the criteria.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
      </li>
      <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      </li>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - filter
     - offset
     - maxNotes
    """
    pass

  def findNoteOffset(self, authenticationToken, filter, guid):
    """
    Finds the position of a note within a sorted subset of all of the user's
    notes. This may be useful for thin clients that are displaying a paginated
    listing of a large account, which need to know where a particular note
    sits in the list without retrieving all notes first.
    
    @param authenticationToken
      Must be a valid token for the user's account unless the NoteFilter
      'notebookGuid' is the GUID of a public notebook.
    
    @param filter
      The list of criteria that will constrain the notes to be returned.
    
    @param guid
      The GUID of the note to be retrieved.
    
    @return
      If the note with the provided GUID is found within the matching note
      list, this will return the offset of that note within that list (where
      the first offset is 0).  If the note is not found within the set of
      notes, this will return -1.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
      </li>
      <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      </li>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - filter
     - guid
    """
    pass

  def findNotesMetadata(self, authenticationToken, filter, offset, maxNotes, resultSpec):
    """
    Used to find the high-level information about a set of the notes from a
    user's account based on various criteria specified via a NoteFilter object.
    This should be used instead of 'findNotes' whenever the client doesn't
    really need all of the deep structure of every Note and Resource, but
    just wants a high-level list of information.  This will save time and
    bandwidth.
    
    @param authenticationToken
      Must be a valid token for the user's account unless the NoteFilter
      'notebookGuid' is the GUID of a public notebook.
    
    @param filter
      The list of criteria that will constrain the notes to be returned.
    
    @param offset
      The numeric index of the first note to show within the sorted
      results.  The numbering scheme starts with "0".  This can be used for
      pagination.
    
    @param maxNotes
      The mximum notes to return in this query.  The service will return a set
      of notes that is no larger than this number, but may return fewer notes
      if needed.  The NoteList.totalNotes field in the return value will
      indicate whether there are more values available after the returned set.
    
    @param resultSpec
      This specifies which information should be returned for each matching
      Note. The fields on this structure can be used to eliminate data that
      the client doesn't need, which will reduce the time and bandwidth
      to receive and process the reply.
    
    @return
      The list of notes that match the criteria.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
      </li>
      <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - filter
     - offset
     - maxNotes
     - resultSpec
    """
    pass

  def findNoteCounts(self, authenticationToken, filter, withTrash):
    """
    This function is used to determine how many notes are found for each
    notebook and tag in the user's account, given a current set of filter
    parameters that determine the current selection.  This function will
    return a structure that gives the note count for each notebook and tag
    that has at least one note under the requested filter.  Any notebook or
    tag that has zero notes in the filtered set will not be listed in the
    reply to this function (so they can be assumed to be 0).
    
    @param authenticationToken
      Must be a valid token for the user's account unless the NoteFilter
      'notebookGuid' is the GUID of a public notebook.
    
    @param filter
      The note selection filter that is currently being applied.  The note
      counts are to be calculated with this filter applied to the total set
      of notes in the user's account.
    
    @param withTrash
      If true, then the NoteCollectionCounts.trashCount will be calculated
      and supplied in the reply. Otherwise, the trash value will be omitted.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.notebookGuids" - if any are malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      </li>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - filter
     - withTrash
    """
    pass

  def getNote(self, authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData):
    """
    Returns the current state of the note in the service with the provided
    GUID.  The ENML contents of the note will only be provided if the
    'withContent' parameter is true.  The service will include the meta-data
    for each resource in the note, but the binary contents of the resources
    and their recognition data will be omitted.
    If the Note is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).  The applicationData
    fields are returned as keysOnly.
    
    @param guid
      The GUID of the note to be retrieved.
    
    @param withContent
      If true, the note will include the ENML contents of its
      'content' field.
    
    @param withResourcesData
      If true, any Resource elements in this Note will include the binary
      contents of their 'data' field's body.
    
    @param withResourcesRecognition
      If true, any Resource elements will include the binary contents of the
      'recognition' field's body if recognition data is present.
    
    @param withResourcesAlternateData
      If true, any Resource elements in this Note will include the binary
      contents of their 'alternateData' fields' body, if an alternate form
      is present.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
     - withContent
     - withResourcesData
     - withResourcesRecognition
     - withResourcesAlternateData
    """
    pass

  def getNoteApplicationData(self, authenticationToken, guid):
    """
    Get all of the application data for the note identified by GUID,
    with values returned within the LazyMap fullMap field.
    If there are no applicationData entries, then a LazyMap
    with an empty fullMap will be returned. If your application
    only needs to fetch its own applicationData entry, use
    getNoteApplicationDataEntry instead.
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def getNoteApplicationDataEntry(self, authenticationToken, guid, key):
    """
    Get the value of a single entry in the applicationData map
    for the note identified by GUID.
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - note not found, by GUID</li>
      <li> "NoteAttributes.applicationData.key" - note not found, by key</li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
     - key
    """
    pass

  def setNoteApplicationDataEntry(self, authenticationToken, guid, key, value):
    """
    Update, or create, an entry in the applicationData map for
    the note identified by guid.
    
    Parameters:
     - authenticationToken
     - guid
     - key
     - value
    """
    pass

  def unsetNoteApplicationDataEntry(self, authenticationToken, guid, key):
    """
    Remove an entry identified by 'key' from the applicationData map for
    the note identified by 'guid'. Silently ignores an unset of a
    non-existing key.
    
    Parameters:
     - authenticationToken
     - guid
     - key
    """
    pass

  def getNoteContent(self, authenticationToken, guid):
    """
    Returns XHTML contents of the note with the provided GUID.
    If the Note is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the note to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def getNoteSearchText(self, authenticationToken, guid, noteOnly, tokenizeForIndexing):
    """
    Returns a block of the extracted plain text contents of the note with the
    provided GUID.  This text can be indexed for search purposes by a light
    client that doesn't have capabilities to extract all of the searchable
    text content from the note and its resources.
    
    If the Note is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the note to be retrieved.
    
    @param noteOnly
      If true, this will only return the text extracted from the ENML contents
      of the note itself.  If false, this will also include the extracted text
      from any text-bearing resources (PDF, recognized images)
    
    @param tokenizeForIndexing
      If true, this will break the text into cleanly separated and sanitized
      tokens.  If false, this will return the more raw text extraction, with
      its original punctuation, capitalization, spacing, etc.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
     - noteOnly
     - tokenizeForIndexing
    """
    pass

  def getResourceSearchText(self, authenticationToken, guid):
    """
    Returns a block of the extracted plain text contents of the resource with
    the provided GUID.  This text can be indexed for search purposes by a light
    client that doesn't have capability to extract all of the searchable
    text content from a resource.
    
    If the Resource is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the resource to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def getNoteTagNames(self, authenticationToken, guid):
    """
    Returns a list of the names of the tags for the note with the provided
    guid.  This can be used with authentication to get the tags for a
    user's own note, or can be used without valid authentication to retrieve
    the names of the tags for a note in a public notebook.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def createNote(self, authenticationToken, note):
    """
    Asks the service to make a note with the provided set of information.
    
    @param note
      A Note object containing the desired fields to be populated on
      the service.
    
    @return
      The newly created Note from the service.  The server-side
      GUIDs for the Note and any Resources will be saved in this object.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML content
      </li>
      <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      </li>
      <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
      </li>
      <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      </li>
      <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
      </li>
      <li> DATA_REQUIRED "Resource.data" - resource data body missing
      </li>
      <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      </li>
      <li> LIMIT_REACHED "Note" - at max number per account
      </li>
      <li> LIMIT_REACHED "Note.size" - total note size too large
      </li>
      <li> LIMIT_REACHED "Note.resources" - too many resources on Note
      </li>
      <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
      </li>
      <li> LIMIT_REACHED "Resource.data.size" - resource too large
      </li>
      <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
      </li>
      <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      </li>
      <li> PERMISSION_DENIED "Note.notebookGuid" - NB not owned by user
      </li>
      <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      </li>
      <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
        of the specified tags had an invalid length or pattern
      </li>
      <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
        new tags would exceed the maximum number per account
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.notebookGuid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - note
    """
    pass

  def updateNote(self, authenticationToken, note):
    """
    Submit a set of changes to a note to the service.  The provided data
    must include the note's guid field for identification. The note's
    title must also be set.
    
    @param note
      A Note object containing the desired fields to be populated on
      the service. With the exception of the note's title and guid, fields
      that are not being changed do not need to be set. If the content is not
      being modified, note.content should be left unset. If the list of
      resources is not being modified, note.resources should be left unset.
    
    @return
      The metadata (no contents) for the Note on the server after the update
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML body
      </li>
      <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
      </li>
      <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      </li>
      <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      </li>
      <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
      </li>
      <li> DATA_REQUIRED "Resource.data" - resource data body missing
      </li>
      <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      </li>
      <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
      </li>
      <li> LIMIT_REACHED "Note.resources" - too many resources on Note
      </li>
      <li> LIMIT_REACHED "Note.size" - total note size too large
      </li>
      <li> LIMIT_REACHED "Resource.data.size" - resource too large
      </li>
      <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
      </li>
      <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      </li>
      <li> PERMISSION_DENIED "Note" - user doesn't own
      </li>
      <li> PERMISSION_DENIED "Note.notebookGuid" - user doesn't own destination
      </li>
      <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      </li>
      <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
        of the specified tags had an invalid length or pattern
      </li>
      <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
        new tags would exceed the maximum number per account
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - note not found, by GUID
      </li>
      <li> "Note.notebookGuid" - if notebookGuid provided, but not found
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - note
    """
    pass

  def deleteNote(self, authenticationToken, guid):
    """
    Moves the note into the trash. The note may still be undeleted, unless it
    is expunged.  This is equivalent to calling updateNote() after setting
    Note.active = false
    
    @param guid
      The GUID of the note to delete.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "Note" - user doesn't have permission to
             update the note.
      </li>
    </ul>
    
    @throws EDAMUserException <ul>
      <li> DATA_CONFLICT "Note.guid" - the note is already deleted
      </li>
    </ul>
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def expungeNote(self, authenticationToken, guid):
    """
    Permanently removes a Note, and all of its Resources,
    from the service.
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param guid
      The GUID of the note to delete.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "Note" - user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def expungeNotes(self, authenticationToken, noteGuids):
    """
    Permanently removes a list of Notes, and all of their Resources, from
    the service.  This should be invoked with a small number of Note GUIDs
    (e.g. 100 or less) on each call.  To expunge a larger number of notes,
    call this method multiple times.  This should also be used to reduce the
    number of Notes in a notebook before calling expungeNotebook() or
    in the trash before calling expungeInactiveNotes(), since these calls may
    be prohibitively slow if there are more than a few hundred notes.
    If an exception is thrown for any of the GUIDs, then none of the notes
    will be deleted.  I.e. this call can be treated as an atomic transaction.
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param noteGuids
      The list of GUIDs for the Notes to remove.
    
    @return
      The account's updateCount at the end of this operation
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "Note" - user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - noteGuids
    """
    pass

  def expungeInactiveNotes(self, authenticationToken):
    """
    Permanently removes all of the Notes that are currently marked as
    inactive.  This is equivalent to "emptying the trash", and these Notes
    will be gone permanently.
    <p/>
    This operation may be relatively slow if the account contains a large
    number of inactive Notes.
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @return
       The number of notes that were expunged.
    
    Parameters:
     - authenticationToken
    """
    pass

  def copyNote(self, authenticationToken, noteGuid, toNotebookGuid):
    """
    Performs a deep copy of the Note with the provided GUID 'noteGuid' into
    the Notebook with the provided GUID 'toNotebookGuid'.
    The caller must be the owner of both the Note and the Notebook.
    This creates a new Note in the destination Notebook with new content and
    Resources that match all of the content and Resources from the original
    Note, but with new GUID identifiers.
    The original Note is not modified by this operation.
    The copied note is considered as an "upload" for the purpose of upload
    transfer limit calculation, so its size is added to the upload count for
    the owner.
    
    @param noteGuid
      The GUID of the Note to copy.
    
    @param toNotebookGuid
      The GUID of the Notebook that should receive the new Note.
    
    @return
      The metadata for the new Note that was created.  This will include the
      new GUID for this Note (and any copied Resources), but will not include
      the content body or the binary bodies of any Resources.
    
    @throws EDAMUserException <ul>
      <li> LIMIT_REACHED "Note" - at max number per account
      </li>
      <li> PERMISSION_DENIED "Notebook.guid" - destination not owned by user
      </li>
      <li> PERMISSION_DENIED "Note" - user doesn't own
      </li>
      <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - noteGuid
     - toNotebookGuid
    """
    pass

  def listNoteVersions(self, authenticationToken, noteGuid):
    """
    Returns a list of the prior versions of a particular note that are
    saved within the service.  These prior versions are stored to provide a
    recovery from unintentional removal of content from a note. The identifiers
    that are returned by this call can be used with getNoteVersion to retrieve
    the previous note.
    The identifiers will be listed from the most recent versions to the oldest.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - noteGuid
    """
    pass

  def getNoteVersion(self, authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData):
    """
    This can be used to retrieve a previous version of a Note after it has been
    updated within the service.  The caller must identify the note (via its
    guid) and the version (via the updateSequenceNumber of that version).
    to find a listing of the stored version USNs for a note, call
    listNoteVersions.
    This call is only available for notes in Premium accounts.  (I.e. access
    to past versions of Notes is a Premium-only feature.)
    
    @param guid
      The GUID of the note to be retrieved.
    
    @param updateSequenceNum
      The USN of the version of the note that is being retrieved
    
    @param withResourcesData
      If true, any Resource elements in this Note will include the binary
      contents of their 'data' field's body.
    
    @param withResourcesRecognition
      If true, any Resource elements will include the binary contents of the
      'recognition' field's body if recognition data is present.
    
    @param withResourcesAlternateData
      If true, any Resource elements in this Note will include the binary
      contents of their 'alternateData' fields' body, if an alternate form
      is present.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
      <li> PERMISSION_DENIED "updateSequenceNum" -
        The account isn't permitted to access previous versions of notes.
        (i.e. this is a Free account.)
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
      <li> "Note.updateSequenceNumber" - the Note doesn't have a version with
         the corresponding USN.
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - noteGuid
     - updateSequenceNum
     - withResourcesData
     - withResourcesRecognition
     - withResourcesAlternateData
    """
    pass

  def getResource(self, authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData):
    """
    Returns the current state of the resource in the service with the
    provided GUID.
    If the Resource is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).  Only the
    keys for the applicationData will be returned.
    
    @param guid
      The GUID of the resource to be retrieved.
    
    @param withData
      If true, the Resource will include the binary contents of the
      'data' field's body.
    
    @param withRecognition
      If true, the Resource will include the binary contents of the
      'recognition' field's body if recognition data is present.
    
    @param withAttributes
      If true, the Resource will include the attributes
    
    @param withAlternateData
      If true, the Resource will include the binary contents of the
      'alternateData' field's body, if an alternate form is present.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
     - withData
     - withRecognition
     - withAttributes
     - withAlternateData
    """
    pass

  def getResourceApplicationData(self, authenticationToken, guid):
    """
    Get all of the application data for the Resource identified by GUID,
    with values returned within the LazyMap fullMap field.
    If there are no applicationData entries, then a LazyMap
    with an empty fullMap will be returned. If your application
    only needs to fetch its own applicationData entry, use
    getResourceApplicationDataEntry instead.
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def getResourceApplicationDataEntry(self, authenticationToken, guid, key):
    """
    Get the value of a single entry in the applicationData map
    for the Resource identified by GUID.
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - Resource not found, by GUID</li>
      <li> "ResourceAttributes.applicationData.key" - Resource not found, by key</li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
     - key
    """
    pass

  def setResourceApplicationDataEntry(self, authenticationToken, guid, key, value):
    """
    Update, or create, an entry in the applicationData map for
    the Resource identified by guid.
    
    Parameters:
     - authenticationToken
     - guid
     - key
     - value
    """
    pass

  def unsetResourceApplicationDataEntry(self, authenticationToken, guid, key):
    """
    Remove an entry identified by 'key' from the applicationData map for
    the Resource identified by 'guid'.
    
    Parameters:
     - authenticationToken
     - guid
     - key
    """
    pass

  def updateResource(self, authenticationToken, resource):
    """
    Submit a set of changes to a resource to the service.  This can be used
    to update the meta-data about the resource, but cannot be used to change
    the binary contents of the resource (including the length and hash).  These
    cannot be changed directly without creating a new resource and removing the
    old one via updateNote.
    
    @param resource
      A Resource object containing the desired fields to be populated on
      the service.  The service will attempt to update the resource with the
      following fields from the client:
      <ul>
         <li>guid:  must be provided to identify the resource
         </li>
         <li>mime
         </li>
         <li>width
         </li>
         <li>height
         </li>
         <li>duration
         </li>
         <li>attributes:  optional.  if present, the set of attributes will
              be replaced.
         </li>
      </ul>
    
    @return
      The Update Sequence Number of the resource after the changes have been
      applied.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      </li>
      <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      </li>
      <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - resource
    """
    pass

  def getResourceData(self, authenticationToken, guid):
    """
    Returns binary data of the resource with the provided GUID.  For
    example, if this were an image resource, this would contain the
    raw bits of the image.
    If the Resource is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the resource to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def getResourceByHash(self, authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData):
    """
    Returns the current state of a resource, referenced by containing
    note GUID and resource content hash.
    
    @param noteGuid
      The GUID of the note that holds the resource to be retrieved.
    
    @param contentHash
      The MD5 checksum of the resource within that note.
    
    @param withData
      If true, the Resource will include the binary contents of the
      'data' field's body.
    
    @param withRecognition
      If true, the Resource will include the binary contents of the
      'recognition' field's body.
    
    @param withAlternateData
      If true, the Resource will include the binary contents of the
      'alternateData' field's body, if an alternate form is present.
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "Note.guid" - noteGuid param missing
      </li>
      <li> DATA_REQUIRED "Note.contentHash" - contentHash param missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note" - not found, by guid
      </li>
      <li> "Resource" - not found, by hash
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - noteGuid
     - contentHash
     - withData
     - withRecognition
     - withAlternateData
    """
    pass

  def getResourceRecognition(self, authenticationToken, guid):
    """
    Returns the binary contents of the recognition index for the resource
    with the provided GUID.  If the caller asks about a resource that has
    no recognition data, this will throw EDAMNotFoundException.
    If the Resource is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the resource whose recognition data should be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
      <li> "Resource.recognition" - resource has no recognition
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def getResourceAlternateData(self, authenticationToken, guid):
    """
    If the Resource with the provided GUID has an alternate data representation
    (indicated via the Resource.alternateData field), then this request can
    be used to retrieve the binary contents of that alternate data file.
    If the caller asks about a resource that has no alternate data form, this
    will throw EDAMNotFoundException.
    
    @param guid
       The GUID of the resource whose recognition data should be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
      <li> "Resource.alternateData" - resource has no recognition
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def getResourceAttributes(self, authenticationToken, guid):
    """
    Returns the set of attributes for the Resource with the provided GUID.
    If the Resource is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the resource whose attributes should be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def getAccountSize(self, authenticationToken):
    """
    @deprecated -
      This function is deprecated, and should no longer be used.  This will
      always return a value of '0'.
    
    Parameters:
     - authenticationToken
    """
    pass

  def getAds(self, authenticationToken, adParameters):
    """
    Clients should make this call once per day to receive a bundle of ads that
    will be displayed for the subsequent 24 hour period.
    <p/>
    NOTE: This function is not available to third party applications.
    
    @param adParameters
      A set of parameters that help the service determine which ads to return.
    
    Parameters:
     - authenticationToken
     - adParameters
    """
    pass

  def getRandomAd(self, authenticationToken, adParameters):
    """
    A thin client should make this call to retrieve a single random ad for
    immediate display.
    <p/>
    NOTE: This function is not available to third party applications.
    
    @param adParameters
      A set of parameters to help the service determine which ad to return.
      The 'impression' field should either be absent (if no ads have been
      displayed previously), or else it should contain the identifier for
      the most recently-displayed ad so that the service can give a different
      ad.
    
    Parameters:
     - authenticationToken
     - adParameters
    """
    pass

  def getPublicNotebook(self, userId, publicUri):
    """
    Looks for a user account with the provided userId on this NoteStore
    shard and determines whether that account contains a public notebook
    with the given URI.  If the account is not found, or no public notebook
    exists with this URI, this will throw an EDAMNotFoundException,
    otherwise this will return the information for that Notebook.
    
    @param userId
       The numeric identifier for the user who owns the public notebook.
       To find this value based on a username string, you can invoke
       UserStore.getPublicUserInfo
    
    @param publicUri
       The uri string for the public notebook, from Notebook.publishing.uri.
       If a notebook is visible on the web with a full URL like
       http://www.evernote.com/pub/ensupport/faq
       Then 'ensupport' is the username and 'faq' is the uri.
    
    @throws EDAMNotFoundException <ul>
      <li> "Publishing.uri" - not found, by URI
      </li>
    </ul>
    
    Parameters:
     - userId
     - publicUri
    """
    pass

  def createSharedNotebook(self, authenticationToken, sharedNotebook):
    """
    Used to construct a shared notebook object. The constructed notebook will
    contain a "share key" which serve as a unique identifer and access token
    for a user to access the notebook of the shared notebook owner.
    
    @param sharedNotebook
      An shared notebook object populated with the email address of the share
      recipient, the notebook guid and the access permissions. All other
      attributes of the shared object are ignored.
    @return
      The fully populated SharedNotebook object including the server assigned
      share id and shareKey which can both the used to uniquely identify the
      SharedNotebook.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "SharedNotebook.email" - if the  email was not valid
      </li>
      </ul>
    @throws EDAMNotFoundException <ul>
      <li> Notebook.guid - if the notebookGuid is not a valid guid for the user
      </li>
      </ul>
    
    Parameters:
     - authenticationToken
     - sharedNotebook
    """
    pass

  def sendMessageToSharedNotebookMembers(self, authenticationToken, notebookGuid, messageText, recipients):
    """
    Send a reminder message to some or all of the email addresses that a notebook has been
    shared with. The message includes the current link to view the notebook.
    @param authenticationToken
      The auth token of the user with permissions to share the notebook
    @param notebookGuid
      The guid of the shared notebook
    @param messageText
     User provided text to include in the email
    @param recipients
     The email addresses of the recipients. If this list is empty then all of the
     users that the notebook has been shared with are emailed.
     If an email address doesn't correspond to share invite members then that address
     is ignored.
    @return
     The number of messages sent
    @throws EDAMUserException <ul>
      <li> LIMIT_REACHED "(recipients)" -
        The email can't be sent because this would exceed the user's daily
        email limit.
      </li>
      <li> PERMISSION_DENIED "Notebook" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - notebookGuid
     - messageText
     - recipients
    """
    pass

  def listSharedNotebooks(self, authenticationToken):
    """
    Lists the collection of shared notebooks for all notebooks in the
    users account.
    
    @return
     The list of all SharedNotebooks for the user
    
    Parameters:
     - authenticationToken
    """
    pass

  def expungeSharedNotebooks(self, authenticationToken, sharedNotebookIds):
    """
    Expunges the SharedNotebooks in the user's account using the
    SharedNotebook.id as the identifier.
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param
      sharedNotebookIds - a list of ShardNotebook.id longs identifying the
          objects to delete permanently.
    
    @return
      The account's update sequence number.
    
    Parameters:
     - authenticationToken
     - sharedNotebookIds
    """
    pass

  def createLinkedNotebook(self, authenticationToken, linkedNotebook):
    """
    Asks the service to make a linked notebook with the provided name, username
    of the owner and identifiers provided. A linked notebook can be either a
    link to a public notebook or to a private shared notebook.
    
    @param linkedNotebook
      The desired fields for the linked notebook must be provided on this
      object.  The name of the linked notebook must be set. Either a username
      uri or a shard id and share key must be provided otherwise a
      EDAMUserException is thrown.
    
    @return
      The newly created LinkedNotebook.  The server-side id will be
      saved in this object's 'id' field.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "LinkedNotebook.username" - bad username format
      </li>
      <li> BAD_DATA_FORMAT "LinkedNotebook.uri" -
        if public notebook set but bad uri
      </li>
      <li> BAD_DATA_FORMAT "LinkedNotebook.shareKey" -
        if private notebook set but bad shareKey
      </li>
      <li> DATA_REQUIRED "LinkedNotebook.shardId" -
        if private notebook but shard id not provided
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - linkedNotebook
    """
    pass

  def updateLinkedNotebook(self, authenticationToken, linkedNotebook):
    """
    @param linkedNotebook
      Updates the name of a linked notebook.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid length or pattern
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - linkedNotebook
    """
    pass

  def listLinkedNotebooks(self, authenticationToken):
    """
    Returns a list of linked notebooks
    
    Parameters:
     - authenticationToken
    """
    pass

  def expungeLinkedNotebook(self, authenticationToken, guid):
    """
    Permanently expunges the linked notebook from the account.
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param guid
      The LinkedNotebook.guid field of the LinkedNotebook to permanently remove
      from the account.
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def authenticateToSharedNotebook(self, shareKey, authenticationToken):
    """
    Asks the service to produce an authentication token that can be used to
    access the contents of a shared notebook from someone else's account.
    This authenticationToken can be used with the various other NoteStore
    calls to find and retrieve notes, and if the permissions in the shared
    notebook are sufficient, to make changes to the contents of the notebook.
    
    @param shareKey
      The 'shareKey' identifier from the SharedNotebook that was granted to
      some recipient.  This string internally encodes the notebook identifier
      and a security signature.
    
    @param authenticationToken
      If a non-empty string is provided, this is the full user-based
      authentication token that identifies the user who is currently logged in
      and trying to access the shared notebook.  This may be required if the
      notebook was created with 'requireLogin'.
      If this string is empty, the service will attempt to authenticate to the
      shared notebook without any logged in user.
    
    @throws EDAMSystemException <ul>
      <li> BAD_DATA_FORMAT "shareKey" - invalid shareKey string
      </li>
      <li> INVALID_AUTH "shareKey" - bad signature on shareKey string
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "SharedNotebook.id" - the shared notebook no longer exists
      </li>
    </ul>
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "authenticationToken" - the share requires login, and
             no valid authentication token was provided.
      </li>
      <li> PERMISSION_DENIED "SharedNotebook.username" - share requires login,
             and another username has already been bound to this notebook.
      </li>
    </ul>
    
    Parameters:
     - shareKey
     - authenticationToken
    """
    pass

  def getSharedNotebookByAuth(self, authenticationToken):
    """
    This function is used to retrieve extended information about a shared
    notebook by a guest who has already authenticated to access that notebook.
    This requires an 'authenticationToken' parameter which should be the
    resut of a call to authenticateToSharedNotebook(...).
    I.e. this is the token that gives access to the particular shared notebook
    in someone else's account -- it's not the authenticationToken for the
    owner of the notebook itself.
    
    @param authenticationToken
      Should be the authentication token retrieved from the reply of
      authenticateToSharedNotebook(), proving access to a particular shared
      notebook.
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "authenticationToken" -
             authentication token doesn't correspond to a valid shared notebook
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "SharedNotebook.id" - the shared notebook no longer exists
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
    """
    pass

  def emailNote(self, authenticationToken, parameters):
    """
    Attempts to send a single note to one or more email recipients.
    
    @param authenticationToken
       The note will be sent as the user logged in via this token, using that
       user's registered email address.  If the authenticated user doesn't
       have permission to read that note, the emailing will fail.
    
    @param parameters
       The note must be specified either by GUID (in which case it will be
       sent using the existing data in the service), or else the full Note
       must be passed to this call.  This also specifies the additional
       email fields that will be used in the email.
    
    @throws EDAMUserException <ul>
      <li> LIMIT_REACHED "NoteEmailParameters.toAddresses" -
        The email can't be sent because this would exceed the user's daily
        email limit.
      </li>
      <li> BAD_DATA_FORMAT "(email address)" -
        email address malformed
      </li>
      <li> DATA_REQUIRED "NoteEmailParameters.toAddresses" -
        if there are no To: or Cc: addresses provided.
      </li>
      <li> DATA_REQUIRED "Note.title" -
        if the caller provides a Note parameter with no title
      </li>
      <li> DATA_REQUIRED "Note.content" -
        if the caller provides a Note parameter with no content
      </li>
      <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      </li>
      <li> DATA_REQUIRED "NoteEmailParameters.note" -
        if no guid or note provided
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - parameters
    """
    pass

  def shareNote(self, authenticationToken, guid):
    """
    If this note is not already shared (via its own direct URL), then this
    will start sharing that note.
    This will return the secret "Note Key" for this note that
    can currently be used in conjunction with the Note's GUID to gain direct
    read-only access to the Note.
    If the note is already shared, then this won't make any changes to the
    note, and the existing "Note Key" will be returned.  The only way to change
    the Note Key for an existing note is to stopSharingNote first, and then
    call this function.
    
    @param guid
      The GUID of the note to be shared.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def stopSharingNote(self, authenticationToken, guid):
    """
    If this note is not already shared then this will stop sharing that note
    and invalidate its "Note Key", so any existing URLs to access that Note
    will stop working.
    If the Note is not shared, then this function will do nothing.
    
    @param guid
      The GUID of the note to be un-shared.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    pass

  def authenticateToSharedNote(self, guid, noteKey):
    """
    Asks the service to produce an authentication token that can be used to
    access the contents of a single Note which was individually shared
    from someone's account.
    This authenticationToken can be used with the various other NoteStore
    calls to find and retrieve the Note and its directly-referenced children.
    
    @param guid
      The GUID identifying this Note on this shard.
    
    @param noteKey
      The 'noteKey' identifier from the Note that was originally created via
      a call to shareNote() and then given to a recipient to access.
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "Note" - the Note with that GUID is either not
        shared, or the noteKey doesn't match the current key for this note
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "guid" - the note with that GUID is not found
      </li>
    </ul>
    
    Parameters:
     - guid
     - noteKey
    """
    pass


class Client(Iface):
  """
  Service:  NoteStore
  <p>
  The NoteStore service is used by EDAM clients to exchange information
  about the collection of notes in an account.  This is primarily used for
  synchronization, but could also be used by a "thin" client without a full
  local cache.
  </p><p>
  All functions take an "authenticationToken" parameter, which is the
  value returned by the UserStore which permits access to the account.
  This parameter is mandatory for all functions.
  </p>
  
  Calls which require an authenticationToken may throw an EDAMUserException
  for the following reasons:
   <ul>
    <li> AUTH_EXPIRED "authenticationToken" - token has expired
    </li>
    <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
    </li>
    <li> DATA_REQUIRED "authenticationToken" - token is empty
    </li>
    <li> INVALID_AUTH "authenticationToken" - token signature is invalid
    </li>
  </ul>
  """
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def getSyncState(self, authenticationToken):
    """
    Asks the NoteStore to provide information about the status of the user
    account corresponding to the provided authentication token.
    
    Parameters:
     - authenticationToken
    """
    self.send_getSyncState(authenticationToken)
    return self.recv_getSyncState()

  def send_getSyncState(self, authenticationToken):
    self._oprot.writeMessageBegin('getSyncState', TMessageType.CALL, self._seqid)
    args = getSyncState_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSyncState(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSyncState_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSyncState failed: unknown result");

  def getSyncStateWithMetrics(self, authenticationToken, clientMetrics):
    """
    Asks the NoteStore to provide information about the status of the user
    account corresponding to the provided authentication token.
    This version of 'getSyncState' allows the client to upload coarse-
    grained usage metrics to the service.
    
    @param clientMetrics  see the documentation of the ClientUsageMetrics
      structure for an explanation of the fields that clients can pass to
      the service.
    
    Parameters:
     - authenticationToken
     - clientMetrics
    """
    self.send_getSyncStateWithMetrics(authenticationToken, clientMetrics)
    return self.recv_getSyncStateWithMetrics()

  def send_getSyncStateWithMetrics(self, authenticationToken, clientMetrics):
    self._oprot.writeMessageBegin('getSyncStateWithMetrics', TMessageType.CALL, self._seqid)
    args = getSyncStateWithMetrics_args()
    args.authenticationToken = authenticationToken
    args.clientMetrics = clientMetrics
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSyncStateWithMetrics(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSyncStateWithMetrics_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSyncStateWithMetrics failed: unknown result");

  def getSyncChunk(self, authenticationToken, afterUSN, maxEntries, fullSyncOnly):
    """
    Asks the NoteStore to provide the state of the account in order of
    last modification.  This request retrieves one block of the server's
    state so that a client can make several small requests against a large
    account rather than getting the entire state in one big message.
    
    @param afterUSN
      The client can pass this value to ask only for objects that
      have been updated after a certain point.  This allows the client to
      receive updates after its last checkpoint rather than doing a full
      synchronization on every pass.  The default value of "0" indicates
      that the client wants to get objects from the start of the account.
    
    @param maxEntries
      The maximum number of modified objects that should be
      returned in the result SyncChunk. This can be used to limit the size
      of each individual message to be friendly for network transfer.
      Applications should not request more than 256 objects at a time,
      and must handle the case where the service returns less than the
      requested number of objects in a given request even though more
      objects are available on the service.
    
    @param fullSyncOnly
      If true, then the client only wants initial data for a full sync.
      In this case, the service will not return any expunged objects,
      and will not return any Resources, since these are also provided
      in their corresponding Notes.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "afterUSN" - if negative
      </li>
      <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - afterUSN
     - maxEntries
     - fullSyncOnly
    """
    self.send_getSyncChunk(authenticationToken, afterUSN, maxEntries, fullSyncOnly)
    return self.recv_getSyncChunk()

  def send_getSyncChunk(self, authenticationToken, afterUSN, maxEntries, fullSyncOnly):
    self._oprot.writeMessageBegin('getSyncChunk', TMessageType.CALL, self._seqid)
    args = getSyncChunk_args()
    args.authenticationToken = authenticationToken
    args.afterUSN = afterUSN
    args.maxEntries = maxEntries
    args.fullSyncOnly = fullSyncOnly
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSyncChunk(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSyncChunk_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSyncChunk failed: unknown result");

  def getFilteredSyncChunk(self, authenticationToken, afterUSN, maxEntries, filter):
    """
    Asks the NoteStore to provide the state of the account in order of
    last modification.  This request retrieves one block of the server's
    state so that a client can make several small requests against a large
    account rather than getting the entire state in one big message.
    This call gives more fine-grained control of the data that will
    be received by a client by omitting data elements that a client doesn't
    need. This may reduce network traffic and sync times.
    
    @param afterUSN
      The client can pass this value to ask only for objects that
      have been updated after a certain point.  This allows the client to
      receive updates after its last checkpoint rather than doing a full
      synchronization on every pass.  The default value of "0" indicates
      that the client wants to get objects from the start of the account.
    
    @param maxEntries
      The maximum number of modified objects that should be
      returned in the result SyncChunk.  This can be used to limit the size
      of each individual message to be friendly for network transfer.
    
    @param filter
      The caller must set some of the flags in this structure to specify which
      data types should be returned during the synchronization.  See
      the SyncChunkFilter structure for information on each flag.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "afterUSN" - if negative
      </li>
      <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - afterUSN
     - maxEntries
     - filter
    """
    self.send_getFilteredSyncChunk(authenticationToken, afterUSN, maxEntries, filter)
    return self.recv_getFilteredSyncChunk()

  def send_getFilteredSyncChunk(self, authenticationToken, afterUSN, maxEntries, filter):
    self._oprot.writeMessageBegin('getFilteredSyncChunk', TMessageType.CALL, self._seqid)
    args = getFilteredSyncChunk_args()
    args.authenticationToken = authenticationToken
    args.afterUSN = afterUSN
    args.maxEntries = maxEntries
    args.filter = filter
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getFilteredSyncChunk(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getFilteredSyncChunk_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getFilteredSyncChunk failed: unknown result");

  def getLinkedNotebookSyncState(self, authenticationToken, linkedNotebook):
    """
    Asks the NoteStore to provide information about the status of a linked
    notebook that has been shared with the caller, or that is public to the
    world.
    This will return a result that is similar to getSyncState, but may omit
    SyncState.uploaded if the caller doesn't have permission to write to
    the linked notebook.
    
    This function must be called on the shard that owns the referenced
    notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
    same as LinkedNotebook.shardId.)
    
    @param authenticationToken
      This should be an authenticationToken for the guest who has received
      the invitation to the share.  (I.e. this should not be the result of
      NoteStore.authenticateToSharedNotebook)
    
    @param linkedNotebook
      This structure should contain identifying information and permissions
      to access the notebook in question.
    
    Parameters:
     - authenticationToken
     - linkedNotebook
    """
    self.send_getLinkedNotebookSyncState(authenticationToken, linkedNotebook)
    return self.recv_getLinkedNotebookSyncState()

  def send_getLinkedNotebookSyncState(self, authenticationToken, linkedNotebook):
    self._oprot.writeMessageBegin('getLinkedNotebookSyncState', TMessageType.CALL, self._seqid)
    args = getLinkedNotebookSyncState_args()
    args.authenticationToken = authenticationToken
    args.linkedNotebook = linkedNotebook
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getLinkedNotebookSyncState(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getLinkedNotebookSyncState_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getLinkedNotebookSyncState failed: unknown result");

  def getLinkedNotebookSyncChunk(self, authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly):
    """
    Asks the NoteStore to provide information about the contents of a linked
    notebook that has been shared with the caller, or that is public to the
    world.
    This will return a result that is similar to getSyncChunk, but will only
    contain entries that are visible to the caller.  I.e. only that particular
    Notebook will be visible, along with its Notes, and Tags on those Notes.
    
    This function must be called on the shard that owns the referenced
    notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
    same as LinkedNotebook.shardId.)
    
    @param authenticationToken
      This should be an authenticationToken for the guest who has received
      the invitation to the share.  (I.e. this should not be the result of
      NoteStore.authenticateToSharedNotebook)
    
    @param linkedNotebook
      This structure should contain identifying information and permissions
      to access the notebook in question.  This must contain the valid fields
      for either a shared notebook (e.g. shareKey)
      or a public notebook (e.g. username, uri)
    
    @param afterUSN
      The client can pass this value to ask only for objects that
      have been updated after a certain point.  This allows the client to
      receive updates after its last checkpoint rather than doing a full
      synchronization on every pass.  The default value of "0" indicates
      that the client wants to get objects from the start of the account.
    
    @param maxEntries
      The maximum number of modified objects that should be
      returned in the result SyncChunk.  This can be used to limit the size
      of each individual message to be friendly for network transfer.
      Applications should not request more than 256 objects at a time,
      and must handle the case where the service returns less than the
      requested number of objects in a given request even though more
      objects are available on the service.
    
    @param fullSyncOnly
      If true, then the client only wants initial data for a full sync.
      In this case, the service will not return any expunged objects,
      and will not return any Resources, since these are also provided
      in their corresponding Notes.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "afterUSN" - if negative
      </li>
      <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "LinkedNotebook" - if the provided information doesn't match any
        valid notebook
      </li>
      <li> "LinkedNotebook.uri" - if the provided public URI doesn't match any
        valid notebook
      </li>
      <li> "SharedNotebook.id" - if the provided information indicates a
         shared notebook that no longer exists
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - linkedNotebook
     - afterUSN
     - maxEntries
     - fullSyncOnly
    """
    self.send_getLinkedNotebookSyncChunk(authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly)
    return self.recv_getLinkedNotebookSyncChunk()

  def send_getLinkedNotebookSyncChunk(self, authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly):
    self._oprot.writeMessageBegin('getLinkedNotebookSyncChunk', TMessageType.CALL, self._seqid)
    args = getLinkedNotebookSyncChunk_args()
    args.authenticationToken = authenticationToken
    args.linkedNotebook = linkedNotebook
    args.afterUSN = afterUSN
    args.maxEntries = maxEntries
    args.fullSyncOnly = fullSyncOnly
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getLinkedNotebookSyncChunk(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getLinkedNotebookSyncChunk_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getLinkedNotebookSyncChunk failed: unknown result");

  def listNotebooks(self, authenticationToken):
    """
    Returns a list of all of the notebooks in the account.
    
    Parameters:
     - authenticationToken
    """
    self.send_listNotebooks(authenticationToken)
    return self.recv_listNotebooks()

  def send_listNotebooks(self, authenticationToken):
    self._oprot.writeMessageBegin('listNotebooks', TMessageType.CALL, self._seqid)
    args = listNotebooks_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listNotebooks(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listNotebooks_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listNotebooks failed: unknown result");

  def getNotebook(self, authenticationToken, guid):
    """
    Returns the current state of the notebook with the provided GUID.
    The notebook may be active or deleted (but not expunged).
    
    @param guid
      The GUID of the notebook to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - tag not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getNotebook(authenticationToken, guid)
    return self.recv_getNotebook()

  def send_getNotebook(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getNotebook', TMessageType.CALL, self._seqid)
    args = getNotebook_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNotebook failed: unknown result");

  def getDefaultNotebook(self, authenticationToken):
    """
    Returns the notebook that should be used to store new notes in the
    user's account when no other notebooks are specified.
    
    Parameters:
     - authenticationToken
    """
    self.send_getDefaultNotebook(authenticationToken)
    return self.recv_getDefaultNotebook()

  def send_getDefaultNotebook(self, authenticationToken):
    self._oprot.writeMessageBegin('getDefaultNotebook', TMessageType.CALL, self._seqid)
    args = getDefaultNotebook_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDefaultNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getDefaultNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDefaultNotebook failed: unknown result");

  def createNotebook(self, authenticationToken, notebook):
    """
    Asks the service to make a notebook with the provided name.
    
    @param notebook
      The desired fields for the notebook must be provided on this
      object.  The name of the notebook must be set, and either the 'active'
      or 'defaultNotebook' fields may be set by the client at creation.
      If a notebook exists in the account with the same name (via
      case-insensitive compare), this will throw an EDAMUserException.
    
    @return
      The newly created Notebook.  The server-side GUID will be
      saved in this object's 'guid' field.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri
      </li>
      <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long
      </li>
      <li> DATA_CONFLICT "Notebook.name" - name already in use
      </li>
      <li> DATA_CONFLICT "Publishing.uri" - if URI already in use
      </li>
      <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing
      </li>
      <li> LIMIT_REACHED "Notebook" - at max number of notebooks
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - notebook
    """
    self.send_createNotebook(authenticationToken, notebook)
    return self.recv_createNotebook()

  def send_createNotebook(self, authenticationToken, notebook):
    self._oprot.writeMessageBegin('createNotebook', TMessageType.CALL, self._seqid)
    args = createNotebook_args()
    args.authenticationToken = authenticationToken
    args.notebook = notebook
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createNotebook failed: unknown result");

  def updateNotebook(self, authenticationToken, notebook):
    """
    Submits notebook changes to the service.  The provided data must include
    the notebook's guid field for identification.
    
    @param notebook
      The notebook object containing the requested changes.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri
      </li>
      <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long
      </li>
      <li> DATA_CONFLICT "Notebook.name" - name already in use
      </li>
      <li> DATA_CONFLICT "Publishing.uri" - if URI already in use
      </li>
      <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - notebook
    """
    self.send_updateNotebook(authenticationToken, notebook)
    return self.recv_updateNotebook()

  def send_updateNotebook(self, authenticationToken, notebook):
    self._oprot.writeMessageBegin('updateNotebook', TMessageType.CALL, self._seqid)
    args = updateNotebook_args()
    args.authenticationToken = authenticationToken
    args.notebook = notebook
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateNotebook failed: unknown result");

  def expungeNotebook(self, authenticationToken, guid):
    """
    Permanently removes the notebook from the user's account.
    After this action, the notebook is no longer available for undeletion, etc.
    If the notebook contains any Notes, they will be moved to the current
    default notebook and moved into the trash (i.e. Note.active=false).
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param guid
      The GUID of the notebook to delete.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
      </li>
      <li> LIMIT_REACHED "Notebook" - trying to expunge the last Notebook
      </li>
      <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_expungeNotebook(authenticationToken, guid)
    return self.recv_expungeNotebook()

  def send_expungeNotebook(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('expungeNotebook', TMessageType.CALL, self._seqid)
    args = expungeNotebook_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_expungeNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = expungeNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeNotebook failed: unknown result");

  def listTags(self, authenticationToken):
    """
    Returns a list of the tags in the account.  Evernote does not support
    the undeletion of tags, so this will only include active tags.
    
    Parameters:
     - authenticationToken
    """
    self.send_listTags(authenticationToken)
    return self.recv_listTags()

  def send_listTags(self, authenticationToken):
    self._oprot.writeMessageBegin('listTags', TMessageType.CALL, self._seqid)
    args = listTags_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listTags(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listTags_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listTags failed: unknown result");

  def listTagsByNotebook(self, authenticationToken, notebookGuid):
    """
    Returns a list of the tags that are applied to at least one note within
    the provided notebook.  If the notebook is public, the authenticationToken
    may be ignored.
    
    @param notebookGuid
       the GUID of the notebook to use to find tags
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - notebook not found by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - notebookGuid
    """
    self.send_listTagsByNotebook(authenticationToken, notebookGuid)
    return self.recv_listTagsByNotebook()

  def send_listTagsByNotebook(self, authenticationToken, notebookGuid):
    self._oprot.writeMessageBegin('listTagsByNotebook', TMessageType.CALL, self._seqid)
    args = listTagsByNotebook_args()
    args.authenticationToken = authenticationToken
    args.notebookGuid = notebookGuid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listTagsByNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listTagsByNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listTagsByNotebook failed: unknown result");

  def getTag(self, authenticationToken, guid):
    """
    Returns the current state of the Tag with the provided GUID.
    
    @param guid
      The GUID of the tag to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Tag.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Tag" - private Tag, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Tag.guid" - tag not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getTag(authenticationToken, guid)
    return self.recv_getTag()

  def send_getTag(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getTag', TMessageType.CALL, self._seqid)
    args = getTag_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getTag(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getTag_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTag failed: unknown result");

  def createTag(self, authenticationToken, tag):
    """
    Asks the service to make a tag with a set of information.
    
    @param tag
      The desired list of fields for the tag are specified in this
      object.  The caller must specify the tag name, and may provide
      the parentGUID.
    
    @return
      The newly created Tag.  The server-side GUID will be
      saved in this object.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
      </li>
      <li> DATA_CONFLICT "Tag.name" - name already in use
      </li>
      <li> LIMIT_REACHED "Tag" - at max number of tags
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Tag.parentGuid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - tag
    """
    self.send_createTag(authenticationToken, tag)
    return self.recv_createTag()

  def send_createTag(self, authenticationToken, tag):
    self._oprot.writeMessageBegin('createTag', TMessageType.CALL, self._seqid)
    args = createTag_args()
    args.authenticationToken = authenticationToken
    args.tag = tag
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createTag(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createTag_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createTag failed: unknown result");

  def updateTag(self, authenticationToken, tag):
    """
    Submits tag changes to the service.  The provided data must include
    the tag's guid field for identification.  The service will apply
    updates to the following tag fields:  name, parentGuid
    
    @param tag
      The tag object containing the requested changes.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
      </li>
      <li> DATA_CONFLICT "Tag.name" - name already in use
      </li>
      <li> DATA_CONFLICT "Tag.parentGuid" - can't set parent: circular
      </li>
      <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Tag.guid" - tag not found, by GUID
      </li>
      <li> "Tag.parentGuid" - parent not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - tag
    """
    self.send_updateTag(authenticationToken, tag)
    return self.recv_updateTag()

  def send_updateTag(self, authenticationToken, tag):
    self._oprot.writeMessageBegin('updateTag', TMessageType.CALL, self._seqid)
    args = updateTag_args()
    args.authenticationToken = authenticationToken
    args.tag = tag
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateTag(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateTag_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateTag failed: unknown result");

  def untagAll(self, authenticationToken, guid):
    """
    Removes the provided tag from every note that is currently tagged with
    this tag.  If this operation is successful, the tag will still be in
    the account, but it will not be tagged on any notes.
    
    This function is not indended for use by full synchronizing clients, since
    it does not provide enough result information to the client to reconcile
    the local state without performing a follow-up sync from the service.  This
    is intended for "thin clients" that need to efficiently support this as
    a UI operation.
    
    @param guid
      The GUID of the tag to remove from all notes.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
      </li>
      <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Tag.guid" - tag not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_untagAll(authenticationToken, guid)
    self.recv_untagAll()

  def send_untagAll(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('untagAll', TMessageType.CALL, self._seqid)
    args = untagAll_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_untagAll(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = untagAll_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    return

  def expungeTag(self, authenticationToken, guid):
    """
    Permanently deletes the tag with the provided GUID, if present.
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param guid
      The GUID of the tag to delete.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
      </li>
      <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Tag.guid" - tag not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_expungeTag(authenticationToken, guid)
    return self.recv_expungeTag()

  def send_expungeTag(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('expungeTag', TMessageType.CALL, self._seqid)
    args = expungeTag_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_expungeTag(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = expungeTag_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeTag failed: unknown result");

  def listSearches(self, authenticationToken):
    """
    Returns a list of the searches in the account.  Evernote does not support
    the undeletion of searches, so this will only include active searches.
    
    Parameters:
     - authenticationToken
    """
    self.send_listSearches(authenticationToken)
    return self.recv_listSearches()

  def send_listSearches(self, authenticationToken):
    self._oprot.writeMessageBegin('listSearches', TMessageType.CALL, self._seqid)
    args = listSearches_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listSearches(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listSearches_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listSearches failed: unknown result");

  def getSearch(self, authenticationToken, guid):
    """
    Returns the current state of the search with the provided GUID.
    
    @param guid
      The GUID of the search to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "SavedSearch" - private Tag, user doesn't own
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getSearch(authenticationToken, guid)
    return self.recv_getSearch()

  def send_getSearch(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getSearch', TMessageType.CALL, self._seqid)
    args = getSearch_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSearch(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSearch_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSearch failed: unknown result");

  def createSearch(self, authenticationToken, search):
    """
    Asks the service to make a saved search with a set of information.
    
    @param search
      The desired list of fields for the search are specified in this
      object.  The caller must specify the
      name, query, and format of the search.
    
    @return
      The newly created SavedSearch.  The server-side GUID will be
      saved in this object.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
      </li>
      <li> BAD_DATA_FORMAT "SavedSearch.format" - not a valid QueryFormat value
      </li>
      <li> DATA_CONFLICT "SavedSearch.name" - name already in use
      </li>
      <li> LIMIT_REACHED "SavedSearch" - at max number of searches
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - search
    """
    self.send_createSearch(authenticationToken, search)
    return self.recv_createSearch()

  def send_createSearch(self, authenticationToken, search):
    self._oprot.writeMessageBegin('createSearch', TMessageType.CALL, self._seqid)
    args = createSearch_args()
    args.authenticationToken = authenticationToken
    args.search = search
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createSearch(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createSearch_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createSearch failed: unknown result");

  def updateSearch(self, authenticationToken, search):
    """
    Submits search changes to the service.  The provided data must include
    the search's guid field for identification.  The service will apply
    updates to the following search fields:  name, query, and format
    
    @param search
      The search object containing the requested changes.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
      </li>
      <li> BAD_DATA_FORMAT "SavedSearch.format" - not a valid QueryFormat value
      </li>
      <li> DATA_CONFLICT "SavedSearch.name" - name already in use
      </li>
      <li> PERMISSION_DENIED "SavedSearch" - user doesn't own tag
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "SavedSearch.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - search
    """
    self.send_updateSearch(authenticationToken, search)
    return self.recv_updateSearch()

  def send_updateSearch(self, authenticationToken, search):
    self._oprot.writeMessageBegin('updateSearch', TMessageType.CALL, self._seqid)
    args = updateSearch_args()
    args.authenticationToken = authenticationToken
    args.search = search
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateSearch(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateSearch_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateSearch failed: unknown result");

  def expungeSearch(self, authenticationToken, guid):
    """
    Permanently deletes the saved search with the provided GUID, if present.
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param guid
      The GUID of the search to delete.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the guid parameter is empty
      </li>
      <li> PERMISSION_DENIED "SavedSearch" - user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "SavedSearch.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_expungeSearch(authenticationToken, guid)
    return self.recv_expungeSearch()

  def send_expungeSearch(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('expungeSearch', TMessageType.CALL, self._seqid)
    args = expungeSearch_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_expungeSearch(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = expungeSearch_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeSearch failed: unknown result");

  def findNotes(self, authenticationToken, filter, offset, maxNotes):
    """
    Used to find a set of the notes from a user's account based on various
    criteria specified via a NoteFilter object.
    The Notes (and any embedded Resources) will have empty Data bodies for
    contents, resource data, and resource recognition fields.  These values
    must be retrieved individually.
    
    @param authenticationToken
      Must be a valid token for the user's account unless the NoteFilter
      'notebookGuid' is the GUID of a public notebook.
    
    @param filter
      The list of criteria that will constrain the notes to be returned.
    
    @param offset
      The numeric index of the first note to show within the sorted
      results.  The numbering scheme starts with "0".  This can be used for
      pagination.
    
    @param maxNotes
      The most notes to return in this query.  The service will return a set
      of notes that is no larger than this number, but may return fewer notes
      if needed.  The NoteList.totalNotes field in the return value will
      indicate whether there are more values available after the returned set.
    
    @return
      The list of notes that match the criteria.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
      </li>
      <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      </li>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - filter
     - offset
     - maxNotes
    """
    self.send_findNotes(authenticationToken, filter, offset, maxNotes)
    return self.recv_findNotes()

  def send_findNotes(self, authenticationToken, filter, offset, maxNotes):
    self._oprot.writeMessageBegin('findNotes', TMessageType.CALL, self._seqid)
    args = findNotes_args()
    args.authenticationToken = authenticationToken
    args.filter = filter
    args.offset = offset
    args.maxNotes = maxNotes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findNotes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = findNotes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findNotes failed: unknown result");

  def findNoteOffset(self, authenticationToken, filter, guid):
    """
    Finds the position of a note within a sorted subset of all of the user's
    notes. This may be useful for thin clients that are displaying a paginated
    listing of a large account, which need to know where a particular note
    sits in the list without retrieving all notes first.
    
    @param authenticationToken
      Must be a valid token for the user's account unless the NoteFilter
      'notebookGuid' is the GUID of a public notebook.
    
    @param filter
      The list of criteria that will constrain the notes to be returned.
    
    @param guid
      The GUID of the note to be retrieved.
    
    @return
      If the note with the provided GUID is found within the matching note
      list, this will return the offset of that note within that list (where
      the first offset is 0).  If the note is not found within the set of
      notes, this will return -1.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
      </li>
      <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      </li>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - filter
     - guid
    """
    self.send_findNoteOffset(authenticationToken, filter, guid)
    return self.recv_findNoteOffset()

  def send_findNoteOffset(self, authenticationToken, filter, guid):
    self._oprot.writeMessageBegin('findNoteOffset', TMessageType.CALL, self._seqid)
    args = findNoteOffset_args()
    args.authenticationToken = authenticationToken
    args.filter = filter
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findNoteOffset(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = findNoteOffset_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findNoteOffset failed: unknown result");

  def findNotesMetadata(self, authenticationToken, filter, offset, maxNotes, resultSpec):
    """
    Used to find the high-level information about a set of the notes from a
    user's account based on various criteria specified via a NoteFilter object.
    This should be used instead of 'findNotes' whenever the client doesn't
    really need all of the deep structure of every Note and Resource, but
    just wants a high-level list of information.  This will save time and
    bandwidth.
    
    @param authenticationToken
      Must be a valid token for the user's account unless the NoteFilter
      'notebookGuid' is the GUID of a public notebook.
    
    @param filter
      The list of criteria that will constrain the notes to be returned.
    
    @param offset
      The numeric index of the first note to show within the sorted
      results.  The numbering scheme starts with "0".  This can be used for
      pagination.
    
    @param maxNotes
      The mximum notes to return in this query.  The service will return a set
      of notes that is no larger than this number, but may return fewer notes
      if needed.  The NoteList.totalNotes field in the return value will
      indicate whether there are more values available after the returned set.
    
    @param resultSpec
      This specifies which information should be returned for each matching
      Note. The fields on this structure can be used to eliminate data that
      the client doesn't need, which will reduce the time and bandwidth
      to receive and process the reply.
    
    @return
      The list of notes that match the criteria.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
      </li>
      <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - filter
     - offset
     - maxNotes
     - resultSpec
    """
    self.send_findNotesMetadata(authenticationToken, filter, offset, maxNotes, resultSpec)
    return self.recv_findNotesMetadata()

  def send_findNotesMetadata(self, authenticationToken, filter, offset, maxNotes, resultSpec):
    self._oprot.writeMessageBegin('findNotesMetadata', TMessageType.CALL, self._seqid)
    args = findNotesMetadata_args()
    args.authenticationToken = authenticationToken
    args.filter = filter
    args.offset = offset
    args.maxNotes = maxNotes
    args.resultSpec = resultSpec
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findNotesMetadata(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = findNotesMetadata_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findNotesMetadata failed: unknown result");

  def findNoteCounts(self, authenticationToken, filter, withTrash):
    """
    This function is used to determine how many notes are found for each
    notebook and tag in the user's account, given a current set of filter
    parameters that determine the current selection.  This function will
    return a structure that gives the note count for each notebook and tag
    that has at least one note under the requested filter.  Any notebook or
    tag that has zero notes in the filtered set will not be listed in the
    reply to this function (so they can be assumed to be 0).
    
    @param authenticationToken
      Must be a valid token for the user's account unless the NoteFilter
      'notebookGuid' is the GUID of a public notebook.
    
    @param filter
      The note selection filter that is currently being applied.  The note
      counts are to be calculated with this filter applied to the total set
      of notes in the user's account.
    
    @param withTrash
      If true, then the NoteCollectionCounts.trashCount will be calculated
      and supplied in the reply. Otherwise, the trash value will be omitted.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.notebookGuids" - if any are malformed
      </li>
      <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      </li>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - filter
     - withTrash
    """
    self.send_findNoteCounts(authenticationToken, filter, withTrash)
    return self.recv_findNoteCounts()

  def send_findNoteCounts(self, authenticationToken, filter, withTrash):
    self._oprot.writeMessageBegin('findNoteCounts', TMessageType.CALL, self._seqid)
    args = findNoteCounts_args()
    args.authenticationToken = authenticationToken
    args.filter = filter
    args.withTrash = withTrash
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findNoteCounts(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = findNoteCounts_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findNoteCounts failed: unknown result");

  def getNote(self, authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData):
    """
    Returns the current state of the note in the service with the provided
    GUID.  The ENML contents of the note will only be provided if the
    'withContent' parameter is true.  The service will include the meta-data
    for each resource in the note, but the binary contents of the resources
    and their recognition data will be omitted.
    If the Note is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).  The applicationData
    fields are returned as keysOnly.
    
    @param guid
      The GUID of the note to be retrieved.
    
    @param withContent
      If true, the note will include the ENML contents of its
      'content' field.
    
    @param withResourcesData
      If true, any Resource elements in this Note will include the binary
      contents of their 'data' field's body.
    
    @param withResourcesRecognition
      If true, any Resource elements will include the binary contents of the
      'recognition' field's body if recognition data is present.
    
    @param withResourcesAlternateData
      If true, any Resource elements in this Note will include the binary
      contents of their 'alternateData' fields' body, if an alternate form
      is present.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
     - withContent
     - withResourcesData
     - withResourcesRecognition
     - withResourcesAlternateData
    """
    self.send_getNote(authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData)
    return self.recv_getNote()

  def send_getNote(self, authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData):
    self._oprot.writeMessageBegin('getNote', TMessageType.CALL, self._seqid)
    args = getNote_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.withContent = withContent
    args.withResourcesData = withResourcesData
    args.withResourcesRecognition = withResourcesRecognition
    args.withResourcesAlternateData = withResourcesAlternateData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNote failed: unknown result");

  def getNoteApplicationData(self, authenticationToken, guid):
    """
    Get all of the application data for the note identified by GUID,
    with values returned within the LazyMap fullMap field.
    If there are no applicationData entries, then a LazyMap
    with an empty fullMap will be returned. If your application
    only needs to fetch its own applicationData entry, use
    getNoteApplicationDataEntry instead.
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getNoteApplicationData(authenticationToken, guid)
    return self.recv_getNoteApplicationData()

  def send_getNoteApplicationData(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getNoteApplicationData', TMessageType.CALL, self._seqid)
    args = getNoteApplicationData_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNoteApplicationData(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNoteApplicationData_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteApplicationData failed: unknown result");

  def getNoteApplicationDataEntry(self, authenticationToken, guid, key):
    """
    Get the value of a single entry in the applicationData map
    for the note identified by GUID.
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - note not found, by GUID</li>
      <li> "NoteAttributes.applicationData.key" - note not found, by key</li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
     - key
    """
    self.send_getNoteApplicationDataEntry(authenticationToken, guid, key)
    return self.recv_getNoteApplicationDataEntry()

  def send_getNoteApplicationDataEntry(self, authenticationToken, guid, key):
    self._oprot.writeMessageBegin('getNoteApplicationDataEntry', TMessageType.CALL, self._seqid)
    args = getNoteApplicationDataEntry_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.key = key
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNoteApplicationDataEntry(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNoteApplicationDataEntry_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteApplicationDataEntry failed: unknown result");

  def setNoteApplicationDataEntry(self, authenticationToken, guid, key, value):
    """
    Update, or create, an entry in the applicationData map for
    the note identified by guid.
    
    Parameters:
     - authenticationToken
     - guid
     - key
     - value
    """
    self.send_setNoteApplicationDataEntry(authenticationToken, guid, key, value)
    return self.recv_setNoteApplicationDataEntry()

  def send_setNoteApplicationDataEntry(self, authenticationToken, guid, key, value):
    self._oprot.writeMessageBegin('setNoteApplicationDataEntry', TMessageType.CALL, self._seqid)
    args = setNoteApplicationDataEntry_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.key = key
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setNoteApplicationDataEntry(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setNoteApplicationDataEntry_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setNoteApplicationDataEntry failed: unknown result");

  def unsetNoteApplicationDataEntry(self, authenticationToken, guid, key):
    """
    Remove an entry identified by 'key' from the applicationData map for
    the note identified by 'guid'. Silently ignores an unset of a
    non-existing key.
    
    Parameters:
     - authenticationToken
     - guid
     - key
    """
    self.send_unsetNoteApplicationDataEntry(authenticationToken, guid, key)
    return self.recv_unsetNoteApplicationDataEntry()

  def send_unsetNoteApplicationDataEntry(self, authenticationToken, guid, key):
    self._oprot.writeMessageBegin('unsetNoteApplicationDataEntry', TMessageType.CALL, self._seqid)
    args = unsetNoteApplicationDataEntry_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.key = key
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_unsetNoteApplicationDataEntry(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = unsetNoteApplicationDataEntry_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "unsetNoteApplicationDataEntry failed: unknown result");

  def getNoteContent(self, authenticationToken, guid):
    """
    Returns XHTML contents of the note with the provided GUID.
    If the Note is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the note to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getNoteContent(authenticationToken, guid)
    return self.recv_getNoteContent()

  def send_getNoteContent(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getNoteContent', TMessageType.CALL, self._seqid)
    args = getNoteContent_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNoteContent(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNoteContent_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteContent failed: unknown result");

  def getNoteSearchText(self, authenticationToken, guid, noteOnly, tokenizeForIndexing):
    """
    Returns a block of the extracted plain text contents of the note with the
    provided GUID.  This text can be indexed for search purposes by a light
    client that doesn't have capabilities to extract all of the searchable
    text content from the note and its resources.
    
    If the Note is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the note to be retrieved.
    
    @param noteOnly
      If true, this will only return the text extracted from the ENML contents
      of the note itself.  If false, this will also include the extracted text
      from any text-bearing resources (PDF, recognized images)
    
    @param tokenizeForIndexing
      If true, this will break the text into cleanly separated and sanitized
      tokens.  If false, this will return the more raw text extraction, with
      its original punctuation, capitalization, spacing, etc.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
     - noteOnly
     - tokenizeForIndexing
    """
    self.send_getNoteSearchText(authenticationToken, guid, noteOnly, tokenizeForIndexing)
    return self.recv_getNoteSearchText()

  def send_getNoteSearchText(self, authenticationToken, guid, noteOnly, tokenizeForIndexing):
    self._oprot.writeMessageBegin('getNoteSearchText', TMessageType.CALL, self._seqid)
    args = getNoteSearchText_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.noteOnly = noteOnly
    args.tokenizeForIndexing = tokenizeForIndexing
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNoteSearchText(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNoteSearchText_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteSearchText failed: unknown result");

  def getResourceSearchText(self, authenticationToken, guid):
    """
    Returns a block of the extracted plain text contents of the resource with
    the provided GUID.  This text can be indexed for search purposes by a light
    client that doesn't have capability to extract all of the searchable
    text content from a resource.
    
    If the Resource is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the resource to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getResourceSearchText(authenticationToken, guid)
    return self.recv_getResourceSearchText()

  def send_getResourceSearchText(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getResourceSearchText', TMessageType.CALL, self._seqid)
    args = getResourceSearchText_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getResourceSearchText(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getResourceSearchText_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceSearchText failed: unknown result");

  def getNoteTagNames(self, authenticationToken, guid):
    """
    Returns a list of the names of the tags for the note with the provided
    guid.  This can be used with authentication to get the tags for a
    user's own note, or can be used without valid authentication to retrieve
    the names of the tags for a note in a public notebook.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getNoteTagNames(authenticationToken, guid)
    return self.recv_getNoteTagNames()

  def send_getNoteTagNames(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getNoteTagNames', TMessageType.CALL, self._seqid)
    args = getNoteTagNames_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNoteTagNames(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNoteTagNames_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteTagNames failed: unknown result");

  def createNote(self, authenticationToken, note):
    """
    Asks the service to make a note with the provided set of information.
    
    @param note
      A Note object containing the desired fields to be populated on
      the service.
    
    @return
      The newly created Note from the service.  The server-side
      GUIDs for the Note and any Resources will be saved in this object.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML content
      </li>
      <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      </li>
      <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
      </li>
      <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      </li>
      <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
      </li>
      <li> DATA_REQUIRED "Resource.data" - resource data body missing
      </li>
      <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      </li>
      <li> LIMIT_REACHED "Note" - at max number per account
      </li>
      <li> LIMIT_REACHED "Note.size" - total note size too large
      </li>
      <li> LIMIT_REACHED "Note.resources" - too many resources on Note
      </li>
      <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
      </li>
      <li> LIMIT_REACHED "Resource.data.size" - resource too large
      </li>
      <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
      </li>
      <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      </li>
      <li> PERMISSION_DENIED "Note.notebookGuid" - NB not owned by user
      </li>
      <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      </li>
      <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
        of the specified tags had an invalid length or pattern
      </li>
      <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
        new tags would exceed the maximum number per account
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.notebookGuid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - note
    """
    self.send_createNote(authenticationToken, note)
    return self.recv_createNote()

  def send_createNote(self, authenticationToken, note):
    self._oprot.writeMessageBegin('createNote', TMessageType.CALL, self._seqid)
    args = createNote_args()
    args.authenticationToken = authenticationToken
    args.note = note
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createNote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createNote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createNote failed: unknown result");

  def updateNote(self, authenticationToken, note):
    """
    Submit a set of changes to a note to the service.  The provided data
    must include the note's guid field for identification. The note's
    title must also be set.
    
    @param note
      A Note object containing the desired fields to be populated on
      the service. With the exception of the note's title and guid, fields
      that are not being changed do not need to be set. If the content is not
      being modified, note.content should be left unset. If the list of
      resources is not being modified, note.resources should be left unset.
    
    @return
      The metadata (no contents) for the Note on the server after the update
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML body
      </li>
      <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
      </li>
      <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      </li>
      <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      </li>
      <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
      </li>
      <li> DATA_REQUIRED "Resource.data" - resource data body missing
      </li>
      <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      </li>
      <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
      </li>
      <li> LIMIT_REACHED "Note.resources" - too many resources on Note
      </li>
      <li> LIMIT_REACHED "Note.size" - total note size too large
      </li>
      <li> LIMIT_REACHED "Resource.data.size" - resource too large
      </li>
      <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
      </li>
      <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      </li>
      <li> PERMISSION_DENIED "Note" - user doesn't own
      </li>
      <li> PERMISSION_DENIED "Note.notebookGuid" - user doesn't own destination
      </li>
      <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      </li>
      <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
        of the specified tags had an invalid length or pattern
      </li>
      <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
        new tags would exceed the maximum number per account
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - note not found, by GUID
      </li>
      <li> "Note.notebookGuid" - if notebookGuid provided, but not found
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - note
    """
    self.send_updateNote(authenticationToken, note)
    return self.recv_updateNote()

  def send_updateNote(self, authenticationToken, note):
    self._oprot.writeMessageBegin('updateNote', TMessageType.CALL, self._seqid)
    args = updateNote_args()
    args.authenticationToken = authenticationToken
    args.note = note
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateNote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateNote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateNote failed: unknown result");

  def deleteNote(self, authenticationToken, guid):
    """
    Moves the note into the trash. The note may still be undeleted, unless it
    is expunged.  This is equivalent to calling updateNote() after setting
    Note.active = false
    
    @param guid
      The GUID of the note to delete.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "Note" - user doesn't have permission to
             update the note.
      </li>
    </ul>
    
    @throws EDAMUserException <ul>
      <li> DATA_CONFLICT "Note.guid" - the note is already deleted
      </li>
    </ul>
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_deleteNote(authenticationToken, guid)
    return self.recv_deleteNote()

  def send_deleteNote(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('deleteNote', TMessageType.CALL, self._seqid)
    args = deleteNote_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteNote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteNote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteNote failed: unknown result");

  def expungeNote(self, authenticationToken, guid):
    """
    Permanently removes a Note, and all of its Resources,
    from the service.
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param guid
      The GUID of the note to delete.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "Note" - user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_expungeNote(authenticationToken, guid)
    return self.recv_expungeNote()

  def send_expungeNote(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('expungeNote', TMessageType.CALL, self._seqid)
    args = expungeNote_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_expungeNote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = expungeNote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeNote failed: unknown result");

  def expungeNotes(self, authenticationToken, noteGuids):
    """
    Permanently removes a list of Notes, and all of their Resources, from
    the service.  This should be invoked with a small number of Note GUIDs
    (e.g. 100 or less) on each call.  To expunge a larger number of notes,
    call this method multiple times.  This should also be used to reduce the
    number of Notes in a notebook before calling expungeNotebook() or
    in the trash before calling expungeInactiveNotes(), since these calls may
    be prohibitively slow if there are more than a few hundred notes.
    If an exception is thrown for any of the GUIDs, then none of the notes
    will be deleted.  I.e. this call can be treated as an atomic transaction.
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param noteGuids
      The list of GUIDs for the Notes to remove.
    
    @return
      The account's updateCount at the end of this operation
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "Note" - user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - noteGuids
    """
    self.send_expungeNotes(authenticationToken, noteGuids)
    return self.recv_expungeNotes()

  def send_expungeNotes(self, authenticationToken, noteGuids):
    self._oprot.writeMessageBegin('expungeNotes', TMessageType.CALL, self._seqid)
    args = expungeNotes_args()
    args.authenticationToken = authenticationToken
    args.noteGuids = noteGuids
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_expungeNotes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = expungeNotes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeNotes failed: unknown result");

  def expungeInactiveNotes(self, authenticationToken):
    """
    Permanently removes all of the Notes that are currently marked as
    inactive.  This is equivalent to "emptying the trash", and these Notes
    will be gone permanently.
    <p/>
    This operation may be relatively slow if the account contains a large
    number of inactive Notes.
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @return
       The number of notes that were expunged.
    
    Parameters:
     - authenticationToken
    """
    self.send_expungeInactiveNotes(authenticationToken)
    return self.recv_expungeInactiveNotes()

  def send_expungeInactiveNotes(self, authenticationToken):
    self._oprot.writeMessageBegin('expungeInactiveNotes', TMessageType.CALL, self._seqid)
    args = expungeInactiveNotes_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_expungeInactiveNotes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = expungeInactiveNotes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeInactiveNotes failed: unknown result");

  def copyNote(self, authenticationToken, noteGuid, toNotebookGuid):
    """
    Performs a deep copy of the Note with the provided GUID 'noteGuid' into
    the Notebook with the provided GUID 'toNotebookGuid'.
    The caller must be the owner of both the Note and the Notebook.
    This creates a new Note in the destination Notebook with new content and
    Resources that match all of the content and Resources from the original
    Note, but with new GUID identifiers.
    The original Note is not modified by this operation.
    The copied note is considered as an "upload" for the purpose of upload
    transfer limit calculation, so its size is added to the upload count for
    the owner.
    
    @param noteGuid
      The GUID of the Note to copy.
    
    @param toNotebookGuid
      The GUID of the Notebook that should receive the new Note.
    
    @return
      The metadata for the new Note that was created.  This will include the
      new GUID for this Note (and any copied Resources), but will not include
      the content body or the binary bodies of any Resources.
    
    @throws EDAMUserException <ul>
      <li> LIMIT_REACHED "Note" - at max number per account
      </li>
      <li> PERMISSION_DENIED "Notebook.guid" - destination not owned by user
      </li>
      <li> PERMISSION_DENIED "Note" - user doesn't own
      </li>
      <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - noteGuid
     - toNotebookGuid
    """
    self.send_copyNote(authenticationToken, noteGuid, toNotebookGuid)
    return self.recv_copyNote()

  def send_copyNote(self, authenticationToken, noteGuid, toNotebookGuid):
    self._oprot.writeMessageBegin('copyNote', TMessageType.CALL, self._seqid)
    args = copyNote_args()
    args.authenticationToken = authenticationToken
    args.noteGuid = noteGuid
    args.toNotebookGuid = toNotebookGuid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_copyNote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = copyNote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "copyNote failed: unknown result");

  def listNoteVersions(self, authenticationToken, noteGuid):
    """
    Returns a list of the prior versions of a particular note that are
    saved within the service.  These prior versions are stored to provide a
    recovery from unintentional removal of content from a note. The identifiers
    that are returned by this call can be used with getNoteVersion to retrieve
    the previous note.
    The identifiers will be listed from the most recent versions to the oldest.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - noteGuid
    """
    self.send_listNoteVersions(authenticationToken, noteGuid)
    return self.recv_listNoteVersions()

  def send_listNoteVersions(self, authenticationToken, noteGuid):
    self._oprot.writeMessageBegin('listNoteVersions', TMessageType.CALL, self._seqid)
    args = listNoteVersions_args()
    args.authenticationToken = authenticationToken
    args.noteGuid = noteGuid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listNoteVersions(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listNoteVersions_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listNoteVersions failed: unknown result");

  def getNoteVersion(self, authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData):
    """
    This can be used to retrieve a previous version of a Note after it has been
    updated within the service.  The caller must identify the note (via its
    guid) and the version (via the updateSequenceNumber of that version).
    to find a listing of the stored version USNs for a note, call
    listNoteVersions.
    This call is only available for notes in Premium accounts.  (I.e. access
    to past versions of Notes is a Premium-only feature.)
    
    @param guid
      The GUID of the note to be retrieved.
    
    @param updateSequenceNum
      The USN of the version of the note that is being retrieved
    
    @param withResourcesData
      If true, any Resource elements in this Note will include the binary
      contents of their 'data' field's body.
    
    @param withResourcesRecognition
      If true, any Resource elements will include the binary contents of the
      'recognition' field's body if recognition data is present.
    
    @param withResourcesAlternateData
      If true, any Resource elements in this Note will include the binary
      contents of their 'alternateData' fields' body, if an alternate form
      is present.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
      <li> PERMISSION_DENIED "updateSequenceNum" -
        The account isn't permitted to access previous versions of notes.
        (i.e. this is a Free account.)
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
      <li> "Note.updateSequenceNumber" - the Note doesn't have a version with
         the corresponding USN.
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - noteGuid
     - updateSequenceNum
     - withResourcesData
     - withResourcesRecognition
     - withResourcesAlternateData
    """
    self.send_getNoteVersion(authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData)
    return self.recv_getNoteVersion()

  def send_getNoteVersion(self, authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData):
    self._oprot.writeMessageBegin('getNoteVersion', TMessageType.CALL, self._seqid)
    args = getNoteVersion_args()
    args.authenticationToken = authenticationToken
    args.noteGuid = noteGuid
    args.updateSequenceNum = updateSequenceNum
    args.withResourcesData = withResourcesData
    args.withResourcesRecognition = withResourcesRecognition
    args.withResourcesAlternateData = withResourcesAlternateData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNoteVersion(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNoteVersion_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteVersion failed: unknown result");

  def getResource(self, authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData):
    """
    Returns the current state of the resource in the service with the
    provided GUID.
    If the Resource is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).  Only the
    keys for the applicationData will be returned.
    
    @param guid
      The GUID of the resource to be retrieved.
    
    @param withData
      If true, the Resource will include the binary contents of the
      'data' field's body.
    
    @param withRecognition
      If true, the Resource will include the binary contents of the
      'recognition' field's body if recognition data is present.
    
    @param withAttributes
      If true, the Resource will include the attributes
    
    @param withAlternateData
      If true, the Resource will include the binary contents of the
      'alternateData' field's body, if an alternate form is present.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
     - withData
     - withRecognition
     - withAttributes
     - withAlternateData
    """
    self.send_getResource(authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData)
    return self.recv_getResource()

  def send_getResource(self, authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData):
    self._oprot.writeMessageBegin('getResource', TMessageType.CALL, self._seqid)
    args = getResource_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.withData = withData
    args.withRecognition = withRecognition
    args.withAttributes = withAttributes
    args.withAlternateData = withAlternateData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getResource(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getResource_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getResource failed: unknown result");

  def getResourceApplicationData(self, authenticationToken, guid):
    """
    Get all of the application data for the Resource identified by GUID,
    with values returned within the LazyMap fullMap field.
    If there are no applicationData entries, then a LazyMap
    with an empty fullMap will be returned. If your application
    only needs to fetch its own applicationData entry, use
    getResourceApplicationDataEntry instead.
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getResourceApplicationData(authenticationToken, guid)
    return self.recv_getResourceApplicationData()

  def send_getResourceApplicationData(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getResourceApplicationData', TMessageType.CALL, self._seqid)
    args = getResourceApplicationData_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getResourceApplicationData(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getResourceApplicationData_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceApplicationData failed: unknown result");

  def getResourceApplicationDataEntry(self, authenticationToken, guid, key):
    """
    Get the value of a single entry in the applicationData map
    for the Resource identified by GUID.
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - Resource not found, by GUID</li>
      <li> "ResourceAttributes.applicationData.key" - Resource not found, by key</li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
     - key
    """
    self.send_getResourceApplicationDataEntry(authenticationToken, guid, key)
    return self.recv_getResourceApplicationDataEntry()

  def send_getResourceApplicationDataEntry(self, authenticationToken, guid, key):
    self._oprot.writeMessageBegin('getResourceApplicationDataEntry', TMessageType.CALL, self._seqid)
    args = getResourceApplicationDataEntry_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.key = key
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getResourceApplicationDataEntry(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getResourceApplicationDataEntry_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceApplicationDataEntry failed: unknown result");

  def setResourceApplicationDataEntry(self, authenticationToken, guid, key, value):
    """
    Update, or create, an entry in the applicationData map for
    the Resource identified by guid.
    
    Parameters:
     - authenticationToken
     - guid
     - key
     - value
    """
    self.send_setResourceApplicationDataEntry(authenticationToken, guid, key, value)
    return self.recv_setResourceApplicationDataEntry()

  def send_setResourceApplicationDataEntry(self, authenticationToken, guid, key, value):
    self._oprot.writeMessageBegin('setResourceApplicationDataEntry', TMessageType.CALL, self._seqid)
    args = setResourceApplicationDataEntry_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.key = key
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setResourceApplicationDataEntry(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setResourceApplicationDataEntry_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setResourceApplicationDataEntry failed: unknown result");

  def unsetResourceApplicationDataEntry(self, authenticationToken, guid, key):
    """
    Remove an entry identified by 'key' from the applicationData map for
    the Resource identified by 'guid'.
    
    Parameters:
     - authenticationToken
     - guid
     - key
    """
    self.send_unsetResourceApplicationDataEntry(authenticationToken, guid, key)
    return self.recv_unsetResourceApplicationDataEntry()

  def send_unsetResourceApplicationDataEntry(self, authenticationToken, guid, key):
    self._oprot.writeMessageBegin('unsetResourceApplicationDataEntry', TMessageType.CALL, self._seqid)
    args = unsetResourceApplicationDataEntry_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.key = key
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_unsetResourceApplicationDataEntry(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = unsetResourceApplicationDataEntry_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "unsetResourceApplicationDataEntry failed: unknown result");

  def updateResource(self, authenticationToken, resource):
    """
    Submit a set of changes to a resource to the service.  This can be used
    to update the meta-data about the resource, but cannot be used to change
    the binary contents of the resource (including the length and hash).  These
    cannot be changed directly without creating a new resource and removing the
    old one via updateNote.
    
    @param resource
      A Resource object containing the desired fields to be populated on
      the service.  The service will attempt to update the resource with the
      following fields from the client:
      <ul>
         <li>guid:  must be provided to identify the resource
         </li>
         <li>mime
         </li>
         <li>width
         </li>
         <li>height
         </li>
         <li>duration
         </li>
         <li>attributes:  optional.  if present, the set of attributes will
              be replaced.
         </li>
      </ul>
    
    @return
      The Update Sequence Number of the resource after the changes have been
      applied.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      </li>
      <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      </li>
      <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - resource
    """
    self.send_updateResource(authenticationToken, resource)
    return self.recv_updateResource()

  def send_updateResource(self, authenticationToken, resource):
    self._oprot.writeMessageBegin('updateResource', TMessageType.CALL, self._seqid)
    args = updateResource_args()
    args.authenticationToken = authenticationToken
    args.resource = resource
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateResource(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateResource_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateResource failed: unknown result");

  def getResourceData(self, authenticationToken, guid):
    """
    Returns binary data of the resource with the provided GUID.  For
    example, if this were an image resource, this would contain the
    raw bits of the image.
    If the Resource is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the resource to be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getResourceData(authenticationToken, guid)
    return self.recv_getResourceData()

  def send_getResourceData(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getResourceData', TMessageType.CALL, self._seqid)
    args = getResourceData_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getResourceData(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getResourceData_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceData failed: unknown result");

  def getResourceByHash(self, authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData):
    """
    Returns the current state of a resource, referenced by containing
    note GUID and resource content hash.
    
    @param noteGuid
      The GUID of the note that holds the resource to be retrieved.
    
    @param contentHash
      The MD5 checksum of the resource within that note.
    
    @param withData
      If true, the Resource will include the binary contents of the
      'data' field's body.
    
    @param withRecognition
      If true, the Resource will include the binary contents of the
      'recognition' field's body.
    
    @param withAlternateData
      If true, the Resource will include the binary contents of the
      'alternateData' field's body, if an alternate form is present.
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "Note.guid" - noteGuid param missing
      </li>
      <li> DATA_REQUIRED "Note.contentHash" - contentHash param missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note" - not found, by guid
      </li>
      <li> "Resource" - not found, by hash
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - noteGuid
     - contentHash
     - withData
     - withRecognition
     - withAlternateData
    """
    self.send_getResourceByHash(authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData)
    return self.recv_getResourceByHash()

  def send_getResourceByHash(self, authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData):
    self._oprot.writeMessageBegin('getResourceByHash', TMessageType.CALL, self._seqid)
    args = getResourceByHash_args()
    args.authenticationToken = authenticationToken
    args.noteGuid = noteGuid
    args.contentHash = contentHash
    args.withData = withData
    args.withRecognition = withRecognition
    args.withAlternateData = withAlternateData
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getResourceByHash(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getResourceByHash_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceByHash failed: unknown result");

  def getResourceRecognition(self, authenticationToken, guid):
    """
    Returns the binary contents of the recognition index for the resource
    with the provided GUID.  If the caller asks about a resource that has
    no recognition data, this will throw EDAMNotFoundException.
    If the Resource is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the resource whose recognition data should be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
      <li> "Resource.recognition" - resource has no recognition
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getResourceRecognition(authenticationToken, guid)
    return self.recv_getResourceRecognition()

  def send_getResourceRecognition(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getResourceRecognition', TMessageType.CALL, self._seqid)
    args = getResourceRecognition_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getResourceRecognition(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getResourceRecognition_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceRecognition failed: unknown result");

  def getResourceAlternateData(self, authenticationToken, guid):
    """
    If the Resource with the provided GUID has an alternate data representation
    (indicated via the Resource.alternateData field), then this request can
    be used to retrieve the binary contents of that alternate data file.
    If the caller asks about a resource that has no alternate data form, this
    will throw EDAMNotFoundException.
    
    @param guid
       The GUID of the resource whose recognition data should be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
      <li> "Resource.alternateData" - resource has no recognition
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getResourceAlternateData(authenticationToken, guid)
    return self.recv_getResourceAlternateData()

  def send_getResourceAlternateData(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getResourceAlternateData', TMessageType.CALL, self._seqid)
    args = getResourceAlternateData_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getResourceAlternateData(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getResourceAlternateData_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceAlternateData failed: unknown result");

  def getResourceAttributes(self, authenticationToken, guid):
    """
    Returns the set of attributes for the Resource with the provided GUID.
    If the Resource is found in a public notebook, the authenticationToken
    will be ignored (so it could be an empty string).
    
    @param guid
      The GUID of the resource whose attributes should be retrieved.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Resource.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_getResourceAttributes(authenticationToken, guid)
    return self.recv_getResourceAttributes()

  def send_getResourceAttributes(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('getResourceAttributes', TMessageType.CALL, self._seqid)
    args = getResourceAttributes_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getResourceAttributes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getResourceAttributes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getResourceAttributes failed: unknown result");

  def getAccountSize(self, authenticationToken):
    """
    @deprecated -
      This function is deprecated, and should no longer be used.  This will
      always return a value of '0'.
    
    Parameters:
     - authenticationToken
    """
    self.send_getAccountSize(authenticationToken)
    return self.recv_getAccountSize()

  def send_getAccountSize(self, authenticationToken):
    self._oprot.writeMessageBegin('getAccountSize', TMessageType.CALL, self._seqid)
    args = getAccountSize_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getAccountSize(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getAccountSize_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getAccountSize failed: unknown result");

  def getAds(self, authenticationToken, adParameters):
    """
    Clients should make this call once per day to receive a bundle of ads that
    will be displayed for the subsequent 24 hour period.
    <p/>
    NOTE: This function is not available to third party applications.
    
    @param adParameters
      A set of parameters that help the service determine which ads to return.
    
    Parameters:
     - authenticationToken
     - adParameters
    """
    self.send_getAds(authenticationToken, adParameters)
    return self.recv_getAds()

  def send_getAds(self, authenticationToken, adParameters):
    self._oprot.writeMessageBegin('getAds', TMessageType.CALL, self._seqid)
    args = getAds_args()
    args.authenticationToken = authenticationToken
    args.adParameters = adParameters
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getAds(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getAds_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getAds failed: unknown result");

  def getRandomAd(self, authenticationToken, adParameters):
    """
    A thin client should make this call to retrieve a single random ad for
    immediate display.
    <p/>
    NOTE: This function is not available to third party applications.
    
    @param adParameters
      A set of parameters to help the service determine which ad to return.
      The 'impression' field should either be absent (if no ads have been
      displayed previously), or else it should contain the identifier for
      the most recently-displayed ad so that the service can give a different
      ad.
    
    Parameters:
     - authenticationToken
     - adParameters
    """
    self.send_getRandomAd(authenticationToken, adParameters)
    return self.recv_getRandomAd()

  def send_getRandomAd(self, authenticationToken, adParameters):
    self._oprot.writeMessageBegin('getRandomAd', TMessageType.CALL, self._seqid)
    args = getRandomAd_args()
    args.authenticationToken = authenticationToken
    args.adParameters = adParameters
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getRandomAd(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getRandomAd_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getRandomAd failed: unknown result");

  def getPublicNotebook(self, userId, publicUri):
    """
    Looks for a user account with the provided userId on this NoteStore
    shard and determines whether that account contains a public notebook
    with the given URI.  If the account is not found, or no public notebook
    exists with this URI, this will throw an EDAMNotFoundException,
    otherwise this will return the information for that Notebook.
    
    @param userId
       The numeric identifier for the user who owns the public notebook.
       To find this value based on a username string, you can invoke
       UserStore.getPublicUserInfo
    
    @param publicUri
       The uri string for the public notebook, from Notebook.publishing.uri.
       If a notebook is visible on the web with a full URL like
       http://www.evernote.com/pub/ensupport/faq
       Then 'ensupport' is the username and 'faq' is the uri.
    
    @throws EDAMNotFoundException <ul>
      <li> "Publishing.uri" - not found, by URI
      </li>
    </ul>
    
    Parameters:
     - userId
     - publicUri
    """
    self.send_getPublicNotebook(userId, publicUri)
    return self.recv_getPublicNotebook()

  def send_getPublicNotebook(self, userId, publicUri):
    self._oprot.writeMessageBegin('getPublicNotebook', TMessageType.CALL, self._seqid)
    args = getPublicNotebook_args()
    args.userId = userId
    args.publicUri = publicUri
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getPublicNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getPublicNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.systemException is not None:
      raise result.systemException
    if result.notFoundException is not None:
      raise result.notFoundException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getPublicNotebook failed: unknown result");

  def createSharedNotebook(self, authenticationToken, sharedNotebook):
    """
    Used to construct a shared notebook object. The constructed notebook will
    contain a "share key" which serve as a unique identifer and access token
    for a user to access the notebook of the shared notebook owner.
    
    @param sharedNotebook
      An shared notebook object populated with the email address of the share
      recipient, the notebook guid and the access permissions. All other
      attributes of the shared object are ignored.
    @return
      The fully populated SharedNotebook object including the server assigned
      share id and shareKey which can both the used to uniquely identify the
      SharedNotebook.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "SharedNotebook.email" - if the  email was not valid
      </li>
      </ul>
    @throws EDAMNotFoundException <ul>
      <li> Notebook.guid - if the notebookGuid is not a valid guid for the user
      </li>
      </ul>
    
    Parameters:
     - authenticationToken
     - sharedNotebook
    """
    self.send_createSharedNotebook(authenticationToken, sharedNotebook)
    return self.recv_createSharedNotebook()

  def send_createSharedNotebook(self, authenticationToken, sharedNotebook):
    self._oprot.writeMessageBegin('createSharedNotebook', TMessageType.CALL, self._seqid)
    args = createSharedNotebook_args()
    args.authenticationToken = authenticationToken
    args.sharedNotebook = sharedNotebook
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createSharedNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createSharedNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createSharedNotebook failed: unknown result");

  def sendMessageToSharedNotebookMembers(self, authenticationToken, notebookGuid, messageText, recipients):
    """
    Send a reminder message to some or all of the email addresses that a notebook has been
    shared with. The message includes the current link to view the notebook.
    @param authenticationToken
      The auth token of the user with permissions to share the notebook
    @param notebookGuid
      The guid of the shared notebook
    @param messageText
     User provided text to include in the email
    @param recipients
     The email addresses of the recipients. If this list is empty then all of the
     users that the notebook has been shared with are emailed.
     If an email address doesn't correspond to share invite members then that address
     is ignored.
    @return
     The number of messages sent
    @throws EDAMUserException <ul>
      <li> LIMIT_REACHED "(recipients)" -
        The email can't be sent because this would exceed the user's daily
        email limit.
      </li>
      <li> PERMISSION_DENIED "Notebook" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Notebook.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - notebookGuid
     - messageText
     - recipients
    """
    self.send_sendMessageToSharedNotebookMembers(authenticationToken, notebookGuid, messageText, recipients)
    return self.recv_sendMessageToSharedNotebookMembers()

  def send_sendMessageToSharedNotebookMembers(self, authenticationToken, notebookGuid, messageText, recipients):
    self._oprot.writeMessageBegin('sendMessageToSharedNotebookMembers', TMessageType.CALL, self._seqid)
    args = sendMessageToSharedNotebookMembers_args()
    args.authenticationToken = authenticationToken
    args.notebookGuid = notebookGuid
    args.messageText = messageText
    args.recipients = recipients
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sendMessageToSharedNotebookMembers(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sendMessageToSharedNotebookMembers_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sendMessageToSharedNotebookMembers failed: unknown result");

  def listSharedNotebooks(self, authenticationToken):
    """
    Lists the collection of shared notebooks for all notebooks in the
    users account.
    
    @return
     The list of all SharedNotebooks for the user
    
    Parameters:
     - authenticationToken
    """
    self.send_listSharedNotebooks(authenticationToken)
    return self.recv_listSharedNotebooks()

  def send_listSharedNotebooks(self, authenticationToken):
    self._oprot.writeMessageBegin('listSharedNotebooks', TMessageType.CALL, self._seqid)
    args = listSharedNotebooks_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listSharedNotebooks(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listSharedNotebooks_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listSharedNotebooks failed: unknown result");

  def expungeSharedNotebooks(self, authenticationToken, sharedNotebookIds):
    """
    Expunges the SharedNotebooks in the user's account using the
    SharedNotebook.id as the identifier.
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param
      sharedNotebookIds - a list of ShardNotebook.id longs identifying the
          objects to delete permanently.
    
    @return
      The account's update sequence number.
    
    Parameters:
     - authenticationToken
     - sharedNotebookIds
    """
    self.send_expungeSharedNotebooks(authenticationToken, sharedNotebookIds)
    return self.recv_expungeSharedNotebooks()

  def send_expungeSharedNotebooks(self, authenticationToken, sharedNotebookIds):
    self._oprot.writeMessageBegin('expungeSharedNotebooks', TMessageType.CALL, self._seqid)
    args = expungeSharedNotebooks_args()
    args.authenticationToken = authenticationToken
    args.sharedNotebookIds = sharedNotebookIds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_expungeSharedNotebooks(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = expungeSharedNotebooks_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeSharedNotebooks failed: unknown result");

  def createLinkedNotebook(self, authenticationToken, linkedNotebook):
    """
    Asks the service to make a linked notebook with the provided name, username
    of the owner and identifiers provided. A linked notebook can be either a
    link to a public notebook or to a private shared notebook.
    
    @param linkedNotebook
      The desired fields for the linked notebook must be provided on this
      object.  The name of the linked notebook must be set. Either a username
      uri or a shard id and share key must be provided otherwise a
      EDAMUserException is thrown.
    
    @return
      The newly created LinkedNotebook.  The server-side id will be
      saved in this object's 'id' field.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid length or pattern
      </li>
      <li> BAD_DATA_FORMAT "LinkedNotebook.username" - bad username format
      </li>
      <li> BAD_DATA_FORMAT "LinkedNotebook.uri" -
        if public notebook set but bad uri
      </li>
      <li> BAD_DATA_FORMAT "LinkedNotebook.shareKey" -
        if private notebook set but bad shareKey
      </li>
      <li> DATA_REQUIRED "LinkedNotebook.shardId" -
        if private notebook but shard id not provided
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - linkedNotebook
    """
    self.send_createLinkedNotebook(authenticationToken, linkedNotebook)
    return self.recv_createLinkedNotebook()

  def send_createLinkedNotebook(self, authenticationToken, linkedNotebook):
    self._oprot.writeMessageBegin('createLinkedNotebook', TMessageType.CALL, self._seqid)
    args = createLinkedNotebook_args()
    args.authenticationToken = authenticationToken
    args.linkedNotebook = linkedNotebook
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createLinkedNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createLinkedNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createLinkedNotebook failed: unknown result");

  def updateLinkedNotebook(self, authenticationToken, linkedNotebook):
    """
    @param linkedNotebook
      Updates the name of a linked notebook.
    
    @return
      The Update Sequence Number for this change within the account.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid length or pattern
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - linkedNotebook
    """
    self.send_updateLinkedNotebook(authenticationToken, linkedNotebook)
    return self.recv_updateLinkedNotebook()

  def send_updateLinkedNotebook(self, authenticationToken, linkedNotebook):
    self._oprot.writeMessageBegin('updateLinkedNotebook', TMessageType.CALL, self._seqid)
    args = updateLinkedNotebook_args()
    args.authenticationToken = authenticationToken
    args.linkedNotebook = linkedNotebook
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateLinkedNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateLinkedNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateLinkedNotebook failed: unknown result");

  def listLinkedNotebooks(self, authenticationToken):
    """
    Returns a list of linked notebooks
    
    Parameters:
     - authenticationToken
    """
    self.send_listLinkedNotebooks(authenticationToken)
    return self.recv_listLinkedNotebooks()

  def send_listLinkedNotebooks(self, authenticationToken):
    self._oprot.writeMessageBegin('listLinkedNotebooks', TMessageType.CALL, self._seqid)
    args = listLinkedNotebooks_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listLinkedNotebooks(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listLinkedNotebooks_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listLinkedNotebooks failed: unknown result");

  def expungeLinkedNotebook(self, authenticationToken, guid):
    """
    Permanently expunges the linked notebook from the account.
    <p/>
    NOTE: This function is not available to third party applications.
    Calls will result in an EDAMUserException with the error code
    PERMISSION_DENIED.
    
    @param guid
      The LinkedNotebook.guid field of the LinkedNotebook to permanently remove
      from the account.
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_expungeLinkedNotebook(authenticationToken, guid)
    return self.recv_expungeLinkedNotebook()

  def send_expungeLinkedNotebook(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('expungeLinkedNotebook', TMessageType.CALL, self._seqid)
    args = expungeLinkedNotebook_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_expungeLinkedNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = expungeLinkedNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "expungeLinkedNotebook failed: unknown result");

  def authenticateToSharedNotebook(self, shareKey, authenticationToken):
    """
    Asks the service to produce an authentication token that can be used to
    access the contents of a shared notebook from someone else's account.
    This authenticationToken can be used with the various other NoteStore
    calls to find and retrieve notes, and if the permissions in the shared
    notebook are sufficient, to make changes to the contents of the notebook.
    
    @param shareKey
      The 'shareKey' identifier from the SharedNotebook that was granted to
      some recipient.  This string internally encodes the notebook identifier
      and a security signature.
    
    @param authenticationToken
      If a non-empty string is provided, this is the full user-based
      authentication token that identifies the user who is currently logged in
      and trying to access the shared notebook.  This may be required if the
      notebook was created with 'requireLogin'.
      If this string is empty, the service will attempt to authenticate to the
      shared notebook without any logged in user.
    
    @throws EDAMSystemException <ul>
      <li> BAD_DATA_FORMAT "shareKey" - invalid shareKey string
      </li>
      <li> INVALID_AUTH "shareKey" - bad signature on shareKey string
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "SharedNotebook.id" - the shared notebook no longer exists
      </li>
    </ul>
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "authenticationToken" - the share requires login, and
             no valid authentication token was provided.
      </li>
      <li> PERMISSION_DENIED "SharedNotebook.username" - share requires login,
             and another username has already been bound to this notebook.
      </li>
    </ul>
    
    Parameters:
     - shareKey
     - authenticationToken
    """
    self.send_authenticateToSharedNotebook(shareKey, authenticationToken)
    return self.recv_authenticateToSharedNotebook()

  def send_authenticateToSharedNotebook(self, shareKey, authenticationToken):
    self._oprot.writeMessageBegin('authenticateToSharedNotebook', TMessageType.CALL, self._seqid)
    args = authenticateToSharedNotebook_args()
    args.shareKey = shareKey
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_authenticateToSharedNotebook(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = authenticateToSharedNotebook_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticateToSharedNotebook failed: unknown result");

  def getSharedNotebookByAuth(self, authenticationToken):
    """
    This function is used to retrieve extended information about a shared
    notebook by a guest who has already authenticated to access that notebook.
    This requires an 'authenticationToken' parameter which should be the
    resut of a call to authenticateToSharedNotebook(...).
    I.e. this is the token that gives access to the particular shared notebook
    in someone else's account -- it's not the authenticationToken for the
    owner of the notebook itself.
    
    @param authenticationToken
      Should be the authentication token retrieved from the reply of
      authenticateToSharedNotebook(), proving access to a particular shared
      notebook.
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "authenticationToken" -
             authentication token doesn't correspond to a valid shared notebook
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "SharedNotebook.id" - the shared notebook no longer exists
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
    """
    self.send_getSharedNotebookByAuth(authenticationToken)
    return self.recv_getSharedNotebookByAuth()

  def send_getSharedNotebookByAuth(self, authenticationToken):
    self._oprot.writeMessageBegin('getSharedNotebookByAuth', TMessageType.CALL, self._seqid)
    args = getSharedNotebookByAuth_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSharedNotebookByAuth(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSharedNotebookByAuth_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSharedNotebookByAuth failed: unknown result");

  def emailNote(self, authenticationToken, parameters):
    """
    Attempts to send a single note to one or more email recipients.
    
    @param authenticationToken
       The note will be sent as the user logged in via this token, using that
       user's registered email address.  If the authenticated user doesn't
       have permission to read that note, the emailing will fail.
    
    @param parameters
       The note must be specified either by GUID (in which case it will be
       sent using the existing data in the service), or else the full Note
       must be passed to this call.  This also specifies the additional
       email fields that will be used in the email.
    
    @throws EDAMUserException <ul>
      <li> LIMIT_REACHED "NoteEmailParameters.toAddresses" -
        The email can't be sent because this would exceed the user's daily
        email limit.
      </li>
      <li> BAD_DATA_FORMAT "(email address)" -
        email address malformed
      </li>
      <li> DATA_REQUIRED "NoteEmailParameters.toAddresses" -
        if there are no To: or Cc: addresses provided.
      </li>
      <li> DATA_REQUIRED "Note.title" -
        if the caller provides a Note parameter with no title
      </li>
      <li> DATA_REQUIRED "Note.content" -
        if the caller provides a Note parameter with no content
      </li>
      <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      </li>
      <li> DATA_REQUIRED "NoteEmailParameters.note" -
        if no guid or note provided
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - parameters
    """
    self.send_emailNote(authenticationToken, parameters)
    self.recv_emailNote()

  def send_emailNote(self, authenticationToken, parameters):
    self._oprot.writeMessageBegin('emailNote', TMessageType.CALL, self._seqid)
    args = emailNote_args()
    args.authenticationToken = authenticationToken
    args.parameters = parameters
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_emailNote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = emailNote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    return

  def shareNote(self, authenticationToken, guid):
    """
    If this note is not already shared (via its own direct URL), then this
    will start sharing that note.
    This will return the secret "Note Key" for this note that
    can currently be used in conjunction with the Note's GUID to gain direct
    read-only access to the Note.
    If the note is already shared, then this won't make any changes to the
    note, and the existing "Note Key" will be returned.  The only way to change
    the Note Key for an existing note is to stopSharingNote first, and then
    call this function.
    
    @param guid
      The GUID of the note to be shared.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_shareNote(authenticationToken, guid)
    return self.recv_shareNote()

  def send_shareNote(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('shareNote', TMessageType.CALL, self._seqid)
    args = shareNote_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_shareNote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = shareNote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "shareNote failed: unknown result");

  def stopSharingNote(self, authenticationToken, guid):
    """
    If this note is not already shared then this will stop sharing that note
    and invalidate its "Note Key", so any existing URLs to access that Note
    will stop working.
    If the Note is not shared, then this function will do nothing.
    
    @param guid
      The GUID of the note to be un-shared.
    
    @throws EDAMUserException <ul>
      <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      </li>
      <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "Note.guid" - not found, by GUID
      </li>
    </ul>
    
    Parameters:
     - authenticationToken
     - guid
    """
    self.send_stopSharingNote(authenticationToken, guid)
    self.recv_stopSharingNote()

  def send_stopSharingNote(self, authenticationToken, guid):
    self._oprot.writeMessageBegin('stopSharingNote', TMessageType.CALL, self._seqid)
    args = stopSharingNote_args()
    args.authenticationToken = authenticationToken
    args.guid = guid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_stopSharingNote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = stopSharingNote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    return

  def authenticateToSharedNote(self, guid, noteKey):
    """
    Asks the service to produce an authentication token that can be used to
    access the contents of a single Note which was individually shared
    from someone's account.
    This authenticationToken can be used with the various other NoteStore
    calls to find and retrieve the Note and its directly-referenced children.
    
    @param guid
      The GUID identifying this Note on this shard.
    
    @param noteKey
      The 'noteKey' identifier from the Note that was originally created via
      a call to shareNote() and then given to a recipient to access.
    
    @throws EDAMUserException <ul>
      <li> PERMISSION_DENIED "Note" - the Note with that GUID is either not
        shared, or the noteKey doesn't match the current key for this note
      </li>
    </ul>
    
    @throws EDAMNotFoundException <ul>
      <li> "guid" - the note with that GUID is not found
      </li>
    </ul>
    
    Parameters:
     - guid
     - noteKey
    """
    self.send_authenticateToSharedNote(guid, noteKey)
    return self.recv_authenticateToSharedNote()

  def send_authenticateToSharedNote(self, guid, noteKey):
    self._oprot.writeMessageBegin('authenticateToSharedNote', TMessageType.CALL, self._seqid)
    args = authenticateToSharedNote_args()
    args.guid = guid
    args.noteKey = noteKey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_authenticateToSharedNote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = authenticateToSharedNote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticateToSharedNote failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["getSyncState"] = Processor.process_getSyncState
    self._processMap["getSyncStateWithMetrics"] = Processor.process_getSyncStateWithMetrics
    self._processMap["getSyncChunk"] = Processor.process_getSyncChunk
    self._processMap["getFilteredSyncChunk"] = Processor.process_getFilteredSyncChunk
    self._processMap["getLinkedNotebookSyncState"] = Processor.process_getLinkedNotebookSyncState
    self._processMap["getLinkedNotebookSyncChunk"] = Processor.process_getLinkedNotebookSyncChunk
    self._processMap["listNotebooks"] = Processor.process_listNotebooks
    self._processMap["getNotebook"] = Processor.process_getNotebook
    self._processMap["getDefaultNotebook"] = Processor.process_getDefaultNotebook
    self._processMap["createNotebook"] = Processor.process_createNotebook
    self._processMap["updateNotebook"] = Processor.process_updateNotebook
    self._processMap["expungeNotebook"] = Processor.process_expungeNotebook
    self._processMap["listTags"] = Processor.process_listTags
    self._processMap["listTagsByNotebook"] = Processor.process_listTagsByNotebook
    self._processMap["getTag"] = Processor.process_getTag
    self._processMap["createTag"] = Processor.process_createTag
    self._processMap["updateTag"] = Processor.process_updateTag
    self._processMap["untagAll"] = Processor.process_untagAll
    self._processMap["expungeTag"] = Processor.process_expungeTag
    self._processMap["listSearches"] = Processor.process_listSearches
    self._processMap["getSearch"] = Processor.process_getSearch
    self._processMap["createSearch"] = Processor.process_createSearch
    self._processMap["updateSearch"] = Processor.process_updateSearch
    self._processMap["expungeSearch"] = Processor.process_expungeSearch
    self._processMap["findNotes"] = Processor.process_findNotes
    self._processMap["findNoteOffset"] = Processor.process_findNoteOffset
    self._processMap["findNotesMetadata"] = Processor.process_findNotesMetadata
    self._processMap["findNoteCounts"] = Processor.process_findNoteCounts
    self._processMap["getNote"] = Processor.process_getNote
    self._processMap["getNoteApplicationData"] = Processor.process_getNoteApplicationData
    self._processMap["getNoteApplicationDataEntry"] = Processor.process_getNoteApplicationDataEntry
    self._processMap["setNoteApplicationDataEntry"] = Processor.process_setNoteApplicationDataEntry
    self._processMap["unsetNoteApplicationDataEntry"] = Processor.process_unsetNoteApplicationDataEntry
    self._processMap["getNoteContent"] = Processor.process_getNoteContent
    self._processMap["getNoteSearchText"] = Processor.process_getNoteSearchText
    self._processMap["getResourceSearchText"] = Processor.process_getResourceSearchText
    self._processMap["getNoteTagNames"] = Processor.process_getNoteTagNames
    self._processMap["createNote"] = Processor.process_createNote
    self._processMap["updateNote"] = Processor.process_updateNote
    self._processMap["deleteNote"] = Processor.process_deleteNote
    self._processMap["expungeNote"] = Processor.process_expungeNote
    self._processMap["expungeNotes"] = Processor.process_expungeNotes
    self._processMap["expungeInactiveNotes"] = Processor.process_expungeInactiveNotes
    self._processMap["copyNote"] = Processor.process_copyNote
    self._processMap["listNoteVersions"] = Processor.process_listNoteVersions
    self._processMap["getNoteVersion"] = Processor.process_getNoteVersion
    self._processMap["getResource"] = Processor.process_getResource
    self._processMap["getResourceApplicationData"] = Processor.process_getResourceApplicationData
    self._processMap["getResourceApplicationDataEntry"] = Processor.process_getResourceApplicationDataEntry
    self._processMap["setResourceApplicationDataEntry"] = Processor.process_setResourceApplicationDataEntry
    self._processMap["unsetResourceApplicationDataEntry"] = Processor.process_unsetResourceApplicationDataEntry
    self._processMap["updateResource"] = Processor.process_updateResource
    self._processMap["getResourceData"] = Processor.process_getResourceData
    self._processMap["getResourceByHash"] = Processor.process_getResourceByHash
    self._processMap["getResourceRecognition"] = Processor.process_getResourceRecognition
    self._processMap["getResourceAlternateData"] = Processor.process_getResourceAlternateData
    self._processMap["getResourceAttributes"] = Processor.process_getResourceAttributes
    self._processMap["getAccountSize"] = Processor.process_getAccountSize
    self._processMap["getAds"] = Processor.process_getAds
    self._processMap["getRandomAd"] = Processor.process_getRandomAd
    self._processMap["getPublicNotebook"] = Processor.process_getPublicNotebook
    self._processMap["createSharedNotebook"] = Processor.process_createSharedNotebook
    self._processMap["sendMessageToSharedNotebookMembers"] = Processor.process_sendMessageToSharedNotebookMembers
    self._processMap["listSharedNotebooks"] = Processor.process_listSharedNotebooks
    self._processMap["expungeSharedNotebooks"] = Processor.process_expungeSharedNotebooks
    self._processMap["createLinkedNotebook"] = Processor.process_createLinkedNotebook
    self._processMap["updateLinkedNotebook"] = Processor.process_updateLinkedNotebook
    self._processMap["listLinkedNotebooks"] = Processor.process_listLinkedNotebooks
    self._processMap["expungeLinkedNotebook"] = Processor.process_expungeLinkedNotebook
    self._processMap["authenticateToSharedNotebook"] = Processor.process_authenticateToSharedNotebook
    self._processMap["getSharedNotebookByAuth"] = Processor.process_getSharedNotebookByAuth
    self._processMap["emailNote"] = Processor.process_emailNote
    self._processMap["shareNote"] = Processor.process_shareNote
    self._processMap["stopSharingNote"] = Processor.process_stopSharingNote
    self._processMap["authenticateToSharedNote"] = Processor.process_authenticateToSharedNote

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_getSyncState(self, seqid, iprot, oprot):
    args = getSyncState_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSyncState_result()
    try:
      result.success = self._handler.getSyncState(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getSyncState", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSyncStateWithMetrics(self, seqid, iprot, oprot):
    args = getSyncStateWithMetrics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSyncStateWithMetrics_result()
    try:
      result.success = self._handler.getSyncStateWithMetrics(args.authenticationToken, args.clientMetrics)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getSyncStateWithMetrics", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSyncChunk(self, seqid, iprot, oprot):
    args = getSyncChunk_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSyncChunk_result()
    try:
      result.success = self._handler.getSyncChunk(args.authenticationToken, args.afterUSN, args.maxEntries, args.fullSyncOnly)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getSyncChunk", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getFilteredSyncChunk(self, seqid, iprot, oprot):
    args = getFilteredSyncChunk_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getFilteredSyncChunk_result()
    try:
      result.success = self._handler.getFilteredSyncChunk(args.authenticationToken, args.afterUSN, args.maxEntries, args.filter)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getFilteredSyncChunk", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getLinkedNotebookSyncState(self, seqid, iprot, oprot):
    args = getLinkedNotebookSyncState_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getLinkedNotebookSyncState_result()
    try:
      result.success = self._handler.getLinkedNotebookSyncState(args.authenticationToken, args.linkedNotebook)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getLinkedNotebookSyncState", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getLinkedNotebookSyncChunk(self, seqid, iprot, oprot):
    args = getLinkedNotebookSyncChunk_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getLinkedNotebookSyncChunk_result()
    try:
      result.success = self._handler.getLinkedNotebookSyncChunk(args.authenticationToken, args.linkedNotebook, args.afterUSN, args.maxEntries, args.fullSyncOnly)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getLinkedNotebookSyncChunk", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listNotebooks(self, seqid, iprot, oprot):
    args = listNotebooks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listNotebooks_result()
    try:
      result.success = self._handler.listNotebooks(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("listNotebooks", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNotebook(self, seqid, iprot, oprot):
    args = getNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNotebook_result()
    try:
      result.success = self._handler.getNotebook(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDefaultNotebook(self, seqid, iprot, oprot):
    args = getDefaultNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDefaultNotebook_result()
    try:
      result.success = self._handler.getDefaultNotebook(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getDefaultNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createNotebook(self, seqid, iprot, oprot):
    args = createNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createNotebook_result()
    try:
      result.success = self._handler.createNotebook(args.authenticationToken, args.notebook)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("createNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateNotebook(self, seqid, iprot, oprot):
    args = updateNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateNotebook_result()
    try:
      result.success = self._handler.updateNotebook(args.authenticationToken, args.notebook)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("updateNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_expungeNotebook(self, seqid, iprot, oprot):
    args = expungeNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = expungeNotebook_result()
    try:
      result.success = self._handler.expungeNotebook(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("expungeNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listTags(self, seqid, iprot, oprot):
    args = listTags_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listTags_result()
    try:
      result.success = self._handler.listTags(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("listTags", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listTagsByNotebook(self, seqid, iprot, oprot):
    args = listTagsByNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listTagsByNotebook_result()
    try:
      result.success = self._handler.listTagsByNotebook(args.authenticationToken, args.notebookGuid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("listTagsByNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getTag(self, seqid, iprot, oprot):
    args = getTag_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getTag_result()
    try:
      result.success = self._handler.getTag(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getTag", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createTag(self, seqid, iprot, oprot):
    args = createTag_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createTag_result()
    try:
      result.success = self._handler.createTag(args.authenticationToken, args.tag)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("createTag", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateTag(self, seqid, iprot, oprot):
    args = updateTag_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateTag_result()
    try:
      result.success = self._handler.updateTag(args.authenticationToken, args.tag)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("updateTag", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_untagAll(self, seqid, iprot, oprot):
    args = untagAll_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = untagAll_result()
    try:
      self._handler.untagAll(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("untagAll", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_expungeTag(self, seqid, iprot, oprot):
    args = expungeTag_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = expungeTag_result()
    try:
      result.success = self._handler.expungeTag(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("expungeTag", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listSearches(self, seqid, iprot, oprot):
    args = listSearches_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listSearches_result()
    try:
      result.success = self._handler.listSearches(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("listSearches", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSearch(self, seqid, iprot, oprot):
    args = getSearch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSearch_result()
    try:
      result.success = self._handler.getSearch(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getSearch", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createSearch(self, seqid, iprot, oprot):
    args = createSearch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createSearch_result()
    try:
      result.success = self._handler.createSearch(args.authenticationToken, args.search)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("createSearch", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateSearch(self, seqid, iprot, oprot):
    args = updateSearch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateSearch_result()
    try:
      result.success = self._handler.updateSearch(args.authenticationToken, args.search)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("updateSearch", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_expungeSearch(self, seqid, iprot, oprot):
    args = expungeSearch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = expungeSearch_result()
    try:
      result.success = self._handler.expungeSearch(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("expungeSearch", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findNotes(self, seqid, iprot, oprot):
    args = findNotes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findNotes_result()
    try:
      result.success = self._handler.findNotes(args.authenticationToken, args.filter, args.offset, args.maxNotes)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("findNotes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findNoteOffset(self, seqid, iprot, oprot):
    args = findNoteOffset_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findNoteOffset_result()
    try:
      result.success = self._handler.findNoteOffset(args.authenticationToken, args.filter, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("findNoteOffset", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findNotesMetadata(self, seqid, iprot, oprot):
    args = findNotesMetadata_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findNotesMetadata_result()
    try:
      result.success = self._handler.findNotesMetadata(args.authenticationToken, args.filter, args.offset, args.maxNotes, args.resultSpec)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("findNotesMetadata", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findNoteCounts(self, seqid, iprot, oprot):
    args = findNoteCounts_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findNoteCounts_result()
    try:
      result.success = self._handler.findNoteCounts(args.authenticationToken, args.filter, args.withTrash)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("findNoteCounts", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNote(self, seqid, iprot, oprot):
    args = getNote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNote_result()
    try:
      result.success = self._handler.getNote(args.authenticationToken, args.guid, args.withContent, args.withResourcesData, args.withResourcesRecognition, args.withResourcesAlternateData)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getNote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNoteApplicationData(self, seqid, iprot, oprot):
    args = getNoteApplicationData_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNoteApplicationData_result()
    try:
      result.success = self._handler.getNoteApplicationData(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getNoteApplicationData", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNoteApplicationDataEntry(self, seqid, iprot, oprot):
    args = getNoteApplicationDataEntry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNoteApplicationDataEntry_result()
    try:
      result.success = self._handler.getNoteApplicationDataEntry(args.authenticationToken, args.guid, args.key)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getNoteApplicationDataEntry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setNoteApplicationDataEntry(self, seqid, iprot, oprot):
    args = setNoteApplicationDataEntry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setNoteApplicationDataEntry_result()
    try:
      result.success = self._handler.setNoteApplicationDataEntry(args.authenticationToken, args.guid, args.key, args.value)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("setNoteApplicationDataEntry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_unsetNoteApplicationDataEntry(self, seqid, iprot, oprot):
    args = unsetNoteApplicationDataEntry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = unsetNoteApplicationDataEntry_result()
    try:
      result.success = self._handler.unsetNoteApplicationDataEntry(args.authenticationToken, args.guid, args.key)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("unsetNoteApplicationDataEntry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNoteContent(self, seqid, iprot, oprot):
    args = getNoteContent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNoteContent_result()
    try:
      result.success = self._handler.getNoteContent(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getNoteContent", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNoteSearchText(self, seqid, iprot, oprot):
    args = getNoteSearchText_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNoteSearchText_result()
    try:
      result.success = self._handler.getNoteSearchText(args.authenticationToken, args.guid, args.noteOnly, args.tokenizeForIndexing)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getNoteSearchText", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getResourceSearchText(self, seqid, iprot, oprot):
    args = getResourceSearchText_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getResourceSearchText_result()
    try:
      result.success = self._handler.getResourceSearchText(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getResourceSearchText", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNoteTagNames(self, seqid, iprot, oprot):
    args = getNoteTagNames_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNoteTagNames_result()
    try:
      result.success = self._handler.getNoteTagNames(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getNoteTagNames", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createNote(self, seqid, iprot, oprot):
    args = createNote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createNote_result()
    try:
      result.success = self._handler.createNote(args.authenticationToken, args.note)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("createNote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateNote(self, seqid, iprot, oprot):
    args = updateNote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateNote_result()
    try:
      result.success = self._handler.updateNote(args.authenticationToken, args.note)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("updateNote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteNote(self, seqid, iprot, oprot):
    args = deleteNote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteNote_result()
    try:
      result.success = self._handler.deleteNote(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("deleteNote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_expungeNote(self, seqid, iprot, oprot):
    args = expungeNote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = expungeNote_result()
    try:
      result.success = self._handler.expungeNote(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("expungeNote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_expungeNotes(self, seqid, iprot, oprot):
    args = expungeNotes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = expungeNotes_result()
    try:
      result.success = self._handler.expungeNotes(args.authenticationToken, args.noteGuids)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("expungeNotes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_expungeInactiveNotes(self, seqid, iprot, oprot):
    args = expungeInactiveNotes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = expungeInactiveNotes_result()
    try:
      result.success = self._handler.expungeInactiveNotes(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("expungeInactiveNotes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_copyNote(self, seqid, iprot, oprot):
    args = copyNote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = copyNote_result()
    try:
      result.success = self._handler.copyNote(args.authenticationToken, args.noteGuid, args.toNotebookGuid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("copyNote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listNoteVersions(self, seqid, iprot, oprot):
    args = listNoteVersions_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listNoteVersions_result()
    try:
      result.success = self._handler.listNoteVersions(args.authenticationToken, args.noteGuid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("listNoteVersions", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNoteVersion(self, seqid, iprot, oprot):
    args = getNoteVersion_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNoteVersion_result()
    try:
      result.success = self._handler.getNoteVersion(args.authenticationToken, args.noteGuid, args.updateSequenceNum, args.withResourcesData, args.withResourcesRecognition, args.withResourcesAlternateData)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getNoteVersion", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getResource(self, seqid, iprot, oprot):
    args = getResource_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getResource_result()
    try:
      result.success = self._handler.getResource(args.authenticationToken, args.guid, args.withData, args.withRecognition, args.withAttributes, args.withAlternateData)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getResource", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getResourceApplicationData(self, seqid, iprot, oprot):
    args = getResourceApplicationData_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getResourceApplicationData_result()
    try:
      result.success = self._handler.getResourceApplicationData(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getResourceApplicationData", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getResourceApplicationDataEntry(self, seqid, iprot, oprot):
    args = getResourceApplicationDataEntry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getResourceApplicationDataEntry_result()
    try:
      result.success = self._handler.getResourceApplicationDataEntry(args.authenticationToken, args.guid, args.key)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getResourceApplicationDataEntry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setResourceApplicationDataEntry(self, seqid, iprot, oprot):
    args = setResourceApplicationDataEntry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setResourceApplicationDataEntry_result()
    try:
      result.success = self._handler.setResourceApplicationDataEntry(args.authenticationToken, args.guid, args.key, args.value)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("setResourceApplicationDataEntry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_unsetResourceApplicationDataEntry(self, seqid, iprot, oprot):
    args = unsetResourceApplicationDataEntry_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = unsetResourceApplicationDataEntry_result()
    try:
      result.success = self._handler.unsetResourceApplicationDataEntry(args.authenticationToken, args.guid, args.key)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("unsetResourceApplicationDataEntry", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateResource(self, seqid, iprot, oprot):
    args = updateResource_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateResource_result()
    try:
      result.success = self._handler.updateResource(args.authenticationToken, args.resource)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("updateResource", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getResourceData(self, seqid, iprot, oprot):
    args = getResourceData_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getResourceData_result()
    try:
      result.success = self._handler.getResourceData(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getResourceData", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getResourceByHash(self, seqid, iprot, oprot):
    args = getResourceByHash_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getResourceByHash_result()
    try:
      result.success = self._handler.getResourceByHash(args.authenticationToken, args.noteGuid, args.contentHash, args.withData, args.withRecognition, args.withAlternateData)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getResourceByHash", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getResourceRecognition(self, seqid, iprot, oprot):
    args = getResourceRecognition_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getResourceRecognition_result()
    try:
      result.success = self._handler.getResourceRecognition(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getResourceRecognition", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getResourceAlternateData(self, seqid, iprot, oprot):
    args = getResourceAlternateData_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getResourceAlternateData_result()
    try:
      result.success = self._handler.getResourceAlternateData(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getResourceAlternateData", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getResourceAttributes(self, seqid, iprot, oprot):
    args = getResourceAttributes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getResourceAttributes_result()
    try:
      result.success = self._handler.getResourceAttributes(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getResourceAttributes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getAccountSize(self, seqid, iprot, oprot):
    args = getAccountSize_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getAccountSize_result()
    try:
      result.success = self._handler.getAccountSize(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getAccountSize", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getAds(self, seqid, iprot, oprot):
    args = getAds_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getAds_result()
    try:
      result.success = self._handler.getAds(args.authenticationToken, args.adParameters)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getAds", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getRandomAd(self, seqid, iprot, oprot):
    args = getRandomAd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getRandomAd_result()
    try:
      result.success = self._handler.getRandomAd(args.authenticationToken, args.adParameters)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getRandomAd", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getPublicNotebook(self, seqid, iprot, oprot):
    args = getPublicNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getPublicNotebook_result()
    try:
      result.success = self._handler.getPublicNotebook(args.userId, args.publicUri)
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    oprot.writeMessageBegin("getPublicNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createSharedNotebook(self, seqid, iprot, oprot):
    args = createSharedNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createSharedNotebook_result()
    try:
      result.success = self._handler.createSharedNotebook(args.authenticationToken, args.sharedNotebook)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("createSharedNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sendMessageToSharedNotebookMembers(self, seqid, iprot, oprot):
    args = sendMessageToSharedNotebookMembers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sendMessageToSharedNotebookMembers_result()
    try:
      result.success = self._handler.sendMessageToSharedNotebookMembers(args.authenticationToken, args.notebookGuid, args.messageText, args.recipients)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("sendMessageToSharedNotebookMembers", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listSharedNotebooks(self, seqid, iprot, oprot):
    args = listSharedNotebooks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listSharedNotebooks_result()
    try:
      result.success = self._handler.listSharedNotebooks(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("listSharedNotebooks", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_expungeSharedNotebooks(self, seqid, iprot, oprot):
    args = expungeSharedNotebooks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = expungeSharedNotebooks_result()
    try:
      result.success = self._handler.expungeSharedNotebooks(args.authenticationToken, args.sharedNotebookIds)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("expungeSharedNotebooks", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createLinkedNotebook(self, seqid, iprot, oprot):
    args = createLinkedNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createLinkedNotebook_result()
    try:
      result.success = self._handler.createLinkedNotebook(args.authenticationToken, args.linkedNotebook)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("createLinkedNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateLinkedNotebook(self, seqid, iprot, oprot):
    args = updateLinkedNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateLinkedNotebook_result()
    try:
      result.success = self._handler.updateLinkedNotebook(args.authenticationToken, args.linkedNotebook)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("updateLinkedNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listLinkedNotebooks(self, seqid, iprot, oprot):
    args = listLinkedNotebooks_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listLinkedNotebooks_result()
    try:
      result.success = self._handler.listLinkedNotebooks(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("listLinkedNotebooks", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_expungeLinkedNotebook(self, seqid, iprot, oprot):
    args = expungeLinkedNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = expungeLinkedNotebook_result()
    try:
      result.success = self._handler.expungeLinkedNotebook(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("expungeLinkedNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_authenticateToSharedNotebook(self, seqid, iprot, oprot):
    args = authenticateToSharedNotebook_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = authenticateToSharedNotebook_result()
    try:
      result.success = self._handler.authenticateToSharedNotebook(args.shareKey, args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("authenticateToSharedNotebook", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSharedNotebookByAuth(self, seqid, iprot, oprot):
    args = getSharedNotebookByAuth_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSharedNotebookByAuth_result()
    try:
      result.success = self._handler.getSharedNotebookByAuth(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getSharedNotebookByAuth", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_emailNote(self, seqid, iprot, oprot):
    args = emailNote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = emailNote_result()
    try:
      self._handler.emailNote(args.authenticationToken, args.parameters)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("emailNote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_shareNote(self, seqid, iprot, oprot):
    args = shareNote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = shareNote_result()
    try:
      result.success = self._handler.shareNote(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("shareNote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_stopSharingNote(self, seqid, iprot, oprot):
    args = stopSharingNote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = stopSharingNote_result()
    try:
      self._handler.stopSharingNote(args.authenticationToken, args.guid)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("stopSharingNote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_authenticateToSharedNote(self, seqid, iprot, oprot):
    args = authenticateToSharedNote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = authenticateToSharedNote_result()
    try:
      result.success = self._handler.authenticateToSharedNote(args.guid, args.noteKey)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("authenticateToSharedNote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class getSyncState_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSyncState_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSyncState_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SyncState, SyncState.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SyncState()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSyncState_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSyncStateWithMetrics_args(object):
  """
  Attributes:
   - authenticationToken
   - clientMetrics
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'clientMetrics', (ClientUsageMetrics, ClientUsageMetrics.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, clientMetrics=None,):
    self.authenticationToken = authenticationToken
    self.clientMetrics = clientMetrics

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.clientMetrics = ClientUsageMetrics()
          self.clientMetrics.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSyncStateWithMetrics_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.clientMetrics is not None:
      oprot.writeFieldBegin('clientMetrics', TType.STRUCT, 2)
      self.clientMetrics.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSyncStateWithMetrics_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SyncState, SyncState.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SyncState()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSyncStateWithMetrics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSyncChunk_args(object):
  """
  Attributes:
   - authenticationToken
   - afterUSN
   - maxEntries
   - fullSyncOnly
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.I32, 'afterUSN', None, None, ), # 2
    (3, TType.I32, 'maxEntries', None, None, ), # 3
    (4, TType.BOOL, 'fullSyncOnly', None, None, ), # 4
  )

  def __init__(self, authenticationToken=None, afterUSN=None, maxEntries=None, fullSyncOnly=None,):
    self.authenticationToken = authenticationToken
    self.afterUSN = afterUSN
    self.maxEntries = maxEntries
    self.fullSyncOnly = fullSyncOnly

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.afterUSN = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.maxEntries = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.fullSyncOnly = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSyncChunk_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.afterUSN is not None:
      oprot.writeFieldBegin('afterUSN', TType.I32, 2)
      oprot.writeI32(self.afterUSN)
      oprot.writeFieldEnd()
    if self.maxEntries is not None:
      oprot.writeFieldBegin('maxEntries', TType.I32, 3)
      oprot.writeI32(self.maxEntries)
      oprot.writeFieldEnd()
    if self.fullSyncOnly is not None:
      oprot.writeFieldBegin('fullSyncOnly', TType.BOOL, 4)
      oprot.writeBool(self.fullSyncOnly)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSyncChunk_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SyncChunk, SyncChunk.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SyncChunk()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSyncChunk_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getFilteredSyncChunk_args(object):
  """
  Attributes:
   - authenticationToken
   - afterUSN
   - maxEntries
   - filter
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.I32, 'afterUSN', None, None, ), # 2
    (3, TType.I32, 'maxEntries', None, None, ), # 3
    (4, TType.STRUCT, 'filter', (SyncChunkFilter, SyncChunkFilter.thrift_spec), None, ), # 4
  )

  def __init__(self, authenticationToken=None, afterUSN=None, maxEntries=None, filter=None,):
    self.authenticationToken = authenticationToken
    self.afterUSN = afterUSN
    self.maxEntries = maxEntries
    self.filter = filter

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.afterUSN = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.maxEntries = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.filter = SyncChunkFilter()
          self.filter.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getFilteredSyncChunk_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.afterUSN is not None:
      oprot.writeFieldBegin('afterUSN', TType.I32, 2)
      oprot.writeI32(self.afterUSN)
      oprot.writeFieldEnd()
    if self.maxEntries is not None:
      oprot.writeFieldBegin('maxEntries', TType.I32, 3)
      oprot.writeI32(self.maxEntries)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRUCT, 4)
      self.filter.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getFilteredSyncChunk_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SyncChunk, SyncChunk.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SyncChunk()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getFilteredSyncChunk_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLinkedNotebookSyncState_args(object):
  """
  Attributes:
   - authenticationToken
   - linkedNotebook
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'linkedNotebook', (evernote.edam.type.ttypes.LinkedNotebook, evernote.edam.type.ttypes.LinkedNotebook.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, linkedNotebook=None,):
    self.authenticationToken = authenticationToken
    self.linkedNotebook = linkedNotebook

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.linkedNotebook = evernote.edam.type.ttypes.LinkedNotebook()
          self.linkedNotebook.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLinkedNotebookSyncState_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.linkedNotebook is not None:
      oprot.writeFieldBegin('linkedNotebook', TType.STRUCT, 2)
      self.linkedNotebook.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLinkedNotebookSyncState_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SyncState, SyncState.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SyncState()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLinkedNotebookSyncState_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLinkedNotebookSyncChunk_args(object):
  """
  Attributes:
   - authenticationToken
   - linkedNotebook
   - afterUSN
   - maxEntries
   - fullSyncOnly
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'linkedNotebook', (evernote.edam.type.ttypes.LinkedNotebook, evernote.edam.type.ttypes.LinkedNotebook.thrift_spec), None, ), # 2
    (3, TType.I32, 'afterUSN', None, None, ), # 3
    (4, TType.I32, 'maxEntries', None, None, ), # 4
    (5, TType.BOOL, 'fullSyncOnly', None, None, ), # 5
  )

  def __init__(self, authenticationToken=None, linkedNotebook=None, afterUSN=None, maxEntries=None, fullSyncOnly=None,):
    self.authenticationToken = authenticationToken
    self.linkedNotebook = linkedNotebook
    self.afterUSN = afterUSN
    self.maxEntries = maxEntries
    self.fullSyncOnly = fullSyncOnly

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.linkedNotebook = evernote.edam.type.ttypes.LinkedNotebook()
          self.linkedNotebook.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.afterUSN = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.maxEntries = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.fullSyncOnly = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLinkedNotebookSyncChunk_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.linkedNotebook is not None:
      oprot.writeFieldBegin('linkedNotebook', TType.STRUCT, 2)
      self.linkedNotebook.write(oprot)
      oprot.writeFieldEnd()
    if self.afterUSN is not None:
      oprot.writeFieldBegin('afterUSN', TType.I32, 3)
      oprot.writeI32(self.afterUSN)
      oprot.writeFieldEnd()
    if self.maxEntries is not None:
      oprot.writeFieldBegin('maxEntries', TType.I32, 4)
      oprot.writeI32(self.maxEntries)
      oprot.writeFieldEnd()
    if self.fullSyncOnly is not None:
      oprot.writeFieldBegin('fullSyncOnly', TType.BOOL, 5)
      oprot.writeBool(self.fullSyncOnly)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getLinkedNotebookSyncChunk_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SyncChunk, SyncChunk.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SyncChunk()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getLinkedNotebookSyncChunk_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listNotebooks_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listNotebooks_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listNotebooks_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(evernote.edam.type.ttypes.Notebook, evernote.edam.type.ttypes.Notebook.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype184, _size181) = iprot.readListBegin()
          for _i185 in xrange(_size181):
            _elem186 = evernote.edam.type.ttypes.Notebook()
            _elem186.read(iprot)
            self.success.append(_elem186)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listNotebooks_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter187 in self.success:
        iter187.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNotebook_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Notebook, evernote.edam.type.ttypes.Notebook.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Notebook()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDefaultNotebook_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDefaultNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDefaultNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Notebook, evernote.edam.type.ttypes.Notebook.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Notebook()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDefaultNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createNotebook_args(object):
  """
  Attributes:
   - authenticationToken
   - notebook
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'notebook', (evernote.edam.type.ttypes.Notebook, evernote.edam.type.ttypes.Notebook.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, notebook=None,):
    self.authenticationToken = authenticationToken
    self.notebook = notebook

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notebook = evernote.edam.type.ttypes.Notebook()
          self.notebook.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.notebook is not None:
      oprot.writeFieldBegin('notebook', TType.STRUCT, 2)
      self.notebook.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Notebook, evernote.edam.type.ttypes.Notebook.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Notebook()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateNotebook_args(object):
  """
  Attributes:
   - authenticationToken
   - notebook
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'notebook', (evernote.edam.type.ttypes.Notebook, evernote.edam.type.ttypes.Notebook.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, notebook=None,):
    self.authenticationToken = authenticationToken
    self.notebook = notebook

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notebook = evernote.edam.type.ttypes.Notebook()
          self.notebook.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.notebook is not None:
      oprot.writeFieldBegin('notebook', TType.STRUCT, 2)
      self.notebook.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeNotebook_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listTags_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listTags_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listTags_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(evernote.edam.type.ttypes.Tag, evernote.edam.type.ttypes.Tag.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype191, _size188) = iprot.readListBegin()
          for _i192 in xrange(_size188):
            _elem193 = evernote.edam.type.ttypes.Tag()
            _elem193.read(iprot)
            self.success.append(_elem193)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listTags_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter194 in self.success:
        iter194.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listTagsByNotebook_args(object):
  """
  Attributes:
   - authenticationToken
   - notebookGuid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'notebookGuid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, notebookGuid=None,):
    self.authenticationToken = authenticationToken
    self.notebookGuid = notebookGuid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.notebookGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listTagsByNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.notebookGuid is not None:
      oprot.writeFieldBegin('notebookGuid', TType.STRING, 2)
      oprot.writeString(self.notebookGuid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listTagsByNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(evernote.edam.type.ttypes.Tag, evernote.edam.type.ttypes.Tag.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype198, _size195) = iprot.readListBegin()
          for _i199 in xrange(_size195):
            _elem200 = evernote.edam.type.ttypes.Tag()
            _elem200.read(iprot)
            self.success.append(_elem200)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listTagsByNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter201 in self.success:
        iter201.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTag_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTag_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTag_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Tag, evernote.edam.type.ttypes.Tag.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Tag()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTag_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createTag_args(object):
  """
  Attributes:
   - authenticationToken
   - tag
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'tag', (evernote.edam.type.ttypes.Tag, evernote.edam.type.ttypes.Tag.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, tag=None,):
    self.authenticationToken = authenticationToken
    self.tag = tag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tag = evernote.edam.type.ttypes.Tag()
          self.tag.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createTag_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.tag is not None:
      oprot.writeFieldBegin('tag', TType.STRUCT, 2)
      self.tag.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createTag_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Tag, evernote.edam.type.ttypes.Tag.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Tag()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createTag_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateTag_args(object):
  """
  Attributes:
   - authenticationToken
   - tag
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'tag', (evernote.edam.type.ttypes.Tag, evernote.edam.type.ttypes.Tag.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, tag=None,):
    self.authenticationToken = authenticationToken
    self.tag = tag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tag = evernote.edam.type.ttypes.Tag()
          self.tag.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateTag_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.tag is not None:
      oprot.writeFieldBegin('tag', TType.STRUCT, 2)
      self.tag.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateTag_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateTag_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class untagAll_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('untagAll_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class untagAll_result(object):
  """
  Attributes:
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, userException=None, systemException=None, notFoundException=None,):
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('untagAll_result')
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeTag_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeTag_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeTag_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeTag_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSearches_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSearches_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSearches_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(evernote.edam.type.ttypes.SavedSearch, evernote.edam.type.ttypes.SavedSearch.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype205, _size202) = iprot.readListBegin()
          for _i206 in xrange(_size202):
            _elem207 = evernote.edam.type.ttypes.SavedSearch()
            _elem207.read(iprot)
            self.success.append(_elem207)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSearches_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter208 in self.success:
        iter208.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSearch_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSearch_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSearch_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.SavedSearch, evernote.edam.type.ttypes.SavedSearch.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.SavedSearch()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSearch_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createSearch_args(object):
  """
  Attributes:
   - authenticationToken
   - search
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'search', (evernote.edam.type.ttypes.SavedSearch, evernote.edam.type.ttypes.SavedSearch.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, search=None,):
    self.authenticationToken = authenticationToken
    self.search = search

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.search = evernote.edam.type.ttypes.SavedSearch()
          self.search.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createSearch_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.search is not None:
      oprot.writeFieldBegin('search', TType.STRUCT, 2)
      self.search.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createSearch_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.SavedSearch, evernote.edam.type.ttypes.SavedSearch.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.SavedSearch()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createSearch_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateSearch_args(object):
  """
  Attributes:
   - authenticationToken
   - search
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'search', (evernote.edam.type.ttypes.SavedSearch, evernote.edam.type.ttypes.SavedSearch.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, search=None,):
    self.authenticationToken = authenticationToken
    self.search = search

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.search = evernote.edam.type.ttypes.SavedSearch()
          self.search.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateSearch_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.search is not None:
      oprot.writeFieldBegin('search', TType.STRUCT, 2)
      self.search.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateSearch_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateSearch_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeSearch_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeSearch_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeSearch_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeSearch_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findNotes_args(object):
  """
  Attributes:
   - authenticationToken
   - filter
   - offset
   - maxNotes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'filter', (NoteFilter, NoteFilter.thrift_spec), None, ), # 2
    (3, TType.I32, 'offset', None, None, ), # 3
    (4, TType.I32, 'maxNotes', None, None, ), # 4
  )

  def __init__(self, authenticationToken=None, filter=None, offset=None, maxNotes=None,):
    self.authenticationToken = authenticationToken
    self.filter = filter
    self.offset = offset
    self.maxNotes = maxNotes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.filter = NoteFilter()
          self.filter.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.offset = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.maxNotes = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findNotes_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRUCT, 2)
      self.filter.write(oprot)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 3)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.maxNotes is not None:
      oprot.writeFieldBegin('maxNotes', TType.I32, 4)
      oprot.writeI32(self.maxNotes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findNotes_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (NoteList, NoteList.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = NoteList()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findNotes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findNoteOffset_args(object):
  """
  Attributes:
   - authenticationToken
   - filter
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'filter', (NoteFilter, NoteFilter.thrift_spec), None, ), # 2
    (3, TType.STRING, 'guid', None, None, ), # 3
  )

  def __init__(self, authenticationToken=None, filter=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.filter = filter
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.filter = NoteFilter()
          self.filter.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findNoteOffset_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRUCT, 2)
      self.filter.write(oprot)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 3)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findNoteOffset_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findNoteOffset_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findNotesMetadata_args(object):
  """
  Attributes:
   - authenticationToken
   - filter
   - offset
   - maxNotes
   - resultSpec
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'filter', (NoteFilter, NoteFilter.thrift_spec), None, ), # 2
    (3, TType.I32, 'offset', None, None, ), # 3
    (4, TType.I32, 'maxNotes', None, None, ), # 4
    (5, TType.STRUCT, 'resultSpec', (NotesMetadataResultSpec, NotesMetadataResultSpec.thrift_spec), None, ), # 5
  )

  def __init__(self, authenticationToken=None, filter=None, offset=None, maxNotes=None, resultSpec=None,):
    self.authenticationToken = authenticationToken
    self.filter = filter
    self.offset = offset
    self.maxNotes = maxNotes
    self.resultSpec = resultSpec

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.filter = NoteFilter()
          self.filter.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.offset = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.maxNotes = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.resultSpec = NotesMetadataResultSpec()
          self.resultSpec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findNotesMetadata_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRUCT, 2)
      self.filter.write(oprot)
      oprot.writeFieldEnd()
    if self.offset is not None:
      oprot.writeFieldBegin('offset', TType.I32, 3)
      oprot.writeI32(self.offset)
      oprot.writeFieldEnd()
    if self.maxNotes is not None:
      oprot.writeFieldBegin('maxNotes', TType.I32, 4)
      oprot.writeI32(self.maxNotes)
      oprot.writeFieldEnd()
    if self.resultSpec is not None:
      oprot.writeFieldBegin('resultSpec', TType.STRUCT, 5)
      self.resultSpec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findNotesMetadata_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (NotesMetadataList, NotesMetadataList.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = NotesMetadataList()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findNotesMetadata_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findNoteCounts_args(object):
  """
  Attributes:
   - authenticationToken
   - filter
   - withTrash
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'filter', (NoteFilter, NoteFilter.thrift_spec), None, ), # 2
    (3, TType.BOOL, 'withTrash', None, None, ), # 3
  )

  def __init__(self, authenticationToken=None, filter=None, withTrash=None,):
    self.authenticationToken = authenticationToken
    self.filter = filter
    self.withTrash = withTrash

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.filter = NoteFilter()
          self.filter.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.withTrash = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findNoteCounts_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRUCT, 2)
      self.filter.write(oprot)
      oprot.writeFieldEnd()
    if self.withTrash is not None:
      oprot.writeFieldBegin('withTrash', TType.BOOL, 3)
      oprot.writeBool(self.withTrash)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findNoteCounts_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (NoteCollectionCounts, NoteCollectionCounts.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = NoteCollectionCounts()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findNoteCounts_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNote_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
   - withContent
   - withResourcesData
   - withResourcesRecognition
   - withResourcesAlternateData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
    (3, TType.BOOL, 'withContent', None, None, ), # 3
    (4, TType.BOOL, 'withResourcesData', None, None, ), # 4
    (5, TType.BOOL, 'withResourcesRecognition', None, None, ), # 5
    (6, TType.BOOL, 'withResourcesAlternateData', None, None, ), # 6
  )

  def __init__(self, authenticationToken=None, guid=None, withContent=None, withResourcesData=None, withResourcesRecognition=None, withResourcesAlternateData=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid
    self.withContent = withContent
    self.withResourcesData = withResourcesData
    self.withResourcesRecognition = withResourcesRecognition
    self.withResourcesAlternateData = withResourcesAlternateData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.withContent = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.withResourcesData = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.withResourcesRecognition = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.withResourcesAlternateData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNote_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.withContent is not None:
      oprot.writeFieldBegin('withContent', TType.BOOL, 3)
      oprot.writeBool(self.withContent)
      oprot.writeFieldEnd()
    if self.withResourcesData is not None:
      oprot.writeFieldBegin('withResourcesData', TType.BOOL, 4)
      oprot.writeBool(self.withResourcesData)
      oprot.writeFieldEnd()
    if self.withResourcesRecognition is not None:
      oprot.writeFieldBegin('withResourcesRecognition', TType.BOOL, 5)
      oprot.writeBool(self.withResourcesRecognition)
      oprot.writeFieldEnd()
    if self.withResourcesAlternateData is not None:
      oprot.writeFieldBegin('withResourcesAlternateData', TType.BOOL, 6)
      oprot.writeBool(self.withResourcesAlternateData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNote_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Note()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNote_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteApplicationData_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteApplicationData_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteApplicationData_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.LazyMap, evernote.edam.type.ttypes.LazyMap.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.LazyMap()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteApplicationData_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteApplicationDataEntry_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
   - key
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
    (3, TType.STRING, 'key', None, None, ), # 3
  )

  def __init__(self, authenticationToken=None, guid=None, key=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteApplicationDataEntry_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 3)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteApplicationDataEntry_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteApplicationDataEntry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setNoteApplicationDataEntry_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
   - key
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
    (3, TType.STRING, 'key', None, None, ), # 3
    (4, TType.STRING, 'value', None, None, ), # 4
  )

  def __init__(self, authenticationToken=None, guid=None, key=None, value=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid
    self.key = key
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setNoteApplicationDataEntry_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 3)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 4)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setNoteApplicationDataEntry_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setNoteApplicationDataEntry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unsetNoteApplicationDataEntry_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
   - key
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
    (3, TType.STRING, 'key', None, None, ), # 3
  )

  def __init__(self, authenticationToken=None, guid=None, key=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unsetNoteApplicationDataEntry_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 3)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unsetNoteApplicationDataEntry_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unsetNoteApplicationDataEntry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteContent_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteContent_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteContent_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteContent_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteSearchText_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
   - noteOnly
   - tokenizeForIndexing
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
    (3, TType.BOOL, 'noteOnly', None, None, ), # 3
    (4, TType.BOOL, 'tokenizeForIndexing', None, None, ), # 4
  )

  def __init__(self, authenticationToken=None, guid=None, noteOnly=None, tokenizeForIndexing=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid
    self.noteOnly = noteOnly
    self.tokenizeForIndexing = tokenizeForIndexing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.noteOnly = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.tokenizeForIndexing = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteSearchText_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.noteOnly is not None:
      oprot.writeFieldBegin('noteOnly', TType.BOOL, 3)
      oprot.writeBool(self.noteOnly)
      oprot.writeFieldEnd()
    if self.tokenizeForIndexing is not None:
      oprot.writeFieldBegin('tokenizeForIndexing', TType.BOOL, 4)
      oprot.writeBool(self.tokenizeForIndexing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteSearchText_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteSearchText_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceSearchText_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceSearchText_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceSearchText_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceSearchText_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteTagNames_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteTagNames_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteTagNames_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype212, _size209) = iprot.readListBegin()
          for _i213 in xrange(_size209):
            _elem214 = iprot.readString();
            self.success.append(_elem214)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteTagNames_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter215 in self.success:
        oprot.writeString(iter215)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createNote_args(object):
  """
  Attributes:
   - authenticationToken
   - note
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'note', (evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, note=None,):
    self.authenticationToken = authenticationToken
    self.note = note

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.note = evernote.edam.type.ttypes.Note()
          self.note.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createNote_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.note is not None:
      oprot.writeFieldBegin('note', TType.STRUCT, 2)
      self.note.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createNote_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Note()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createNote_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateNote_args(object):
  """
  Attributes:
   - authenticationToken
   - note
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'note', (evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, note=None,):
    self.authenticationToken = authenticationToken
    self.note = note

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.note = evernote.edam.type.ttypes.Note()
          self.note.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateNote_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.note is not None:
      oprot.writeFieldBegin('note', TType.STRUCT, 2)
      self.note.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateNote_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Note()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateNote_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteNote_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteNote_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteNote_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteNote_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeNote_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeNote_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeNote_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeNote_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeNotes_args(object):
  """
  Attributes:
   - authenticationToken
   - noteGuids
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.LIST, 'noteGuids', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, authenticationToken=None, noteGuids=None,):
    self.authenticationToken = authenticationToken
    self.noteGuids = noteGuids

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.noteGuids = []
          (_etype219, _size216) = iprot.readListBegin()
          for _i220 in xrange(_size216):
            _elem221 = iprot.readString();
            self.noteGuids.append(_elem221)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeNotes_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.noteGuids is not None:
      oprot.writeFieldBegin('noteGuids', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.noteGuids))
      for iter222 in self.noteGuids:
        oprot.writeString(iter222)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeNotes_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeNotes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeInactiveNotes_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeInactiveNotes_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeInactiveNotes_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeInactiveNotes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class copyNote_args(object):
  """
  Attributes:
   - authenticationToken
   - noteGuid
   - toNotebookGuid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'noteGuid', None, None, ), # 2
    (3, TType.STRING, 'toNotebookGuid', None, None, ), # 3
  )

  def __init__(self, authenticationToken=None, noteGuid=None, toNotebookGuid=None,):
    self.authenticationToken = authenticationToken
    self.noteGuid = noteGuid
    self.toNotebookGuid = toNotebookGuid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.noteGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.toNotebookGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('copyNote_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.noteGuid is not None:
      oprot.writeFieldBegin('noteGuid', TType.STRING, 2)
      oprot.writeString(self.noteGuid)
      oprot.writeFieldEnd()
    if self.toNotebookGuid is not None:
      oprot.writeFieldBegin('toNotebookGuid', TType.STRING, 3)
      oprot.writeString(self.toNotebookGuid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class copyNote_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Note()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('copyNote_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listNoteVersions_args(object):
  """
  Attributes:
   - authenticationToken
   - noteGuid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'noteGuid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, noteGuid=None,):
    self.authenticationToken = authenticationToken
    self.noteGuid = noteGuid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.noteGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listNoteVersions_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.noteGuid is not None:
      oprot.writeFieldBegin('noteGuid', TType.STRING, 2)
      oprot.writeString(self.noteGuid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listNoteVersions_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(NoteVersionId, NoteVersionId.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype226, _size223) = iprot.readListBegin()
          for _i227 in xrange(_size223):
            _elem228 = NoteVersionId()
            _elem228.read(iprot)
            self.success.append(_elem228)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listNoteVersions_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter229 in self.success:
        iter229.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteVersion_args(object):
  """
  Attributes:
   - authenticationToken
   - noteGuid
   - updateSequenceNum
   - withResourcesData
   - withResourcesRecognition
   - withResourcesAlternateData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'noteGuid', None, None, ), # 2
    (3, TType.I32, 'updateSequenceNum', None, None, ), # 3
    (4, TType.BOOL, 'withResourcesData', None, None, ), # 4
    (5, TType.BOOL, 'withResourcesRecognition', None, None, ), # 5
    (6, TType.BOOL, 'withResourcesAlternateData', None, None, ), # 6
  )

  def __init__(self, authenticationToken=None, noteGuid=None, updateSequenceNum=None, withResourcesData=None, withResourcesRecognition=None, withResourcesAlternateData=None,):
    self.authenticationToken = authenticationToken
    self.noteGuid = noteGuid
    self.updateSequenceNum = updateSequenceNum
    self.withResourcesData = withResourcesData
    self.withResourcesRecognition = withResourcesRecognition
    self.withResourcesAlternateData = withResourcesAlternateData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.noteGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.withResourcesData = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.withResourcesRecognition = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.withResourcesAlternateData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteVersion_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.noteGuid is not None:
      oprot.writeFieldBegin('noteGuid', TType.STRING, 2)
      oprot.writeString(self.noteGuid)
      oprot.writeFieldEnd()
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 3)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    if self.withResourcesData is not None:
      oprot.writeFieldBegin('withResourcesData', TType.BOOL, 4)
      oprot.writeBool(self.withResourcesData)
      oprot.writeFieldEnd()
    if self.withResourcesRecognition is not None:
      oprot.writeFieldBegin('withResourcesRecognition', TType.BOOL, 5)
      oprot.writeBool(self.withResourcesRecognition)
      oprot.writeFieldEnd()
    if self.withResourcesAlternateData is not None:
      oprot.writeFieldBegin('withResourcesAlternateData', TType.BOOL, 6)
      oprot.writeBool(self.withResourcesAlternateData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteVersion_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Note()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteVersion_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResource_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
   - withData
   - withRecognition
   - withAttributes
   - withAlternateData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
    (3, TType.BOOL, 'withData', None, None, ), # 3
    (4, TType.BOOL, 'withRecognition', None, None, ), # 4
    (5, TType.BOOL, 'withAttributes', None, None, ), # 5
    (6, TType.BOOL, 'withAlternateData', None, None, ), # 6
  )

  def __init__(self, authenticationToken=None, guid=None, withData=None, withRecognition=None, withAttributes=None, withAlternateData=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid
    self.withData = withData
    self.withRecognition = withRecognition
    self.withAttributes = withAttributes
    self.withAlternateData = withAlternateData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.withData = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.withRecognition = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.withAttributes = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.withAlternateData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResource_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.withData is not None:
      oprot.writeFieldBegin('withData', TType.BOOL, 3)
      oprot.writeBool(self.withData)
      oprot.writeFieldEnd()
    if self.withRecognition is not None:
      oprot.writeFieldBegin('withRecognition', TType.BOOL, 4)
      oprot.writeBool(self.withRecognition)
      oprot.writeFieldEnd()
    if self.withAttributes is not None:
      oprot.writeFieldBegin('withAttributes', TType.BOOL, 5)
      oprot.writeBool(self.withAttributes)
      oprot.writeFieldEnd()
    if self.withAlternateData is not None:
      oprot.writeFieldBegin('withAlternateData', TType.BOOL, 6)
      oprot.writeBool(self.withAlternateData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResource_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Resource, evernote.edam.type.ttypes.Resource.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Resource()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResource_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceApplicationData_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceApplicationData_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceApplicationData_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.LazyMap, evernote.edam.type.ttypes.LazyMap.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.LazyMap()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceApplicationData_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceApplicationDataEntry_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
   - key
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
    (3, TType.STRING, 'key', None, None, ), # 3
  )

  def __init__(self, authenticationToken=None, guid=None, key=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceApplicationDataEntry_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 3)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceApplicationDataEntry_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceApplicationDataEntry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setResourceApplicationDataEntry_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
   - key
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
    (3, TType.STRING, 'key', None, None, ), # 3
    (4, TType.STRING, 'value', None, None, ), # 4
  )

  def __init__(self, authenticationToken=None, guid=None, key=None, value=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid
    self.key = key
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setResourceApplicationDataEntry_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 3)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 4)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setResourceApplicationDataEntry_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setResourceApplicationDataEntry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unsetResourceApplicationDataEntry_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
   - key
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
    (3, TType.STRING, 'key', None, None, ), # 3
  )

  def __init__(self, authenticationToken=None, guid=None, key=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unsetResourceApplicationDataEntry_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 3)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unsetResourceApplicationDataEntry_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unsetResourceApplicationDataEntry_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateResource_args(object):
  """
  Attributes:
   - authenticationToken
   - resource
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'resource', (evernote.edam.type.ttypes.Resource, evernote.edam.type.ttypes.Resource.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, resource=None,):
    self.authenticationToken = authenticationToken
    self.resource = resource

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.resource = evernote.edam.type.ttypes.Resource()
          self.resource.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateResource_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.resource is not None:
      oprot.writeFieldBegin('resource', TType.STRUCT, 2)
      self.resource.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateResource_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateResource_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceData_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceData_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceData_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceData_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceByHash_args(object):
  """
  Attributes:
   - authenticationToken
   - noteGuid
   - contentHash
   - withData
   - withRecognition
   - withAlternateData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'noteGuid', None, None, ), # 2
    (3, TType.STRING, 'contentHash', None, None, ), # 3
    (4, TType.BOOL, 'withData', None, None, ), # 4
    (5, TType.BOOL, 'withRecognition', None, None, ), # 5
    (6, TType.BOOL, 'withAlternateData', None, None, ), # 6
  )

  def __init__(self, authenticationToken=None, noteGuid=None, contentHash=None, withData=None, withRecognition=None, withAlternateData=None,):
    self.authenticationToken = authenticationToken
    self.noteGuid = noteGuid
    self.contentHash = contentHash
    self.withData = withData
    self.withRecognition = withRecognition
    self.withAlternateData = withAlternateData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.noteGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.contentHash = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.withData = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.withRecognition = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.withAlternateData = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceByHash_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.noteGuid is not None:
      oprot.writeFieldBegin('noteGuid', TType.STRING, 2)
      oprot.writeString(self.noteGuid)
      oprot.writeFieldEnd()
    if self.contentHash is not None:
      oprot.writeFieldBegin('contentHash', TType.STRING, 3)
      oprot.writeString(self.contentHash)
      oprot.writeFieldEnd()
    if self.withData is not None:
      oprot.writeFieldBegin('withData', TType.BOOL, 4)
      oprot.writeBool(self.withData)
      oprot.writeFieldEnd()
    if self.withRecognition is not None:
      oprot.writeFieldBegin('withRecognition', TType.BOOL, 5)
      oprot.writeBool(self.withRecognition)
      oprot.writeFieldEnd()
    if self.withAlternateData is not None:
      oprot.writeFieldBegin('withAlternateData', TType.BOOL, 6)
      oprot.writeBool(self.withAlternateData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceByHash_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Resource, evernote.edam.type.ttypes.Resource.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Resource()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceByHash_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceRecognition_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceRecognition_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceRecognition_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceRecognition_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceAlternateData_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceAlternateData_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceAlternateData_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceAlternateData_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceAttributes_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceAttributes_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getResourceAttributes_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.ResourceAttributes, evernote.edam.type.ttypes.ResourceAttributes.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, systemException=None, notFoundException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.ResourceAttributes()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getResourceAttributes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 3)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAccountSize_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAccountSize_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAccountSize_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAccountSize_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAds_args(object):
  """
  Attributes:
   - authenticationToken
   - adParameters
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'adParameters', (AdParameters, AdParameters.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, adParameters=None,):
    self.authenticationToken = authenticationToken
    self.adParameters = adParameters

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.adParameters = AdParameters()
          self.adParameters.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAds_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.adParameters is not None:
      oprot.writeFieldBegin('adParameters', TType.STRUCT, 2)
      self.adParameters.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAds_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(evernote.edam.type.ttypes.Ad, evernote.edam.type.ttypes.Ad.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype233, _size230) = iprot.readListBegin()
          for _i234 in xrange(_size230):
            _elem235 = evernote.edam.type.ttypes.Ad()
            _elem235.read(iprot)
            self.success.append(_elem235)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAds_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter236 in self.success:
        iter236.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRandomAd_args(object):
  """
  Attributes:
   - authenticationToken
   - adParameters
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'adParameters', (AdParameters, AdParameters.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, adParameters=None,):
    self.authenticationToken = authenticationToken
    self.adParameters = adParameters

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.adParameters = AdParameters()
          self.adParameters.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRandomAd_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.adParameters is not None:
      oprot.writeFieldBegin('adParameters', TType.STRUCT, 2)
      self.adParameters.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRandomAd_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Ad, evernote.edam.type.ttypes.Ad.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Ad()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRandomAd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPublicNotebook_args(object):
  """
  Attributes:
   - userId
   - publicUri
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'userId', None, None, ), # 1
    (2, TType.STRING, 'publicUri', None, None, ), # 2
  )

  def __init__(self, userId=None, publicUri=None,):
    self.userId = userId
    self.publicUri = publicUri

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.userId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.publicUri = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPublicNotebook_args')
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.I32, 1)
      oprot.writeI32(self.userId)
      oprot.writeFieldEnd()
    if self.publicUri is not None:
      oprot.writeFieldBegin('publicUri', TType.STRING, 2)
      oprot.writeString(self.publicUri)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPublicNotebook_result(object):
  """
  Attributes:
   - success
   - systemException
   - notFoundException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.Notebook, evernote.edam.type.ttypes.Notebook.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, systemException=None, notFoundException=None,):
    self.success = success
    self.systemException = systemException
    self.notFoundException = notFoundException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.Notebook()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPublicNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 1)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createSharedNotebook_args(object):
  """
  Attributes:
   - authenticationToken
   - sharedNotebook
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'sharedNotebook', (evernote.edam.type.ttypes.SharedNotebook, evernote.edam.type.ttypes.SharedNotebook.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, sharedNotebook=None,):
    self.authenticationToken = authenticationToken
    self.sharedNotebook = sharedNotebook

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.sharedNotebook = evernote.edam.type.ttypes.SharedNotebook()
          self.sharedNotebook.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createSharedNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.sharedNotebook is not None:
      oprot.writeFieldBegin('sharedNotebook', TType.STRUCT, 2)
      self.sharedNotebook.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createSharedNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.SharedNotebook, evernote.edam.type.ttypes.SharedNotebook.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.SharedNotebook()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createSharedNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sendMessageToSharedNotebookMembers_args(object):
  """
  Attributes:
   - authenticationToken
   - notebookGuid
   - messageText
   - recipients
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'notebookGuid', None, None, ), # 2
    (3, TType.STRING, 'messageText', None, None, ), # 3
    (4, TType.LIST, 'recipients', (TType.STRING,None), None, ), # 4
  )

  def __init__(self, authenticationToken=None, notebookGuid=None, messageText=None, recipients=None,):
    self.authenticationToken = authenticationToken
    self.notebookGuid = notebookGuid
    self.messageText = messageText
    self.recipients = recipients

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.notebookGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.messageText = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.recipients = []
          (_etype240, _size237) = iprot.readListBegin()
          for _i241 in xrange(_size237):
            _elem242 = iprot.readString();
            self.recipients.append(_elem242)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sendMessageToSharedNotebookMembers_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.notebookGuid is not None:
      oprot.writeFieldBegin('notebookGuid', TType.STRING, 2)
      oprot.writeString(self.notebookGuid)
      oprot.writeFieldEnd()
    if self.messageText is not None:
      oprot.writeFieldBegin('messageText', TType.STRING, 3)
      oprot.writeString(self.messageText)
      oprot.writeFieldEnd()
    if self.recipients is not None:
      oprot.writeFieldBegin('recipients', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.recipients))
      for iter243 in self.recipients:
        oprot.writeString(iter243)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sendMessageToSharedNotebookMembers_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sendMessageToSharedNotebookMembers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSharedNotebooks_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSharedNotebooks_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listSharedNotebooks_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(evernote.edam.type.ttypes.SharedNotebook, evernote.edam.type.ttypes.SharedNotebook.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype247, _size244) = iprot.readListBegin()
          for _i248 in xrange(_size244):
            _elem249 = evernote.edam.type.ttypes.SharedNotebook()
            _elem249.read(iprot)
            self.success.append(_elem249)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listSharedNotebooks_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter250 in self.success:
        iter250.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeSharedNotebooks_args(object):
  """
  Attributes:
   - authenticationToken
   - sharedNotebookIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.LIST, 'sharedNotebookIds', (TType.I64,None), None, ), # 2
  )

  def __init__(self, authenticationToken=None, sharedNotebookIds=None,):
    self.authenticationToken = authenticationToken
    self.sharedNotebookIds = sharedNotebookIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.sharedNotebookIds = []
          (_etype254, _size251) = iprot.readListBegin()
          for _i255 in xrange(_size251):
            _elem256 = iprot.readI64();
            self.sharedNotebookIds.append(_elem256)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeSharedNotebooks_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.sharedNotebookIds is not None:
      oprot.writeFieldBegin('sharedNotebookIds', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.sharedNotebookIds))
      for iter257 in self.sharedNotebookIds:
        oprot.writeI64(iter257)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeSharedNotebooks_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeSharedNotebooks_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createLinkedNotebook_args(object):
  """
  Attributes:
   - authenticationToken
   - linkedNotebook
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'linkedNotebook', (evernote.edam.type.ttypes.LinkedNotebook, evernote.edam.type.ttypes.LinkedNotebook.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, linkedNotebook=None,):
    self.authenticationToken = authenticationToken
    self.linkedNotebook = linkedNotebook

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.linkedNotebook = evernote.edam.type.ttypes.LinkedNotebook()
          self.linkedNotebook.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createLinkedNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.linkedNotebook is not None:
      oprot.writeFieldBegin('linkedNotebook', TType.STRUCT, 2)
      self.linkedNotebook.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createLinkedNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.LinkedNotebook, evernote.edam.type.ttypes.LinkedNotebook.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.LinkedNotebook()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createLinkedNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateLinkedNotebook_args(object):
  """
  Attributes:
   - authenticationToken
   - linkedNotebook
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'linkedNotebook', (evernote.edam.type.ttypes.LinkedNotebook, evernote.edam.type.ttypes.LinkedNotebook.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, linkedNotebook=None,):
    self.authenticationToken = authenticationToken
    self.linkedNotebook = linkedNotebook

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.linkedNotebook = evernote.edam.type.ttypes.LinkedNotebook()
          self.linkedNotebook.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateLinkedNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.linkedNotebook is not None:
      oprot.writeFieldBegin('linkedNotebook', TType.STRUCT, 2)
      self.linkedNotebook.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateLinkedNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateLinkedNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listLinkedNotebooks_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listLinkedNotebooks_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listLinkedNotebooks_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(evernote.edam.type.ttypes.LinkedNotebook, evernote.edam.type.ttypes.LinkedNotebook.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype261, _size258) = iprot.readListBegin()
          for _i262 in xrange(_size258):
            _elem263 = evernote.edam.type.ttypes.LinkedNotebook()
            _elem263.read(iprot)
            self.success.append(_elem263)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listLinkedNotebooks_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter264 in self.success:
        iter264.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeLinkedNotebook_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeLinkedNotebook_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class expungeLinkedNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('expungeLinkedNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authenticateToSharedNotebook_args(object):
  """
  Attributes:
   - shareKey
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'shareKey', None, None, ), # 1
    (2, TType.STRING, 'authenticationToken', None, None, ), # 2
  )

  def __init__(self, shareKey=None, authenticationToken=None,):
    self.shareKey = shareKey
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.shareKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authenticateToSharedNotebook_args')
    if self.shareKey is not None:
      oprot.writeFieldBegin('shareKey', TType.STRING, 1)
      oprot.writeString(self.shareKey)
      oprot.writeFieldEnd()
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 2)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authenticateToSharedNotebook_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.userstore.ttypes.AuthenticationResult, evernote.edam.userstore.ttypes.AuthenticationResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.userstore.ttypes.AuthenticationResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authenticateToSharedNotebook_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSharedNotebookByAuth_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSharedNotebookByAuth_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSharedNotebookByAuth_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.SharedNotebook, evernote.edam.type.ttypes.SharedNotebook.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.SharedNotebook()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSharedNotebookByAuth_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class emailNote_args(object):
  """
  Attributes:
   - authenticationToken
   - parameters
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRUCT, 'parameters', (NoteEmailParameters, NoteEmailParameters.thrift_spec), None, ), # 2
  )

  def __init__(self, authenticationToken=None, parameters=None,):
    self.authenticationToken = authenticationToken
    self.parameters = parameters

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.parameters = NoteEmailParameters()
          self.parameters.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('emailNote_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.STRUCT, 2)
      self.parameters.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class emailNote_result(object):
  """
  Attributes:
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, userException=None, notFoundException=None, systemException=None,):
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('emailNote_result')
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class shareNote_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('shareNote_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class shareNote_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('shareNote_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopSharingNote_args(object):
  """
  Attributes:
   - authenticationToken
   - guid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
    (2, TType.STRING, 'guid', None, None, ), # 2
  )

  def __init__(self, authenticationToken=None, guid=None,):
    self.authenticationToken = authenticationToken
    self.guid = guid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopSharingNote_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 2)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopSharingNote_result(object):
  """
  Attributes:
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, userException=None, notFoundException=None, systemException=None,):
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopSharingNote_result')
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authenticateToSharedNote_args(object):
  """
  Attributes:
   - guid
   - noteKey
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRING, 'noteKey', None, None, ), # 2
  )

  def __init__(self, guid=None, noteKey=None,):
    self.guid = guid
    self.noteKey = noteKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.noteKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authenticateToSharedNote_args')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.noteKey is not None:
      oprot.writeFieldBegin('noteKey', TType.STRING, 2)
      oprot.writeString(self.noteKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authenticateToSharedNote_result(object):
  """
  Attributes:
   - success
   - userException
   - notFoundException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.userstore.ttypes.AuthenticationResult, evernote.edam.userstore.ttypes.AuthenticationResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, userException=None, notFoundException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.notFoundException = notFoundException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.userstore.ttypes.AuthenticationResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authenticateToSharedNote_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 2)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 3)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

########NEW FILE########
__FILENAME__ = ttypes
#
# Autogenerated by Thrift Compiler (0.5.0-en-262021)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import evernote.edam.userstore.ttypes
import evernote.edam.type.ttypes
import evernote.edam.error.ttypes
import evernote.edam.limits.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None



class SyncState(object):
  """
   This structure encapsulates the information about the state of the
   user's account for the purpose of "state based" synchronization.
  <dl>
   <dt>currentTime</dt>
     <dd>
     The server's current date and time.
     </dd>
  
   <dt>fullSyncBefore</dt>
     <dd>
     The cutoff date and time for client caches to be
     updated via incremental synchronization.  Any clients that were last
     synched with the server before this date/time must do a full resync of all
     objects.  This cutoff point will change over time as archival data is
     deleted or special circumstances on the service require resynchronization.
     </dd>
  
   <dt>updateCount</dt>
     <dd>
     Indicates the total number of transactions that have
     been committed within the account.  This reflects (for example) the
     number of discrete additions or modifications that have been made to
     the data in this account (tags, notes, resources, etc.).
     This number is the "high water mark" for Update Sequence Numbers (USN)
     within the account.
     </dd>
  
   <dt>uploaded</dt>
     <dd>
     The total number of bytes that have been uploaded to
     this account in the current monthly period.  This can be compared against
     Accounting.uploadLimit (from the UserStore) to determine how close the user
     is to their monthly upload limit.
     This value may not be present if the SyncState has been retrieved by
     a caller that only has read access to the account.
     </dd>
   </dl>
  
  Attributes:
   - currentTime
   - fullSyncBefore
   - updateCount
   - uploaded
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'currentTime', None, None, ), # 1
    (2, TType.I64, 'fullSyncBefore', None, None, ), # 2
    (3, TType.I32, 'updateCount', None, None, ), # 3
    (4, TType.I64, 'uploaded', None, None, ), # 4
  )

  def __init__(self, currentTime=None, fullSyncBefore=None, updateCount=None, uploaded=None,):
    self.currentTime = currentTime
    self.fullSyncBefore = fullSyncBefore
    self.updateCount = updateCount
    self.uploaded = uploaded

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.currentTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.fullSyncBefore = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.updateCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.uploaded = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SyncState')
    if self.currentTime is not None:
      oprot.writeFieldBegin('currentTime', TType.I64, 1)
      oprot.writeI64(self.currentTime)
      oprot.writeFieldEnd()
    if self.fullSyncBefore is not None:
      oprot.writeFieldBegin('fullSyncBefore', TType.I64, 2)
      oprot.writeI64(self.fullSyncBefore)
      oprot.writeFieldEnd()
    if self.updateCount is not None:
      oprot.writeFieldBegin('updateCount', TType.I32, 3)
      oprot.writeI32(self.updateCount)
      oprot.writeFieldEnd()
    if self.uploaded is not None:
      oprot.writeFieldBegin('uploaded', TType.I64, 4)
      oprot.writeI64(self.uploaded)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.currentTime is None:
      raise TProtocol.TProtocolException(message='Required field currentTime is unset!')
    if self.fullSyncBefore is None:
      raise TProtocol.TProtocolException(message='Required field fullSyncBefore is unset!')
    if self.updateCount is None:
      raise TProtocol.TProtocolException(message='Required field updateCount is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SyncChunk(object):
  """
   This structure is given out by the NoteStore when a client asks to
   receive the current state of an account.  The client asks for the server's
   state one chunk at a time in order to allow clients to retrieve the state
   of a large account without needing to transfer the entire account in
   a single message.
  
   The server always gives SyncChunks using an ascending series of Update
   Sequence Numbers (USNs).
  
  <dl>
   <dt>currentTime</dt>
     <dd>
     The server's current date and time.
     </dd>
  
   <dt>chunkHighUSN</dt>
     <dd>
     The highest USN for any of the data objects represented
     in this sync chunk.  If there are no objects in the chunk, this will not be
     set.
     </dd>
  
   <dt>updateCount</dt>
     <dd>
     The total number of updates that have been performed in
     the service for this account.  This is equal to the highest USN within the
     account at the point that this SyncChunk was generated.  If updateCount
     and chunkHighUSN are identical, that means that this is the last chunk
     in the account ... there is no more recent information.
     </dd>
  
   <dt>notes</dt>
     <dd>
     If present, this is a list of non-expunged notes that
     have a USN in this chunk.  This will include notes that are "deleted"
     but not expunged (i.e. in the trash).  The notes will include their list
     of tags and resources, but the resource content and recognition data
     will not be supplied.
     </dd>
  
   <dt>notebooks</dt>
     <dd>
     If present, this is a list of non-expunged notebooks that
     have a USN in this chunk.  This will include notebooks that are "deleted"
     but not expunged (i.e. in the trash).
     </dd>
  
   <dt>tags</dt>
     <dd>
     If present, this is a list of the non-expunged tags that have a
     USN in this chunk.
     </dd>
  
   <dt>searches</dt>
     <dd>
     If present, this is a list of non-expunged searches that
     have a USN in this chunk.
     </dd>
  
   <dt>resources</dt>
     <dd>
     If present, this is a list of the non-expunged resources
     that have a USN in this chunk.  This will include the metadata for each
     resource, but not its binary contents or recognition data, which must be
     retrieved separately.
     </dd>
  
   <dt>expungedNotes</dt>
     <dd>
     If present, the GUIDs of all of the notes that were
     permanently expunged in this chunk.
     </dd>
  
   <dt>expungedNotebooks</dt>
     <dd>
     If present, the GUIDs of all of the notebooks that
     were permanently expunged in this chunk.  When a notebook is expunged,
     this implies that all of its child notes (and their resources) were
     also expunged.
     </dd>
  
   <dt>expungedTags</dt>
     <dd>
     If present, the GUIDs of all of the tags that were
     permanently expunged in this chunk.
     </dd>
  
   <dt>expungedSearches</dt>
     <dd>
     If present, the GUIDs of all of the saved searches
     that were permanently expunged in this chunk.
     </dd>
  
   <dt>linkedNotebooks</dt>
     <dd>
     If present, this is a list of non-expunged LinkedNotebooks that
     have a USN in this chunk.
     </dd>
  
   <dt>expungedLinkedNotebooks</dt>
     <dd>
     If present, the GUIDs of all of the LinkedNotebooks
     that were permanently expunged in this chunk.
     </dd>
   </dl>
  
  Attributes:
   - currentTime
   - chunkHighUSN
   - updateCount
   - notes
   - notebooks
   - tags
   - searches
   - resources
   - expungedNotes
   - expungedNotebooks
   - expungedTags
   - expungedSearches
   - linkedNotebooks
   - expungedLinkedNotebooks
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'currentTime', None, None, ), # 1
    (2, TType.I32, 'chunkHighUSN', None, None, ), # 2
    (3, TType.I32, 'updateCount', None, None, ), # 3
    (4, TType.LIST, 'notes', (TType.STRUCT,(evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec)), None, ), # 4
    (5, TType.LIST, 'notebooks', (TType.STRUCT,(evernote.edam.type.ttypes.Notebook, evernote.edam.type.ttypes.Notebook.thrift_spec)), None, ), # 5
    (6, TType.LIST, 'tags', (TType.STRUCT,(evernote.edam.type.ttypes.Tag, evernote.edam.type.ttypes.Tag.thrift_spec)), None, ), # 6
    (7, TType.LIST, 'searches', (TType.STRUCT,(evernote.edam.type.ttypes.SavedSearch, evernote.edam.type.ttypes.SavedSearch.thrift_spec)), None, ), # 7
    (8, TType.LIST, 'resources', (TType.STRUCT,(evernote.edam.type.ttypes.Resource, evernote.edam.type.ttypes.Resource.thrift_spec)), None, ), # 8
    (9, TType.LIST, 'expungedNotes', (TType.STRING,None), None, ), # 9
    (10, TType.LIST, 'expungedNotebooks', (TType.STRING,None), None, ), # 10
    (11, TType.LIST, 'expungedTags', (TType.STRING,None), None, ), # 11
    (12, TType.LIST, 'expungedSearches', (TType.STRING,None), None, ), # 12
    (13, TType.LIST, 'linkedNotebooks', (TType.STRUCT,(evernote.edam.type.ttypes.LinkedNotebook, evernote.edam.type.ttypes.LinkedNotebook.thrift_spec)), None, ), # 13
    (14, TType.LIST, 'expungedLinkedNotebooks', (TType.STRING,None), None, ), # 14
  )

  def __init__(self, currentTime=None, chunkHighUSN=None, updateCount=None, notes=None, notebooks=None, tags=None, searches=None, resources=None, expungedNotes=None, expungedNotebooks=None, expungedTags=None, expungedSearches=None, linkedNotebooks=None, expungedLinkedNotebooks=None,):
    self.currentTime = currentTime
    self.chunkHighUSN = chunkHighUSN
    self.updateCount = updateCount
    self.notes = notes
    self.notebooks = notebooks
    self.tags = tags
    self.searches = searches
    self.resources = resources
    self.expungedNotes = expungedNotes
    self.expungedNotebooks = expungedNotebooks
    self.expungedTags = expungedTags
    self.expungedSearches = expungedSearches
    self.linkedNotebooks = linkedNotebooks
    self.expungedLinkedNotebooks = expungedLinkedNotebooks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.currentTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.chunkHighUSN = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.updateCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.notes = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = evernote.edam.type.ttypes.Note()
            _elem5.read(iprot)
            self.notes.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.notebooks = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = evernote.edam.type.ttypes.Notebook()
            _elem11.read(iprot)
            self.notebooks.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.tags = []
          (_etype15, _size12) = iprot.readListBegin()
          for _i16 in xrange(_size12):
            _elem17 = evernote.edam.type.ttypes.Tag()
            _elem17.read(iprot)
            self.tags.append(_elem17)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.searches = []
          (_etype21, _size18) = iprot.readListBegin()
          for _i22 in xrange(_size18):
            _elem23 = evernote.edam.type.ttypes.SavedSearch()
            _elem23.read(iprot)
            self.searches.append(_elem23)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.resources = []
          (_etype27, _size24) = iprot.readListBegin()
          for _i28 in xrange(_size24):
            _elem29 = evernote.edam.type.ttypes.Resource()
            _elem29.read(iprot)
            self.resources.append(_elem29)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.expungedNotes = []
          (_etype33, _size30) = iprot.readListBegin()
          for _i34 in xrange(_size30):
            _elem35 = iprot.readString();
            self.expungedNotes.append(_elem35)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.LIST:
          self.expungedNotebooks = []
          (_etype39, _size36) = iprot.readListBegin()
          for _i40 in xrange(_size36):
            _elem41 = iprot.readString();
            self.expungedNotebooks.append(_elem41)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.expungedTags = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = iprot.readString();
            self.expungedTags.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.expungedSearches = []
          (_etype51, _size48) = iprot.readListBegin()
          for _i52 in xrange(_size48):
            _elem53 = iprot.readString();
            self.expungedSearches.append(_elem53)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.LIST:
          self.linkedNotebooks = []
          (_etype57, _size54) = iprot.readListBegin()
          for _i58 in xrange(_size54):
            _elem59 = evernote.edam.type.ttypes.LinkedNotebook()
            _elem59.read(iprot)
            self.linkedNotebooks.append(_elem59)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.LIST:
          self.expungedLinkedNotebooks = []
          (_etype63, _size60) = iprot.readListBegin()
          for _i64 in xrange(_size60):
            _elem65 = iprot.readString();
            self.expungedLinkedNotebooks.append(_elem65)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SyncChunk')
    if self.currentTime is not None:
      oprot.writeFieldBegin('currentTime', TType.I64, 1)
      oprot.writeI64(self.currentTime)
      oprot.writeFieldEnd()
    if self.chunkHighUSN is not None:
      oprot.writeFieldBegin('chunkHighUSN', TType.I32, 2)
      oprot.writeI32(self.chunkHighUSN)
      oprot.writeFieldEnd()
    if self.updateCount is not None:
      oprot.writeFieldBegin('updateCount', TType.I32, 3)
      oprot.writeI32(self.updateCount)
      oprot.writeFieldEnd()
    if self.notes is not None:
      oprot.writeFieldBegin('notes', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.notes))
      for iter66 in self.notes:
        iter66.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.notebooks is not None:
      oprot.writeFieldBegin('notebooks', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.notebooks))
      for iter67 in self.notebooks:
        iter67.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.tags is not None:
      oprot.writeFieldBegin('tags', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.tags))
      for iter68 in self.tags:
        iter68.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.searches is not None:
      oprot.writeFieldBegin('searches', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.searches))
      for iter69 in self.searches:
        iter69.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.resources is not None:
      oprot.writeFieldBegin('resources', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.resources))
      for iter70 in self.resources:
        iter70.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expungedNotes is not None:
      oprot.writeFieldBegin('expungedNotes', TType.LIST, 9)
      oprot.writeListBegin(TType.STRING, len(self.expungedNotes))
      for iter71 in self.expungedNotes:
        oprot.writeString(iter71)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expungedNotebooks is not None:
      oprot.writeFieldBegin('expungedNotebooks', TType.LIST, 10)
      oprot.writeListBegin(TType.STRING, len(self.expungedNotebooks))
      for iter72 in self.expungedNotebooks:
        oprot.writeString(iter72)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expungedTags is not None:
      oprot.writeFieldBegin('expungedTags', TType.LIST, 11)
      oprot.writeListBegin(TType.STRING, len(self.expungedTags))
      for iter73 in self.expungedTags:
        oprot.writeString(iter73)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expungedSearches is not None:
      oprot.writeFieldBegin('expungedSearches', TType.LIST, 12)
      oprot.writeListBegin(TType.STRING, len(self.expungedSearches))
      for iter74 in self.expungedSearches:
        oprot.writeString(iter74)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.linkedNotebooks is not None:
      oprot.writeFieldBegin('linkedNotebooks', TType.LIST, 13)
      oprot.writeListBegin(TType.STRUCT, len(self.linkedNotebooks))
      for iter75 in self.linkedNotebooks:
        iter75.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expungedLinkedNotebooks is not None:
      oprot.writeFieldBegin('expungedLinkedNotebooks', TType.LIST, 14)
      oprot.writeListBegin(TType.STRING, len(self.expungedLinkedNotebooks))
      for iter76 in self.expungedLinkedNotebooks:
        oprot.writeString(iter76)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.currentTime is None:
      raise TProtocol.TProtocolException(message='Required field currentTime is unset!')
    if self.updateCount is None:
      raise TProtocol.TProtocolException(message='Required field updateCount is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SyncChunkFilter(object):
  """
   This structure is used with the 'getFilteredSyncChunk' call to provide
   fine-grained control over the data that's returned when a client needs
   to synchronize with the service. Each flag in this structure specifies
   whether to include one class of data in the results of that call.
  
  <dl>
   <dt>includeNotes</dt>
     <dd>
     If true, then the server will include the SyncChunks.notes field
     </dd>
  
   <dt>includeNoteResources</dt>
     <dd>
     If true, then the server will include the 'resources' field on all of
     the Notes that are in SyncChunk.notes.
     If 'includeNotes' is false, then this will have no effect.
     </dd>
  
   <dt>includeNoteAttributes</dt>
     <dd>
     If true, then the server will include the 'attributes' field on all of
     the Notes that are in SyncChunks.notes.
     If 'includeNotes' is false, then this will have no effect.
     </dd>
  
   <dt>includeNotebooks</dt>
     <dd>
     If true, then the server will include the SyncChunks.notebooks field
     </dd>
  
   <dt>includeTags</dt>
     <dd>
     If true, then the server will include the SyncChunks.tags field
     </dd>
  
   <dt>includeSearches</dt>
     <dd>
     If true, then the server will include the SyncChunks.searches field
     </dd>
  
   <dt>includeResources</dt>
     <dd>
     If true, then the server will include the SyncChunks.resources field.
     Since the Resources are also provided with their Note
     (in the Notes.resources list), this is primarily useful for clients that
     want to watch for changes to individual Resources due to recognition data
     being added.
     </dd>
  
   <dt>includeLinkedNotebooks</dt>
     <dd>
     If true, then the server will include the SyncChunks.linkedNotebooks field.
     </dd>
  
   <dt>includeExpunged</dt>
     <dd>
     If true, then the server will include the 'expunged' data for any type
     of included data.  For example, if 'includeTags' and 'includeExpunged'
     are both true, then the SyncChunks.expungedTags field will be set with
     the GUIDs of tags that have been expunged from the server.
     </dd>
  
   <dt>includeNoteApplicationDataFullMap</dt>
     <dd>
     If true, then the values for the applicationData map will be filled
     in, assuming notes and note attributes are being returned.  Otherwise,
     only the keysOnly field will be filled in.
     </dd>
  
   <dt>includeResourceApplicationDataFullMap</dt>
     <dd>
     If true, then the fullMap values for the applicationData map will be
     filled in, assuming resources and resource attributes are being returned
     (includeResources is true).  Otherwise, only the keysOnly field will be
     filled in.
     </dd>
  
   <dt>includeNoteResourceApplicationDataFullMap</dt>
     <dd>
     If true, then the fullMap values for the applicationData map will be
     filled in for resources found inside of notes, assuming resources are
     being returned in notes (includeNoteResources is true).  Otherwise,
     only the keysOnly field will be filled in.
     </dd>
  
   <dt>requireNoteContentClass</dt>
     <dd>
     If set, then only send notes whose content class matches this value.
     The value can be a literal match or, if the last character is an
     asterisk, a prefix match.
     </dd>
  
   </dl>
  
  Attributes:
   - includeNotes
   - includeNoteResources
   - includeNoteAttributes
   - includeNotebooks
   - includeTags
   - includeSearches
   - includeResources
   - includeLinkedNotebooks
   - includeExpunged
   - includeNoteApplicationDataFullMap
   - includeResourceApplicationDataFullMap
   - includeNoteResourceApplicationDataFullMap
   - requireNoteContentClass
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'includeNotes', None, None, ), # 1
    (2, TType.BOOL, 'includeNoteResources', None, None, ), # 2
    (3, TType.BOOL, 'includeNoteAttributes', None, None, ), # 3
    (4, TType.BOOL, 'includeNotebooks', None, None, ), # 4
    (5, TType.BOOL, 'includeTags', None, None, ), # 5
    (6, TType.BOOL, 'includeSearches', None, None, ), # 6
    (7, TType.BOOL, 'includeResources', None, None, ), # 7
    (8, TType.BOOL, 'includeLinkedNotebooks', None, None, ), # 8
    (9, TType.BOOL, 'includeExpunged', None, None, ), # 9
    (10, TType.BOOL, 'includeNoteApplicationDataFullMap', None, None, ), # 10
    (11, TType.STRING, 'requireNoteContentClass', None, None, ), # 11
    (12, TType.BOOL, 'includeResourceApplicationDataFullMap', None, None, ), # 12
    (13, TType.BOOL, 'includeNoteResourceApplicationDataFullMap', None, None, ), # 13
  )

  def __init__(self, includeNotes=None, includeNoteResources=None, includeNoteAttributes=None, includeNotebooks=None, includeTags=None, includeSearches=None, includeResources=None, includeLinkedNotebooks=None, includeExpunged=None, includeNoteApplicationDataFullMap=None, includeResourceApplicationDataFullMap=None, includeNoteResourceApplicationDataFullMap=None, requireNoteContentClass=None,):
    self.includeNotes = includeNotes
    self.includeNoteResources = includeNoteResources
    self.includeNoteAttributes = includeNoteAttributes
    self.includeNotebooks = includeNotebooks
    self.includeTags = includeTags
    self.includeSearches = includeSearches
    self.includeResources = includeResources
    self.includeLinkedNotebooks = includeLinkedNotebooks
    self.includeExpunged = includeExpunged
    self.includeNoteApplicationDataFullMap = includeNoteApplicationDataFullMap
    self.includeResourceApplicationDataFullMap = includeResourceApplicationDataFullMap
    self.includeNoteResourceApplicationDataFullMap = includeNoteResourceApplicationDataFullMap
    self.requireNoteContentClass = requireNoteContentClass

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.includeNotes = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.includeNoteResources = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.includeNoteAttributes = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.includeNotebooks = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.includeTags = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.includeSearches = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.includeResources = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.includeLinkedNotebooks = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.includeExpunged = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.includeNoteApplicationDataFullMap = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.includeResourceApplicationDataFullMap = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BOOL:
          self.includeNoteResourceApplicationDataFullMap = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.requireNoteContentClass = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SyncChunkFilter')
    if self.includeNotes is not None:
      oprot.writeFieldBegin('includeNotes', TType.BOOL, 1)
      oprot.writeBool(self.includeNotes)
      oprot.writeFieldEnd()
    if self.includeNoteResources is not None:
      oprot.writeFieldBegin('includeNoteResources', TType.BOOL, 2)
      oprot.writeBool(self.includeNoteResources)
      oprot.writeFieldEnd()
    if self.includeNoteAttributes is not None:
      oprot.writeFieldBegin('includeNoteAttributes', TType.BOOL, 3)
      oprot.writeBool(self.includeNoteAttributes)
      oprot.writeFieldEnd()
    if self.includeNotebooks is not None:
      oprot.writeFieldBegin('includeNotebooks', TType.BOOL, 4)
      oprot.writeBool(self.includeNotebooks)
      oprot.writeFieldEnd()
    if self.includeTags is not None:
      oprot.writeFieldBegin('includeTags', TType.BOOL, 5)
      oprot.writeBool(self.includeTags)
      oprot.writeFieldEnd()
    if self.includeSearches is not None:
      oprot.writeFieldBegin('includeSearches', TType.BOOL, 6)
      oprot.writeBool(self.includeSearches)
      oprot.writeFieldEnd()
    if self.includeResources is not None:
      oprot.writeFieldBegin('includeResources', TType.BOOL, 7)
      oprot.writeBool(self.includeResources)
      oprot.writeFieldEnd()
    if self.includeLinkedNotebooks is not None:
      oprot.writeFieldBegin('includeLinkedNotebooks', TType.BOOL, 8)
      oprot.writeBool(self.includeLinkedNotebooks)
      oprot.writeFieldEnd()
    if self.includeExpunged is not None:
      oprot.writeFieldBegin('includeExpunged', TType.BOOL, 9)
      oprot.writeBool(self.includeExpunged)
      oprot.writeFieldEnd()
    if self.includeNoteApplicationDataFullMap is not None:
      oprot.writeFieldBegin('includeNoteApplicationDataFullMap', TType.BOOL, 10)
      oprot.writeBool(self.includeNoteApplicationDataFullMap)
      oprot.writeFieldEnd()
    if self.requireNoteContentClass is not None:
      oprot.writeFieldBegin('requireNoteContentClass', TType.STRING, 11)
      oprot.writeString(self.requireNoteContentClass)
      oprot.writeFieldEnd()
    if self.includeResourceApplicationDataFullMap is not None:
      oprot.writeFieldBegin('includeResourceApplicationDataFullMap', TType.BOOL, 12)
      oprot.writeBool(self.includeResourceApplicationDataFullMap)
      oprot.writeFieldEnd()
    if self.includeNoteResourceApplicationDataFullMap is not None:
      oprot.writeFieldBegin('includeNoteResourceApplicationDataFullMap', TType.BOOL, 13)
      oprot.writeBool(self.includeNoteResourceApplicationDataFullMap)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteFilter(object):
  """
   A list of criteria that are used to indicate which notes are desired from
   the account.  This is used in queries to the NoteStore to determine
   which notes should be retrieved.
  
  <dl>
   <dt>order</dt>
     <dd>
     The NoteSortOrder value indicating what criterion should be
     used to sort the results of the filter.
     </dd>
  
   <dt>ascending</dt>
     <dd>
     If true, the results will be ascending in the requested
     sort order.  If false, the results will be descending.
     </dd>
  
   <dt>words</dt>
     <dd>
     If present, a search query string that will filter the set of notes to be returned.
     Accepts the full search grammar documented in the Evernote API Overview.
     </dd>
  
   <dt>notebookGuid</dt>
     <dd>
     If present, the Guid of the notebook that must contain
     the notes.
     </dd>
  
   <dt>tagGuids</dt>
     <dd>
     If present, the list of tags (by GUID) that must be present
     on the notes.
     </dd>
  
   <dt>timeZone</dt>
     <dd>
     The zone ID for the user, which will be used to interpret
     any dates or times in the queries that do not include their desired zone
     information.
     For example, if a query requests notes created "yesterday", this
     will be evaluated from the provided time zone, if provided.
     The format must be encoded as a standard zone ID such as
     "America/Los_Angeles".
     </dd>
  
   <dt>inactive</dt>
     <dd>
     If true, then only notes that are not active (i.e. notes in
     the Trash) will be returned. Otherwise, only active notes will be returned.
     There is no way to find both active and inactive notes in a single query.
     </dd>
   </dl>
  
  Attributes:
   - order
   - ascending
   - words
   - notebookGuid
   - tagGuids
   - timeZone
   - inactive
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'order', None, None, ), # 1
    (2, TType.BOOL, 'ascending', None, None, ), # 2
    (3, TType.STRING, 'words', None, None, ), # 3
    (4, TType.STRING, 'notebookGuid', None, None, ), # 4
    (5, TType.LIST, 'tagGuids', (TType.STRING,None), None, ), # 5
    (6, TType.STRING, 'timeZone', None, None, ), # 6
    (7, TType.BOOL, 'inactive', None, None, ), # 7
  )

  def __init__(self, order=None, ascending=None, words=None, notebookGuid=None, tagGuids=None, timeZone=None, inactive=None,):
    self.order = order
    self.ascending = ascending
    self.words = words
    self.notebookGuid = notebookGuid
    self.tagGuids = tagGuids
    self.timeZone = timeZone
    self.inactive = inactive

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.order = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.ascending = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.words = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.notebookGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.tagGuids = []
          (_etype80, _size77) = iprot.readListBegin()
          for _i81 in xrange(_size77):
            _elem82 = iprot.readString();
            self.tagGuids.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.timeZone = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.inactive = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteFilter')
    if self.order is not None:
      oprot.writeFieldBegin('order', TType.I32, 1)
      oprot.writeI32(self.order)
      oprot.writeFieldEnd()
    if self.ascending is not None:
      oprot.writeFieldBegin('ascending', TType.BOOL, 2)
      oprot.writeBool(self.ascending)
      oprot.writeFieldEnd()
    if self.words is not None:
      oprot.writeFieldBegin('words', TType.STRING, 3)
      oprot.writeString(self.words)
      oprot.writeFieldEnd()
    if self.notebookGuid is not None:
      oprot.writeFieldBegin('notebookGuid', TType.STRING, 4)
      oprot.writeString(self.notebookGuid)
      oprot.writeFieldEnd()
    if self.tagGuids is not None:
      oprot.writeFieldBegin('tagGuids', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.tagGuids))
      for iter83 in self.tagGuids:
        oprot.writeString(iter83)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timeZone is not None:
      oprot.writeFieldBegin('timeZone', TType.STRING, 6)
      oprot.writeString(self.timeZone)
      oprot.writeFieldEnd()
    if self.inactive is not None:
      oprot.writeFieldBegin('inactive', TType.BOOL, 7)
      oprot.writeBool(self.inactive)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteList(object):
  """
   A small structure for returning a list of notes out of a larger set.
  
  <dl>
   <dt>startIndex</dt>
     <dd>
     The starting index within the overall set of notes.  This
     is also the number of notes that are "before" this list in the set.
     </dd>
  
   <dt>totalNotes</dt>
     <dd>
     The number of notes in the larger set.  This can be used
     to calculate how many notes are "after" this note in the set.
     (I.e.  remaining = totalNotes - (startIndex + notes.length)  )
     </dd>
  
   <dt>notes</dt>
     <dd>
     The list of notes from this range.  The Notes will include all
     metadata (attributes, resources, etc.), but will not include the ENML
     content of the note or the binary contents of any resources.
     </dd>
  
   <dt>stoppedWords</dt>
     <dd>
     If the NoteList was produced using a text based search
     query that included words that are not indexed or searched by the service,
     this will include a list of those ignored words.
     </dd>
  
   <dt>searchedWords</dt>
     <dd>
     If the NoteList was produced using a text based search
     query that included viable search words or quoted expressions, this will
     include a list of those words.  Any stopped words will not be included
     in this list.
     </dd>
  
   <dt>updateCount</dt>
     <dd>
     Indicates the total number of transactions that have
     been committed within the account.  This reflects (for example) the
     number of discrete additions or modifications that have been made to
     the data in this account (tags, notes, resources, etc.).
     This number is the "high water mark" for Update Sequence Numbers (USN)
     within the account.
     </dd>
   </dl>
  
  Attributes:
   - startIndex
   - totalNotes
   - notes
   - stoppedWords
   - searchedWords
   - updateCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'startIndex', None, None, ), # 1
    (2, TType.I32, 'totalNotes', None, None, ), # 2
    (3, TType.LIST, 'notes', (TType.STRUCT,(evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'stoppedWords', (TType.STRING,None), None, ), # 4
    (5, TType.LIST, 'searchedWords', (TType.STRING,None), None, ), # 5
    (6, TType.I32, 'updateCount', None, None, ), # 6
  )

  def __init__(self, startIndex=None, totalNotes=None, notes=None, stoppedWords=None, searchedWords=None, updateCount=None,):
    self.startIndex = startIndex
    self.totalNotes = totalNotes
    self.notes = notes
    self.stoppedWords = stoppedWords
    self.searchedWords = searchedWords
    self.updateCount = updateCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.startIndex = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.totalNotes = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.notes = []
          (_etype87, _size84) = iprot.readListBegin()
          for _i88 in xrange(_size84):
            _elem89 = evernote.edam.type.ttypes.Note()
            _elem89.read(iprot)
            self.notes.append(_elem89)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.stoppedWords = []
          (_etype93, _size90) = iprot.readListBegin()
          for _i94 in xrange(_size90):
            _elem95 = iprot.readString();
            self.stoppedWords.append(_elem95)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.searchedWords = []
          (_etype99, _size96) = iprot.readListBegin()
          for _i100 in xrange(_size96):
            _elem101 = iprot.readString();
            self.searchedWords.append(_elem101)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.updateCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteList')
    if self.startIndex is not None:
      oprot.writeFieldBegin('startIndex', TType.I32, 1)
      oprot.writeI32(self.startIndex)
      oprot.writeFieldEnd()
    if self.totalNotes is not None:
      oprot.writeFieldBegin('totalNotes', TType.I32, 2)
      oprot.writeI32(self.totalNotes)
      oprot.writeFieldEnd()
    if self.notes is not None:
      oprot.writeFieldBegin('notes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.notes))
      for iter102 in self.notes:
        iter102.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.stoppedWords is not None:
      oprot.writeFieldBegin('stoppedWords', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.stoppedWords))
      for iter103 in self.stoppedWords:
        oprot.writeString(iter103)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.searchedWords is not None:
      oprot.writeFieldBegin('searchedWords', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.searchedWords))
      for iter104 in self.searchedWords:
        oprot.writeString(iter104)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.updateCount is not None:
      oprot.writeFieldBegin('updateCount', TType.I32, 6)
      oprot.writeI32(self.updateCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.startIndex is None:
      raise TProtocol.TProtocolException(message='Required field startIndex is unset!')
    if self.totalNotes is None:
      raise TProtocol.TProtocolException(message='Required field totalNotes is unset!')
    if self.notes is None:
      raise TProtocol.TProtocolException(message='Required field notes is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteMetadata(object):
  """
  This structure is used in the set of results returned by the
  findNotesMetadata function.  It represents the high-level information about
  a single Note, without some of the larger deep structure.  This allows
  for the information about a list of Notes to be returned relatively quickly
  with less marshalling and data transfer to remote clients.
  Most fields in this structure are identical to the corresponding field in
  the Note structure, with the exception of:
  
  <dl>
  <dt>largestResourceMime</dt>
    <dd>If set, then this will contain the MIME type of the largest Resource
    (in bytes) within the Note.  This may be useful, for example, to choose
    an appropriate icon or thumbnail to represent the Note.
    </dd>
  
  <dt>largestResourceSize</dt>
   <dd>If set, this will contain the size of the largest Resource file, in
   bytes, within the Note.  This may be useful, for example, to decide whether
   to ask the server for a thumbnail to represent the Note.
   </dd>
  </dl>
  
  Attributes:
   - guid
   - title
   - contentLength
   - created
   - updated
   - updateSequenceNum
   - notebookGuid
   - tagGuids
   - attributes
   - largestResourceMime
   - largestResourceSize
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRING, 'title', None, None, ), # 2
    None, # 3
    None, # 4
    (5, TType.I32, 'contentLength', None, None, ), # 5
    (6, TType.I64, 'created', None, None, ), # 6
    (7, TType.I64, 'updated', None, None, ), # 7
    None, # 8
    None, # 9
    (10, TType.I32, 'updateSequenceNum', None, None, ), # 10
    (11, TType.STRING, 'notebookGuid', None, None, ), # 11
    (12, TType.LIST, 'tagGuids', (TType.STRING,None), None, ), # 12
    None, # 13
    (14, TType.STRUCT, 'attributes', (evernote.edam.type.ttypes.NoteAttributes, evernote.edam.type.ttypes.NoteAttributes.thrift_spec), None, ), # 14
    None, # 15
    None, # 16
    None, # 17
    None, # 18
    None, # 19
    (20, TType.STRING, 'largestResourceMime', None, None, ), # 20
    (21, TType.I32, 'largestResourceSize', None, None, ), # 21
  )

  def __init__(self, guid=None, title=None, contentLength=None, created=None, updated=None, updateSequenceNum=None, notebookGuid=None, tagGuids=None, attributes=None, largestResourceMime=None, largestResourceSize=None,):
    self.guid = guid
    self.title = title
    self.contentLength = contentLength
    self.created = created
    self.updated = updated
    self.updateSequenceNum = updateSequenceNum
    self.notebookGuid = notebookGuid
    self.tagGuids = tagGuids
    self.attributes = attributes
    self.largestResourceMime = largestResourceMime
    self.largestResourceSize = largestResourceSize

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.contentLength = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.created = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.updated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.notebookGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.tagGuids = []
          (_etype108, _size105) = iprot.readListBegin()
          for _i109 in xrange(_size105):
            _elem110 = iprot.readString();
            self.tagGuids.append(_elem110)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.attributes = evernote.edam.type.ttypes.NoteAttributes()
          self.attributes.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.STRING:
          self.largestResourceMime = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.I32:
          self.largestResourceSize = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteMetadata')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.title is not None:
      oprot.writeFieldBegin('title', TType.STRING, 2)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    if self.contentLength is not None:
      oprot.writeFieldBegin('contentLength', TType.I32, 5)
      oprot.writeI32(self.contentLength)
      oprot.writeFieldEnd()
    if self.created is not None:
      oprot.writeFieldBegin('created', TType.I64, 6)
      oprot.writeI64(self.created)
      oprot.writeFieldEnd()
    if self.updated is not None:
      oprot.writeFieldBegin('updated', TType.I64, 7)
      oprot.writeI64(self.updated)
      oprot.writeFieldEnd()
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 10)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    if self.notebookGuid is not None:
      oprot.writeFieldBegin('notebookGuid', TType.STRING, 11)
      oprot.writeString(self.notebookGuid)
      oprot.writeFieldEnd()
    if self.tagGuids is not None:
      oprot.writeFieldBegin('tagGuids', TType.LIST, 12)
      oprot.writeListBegin(TType.STRING, len(self.tagGuids))
      for iter111 in self.tagGuids:
        oprot.writeString(iter111)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.STRUCT, 14)
      self.attributes.write(oprot)
      oprot.writeFieldEnd()
    if self.largestResourceMime is not None:
      oprot.writeFieldBegin('largestResourceMime', TType.STRING, 20)
      oprot.writeString(self.largestResourceMime)
      oprot.writeFieldEnd()
    if self.largestResourceSize is not None:
      oprot.writeFieldBegin('largestResourceSize', TType.I32, 21)
      oprot.writeI32(self.largestResourceSize)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.guid is None:
      raise TProtocol.TProtocolException(message='Required field guid is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotesMetadataList(object):
  """
   This structure is returned from calls to the findNotesMetadata function to
   give the high-level metadata about a subset of Notes that are found to
   match a specified NoteFilter in a search.
  
  <dl>
   <dt>startIndex</dt>
     <dd>
     The starting index within the overall set of notes.  This
     is also the number of notes that are "before" this list in the set.
     </dd>
  
   <dt>totalNotes</dt>
     <dd>
     The number of notes in the larger set.  This can be used
     to calculate how many notes are "after" this note in the set.
     (I.e.  remaining = totalNotes - (startIndex + notes.length)  )
     </dd>
  
   <dt>notes</dt>
     <dd>
     The list of metadata for Notes in this range.  The set of optional fields
     that are set in each metadata structure will depend on the
     NotesMetadataResultSpec provided by the caller when the search was
     performed.  Only the 'guid' field will be guaranteed to be set in each
     Note.
     </dd>
  
   <dt>stoppedWords</dt>
     <dd>
     If the NoteList was produced using a text based search
     query that included words that are not indexed or searched by the service,
     this will include a list of those ignored words.
     </dd>
  
   <dt>searchedWords</dt>
     <dd>
     If the NoteList was produced using a text based search
     query that included viable search words or quoted expressions, this will
     include a list of those words.  Any stopped words will not be included
     in this list.
     </dd>
  
   <dt>updateCount</dt>
     <dd>
     Indicates the total number of transactions that have
     been committed within the account.  This reflects (for example) the
     number of discrete additions or modifications that have been made to
     the data in this account (tags, notes, resources, etc.).
     This number is the "high water mark" for Update Sequence Numbers (USN)
     within the account.
     </dd>
   </dl>
  
  Attributes:
   - startIndex
   - totalNotes
   - notes
   - stoppedWords
   - searchedWords
   - updateCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'startIndex', None, None, ), # 1
    (2, TType.I32, 'totalNotes', None, None, ), # 2
    (3, TType.LIST, 'notes', (TType.STRUCT,(NoteMetadata, NoteMetadata.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'stoppedWords', (TType.STRING,None), None, ), # 4
    (5, TType.LIST, 'searchedWords', (TType.STRING,None), None, ), # 5
    (6, TType.I32, 'updateCount', None, None, ), # 6
  )

  def __init__(self, startIndex=None, totalNotes=None, notes=None, stoppedWords=None, searchedWords=None, updateCount=None,):
    self.startIndex = startIndex
    self.totalNotes = totalNotes
    self.notes = notes
    self.stoppedWords = stoppedWords
    self.searchedWords = searchedWords
    self.updateCount = updateCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.startIndex = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.totalNotes = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.notes = []
          (_etype115, _size112) = iprot.readListBegin()
          for _i116 in xrange(_size112):
            _elem117 = NoteMetadata()
            _elem117.read(iprot)
            self.notes.append(_elem117)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.stoppedWords = []
          (_etype121, _size118) = iprot.readListBegin()
          for _i122 in xrange(_size118):
            _elem123 = iprot.readString();
            self.stoppedWords.append(_elem123)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.searchedWords = []
          (_etype127, _size124) = iprot.readListBegin()
          for _i128 in xrange(_size124):
            _elem129 = iprot.readString();
            self.searchedWords.append(_elem129)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.updateCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotesMetadataList')
    if self.startIndex is not None:
      oprot.writeFieldBegin('startIndex', TType.I32, 1)
      oprot.writeI32(self.startIndex)
      oprot.writeFieldEnd()
    if self.totalNotes is not None:
      oprot.writeFieldBegin('totalNotes', TType.I32, 2)
      oprot.writeI32(self.totalNotes)
      oprot.writeFieldEnd()
    if self.notes is not None:
      oprot.writeFieldBegin('notes', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.notes))
      for iter130 in self.notes:
        iter130.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.stoppedWords is not None:
      oprot.writeFieldBegin('stoppedWords', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.stoppedWords))
      for iter131 in self.stoppedWords:
        oprot.writeString(iter131)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.searchedWords is not None:
      oprot.writeFieldBegin('searchedWords', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.searchedWords))
      for iter132 in self.searchedWords:
        oprot.writeString(iter132)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.updateCount is not None:
      oprot.writeFieldBegin('updateCount', TType.I32, 6)
      oprot.writeI32(self.updateCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.startIndex is None:
      raise TProtocol.TProtocolException(message='Required field startIndex is unset!')
    if self.totalNotes is None:
      raise TProtocol.TProtocolException(message='Required field totalNotes is unset!')
    if self.notes is None:
      raise TProtocol.TProtocolException(message='Required field notes is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NotesMetadataResultSpec(object):
  """
  This structure is provided to the findNotesMetadata function to specify
  the subset of fields that should be included in each NoteMetadata element
  that is returned in the NotesMetadataList.
  Each field on this structure is a boolean flag that indicates whether the
  corresponding field should be included in the NoteMetadata structure when
  it is returned.  For example, if the 'includeTitle' field is set on this
  structure when calling findNotesMetadata, then each NoteMetadata in the
  list should have its 'title' field set.
  If one of the fields in this spec is not set, then it will be treated as
  'false' by the server, so the default behavior is to include nothing in
  replies (but the mandatory GUID)
  
  Attributes:
   - includeTitle
   - includeContentLength
   - includeCreated
   - includeUpdated
   - includeUpdateSequenceNum
   - includeNotebookGuid
   - includeTagGuids
   - includeAttributes
   - includeLargestResourceMime
   - includeLargestResourceSize
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.BOOL, 'includeTitle', None, None, ), # 2
    None, # 3
    None, # 4
    (5, TType.BOOL, 'includeContentLength', None, None, ), # 5
    (6, TType.BOOL, 'includeCreated', None, None, ), # 6
    (7, TType.BOOL, 'includeUpdated', None, None, ), # 7
    None, # 8
    None, # 9
    (10, TType.BOOL, 'includeUpdateSequenceNum', None, None, ), # 10
    (11, TType.BOOL, 'includeNotebookGuid', None, None, ), # 11
    (12, TType.BOOL, 'includeTagGuids', None, None, ), # 12
    None, # 13
    (14, TType.BOOL, 'includeAttributes', None, None, ), # 14
    None, # 15
    None, # 16
    None, # 17
    None, # 18
    None, # 19
    (20, TType.BOOL, 'includeLargestResourceMime', None, None, ), # 20
    (21, TType.BOOL, 'includeLargestResourceSize', None, None, ), # 21
  )

  def __init__(self, includeTitle=None, includeContentLength=None, includeCreated=None, includeUpdated=None, includeUpdateSequenceNum=None, includeNotebookGuid=None, includeTagGuids=None, includeAttributes=None, includeLargestResourceMime=None, includeLargestResourceSize=None,):
    self.includeTitle = includeTitle
    self.includeContentLength = includeContentLength
    self.includeCreated = includeCreated
    self.includeUpdated = includeUpdated
    self.includeUpdateSequenceNum = includeUpdateSequenceNum
    self.includeNotebookGuid = includeNotebookGuid
    self.includeTagGuids = includeTagGuids
    self.includeAttributes = includeAttributes
    self.includeLargestResourceMime = includeLargestResourceMime
    self.includeLargestResourceSize = includeLargestResourceSize

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.BOOL:
          self.includeTitle = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.includeContentLength = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.includeCreated = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.includeUpdated = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.includeUpdateSequenceNum = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.includeNotebookGuid = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.includeTagGuids = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.BOOL:
          self.includeAttributes = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.BOOL:
          self.includeLargestResourceMime = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.BOOL:
          self.includeLargestResourceSize = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NotesMetadataResultSpec')
    if self.includeTitle is not None:
      oprot.writeFieldBegin('includeTitle', TType.BOOL, 2)
      oprot.writeBool(self.includeTitle)
      oprot.writeFieldEnd()
    if self.includeContentLength is not None:
      oprot.writeFieldBegin('includeContentLength', TType.BOOL, 5)
      oprot.writeBool(self.includeContentLength)
      oprot.writeFieldEnd()
    if self.includeCreated is not None:
      oprot.writeFieldBegin('includeCreated', TType.BOOL, 6)
      oprot.writeBool(self.includeCreated)
      oprot.writeFieldEnd()
    if self.includeUpdated is not None:
      oprot.writeFieldBegin('includeUpdated', TType.BOOL, 7)
      oprot.writeBool(self.includeUpdated)
      oprot.writeFieldEnd()
    if self.includeUpdateSequenceNum is not None:
      oprot.writeFieldBegin('includeUpdateSequenceNum', TType.BOOL, 10)
      oprot.writeBool(self.includeUpdateSequenceNum)
      oprot.writeFieldEnd()
    if self.includeNotebookGuid is not None:
      oprot.writeFieldBegin('includeNotebookGuid', TType.BOOL, 11)
      oprot.writeBool(self.includeNotebookGuid)
      oprot.writeFieldEnd()
    if self.includeTagGuids is not None:
      oprot.writeFieldBegin('includeTagGuids', TType.BOOL, 12)
      oprot.writeBool(self.includeTagGuids)
      oprot.writeFieldEnd()
    if self.includeAttributes is not None:
      oprot.writeFieldBegin('includeAttributes', TType.BOOL, 14)
      oprot.writeBool(self.includeAttributes)
      oprot.writeFieldEnd()
    if self.includeLargestResourceMime is not None:
      oprot.writeFieldBegin('includeLargestResourceMime', TType.BOOL, 20)
      oprot.writeBool(self.includeLargestResourceMime)
      oprot.writeFieldEnd()
    if self.includeLargestResourceSize is not None:
      oprot.writeFieldBegin('includeLargestResourceSize', TType.BOOL, 21)
      oprot.writeBool(self.includeLargestResourceSize)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteCollectionCounts(object):
  """
   A data structure representing the number of notes for each notebook
   and tag with a non-zero set of applicable notes.
  
  <dl>
   <dt>notebookCounts</dt>
     <dd>
     A mapping from the Notebook GUID to the number of
     notes (from some selection) that are in the corresponding notebook.
     </dd>
  
   <dt>tagCounts</dt>
     <dd>
     A mapping from the Tag GUID to the number of notes (from some
     selection) that have the corresponding tag.
     </dd>
  
   <dt>trashCount</dt>
     <dd>
     If this is set, then this is the number of notes that are in the trash.
     If this is not set, then the number of notes in the trash hasn't been
     reported.  (I.e. if there are no notes in the trash, this will be set
     to 0.)
     </dd>
   </dl>
  
  Attributes:
   - notebookCounts
   - tagCounts
   - trashCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'notebookCounts', (TType.STRING,None,TType.I32,None), None, ), # 1
    (2, TType.MAP, 'tagCounts', (TType.STRING,None,TType.I32,None), None, ), # 2
    (3, TType.I32, 'trashCount', None, None, ), # 3
  )

  def __init__(self, notebookCounts=None, tagCounts=None, trashCount=None,):
    self.notebookCounts = notebookCounts
    self.tagCounts = tagCounts
    self.trashCount = trashCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.notebookCounts = {}
          (_ktype134, _vtype135, _size133 ) = iprot.readMapBegin() 
          for _i137 in xrange(_size133):
            _key138 = iprot.readString();
            _val139 = iprot.readI32();
            self.notebookCounts[_key138] = _val139
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.tagCounts = {}
          (_ktype141, _vtype142, _size140 ) = iprot.readMapBegin() 
          for _i144 in xrange(_size140):
            _key145 = iprot.readString();
            _val146 = iprot.readI32();
            self.tagCounts[_key145] = _val146
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.trashCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteCollectionCounts')
    if self.notebookCounts is not None:
      oprot.writeFieldBegin('notebookCounts', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.notebookCounts))
      for kiter147,viter148 in self.notebookCounts.items():
        oprot.writeString(kiter147)
        oprot.writeI32(viter148)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.tagCounts is not None:
      oprot.writeFieldBegin('tagCounts', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.tagCounts))
      for kiter149,viter150 in self.tagCounts.items():
        oprot.writeString(kiter149)
        oprot.writeI32(viter150)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.trashCount is not None:
      oprot.writeFieldBegin('trashCount', TType.I32, 3)
      oprot.writeI32(self.trashCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AdImpressions(object):
  """
  Information for tracking the display of a particular ad by a client.
  
  <dl>
   <dt>adId</dt>
     <dd>
       The identifier for this ad, from a previous Ad.id given to the client
     </dd>
  
   <dt>impressionCount</dt>
     <dd>
       The number of times this ad was displayed since the last successful
       ad retrieval.  The client should only report times the ad was selected
       when the client was visible.
     </dd>
  
   <dt>impressionTime</dt>
     <dd>
       The number of seconds that the client displayed the advertisement since
       the last successful ad retrieval.  This corresponds to the seconds that
       the client application was visible.
     </dd>
  </dl>
  
  Attributes:
   - adId
   - impressionCount
   - impressionTime
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'adId', None, None, ), # 1
    (2, TType.I32, 'impressionCount', None, None, ), # 2
    (3, TType.I32, 'impressionTime', None, None, ), # 3
  )

  def __init__(self, adId=None, impressionCount=None, impressionTime=None,):
    self.adId = adId
    self.impressionCount = impressionCount
    self.impressionTime = impressionTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.adId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.impressionCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.impressionTime = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AdImpressions')
    if self.adId is not None:
      oprot.writeFieldBegin('adId', TType.I32, 1)
      oprot.writeI32(self.adId)
      oprot.writeFieldEnd()
    if self.impressionCount is not None:
      oprot.writeFieldBegin('impressionCount', TType.I32, 2)
      oprot.writeI32(self.impressionCount)
      oprot.writeFieldEnd()
    if self.impressionTime is not None:
      oprot.writeFieldBegin('impressionTime', TType.I32, 3)
      oprot.writeI32(self.impressionTime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.adId is None:
      raise TProtocol.TProtocolException(message='Required field adId is unset!')
    if self.impressionCount is None:
      raise TProtocol.TProtocolException(message='Required field impressionCount is unset!')
    if self.impressionTime is None:
      raise TProtocol.TProtocolException(message='Required field impressionTime is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AdParameters(object):
  """
  Parameters that will be given by a client to the service when it requests
  a set of advertisements to display.  If any of these values are omitted,
  the service will use default values.
  
  <dl>
   <dt>clientLanguage</dt>
     <dd>
       The ISO 639-1 language code for the primary language for the client.
       If omitted, English will be assumed ('en').
     </dd>
  
   <dt>impressions</dt>
     <dd>
       A list of the impression counts and total display time for the ads
       that were displayed in the last day.
     </dd>
  
   <dt>supportHtml</dt>
     <dd>
       If true, the client requesting the ads supports ads specified via
       general HTML (with rich media, Javascript, etc.).
     </dd>
  
   <dt>clientProperties</dt>
     <dd>
       If provided, this may contain a set of key/value pairs that identify
       the characteristics of a particular client that may be used to help
       determine appropriate ads for that client.  These tuples may be used
       either to reduce or increase the likelihood that each ad will be
       returned.
     </dd>
  </dl>
  
  Attributes:
   - clientLanguage
   - impressions
   - supportHtml
   - clientProperties
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'clientLanguage', None, None, ), # 2
    None, # 3
    (4, TType.LIST, 'impressions', (TType.STRUCT,(AdImpressions, AdImpressions.thrift_spec)), None, ), # 4
    (5, TType.BOOL, 'supportHtml', None, None, ), # 5
    (6, TType.MAP, 'clientProperties', (TType.STRING,None,TType.STRING,None), None, ), # 6
  )

  def __init__(self, clientLanguage=None, impressions=None, supportHtml=None, clientProperties=None,):
    self.clientLanguage = clientLanguage
    self.impressions = impressions
    self.supportHtml = supportHtml
    self.clientProperties = clientProperties

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.clientLanguage = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.impressions = []
          (_etype154, _size151) = iprot.readListBegin()
          for _i155 in xrange(_size151):
            _elem156 = AdImpressions()
            _elem156.read(iprot)
            self.impressions.append(_elem156)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.supportHtml = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.clientProperties = {}
          (_ktype158, _vtype159, _size157 ) = iprot.readMapBegin() 
          for _i161 in xrange(_size157):
            _key162 = iprot.readString();
            _val163 = iprot.readString();
            self.clientProperties[_key162] = _val163
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AdParameters')
    if self.clientLanguage is not None:
      oprot.writeFieldBegin('clientLanguage', TType.STRING, 2)
      oprot.writeString(self.clientLanguage)
      oprot.writeFieldEnd()
    if self.impressions is not None:
      oprot.writeFieldBegin('impressions', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.impressions))
      for iter164 in self.impressions:
        iter164.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.supportHtml is not None:
      oprot.writeFieldBegin('supportHtml', TType.BOOL, 5)
      oprot.writeBool(self.supportHtml)
      oprot.writeFieldEnd()
    if self.clientProperties is not None:
      oprot.writeFieldBegin('clientProperties', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.clientProperties))
      for kiter165,viter166 in self.clientProperties.items():
        oprot.writeString(kiter165)
        oprot.writeString(viter166)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteEmailParameters(object):
  """
  Parameters that must be given to the NoteStore emailNote call. These allow
  the caller to specify the note to send, the recipient addresses, etc.
  
  <dl>
   <dt>guid</dt>
     <dd>
       If set, this must be the GUID of a note within the user's account that
       should be retrieved from the service and sent as email.  If not set,
       the 'note' field must be provided instead.
     </dd>
  
   <dt>note</dt>
     <dd>
       If the 'guid' field is not set, this field must be provided, including
       the full contents of the note note (and all of its Resources) to send.
       This can be used for a Note that as not been created in the service,
       for example by a local client with local notes.
     </dd>
  
   <dt>toAddresses</dt>
     <dd>
       If provided, this should contain a list of the SMTP email addresses
       that should be included in the "To:" line of the email.
       Callers must specify at least one "to" or "cc" email address.
     </dd>
  
   <dt>ccAddresses</dt>
     <dd>
       If provided, this should contain a list of the SMTP email addresses
       that should be included in the "Cc:" line of the email.
       Callers must specify at least one "to" or "cc" email address.
     </dd>
  
   <dt>subject</dt>
     <dd>
       If provided, this should contain the subject line of the email that
       will be sent.  If not provided, the title of the note will be used
       as the subject of the email.
     </dd>
  
   <dt>message</dt>
     <dd>
       If provided, this is additional personal text that should be included
       into the email as a message from the owner to the recipient(s).
     </dd>
  </dl>
  
  Attributes:
   - guid
   - note
   - toAddresses
   - ccAddresses
   - subject
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRUCT, 'note', (evernote.edam.type.ttypes.Note, evernote.edam.type.ttypes.Note.thrift_spec), None, ), # 2
    (3, TType.LIST, 'toAddresses', (TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'ccAddresses', (TType.STRING,None), None, ), # 4
    (5, TType.STRING, 'subject', None, None, ), # 5
    (6, TType.STRING, 'message', None, None, ), # 6
  )

  def __init__(self, guid=None, note=None, toAddresses=None, ccAddresses=None, subject=None, message=None,):
    self.guid = guid
    self.note = note
    self.toAddresses = toAddresses
    self.ccAddresses = ccAddresses
    self.subject = subject
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.note = evernote.edam.type.ttypes.Note()
          self.note.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.toAddresses = []
          (_etype170, _size167) = iprot.readListBegin()
          for _i171 in xrange(_size167):
            _elem172 = iprot.readString();
            self.toAddresses.append(_elem172)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.ccAddresses = []
          (_etype176, _size173) = iprot.readListBegin()
          for _i177 in xrange(_size173):
            _elem178 = iprot.readString();
            self.ccAddresses.append(_elem178)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.subject = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteEmailParameters')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.note is not None:
      oprot.writeFieldBegin('note', TType.STRUCT, 2)
      self.note.write(oprot)
      oprot.writeFieldEnd()
    if self.toAddresses is not None:
      oprot.writeFieldBegin('toAddresses', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.toAddresses))
      for iter179 in self.toAddresses:
        oprot.writeString(iter179)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccAddresses is not None:
      oprot.writeFieldBegin('ccAddresses', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.ccAddresses))
      for iter180 in self.ccAddresses:
        oprot.writeString(iter180)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.subject is not None:
      oprot.writeFieldBegin('subject', TType.STRING, 5)
      oprot.writeString(self.subject)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 6)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteVersionId(object):
  """
  Identifying information about previous versions of a note that are backed up
  within Evernote's servers.  Used in the return value of the listNoteVersions
  call.
  
  <dl>
   <dt>updateSequenceNum</dt>
   <dd>
     The update sequence number for the Note when it last had this content.
     This serves to uniquely identify each version of the note, since USN
     values are unique within an account for each update.
   </dd>
   <dt>updated</dt>
   <dd>
     The 'updated' time that was set on the Note when it had this version
     of the content.  This is the user-modifiable modification time on the
     note, so it's not reliable for guaranteeing the order of various
     versions.  (E.g. if someone modifies the note, then changes this time
     manually into the past and then updates the note again.)
   </dd>
   <dt>saved</dt>
   <dd>
     A timestamp that holds the date and time when this version of the note
     was backed up by Evernote's servers.  This
   </dd>
   <dt>title</dt>
   <dd>
     The title of the note when this particular version was saved.  (The
     current title of the note may differ from this value.)
   </dd>
  </dl>
  
  Attributes:
   - updateSequenceNum
   - updated
   - saved
   - title
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'updateSequenceNum', None, None, ), # 1
    (2, TType.I64, 'updated', None, None, ), # 2
    (3, TType.I64, 'saved', None, None, ), # 3
    (4, TType.STRING, 'title', None, None, ), # 4
  )

  def __init__(self, updateSequenceNum=None, updated=None, saved=None, title=None,):
    self.updateSequenceNum = updateSequenceNum
    self.updated = updated
    self.saved = saved
    self.title = title

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.updated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.saved = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteVersionId')
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 1)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    if self.updated is not None:
      oprot.writeFieldBegin('updated', TType.I64, 2)
      oprot.writeI64(self.updated)
      oprot.writeFieldEnd()
    if self.saved is not None:
      oprot.writeFieldBegin('saved', TType.I64, 3)
      oprot.writeI64(self.saved)
      oprot.writeFieldEnd()
    if self.title is not None:
      oprot.writeFieldBegin('title', TType.STRING, 4)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.updateSequenceNum is None:
      raise TProtocol.TProtocolException(message='Required field updateSequenceNum is unset!')
    if self.updated is None:
      raise TProtocol.TProtocolException(message='Required field updated is unset!')
    if self.saved is None:
      raise TProtocol.TProtocolException(message='Required field saved is unset!')
    if self.title is None:
      raise TProtocol.TProtocolException(message='Required field title is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ClientUsageMetrics(object):
  """
  This structure is passed from clients to the Evernote service when they wish
  to relay coarse-grained usage metrics to the service to help improve
  products.
  
  <dl>
   <dt>sessions</dt>
   <dd>
     This field contains a count of the number of usage "sessions" that have
     occurred with this client which have not previously been reported to
     the service.
     A "session" is defined as one of the 96 fifteen-minute intervals of the
     day when someone used Evernote's interface at least once.
     So if a user interacts with an Evernote client at 12:18, 12:24, and 12:36,
     and then the client synchronizes at 12:39, it would report that there were
     two previously-unreported sessions (one session for the 12:15-12:30 time
     period, and one for the 12:30-12:45 period).
     If the user used Evernote again at 12:41 and synchronized at 12:43, it
     would not report any new sessions, because the 12:30-12:45 session had
     already been reported.
   </dd>
  </dl>
  
  Attributes:
   - sessions
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sessions', None, None, ), # 1
  )

  def __init__(self, sessions=None,):
    self.sessions = sessions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sessions = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ClientUsageMetrics')
    if self.sessions is not None:
      oprot.writeFieldBegin('sessions', TType.I32, 1)
      oprot.writeI32(self.sessions)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

########NEW FILE########
__FILENAME__ = constants
#
# Autogenerated by Thrift Compiler (0.5.0-en-262021)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *

EDAM_NOTE_SOURCE_WEB_CLIP = "web.clip"
EDAM_NOTE_SOURCE_MAIL_CLIP = "mail.clip"
EDAM_NOTE_SOURCE_MAIL_SMTP_GATEWAY = "mail.smtp"

########NEW FILE########
__FILENAME__ = ttypes
#
# Autogenerated by Thrift Compiler (0.5.0-en-262021)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import evernote.edam.limits.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class PrivilegeLevel(object):
  """
  This enumeration defines the possible permission levels for a user.
  Free accounts will have a level of NORMAL and paid Premium accounts
  will have a level of PREMIUM.
  """
  NORMAL = 1
  PREMIUM = 3
  MANAGER = 7
  SUPPORT = 8
  ADMIN = 9

  _VALUES_TO_NAMES = {
    1: "NORMAL",
    3: "PREMIUM",
    7: "MANAGER",
    8: "SUPPORT",
    9: "ADMIN",
  }

  _NAMES_TO_VALUES = {
    "NORMAL": 1,
    "PREMIUM": 3,
    "MANAGER": 7,
    "SUPPORT": 8,
    "ADMIN": 9,
  }

class QueryFormat(object):
  """
  Every search query is specified as a sequence of characters.
  Currently, only the USER query format is supported.
  """
  USER = 1
  SEXP = 2

  _VALUES_TO_NAMES = {
    1: "USER",
    2: "SEXP",
  }

  _NAMES_TO_VALUES = {
    "USER": 1,
    "SEXP": 2,
  }

class NoteSortOrder(object):
  """
  This enumeration defines the possible sort ordering for notes when
  they are returned from a search result.
  """
  CREATED = 1
  UPDATED = 2
  RELEVANCE = 3
  UPDATE_SEQUENCE_NUMBER = 4
  TITLE = 5

  _VALUES_TO_NAMES = {
    1: "CREATED",
    2: "UPDATED",
    3: "RELEVANCE",
    4: "UPDATE_SEQUENCE_NUMBER",
    5: "TITLE",
  }

  _NAMES_TO_VALUES = {
    "CREATED": 1,
    "UPDATED": 2,
    "RELEVANCE": 3,
    "UPDATE_SEQUENCE_NUMBER": 4,
    "TITLE": 5,
  }

class PremiumOrderStatus(object):
  """
  This enumeration defines the possible states of a premium account
  
  NONE:    the user has never attempted to become a premium subscriber
  
  PENDING: the user has requested a premium account but their charge has not
    been confirmed
  
  ACTIVE:  the user has been charged and their premium account is in good
   standing
  
  FAILED:  the system attempted to charge the was denied. Their premium
    privileges have been revoked. We will periodically attempt to re-validate
    their order.
  
  CANCELLATION_PENDING: the user has requested that no further charges be made
    but the current account is still active.
  
  CANCELED: the premium account was canceled either because of failure to pay
    or user cancelation. No more attempts will be made to activate the account.
  """
  NONE = 0
  PENDING = 1
  ACTIVE = 2
  FAILED = 3
  CANCELLATION_PENDING = 4
  CANCELED = 5

  _VALUES_TO_NAMES = {
    0: "NONE",
    1: "PENDING",
    2: "ACTIVE",
    3: "FAILED",
    4: "CANCELLATION_PENDING",
    5: "CANCELED",
  }

  _NAMES_TO_VALUES = {
    "NONE": 0,
    "PENDING": 1,
    "ACTIVE": 2,
    "FAILED": 3,
    "CANCELLATION_PENDING": 4,
    "CANCELED": 5,
  }


class Data(object):
  """
   In several places, EDAM exchanges blocks of bytes of data for a component
   which may be relatively large.  For example:  the contents of a clipped
   HTML note, the bytes of an embedded image, or the recognition XML for
   a large image.  This structure is used in the protocol to represent
   any of those large blocks of data when they are transmitted or when
   they are only referenced their metadata.
  
  <dl>
   <dt>bodyHash</dt>
     <dd>This field carries a one-way hash of the contents of the
     data body, in binary form.  The hash function is MD5<br/>
     Length:  EDAM_HASH_LEN (exactly)
     </dd>
  
   <dt>size</dt>
     <dd>The length, in bytes, of the data body.
     </dd>
  
   <dt>body</dt>
     <dd>This field is set to contain the binary contents of the data
     whenever the resource is being transferred.  If only metadata is
     being exchanged, this field will be empty.  For example, a client could
     notify the service about the change to an attribute for a resource
     without transmitting the binary resource contents.
     </dd>
   </dl>
  
  Attributes:
   - bodyHash
   - size
   - body
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'bodyHash', None, None, ), # 1
    (2, TType.I32, 'size', None, None, ), # 2
    (3, TType.STRING, 'body', None, None, ), # 3
  )

  def __init__(self, bodyHash=None, size=None, body=None,):
    self.bodyHash = bodyHash
    self.size = size
    self.body = body

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.bodyHash = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.size = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.body = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Data')
    if self.bodyHash is not None:
      oprot.writeFieldBegin('bodyHash', TType.STRING, 1)
      oprot.writeString(self.bodyHash)
      oprot.writeFieldEnd()
    if self.size is not None:
      oprot.writeFieldBegin('size', TType.I32, 2)
      oprot.writeI32(self.size)
      oprot.writeFieldEnd()
    if self.body is not None:
      oprot.writeFieldBegin('body', TType.STRING, 3)
      oprot.writeString(self.body)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UserAttributes(object):
  """
   A structure holding the optional attributes that can be stored
   on a User.  These are generally less critical than the core User fields.
  
  <dl>
   <dt>defaultLocationName</dt>
     <dd>the location string that should be associated
     with the user in order to determine where notes are taken if not otherwise
     specified.<br/>
     Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
     </dd>
  
   <dt>defaultLatitude</dt>
     <dd>if set, this is the latitude that should be
     assigned to any notes that have no other latitude information.
     </dd>
  
   <dt>defaultLongitude</dt>
     <dd>if set, this is the longitude that should be
     assigned to any notes that have no other longitude information.
     </dd>
  
   <dt>preactivation</dt>
     <dd>if set, the user account is not yet confirmed for
     login.  I.e. the account has been created, but we are still waiting for
     the user to complete the activation step.
     </dd>
  
   <dt>viewedPromotions</dt>
     <dd>a list of promotions the user has seen.
      This list may occasionally be modified by the system when promotions are
      no longer available.<br/>
      Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
     </dd>
  
   <dt>incomingEmailAddress</dt>
     <dd>if set, this is the email address that the
      user may send email to in order to add an email note directly into the
      account via the SMTP email gateway.  This is the part of the email
      address before the '@' symbol ... our domain is not included.
      If this is not set, the user may not add notes via the gateway.<br/>
      Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
     </dd>
  
   <dt>recentMailedAddresses</dt>
     <dd>if set, this will contain a list of email
      addresses that have recently been used as recipients
      of outbound emails by the user.  This can be used to pre-populate a
      list of possible destinations when a user wishes to send a note via
      email.<br/>
      Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX each<br/>
      Max:  EDAM_USER_RECENT_MAILED_ADDRESSES_MAX entries
     </dd>
  
   <dt>comments</dt>
     <dd>Free-form text field that may hold general support
      information, etc.<br/>
      Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
     </dd>
  
   <dt>dateAgreedToTermsOfService</dt>
     <dd>The date/time when the user agreed to
      the terms of service.  This can be used as the effective "start date"
      for the account.
     </dd>
  
   <dt>maxReferrals</dt>
     <dd>The number of referrals that the user is permitted
      to make.
     </dd>
  
   <dt>referralCount</dt>
     <dd>The number of referrals sent from this account.
     </dd>
  
   <dt>refererCode</dt>
     <dd>A code indicating where the user was sent from. AKA
      promotion code
     </dd>
  
   <dt>sentEmailDate</dt>
     <dd>The most recent date when the user sent outbound
      emails from the service.  Used with sentEmailCount to limit the number
      of emails that can be sent per day.
     </dd>
  
   <dt>sentEmailCount</dt>
     <dd>The number of emails that were sent from the user
      via the service on sentEmailDate.  Used to enforce a limit on the number
      of emails per user per day to prevent spamming.
     </dd>
  
   <dt>dailyEmailLimit</dt>
     <dd>If set, this is the maximum number of emails that
      may be sent in a given day from this account.  If unset, the server will
      use the configured default limit.
     </dd>
  
   <dt>emailOptOutDate</dt>
     <dd>If set, this is the date when the user asked
      to be excluded from offers and promotions sent by Evernote.  If not set,
      then the user currently agrees to receive these messages.
     </dd>
  
   <dt>partnerEmailOptInDate</dt>
     <dd>If set, this is the date when the user asked
      to be included in offers and promotions sent by Evernote's partners.
      If not sent, then the user currently does not agree to receive these
      emails.
     </dd>
  
   <dt>preferredLanguage</dt>
     <dd>a 2 character language codes based on:
         http://ftp.ics.uci.edu/pub/ietf/http/related/iso639.txt used for
        localization purposes to determine what language to use for the web
        interface and for other direct communication (e.g. emails).
     </dd>
  
   <dt>preferredCountry</dt>
     <dd>Preferred country code based on ISO 3166-1-alpha-2 indicating the
     users preferred country</dd>
  
   <dt>clipFullPage</dt>
     <dd>Boolean flag set to true if the user wants to clip full pages by
     default when they use the web clipper without a selection.</dd>
  
   <dt>twitterUserName</dt>
     <dd>The username of the account of someone who has chosen to enable
     Twittering into Evernote.  This value is subject to change, since users
     may change their Twitter user name.</dd>
  
   <dt>twitterId</dt>
     <dd>The unique identifier of the user's Twitter account if that user
     has chosen to enable Twittering into Evernote.</dd>
  
   <dt>groupName</dt>
     <dd>A name identifier used to identify a particular set of branding and
      light customization.</dd>
  
   <dt>recognitionLanguage</dt>
     <dd>a 2 character language codes based on:
         http://ftp.ics.uci.edu/pub/ietf/http/related/iso639.txt
         If set, this is used to determine the language that should be used
         when processing images and PDF files to find text.
         If not set, then the 'preferredLanguage' will be used.
     </dd>
  
   <dt>customerProfileId</dt>
     <dd>a numeric identified which provides a linkage between the user record
         and the direct credit card payment creditcard profile.
     </dd>
  
   <dt>educationalInstitution</dt>
     <dd>a flag indicating that the user is part of an educational institution which
     makes them eligible for discounts on bulk purchases
     </dd>
  
   <dt>businessAddress</dt>
     <dd>A string recording the business address of a Sponsored Account user who has requested invoicing.
     </dd>
   </dl>
  
   <dt>hideSponsorBilling</dt>
     <dd>A flag indicating whether to hide the billing information on a sponsored
         account owner's settings page
     </dd>
   </dl>
  
  Attributes:
   - defaultLocationName
   - defaultLatitude
   - defaultLongitude
   - preactivation
   - viewedPromotions
   - incomingEmailAddress
   - recentMailedAddresses
   - comments
   - dateAgreedToTermsOfService
   - maxReferrals
   - referralCount
   - refererCode
   - sentEmailDate
   - sentEmailCount
   - dailyEmailLimit
   - emailOptOutDate
   - partnerEmailOptInDate
   - preferredLanguage
   - preferredCountry
   - clipFullPage
   - twitterUserName
   - twitterId
   - groupName
   - recognitionLanguage
   - customerProfileId
   - referralProof
   - educationalDiscount
   - businessAddress
   - hideSponsorBilling
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'defaultLocationName', None, None, ), # 1
    (2, TType.DOUBLE, 'defaultLatitude', None, None, ), # 2
    (3, TType.DOUBLE, 'defaultLongitude', None, None, ), # 3
    (4, TType.BOOL, 'preactivation', None, None, ), # 4
    (5, TType.LIST, 'viewedPromotions', (TType.STRING,None), None, ), # 5
    (6, TType.STRING, 'incomingEmailAddress', None, None, ), # 6
    (7, TType.LIST, 'recentMailedAddresses', (TType.STRING,None), None, ), # 7
    None, # 8
    (9, TType.STRING, 'comments', None, None, ), # 9
    None, # 10
    (11, TType.I64, 'dateAgreedToTermsOfService', None, None, ), # 11
    (12, TType.I32, 'maxReferrals', None, None, ), # 12
    (13, TType.I32, 'referralCount', None, None, ), # 13
    (14, TType.STRING, 'refererCode', None, None, ), # 14
    (15, TType.I64, 'sentEmailDate', None, None, ), # 15
    (16, TType.I32, 'sentEmailCount', None, None, ), # 16
    (17, TType.I32, 'dailyEmailLimit', None, None, ), # 17
    (18, TType.I64, 'emailOptOutDate', None, None, ), # 18
    (19, TType.I64, 'partnerEmailOptInDate', None, None, ), # 19
    (20, TType.STRING, 'preferredLanguage', None, None, ), # 20
    (21, TType.STRING, 'preferredCountry', None, None, ), # 21
    (22, TType.BOOL, 'clipFullPage', None, None, ), # 22
    (23, TType.STRING, 'twitterUserName', None, None, ), # 23
    (24, TType.STRING, 'twitterId', None, None, ), # 24
    (25, TType.STRING, 'groupName', None, None, ), # 25
    (26, TType.STRING, 'recognitionLanguage', None, None, ), # 26
    (27, TType.I64, 'customerProfileId', None, None, ), # 27
    (28, TType.STRING, 'referralProof', None, None, ), # 28
    (29, TType.BOOL, 'educationalDiscount', None, None, ), # 29
    (30, TType.STRING, 'businessAddress', None, None, ), # 30
    (31, TType.BOOL, 'hideSponsorBilling', None, None, ), # 31
  )

  def __init__(self, defaultLocationName=None, defaultLatitude=None, defaultLongitude=None, preactivation=None, viewedPromotions=None, incomingEmailAddress=None, recentMailedAddresses=None, comments=None, dateAgreedToTermsOfService=None, maxReferrals=None, referralCount=None, refererCode=None, sentEmailDate=None, sentEmailCount=None, dailyEmailLimit=None, emailOptOutDate=None, partnerEmailOptInDate=None, preferredLanguage=None, preferredCountry=None, clipFullPage=None, twitterUserName=None, twitterId=None, groupName=None, recognitionLanguage=None, customerProfileId=None, referralProof=None, educationalDiscount=None, businessAddress=None, hideSponsorBilling=None,):
    self.defaultLocationName = defaultLocationName
    self.defaultLatitude = defaultLatitude
    self.defaultLongitude = defaultLongitude
    self.preactivation = preactivation
    self.viewedPromotions = viewedPromotions
    self.incomingEmailAddress = incomingEmailAddress
    self.recentMailedAddresses = recentMailedAddresses
    self.comments = comments
    self.dateAgreedToTermsOfService = dateAgreedToTermsOfService
    self.maxReferrals = maxReferrals
    self.referralCount = referralCount
    self.refererCode = refererCode
    self.sentEmailDate = sentEmailDate
    self.sentEmailCount = sentEmailCount
    self.dailyEmailLimit = dailyEmailLimit
    self.emailOptOutDate = emailOptOutDate
    self.partnerEmailOptInDate = partnerEmailOptInDate
    self.preferredLanguage = preferredLanguage
    self.preferredCountry = preferredCountry
    self.clipFullPage = clipFullPage
    self.twitterUserName = twitterUserName
    self.twitterId = twitterId
    self.groupName = groupName
    self.recognitionLanguage = recognitionLanguage
    self.customerProfileId = customerProfileId
    self.referralProof = referralProof
    self.educationalDiscount = educationalDiscount
    self.businessAddress = businessAddress
    self.hideSponsorBilling = hideSponsorBilling

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.defaultLocationName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.defaultLatitude = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.defaultLongitude = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.preactivation = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.viewedPromotions = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString();
            self.viewedPromotions.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.incomingEmailAddress = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.recentMailedAddresses = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = iprot.readString();
            self.recentMailedAddresses.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.comments = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I64:
          self.dateAgreedToTermsOfService = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.maxReferrals = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I32:
          self.referralCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.refererCode = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I64:
          self.sentEmailDate = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.I32:
          self.sentEmailCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.I32:
          self.dailyEmailLimit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.I64:
          self.emailOptOutDate = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.I64:
          self.partnerEmailOptInDate = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.STRING:
          self.preferredLanguage = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.STRING:
          self.preferredCountry = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.BOOL:
          self.clipFullPage = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.STRING:
          self.twitterUserName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 24:
        if ftype == TType.STRING:
          self.twitterId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 25:
        if ftype == TType.STRING:
          self.groupName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 26:
        if ftype == TType.STRING:
          self.recognitionLanguage = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 27:
        if ftype == TType.I64:
          self.customerProfileId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 28:
        if ftype == TType.STRING:
          self.referralProof = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 29:
        if ftype == TType.BOOL:
          self.educationalDiscount = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 30:
        if ftype == TType.STRING:
          self.businessAddress = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 31:
        if ftype == TType.BOOL:
          self.hideSponsorBilling = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UserAttributes')
    if self.defaultLocationName is not None:
      oprot.writeFieldBegin('defaultLocationName', TType.STRING, 1)
      oprot.writeString(self.defaultLocationName)
      oprot.writeFieldEnd()
    if self.defaultLatitude is not None:
      oprot.writeFieldBegin('defaultLatitude', TType.DOUBLE, 2)
      oprot.writeDouble(self.defaultLatitude)
      oprot.writeFieldEnd()
    if self.defaultLongitude is not None:
      oprot.writeFieldBegin('defaultLongitude', TType.DOUBLE, 3)
      oprot.writeDouble(self.defaultLongitude)
      oprot.writeFieldEnd()
    if self.preactivation is not None:
      oprot.writeFieldBegin('preactivation', TType.BOOL, 4)
      oprot.writeBool(self.preactivation)
      oprot.writeFieldEnd()
    if self.viewedPromotions is not None:
      oprot.writeFieldBegin('viewedPromotions', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.viewedPromotions))
      for iter12 in self.viewedPromotions:
        oprot.writeString(iter12)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.incomingEmailAddress is not None:
      oprot.writeFieldBegin('incomingEmailAddress', TType.STRING, 6)
      oprot.writeString(self.incomingEmailAddress)
      oprot.writeFieldEnd()
    if self.recentMailedAddresses is not None:
      oprot.writeFieldBegin('recentMailedAddresses', TType.LIST, 7)
      oprot.writeListBegin(TType.STRING, len(self.recentMailedAddresses))
      for iter13 in self.recentMailedAddresses:
        oprot.writeString(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.comments is not None:
      oprot.writeFieldBegin('comments', TType.STRING, 9)
      oprot.writeString(self.comments)
      oprot.writeFieldEnd()
    if self.dateAgreedToTermsOfService is not None:
      oprot.writeFieldBegin('dateAgreedToTermsOfService', TType.I64, 11)
      oprot.writeI64(self.dateAgreedToTermsOfService)
      oprot.writeFieldEnd()
    if self.maxReferrals is not None:
      oprot.writeFieldBegin('maxReferrals', TType.I32, 12)
      oprot.writeI32(self.maxReferrals)
      oprot.writeFieldEnd()
    if self.referralCount is not None:
      oprot.writeFieldBegin('referralCount', TType.I32, 13)
      oprot.writeI32(self.referralCount)
      oprot.writeFieldEnd()
    if self.refererCode is not None:
      oprot.writeFieldBegin('refererCode', TType.STRING, 14)
      oprot.writeString(self.refererCode)
      oprot.writeFieldEnd()
    if self.sentEmailDate is not None:
      oprot.writeFieldBegin('sentEmailDate', TType.I64, 15)
      oprot.writeI64(self.sentEmailDate)
      oprot.writeFieldEnd()
    if self.sentEmailCount is not None:
      oprot.writeFieldBegin('sentEmailCount', TType.I32, 16)
      oprot.writeI32(self.sentEmailCount)
      oprot.writeFieldEnd()
    if self.dailyEmailLimit is not None:
      oprot.writeFieldBegin('dailyEmailLimit', TType.I32, 17)
      oprot.writeI32(self.dailyEmailLimit)
      oprot.writeFieldEnd()
    if self.emailOptOutDate is not None:
      oprot.writeFieldBegin('emailOptOutDate', TType.I64, 18)
      oprot.writeI64(self.emailOptOutDate)
      oprot.writeFieldEnd()
    if self.partnerEmailOptInDate is not None:
      oprot.writeFieldBegin('partnerEmailOptInDate', TType.I64, 19)
      oprot.writeI64(self.partnerEmailOptInDate)
      oprot.writeFieldEnd()
    if self.preferredLanguage is not None:
      oprot.writeFieldBegin('preferredLanguage', TType.STRING, 20)
      oprot.writeString(self.preferredLanguage)
      oprot.writeFieldEnd()
    if self.preferredCountry is not None:
      oprot.writeFieldBegin('preferredCountry', TType.STRING, 21)
      oprot.writeString(self.preferredCountry)
      oprot.writeFieldEnd()
    if self.clipFullPage is not None:
      oprot.writeFieldBegin('clipFullPage', TType.BOOL, 22)
      oprot.writeBool(self.clipFullPage)
      oprot.writeFieldEnd()
    if self.twitterUserName is not None:
      oprot.writeFieldBegin('twitterUserName', TType.STRING, 23)
      oprot.writeString(self.twitterUserName)
      oprot.writeFieldEnd()
    if self.twitterId is not None:
      oprot.writeFieldBegin('twitterId', TType.STRING, 24)
      oprot.writeString(self.twitterId)
      oprot.writeFieldEnd()
    if self.groupName is not None:
      oprot.writeFieldBegin('groupName', TType.STRING, 25)
      oprot.writeString(self.groupName)
      oprot.writeFieldEnd()
    if self.recognitionLanguage is not None:
      oprot.writeFieldBegin('recognitionLanguage', TType.STRING, 26)
      oprot.writeString(self.recognitionLanguage)
      oprot.writeFieldEnd()
    if self.customerProfileId is not None:
      oprot.writeFieldBegin('customerProfileId', TType.I64, 27)
      oprot.writeI64(self.customerProfileId)
      oprot.writeFieldEnd()
    if self.referralProof is not None:
      oprot.writeFieldBegin('referralProof', TType.STRING, 28)
      oprot.writeString(self.referralProof)
      oprot.writeFieldEnd()
    if self.educationalDiscount is not None:
      oprot.writeFieldBegin('educationalDiscount', TType.BOOL, 29)
      oprot.writeBool(self.educationalDiscount)
      oprot.writeFieldEnd()
    if self.businessAddress is not None:
      oprot.writeFieldBegin('businessAddress', TType.STRING, 30)
      oprot.writeString(self.businessAddress)
      oprot.writeFieldEnd()
    if self.hideSponsorBilling is not None:
      oprot.writeFieldBegin('hideSponsorBilling', TType.BOOL, 31)
      oprot.writeBool(self.hideSponsorBilling)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Accounting(object):
  """
   This represents the bookkeeping information for the user's subscription.
  
  <dl>
   <dt>uploadLimit</dt>
     <dd>The number of bytes that can be uploaded to the account
     in the current month.  For new notes that are created, this is the length
     of the note content (in Unicode characters) plus the size of each resource
     (in bytes).  For edited notes, this is the the difference between the old
     length and the new length (if this is greater than 0) plus the size of
     each new resource.
     </dd>
   <dt>uploadLimitEnd</dt>
     <dd>The date and time when the current upload limit
     expires.  At this time, the monthly upload count reverts to 0 and a new
     limit is imposed.  This date and time is exclusive, so this is effectively
     the start of the new month.
     </dd>
   <dt>uploadLimitNextMonth</dt>
     <dd> When uploadLimitEnd is reached, the service
     will change uploadLimit to uploadLimitNextMonth. If a premium account is
     canceled, this mechanism will reset the quota appropriately.
     </dd>
   <dt>premiumServiceStatus</dt>
     <dd>Indicates the phases of a premium account
     during the billing process.
     </dd>
   <dt>premiumOrderNumber</dt>
     <dd>The order number used by the commerce system to
     process recurring payments
     </dd>
   <dt>premiumServiceStart</dt>
     <dd>The start date when this premium promotion
     began (this number will get overwritten if a premium service is canceled
     and then re-activated).
     </dd>
   <dt>premiumCommerceService</dt>
     <dd>The commerce system used (paypal, Google
     checkout, etc)
     </dd>
   <dt>premiumServiceSKU</dt>
     <dd>The code associated with the purchase eg. monthly
     or annual purchase. Clients should interpret this value and localize it.
     </dd>
   <dt>lastSuccessfulCharge</dt>
     <dd>Date the last time the user was charged.
     Null if never charged.
     </dd>
   <dt>lastFailedCharge</dt>
     <dd>Date the last time a charge was attempted and
     failed.
     </dd>
   <dt>lastFailedChargeReason</dt>
     <dd>Reason provided for the charge failure
     </dd>
   <dt>nextPaymentDue</dt>
     <dd>The end of the billing cycle. This could be in the
     past if there are failed charges.
     </dd>
   <dt>premiumLockUntil</dt>
     <dd>An internal variable to manage locking operations
     on the commerce variables.
     </dd>
   <dt>updated</dt>
     <dd>The date any modification where made to this record.
     </dd>
   <dt>premiumSubscriptionNumber</dt>
     <dd>The number number identifying the
     recurring subscription used to make the recurring charges.
     </dd>
   <dt>lastRequestedCharge</dt>
     <dd>Date charge last attempted</dd>
   <dt>currency</dt>
     <dd>ISO 4217 currency code</dd>
   <dt>unitPrice</dt>
     <dd>charge in the smallest unit of the currency (e.g. cents for USD)</dd>
   </dl>
  
  Attributes:
   - uploadLimit
   - uploadLimitEnd
   - uploadLimitNextMonth
   - premiumServiceStatus
   - premiumOrderNumber
   - premiumCommerceService
   - premiumServiceStart
   - premiumServiceSKU
   - lastSuccessfulCharge
   - lastFailedCharge
   - lastFailedChargeReason
   - nextPaymentDue
   - premiumLockUntil
   - updated
   - premiumSubscriptionNumber
   - lastRequestedCharge
   - currency
   - unitPrice
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'uploadLimit', None, None, ), # 1
    (2, TType.I64, 'uploadLimitEnd', None, None, ), # 2
    (3, TType.I64, 'uploadLimitNextMonth', None, None, ), # 3
    (4, TType.I32, 'premiumServiceStatus', None, None, ), # 4
    (5, TType.STRING, 'premiumOrderNumber', None, None, ), # 5
    (6, TType.STRING, 'premiumCommerceService', None, None, ), # 6
    (7, TType.I64, 'premiumServiceStart', None, None, ), # 7
    (8, TType.STRING, 'premiumServiceSKU', None, None, ), # 8
    (9, TType.I64, 'lastSuccessfulCharge', None, None, ), # 9
    (10, TType.I64, 'lastFailedCharge', None, None, ), # 10
    (11, TType.STRING, 'lastFailedChargeReason', None, None, ), # 11
    (12, TType.I64, 'nextPaymentDue', None, None, ), # 12
    (13, TType.I64, 'premiumLockUntil', None, None, ), # 13
    (14, TType.I64, 'updated', None, None, ), # 14
    None, # 15
    (16, TType.STRING, 'premiumSubscriptionNumber', None, None, ), # 16
    (17, TType.I64, 'lastRequestedCharge', None, None, ), # 17
    (18, TType.STRING, 'currency', None, None, ), # 18
    (19, TType.I32, 'unitPrice', None, None, ), # 19
  )

  def __init__(self, uploadLimit=None, uploadLimitEnd=None, uploadLimitNextMonth=None, premiumServiceStatus=None, premiumOrderNumber=None, premiumCommerceService=None, premiumServiceStart=None, premiumServiceSKU=None, lastSuccessfulCharge=None, lastFailedCharge=None, lastFailedChargeReason=None, nextPaymentDue=None, premiumLockUntil=None, updated=None, premiumSubscriptionNumber=None, lastRequestedCharge=None, currency=None, unitPrice=None,):
    self.uploadLimit = uploadLimit
    self.uploadLimitEnd = uploadLimitEnd
    self.uploadLimitNextMonth = uploadLimitNextMonth
    self.premiumServiceStatus = premiumServiceStatus
    self.premiumOrderNumber = premiumOrderNumber
    self.premiumCommerceService = premiumCommerceService
    self.premiumServiceStart = premiumServiceStart
    self.premiumServiceSKU = premiumServiceSKU
    self.lastSuccessfulCharge = lastSuccessfulCharge
    self.lastFailedCharge = lastFailedCharge
    self.lastFailedChargeReason = lastFailedChargeReason
    self.nextPaymentDue = nextPaymentDue
    self.premiumLockUntil = premiumLockUntil
    self.updated = updated
    self.premiumSubscriptionNumber = premiumSubscriptionNumber
    self.lastRequestedCharge = lastRequestedCharge
    self.currency = currency
    self.unitPrice = unitPrice

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.uploadLimit = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.uploadLimitEnd = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.uploadLimitNextMonth = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.premiumServiceStatus = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.premiumOrderNumber = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.premiumCommerceService = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.premiumServiceStart = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.premiumServiceSKU = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.lastSuccessfulCharge = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.lastFailedCharge = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.lastFailedChargeReason = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I64:
          self.nextPaymentDue = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I64:
          self.premiumLockUntil = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I64:
          self.updated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRING:
          self.premiumSubscriptionNumber = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.I64:
          self.lastRequestedCharge = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRING:
          self.currency = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.I32:
          self.unitPrice = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Accounting')
    if self.uploadLimit is not None:
      oprot.writeFieldBegin('uploadLimit', TType.I64, 1)
      oprot.writeI64(self.uploadLimit)
      oprot.writeFieldEnd()
    if self.uploadLimitEnd is not None:
      oprot.writeFieldBegin('uploadLimitEnd', TType.I64, 2)
      oprot.writeI64(self.uploadLimitEnd)
      oprot.writeFieldEnd()
    if self.uploadLimitNextMonth is not None:
      oprot.writeFieldBegin('uploadLimitNextMonth', TType.I64, 3)
      oprot.writeI64(self.uploadLimitNextMonth)
      oprot.writeFieldEnd()
    if self.premiumServiceStatus is not None:
      oprot.writeFieldBegin('premiumServiceStatus', TType.I32, 4)
      oprot.writeI32(self.premiumServiceStatus)
      oprot.writeFieldEnd()
    if self.premiumOrderNumber is not None:
      oprot.writeFieldBegin('premiumOrderNumber', TType.STRING, 5)
      oprot.writeString(self.premiumOrderNumber)
      oprot.writeFieldEnd()
    if self.premiumCommerceService is not None:
      oprot.writeFieldBegin('premiumCommerceService', TType.STRING, 6)
      oprot.writeString(self.premiumCommerceService)
      oprot.writeFieldEnd()
    if self.premiumServiceStart is not None:
      oprot.writeFieldBegin('premiumServiceStart', TType.I64, 7)
      oprot.writeI64(self.premiumServiceStart)
      oprot.writeFieldEnd()
    if self.premiumServiceSKU is not None:
      oprot.writeFieldBegin('premiumServiceSKU', TType.STRING, 8)
      oprot.writeString(self.premiumServiceSKU)
      oprot.writeFieldEnd()
    if self.lastSuccessfulCharge is not None:
      oprot.writeFieldBegin('lastSuccessfulCharge', TType.I64, 9)
      oprot.writeI64(self.lastSuccessfulCharge)
      oprot.writeFieldEnd()
    if self.lastFailedCharge is not None:
      oprot.writeFieldBegin('lastFailedCharge', TType.I64, 10)
      oprot.writeI64(self.lastFailedCharge)
      oprot.writeFieldEnd()
    if self.lastFailedChargeReason is not None:
      oprot.writeFieldBegin('lastFailedChargeReason', TType.STRING, 11)
      oprot.writeString(self.lastFailedChargeReason)
      oprot.writeFieldEnd()
    if self.nextPaymentDue is not None:
      oprot.writeFieldBegin('nextPaymentDue', TType.I64, 12)
      oprot.writeI64(self.nextPaymentDue)
      oprot.writeFieldEnd()
    if self.premiumLockUntil is not None:
      oprot.writeFieldBegin('premiumLockUntil', TType.I64, 13)
      oprot.writeI64(self.premiumLockUntil)
      oprot.writeFieldEnd()
    if self.updated is not None:
      oprot.writeFieldBegin('updated', TType.I64, 14)
      oprot.writeI64(self.updated)
      oprot.writeFieldEnd()
    if self.premiumSubscriptionNumber is not None:
      oprot.writeFieldBegin('premiumSubscriptionNumber', TType.STRING, 16)
      oprot.writeString(self.premiumSubscriptionNumber)
      oprot.writeFieldEnd()
    if self.lastRequestedCharge is not None:
      oprot.writeFieldBegin('lastRequestedCharge', TType.I64, 17)
      oprot.writeI64(self.lastRequestedCharge)
      oprot.writeFieldEnd()
    if self.currency is not None:
      oprot.writeFieldBegin('currency', TType.STRING, 18)
      oprot.writeString(self.currency)
      oprot.writeFieldEnd()
    if self.unitPrice is not None:
      oprot.writeFieldBegin('unitPrice', TType.I32, 19)
      oprot.writeI32(self.unitPrice)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class User(object):
  """
   This represents the information about a single user account.
  <dl>
   <dt>id</dt>
     <dd>The unique numeric identifier for the account, which will not
     change for the lifetime of the account.
     </dd>
  
   <dt>username</dt>
     <dd>The name that the user provides to log in to their
     account. In the future, this may be empty for some accounts if their login
     process is indirect (e.g. via social networks, etc.).
     May only contain a-z, 0-9, or '-', and may not start or end with the '-'
     <br/>
     Length:  EDAM_USER_USERNAME_LEN_MIN - EDAM_USER_USERNAME_LEN_MAX
     <br/>
     Regex:  EDAM_USER_USERNAME_REGEX
     </dd>
  
   <dt>email</dt>
     <dd>The email address registered for the user.  Must comply with
     RFC 2821 and RFC 2822.<br/>
     Length:  EDAM_EMAIL_LEN_MIN - EDAM_EMAIL_LEN_MAX
     <br/>
     Regex:  EDAM_EMAIL_REGEX
     </dd>
  
   <dt>name</dt>
     <dd>The printable name of the user, which may be a combination
     of given and family names.  This is used instead of separate "first"
     and "last" names due to variations in international name format/order.
     May not start or end with a whitespace character.  May contain any
     character but carriage return or newline (Unicode classes Zl and Zp).
     <br/>
     Length:  EDAM_USER_NAME_LEN_MIN - EDAM_USER_NAME_LEN_MAX
     <br/>
     Regex:  EDAM_USER_NAME_REGEX
     </dd>
  
   <dt>timezone</dt>
     <dd>The zone ID for the user's default location.  If present,
     this may be used to localize the display of any timestamp for which no
     other timezone is available - for example, an note that arrives via
     a micro-browser may not contain enough information to display its
     local time, so this default timezone may be assigned to the note.
     The format must be encoded as a standard zone ID such as
     "America/Los_Angeles" or "GMT+08:00"
     <br/>
     Length:  EDAM_TIMEZONE_LEN_MIN - EDAM_TIMEZONE_LEN_MAX
     <br/>
     Regex:  EDAM_TIMEZONE_REGEX
     </dd>
  
   <dt>privilege</dt>
     <dd>The level of access permitted for the user.
     </dd>
  
   <dt>created</dt>
     <dd>The date and time when this user account was created in the
     service.
     </dd>
  
   <dt>updated</dt>
     <dd>The date and time when this user account was last modified
     in the service.
     </dd>
  
   <dt>deleted</dt>
     <dd>If the account has been deleted from the system (e.g. as
     the result of a legal request by the user), the date and time of the
     deletion will be represented here.  If not, this value will not be set.
     </dd>
  
   <dt>active</dt>
     <dd>If the user account is available for login and
     synchronization, this flag will be set to true.
     </dd>
  
   <dt>shardId</dt>
     <dd>The name of the virtual server that manages the state of
     this user.  This value is used internally to determine which system should
     service requests about this user's data.
     </dd>
  
   <dt>attributes</dt>
     <dd>If present, this will contain a list of the attributes
     for this user account.
     </dd>
  
   <dt>accounting</dt>
     <dd>Bookkeeping information for the user's subscription.
     </dd>
   </dl>
  
  Attributes:
   - id
   - username
   - email
   - name
   - timezone
   - privilege
   - created
   - updated
   - deleted
   - active
   - shardId
   - attributes
   - accounting
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None, None, ), # 1
    (2, TType.STRING, 'username', None, None, ), # 2
    (3, TType.STRING, 'email', None, None, ), # 3
    (4, TType.STRING, 'name', None, None, ), # 4
    None, # 5
    (6, TType.STRING, 'timezone', None, None, ), # 6
    (7, TType.I32, 'privilege', None, None, ), # 7
    None, # 8
    (9, TType.I64, 'created', None, None, ), # 9
    (10, TType.I64, 'updated', None, None, ), # 10
    (11, TType.I64, 'deleted', None, None, ), # 11
    None, # 12
    (13, TType.BOOL, 'active', None, None, ), # 13
    (14, TType.STRING, 'shardId', None, None, ), # 14
    (15, TType.STRUCT, 'attributes', (UserAttributes, UserAttributes.thrift_spec), None, ), # 15
    (16, TType.STRUCT, 'accounting', (Accounting, Accounting.thrift_spec), None, ), # 16
  )

  def __init__(self, id=None, username=None, email=None, name=None, timezone=None, privilege=None, created=None, updated=None, deleted=None, active=None, shardId=None, attributes=None, accounting=None,):
    self.id = id
    self.username = username
    self.email = email
    self.name = name
    self.timezone = timezone
    self.privilege = privilege
    self.created = created
    self.updated = updated
    self.deleted = deleted
    self.active = active
    self.shardId = shardId
    self.attributes = attributes
    self.accounting = accounting

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.username = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.email = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.timezone = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.privilege = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.created = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.updated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I64:
          self.deleted = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BOOL:
          self.active = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.shardId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRUCT:
          self.attributes = UserAttributes()
          self.attributes.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRUCT:
          self.accounting = Accounting()
          self.accounting.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('User')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 2)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.email is not None:
      oprot.writeFieldBegin('email', TType.STRING, 3)
      oprot.writeString(self.email)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 4)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.timezone is not None:
      oprot.writeFieldBegin('timezone', TType.STRING, 6)
      oprot.writeString(self.timezone)
      oprot.writeFieldEnd()
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.I32, 7)
      oprot.writeI32(self.privilege)
      oprot.writeFieldEnd()
    if self.created is not None:
      oprot.writeFieldBegin('created', TType.I64, 9)
      oprot.writeI64(self.created)
      oprot.writeFieldEnd()
    if self.updated is not None:
      oprot.writeFieldBegin('updated', TType.I64, 10)
      oprot.writeI64(self.updated)
      oprot.writeFieldEnd()
    if self.deleted is not None:
      oprot.writeFieldBegin('deleted', TType.I64, 11)
      oprot.writeI64(self.deleted)
      oprot.writeFieldEnd()
    if self.active is not None:
      oprot.writeFieldBegin('active', TType.BOOL, 13)
      oprot.writeBool(self.active)
      oprot.writeFieldEnd()
    if self.shardId is not None:
      oprot.writeFieldBegin('shardId', TType.STRING, 14)
      oprot.writeString(self.shardId)
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.STRUCT, 15)
      self.attributes.write(oprot)
      oprot.writeFieldEnd()
    if self.accounting is not None:
      oprot.writeFieldBegin('accounting', TType.STRUCT, 16)
      self.accounting.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Tag(object):
  """
   A tag within a user's account is a unique name which may be organized
   a simple hierarchy.
  <dl>
   <dt>guid</dt>
     <dd>The unique identifier of this tag. Will be set by the service,
     so may be omitted by the client when creating the Tag.
     <br/>
     Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
     <br/>
     Regex:  EDAM_GUID_REGEX
     </dd>
  
   <dt>name</dt>
     <dd>A sequence of characters representing the tag's identifier.
     Case is preserved, but is ignored for comparisons.
     This means that an account may only have one tag with a given name, via
     case-insensitive comparison, so an account may not have both "food" and
     "Food" tags.
     May not contain a comma (','), and may not begin or end with a space.
     <br/>
     Length:  EDAM_TAG_NAME_LEN_MIN - EDAM_TAG_NAME_LEN_MAX
     <br/>
     Regex:  EDAM_TAG_NAME_REGEX
     </dd>
  
   <dt>parentGuid</dt>
     <dd>If this is set, then this is the GUID of the tag that
     holds this tag within the tag organizational hierarchy.  If this is
     not set, then the tag has no parent and it is a "top level" tag.
     Cycles are not allowed (e.g. a->parent->parent == a) and will be
     rejected by the service.
     <br/>
     Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
     <br/>
     Regex:  EDAM_GUID_REGEX
     </dd>
  
   <dt>updateSequenceNum</dt>
     <dd>A number identifying the last transaction to
     modify the state of this object.  The USN values are sequential within an
     account, and can be used to compare the order of modifications within the
     service.
     </dd>
   </dl>
  
  Attributes:
   - guid
   - name
   - parentGuid
   - updateSequenceNum
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.STRING, 'parentGuid', None, None, ), # 3
    (4, TType.I32, 'updateSequenceNum', None, None, ), # 4
  )

  def __init__(self, guid=None, name=None, parentGuid=None, updateSequenceNum=None,):
    self.guid = guid
    self.name = name
    self.parentGuid = parentGuid
    self.updateSequenceNum = updateSequenceNum

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.parentGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Tag')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.parentGuid is not None:
      oprot.writeFieldBegin('parentGuid', TType.STRING, 3)
      oprot.writeString(self.parentGuid)
      oprot.writeFieldEnd()
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 4)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LazyMap(object):
  """
  A structure that wraps a map of name/value pairs whose values are not
  always present in the structure in order to reduce space when obtaining
  batches of entities that contain the map.
  
  When the server provides the client with a LazyMap, it will fill in either
  the keysOnly field or the fullMap field, but never both, based on the API
  and parameters.
  
  When a client provides a LazyMap to the server as part of an update to
  an object, the server will only update the LazyMap if the fullMap field is
  set. If the fullMap field is not set, the server will not make any changes
  to the map.
  
  Check the API documentation of the individual calls involving the LazyMap
  for full details including the constraints of the names and values of the
  map.
  
  <dl>
  <dt>keysOnly</dt>
    <dd>The set of keys for the map.  This field is ignored by the
        server when set.
    </dd>
  
  <dt>fullMap</dt>
    <dd>The complete map, including all keys and values.
    </dd>
  </dl>
  
  Attributes:
   - keysOnly
   - fullMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'keysOnly', (TType.STRING,None), None, ), # 1
    (2, TType.MAP, 'fullMap', (TType.STRING,None,TType.STRING,None), None, ), # 2
  )

  def __init__(self, keysOnly=None, fullMap=None,):
    self.keysOnly = keysOnly
    self.fullMap = fullMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.keysOnly = set()
          (_etype17, _size14) = iprot.readSetBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readString();
            self.keysOnly.add(_elem19)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.fullMap = {}
          (_ktype21, _vtype22, _size20 ) = iprot.readMapBegin() 
          for _i24 in xrange(_size20):
            _key25 = iprot.readString();
            _val26 = iprot.readString();
            self.fullMap[_key25] = _val26
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LazyMap')
    if self.keysOnly is not None:
      oprot.writeFieldBegin('keysOnly', TType.SET, 1)
      oprot.writeSetBegin(TType.STRING, len(self.keysOnly))
      for iter27 in self.keysOnly:
        oprot.writeString(iter27)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.fullMap is not None:
      oprot.writeFieldBegin('fullMap', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.fullMap))
      for kiter28,viter29 in self.fullMap.items():
        oprot.writeString(kiter28)
        oprot.writeString(viter29)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResourceAttributes(object):
  """
  Structure holding the optional attributes of a Resource
  <dl>
  <dt>sourceURL</dt>
    <dd>the original location where the resource was hosted
    <br/>
     Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
    </dd>
  
  <dt>timestamp</dt>
    <dd>the date and time that is associated with this resource
    (e.g. the time embedded in an image from a digital camera with a clock)
    </dd>
  
  <dt>latitude</dt>
    <dd>the latitude where the resource was captured
    </dd>
  
  <dt>longitude</dt>
    <dd>the longitude where the resource was captured
    </dd>
  
  <dt>altitude</dt>
    <dd>the altitude where the resource was captured
    </dd>
  
  <dt>cameraMake</dt>
    <dd>information about an image's camera, e.g. as embedded in
    the image's EXIF data
    <br/>
    Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
    </dd>
  
  <dt>cameraModel</dt>
    <dd>information about an image's camera, e.g. as embedded
    in the image's EXIF data
    <br/>
    Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
    </dd>
  
  <dt>clientWillIndex</dt>
    <dd>if true, then the original client that submitted
    the resource plans to submit the recognition index for this resource at a
    later time.
    </dd>
  
  <dt>recoType</dt>
    <dd>DEPRECATED - this field is no longer set by the service, so should
      be ignored.
    </dd>
  
  <dt>fileName</dt>
    <dd>if the resource came from a source that provided an
    explicit file name, the original name will be stored here.  Many resources
    come from unnamed sources, so this will not always be set.
    </dd>
  
  <dt>attachment</dt>
    <dd>this will be true if the resource should be displayed as an attachment,
    or false if the resource should be displayed inline (if possible).
    </dd>
  
  <dt>applicationData</dt>
  <dd>Provides a location for applications to store a relatively small
  (4kb) blob of data associated with a Resource that is not visible to the user
  and that is opaque to the Evernote service. A single application may use at most
  one entry in this map, using its API consumer key as the map key. See the
  documentation for LazyMap for a description of when the actual map values
  are returned by the service.
  <p>To safely add or modify your application's entry in the map, use
  NoteStore.setResourceApplicationDataEntry. To safely remove your application's
  entry from the map, use NoteStore.unsetResourceApplicationDataEntry.</p>
  Minimum length of a name (key): EDAM_APPLICATIONDATA_NAME_LEN_MIN
  <br/>
  Sum max size of key and value: EDAM_APPLICATIONDATA_ENTRY_LEN_MAX
  <br/>
  Syntax regex for name (key): EDAM_APPLICATIONDATA_NAME_REGEX
  </dd>
  
  </dl>
  
  Attributes:
   - sourceURL
   - timestamp
   - latitude
   - longitude
   - altitude
   - cameraMake
   - cameraModel
   - clientWillIndex
   - recoType
   - fileName
   - attachment
   - applicationData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sourceURL', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.DOUBLE, 'latitude', None, None, ), # 3
    (4, TType.DOUBLE, 'longitude', None, None, ), # 4
    (5, TType.DOUBLE, 'altitude', None, None, ), # 5
    (6, TType.STRING, 'cameraMake', None, None, ), # 6
    (7, TType.STRING, 'cameraModel', None, None, ), # 7
    (8, TType.BOOL, 'clientWillIndex', None, None, ), # 8
    (9, TType.STRING, 'recoType', None, None, ), # 9
    (10, TType.STRING, 'fileName', None, None, ), # 10
    (11, TType.BOOL, 'attachment', None, None, ), # 11
    (12, TType.STRUCT, 'applicationData', (LazyMap, LazyMap.thrift_spec), None, ), # 12
  )

  def __init__(self, sourceURL=None, timestamp=None, latitude=None, longitude=None, altitude=None, cameraMake=None, cameraModel=None, clientWillIndex=None, recoType=None, fileName=None, attachment=None, applicationData=None,):
    self.sourceURL = sourceURL
    self.timestamp = timestamp
    self.latitude = latitude
    self.longitude = longitude
    self.altitude = altitude
    self.cameraMake = cameraMake
    self.cameraModel = cameraModel
    self.clientWillIndex = clientWillIndex
    self.recoType = recoType
    self.fileName = fileName
    self.attachment = attachment
    self.applicationData = applicationData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sourceURL = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.latitude = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.longitude = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          self.altitude = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.cameraMake = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.cameraModel = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.clientWillIndex = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.recoType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.fileName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.attachment = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.applicationData = LazyMap()
          self.applicationData.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResourceAttributes')
    if self.sourceURL is not None:
      oprot.writeFieldBegin('sourceURL', TType.STRING, 1)
      oprot.writeString(self.sourceURL)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.latitude is not None:
      oprot.writeFieldBegin('latitude', TType.DOUBLE, 3)
      oprot.writeDouble(self.latitude)
      oprot.writeFieldEnd()
    if self.longitude is not None:
      oprot.writeFieldBegin('longitude', TType.DOUBLE, 4)
      oprot.writeDouble(self.longitude)
      oprot.writeFieldEnd()
    if self.altitude is not None:
      oprot.writeFieldBegin('altitude', TType.DOUBLE, 5)
      oprot.writeDouble(self.altitude)
      oprot.writeFieldEnd()
    if self.cameraMake is not None:
      oprot.writeFieldBegin('cameraMake', TType.STRING, 6)
      oprot.writeString(self.cameraMake)
      oprot.writeFieldEnd()
    if self.cameraModel is not None:
      oprot.writeFieldBegin('cameraModel', TType.STRING, 7)
      oprot.writeString(self.cameraModel)
      oprot.writeFieldEnd()
    if self.clientWillIndex is not None:
      oprot.writeFieldBegin('clientWillIndex', TType.BOOL, 8)
      oprot.writeBool(self.clientWillIndex)
      oprot.writeFieldEnd()
    if self.recoType is not None:
      oprot.writeFieldBegin('recoType', TType.STRING, 9)
      oprot.writeString(self.recoType)
      oprot.writeFieldEnd()
    if self.fileName is not None:
      oprot.writeFieldBegin('fileName', TType.STRING, 10)
      oprot.writeString(self.fileName)
      oprot.writeFieldEnd()
    if self.attachment is not None:
      oprot.writeFieldBegin('attachment', TType.BOOL, 11)
      oprot.writeBool(self.attachment)
      oprot.writeFieldEnd()
    if self.applicationData is not None:
      oprot.writeFieldBegin('applicationData', TType.STRUCT, 12)
      self.applicationData.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Resource(object):
  """
  Every media file that is embedded or attached to a note is represented
  through a Resource entry.
  <dl>
  <dt>guid</dt>
    <dd>The unique identifier of this resource.  Will be set whenever
    a resource is retrieved from the service, but may be null when a client
    is creating a resource.
    <br/>
    Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
    <br/>
    Regex:  EDAM_GUID_REGEX
    </dd>
  
  <dt>noteGuid</dt>
    <dd>The unique identifier of the Note that holds this
    Resource. Will be set whenever the resource is retrieved from the service,
    but may be null when a client is creating a resource.
    <br/>
    Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
    <br/>
    Regex:  EDAM_GUID_REGEX
    </dd>
  
  <dt>data</dt>
    <dd>The contents of the resource.
    Maximum length:  The data.body is limited to EDAM_RESOURCE_SIZE_MAX_FREE
    for free accounts and EDAM_RESOURCE_SIZE_MAX_PREMIUM for premium accounts.
    </dd>
  
  <dt>mime</dt>
    <dd>The MIME type for the embedded resource.  E.g. "image/gif"
    <br/>
    Length:  EDAM_MIME_LEN_MIN - EDAM_MIME_LEN_MAX
    <br/>
    Regex:  EDAM_MIME_REGEX
    </dd>
  
  <dt>width</dt>
    <dd>If set, this contains the display width of this resource, in
    pixels.
    </dd>
  
  <dt>height</dt>
    <dd>If set, this contains the display height of this resource,
    in pixels.
    </dd>
  
  <dt>duration</dt>
    <dd>DEPRECATED: ignored.
    </dd>
  
  <dt>active</dt>
    <dd>DEPRECATED: ignored.
    </dd>
  
  <dt>recognition</dt>
    <dd>If set, this will hold the encoded data that provides
    information on search and recognition within this resource.
    </dd>
  
  <dt>attributes</dt>
    <dd>A list of the attributes for this resource.
    </dd>
  
  <dt>updateSequenceNum</dt>
    <dd>A number identifying the last transaction to
    modify the state of this object. The USN values are sequential within an
    account, and can be used to compare the order of modifications within the
    service.
    </dd>
  
  <dt>alternateData</dt>
    <dd>Some Resources may be assigned an alternate data format by the service
    which may be more appropriate for indexing or rendering than the original
    data provided by the user.  In these cases, the alternate data form will
    be available via this Data element.  If a Resource has no alternate form,
    this field will be unset.</dd>
  </dl>
  
  Attributes:
   - guid
   - noteGuid
   - data
   - mime
   - width
   - height
   - duration
   - active
   - recognition
   - attributes
   - updateSequenceNum
   - alternateData
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRING, 'noteGuid', None, None, ), # 2
    (3, TType.STRUCT, 'data', (Data, Data.thrift_spec), None, ), # 3
    (4, TType.STRING, 'mime', None, None, ), # 4
    (5, TType.I16, 'width', None, None, ), # 5
    (6, TType.I16, 'height', None, None, ), # 6
    (7, TType.I16, 'duration', None, None, ), # 7
    (8, TType.BOOL, 'active', None, None, ), # 8
    (9, TType.STRUCT, 'recognition', (Data, Data.thrift_spec), None, ), # 9
    None, # 10
    (11, TType.STRUCT, 'attributes', (ResourceAttributes, ResourceAttributes.thrift_spec), None, ), # 11
    (12, TType.I32, 'updateSequenceNum', None, None, ), # 12
    (13, TType.STRUCT, 'alternateData', (Data, Data.thrift_spec), None, ), # 13
  )

  def __init__(self, guid=None, noteGuid=None, data=None, mime=None, width=None, height=None, duration=None, active=None, recognition=None, attributes=None, updateSequenceNum=None, alternateData=None,):
    self.guid = guid
    self.noteGuid = noteGuid
    self.data = data
    self.mime = mime
    self.width = width
    self.height = height
    self.duration = duration
    self.active = active
    self.recognition = recognition
    self.attributes = attributes
    self.updateSequenceNum = updateSequenceNum
    self.alternateData = alternateData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.noteGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.data = Data()
          self.data.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.mime = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.width = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I16:
          self.height = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I16:
          self.duration = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.active = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.recognition = Data()
          self.recognition.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.attributes = ResourceAttributes()
          self.attributes.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.alternateData = Data()
          self.alternateData.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Resource')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.noteGuid is not None:
      oprot.writeFieldBegin('noteGuid', TType.STRING, 2)
      oprot.writeString(self.noteGuid)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRUCT, 3)
      self.data.write(oprot)
      oprot.writeFieldEnd()
    if self.mime is not None:
      oprot.writeFieldBegin('mime', TType.STRING, 4)
      oprot.writeString(self.mime)
      oprot.writeFieldEnd()
    if self.width is not None:
      oprot.writeFieldBegin('width', TType.I16, 5)
      oprot.writeI16(self.width)
      oprot.writeFieldEnd()
    if self.height is not None:
      oprot.writeFieldBegin('height', TType.I16, 6)
      oprot.writeI16(self.height)
      oprot.writeFieldEnd()
    if self.duration is not None:
      oprot.writeFieldBegin('duration', TType.I16, 7)
      oprot.writeI16(self.duration)
      oprot.writeFieldEnd()
    if self.active is not None:
      oprot.writeFieldBegin('active', TType.BOOL, 8)
      oprot.writeBool(self.active)
      oprot.writeFieldEnd()
    if self.recognition is not None:
      oprot.writeFieldBegin('recognition', TType.STRUCT, 9)
      self.recognition.write(oprot)
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.STRUCT, 11)
      self.attributes.write(oprot)
      oprot.writeFieldEnd()
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 12)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    if self.alternateData is not None:
      oprot.writeFieldBegin('alternateData', TType.STRUCT, 13)
      self.alternateData.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NoteAttributes(object):
  """
  The list of optional attributes that can be stored on a note.
  <dl>
  <dt>subjectDate</dt>
    <dd>time that the note refers to
    </dd>
  
  <dt>latitude</dt>
    <dd>the latitude where the note was taken
    </dd>
  
  <dt>longitude</dt>
    <dd>the longitude where the note was taken
    </dd>
  
  <dt>altitude</dt>
    <dd>the altitude where the note was taken
    </dd>
  
  <dt>author</dt>
    <dd>the author of the content of the note
    <br/>
    Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
    </dd>
  
  <dt>source</dt>
    <dd>the method that the note was added to the account, if the
    note wasn't directly authored in an Evernote desktop client.
    <br/>
    Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
    </dd>
  
  <dt>sourceURL</dt>
    <dd>the original location where the resource was hosted. For web clips,
    this will be the URL of the page that was clipped.
    <br/>
    Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
    </dd>
  
  <dt>sourceApplication</dt>
    <dd>an identifying string for the application that
    created this note.  This string does not have a guaranteed syntax or
    structure -- it is intended for human inspection and tracking.
    <br/>
    Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
    </dd>
  
  <dt>shareDate</dt>
   <dd>The date and time when this note was directly shared via its own URL.
   This is only set on notes that were individually shared - it is independent
   of any notebook-level sharing of the containing notepbook. This field
   is treated as "read-only" for clients; the server will ignore changes
   to this field from an external client.
   </dd>
  
  <dt>placeName</dt>
  <dd>Allows the user to assign a human-readable location name associated
  with a note. Users may assign values like 'Home' and 'Work'. Place
  names may also be populated with values from geonames database
  (e.g., a restaurant name). Applications are encouraged to normalize values
  so that grouping values by place name provides a useful result. Applications
  MUST NOT automatically add place name values based on geolocation without
  confirmation from the user; that is, the value in this field should be
  more useful than a simple automated lookup based on the note's latitude
  and longitude.</dd>
  
  <dt>contentClass</dt>
  <dd>The class (or type) of note. This field is used to indicate to
  clients that special structured information is represented within
  the note such that special rules apply when making
  modifications. If contentClass is set and the client
  application does not specifically support the specified class,
  the client MUST treat the note as read-only. In this case, the
  client MAY modify the note's notebook and tags via the
  Note.notebookGuid and Note.tagGuids fields.
  <p>Applications should set contentClass only when they are creating notes
  that contain structured information that needs to be maintained in order
  for the user to be able to use the note within that application.
  Setting contentClass makes a note read-only in other applications, so
  there is a trade-off when an application chooses to use contentClass.
  Applications that set contentClass when creating notes must use a contentClass
  string of the form <i>CompanyName.ApplicationName</i> to ensure uniqueness.</p>
  Length restrictions: EDAM_NOTE_CONTENT_CLASS_LEN_MIN, EDAM_NOTE_CONTENT_CLASS_LEN_MAX
  <br/>
  Regex: EDAM_NOTE_CONTENT_CLASS_REGEX
  </dd>
  
  <dt>applicationData</dt>
  <dd>Provides a location for applications to store a relatively small
  (4kb) blob of data that is not meant to be visible to the user and
  that is opaque to the Evernote service. A single application may use at most
  one entry in this map, using its API consumer key as the map key. See the
  documentation for LazyMap for a description of when the actual map values
  are returned by the service.
  <p>To safely add or modify your application's entry in the map, use
  NoteStore.setNoteApplicationDataEntry. To safely remove your application's
  entry from the map, use NoteStore.unsetNoteApplicationDataEntry.</p>
  Minimum length of a name (key): EDAM_APPLICATIONDATA_NAME_LEN_MIN
  <br/>
  Sum max size of key and value: EDAM_APPLICATIONDATA_ENTRY_LEN_MAX
  <br/>
  Syntax regex for name (key): EDAM_APPLICATIONDATA_NAME_REGEX
  </dd>
  
  <dt>lastEditedBy</dt>
  <dd>An indication of who made the last change to the note.  If you are
  accessing the note via a shared notebook to which you have modification
  rights, or if you are the owner of the notebook to which the note belongs,
  then you have access to the value.  In this case, the value will be
  unset if the owner of the notebook containing the note was the last to
  make the modification, else it will be a string describing the
  guest who made the last edit.  If you do not have access to this value,
  it will be left unset.  This field is read-only by clients.  The server
  will ignore all values set by clients into this field.</dd>
  
  </dl>
  
  Attributes:
   - subjectDate
   - latitude
   - longitude
   - altitude
   - author
   - source
   - sourceURL
   - sourceApplication
   - shareDate
   - placeName
   - contentClass
   - applicationData
   - lastEditedBy
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'subjectDate', None, None, ), # 1
    None, # 2
    None, # 3
    None, # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.DOUBLE, 'latitude', None, None, ), # 10
    (11, TType.DOUBLE, 'longitude', None, None, ), # 11
    (12, TType.DOUBLE, 'altitude', None, None, ), # 12
    (13, TType.STRING, 'author', None, None, ), # 13
    (14, TType.STRING, 'source', None, None, ), # 14
    (15, TType.STRING, 'sourceURL', None, None, ), # 15
    (16, TType.STRING, 'sourceApplication', None, None, ), # 16
    (17, TType.I64, 'shareDate', None, None, ), # 17
    None, # 18
    None, # 19
    None, # 20
    (21, TType.STRING, 'placeName', None, None, ), # 21
    (22, TType.STRING, 'contentClass', None, None, ), # 22
    (23, TType.STRUCT, 'applicationData', (LazyMap, LazyMap.thrift_spec), None, ), # 23
    (24, TType.STRING, 'lastEditedBy', None, None, ), # 24
  )

  def __init__(self, subjectDate=None, latitude=None, longitude=None, altitude=None, author=None, source=None, sourceURL=None, sourceApplication=None, shareDate=None, placeName=None, contentClass=None, applicationData=None, lastEditedBy=None,):
    self.subjectDate = subjectDate
    self.latitude = latitude
    self.longitude = longitude
    self.altitude = altitude
    self.author = author
    self.source = source
    self.sourceURL = sourceURL
    self.sourceApplication = sourceApplication
    self.shareDate = shareDate
    self.placeName = placeName
    self.contentClass = contentClass
    self.applicationData = applicationData
    self.lastEditedBy = lastEditedBy

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.subjectDate = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.DOUBLE:
          self.latitude = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.DOUBLE:
          self.longitude = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.DOUBLE:
          self.altitude = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.author = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.source = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRING:
          self.sourceURL = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRING:
          self.sourceApplication = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.I64:
          self.shareDate = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.STRING:
          self.placeName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.STRING:
          self.contentClass = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.STRUCT:
          self.applicationData = LazyMap()
          self.applicationData.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 24:
        if ftype == TType.STRING:
          self.lastEditedBy = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NoteAttributes')
    if self.subjectDate is not None:
      oprot.writeFieldBegin('subjectDate', TType.I64, 1)
      oprot.writeI64(self.subjectDate)
      oprot.writeFieldEnd()
    if self.latitude is not None:
      oprot.writeFieldBegin('latitude', TType.DOUBLE, 10)
      oprot.writeDouble(self.latitude)
      oprot.writeFieldEnd()
    if self.longitude is not None:
      oprot.writeFieldBegin('longitude', TType.DOUBLE, 11)
      oprot.writeDouble(self.longitude)
      oprot.writeFieldEnd()
    if self.altitude is not None:
      oprot.writeFieldBegin('altitude', TType.DOUBLE, 12)
      oprot.writeDouble(self.altitude)
      oprot.writeFieldEnd()
    if self.author is not None:
      oprot.writeFieldBegin('author', TType.STRING, 13)
      oprot.writeString(self.author)
      oprot.writeFieldEnd()
    if self.source is not None:
      oprot.writeFieldBegin('source', TType.STRING, 14)
      oprot.writeString(self.source)
      oprot.writeFieldEnd()
    if self.sourceURL is not None:
      oprot.writeFieldBegin('sourceURL', TType.STRING, 15)
      oprot.writeString(self.sourceURL)
      oprot.writeFieldEnd()
    if self.sourceApplication is not None:
      oprot.writeFieldBegin('sourceApplication', TType.STRING, 16)
      oprot.writeString(self.sourceApplication)
      oprot.writeFieldEnd()
    if self.shareDate is not None:
      oprot.writeFieldBegin('shareDate', TType.I64, 17)
      oprot.writeI64(self.shareDate)
      oprot.writeFieldEnd()
    if self.placeName is not None:
      oprot.writeFieldBegin('placeName', TType.STRING, 21)
      oprot.writeString(self.placeName)
      oprot.writeFieldEnd()
    if self.contentClass is not None:
      oprot.writeFieldBegin('contentClass', TType.STRING, 22)
      oprot.writeString(self.contentClass)
      oprot.writeFieldEnd()
    if self.applicationData is not None:
      oprot.writeFieldBegin('applicationData', TType.STRUCT, 23)
      self.applicationData.write(oprot)
      oprot.writeFieldEnd()
    if self.lastEditedBy is not None:
      oprot.writeFieldBegin('lastEditedBy', TType.STRING, 24)
      oprot.writeString(self.lastEditedBy)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Note(object):
  """
  Represents a single note in the user's account.
  
  <dl>
  <dt>guid</dt>
    <dd>The unique identifier of this note.  Will be set by the
    server, but will be omitted by clients calling NoteStore.createNote()
    <br/>
    Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
    <br/>
    Regex:  EDAM_GUID_REGEX
    </dd>
  
  <dt>title</dt>
    <dd>The subject of the note.  Can't begin or end with a space.
    <br/>
    Length:  EDAM_NOTE_TITLE_LEN_MIN - EDAM_NOTE_TITLE_LEN_MAX
    <br/>
    Regex:  EDAM_NOTE_TITLE_REGEX
    </dd>
  
  <dt>content</dt>
    <dd>The XHTML block that makes up the note.  This is
    the canonical form of the note's contents, so will include abstract
    Evernote tags for internal resource references.  A client may create
    a separate transformed version of this content for internal presentation,
    but the same canonical bytes should be used for transmission and
    comparison unless the user chooses to modify their content.
    <br/>
    Length:  EDAM_NOTE_CONTENT_LEN_MIN - EDAM_NOTE_CONTENT_LEN_MAX
    </dd>
  
  <dt>contentHash</dt>
    <dd>The binary MD5 checksum of the UTF-8 encoded content
    body. This will always be set by the server, but clients may choose to omit
    this when they submit a note with content.
    <br/>
    Length:  EDAM_HASH_LEN (exactly)
    </dd>
  
  <dt>contentLength</dt>
    <dd>The number of Unicode characters in the content of
    the note.  This will always be set by the service, but clients may choose
    to omit this value when they submit a Note.
    </dd>
  
  <dt>created</dt>
    <dd>The date and time when the note was created in one of the
    clients.  In most cases, this will match the user's sense of when
    the note was created, and ordering between notes will be based on
    ordering of this field.  However, this is not a "reliable" timestamp
    if a client has an incorrect clock, so it cannot provide a true absolute
    ordering between notes.  Notes created directly through the service
    (e.g. via the web GUI) will have an absolutely ordered "created" value.
    </dd>
  
  <dt>updated</dt>
    <dd>The date and time when the note was last modified in one of
    the clients.  In most cases, this will match the user's sense of when
    the note was modified, but this field may not be absolutely reliable
    due to the possibility of client clock errors.
    </dd>
  
  <dt>deleted</dt>
    <dd>If present, the note is considered "deleted", and this
    stores the date and time when the note was deleted by one of the clients.
    In most cases, this will match the user's sense of when the note was
    deleted, but this field may be unreliable due to the possibility of
    client clock errors.
    </dd>
  
  <dt>active</dt>
    <dd>If the note is available for normal actions and viewing,
    this flag will be set to true.
    </dd>
  
  <dt>updateSequenceNum</dt>
    <dd>A number identifying the last transaction to
    modify the state of this note (including changes to the note's attributes
    or resources).  The USN values are sequential within an account,
    and can be used to compare the order of modifications within the service.
    </dd>
  
  <dt>notebookGuid</dt>
    <dd>The unique identifier of the notebook that contains
    this note.  If no notebookGuid is provided on a call to createNote(), the
    default notebook will be used instead.
    <br/>
    Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
    <br/>
    Regex:  EDAM_GUID_REGEX
    </dd>
  
  <dt>tagGuids</dt>
    <dd>A list of the GUID identifiers for tags that are applied to this note.
    This may be provided in a call to createNote() to unambiguously declare
    the tags that should be assigned to the new note.  Alternately, clients
    may pass the names of desired tags via the 'tagNames' field during
    note creation.
    If the list of tags are omitted on a call to createNote(), then
    the server will assume that no changes have been made to the resources.
    Maximum:  EDAM_NOTE_TAGS_MAX tags per note
    </dd>
  
  <dt>resources</dt>
    <dd>The list of resources that are embedded within this note.
    If the list of resources are omitted on a call to updateNote(), then
    the server will assume that no changes have been made to the resources.
    The binary contents of the resources must be provided when the resource
    is first sent to the service, but it will be omitted by the service when
    the Note is returned in the future.
    Maximum:  EDAM_NOTE_RESOURCES_MAX resources per note
    </dd>
  
  <dt>attributes</dt>
    <dd>A list of the attributes for this note.
    If the list of attributes are omitted on a call to updateNote(), then
    the server will assume that no changes have been made to the resources.
    </dd>
  
  <dt>tagNames</dt>
    <dd>May be provided by clients during calls to createNote() as an
    alternative to providing the tagGuids of existing tags.  If any tagNames
    are provided during createNote(), these will be found, or created if they
    don't already exist.  Created tags will have no parent (they will be at
    the top level of the tag panel).
    </dd>
  </dl>
  
  Attributes:
   - guid
   - title
   - content
   - contentHash
   - contentLength
   - created
   - updated
   - deleted
   - active
   - updateSequenceNum
   - notebookGuid
   - tagGuids
   - resources
   - attributes
   - tagNames
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRING, 'title', None, None, ), # 2
    (3, TType.STRING, 'content', None, None, ), # 3
    (4, TType.STRING, 'contentHash', None, None, ), # 4
    (5, TType.I32, 'contentLength', None, None, ), # 5
    (6, TType.I64, 'created', None, None, ), # 6
    (7, TType.I64, 'updated', None, None, ), # 7
    (8, TType.I64, 'deleted', None, None, ), # 8
    (9, TType.BOOL, 'active', None, None, ), # 9
    (10, TType.I32, 'updateSequenceNum', None, None, ), # 10
    (11, TType.STRING, 'notebookGuid', None, None, ), # 11
    (12, TType.LIST, 'tagGuids', (TType.STRING,None), None, ), # 12
    (13, TType.LIST, 'resources', (TType.STRUCT,(Resource, Resource.thrift_spec)), None, ), # 13
    (14, TType.STRUCT, 'attributes', (NoteAttributes, NoteAttributes.thrift_spec), None, ), # 14
    (15, TType.LIST, 'tagNames', (TType.STRING,None), None, ), # 15
  )

  def __init__(self, guid=None, title=None, content=None, contentHash=None, contentLength=None, created=None, updated=None, deleted=None, active=None, updateSequenceNum=None, notebookGuid=None, tagGuids=None, resources=None, attributes=None, tagNames=None,):
    self.guid = guid
    self.title = title
    self.content = content
    self.contentHash = contentHash
    self.contentLength = contentLength
    self.created = created
    self.updated = updated
    self.deleted = deleted
    self.active = active
    self.updateSequenceNum = updateSequenceNum
    self.notebookGuid = notebookGuid
    self.tagGuids = tagGuids
    self.resources = resources
    self.attributes = attributes
    self.tagNames = tagNames

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.content = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.contentHash = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.contentLength = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.created = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.updated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.deleted = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.active = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.notebookGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.tagGuids = []
          (_etype33, _size30) = iprot.readListBegin()
          for _i34 in xrange(_size30):
            _elem35 = iprot.readString();
            self.tagGuids.append(_elem35)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.LIST:
          self.resources = []
          (_etype39, _size36) = iprot.readListBegin()
          for _i40 in xrange(_size36):
            _elem41 = Resource()
            _elem41.read(iprot)
            self.resources.append(_elem41)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.attributes = NoteAttributes()
          self.attributes.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.LIST:
          self.tagNames = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = iprot.readString();
            self.tagNames.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Note')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.title is not None:
      oprot.writeFieldBegin('title', TType.STRING, 2)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    if self.content is not None:
      oprot.writeFieldBegin('content', TType.STRING, 3)
      oprot.writeString(self.content)
      oprot.writeFieldEnd()
    if self.contentHash is not None:
      oprot.writeFieldBegin('contentHash', TType.STRING, 4)
      oprot.writeString(self.contentHash)
      oprot.writeFieldEnd()
    if self.contentLength is not None:
      oprot.writeFieldBegin('contentLength', TType.I32, 5)
      oprot.writeI32(self.contentLength)
      oprot.writeFieldEnd()
    if self.created is not None:
      oprot.writeFieldBegin('created', TType.I64, 6)
      oprot.writeI64(self.created)
      oprot.writeFieldEnd()
    if self.updated is not None:
      oprot.writeFieldBegin('updated', TType.I64, 7)
      oprot.writeI64(self.updated)
      oprot.writeFieldEnd()
    if self.deleted is not None:
      oprot.writeFieldBegin('deleted', TType.I64, 8)
      oprot.writeI64(self.deleted)
      oprot.writeFieldEnd()
    if self.active is not None:
      oprot.writeFieldBegin('active', TType.BOOL, 9)
      oprot.writeBool(self.active)
      oprot.writeFieldEnd()
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 10)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    if self.notebookGuid is not None:
      oprot.writeFieldBegin('notebookGuid', TType.STRING, 11)
      oprot.writeString(self.notebookGuid)
      oprot.writeFieldEnd()
    if self.tagGuids is not None:
      oprot.writeFieldBegin('tagGuids', TType.LIST, 12)
      oprot.writeListBegin(TType.STRING, len(self.tagGuids))
      for iter48 in self.tagGuids:
        oprot.writeString(iter48)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.resources is not None:
      oprot.writeFieldBegin('resources', TType.LIST, 13)
      oprot.writeListBegin(TType.STRUCT, len(self.resources))
      for iter49 in self.resources:
        iter49.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.STRUCT, 14)
      self.attributes.write(oprot)
      oprot.writeFieldEnd()
    if self.tagNames is not None:
      oprot.writeFieldBegin('tagNames', TType.LIST, 15)
      oprot.writeListBegin(TType.STRING, len(self.tagNames))
      for iter50 in self.tagNames:
        oprot.writeString(iter50)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Publishing(object):
  """
  If a Notebook has been opened to the public, the Notebook will have a
  reference to one of these structures, which gives the location and optional
  description of the externally-visible public Notebook.
  <dl>
  <dt>uri</dt>
    <dd>If this field is present, then the notebook is published for
    mass consumption on the Internet under the provided URI, which is
    relative to a defined base publishing URI defined by the service.
    This field can only be modified via the web service GUI ... publishing
    cannot be modified via an offline client.
    <br/>
    Length:  EDAM_PUBLISHING_URI_LEN_MIN - EDAM_PUBLISHING_URI_LEN_MAX
    <br/>
    Regex:  EDAM_PUBLISHING_URI_REGEX
    </dd>
  
  <dt>order</dt>
    <dd>When the notes are publicly displayed, they will be sorted
    based on the requested criteria.
    </dd>
  
  <dt>ascending</dt>
    <dd>If this is set to true, then the public notes will be
    displayed in ascending order (e.g. from oldest to newest).  Otherwise,
    the notes will be displayed in descending order (e.g. newest to oldest).
    </dd>
  
  <dt>publicDescription</dt>
    <dd>This field may be used to provide a short
    description of the notebook, which may be displayed when (e.g.) the
    notebook is shown in a public view.  Can't begin or end with a space.
    <br/>
    Length:  EDAM_PUBLISHING_DESCRIPTION_LEN_MIN -
             EDAM_PUBLISHING_DESCRIPTION_LEN_MAX
    <br/>
    Regex:  EDAM_PUBLISHING_DESCRIPTION_REGEX
    </dd>
  </dl>
  
  Attributes:
   - uri
   - order
   - ascending
   - publicDescription
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'uri', None, None, ), # 1
    (2, TType.I32, 'order', None, None, ), # 2
    (3, TType.BOOL, 'ascending', None, None, ), # 3
    (4, TType.STRING, 'publicDescription', None, None, ), # 4
  )

  def __init__(self, uri=None, order=None, ascending=None, publicDescription=None,):
    self.uri = uri
    self.order = order
    self.ascending = ascending
    self.publicDescription = publicDescription

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.uri = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.order = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.ascending = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.publicDescription = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Publishing')
    if self.uri is not None:
      oprot.writeFieldBegin('uri', TType.STRING, 1)
      oprot.writeString(self.uri)
      oprot.writeFieldEnd()
    if self.order is not None:
      oprot.writeFieldBegin('order', TType.I32, 2)
      oprot.writeI32(self.order)
      oprot.writeFieldEnd()
    if self.ascending is not None:
      oprot.writeFieldBegin('ascending', TType.BOOL, 3)
      oprot.writeBool(self.ascending)
      oprot.writeFieldEnd()
    if self.publicDescription is not None:
      oprot.writeFieldBegin('publicDescription', TType.STRING, 4)
      oprot.writeString(self.publicDescription)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SavedSearch(object):
  """
  A named search associated with the account that can be quickly re-used.
  <dl>
  <dt>guid</dt>
    <dd>The unique identifier of this search.  Will be set by the
    service, so may be omitted by the client when creating.
    <br/>
    Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
    <br/>
    Regex:  EDAM_GUID_REGEX
    </dd>
  
  <dt>name</dt>
    <dd>The name of the saved search to display in the GUI.  The
    account may only contain one search with a given name (case-insensitive
    compare). Can't begin or end with a space.
    <br/>
    Length:  EDAM_SAVED_SEARCH_NAME_LEN_MIN - EDAM_SAVED_SEARCH_NAME_LEN_MAX
    <br/>
    Regex:  EDAM_SAVED_SEARCH_NAME_REGEX
    </dd>
  
  <dt>query</dt>
    <dd>A string expressing the search to be performed.
    <br/>
    Length:  EDAM_SAVED_SEARCH_QUERY_LEN_MIN - EDAM_SAVED_SEARCH_QUERY_LEN_MAX
    </dd>
  
  <dt>format</dt>
    <dd>The format of the query string, to determine how to parse
    and process it.
    </dd>
  
  <dt>updateSequenceNum</dt>
    <dd>A number identifying the last transaction to
    modify the state of this object.  The USN values are sequential within an
    account, and can be used to compare the order of modifications within the
    service.
    </dd>
  </dl>
  
  Attributes:
   - guid
   - name
   - query
   - format
   - updateSequenceNum
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.STRING, 'query', None, None, ), # 3
    (4, TType.I32, 'format', None, None, ), # 4
    (5, TType.I32, 'updateSequenceNum', None, None, ), # 5
  )

  def __init__(self, guid=None, name=None, query=None, format=None, updateSequenceNum=None,):
    self.guid = guid
    self.name = name
    self.query = query
    self.format = format
    self.updateSequenceNum = updateSequenceNum

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.query = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.format = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SavedSearch')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.query is not None:
      oprot.writeFieldBegin('query', TType.STRING, 3)
      oprot.writeString(self.query)
      oprot.writeFieldEnd()
    if self.format is not None:
      oprot.writeFieldBegin('format', TType.I32, 4)
      oprot.writeI32(self.format)
      oprot.writeFieldEnd()
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 5)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Ad(object):
  """
  An advertisement that may be displayed within an Evernote client.
  Advertisements are either a snippet of HTML or else they
  are an image (of type: JPEG, GIF, PNG) with an associated destination URL.
  
  <dl>
    <dt>id</dt>
    <dd>The unique identifier of this advertisement within Evernote's ad
    inventory.
    </dd>
  
    <dt>width</dt>
    <dd>This ad should be displayed within a rectangle that is this wide,
    in pixels.
    </dd>
  
    <dt>height</dt>
    <dd>This ad should be displayed within a rectangle that is this high,
    in pixels.
    </dd>
  
    <dt>advertiserName</dt>
    <dd>A string containing a readable version of the name of this advertiser.
    </dd>
  
    <dt>imageUrl</dt>
    <dd>The location of the image to display for this ad.</dd>
  
    <dt>destinationUrl</dt>
    <dd>When a user clicks on the ad, this is the destination they should be
    sent to in a browser.</dd>
  
    <dt>displaySeconds</dt>
    <dd>The number of seconds that the ad should be displayed before it is
    replaced with a different ad.</dd>
  
    <dt>score</dt>
    <dd>A numeric indicator of the relative value of this ad, which can be
    compared against other ads from the same day.
    </dd>
  
    <dt>image</dt>
    <dd>If present, this is the raw image bits of the image file to display
    for the ad.  If not present, the imageUrl should be retrieved directly.
    </dd>
  
    <dt>imageMime</dt>
    <dd>The MIME type of the 'image' bytes, if those are set.</dd>
  
    <dt>html</dt>
    <dd>The exact HTML to display for this ad, to support rich or external
    advertisements.</dd>
  
    <dt>displayFrequency</dt>
    <dd>If this value is set, this is the relatively frequency that this
    ad should be displayed in the daily set of ads, relative to a base
    frequency of 1.0.  I.e. an ad with a frequency of 3.0 should be displayed
    three times more frequently than an ad with a frequency of 1.0.</dd>
  
    <dt>openInTrunk</dt>
    <dd>If true, the ad should be opened in the embedded Trunk window by
    clients with Trunk support.</dd>
  </dl>
  
  Attributes:
   - id
   - width
   - height
   - advertiserName
   - imageUrl
   - destinationUrl
   - displaySeconds
   - score
   - image
   - imageMime
   - html
   - displayFrequency
   - openInTrunk
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'id', None, None, ), # 1
    (2, TType.I16, 'width', None, None, ), # 2
    (3, TType.I16, 'height', None, None, ), # 3
    (4, TType.STRING, 'advertiserName', None, None, ), # 4
    (5, TType.STRING, 'imageUrl', None, None, ), # 5
    (6, TType.STRING, 'destinationUrl', None, None, ), # 6
    (7, TType.I16, 'displaySeconds', None, None, ), # 7
    (8, TType.DOUBLE, 'score', None, None, ), # 8
    (9, TType.STRING, 'image', None, None, ), # 9
    (10, TType.STRING, 'imageMime', None, None, ), # 10
    (11, TType.STRING, 'html', None, None, ), # 11
    (12, TType.DOUBLE, 'displayFrequency', None, None, ), # 12
    (13, TType.BOOL, 'openInTrunk', None, None, ), # 13
  )

  def __init__(self, id=None, width=None, height=None, advertiserName=None, imageUrl=None, destinationUrl=None, displaySeconds=None, score=None, image=None, imageMime=None, html=None, displayFrequency=None, openInTrunk=None,):
    self.id = id
    self.width = width
    self.height = height
    self.advertiserName = advertiserName
    self.imageUrl = imageUrl
    self.destinationUrl = destinationUrl
    self.displaySeconds = displaySeconds
    self.score = score
    self.image = image
    self.imageMime = imageMime
    self.html = html
    self.displayFrequency = displayFrequency
    self.openInTrunk = openInTrunk

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.width = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.height = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.advertiserName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.imageUrl = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.destinationUrl = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I16:
          self.displaySeconds = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.DOUBLE:
          self.score = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.image = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.imageMime = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.html = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.DOUBLE:
          self.displayFrequency = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BOOL:
          self.openInTrunk = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Ad')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.width is not None:
      oprot.writeFieldBegin('width', TType.I16, 2)
      oprot.writeI16(self.width)
      oprot.writeFieldEnd()
    if self.height is not None:
      oprot.writeFieldBegin('height', TType.I16, 3)
      oprot.writeI16(self.height)
      oprot.writeFieldEnd()
    if self.advertiserName is not None:
      oprot.writeFieldBegin('advertiserName', TType.STRING, 4)
      oprot.writeString(self.advertiserName)
      oprot.writeFieldEnd()
    if self.imageUrl is not None:
      oprot.writeFieldBegin('imageUrl', TType.STRING, 5)
      oprot.writeString(self.imageUrl)
      oprot.writeFieldEnd()
    if self.destinationUrl is not None:
      oprot.writeFieldBegin('destinationUrl', TType.STRING, 6)
      oprot.writeString(self.destinationUrl)
      oprot.writeFieldEnd()
    if self.displaySeconds is not None:
      oprot.writeFieldBegin('displaySeconds', TType.I16, 7)
      oprot.writeI16(self.displaySeconds)
      oprot.writeFieldEnd()
    if self.score is not None:
      oprot.writeFieldBegin('score', TType.DOUBLE, 8)
      oprot.writeDouble(self.score)
      oprot.writeFieldEnd()
    if self.image is not None:
      oprot.writeFieldBegin('image', TType.STRING, 9)
      oprot.writeString(self.image)
      oprot.writeFieldEnd()
    if self.imageMime is not None:
      oprot.writeFieldBegin('imageMime', TType.STRING, 10)
      oprot.writeString(self.imageMime)
      oprot.writeFieldEnd()
    if self.html is not None:
      oprot.writeFieldBegin('html', TType.STRING, 11)
      oprot.writeString(self.html)
      oprot.writeFieldEnd()
    if self.displayFrequency is not None:
      oprot.writeFieldBegin('displayFrequency', TType.DOUBLE, 12)
      oprot.writeDouble(self.displayFrequency)
      oprot.writeFieldEnd()
    if self.openInTrunk is not None:
      oprot.writeFieldBegin('openInTrunk', TType.BOOL, 13)
      oprot.writeBool(self.openInTrunk)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SharedNotebook(object):
  """
  Shared notebooks represent a relationship between a notebook and a single
  share invitation recipient.
  <dl>
  <dt>id</dt>
  <dd>the primary identifier of the share</dd>
  
  <dt>userId</dt>
  <dd>the user id of the owner of the notebook</dd>
  
  <dt>notebookGuid</dt>
  <dd>the GUID of the associated notebook shared.</dd>
  
  <dt>email</dt>
  <dd>the email address of the recipient - used by the notebook
  owner to identify who they shared with.</dd>
  
  <dt>notebookModifiable</dt>
  <dd>a flag indicating the share is read/write -otherwise it's read only</dd>
  
  <dt>requireLogin</dt>
  <dd>indicates that a user must login to access the share</dd>
  
  <dt>serviceCreated</dt>
  <dd>the date the owner first created the share with the specific email
    address</dd>
  
  <dt>serviceUpdated</dt>
  <dd>the date the shared notebook was last updated on the service.  This
      will be updated when authenticateToSharedNotebook is called the first
      time with a shared notebook requiring login (i.e. when the username is
      bound to that shared notebook).</dd>
  
  <dt>username</dt>
  <dd>the username of the user who can access this share.
    Once it's assigned it cannot be changed.</dd>
  </dl>
  
  Attributes:
   - id
   - userId
   - notebookGuid
   - email
   - notebookModifiable
   - requireLogin
   - serviceCreated
   - serviceUpdated
   - shareKey
   - username
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.I32, 'userId', None, None, ), # 2
    (3, TType.STRING, 'notebookGuid', None, None, ), # 3
    (4, TType.STRING, 'email', None, None, ), # 4
    (5, TType.BOOL, 'notebookModifiable', None, None, ), # 5
    (6, TType.BOOL, 'requireLogin', None, None, ), # 6
    (7, TType.I64, 'serviceCreated', None, None, ), # 7
    (8, TType.STRING, 'shareKey', None, None, ), # 8
    (9, TType.STRING, 'username', None, None, ), # 9
    (10, TType.I64, 'serviceUpdated', None, None, ), # 10
  )

  def __init__(self, id=None, userId=None, notebookGuid=None, email=None, notebookModifiable=None, requireLogin=None, serviceCreated=None, serviceUpdated=None, shareKey=None, username=None,):
    self.id = id
    self.userId = userId
    self.notebookGuid = notebookGuid
    self.email = email
    self.notebookModifiable = notebookModifiable
    self.requireLogin = requireLogin
    self.serviceCreated = serviceCreated
    self.serviceUpdated = serviceUpdated
    self.shareKey = shareKey
    self.username = username

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.userId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.notebookGuid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.email = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.notebookModifiable = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.requireLogin = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.serviceCreated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.serviceUpdated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.shareKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.username = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SharedNotebook')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.I32, 2)
      oprot.writeI32(self.userId)
      oprot.writeFieldEnd()
    if self.notebookGuid is not None:
      oprot.writeFieldBegin('notebookGuid', TType.STRING, 3)
      oprot.writeString(self.notebookGuid)
      oprot.writeFieldEnd()
    if self.email is not None:
      oprot.writeFieldBegin('email', TType.STRING, 4)
      oprot.writeString(self.email)
      oprot.writeFieldEnd()
    if self.notebookModifiable is not None:
      oprot.writeFieldBegin('notebookModifiable', TType.BOOL, 5)
      oprot.writeBool(self.notebookModifiable)
      oprot.writeFieldEnd()
    if self.requireLogin is not None:
      oprot.writeFieldBegin('requireLogin', TType.BOOL, 6)
      oprot.writeBool(self.requireLogin)
      oprot.writeFieldEnd()
    if self.serviceCreated is not None:
      oprot.writeFieldBegin('serviceCreated', TType.I64, 7)
      oprot.writeI64(self.serviceCreated)
      oprot.writeFieldEnd()
    if self.shareKey is not None:
      oprot.writeFieldBegin('shareKey', TType.STRING, 8)
      oprot.writeString(self.shareKey)
      oprot.writeFieldEnd()
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 9)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.serviceUpdated is not None:
      oprot.writeFieldBegin('serviceUpdated', TType.I64, 10)
      oprot.writeI64(self.serviceUpdated)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Notebook(object):
  """
  A unique container for a set of notes.
  <dl>
  <dt>guid</dt>
    <dd>The unique identifier of this notebook.
    <br/>
    Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
    <br/>
    Regex:  EDAM_GUID_REGEX
    </dd>
  
  <dt>name</dt>
    <dd>A sequence of characters representing the name of the
    notebook.  May be changed by clients, but the account may not contain two
    notebooks with names that are equal via a case-insensitive comparison.
    Can't begin or end with a space.
    <br/>
    Length:  EDAM_NOTEBOOK_NAME_LEN_MIN - EDAM_NOTEBOOK_NAME_LEN_MAX
    <br/>
    Regex:  EDAM_NOTEBOOK_NAME_REGEX
    </dd>
  
  <dt>updateSequenceNum</dt>
    <dd>A number identifying the last transaction to
    modify the state of this object.  The USN values are sequential within an
    account, and can be used to compare the order of modifications within the
    service.
    </dd>
  
  <dt>defaultNotebook</dt>
    <dd>If true, this notebook should be used for new notes
    whenever the user has not (or cannot) specify a desired target notebook.
    For example, if a note is submitted via SMTP email.
    The service will maintain at most one defaultNotebook per account.
    If a second notebook is created or updated with defaultNotebook set to
    true, the service will automatically update the prior notebook's
    defaultNotebook field to false.  If the default notebook is deleted
    (i.e. "active" set to false), the "defaultNotebook" field will be
    set to false by the service.  If the account has no default notebook
    set, the service will use the most recent notebook as the default.
    </dd>
  
  <dt>serviceCreated</dt>
    <dd>The time when this notebook was created on the
    service. This will be set on the service during creation, and the service
    will provide this value when it returns a Notebook to a client.
    The service will ignore this value if it is sent by clients.
    </dd>
  
  <dt>serviceUpdated</dt>
    <dd>The time when this notebook was last modified on the
    service.  This will be set on the service during creation, and the service
    will provide this value when it returns a Notebook to a client.
    The service will ignore this value if it is sent by clients.
    </dd>
  
  <dt>publishing</dt>
    <dd>If the Notebook has been opened for public access (i.e.
    if 'published' is set to true), then this will point to the set of
    publishing information for the Notebook (URI, description, etc.).  A
    Notebook cannot be published without providing this information, but it
    will persist for later use if publishing is ever disabled on the Notebook.
    Clients that do not wish to change the publishing behavior of a Notebook
    should not set this value when calling NoteStore.updateNotebook().
    </dd>
  
  <dt>published</dt>
    <dd>If this is set to true, then the Notebook will be
    accessible to the public via the 'publishing' specification, which must
    also be set.  If this is set to false, the Notebook will not be available
    to the public.
    Clients that do not wish to change the publishing behavior of a Notebook
    should not set this value when calling NoteStore.updateNotebook().
    </dd>
  
  <dt>stack</dt>
    <dd>If this is set, then the notebook is visually contained within a stack
    of notebooks with this name.  All notebooks in the same account with the
    same 'stack' field are considered to be in the same stack.
    Notebooks with no stack set are "top level" and not contained within a
    stack.
    </dd>
  
  <dt>sharedNotebookIds</dt>
    <dd><i>DEPRECATED</i> - replaced by sharedNotebooks.</dd>
  
  <dt>sharedNotebooks</dt>
    <dd>The list of recipients to whom this notebook has been shared
    (one SharedNotebook object per recipient email address). This field will
    be unset if you do not have permission to access this data. If you are
    accessing the notebook as the owner or via a shared notebook that is
    modifiable, then you have access to this data and the value will be set.
    This field is read-only. Clients may not make changes to shared notebooks
    via this field.
    </dd>
  
  </dl>
  
  Attributes:
   - guid
   - name
   - updateSequenceNum
   - defaultNotebook
   - serviceCreated
   - serviceUpdated
   - publishing
   - published
   - stack
   - sharedNotebookIds
   - sharedNotebooks
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'guid', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    None, # 3
    None, # 4
    (5, TType.I32, 'updateSequenceNum', None, None, ), # 5
    (6, TType.BOOL, 'defaultNotebook', None, None, ), # 6
    (7, TType.I64, 'serviceCreated', None, None, ), # 7
    (8, TType.I64, 'serviceUpdated', None, None, ), # 8
    None, # 9
    (10, TType.STRUCT, 'publishing', (Publishing, Publishing.thrift_spec), None, ), # 10
    (11, TType.BOOL, 'published', None, None, ), # 11
    (12, TType.STRING, 'stack', None, None, ), # 12
    (13, TType.LIST, 'sharedNotebookIds', (TType.I64,None), None, ), # 13
    (14, TType.LIST, 'sharedNotebooks', (TType.STRUCT,(SharedNotebook, SharedNotebook.thrift_spec)), None, ), # 14
  )

  def __init__(self, guid=None, name=None, updateSequenceNum=None, defaultNotebook=None, serviceCreated=None, serviceUpdated=None, publishing=None, published=None, stack=None, sharedNotebookIds=None, sharedNotebooks=None,):
    self.guid = guid
    self.name = name
    self.updateSequenceNum = updateSequenceNum
    self.defaultNotebook = defaultNotebook
    self.serviceCreated = serviceCreated
    self.serviceUpdated = serviceUpdated
    self.publishing = publishing
    self.published = published
    self.stack = stack
    self.sharedNotebookIds = sharedNotebookIds
    self.sharedNotebooks = sharedNotebooks

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.defaultNotebook = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.serviceCreated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.serviceUpdated = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.publishing = Publishing()
          self.publishing.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.published = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.stack = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.LIST:
          self.sharedNotebookIds = []
          (_etype54, _size51) = iprot.readListBegin()
          for _i55 in xrange(_size51):
            _elem56 = iprot.readI64();
            self.sharedNotebookIds.append(_elem56)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.LIST:
          self.sharedNotebooks = []
          (_etype60, _size57) = iprot.readListBegin()
          for _i61 in xrange(_size57):
            _elem62 = SharedNotebook()
            _elem62.read(iprot)
            self.sharedNotebooks.append(_elem62)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Notebook')
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 1)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 5)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    if self.defaultNotebook is not None:
      oprot.writeFieldBegin('defaultNotebook', TType.BOOL, 6)
      oprot.writeBool(self.defaultNotebook)
      oprot.writeFieldEnd()
    if self.serviceCreated is not None:
      oprot.writeFieldBegin('serviceCreated', TType.I64, 7)
      oprot.writeI64(self.serviceCreated)
      oprot.writeFieldEnd()
    if self.serviceUpdated is not None:
      oprot.writeFieldBegin('serviceUpdated', TType.I64, 8)
      oprot.writeI64(self.serviceUpdated)
      oprot.writeFieldEnd()
    if self.publishing is not None:
      oprot.writeFieldBegin('publishing', TType.STRUCT, 10)
      self.publishing.write(oprot)
      oprot.writeFieldEnd()
    if self.published is not None:
      oprot.writeFieldBegin('published', TType.BOOL, 11)
      oprot.writeBool(self.published)
      oprot.writeFieldEnd()
    if self.stack is not None:
      oprot.writeFieldBegin('stack', TType.STRING, 12)
      oprot.writeString(self.stack)
      oprot.writeFieldEnd()
    if self.sharedNotebookIds is not None:
      oprot.writeFieldBegin('sharedNotebookIds', TType.LIST, 13)
      oprot.writeListBegin(TType.I64, len(self.sharedNotebookIds))
      for iter63 in self.sharedNotebookIds:
        oprot.writeI64(iter63)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sharedNotebooks is not None:
      oprot.writeFieldBegin('sharedNotebooks', TType.LIST, 14)
      oprot.writeListBegin(TType.STRUCT, len(self.sharedNotebooks))
      for iter64 in self.sharedNotebooks:
        iter64.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LinkedNotebook(object):
  """
  A link in an users account that refers them to a public or individual share in
  another user's account.
  
  <dl>
  <dt>shareName</dt>
  <dd>the display name of the shared notebook.
    The link owner can change this.</dd>
  
  <dt>username</dt>
  <dd>the username of the user who owns the shared or public notebook</dd>
  
  <dt>shardId</dt>
  <dd>the shard ID of the notebook if the notebook is not public</dt>
  
  <dt>shareKey</dt>
  <dd>the secret key that provides access to the shared notebook</dd>
  
  <dt>uri</dt>
  <dd>the identifier of the public notebook</dd>
  
  <dt>guid</dt>
    <dd>The unique identifier of this linked notebook.  Will be set whenever
    a resource is retrieved from the service, but may be null when a client
    is creating a resource.
    <br/>
    Length:  EDAM_GUID_LEN_MIN - EDAM_GUID_LEN_MAX
    <br/>
    Regex:  EDAM_GUID_REGEX
    </dd>
  
  <dt>updateSequenceNum</dt>
    <dd>A number identifying the last transaction to
    modify the state of this object.  The USN values are sequential within an
    account, and can be used to compare the order of modifications within the
    service.
    </dd>
  
  <dt>noteStoreUrl</dt>
    <dd>
    This field will contain the full URL that clients should use to make
    NoteStore requests to the server shard that contains that notebook's data.
    I.e. this is the URL that should be used to create the Thrift HTTP client
    transport to send messages to the NoteStore service for the account.
    </dd>
  
  <dt>webApiUrlPrefix:</dt>
    <dd>
    This field will contain the initial part of the URLs that should be used
    to make requests to Evernote's thin client "web API", which provide
    optimized operations for clients that aren't capable of manipulating
    the full contents of accounts via the full Thrift data model. Clients
    should concatenate the relative path for the various servlets onto the
    end of this string to construct the full URL, as documented on our
    developer web site.
    </dd>
  </dl>
  
  Attributes:
   - shareName
   - username
   - shardId
   - shareKey
   - uri
   - guid
   - updateSequenceNum
   - noteStoreUrl
   - webApiUrlPrefix
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'shareName', None, None, ), # 2
    (3, TType.STRING, 'username', None, None, ), # 3
    (4, TType.STRING, 'shardId', None, None, ), # 4
    (5, TType.STRING, 'shareKey', None, None, ), # 5
    (6, TType.STRING, 'uri', None, None, ), # 6
    (7, TType.STRING, 'guid', None, None, ), # 7
    (8, TType.I32, 'updateSequenceNum', None, None, ), # 8
    (9, TType.STRING, 'noteStoreUrl', None, None, ), # 9
    (10, TType.STRING, 'webApiUrlPrefix', None, None, ), # 10
  )

  def __init__(self, shareName=None, username=None, shardId=None, shareKey=None, uri=None, guid=None, updateSequenceNum=None, noteStoreUrl=None, webApiUrlPrefix=None,):
    self.shareName = shareName
    self.username = username
    self.shardId = shardId
    self.shareKey = shareKey
    self.uri = uri
    self.guid = guid
    self.updateSequenceNum = updateSequenceNum
    self.noteStoreUrl = noteStoreUrl
    self.webApiUrlPrefix = webApiUrlPrefix

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.shareName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.username = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.shardId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.shareKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.uri = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.guid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.updateSequenceNum = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.noteStoreUrl = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.webApiUrlPrefix = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LinkedNotebook')
    if self.shareName is not None:
      oprot.writeFieldBegin('shareName', TType.STRING, 2)
      oprot.writeString(self.shareName)
      oprot.writeFieldEnd()
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 3)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.shardId is not None:
      oprot.writeFieldBegin('shardId', TType.STRING, 4)
      oprot.writeString(self.shardId)
      oprot.writeFieldEnd()
    if self.shareKey is not None:
      oprot.writeFieldBegin('shareKey', TType.STRING, 5)
      oprot.writeString(self.shareKey)
      oprot.writeFieldEnd()
    if self.uri is not None:
      oprot.writeFieldBegin('uri', TType.STRING, 6)
      oprot.writeString(self.uri)
      oprot.writeFieldEnd()
    if self.guid is not None:
      oprot.writeFieldBegin('guid', TType.STRING, 7)
      oprot.writeString(self.guid)
      oprot.writeFieldEnd()
    if self.updateSequenceNum is not None:
      oprot.writeFieldBegin('updateSequenceNum', TType.I32, 8)
      oprot.writeI32(self.updateSequenceNum)
      oprot.writeFieldEnd()
    if self.noteStoreUrl is not None:
      oprot.writeFieldBegin('noteStoreUrl', TType.STRING, 9)
      oprot.writeString(self.noteStoreUrl)
      oprot.writeFieldEnd()
    if self.webApiUrlPrefix is not None:
      oprot.writeFieldBegin('webApiUrlPrefix', TType.STRING, 10)
      oprot.writeString(self.webApiUrlPrefix)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

########NEW FILE########
__FILENAME__ = constants
#
# Autogenerated by Thrift Compiler (0.5.0-en-262021)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *

EDAM_VERSION_MAJOR = 1
EDAM_VERSION_MINOR = 21

########NEW FILE########
__FILENAME__ = ttypes
#
# Autogenerated by Thrift Compiler (0.5.0-en-262021)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import evernote.edam.type.ttypes
import evernote.edam.error.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class SponsoredGroupRole(object):
  """
  Enumeration of Sponsored Group Roles
  """
  GROUP_MEMBER = 1
  GROUP_ADMIN = 2
  GROUP_OWNER = 3

  _VALUES_TO_NAMES = {
    1: "GROUP_MEMBER",
    2: "GROUP_ADMIN",
    3: "GROUP_OWNER",
  }

  _NAMES_TO_VALUES = {
    "GROUP_MEMBER": 1,
    "GROUP_ADMIN": 2,
    "GROUP_OWNER": 3,
  }


class PublicUserInfo(object):
  """
   This structure is used to provide publicly-available user information
   about a particular account.
  <dl>
   <dt>userId:</dt>
     <dd>
     The unique numeric user identifier for the user account.
     </dd>
   <dt>shardId:</dt>
     <dd>
     The name of the virtual server that manages the state of
     this user. This value is used internally to determine which system should
     service requests about this user's data.
     </dd>
   <dt>privilege:</dt>
     <dd>
     The privilege level of the account, to determine whether
     this is a Premium or Free account.
     </dd>
   <dt>noteStoreUrl:</dt>
     <dd>
     This field will contain the full URL that clients should use to make
     NoteStore requests to the server shard that contains that user's data.
     I.e. this is the URL that should be used to create the Thrift HTTP client
     transport to send messages to the NoteStore service for the account.
     </dd>
   </dl>
  
  Attributes:
   - userId
   - shardId
   - privilege
   - username
   - noteStoreUrl
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'userId', None, None, ), # 1
    (2, TType.STRING, 'shardId', None, None, ), # 2
    (3, TType.I32, 'privilege', None, None, ), # 3
    (4, TType.STRING, 'username', None, None, ), # 4
    (5, TType.STRING, 'noteStoreUrl', None, None, ), # 5
  )

  def __init__(self, userId=None, shardId=None, privilege=None, username=None, noteStoreUrl=None,):
    self.userId = userId
    self.shardId = shardId
    self.privilege = privilege
    self.username = username
    self.noteStoreUrl = noteStoreUrl

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.userId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.shardId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.privilege = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.username = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.noteStoreUrl = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PublicUserInfo')
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.I32, 1)
      oprot.writeI32(self.userId)
      oprot.writeFieldEnd()
    if self.shardId is not None:
      oprot.writeFieldBegin('shardId', TType.STRING, 2)
      oprot.writeString(self.shardId)
      oprot.writeFieldEnd()
    if self.privilege is not None:
      oprot.writeFieldBegin('privilege', TType.I32, 3)
      oprot.writeI32(self.privilege)
      oprot.writeFieldEnd()
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 4)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.noteStoreUrl is not None:
      oprot.writeFieldBegin('noteStoreUrl', TType.STRING, 5)
      oprot.writeString(self.noteStoreUrl)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.userId is None:
      raise TProtocol.TProtocolException(message='Required field userId is unset!')
    if self.shardId is None:
      raise TProtocol.TProtocolException(message='Required field shardId is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PremiumInfo(object):
  """
   This structure is used to provide information about a user's Premium account.
  <dl>
   <dt>currentTime:</dt>
     <dd>
     The server-side date and time when this data was generated.
     </dd>
   <dt>premium:</dt>
     <dd>
  	 True if the user's account is Premium.
     </dd>
   <dt>premiumRecurring</dt>
     <dd>
     True if the user's account is Premium and has a recurring payment method.
     </dd>
   <dt>premiumExpirationDate:</dt>
     <dd>
     The date when the user's Premium account expires, or the date when the
     user's account will be charged if it has a recurring payment method.
     </dd>
   <dt>premiumExtendable:</dt>
     <dd>
     True if the user is eligible for purchasing Premium account extensions.
     </dd>
   <dt>premiumPending:</dt>
     <dd>
     True if the user's Premium account is pending payment confirmation
     </dd>
   <dt>premiumCancellationPending:</dt>
     <dd>
     True if the user has requested that no further charges to be made; the
     Premium account will remain active until it expires.
     </dd>
   <dt>canPurchaseUploadAllowance:</dt>
     <dd>
     True if the user is eligible for purchasing additional upload allowance.
     </dd>
   <dt>sponsoredGroupName:</dt>
     <dd>
     The name of the sponsored group that the user is part of.
     </dd>
   <dt>sponsoredGroupRole:</dt>
     <dd>
     The role of the user within a sponsored group.
     </dd>
   <dt>businessName:</dt>
     <dd>
     The name of the business that the user is associated with.
     </dd>
   <dt>businessAdmin:</dt>
     <dd>
     True if the user is the administrator of the business.
     </dd>
   </dl>
  
  Attributes:
   - currentTime
   - premium
   - premiumRecurring
   - premiumExpirationDate
   - premiumExtendable
   - premiumPending
   - premiumCancellationPending
   - canPurchaseUploadAllowance
   - sponsoredGroupName
   - sponsoredGroupRole
   - businessName
   - businessAdmin
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'currentTime', None, None, ), # 1
    (2, TType.BOOL, 'premium', None, None, ), # 2
    (3, TType.BOOL, 'premiumRecurring', None, None, ), # 3
    (4, TType.I64, 'premiumExpirationDate', None, None, ), # 4
    (5, TType.BOOL, 'premiumExtendable', None, None, ), # 5
    (6, TType.BOOL, 'premiumPending', None, None, ), # 6
    (7, TType.BOOL, 'premiumCancellationPending', None, None, ), # 7
    (8, TType.BOOL, 'canPurchaseUploadAllowance', None, None, ), # 8
    (9, TType.STRING, 'sponsoredGroupName', None, None, ), # 9
    (10, TType.I32, 'sponsoredGroupRole', None, None, ), # 10
    (11, TType.STRING, 'businessName', None, None, ), # 11
    (12, TType.BOOL, 'businessAdmin', None, None, ), # 12
  )

  def __init__(self, currentTime=None, premium=None, premiumRecurring=None, premiumExpirationDate=None, premiumExtendable=None, premiumPending=None, premiumCancellationPending=None, canPurchaseUploadAllowance=None, sponsoredGroupName=None, sponsoredGroupRole=None, businessName=None, businessAdmin=None,):
    self.currentTime = currentTime
    self.premium = premium
    self.premiumRecurring = premiumRecurring
    self.premiumExpirationDate = premiumExpirationDate
    self.premiumExtendable = premiumExtendable
    self.premiumPending = premiumPending
    self.premiumCancellationPending = premiumCancellationPending
    self.canPurchaseUploadAllowance = canPurchaseUploadAllowance
    self.sponsoredGroupName = sponsoredGroupName
    self.sponsoredGroupRole = sponsoredGroupRole
    self.businessName = businessName
    self.businessAdmin = businessAdmin

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.currentTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.premium = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.premiumRecurring = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.premiumExpirationDate = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.premiumExtendable = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.premiumPending = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.premiumCancellationPending = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.canPurchaseUploadAllowance = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.sponsoredGroupName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.sponsoredGroupRole = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.businessName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.businessAdmin = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PremiumInfo')
    if self.currentTime is not None:
      oprot.writeFieldBegin('currentTime', TType.I64, 1)
      oprot.writeI64(self.currentTime)
      oprot.writeFieldEnd()
    if self.premium is not None:
      oprot.writeFieldBegin('premium', TType.BOOL, 2)
      oprot.writeBool(self.premium)
      oprot.writeFieldEnd()
    if self.premiumRecurring is not None:
      oprot.writeFieldBegin('premiumRecurring', TType.BOOL, 3)
      oprot.writeBool(self.premiumRecurring)
      oprot.writeFieldEnd()
    if self.premiumExpirationDate is not None:
      oprot.writeFieldBegin('premiumExpirationDate', TType.I64, 4)
      oprot.writeI64(self.premiumExpirationDate)
      oprot.writeFieldEnd()
    if self.premiumExtendable is not None:
      oprot.writeFieldBegin('premiumExtendable', TType.BOOL, 5)
      oprot.writeBool(self.premiumExtendable)
      oprot.writeFieldEnd()
    if self.premiumPending is not None:
      oprot.writeFieldBegin('premiumPending', TType.BOOL, 6)
      oprot.writeBool(self.premiumPending)
      oprot.writeFieldEnd()
    if self.premiumCancellationPending is not None:
      oprot.writeFieldBegin('premiumCancellationPending', TType.BOOL, 7)
      oprot.writeBool(self.premiumCancellationPending)
      oprot.writeFieldEnd()
    if self.canPurchaseUploadAllowance is not None:
      oprot.writeFieldBegin('canPurchaseUploadAllowance', TType.BOOL, 8)
      oprot.writeBool(self.canPurchaseUploadAllowance)
      oprot.writeFieldEnd()
    if self.sponsoredGroupName is not None:
      oprot.writeFieldBegin('sponsoredGroupName', TType.STRING, 9)
      oprot.writeString(self.sponsoredGroupName)
      oprot.writeFieldEnd()
    if self.sponsoredGroupRole is not None:
      oprot.writeFieldBegin('sponsoredGroupRole', TType.I32, 10)
      oprot.writeI32(self.sponsoredGroupRole)
      oprot.writeFieldEnd()
    if self.businessName is not None:
      oprot.writeFieldBegin('businessName', TType.STRING, 11)
      oprot.writeString(self.businessName)
      oprot.writeFieldEnd()
    if self.businessAdmin is not None:
      oprot.writeFieldBegin('businessAdmin', TType.BOOL, 12)
      oprot.writeBool(self.businessAdmin)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.currentTime is None:
      raise TProtocol.TProtocolException(message='Required field currentTime is unset!')
    if self.premium is None:
      raise TProtocol.TProtocolException(message='Required field premium is unset!')
    if self.premiumRecurring is None:
      raise TProtocol.TProtocolException(message='Required field premiumRecurring is unset!')
    if self.premiumExtendable is None:
      raise TProtocol.TProtocolException(message='Required field premiumExtendable is unset!')
    if self.premiumPending is None:
      raise TProtocol.TProtocolException(message='Required field premiumPending is unset!')
    if self.premiumCancellationPending is None:
      raise TProtocol.TProtocolException(message='Required field premiumCancellationPending is unset!')
    if self.canPurchaseUploadAllowance is None:
      raise TProtocol.TProtocolException(message='Required field canPurchaseUploadAllowance is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AuthenticationResult(object):
  """
   When an authentication (or re-authentication) is performed, this structure
   provides the result to the client.
  <dl>
   <dt>currentTime:</dt>
     <dd>
     The server-side date and time when this result was
     generated.
     </dd>
   <dt>authenticationToken:</dt>
     <dd>
     Holds an opaque, ASCII-encoded token that can be
     used by the client to perform actions on a NoteStore.
     </dd>
   <dt>expiration:</dt>
     <dd>
     Holds the server-side date and time when the
     authentication token will expire.
     This time can be compared to "currentTime" to produce an expiration
     time that can be reconciled with the client's local clock.
     </dd>
   <dt>user:</dt>
     <dd>
     Holds the information about the account which was
     authenticated if this was a full authentication.  May be absent if this
     particular authentication did not require user information.
     </dd>
   <dt>publicUserInfo:</dt>
     <dd>
     If this authentication result was achieved without full permissions to
     access the full User structure, this field may be set to give back
     a more limited public set of data.
     </dd>
   <dt>noteStoreUrl:</dt>
     <dd>
     This field will contain the full URL that clients should use to make
     NoteStore requests to the server shard that contains that user's data.
     I.e. this is the URL that should be used to create the Thrift HTTP client
     transport to send messages to the NoteStore service for the account.
     </dd>
   <dt>webApiUrlPrefix:</dt>
     <dd>
     This field will contain the initial part of the URLs that should be used
     to make requests to Evernote's thin client "web API", which provide
     optimized operations for clients that aren't capable of manipulating
     the full contents of accounts via the full Thrift data model. Clients
     should concatenate the relative path for the various servlets onto the
     end of this string to construct the full URL, as documented on our
     developer web site.
     </dd>
   </dl>
  
  Attributes:
   - currentTime
   - authenticationToken
   - expiration
   - user
   - publicUserInfo
   - noteStoreUrl
   - webApiUrlPrefix
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'currentTime', None, None, ), # 1
    (2, TType.STRING, 'authenticationToken', None, None, ), # 2
    (3, TType.I64, 'expiration', None, None, ), # 3
    (4, TType.STRUCT, 'user', (evernote.edam.type.ttypes.User, evernote.edam.type.ttypes.User.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'publicUserInfo', (PublicUserInfo, PublicUserInfo.thrift_spec), None, ), # 5
    (6, TType.STRING, 'noteStoreUrl', None, None, ), # 6
    (7, TType.STRING, 'webApiUrlPrefix', None, None, ), # 7
  )

  def __init__(self, currentTime=None, authenticationToken=None, expiration=None, user=None, publicUserInfo=None, noteStoreUrl=None, webApiUrlPrefix=None,):
    self.currentTime = currentTime
    self.authenticationToken = authenticationToken
    self.expiration = expiration
    self.user = user
    self.publicUserInfo = publicUserInfo
    self.noteStoreUrl = noteStoreUrl
    self.webApiUrlPrefix = webApiUrlPrefix

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.currentTime = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.expiration = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.user = evernote.edam.type.ttypes.User()
          self.user.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.publicUserInfo = PublicUserInfo()
          self.publicUserInfo.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.noteStoreUrl = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.webApiUrlPrefix = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AuthenticationResult')
    if self.currentTime is not None:
      oprot.writeFieldBegin('currentTime', TType.I64, 1)
      oprot.writeI64(self.currentTime)
      oprot.writeFieldEnd()
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 2)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    if self.expiration is not None:
      oprot.writeFieldBegin('expiration', TType.I64, 3)
      oprot.writeI64(self.expiration)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRUCT, 4)
      self.user.write(oprot)
      oprot.writeFieldEnd()
    if self.publicUserInfo is not None:
      oprot.writeFieldBegin('publicUserInfo', TType.STRUCT, 5)
      self.publicUserInfo.write(oprot)
      oprot.writeFieldEnd()
    if self.noteStoreUrl is not None:
      oprot.writeFieldBegin('noteStoreUrl', TType.STRING, 6)
      oprot.writeString(self.noteStoreUrl)
      oprot.writeFieldEnd()
    if self.webApiUrlPrefix is not None:
      oprot.writeFieldBegin('webApiUrlPrefix', TType.STRING, 7)
      oprot.writeString(self.webApiUrlPrefix)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.currentTime is None:
      raise TProtocol.TProtocolException(message='Required field currentTime is unset!')
    if self.authenticationToken is None:
      raise TProtocol.TProtocolException(message='Required field authenticationToken is unset!')
    if self.expiration is None:
      raise TProtocol.TProtocolException(message='Required field expiration is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BootstrapSettings(object):
  """
   This structure describes a collection of bootstrap settings.
  <dl>
   <dt>serviceHost:</dt>
     <dd>
     The hostname and optional port for composing Evernote web service URLs.
     This URL can be used to access the UserStore and related services,
     but must not be used to compose the NoteStore URL. Client applications
     must handle serviceHost values that include only the hostname
     (e.g. www.evernote.com) or both the hostname and port (e.g. www.evernote.com:8080).
     If no port is specified, or if port 443 is specified, client applications must
     use the scheme "https" when composing URLs. Otherwise, a client must use the
     scheme "http".
   </dd>
   <dt>marketingUrl:</dt>
     <dd>
     The URL stem for the Evernote corporate marketing website, e.g. http://www.evernote.com.
     This stem can be used to compose website URLs. For example, the URL of the Evernote
     Trunk is composed by appending "/about/trunk/" to the value of marketingUrl.
     </dd>
   <dt>supportUrl:</dt>
     <dd>
     The full URL for the Evernote customer support website, e.g. https://support.evernote.com.
     </dd>
   <dt>accountEmailDomain:</dt>
     <dd>
     The domain used for an Evernote user's incoming email address, which allows notes to
     be emailed into an account. E.g. m.evernote.com.
     </dd>
   <dt>enableFacebookSharing:</dt>
     <dd>
     Whether the client application should enable sharing of notes on Facebook.
     </dd>
   <dt>enableGiftSubscriptions:</dt>
     <dd>
     Whether the client application should enable gift subscriptions.
     </dd>
   <dt>enableSupportTickets:</dt>
     <dd>
     Whether the client application should enable in-client creation of support tickets.
     </dd>
   <dt>enableSharedNotebooks:</dt>
     <dd>
     Whether the client application should enable shared notebooks.
     </dd>
   <dt>enableSingleNoteSharing:</dt>
     <dd>
     Whether the client application should enable single note sharing.
     </dd>
   <dt>enableSponsoredAccounts:</dt>
     <dd>
     Whether the client application should enable sponsored accounts.
     </dd>
   <dt>enableTwitterSharing:</dt>
     <dd>
     Whether the client application should enable sharing of notes on Twitter.
     </dd>
   </dl>
  
  Attributes:
   - serviceHost
   - marketingUrl
   - supportUrl
   - accountEmailDomain
   - enableFacebookSharing
   - enableGiftSubscriptions
   - enableSupportTickets
   - enableSharedNotebooks
   - enableSingleNoteSharing
   - enableSponsoredAccounts
   - enableTwitterSharing
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'serviceHost', None, None, ), # 1
    (2, TType.STRING, 'marketingUrl', None, None, ), # 2
    (3, TType.STRING, 'supportUrl', None, None, ), # 3
    (4, TType.STRING, 'accountEmailDomain', None, None, ), # 4
    (5, TType.BOOL, 'enableFacebookSharing', None, None, ), # 5
    (6, TType.BOOL, 'enableGiftSubscriptions', None, None, ), # 6
    (7, TType.BOOL, 'enableSupportTickets', None, None, ), # 7
    (8, TType.BOOL, 'enableSharedNotebooks', None, None, ), # 8
    (9, TType.BOOL, 'enableSingleNoteSharing', None, None, ), # 9
    (10, TType.BOOL, 'enableSponsoredAccounts', None, None, ), # 10
    (11, TType.BOOL, 'enableTwitterSharing', None, None, ), # 11
  )

  def __init__(self, serviceHost=None, marketingUrl=None, supportUrl=None, accountEmailDomain=None, enableFacebookSharing=None, enableGiftSubscriptions=None, enableSupportTickets=None, enableSharedNotebooks=None, enableSingleNoteSharing=None, enableSponsoredAccounts=None, enableTwitterSharing=None,):
    self.serviceHost = serviceHost
    self.marketingUrl = marketingUrl
    self.supportUrl = supportUrl
    self.accountEmailDomain = accountEmailDomain
    self.enableFacebookSharing = enableFacebookSharing
    self.enableGiftSubscriptions = enableGiftSubscriptions
    self.enableSupportTickets = enableSupportTickets
    self.enableSharedNotebooks = enableSharedNotebooks
    self.enableSingleNoteSharing = enableSingleNoteSharing
    self.enableSponsoredAccounts = enableSponsoredAccounts
    self.enableTwitterSharing = enableTwitterSharing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.serviceHost = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.marketingUrl = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.supportUrl = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.accountEmailDomain = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.enableFacebookSharing = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.enableGiftSubscriptions = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.enableSupportTickets = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.enableSharedNotebooks = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.enableSingleNoteSharing = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.enableSponsoredAccounts = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.enableTwitterSharing = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BootstrapSettings')
    if self.serviceHost is not None:
      oprot.writeFieldBegin('serviceHost', TType.STRING, 1)
      oprot.writeString(self.serviceHost)
      oprot.writeFieldEnd()
    if self.marketingUrl is not None:
      oprot.writeFieldBegin('marketingUrl', TType.STRING, 2)
      oprot.writeString(self.marketingUrl)
      oprot.writeFieldEnd()
    if self.supportUrl is not None:
      oprot.writeFieldBegin('supportUrl', TType.STRING, 3)
      oprot.writeString(self.supportUrl)
      oprot.writeFieldEnd()
    if self.accountEmailDomain is not None:
      oprot.writeFieldBegin('accountEmailDomain', TType.STRING, 4)
      oprot.writeString(self.accountEmailDomain)
      oprot.writeFieldEnd()
    if self.enableFacebookSharing is not None:
      oprot.writeFieldBegin('enableFacebookSharing', TType.BOOL, 5)
      oprot.writeBool(self.enableFacebookSharing)
      oprot.writeFieldEnd()
    if self.enableGiftSubscriptions is not None:
      oprot.writeFieldBegin('enableGiftSubscriptions', TType.BOOL, 6)
      oprot.writeBool(self.enableGiftSubscriptions)
      oprot.writeFieldEnd()
    if self.enableSupportTickets is not None:
      oprot.writeFieldBegin('enableSupportTickets', TType.BOOL, 7)
      oprot.writeBool(self.enableSupportTickets)
      oprot.writeFieldEnd()
    if self.enableSharedNotebooks is not None:
      oprot.writeFieldBegin('enableSharedNotebooks', TType.BOOL, 8)
      oprot.writeBool(self.enableSharedNotebooks)
      oprot.writeFieldEnd()
    if self.enableSingleNoteSharing is not None:
      oprot.writeFieldBegin('enableSingleNoteSharing', TType.BOOL, 9)
      oprot.writeBool(self.enableSingleNoteSharing)
      oprot.writeFieldEnd()
    if self.enableSponsoredAccounts is not None:
      oprot.writeFieldBegin('enableSponsoredAccounts', TType.BOOL, 10)
      oprot.writeBool(self.enableSponsoredAccounts)
      oprot.writeFieldEnd()
    if self.enableTwitterSharing is not None:
      oprot.writeFieldBegin('enableTwitterSharing', TType.BOOL, 11)
      oprot.writeBool(self.enableTwitterSharing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.serviceHost is None:
      raise TProtocol.TProtocolException(message='Required field serviceHost is unset!')
    if self.marketingUrl is None:
      raise TProtocol.TProtocolException(message='Required field marketingUrl is unset!')
    if self.supportUrl is None:
      raise TProtocol.TProtocolException(message='Required field supportUrl is unset!')
    if self.accountEmailDomain is None:
      raise TProtocol.TProtocolException(message='Required field accountEmailDomain is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BootstrapProfile(object):
  """
   This structure describes a collection of bootstrap settings.
  <dl>
   <dt>name:</dt>
     <dd>
     The unique name of the profile, which is guaranteed to remain consistent across
     calls to getBootstrapInfo.
     </dd>
   <dt>settings:</dt>
     <dd>
     The settings for this profile.
     </dd>
   </dl>
  
  Attributes:
   - name
   - settings
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRUCT, 'settings', (BootstrapSettings, BootstrapSettings.thrift_spec), None, ), # 2
  )

  def __init__(self, name=None, settings=None,):
    self.name = name
    self.settings = settings

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.settings = BootstrapSettings()
          self.settings.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BootstrapProfile')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.settings is not None:
      oprot.writeFieldBegin('settings', TType.STRUCT, 2)
      self.settings.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.settings is None:
      raise TProtocol.TProtocolException(message='Required field settings is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BootstrapInfo(object):
  """
   This structure describes a collection of bootstrap profiles.
  <dl>
   <dt>profiles:</dt>
     <dd>
     List of one or more bootstrap profiles, in descending
     preference order.
     </dd>
   </dl>
  
  Attributes:
   - profiles
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'profiles', (TType.STRUCT,(BootstrapProfile, BootstrapProfile.thrift_spec)), None, ), # 1
  )

  def __init__(self, profiles=None,):
    self.profiles = profiles

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.profiles = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = BootstrapProfile()
            _elem5.read(iprot)
            self.profiles.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BootstrapInfo')
    if self.profiles is not None:
      oprot.writeFieldBegin('profiles', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.profiles))
      for iter6 in self.profiles:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.profiles is None:
      raise TProtocol.TProtocolException(message='Required field profiles is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

########NEW FILE########
__FILENAME__ = UserStore
#
# Autogenerated by Thrift Compiler (0.5.0-en-262021)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(object):
  """
  Service:  UserStore
  <p>
  The UserStore service is primarily used by EDAM clients to establish
  authentication via username and password over a trusted connection (e.g.
  SSL).  A client's first call to this interface should be checkVersion() to
  ensure that the client's software is up to date.
  </p>
  All calls which require an authenticationToken may throw an
  EDAMUserException for the following reasons:
   <ul>
    <li> AUTH_EXPIRED "authenticationToken" - token has expired
    <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
    <li> DATA_REQUIRED "authenticationToken" - token is empty
    <li> INVALID_AUTH "authenticationToken" - token signature is invalid
  </ul>
  """
  def checkVersion(self, clientName, edamVersionMajor, edamVersionMinor):
    """
    This should be the first call made by a client to the EDAM service.  It
    tells the service what protocol version is used by the client.  The
    service will then return true if the client is capable of talking to
    the service, and false if the client's protocol version is incompatible
    with the service, so the client must upgrade.  If a client receives a
    false value, it should report the incompatibility to the user and not
    continue with any more EDAM requests (UserStore or NoteStore).
    
    @param clientName
      This string provides some information about the client for
      tracking/logging on the service.  It should provide information about
      the client's software and platform.  The structure should be:
      application/version; platform/version; [ device/version ]
      E.g.   "Evernote Windows/3.0.1; Windows/XP SP3" or
      "Evernote Clipper/1.0.1; JME/2.0; Motorola RAZR/2.0;
    
    @param edamVersionMajor
      This should be the major protocol version that was compiled by the
      client.  This should be the current value of the EDAM_VERSION_MAJOR
      constant for the client.
    
    @param edamVersionMinor
      This should be the major protocol version that was compiled by the
      client.  This should be the current value of the EDAM_VERSION_MINOR
      constant for the client.
    
    Parameters:
     - clientName
     - edamVersionMajor
     - edamVersionMinor
    """
    pass

  def getBootstrapInfo(self, locale):
    """
    This provides bootstrap information to the client. Various bootstrap
    profiles and settings may be used by the client to configure itself.
    
    @param locale
      The client's current locale, expressed in language[_country]
      format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
      language and country codes.
    
    @return
      The bootstrap information suitable for this client.
    
    Parameters:
     - locale
    """
    pass

  def authenticate(self, username, password, consumerKey, consumerSecret):
    """
    This is used to check a username and password in order to create an
    authentication session that could be used for further actions.
    
    This function is only availabe to Evernote's internal applications.
    Third party applications must authenticate using OAuth as
    described at
    <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
    
    @param username
      The username (not numeric user ID) for the account to
      authenticate against.  This function will also accept the user's
      registered email address in this parameter.
    
    @param password
      The plaintext password to check against the account.  Since
      this is not protected by the EDAM protocol, this information must be
      provided over a protected transport (e.g. SSL).
    
    @param consumerKey
      A unique identifier for this client application, provided by Evernote
      to developers who request an API key.  This must be provided to identify
      the client.
    
    @param consumerSecret
      If the client was given a "consumer secret" when the API key was issued,
      it must be provided here to authenticate the application itself.
    
    @return
      The result of the authentication.  If the authentication was successful,
      the AuthenticationResult.user field will be set with the full information
      about the User.
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "username" - username is empty
      <li> DATA_REQUIRED "password" - password is empty
      <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
      <li> INVALID_AUTH "username" - username not found
      <li> INVALID_AUTH "password" - password did not match
      <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
      <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
      <li> PERMISSION_DENIED "User.active" - user account is closed
      <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
        failed authentication too often
    </ul>
    
    Parameters:
     - username
     - password
     - consumerKey
     - consumerSecret
    """
    pass

  def refreshAuthentication(self, authenticationToken):
    """
    This is used to take an existing authentication token (returned from
    'authenticate') and exchange it for a newer token which will not expire
    as soon.  This must be invoked before the previous token expires.
    
    This function is only availabe to Evernote's internal applications.
    
    @param authenticationToken
      The previous authentication token from the authenticate() result.
    
    @return
      The result of the authentication, with the new token in
      the result's "authentication" field.  The User field will
      not be set in the reply.
    
    Parameters:
     - authenticationToken
    """
    pass

  def getUser(self, authenticationToken):
    """
    Returns the User corresponding to the provided authentication token,
    or throws an exception if this token is not valid.
    The level of detail provided in the returned User structure depends on
    the access level granted by the token, so a web service client may receive
    fewer fields than an integrated desktop client.
    
    Parameters:
     - authenticationToken
    """
    pass

  def getPublicUserInfo(self, username):
    """
    Asks the UserStore about the publicly available location information for
    a particular username.
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "username" - username is empty
    </ul>
    
    Parameters:
     - username
    """
    pass

  def getPremiumInfo(self, authenticationToken):
    """
    Returns information regarding a user's Premium account corresponding to the
    provided authentication token, or throws an exception if this token is not
    valid.
    
    Parameters:
     - authenticationToken
    """
    pass

  def getNoteStoreUrl(self, authenticationToken):
    """
    Returns the URL that should be used to talk to the NoteStore for the
    account represented by the provided authenticationToken.
    This method isn't needed by most clients, who can retrieve the correct
    NoteStore URL from the AuthenticationResult returned from the authenticate
    or refreshAuthentication calls. This method is typically only needed
    to look up the correct URL for a long-lived session token (e.g. for an
    OAuth web service).
    
    Parameters:
     - authenticationToken
    """
    pass


class Client(Iface):
  """
  Service:  UserStore
  <p>
  The UserStore service is primarily used by EDAM clients to establish
  authentication via username and password over a trusted connection (e.g.
  SSL).  A client's first call to this interface should be checkVersion() to
  ensure that the client's software is up to date.
  </p>
  All calls which require an authenticationToken may throw an
  EDAMUserException for the following reasons:
   <ul>
    <li> AUTH_EXPIRED "authenticationToken" - token has expired
    <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
    <li> DATA_REQUIRED "authenticationToken" - token is empty
    <li> INVALID_AUTH "authenticationToken" - token signature is invalid
  </ul>
  """
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def checkVersion(self, clientName, edamVersionMajor, edamVersionMinor):
    """
    This should be the first call made by a client to the EDAM service.  It
    tells the service what protocol version is used by the client.  The
    service will then return true if the client is capable of talking to
    the service, and false if the client's protocol version is incompatible
    with the service, so the client must upgrade.  If a client receives a
    false value, it should report the incompatibility to the user and not
    continue with any more EDAM requests (UserStore or NoteStore).
    
    @param clientName
      This string provides some information about the client for
      tracking/logging on the service.  It should provide information about
      the client's software and platform.  The structure should be:
      application/version; platform/version; [ device/version ]
      E.g.   "Evernote Windows/3.0.1; Windows/XP SP3" or
      "Evernote Clipper/1.0.1; JME/2.0; Motorola RAZR/2.0;
    
    @param edamVersionMajor
      This should be the major protocol version that was compiled by the
      client.  This should be the current value of the EDAM_VERSION_MAJOR
      constant for the client.
    
    @param edamVersionMinor
      This should be the major protocol version that was compiled by the
      client.  This should be the current value of the EDAM_VERSION_MINOR
      constant for the client.
    
    Parameters:
     - clientName
     - edamVersionMajor
     - edamVersionMinor
    """
    self.send_checkVersion(clientName, edamVersionMajor, edamVersionMinor)
    return self.recv_checkVersion()

  def send_checkVersion(self, clientName, edamVersionMajor, edamVersionMinor):
    self._oprot.writeMessageBegin('checkVersion', TMessageType.CALL, self._seqid)
    args = checkVersion_args()
    args.clientName = clientName
    args.edamVersionMajor = edamVersionMajor
    args.edamVersionMinor = edamVersionMinor
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_checkVersion(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = checkVersion_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "checkVersion failed: unknown result");

  def getBootstrapInfo(self, locale):
    """
    This provides bootstrap information to the client. Various bootstrap
    profiles and settings may be used by the client to configure itself.
    
    @param locale
      The client's current locale, expressed in language[_country]
      format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
      language and country codes.
    
    @return
      The bootstrap information suitable for this client.
    
    Parameters:
     - locale
    """
    self.send_getBootstrapInfo(locale)
    return self.recv_getBootstrapInfo()

  def send_getBootstrapInfo(self, locale):
    self._oprot.writeMessageBegin('getBootstrapInfo', TMessageType.CALL, self._seqid)
    args = getBootstrapInfo_args()
    args.locale = locale
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getBootstrapInfo(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getBootstrapInfo_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getBootstrapInfo failed: unknown result");

  def authenticate(self, username, password, consumerKey, consumerSecret):
    """
    This is used to check a username and password in order to create an
    authentication session that could be used for further actions.
    
    This function is only availabe to Evernote's internal applications.
    Third party applications must authenticate using OAuth as
    described at
    <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
    
    @param username
      The username (not numeric user ID) for the account to
      authenticate against.  This function will also accept the user's
      registered email address in this parameter.
    
    @param password
      The plaintext password to check against the account.  Since
      this is not protected by the EDAM protocol, this information must be
      provided over a protected transport (e.g. SSL).
    
    @param consumerKey
      A unique identifier for this client application, provided by Evernote
      to developers who request an API key.  This must be provided to identify
      the client.
    
    @param consumerSecret
      If the client was given a "consumer secret" when the API key was issued,
      it must be provided here to authenticate the application itself.
    
    @return
      The result of the authentication.  If the authentication was successful,
      the AuthenticationResult.user field will be set with the full information
      about the User.
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "username" - username is empty
      <li> DATA_REQUIRED "password" - password is empty
      <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
      <li> INVALID_AUTH "username" - username not found
      <li> INVALID_AUTH "password" - password did not match
      <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
      <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
      <li> PERMISSION_DENIED "User.active" - user account is closed
      <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
        failed authentication too often
    </ul>
    
    Parameters:
     - username
     - password
     - consumerKey
     - consumerSecret
    """
    self.send_authenticate(username, password, consumerKey, consumerSecret)
    return self.recv_authenticate()

  def send_authenticate(self, username, password, consumerKey, consumerSecret):
    self._oprot.writeMessageBegin('authenticate', TMessageType.CALL, self._seqid)
    args = authenticate_args()
    args.username = username
    args.password = password
    args.consumerKey = consumerKey
    args.consumerSecret = consumerSecret
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_authenticate(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = authenticate_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticate failed: unknown result");

  def refreshAuthentication(self, authenticationToken):
    """
    This is used to take an existing authentication token (returned from
    'authenticate') and exchange it for a newer token which will not expire
    as soon.  This must be invoked before the previous token expires.
    
    This function is only availabe to Evernote's internal applications.
    
    @param authenticationToken
      The previous authentication token from the authenticate() result.
    
    @return
      The result of the authentication, with the new token in
      the result's "authentication" field.  The User field will
      not be set in the reply.
    
    Parameters:
     - authenticationToken
    """
    self.send_refreshAuthentication(authenticationToken)
    return self.recv_refreshAuthentication()

  def send_refreshAuthentication(self, authenticationToken):
    self._oprot.writeMessageBegin('refreshAuthentication', TMessageType.CALL, self._seqid)
    args = refreshAuthentication_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_refreshAuthentication(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = refreshAuthentication_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "refreshAuthentication failed: unknown result");

  def getUser(self, authenticationToken):
    """
    Returns the User corresponding to the provided authentication token,
    or throws an exception if this token is not valid.
    The level of detail provided in the returned User structure depends on
    the access level granted by the token, so a web service client may receive
    fewer fields than an integrated desktop client.
    
    Parameters:
     - authenticationToken
    """
    self.send_getUser(authenticationToken)
    return self.recv_getUser()

  def send_getUser(self, authenticationToken):
    self._oprot.writeMessageBegin('getUser', TMessageType.CALL, self._seqid)
    args = getUser_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getUser(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getUser_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getUser failed: unknown result");

  def getPublicUserInfo(self, username):
    """
    Asks the UserStore about the publicly available location information for
    a particular username.
    
    @throws EDAMUserException <ul>
      <li> DATA_REQUIRED "username" - username is empty
    </ul>
    
    Parameters:
     - username
    """
    self.send_getPublicUserInfo(username)
    return self.recv_getPublicUserInfo()

  def send_getPublicUserInfo(self, username):
    self._oprot.writeMessageBegin('getPublicUserInfo', TMessageType.CALL, self._seqid)
    args = getPublicUserInfo_args()
    args.username = username
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getPublicUserInfo(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getPublicUserInfo_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.notFoundException is not None:
      raise result.notFoundException
    if result.systemException is not None:
      raise result.systemException
    if result.userException is not None:
      raise result.userException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getPublicUserInfo failed: unknown result");

  def getPremiumInfo(self, authenticationToken):
    """
    Returns information regarding a user's Premium account corresponding to the
    provided authentication token, or throws an exception if this token is not
    valid.
    
    Parameters:
     - authenticationToken
    """
    self.send_getPremiumInfo(authenticationToken)
    return self.recv_getPremiumInfo()

  def send_getPremiumInfo(self, authenticationToken):
    self._oprot.writeMessageBegin('getPremiumInfo', TMessageType.CALL, self._seqid)
    args = getPremiumInfo_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getPremiumInfo(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getPremiumInfo_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getPremiumInfo failed: unknown result");

  def getNoteStoreUrl(self, authenticationToken):
    """
    Returns the URL that should be used to talk to the NoteStore for the
    account represented by the provided authenticationToken.
    This method isn't needed by most clients, who can retrieve the correct
    NoteStore URL from the AuthenticationResult returned from the authenticate
    or refreshAuthentication calls. This method is typically only needed
    to look up the correct URL for a long-lived session token (e.g. for an
    OAuth web service).
    
    Parameters:
     - authenticationToken
    """
    self.send_getNoteStoreUrl(authenticationToken)
    return self.recv_getNoteStoreUrl()

  def send_getNoteStoreUrl(self, authenticationToken):
    self._oprot.writeMessageBegin('getNoteStoreUrl', TMessageType.CALL, self._seqid)
    args = getNoteStoreUrl_args()
    args.authenticationToken = authenticationToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNoteStoreUrl(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNoteStoreUrl_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userException is not None:
      raise result.userException
    if result.systemException is not None:
      raise result.systemException
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNoteStoreUrl failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["checkVersion"] = Processor.process_checkVersion
    self._processMap["getBootstrapInfo"] = Processor.process_getBootstrapInfo
    self._processMap["authenticate"] = Processor.process_authenticate
    self._processMap["refreshAuthentication"] = Processor.process_refreshAuthentication
    self._processMap["getUser"] = Processor.process_getUser
    self._processMap["getPublicUserInfo"] = Processor.process_getPublicUserInfo
    self._processMap["getPremiumInfo"] = Processor.process_getPremiumInfo
    self._processMap["getNoteStoreUrl"] = Processor.process_getNoteStoreUrl

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_checkVersion(self, seqid, iprot, oprot):
    args = checkVersion_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = checkVersion_result()
    result.success = self._handler.checkVersion(args.clientName, args.edamVersionMajor, args.edamVersionMinor)
    oprot.writeMessageBegin("checkVersion", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getBootstrapInfo(self, seqid, iprot, oprot):
    args = getBootstrapInfo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getBootstrapInfo_result()
    result.success = self._handler.getBootstrapInfo(args.locale)
    oprot.writeMessageBegin("getBootstrapInfo", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_authenticate(self, seqid, iprot, oprot):
    args = authenticate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = authenticate_result()
    try:
      result.success = self._handler.authenticate(args.username, args.password, args.consumerKey, args.consumerSecret)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("authenticate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_refreshAuthentication(self, seqid, iprot, oprot):
    args = refreshAuthentication_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = refreshAuthentication_result()
    try:
      result.success = self._handler.refreshAuthentication(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("refreshAuthentication", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getUser(self, seqid, iprot, oprot):
    args = getUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getUser_result()
    try:
      result.success = self._handler.getUser(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getPublicUserInfo(self, seqid, iprot, oprot):
    args = getPublicUserInfo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getPublicUserInfo_result()
    try:
      result.success = self._handler.getPublicUserInfo(args.username)
    except evernote.edam.error.ttypes.EDAMNotFoundException, notFoundException:
      result.notFoundException = notFoundException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    oprot.writeMessageBegin("getPublicUserInfo", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getPremiumInfo(self, seqid, iprot, oprot):
    args = getPremiumInfo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getPremiumInfo_result()
    try:
      result.success = self._handler.getPremiumInfo(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getPremiumInfo", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNoteStoreUrl(self, seqid, iprot, oprot):
    args = getNoteStoreUrl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNoteStoreUrl_result()
    try:
      result.success = self._handler.getNoteStoreUrl(args.authenticationToken)
    except evernote.edam.error.ttypes.EDAMUserException, userException:
      result.userException = userException
    except evernote.edam.error.ttypes.EDAMSystemException, systemException:
      result.systemException = systemException
    oprot.writeMessageBegin("getNoteStoreUrl", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class checkVersion_args(object):
  """
  Attributes:
   - clientName
   - edamVersionMajor
   - edamVersionMinor
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'clientName', None, None, ), # 1
    (2, TType.I16, 'edamVersionMajor', None, 1, ), # 2
    (3, TType.I16, 'edamVersionMinor', None, 21, ), # 3
  )

  def __init__(self, clientName=None, edamVersionMajor=thrift_spec[2][4], edamVersionMinor=thrift_spec[3][4],):
    self.clientName = clientName
    self.edamVersionMajor = edamVersionMajor
    self.edamVersionMinor = edamVersionMinor

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.clientName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.edamVersionMajor = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.edamVersionMinor = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('checkVersion_args')
    if self.clientName is not None:
      oprot.writeFieldBegin('clientName', TType.STRING, 1)
      oprot.writeString(self.clientName)
      oprot.writeFieldEnd()
    if self.edamVersionMajor is not None:
      oprot.writeFieldBegin('edamVersionMajor', TType.I16, 2)
      oprot.writeI16(self.edamVersionMajor)
      oprot.writeFieldEnd()
    if self.edamVersionMinor is not None:
      oprot.writeFieldBegin('edamVersionMinor', TType.I16, 3)
      oprot.writeI16(self.edamVersionMinor)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class checkVersion_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('checkVersion_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getBootstrapInfo_args(object):
  """
  Attributes:
   - locale
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'locale', None, None, ), # 1
  )

  def __init__(self, locale=None,):
    self.locale = locale

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.locale = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getBootstrapInfo_args')
    if self.locale is not None:
      oprot.writeFieldBegin('locale', TType.STRING, 1)
      oprot.writeString(self.locale)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getBootstrapInfo_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (BootstrapInfo, BootstrapInfo.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = BootstrapInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getBootstrapInfo_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authenticate_args(object):
  """
  Attributes:
   - username
   - password
   - consumerKey
   - consumerSecret
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'username', None, None, ), # 1
    (2, TType.STRING, 'password', None, None, ), # 2
    (3, TType.STRING, 'consumerKey', None, None, ), # 3
    (4, TType.STRING, 'consumerSecret', None, None, ), # 4
  )

  def __init__(self, username=None, password=None, consumerKey=None, consumerSecret=None,):
    self.username = username
    self.password = password
    self.consumerKey = consumerKey
    self.consumerSecret = consumerSecret

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.username = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.password = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.consumerKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.consumerSecret = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authenticate_args')
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 1)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.password is not None:
      oprot.writeFieldBegin('password', TType.STRING, 2)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    if self.consumerKey is not None:
      oprot.writeFieldBegin('consumerKey', TType.STRING, 3)
      oprot.writeString(self.consumerKey)
      oprot.writeFieldEnd()
    if self.consumerSecret is not None:
      oprot.writeFieldBegin('consumerSecret', TType.STRING, 4)
      oprot.writeString(self.consumerSecret)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class authenticate_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AuthenticationResult, AuthenticationResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AuthenticationResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('authenticate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class refreshAuthentication_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('refreshAuthentication_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class refreshAuthentication_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AuthenticationResult, AuthenticationResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AuthenticationResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('refreshAuthentication_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUser_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUser_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getUser_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (evernote.edam.type.ttypes.User, evernote.edam.type.ttypes.User.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = evernote.edam.type.ttypes.User()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPublicUserInfo_args(object):
  """
  Attributes:
   - username
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'username', None, None, ), # 1
  )

  def __init__(self, username=None,):
    self.username = username

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.username = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPublicUserInfo_args')
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 1)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPublicUserInfo_result(object):
  """
  Attributes:
   - success
   - notFoundException
   - systemException
   - userException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PublicUserInfo, PublicUserInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'notFoundException', (evernote.edam.error.ttypes.EDAMNotFoundException, evernote.edam.error.ttypes.EDAMNotFoundException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, notFoundException=None, systemException=None, userException=None,):
    self.success = success
    self.notFoundException = notFoundException
    self.systemException = systemException
    self.userException = userException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PublicUserInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.notFoundException = evernote.edam.error.ttypes.EDAMNotFoundException()
          self.notFoundException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPublicUserInfo_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.notFoundException is not None:
      oprot.writeFieldBegin('notFoundException', TType.STRUCT, 1)
      self.notFoundException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 3)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPremiumInfo_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPremiumInfo_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPremiumInfo_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PremiumInfo, PremiumInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PremiumInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPremiumInfo_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteStoreUrl_args(object):
  """
  Attributes:
   - authenticationToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'authenticationToken', None, None, ), # 1
  )

  def __init__(self, authenticationToken=None,):
    self.authenticationToken = authenticationToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.authenticationToken = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteStoreUrl_args')
    if self.authenticationToken is not None:
      oprot.writeFieldBegin('authenticationToken', TType.STRING, 1)
      oprot.writeString(self.authenticationToken)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNoteStoreUrl_result(object):
  """
  Attributes:
   - success
   - userException
   - systemException
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'userException', (evernote.edam.error.ttypes.EDAMUserException, evernote.edam.error.ttypes.EDAMUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'systemException', (evernote.edam.error.ttypes.EDAMSystemException, evernote.edam.error.ttypes.EDAMSystemException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, userException=None, systemException=None,):
    self.success = success
    self.userException = userException
    self.systemException = systemException

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userException = evernote.edam.error.ttypes.EDAMUserException()
          self.userException.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.systemException = evernote.edam.error.ttypes.EDAMSystemException()
          self.systemException.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNoteStoreUrl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.userException is not None:
      oprot.writeFieldBegin('userException', TType.STRUCT, 1)
      self.userException.write(oprot)
      oprot.writeFieldEnd()
    if self.systemException is not None:
      oprot.writeFieldBegin('systemException', TType.STRUCT, 2)
      self.systemException.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

########NEW FILE########
__FILENAME__ = basetypes
from sqlalchemy.orm.exc import NoResultFound


NONE_ID = 0
NONE_VAL = 0


class DbusSendableList(object):
    """Dbus sendable list"""

    def __init__(self, cls):
        self._cls = cls

    def __rshift__(self, other):
        """Shortcut to from_obj and struct"""
        return [self._cls.from_obj(item).struct for item in other]

    def __lshift__(self, other):
        """Shortcut to from_tuple"""
        return [self._cls.from_tuple(item) for item in other]


class BaseDbusSendable(type):
    @property
    def signature(cls):
        return '(' + ''.join(map(
            lambda field: field[1],
            cls.fields,
        )) + ')'

    def __rshift__(cls, other):
        """Shortcut to from_obj and struct"""
        return cls.from_obj(other).struct

    def __lshift__(cls, other):
        """Shortcut to from_tuple"""
        return cls.from_tuple(other)

    @property
    def list(cls):
        """Return shortcut for list mapping"""
        return DbusSendableList(cls)


class DbusSendable(object):
    __metaclass__ = BaseDbusSendable
    fields = tuple()

    def __init__(self, **kwargs):
        for key, val in kwargs.items():
            setattr(self, key, val)

    @classmethod
    def from_obj(cls, data):
        inst = cls()
        for field in cls.fields:
            if hasattr(data, field[0] + '_dbus'):
                val = getattr(data, field[0] + '_dbus')
            else:
                val = getattr(data, field[0], None)
            if hasattr(val, '__call__'):
                val = val()
            setattr(inst, field[0], val)
        return inst

    @classmethod
    def from_tuple(cls, data):
        inst = cls()
        for num, field in enumerate(cls.fields):
            setattr(inst, field[0], data[num])
        return inst

    @property
    def struct(self):
        result = []
        for field in self.fields:
            result.append(getattr(self, field[0], None))
        return tuple(result)

    def give_to_obj(self, obj):
        for field in self.fields:
            val = getattr(self, field[0])
            try:
                # check exists, hasattr fails with fresh sqlalchemy
                # with object has no attribute '_sa_instance_state'
                try:
                    getattr(obj, field[0] + '_dbus')
                except NoResultFound:
                    # pass when fields is one-to-one relation
                    pass

                setattr(obj, field[0] + '_dbus', val)
            except AttributeError:
                setattr(obj, field[0], val)

    def __repr__(self):
        return "<%s:\n%s>" % (
            type(self).__name__,
            "\n".join(map(
                lambda field: '%s: %s' % (
                    field[0], str(getattr(self, field[0], '')),
                ), self.fields,
            ))
        )


class Note(DbusSendable):
    ORDER_TITLE = 0
    ORDER_UPDATED = 1
    ORDER_TITLE_DESC = 2
    ORDER_UPDATED_DESC = 3

    fields = (
        ('id', 'i'),
        ('title', 's'),
        ('content', 's'),
        ('created', 'x'),
        ('updated', 'x'),
        ('notebook', 'i'),
        ('tags', 'as'),
        ('place', 's'),
        ('pinnded', 'b'),
        ('conflict_parent', 'i'),
        ('conflict_items', 'ai'),
        ('share_date', 'x'),
        ('share_url', 's'),
    )


class Notebook(DbusSendable):
    fields = (
        ('id', 'i'),
        ('name', 's'),
        ('default', 'i'),
        ('stack', 's')
    )


class Tag(DbusSendable):
    fields = (
        ('id', 'i'),
        ('name', 's'),
    )


class Resource(DbusSendable):
    fields = (
        ('id', 'i'),
        ('file_name', 's'),
        ('file_path', 's'),
        ('mime', 's'),
        ('hash', 's'),
    )


class Place(DbusSendable):
    fields = (
        ('id', 'i'),
        ('name', 's'),
    )

########NEW FILE########
__FILENAME__ = const
CONSUMER_KEY = 'nvbn-1422'
CONSUMER_SECRET = 'c17c0979d0054310'
HOST = 'www.evernote.com'
STATUS_NONE = 0
STATUS_SYNC = 1
DEFAULT_SYNC_DELAY = 30000 * 60
SYNC_STATE_START = 0
SYNC_STATE_NOTEBOOKS_LOCAL = 1
SYNC_STATE_TAGS_LOCAL = 2
SYNC_STATE_NOTES_LOCAL = 3
SYNC_STATE_NOTEBOOKS_REMOTE = 4
SYNC_STATE_TAGS_REMOTE = 5
SYNC_STATE_NOTES_REMOTE = 6
SYNC_STATE_SHARE = 7
SYNC_STATE_STOP_SHARE = 8
SYNC_STATE_FINISH = 9
SYNC_MANUAL = -1
SYNC_STATES = (
    SYNC_STATE_START, SYNC_STATE_NOTEBOOKS_LOCAL,
    SYNC_STATE_TAGS_LOCAL, SYNC_STATE_NOTES_LOCAL,
    SYNC_STATE_NOTEBOOKS_REMOTE, SYNC_STATE_TAGS_REMOTE,
    SYNC_STATE_NOTES_REMOTE, SYNC_STATE_FINISH,
)
DEFAULT_FONT = 'Sans'
DEFAULT_FONT_SIZE = 14
DEFAULT_INDICATOR_LAYOUT = [
    'create_note', 'pin_notes', 'notes', 'all_notes', 'sync',
]

SCHEMA_VERSION = 5
API_VERSION = 6
VERSION = '2.5'
DB_PATH = "~/.everpad/everpad.%s.db" % SCHEMA_VERSION

ACTION_NONE = 0
ACTION_CREATE = 1
ACTION_DELETE = 2
ACTION_CHANGE = 3
ACTION_NOEXSIST = 4
ACTION_CONFLICT = 5
ACTION_DUPLICATE = 6

DISABLED_ACTIONS = (ACTION_DELETE, ACTION_NOEXSIST, ACTION_CONFLICT)

SHARE_NONE = 0
SHARE_NEED_SHARE = 1
SHARE_SHARED = 2
SHARE_NEED_STOP = 3

NONE_ID = 0
NONE_VAL = 0

ORDER_TITLE = 0
ORDER_UPDATED = 1
ORDER_TITLE_DESC = 2
ORDER_UPDATED_DESC = 3

DEFAULT_LIMIT = 100
NOT_PINNDED = -1

########NEW FILE########
__FILENAME__ = editor
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'editor.ui'
#
# Created: Sun Feb 24 18:32:37 2013
#      by: pyside-uic 0.2.13 running on PySide 1.1.1
#
# WARNING! All changes made in this file will be lost!

from PySide import QtCore, QtGui

class Ui_Editor(object):
    def setupUi(self, Editor):
        Editor.setObjectName("Editor")
        Editor.resize(565, 381)
        self.centralwidget = QtGui.QWidget(Editor)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayout = QtGui.QVBoxLayout(self.centralwidget)
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout = QtGui.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.contentView = QtWebKit.QWebView(self.centralwidget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.contentView.sizePolicy().hasHeightForWidth())
        self.contentView.setSizePolicy(sizePolicy)
        self.contentView.setUrl(QtCore.QUrl("about:blank"))
        self.contentView.setObjectName("contentView")
        self.horizontalLayout.addWidget(self.contentView)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.options = QtGui.QHBoxLayout()
        self.options.setObjectName("options")
        self.notebook = QtGui.QComboBox(self.centralwidget)
        self.notebook.setObjectName("notebook")
        self.options.addWidget(self.notebook)
        self.tags = QtGui.QLineEdit(self.centralwidget)
        self.tags.setObjectName("tags")
        self.options.addWidget(self.tags)
        self.verticalLayout.addLayout(self.options)
        self.resourceLabel = QtGui.QLabel(self.centralwidget)
        self.resourceLabel.setTextFormat(QtCore.Qt.AutoText)
        self.resourceLabel.setObjectName("resourceLabel")
        self.verticalLayout.addWidget(self.resourceLabel)
        self.alternativeVersions = QtGui.QLabel(self.centralwidget)
        self.alternativeVersions.setWordWrap(True)
        self.alternativeVersions.setObjectName("alternativeVersions")
        self.verticalLayout.addWidget(self.alternativeVersions)
        self.resourceArea = QtGui.QScrollArea(self.centralwidget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.resourceArea.sizePolicy().hasHeightForWidth())
        self.resourceArea.setSizePolicy(sizePolicy)
        self.resourceArea.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.resourceArea.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)
        self.resourceArea.setWidgetResizable(True)
        self.resourceArea.setObjectName("resourceArea")
        self.scrollAreaWidgetContents = QtGui.QWidget()
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 545, 76))
        self.scrollAreaWidgetContents.setObjectName("scrollAreaWidgetContents")
        self.resourceArea.setWidget(self.scrollAreaWidgetContents)
        self.verticalLayout.addWidget(self.resourceArea)
        Editor.setCentralWidget(self.centralwidget)
        self.toolBar = QtGui.QToolBar(Editor)
        self.toolBar.setMovable(False)
        self.toolBar.setObjectName("toolBar")
        Editor.addToolBar(QtCore.Qt.TopToolBarArea, self.toolBar)
        self.menubar = QtGui.QMenuBar(Editor)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 565, 25))
        self.menubar.setObjectName("menubar")
        self.menuFIle = QtGui.QMenu(self.menubar)
        self.menuFIle.setObjectName("menuFIle")
        self.menuEdit = QtGui.QMenu(self.menubar)
        self.menuEdit.setObjectName("menuEdit")
        Editor.setMenuBar(self.menubar)
        self.actionSave = QtGui.QAction(Editor)
        self.actionSave.setObjectName("actionSave")
        self.actionSave_and_close = QtGui.QAction(Editor)
        self.actionSave_and_close.setObjectName("actionSave_and_close")
        self.actionDelete = QtGui.QAction(Editor)
        self.actionDelete.setObjectName("actionDelete")
        self.actionClose = QtGui.QAction(Editor)
        self.actionClose.setObjectName("actionClose")
        self.actionCut = QtGui.QAction(Editor)
        self.actionCut.setObjectName("actionCut")
        self.actionCopy = QtGui.QAction(Editor)
        self.actionCopy.setObjectName("actionCopy")
        self.actionPaste = QtGui.QAction(Editor)
        self.actionPaste.setObjectName("actionPaste")
        self.actionFind = QtGui.QAction(Editor)
        self.actionFind.setObjectName("actionFind")
        self.menuFIle.addAction(self.actionSave)
        self.menuFIle.addAction(self.actionSave_and_close)
        self.menuFIle.addAction(self.actionDelete)
        self.menuFIle.addAction(self.actionClose)
        self.menuEdit.addAction(self.actionCut)
        self.menuEdit.addAction(self.actionCopy)
        self.menuEdit.addAction(self.actionPaste)
        self.menubar.addAction(self.menuFIle.menuAction())
        self.menubar.addAction(self.menuEdit.menuAction())

        self.retranslateUi(Editor)
        QtCore.QMetaObject.connectSlotsByName(Editor)

    def retranslateUi(self, Editor):
        Editor.setWindowTitle(QtGui.QApplication.translate("Editor", "Everpad", None, QtGui.QApplication.UnicodeUTF8))
        self.notebook.setToolTip(QtGui.QApplication.translate("Editor", "Select notebook", None, QtGui.QApplication.UnicodeUTF8))
        self.tags.setToolTip(QtGui.QApplication.translate("Editor", "Note tags", None, QtGui.QApplication.UnicodeUTF8))
        self.tags.setPlaceholderText(QtGui.QApplication.translate("Editor", "Commas separated tags", None, QtGui.QApplication.UnicodeUTF8))
        self.resourceLabel.setText(QtGui.QApplication.translate("Editor", "%d attached files, <a href=\'#\'>show</a> / <a href=\'#\'> add another</a>", None, QtGui.QApplication.UnicodeUTF8))
        self.alternativeVersions.setText(QtGui.QApplication.translate("Editor", "This note has alternative versions: %s", None, QtGui.QApplication.UnicodeUTF8))
        self.toolBar.setWindowTitle(QtGui.QApplication.translate("Editor", "toolBar", None, QtGui.QApplication.UnicodeUTF8))
        self.menuFIle.setTitle(QtGui.QApplication.translate("Editor", "Note", None, QtGui.QApplication.UnicodeUTF8))
        self.menuEdit.setTitle(QtGui.QApplication.translate("Editor", "Edit", None, QtGui.QApplication.UnicodeUTF8))
        self.actionSave.setText(QtGui.QApplication.translate("Editor", "Save", None, QtGui.QApplication.UnicodeUTF8))
        self.actionSave_and_close.setText(QtGui.QApplication.translate("Editor", "Save and close", None, QtGui.QApplication.UnicodeUTF8))
        self.actionDelete.setText(QtGui.QApplication.translate("Editor", "Delete", None, QtGui.QApplication.UnicodeUTF8))
        self.actionClose.setText(QtGui.QApplication.translate("Editor", "Close", None, QtGui.QApplication.UnicodeUTF8))
        self.actionCut.setText(QtGui.QApplication.translate("Editor", "Cut", None, QtGui.QApplication.UnicodeUTF8))
        self.actionCopy.setText(QtGui.QApplication.translate("Editor", "Copy", None, QtGui.QApplication.UnicodeUTF8))
        self.actionPaste.setText(QtGui.QApplication.translate("Editor", "Paste", None, QtGui.QApplication.UnicodeUTF8))
        self.actionFind.setText(QtGui.QApplication.translate("Editor", "Find", None, QtGui.QApplication.UnicodeUTF8))

from PySide import QtWebKit

########NEW FILE########
__FILENAME__ = findbar
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'everpad/interface/findbar.ui'
#
# Created: Sun Oct 21 07:01:56 2012
#      by: pyside-uic 0.2.13 running on PySide 1.1.0
#
# WARNING! All changes made in this file will be lost!

from PySide import QtCore, QtGui

class Ui_FindBar(object):
    def setupUi(self, FindBar):
        FindBar.setObjectName("FindBar")
        FindBar.resize(750, 33)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(FindBar.sizePolicy().hasHeightForWidth())
        FindBar.setSizePolicy(sizePolicy)
        self.horizontalLayout = QtGui.QHBoxLayout(FindBar)
        self.horizontalLayout.setContentsMargins(3, 3, 3, 3)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.btnClose = QtGui.QPushButton(FindBar)
        self.btnClose.setText("")
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap("../../../../.designer/backup"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.btnClose.setIcon(icon)
        self.btnClose.setObjectName("btnClose")
        self.horizontalLayout.addWidget(self.btnClose)
        self.lblFind = QtGui.QLabel(FindBar)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lblFind.sizePolicy().hasHeightForWidth())
        self.lblFind.setSizePolicy(sizePolicy)
        self.lblFind.setObjectName("lblFind")
        self.horizontalLayout.addWidget(self.lblFind)
        self.edtFindText = QtGui.QLineEdit(FindBar)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.edtFindText.sizePolicy().hasHeightForWidth())
        self.edtFindText.setSizePolicy(sizePolicy)
        self.edtFindText.setMinimumSize(QtCore.QSize(240, 0))
        self.edtFindText.setObjectName("edtFindText")
        self.horizontalLayout.addWidget(self.edtFindText)
        self.btnPrevious = QtGui.QPushButton(FindBar)
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap("../../../../../../.designer/backup"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.btnPrevious.setIcon(icon1)
        self.btnPrevious.setObjectName("btnPrevious")
        self.horizontalLayout.addWidget(self.btnPrevious)
        self.btnNext = QtGui.QPushButton(FindBar)
        self.btnNext.setIcon(icon1)
        self.btnNext.setObjectName("btnNext")
        self.horizontalLayout.addWidget(self.btnNext)
        self.btnHighlight = QtGui.QPushButton(FindBar)
        self.btnHighlight.setCheckable(True)
        self.btnHighlight.setObjectName("btnHighlight")
        self.horizontalLayout.addWidget(self.btnHighlight)
        self.chkMatchCase = QtGui.QCheckBox(FindBar)
        self.chkMatchCase.setObjectName("chkMatchCase")
        self.horizontalLayout.addWidget(self.chkMatchCase)
        spacerItem = QtGui.QSpacerItem(0, 0, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)

        self.retranslateUi(FindBar)
        QtCore.QMetaObject.connectSlotsByName(FindBar)

    def retranslateUi(self, FindBar):
        FindBar.setWindowTitle(QtGui.QApplication.translate("FindBar", "Form", None, QtGui.QApplication.UnicodeUTF8))
        self.lblFind.setText(QtGui.QApplication.translate("FindBar", "Find:", None, QtGui.QApplication.UnicodeUTF8))
        self.btnPrevious.setText(QtGui.QApplication.translate("FindBar", "Previous", None, QtGui.QApplication.UnicodeUTF8))
        self.btnNext.setText(QtGui.QApplication.translate("FindBar", "Next", None, QtGui.QApplication.UnicodeUTF8))
        self.btnHighlight.setText(QtGui.QApplication.translate("FindBar", "Highlight All", None, QtGui.QApplication.UnicodeUTF8))
        self.chkMatchCase.setText(QtGui.QApplication.translate("FindBar", "Match Case", None, QtGui.QApplication.UnicodeUTF8))


########NEW FILE########
__FILENAME__ = image
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'image.ui'
#
# Created: Sat Sep 29 16:13:53 2012
#      by: pyside-uic 0.2.13 running on PySide 1.1.0
#
# WARNING! All changes made in this file will be lost!

from PySide import QtCore, QtGui

class Ui_ImageDialog(object):
    def setupUi(self, ImageDialog):
        ImageDialog.setObjectName("ImageDialog")
        ImageDialog.setWindowModality(QtCore.Qt.WindowModal)
        ImageDialog.resize(248, 164)
        ImageDialog.setModal(True)
        self.gridLayout = QtGui.QGridLayout(ImageDialog)
        self.gridLayout.setObjectName("gridLayout")
        self.label = QtGui.QLabel(ImageDialog)
        self.label.setObjectName("label")
        self.gridLayout.addWidget(self.label, 0, 0, 1, 1)
        self.widthBox = QtGui.QSpinBox(ImageDialog)
        self.widthBox.setMinimum(1)
        self.widthBox.setMaximum(99999)
        self.widthBox.setObjectName("widthBox")
        self.gridLayout.addWidget(self.widthBox, 0, 1, 1, 1)
        self.label_2 = QtGui.QLabel(ImageDialog)
        self.label_2.setObjectName("label_2")
        self.gridLayout.addWidget(self.label_2, 1, 0, 1, 1)
        self.heightBox = QtGui.QSpinBox(ImageDialog)
        self.heightBox.setMinimum(1)
        self.heightBox.setMaximum(99999)
        self.heightBox.setObjectName("heightBox")
        self.gridLayout.addWidget(self.heightBox, 1, 1, 1, 1)
        self.checkBox = QtGui.QCheckBox(ImageDialog)
        self.checkBox.setChecked(True)
        self.checkBox.setObjectName("checkBox")
        self.gridLayout.addWidget(self.checkBox, 2, 0, 1, 2)
        self.buttonBox = QtGui.QDialogButtonBox(ImageDialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.gridLayout.addWidget(self.buttonBox, 3, 0, 1, 2)

        self.retranslateUi(ImageDialog)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL("accepted()"), ImageDialog.accept)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL("rejected()"), ImageDialog.reject)
        QtCore.QMetaObject.connectSlotsByName(ImageDialog)

    def retranslateUi(self, ImageDialog):
        ImageDialog.setWindowTitle(QtGui.QApplication.translate("ImageDialog", "Everpad / Image Preferences", None, QtGui.QApplication.UnicodeUTF8))
        self.label.setText(QtGui.QApplication.translate("ImageDialog", "Width", None, QtGui.QApplication.UnicodeUTF8))
        self.label_2.setText(QtGui.QApplication.translate("ImageDialog", "Height", None, QtGui.QApplication.UnicodeUTF8))
        self.checkBox.setText(QtGui.QApplication.translate("ImageDialog", "Discard ratio", None, QtGui.QApplication.UnicodeUTF8))


########NEW FILE########
__FILENAME__ = list
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'list.ui'
#
# Created: Sun Feb 24 10:42:09 2013
#      by: pyside-uic 0.2.13 running on PySide 1.1.1
#
# WARNING! All changes made in this file will be lost!

from PySide import QtCore, QtGui

class Ui_List(object):
    def setupUi(self, List):
        List.setObjectName("List")
        List.resize(800, 600)
        self.centralwidget = QtGui.QWidget(List)
        self.centralwidget.setObjectName("centralwidget")
        self.horizontalLayout = QtGui.QHBoxLayout(self.centralwidget)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.splitter = QtGui.QSplitter(self.centralwidget)
        self.splitter.setOrientation(QtCore.Qt.Horizontal)
        self.splitter.setChildrenCollapsible(False)
        self.splitter.setObjectName("splitter")
        self.layoutWidget = QtGui.QWidget(self.splitter)
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout_2 = QtGui.QVBoxLayout(self.layoutWidget)
        self.verticalLayout_2.setSizeConstraint(QtGui.QLayout.SetMinimumSize)
        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.horizontalLayout_2 = QtGui.QHBoxLayout()
        self.horizontalLayout_2.setSizeConstraint(QtGui.QLayout.SetMinimumSize)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.newNotebookBtn = QtGui.QPushButton(self.layoutWidget)
        self.newNotebookBtn.setObjectName("newNotebookBtn")
        self.horizontalLayout_2.addWidget(self.newNotebookBtn)
        self.newNoteBtn = QtGui.QPushButton(self.layoutWidget)
        self.newNoteBtn.setObjectName("newNoteBtn")
        self.horizontalLayout_2.addWidget(self.newNoteBtn)
        self.verticalLayout_2.addLayout(self.horizontalLayout_2)
        self.notebooksList = EverpadTreeView(self.layoutWidget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.notebooksList.sizePolicy().hasHeightForWidth())
        self.notebooksList.setSizePolicy(sizePolicy)
        self.notebooksList.setMinimumSize(QtCore.QSize(200, 0))
        self.notebooksList.setEditTriggers(QtGui.QAbstractItemView.NoEditTriggers)
        self.notebooksList.setHeaderHidden(True)
        self.notebooksList.setObjectName("notebooksList")
        self.verticalLayout_2.addWidget(self.notebooksList)
        self.tagsList = EverpadTreeView(self.layoutWidget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Preferred, QtGui.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tagsList.sizePolicy().hasHeightForWidth())
        self.tagsList.setSizePolicy(sizePolicy)
        self.tagsList.setMinimumSize(QtCore.QSize(200, 0))
        self.tagsList.setEditTriggers(QtGui.QAbstractItemView.NoEditTriggers)
        self.tagsList.setHeaderHidden(True)
        self.tagsList.setObjectName("tagsList")
        self.verticalLayout_2.addWidget(self.tagsList)
        self.notesList = EverpadTreeView(self.splitter)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(1)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.notesList.sizePolicy().hasHeightForWidth())
        self.notesList.setSizePolicy(sizePolicy)
        self.notesList.setMinimumSize(QtCore.QSize(300, 0))
        self.notesList.setEditTriggers(QtGui.QAbstractItemView.NoEditTriggers)
        self.notesList.setSortingEnabled(True)
        self.notesList.setObjectName("notesList")
        self.notesList.header().setDefaultSectionSize(200)
        self.notesList.header().setSortIndicatorShown(True)
        self.horizontalLayout.addWidget(self.splitter)
        List.setCentralWidget(self.centralwidget)
        self.menubar = QtGui.QMenuBar(List)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 25))
        self.menubar.setObjectName("menubar")
        List.setMenuBar(self.menubar)
        self.statusbar = QtGui.QStatusBar(List)
        self.statusbar.setObjectName("statusbar")
        List.setStatusBar(self.statusbar)

        self.retranslateUi(List)
        QtCore.QMetaObject.connectSlotsByName(List)

    def retranslateUi(self, List):
        List.setWindowTitle(QtGui.QApplication.translate("List", "MainWindow", None, QtGui.QApplication.UnicodeUTF8))
        self.newNotebookBtn.setToolTip(QtGui.QApplication.translate("List", "Create Notebook", None, QtGui.QApplication.UnicodeUTF8))
        self.newNotebookBtn.setText(QtGui.QApplication.translate("List", "Notebook", None, QtGui.QApplication.UnicodeUTF8))
        self.newNoteBtn.setToolTip(QtGui.QApplication.translate("List", "Create Note", None, QtGui.QApplication.UnicodeUTF8))
        self.newNoteBtn.setText(QtGui.QApplication.translate("List", "Note", None, QtGui.QApplication.UnicodeUTF8))

from everpad.pad.treeview import EverpadTreeView

########NEW FILE########
__FILENAME__ = management
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'management.ui'
#
# Created: Sun Mar 10 14:15:51 2013
#      by: pyside-uic 0.2.13 running on PySide 1.1.1
#
# WARNING! All changes made in this file will be lost!

from PySide import QtCore, QtGui

class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(438, 372)
        Dialog.setModal(False)
        self.verticalLayout = QtGui.QVBoxLayout(Dialog)
        self.verticalLayout.setObjectName("verticalLayout")
        self.tabWidget = QtGui.QTabWidget(Dialog)
        self.tabWidget.setObjectName("tabWidget")
        self.tab = QtGui.QWidget()
        self.tab.setObjectName("tab")
        self.gridLayout = QtGui.QGridLayout(self.tab)
        self.gridLayout.setObjectName("gridLayout")
        self.label = QtGui.QLabel(self.tab)
        self.label.setObjectName("label")
        self.gridLayout.addWidget(self.label, 0, 0, 1, 1)
        self.authBtn = QtGui.QPushButton(self.tab)
        self.authBtn.setObjectName("authBtn")
        self.gridLayout.addWidget(self.authBtn, 0, 1, 1, 1)
        self.label_2 = QtGui.QLabel(self.tab)
        self.label_2.setObjectName("label_2")
        self.gridLayout.addWidget(self.label_2, 2, 0, 1, 1)
        self.syncDelayBox = QtGui.QComboBox(self.tab)
        self.syncDelayBox.setObjectName("syncDelayBox")
        self.gridLayout.addWidget(self.syncDelayBox, 2, 1, 1, 1)
        self.label_3 = QtGui.QLabel(self.tab)
        self.label_3.setObjectName("label_3")
        self.gridLayout.addWidget(self.label_3, 3, 0, 1, 1)
        self.autoStart = QtGui.QCheckBox(self.tab)
        self.autoStart.setText("")
        self.autoStart.setObjectName("autoStart")
        self.gridLayout.addWidget(self.autoStart, 3, 1, 1, 1)
        self.tabWidget.addTab(self.tab, "")
        self.tab_2 = QtGui.QWidget()
        self.tab_2.setObjectName("tab_2")
        self.gridLayout_2 = QtGui.QGridLayout(self.tab_2)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.label_4 = QtGui.QLabel(self.tab_2)
        self.label_4.setObjectName("label_4")
        self.gridLayout_2.addWidget(self.label_4, 0, 0, 1, 1)
        self.noteFont = QtGui.QFontComboBox(self.tab_2)
        self.noteFont.setObjectName("noteFont")
        self.gridLayout_2.addWidget(self.noteFont, 0, 1, 1, 1)
        self.label_5 = QtGui.QLabel(self.tab_2)
        self.label_5.setObjectName("label_5")
        self.gridLayout_2.addWidget(self.label_5, 1, 0, 1, 1)
        self.noteSize = QtGui.QSpinBox(self.tab_2)
        self.noteSize.setObjectName("noteSize")
        self.gridLayout_2.addWidget(self.noteSize, 1, 1, 1, 1)
        self.label_6 = QtGui.QLabel(self.tab_2)
        self.label_6.setObjectName("label_6")
        self.gridLayout_2.addWidget(self.label_6, 2, 0, 1, 1)
        self.blackTray = QtGui.QCheckBox(self.tab_2)
        self.blackTray.setText("")
        self.blackTray.setObjectName("blackTray")
        self.gridLayout_2.addWidget(self.blackTray, 2, 1, 1, 1)
        self.progressLabel = QtGui.QLabel(self.tab_2)
        self.progressLabel.setObjectName("progressLabel")
        self.gridLayout_2.addWidget(self.progressLabel, 3, 0, 1, 1)
        self.progressCheckBox = QtGui.QCheckBox(self.tab_2)
        self.progressCheckBox.setText("")
        self.progressCheckBox.setObjectName("progressCheckBox")
        self.gridLayout_2.addWidget(self.progressCheckBox, 3, 1, 1, 1)
        self.label_7 = QtGui.QLabel(self.tab_2)
        self.label_7.setObjectName("label_7")
        self.gridLayout_2.addWidget(self.label_7, 4, 0, 1, 1)
        self.searchOnHome = QtGui.QCheckBox(self.tab_2)
        self.searchOnHome.setText("")
        self.searchOnHome.setObjectName("searchOnHome")
        self.gridLayout_2.addWidget(self.searchOnHome, 4, 1, 1, 1)
        self.label_8 = QtGui.QLabel(self.tab_2)
        self.label_8.setObjectName("label_8")
        self.gridLayout_2.addWidget(self.label_8, 5, 0, 1, 1)
        self.sortByNotebook = QtGui.QCheckBox(self.tab_2)
        self.sortByNotebook.setText("")
        self.sortByNotebook.setObjectName("sortByNotebook")
        self.gridLayout_2.addWidget(self.sortByNotebook, 5, 1, 1, 1)
        self.label_indLayout = QtGui.QLabel(self.tab_2)
        self.label_indLayout.setObjectName("label_indLayout")
        self.gridLayout_2.addWidget(self.label_indLayout, 6, 0, 1, 1)
        self.listWidget_indLayout = QtGui.QListWidget(self.tab_2)
        self.listWidget_indLayout.setMinimumSize(QtCore.QSize(0, 96))
        self.listWidget_indLayout.setMaximumSize(QtCore.QSize(16777215, 96))
        self.listWidget_indLayout.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.listWidget_indLayout.setDragDropMode(QtGui.QAbstractItemView.InternalMove)
        self.listWidget_indLayout.setObjectName("listWidget_indLayout")
        self.gridLayout_2.addWidget(self.listWidget_indLayout, 6, 1, 1, 1)
        self.tabWidget.addTab(self.tab_2, "")
        self.verticalLayout.addWidget(self.tabWidget)
        self.webView = QtWebKit.QWebView(Dialog)
        self.webView.setUrl(QtCore.QUrl("about:blank"))
        self.webView.setObjectName("webView")
        self.verticalLayout.addWidget(self.webView)
        self.buttonBox = QtGui.QDialogButtonBox(Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Close)
        self.buttonBox.setObjectName("buttonBox")
        self.verticalLayout.addWidget(self.buttonBox)

        self.retranslateUi(Dialog)
        self.tabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        Dialog.setWindowTitle(QtGui.QApplication.translate("Dialog", "Everpad / Settings and Management", None, QtGui.QApplication.UnicodeUTF8))
        self.label.setText(QtGui.QApplication.translate("Dialog", "Authorisation", None, QtGui.QApplication.UnicodeUTF8))
        self.authBtn.setText(QtGui.QApplication.translate("Dialog", "Authorise", None, QtGui.QApplication.UnicodeUTF8))
        self.label_2.setText(QtGui.QApplication.translate("Dialog", "Sync delay", None, QtGui.QApplication.UnicodeUTF8))
        self.label_3.setText(QtGui.QApplication.translate("Dialog", "Start with system", None, QtGui.QApplication.UnicodeUTF8))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), QtGui.QApplication.translate("Dialog", "Settings", None, QtGui.QApplication.UnicodeUTF8))
        self.label_4.setText(QtGui.QApplication.translate("Dialog", "Note font family", None, QtGui.QApplication.UnicodeUTF8))
        self.label_5.setText(QtGui.QApplication.translate("Dialog", "Note font size", None, QtGui.QApplication.UnicodeUTF8))
        self.label_6.setText(QtGui.QApplication.translate("Dialog", "Black tray icon", None, QtGui.QApplication.UnicodeUTF8))
        self.progressLabel.setText(QtGui.QApplication.translate("Dialog", "Launcher progress bar", None, QtGui.QApplication.UnicodeUTF8))
        self.label_7.setText(QtGui.QApplication.translate("Dialog", "Search on the home lens", None, QtGui.QApplication.UnicodeUTF8))
        self.label_8.setText(QtGui.QApplication.translate("Dialog", "Sort notes by notebook", None, QtGui.QApplication.UnicodeUTF8))
        self.label_indLayout.setText(QtGui.QApplication.translate("Dialog", "Indicator Layout", None, QtGui.QApplication.UnicodeUTF8))
        self.listWidget_indLayout.setToolTip(QtGui.QApplication.translate("Dialog", "<html><head/><body><p>Drag and drop items to change layout.</p></body></html>", None, QtGui.QApplication.UnicodeUTF8))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2), QtGui.QApplication.translate("Dialog", "Appearance", None, QtGui.QApplication.UnicodeUTF8))

from PySide import QtWebKit

########NEW FILE########
__FILENAME__ = notebook
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'notebook.ui'
#
# Created: Sun Aug 19 18:09:52 2012
#      by: pyside-uic 0.2.13 running on PySide 1.1.0
#
# WARNING! All changes made in this file will be lost!

from PySide import QtCore, QtGui

class Ui_Notebook(object):
    def setupUi(self, Notebook):
        Notebook.setObjectName("Notebook")
        Notebook.resize(296, 60)
        self.horizontalLayout = QtGui.QHBoxLayout(Notebook)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.verticalLayout = QtGui.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.name = QtGui.QLabel(Notebook)
        font = QtGui.QFont()
        font.setWeight(75)
        font.setBold(True)
        self.name.setFont(font)
        self.name.setObjectName("name")
        self.verticalLayout.addWidget(self.name)
        self.content = QtGui.QLabel(Notebook)
        font = QtGui.QFont()
        font.setWeight(50)
        font.setBold(False)
        self.content.setFont(font)
        self.content.setObjectName("content")
        self.verticalLayout.addWidget(self.content)
        self.horizontalLayout.addLayout(self.verticalLayout)
        spacerItem = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.actionBtn = QtGui.QPushButton(Notebook)
        self.actionBtn.setText("")
        self.actionBtn.setObjectName("actionBtn")
        self.horizontalLayout.addWidget(self.actionBtn)

        self.retranslateUi(Notebook)
        QtCore.QMetaObject.connectSlotsByName(Notebook)

    def retranslateUi(self, Notebook):
        Notebook.setWindowTitle(QtGui.QApplication.translate("Notebook", "Form", None, QtGui.QApplication.UnicodeUTF8))
        self.name.setText(QtGui.QApplication.translate("Notebook", "Notebook name", None, QtGui.QApplication.UnicodeUTF8))
        self.content.setText(QtGui.QApplication.translate("Notebook", "Contains 5 notes", None, QtGui.QApplication.UnicodeUTF8))


########NEW FILE########
__FILENAME__ = share_note
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'share_note.ui'
#
# Created: Tue Jan 22 22:46:18 2013
#      by: pyside-uic 0.2.13 running on PySide 1.1.1
#
# WARNING! All changes made in this file will be lost!

from PySide import QtCore, QtGui

class Ui_ShareNote(object):
    def setupUi(self, ShareNote):
        ShareNote.setObjectName("ShareNote")
        ShareNote.resize(442, 197)
        ShareNote.setModal(True)
        self.verticalLayout = QtGui.QVBoxLayout(ShareNote)
        self.verticalLayout.setObjectName("verticalLayout")
        self.waitText = QtGui.QLabel(ShareNote)
        font = QtGui.QFont()
        font.setPointSize(18)
        self.waitText.setFont(font)
        self.waitText.setScaledContents(False)
        self.waitText.setAlignment(QtCore.Qt.AlignCenter)
        self.waitText.setObjectName("waitText")
        self.verticalLayout.addWidget(self.waitText)
        self.sharedWidget = QtGui.QWidget(ShareNote)
        self.sharedWidget.setObjectName("sharedWidget")
        self.horizontalLayout_2 = QtGui.QHBoxLayout(self.sharedWidget)
        self.horizontalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.sharedBox = QtGui.QVBoxLayout()
        self.sharedBox.setObjectName("sharedBox")
        self.horizontalLayout = QtGui.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label = QtGui.QLabel(self.sharedWidget)
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)
        self.shareLink = QtGui.QLineEdit(self.sharedWidget)
        self.shareLink.setReadOnly(True)
        self.shareLink.setObjectName("shareLink")
        self.horizontalLayout.addWidget(self.shareLink)
        self.sharedBox.addLayout(self.horizontalLayout)
        self.horizontalLayout_3 = QtGui.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.copyButton = QtGui.QPushButton(self.sharedWidget)
        self.copyButton.setObjectName("copyButton")
        self.horizontalLayout_3.addWidget(self.copyButton)
        self.cancelButton = QtGui.QPushButton(self.sharedWidget)
        self.cancelButton.setObjectName("cancelButton")
        self.horizontalLayout_3.addWidget(self.cancelButton)
        self.sharedBox.addLayout(self.horizontalLayout_3)
        self.horizontalLayout_2.addLayout(self.sharedBox)
        self.verticalLayout.addWidget(self.sharedWidget)

        self.retranslateUi(ShareNote)
        QtCore.QMetaObject.connectSlotsByName(ShareNote)

    def retranslateUi(self, ShareNote):
        ShareNote.setWindowTitle(QtGui.QApplication.translate("ShareNote", "Dialog", None, QtGui.QApplication.UnicodeUTF8))
        self.waitText.setText(QtGui.QApplication.translate("ShareNote", "wait_text", None, QtGui.QApplication.UnicodeUTF8))
        self.label.setText(QtGui.QApplication.translate("ShareNote", "You can share note with link: ", None, QtGui.QApplication.UnicodeUTF8))
        self.copyButton.setText(QtGui.QApplication.translate("ShareNote", "Copy url", None, QtGui.QApplication.UnicodeUTF8))
        self.cancelButton.setText(QtGui.QApplication.translate("ShareNote", "Cancel sharing", None, QtGui.QApplication.UnicodeUTF8))


########NEW FILE########
__FILENAME__ = tableinsert
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file './tableinsert.ui'
#
# Created: Sun Oct  7 06:22:18 2012
#      by: pyside-uic 0.2.13 running on PySide 1.1.0
#
# WARNING! All changes made in this file will be lost!

from PySide import QtCore, QtGui

class Ui_TableInsertDialog(object):
    def setupUi(self, TableInsertDialog):
        TableInsertDialog.setObjectName("TableInsertDialog")
        TableInsertDialog.setWindowModality(QtCore.Qt.WindowModal)
        TableInsertDialog.resize(433, 191)
        self.buttonBox = QtGui.QDialogButtonBox(TableInsertDialog)
        self.buttonBox.setGeometry(QtCore.QRect(80, 150, 341, 32))
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.gridLayoutWidget = QtGui.QWidget(TableInsertDialog)
        self.gridLayoutWidget.setGeometry(QtCore.QRect(10, 10, 411, 121))
        self.gridLayoutWidget.setObjectName("gridLayoutWidget")
        self.gridLayout = QtGui.QGridLayout(self.gridLayoutWidget)
        self.gridLayout.setContentsMargins(0, 0, 0, 0)
        self.gridLayout.setObjectName("gridLayout")
        self.width = QtGui.QLineEdit(self.gridLayoutWidget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.width.sizePolicy().hasHeightForWidth())
        self.width.setSizePolicy(sizePolicy)
        self.width.setObjectName("width")
        self.gridLayout.addWidget(self.width, 2, 1, 1, 1)
        self.label_2 = QtGui.QLabel(self.gridLayoutWidget)
        self.label_2.setObjectName("label_2")
        self.gridLayout.addWidget(self.label_2, 1, 0, 1, 1)
        self.rows = QtGui.QLineEdit(self.gridLayoutWidget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.rows.sizePolicy().hasHeightForWidth())
        self.rows.setSizePolicy(sizePolicy)
        self.rows.setObjectName("rows")
        self.gridLayout.addWidget(self.rows, 0, 1, 1, 1)
        self.label = QtGui.QLabel(self.gridLayoutWidget)
        self.label.setObjectName("label")
        self.gridLayout.addWidget(self.label, 0, 0, 1, 1)
        self.columns = QtGui.QLineEdit(self.gridLayoutWidget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.columns.sizePolicy().hasHeightForWidth())
        self.columns.setSizePolicy(sizePolicy)
        self.columns.setObjectName("columns")
        self.gridLayout.addWidget(self.columns, 1, 1, 1, 1)
        self.label_3 = QtGui.QLabel(self.gridLayoutWidget)
        self.label_3.setObjectName("label_3")
        self.gridLayout.addWidget(self.label_3, 2, 0, 1, 1)
        self.widthType = QtGui.QComboBox(self.gridLayoutWidget)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.widthType.sizePolicy().hasHeightForWidth())
        self.widthType.setSizePolicy(sizePolicy)
        self.widthType.setObjectName("widthType")
        self.widthType.addItem("")
        self.widthType.addItem("")
        self.gridLayout.addWidget(self.widthType, 2, 2, 1, 1)

        self.retranslateUi(TableInsertDialog)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL("accepted()"), TableInsertDialog.accept)
        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL("rejected()"), TableInsertDialog.reject)
        QtCore.QMetaObject.connectSlotsByName(TableInsertDialog)

    def retranslateUi(self, TableInsertDialog):
        TableInsertDialog.setWindowTitle(QtGui.QApplication.translate("TableInsertDialog", "Everpad / Insert Table", None, QtGui.QApplication.UnicodeUTF8))
        self.width.setText(QtGui.QApplication.translate("TableInsertDialog", "100", None, QtGui.QApplication.UnicodeUTF8))
        self.label_2.setText(QtGui.QApplication.translate("TableInsertDialog", "Columns:", None, QtGui.QApplication.UnicodeUTF8))
        self.rows.setText(QtGui.QApplication.translate("TableInsertDialog", "2", None, QtGui.QApplication.UnicodeUTF8))
        self.label.setText(QtGui.QApplication.translate("TableInsertDialog", "Rows:", None, QtGui.QApplication.UnicodeUTF8))
        self.columns.setText(QtGui.QApplication.translate("TableInsertDialog", "2", None, QtGui.QApplication.UnicodeUTF8))
        self.label_3.setText(QtGui.QApplication.translate("TableInsertDialog", "Width:", None, QtGui.QApplication.UnicodeUTF8))
        self.widthType.setItemText(0, QtGui.QApplication.translate("TableInsertDialog", "% of page", None, QtGui.QApplication.UnicodeUTF8))
        self.widthType.setItemText(1, QtGui.QApplication.translate("TableInsertDialog", "pixels", None, QtGui.QApplication.UnicodeUTF8))


########NEW FILE########
__FILENAME__ = monkey
import httplib2
import ssl


def _ssl_wrap_socket(sock, key_file, cert_file,
                         disable_validation, ca_certs):
    if disable_validation:
        cert_reqs = ssl.CERT_NONE
    else:
        cert_reqs = ssl.CERT_REQUIRED
    # We should be specifying SSL version 3 or TLS v1, but the ssl module
    # doesn't expose the necessary knobs. So we need to go with the default
    # of SSLv23.
    return ssl.wrap_socket(sock, keyfile=key_file, certfile=cert_file,
        cert_reqs=cert_reqs, ca_certs=ca_certs, ssl_version=ssl.PROTOCOL_TLSv1)
httplib2._ssl_wrap_socket = _ssl_wrap_socket

########NEW FILE########
__FILENAME__ = actions
from PySide.QtGui import QIcon, QDialog, QWidget, QApplication
from PySide.QtCore import Slot
from PySide.QtWebKit import QWebPage
from everpad.interface.tableinsert import Ui_TableInsertDialog
from everpad.interface.image import Ui_ImageDialog
from everpad.interface.findbar import Ui_FindBar
from everpad.pad.tools import get_icon


class ImagePrefs(QDialog):
    def __init__(self, res, *args, **kwargs):
        QDialog.__init__(self, *args, **kwargs)
        self.app = QApplication.instance()
        self.res = res
        self.ui = Ui_ImageDialog()
        self.ui.setupUi(self)
        self.setWindowIcon(get_icon())
        self.ui.widthBox.setValue(self.res.w)
        self.ui.heightBox.setValue(self.res.h)
        self.ui.widthBox.valueChanged.connect(self.width_changed)
        self.ui.heightBox.valueChanged.connect(self.height_changed)
        self._auto_change = False

    def get_size(self):
        return self.ui.widthBox.value(), self.ui.heightBox.value()

    @Slot()
    def width_changed(self):
        if self.ui.checkBox.isChecked() and not self._auto_change:
            self._auto_change = True
            self.ui.heightBox.setValue(
                self.ui.widthBox.value() * self.res.h / self.res.w,
            )
        else:
            self._auto_change = False

    @Slot()
    def height_changed(self):
        if self.ui.checkBox.isChecked() and not self._auto_change:
            self._auto_change = True
            self.ui.widthBox.setValue(
                self.ui.heightBox.value() * self.res.w / self.res.h,
            )
        else:
            self._auto_change = False


class TableWidget(QDialog):
    def __init__(self, parent, rows=None, cells=None, *args, **kwargs):
        QDialog.__init__(self, parent, *args, **kwargs)
        self.ui = Ui_TableInsertDialog()
        self.ui.setupUi(self)
        self.setWindowIcon(get_icon())
        if rows:  # typecasting sucks
            self.ui.rows.setText(str(int(rows)))
        if cells:
            self.ui.columns.setText(str(int(cells)))

    def get_width(self):
        result = self.ui.width.text()
        # 0 is %, 1 is px.
        if self.ui.widthType.currentIndex() == 0:
            result += '%'
        return result


class FindBar(QWidget):
    def __init__(self, editor, *args, **kwargs):
        QWidget.__init__(self, *args, **kwargs)
        self.editor = editor
        self.ui = Ui_FindBar()
        self.ui.setupUi(self)

        # pyside-uic doesn't translate icons from themes correctly, so we have
        # to re-set the icons manually here
        self.ui.btnPrevious.setIcon(QIcon.fromTheme('go-previous'))
        self.ui.btnNext.setIcon(QIcon.fromTheme('go-next'))
        self.ui.btnClose.setIcon(QIcon.fromTheme('window-close'))
        self.visible = False

        self.ui.btnClose.clicked.connect(self.hide)
        self.ui.edtFindText.returnPressed.connect(self.find_next)
        self.ui.edtFindText.textChanged.connect(self.find_text_updated)

        self.ui.btnNext.clicked.connect(self.find_next)
        self.ui.btnPrevious.clicked.connect(self.find_previous)

        self.ui.btnHighlight.clicked.connect(self.update_highlight)
        self.ui.chkMatchCase.clicked.connect(self.match_case_updated)

    def set_search_term(self, search_term):
        self.ui.edtFindText.setText(search_term)

    def get_flags(self, default_flags=None):
        flags = QWebPage.FindFlag.FindWrapsAroundDocument
        if default_flags is not None:
            flags |= default_flags
        if self.ui.chkMatchCase.isChecked():
            flags |= QWebPage.FindFlag.FindCaseSensitively
        return flags

    @Slot()
    def match_case_updated(self):
        flags = self.get_flags()

        # We need the *old* flags value;  clear this flag if it's checked
        if self.ui.chkMatchCase.isChecked():
            flags &= ~QWebPage.FindFlag.FindCaseSensitively
        else:
            flags |= QWebPage.FindFlag.FindCaseSensitively
        self.update_highlight(flags=flags, clear=True)
        self.update_highlight()

    @Slot(str)
    def find_text_updated(self, text):
        self.update_highlight(text=text, clear=True)
        self.find()

    @Slot()
    def find_next(self, text=None):
        self.find()

    @Slot()
    def find_previous(self):
        self.find(QWebPage.FindFlag.FindBackward)

    def find(self, flags=None):
        if not self.visible:
            self.show(focus=False)
            return

        flags = self.get_flags(flags)
        self.editor.note_edit.page.findText(self.ui.edtFindText.text(), flags)
        self.update_highlight()

    @Slot()
    def update_highlight(self, flags=None, text=None, clear=False):
        flags = flags or self.get_flags()
        flags |= QWebPage.FindFlag.HighlightAllOccurrences
        text = text or self.ui.edtFindText.text()
        if clear or not self.ui.btnHighlight.isChecked():
            text = ''
        self.editor.note_edit.page.findText(text, flags)

    def show(self, flags=None, focus=True):
        QWidget.show(self)
        if self.visible:
            self.find(flags)
        else:
            self.editor.ui.centralwidget.layout().addWidget(self)
            self.visible = True

            self.find(flags)
            self.update_highlight()

        if focus:
            self.ui.edtFindText.setFocus()

        self.editor.find_action.setChecked(True)

    @Slot()
    def hide(self):
        QWidget.hide(self)
        if not self.visible:
            return
        self.update_highlight(clear=True)
        self.editor.ui.centralwidget.layout().removeWidget(self)
        self.setParent(None)
        self.visible = False
        self.editor.find_action.setChecked(False)

    @Slot()
    def toggle_visible(self):
        if self.visible:
            self.hide()
        else:
            self.show()

########NEW FILE########
__FILENAME__ = content
from PySide.QtGui import (
    QIcon, QAction, QFileDialog,
    QShortcut, QKeySequence, QInputDialog,
    QPrintPreviewDialog, QPrinter, QDropEvent,
    QDragEnterEvent, QDragMoveEvent, QApplication,
    QDesktopServices,
)
from PySide.QtCore import (
    Slot, Qt, QPoint, QObject, Signal, QUrl,
    QMimeData,
)
from PySide.QtWebKit import QWebPage, QWebSettings
from everpad.basetypes import Note
from everpad.pad.editor.actions import ImagePrefs, TableWidget
from everpad.pad.tools import file_icon_path
from everpad.tools import sanitize, clean, html_unescape, resource_filename
from everpad.const import DEFAULT_FONT, DEFAULT_FONT_SIZE
from BeautifulSoup import BeautifulSoup, Tag
from functools import partial
from copy import copy
import webbrowser
import os
import json
import re
import cgi


url = re.compile(r"((https?://|www)[-\w./#?%=&]+)")


def set_links(text):
    """Insert a href"""
    soup = BeautifulSoup(text)
    # don't change if text contains html
    if len(soup.findAll()):
        return text
    else:
        return url.sub(r'<a href="\1">\1</a>', text)


class Page(QWebPage):
    def __init__(self, edit):
        QWebPage.__init__(self)
        self.current = None
        self.edit = edit
        self.active_image = None
        self.active_link = None
        self.active_table = None
        settings = self.settings()
        family = self.edit.app.settings.value(
            'note-font-family', DEFAULT_FONT,
        )
        size = int(self.edit.app.settings.value(
            'note-font-size', DEFAULT_FONT_SIZE,
        ))
        settings.setFontFamily(
            QWebSettings.StandardFont, family,
        )
        settings.setFontSize(
            QWebSettings.DefaultFontSize, size,
        )
        settings.setFontSize(
            QWebSettings.DefaultFixedFontSize, size,
        )
        QWebSettings.globalSettings().setAttribute(
            QWebSettings.DeveloperExtrasEnabled, True,
        )

        # This allows JavaScript to call back to Slots, connect to Signals
        # and access/modify Qt props
        self.mainFrame().addToJavaScriptWindowObject("qpage", self)

    @Slot()
    def show_findbar(self):
        self.edit.parent.findbar.show()

    @Slot()
    def find_next(self):
        self.edit.parent.findbar.find_next()

    @Slot()
    def find_previous(self):
        self.edit.parent.findbar.find_previous()

    @Slot(str)
    def set_current_focus(self, focused):
        self.current = focused

    @Slot()
    def page_changed(self):
        self.edit.page_changed()

    @Slot(str, int, int)
    def set_active_image_info(self, image, width, height):
        self.active_image = image
        self.active_width = width
        self.active_height = height

    @Slot(str)
    def set_active_link(self, url):
        self.active_link = url

    @Slot(str)
    def set_active_table(self, id):
        self.active_table = id

    def javaScriptConsoleMessage(self, message, lineNumber, sourceID):
        print lineNumber, ':', message

    def acceptNavigationRequest(self, frame, request, type):
        modifiers = QApplication.keyboardModifiers()
        if modifiers == Qt.ControlModifier and type == QWebPage.NavigationTypeLinkClicked:
            QDesktopServices.openUrl(request.url())
        return False

    def event(self, e):
        if isinstance(e, QDragEnterEvent):
            data = e.mimeData()
            if data.hasUrls():
                e.accept()
            else:
                e.ignore()
            return True
        elif isinstance(e, QDragMoveEvent):
            pass
        elif isinstance(e, QDropEvent):
            self.edit.insert_files(e.mimeData().urls(), e.pos())
            return True

        return super(Page, self).event(e)


class ContentEdit(QObject):
    _editor_path = os.path.join(
        os.path.dirname(__file__), 'editor.html',
    )
    if not os.path.exists(_editor_path):
        _editor_path = resource_filename('share/everpad/editor.html')

    _html = open(_editor_path).read()

    copy_available = Signal(bool)

    def __init__(self, parent, widget, on_change):
        QObject.__init__(self)
        self.parent = parent
        self.app = QApplication.instance()
        self.widget = widget
        self.page = Page(self)
        self._on_change = on_change
        self._title = None
        self._content = None
        self._hovered_url = None
        self.widget.setContextMenuPolicy(Qt.CustomContextMenu)
        self.widget.customContextMenuRequested.connect(self.context_menu)
        self._init_actions()
        self._init_shortcuts()
        self._last_table_num = 0

    def _init_actions(self):
        self.check_action = QAction(self.tr('Insert Checkbox'), self)
        self.check_action.triggered.connect(self._insert_check)
        self.link_action = QAction(self.tr('Insert Link'), self)
        self.link_action.triggered.connect(self._insert_link)
        self.table_action = QAction(self.tr('Insert Table'), self)
        self.table_action.triggered.connect(self._insert_table)
        self.image_action = QAction(self.tr('Insert Image'), self)
        self.image_action.triggered.connect(self._insert_image)
        self.change_link = QAction(self.tr('Change link'), self)
        self.change_link.triggered.connect(
            Slot()(partial(self._change_link, self.page.active_link))
        )
        self.remove_link = QAction(self.tr('Remove link'), self)
        self.remove_link.triggered.connect(self._remove_link)

    def _init_shortcuts(self):
        for key, action in (
            ('Ctrl+b', QWebPage.ToggleBold),
            ('Ctrl+i', QWebPage.ToggleItalic),
            ('Ctrl+u', QWebPage.ToggleUnderline),
            ('Ctrl+Shift+b', QWebPage.InsertUnorderedList),
            ('Ctrl+Shift+o', QWebPage.InsertOrderedList),
            ('Ctrl+Shift+v', QWebPage.PasteAndMatchStyle),
            ('Ctrl+k', self.link_action),
            ('Ctrl+Shift+k',  self.change_link),
            ('Ctrl+l',  QWebPage.AlignLeft),
            ('Ctrl+r',  QWebPage.AlignRight),
            ('Ctrl+e',  QWebPage.AlignCenter),
            ('Ctrl+j',  QWebPage.AlignJustified),
            ('Ctrl+t',  QWebPage.ToggleStrikethrough),
            ('Ctrl+Space', QWebPage.RemoveFormat),
            ('Ctrl+Shift+c', self.check_action),
        ):
            QShortcut(
                QKeySequence(self.app.tr(key)),
                self.widget,
            ).activated.connect(
                Slot()(partial(self._action_for_key, action)),
            )

    @property
    def title(self):
        """Cache title and return"""
        soup = BeautifulSoup(self.page.mainFrame().toHtml())
        self._title = soup.find(id='title').text
        return clean(html_unescape(self._title))

    @title.setter
    def title(self, val):
        """Set title"""
        self._title = val
        self.apply()

    @property
    def content(self):
        """Cache content and return"""
        soup = BeautifulSoup(self.page.mainFrame().toHtml())
        for todo in soup.findAll('input', {'type': 'checkbox'}):
            todo.name = 'en-todo'
            if todo.get('checked') == 'false':
                del todo['checked']
            del todo['type']
        for media in soup.findAll('img'):
            if media.get('class') == 'tab':
                media.replaceWith(' ' * 5)
            if media.get('hash'):
                media.name = 'en-media'
                del media['src']
                del media['title']
        # remove tables id's before save
        for table in soup.findAll('table'):
            del table['id']
        self._content = sanitize(
            soup=soup.find(id='content'),
        ).replace('  ', u'\xa0\xa0').replace(u'\xa0 ', u'\xa0\xa0')
        return self._content

    @content.setter
    def content(self, val):
        """Set content"""
        soup = BeautifulSoup(val)
        for todo in soup.findAll('en-todo'):
            todo.name = 'input'
            todo['type'] = 'checkbox'
            if todo.get('checked') == 'false':
                del todo['checked']
            self.changed_by_default = True
        for media in soup.findAll('en-media'):
            if media.get('hash'):  # evernote android app error
                media.name = 'img'
                res = self.parent.resource_edit.get_by_hash(media['hash'])  # shit!
                if res:
                    if media['type'].find('image') == 0:
                        media['src'] = 'file://%s' % res.file_path
                    else:
                        media['src'] = file_icon_path
                    media['title'] = res.file_name
                    res.in_content = True
                    # wrap in link to make clickable
                    tag = Tag(soup, "a", [("href", 'file://%s' % res.file_path)])
                    media.replaceWith(tag)
                    tag.insert(0, media)
                else:
                    media['src'] = ''
                    media['title'] = ''
            else:
                media.hidden = True
        # set tables id's for identifing on hover
        for num, table in enumerate(soup.findAll('table')):
            table['id'] = 'table_%d' % num
            self._last_table_num = num
        self._content = re.sub(
            r'(&nbsp;| ){5}', '<img class="tab" />',
            unicode(soup).replace(u'\xa0', ' '),
        )  # shit!
        self.apply()

    def apply(self):
        """Apply title and content when filled"""
        if None not in (self._title, self._content):
            html = self._html.replace(
                '{{ title }}', cgi.escape(self._title),
            ).replace(
                '{{ content }}', self._content,
            )
            self.page.mainFrame().setHtml(html)
            self.widget.setPage(self.page)
            self.page.selectionChanged.connect(self.selection_changed)
            self.page.setLinkDelegationPolicy(QWebPage.DelegateAllLinks)
            self.page.linkClicked.connect(self.link_clicked)
            self.page.linkHovered.connect(self.link_hovered)
            self.page.contentsChanged.connect(self.page_changed)

    @Slot()
    def selection_changed(self):
        self.copy_available.emit(
            self.page.current == 'body'
        )

    @Slot(QUrl)
    def link_clicked(self, url):
        if url.scheme() == 'evernote':
            note_guid = url.toString().split('/')[6]
            note = Note.from_tuple(
                self.app.provider.get_note_by_guid(note_guid),
            )
            self.app.open(note)
        else:
            webbrowser.open(url.toString())

    @Slot(QPoint)
    def context_menu(self, pos, image_hash=None):
        """Show custom context menu"""
        menu = self.page.createStandardContextMenu()
        menu.clear()
        menu.addAction(self.page.action(QWebPage.Cut))
        menu.addAction(self.page.action(QWebPage.Copy))
        menu.addAction(self.page.action(QWebPage.Paste))
        paste_wo = self.page.action(QWebPage.PasteAndMatchStyle)
        paste_wo.setText(self.tr('Paste as Plain Text'))
        menu.addAction(paste_wo)
        if self._hovered_url:
            menu.addAction(self.page.action(QWebPage.CopyLinkToClipboard))
            menu.addAction(self.change_link)
            menu.addAction(self.remove_link)
            self.page.active_link = None
        if self.page.active_image:
            res = self.parent.resource_edit.get_by_hash(self.page.active_image)
            self.page.active_image = None
            menu.addAction(
                self.tr('Image Preferences'),
                Slot()(partial(self._show_image_dialog, res)),
            )
        if self.page.active_table:
            menu.addAction(
                self.tr('Change table'),
                Slot()(partial(self._update_table, self.page.active_table)),
            )
            self.page.active_table = None
        menu.addSeparator()
        menu.addAction(self.page.action(QWebPage.RemoveFormat))
        menu.addAction(self.page.action(QWebPage.SelectAll))
        menu.exec_(self.widget.mapToGlobal(pos))

    @Slot(unicode, unicode, unicode)
    def link_hovered(self, link, title, text):
        self._hovered_url = link

    @Slot()
    def page_changed(self):
        self._on_change()

    def _action_with_icon(self, action_type, icon_names, is_action=False):
        if is_action:
            action = action_type
        else:
            action = self.page.action(action_type)
        for icon_name in icon_names:
            if QIcon.hasThemeIcon(icon_name):
                action.setIcon(QIcon.fromTheme(icon_name))
                break

        self.copy_available.connect(action.setEnabled)
        return action

    def _action_for_key(self, action):
        if self.page.current == 'body':
            if isinstance(action, QWebPage.WebAction):
                action = self.page.action(action)
            action.trigger()

    @Slot()
    def _insert_link(self):
        url, ok = QInputDialog.getText(self.parent,
            self.tr('Everpad / Insert link'),
            self.tr('Press link address'),
        )
        if ok and url:
            self.page.mainFrame().evaluateJavaScript(
                'insertLink(%s);' % json.dumps(url),
            )
            self.page_changed()

    def _change_link(self, url):
        url, ok = QInputDialog.getText(self.parent,
            self.tr('Everpad / Change link'),
            self.tr('Press new link address'),
            text=url,
        )
        if ok and url:
            self.page.mainFrame().evaluateJavaScript(
                'changeLink(%s);' % json.dumps(url),
            )
            self.page_changed()

    @Slot()
    def _remove_link(self):
        self.page.mainFrame().evaluateJavaScript(
            'removeLink();',
        )
        self.page_changed()

    @Slot()
    def _insert_table(self):
        dialog = TableWidget(self.parent)
        self._last_table_num += 1
        if dialog.exec_():
            self.page.mainFrame().evaluateJavaScript(
                'insertTable(%s, %s, "%s", "table_%d");' % (
                    dialog.ui.rows.text(),
                    dialog.ui.columns.text(),
                    dialog.get_width(),
                    self._last_table_num,
                )
            )

    def _update_table(self, id):
        rows = self.page.mainFrame().evaluateJavaScript(
            'getTableRows("%s")' % id,
        )
        cells = self.page.mainFrame().evaluateJavaScript(
            'getTableCells("%s")' % id,
        )
        dialog = TableWidget(self.parent, rows, cells)
        self._last_table_num += 1
        if dialog.exec_():
            self.page.mainFrame().evaluateJavaScript(
                'updateTable(%s, %s, "%s", "%s");' % (
                    dialog.ui.rows.text(),
                    dialog.ui.columns.text(),
                    dialog.get_width(),
                    id,
                )
            )

    @Slot()
    def _insert_check(self):
        self.page.mainFrame().evaluateJavaScript(
            'insertCheck();',
        )
        self.page_changed()

    @Slot()
    def _insert_image(self):
        name = QFileDialog.getOpenFileName(
            filter=self.tr("Image Files (*.png *.jpg *.bmp *.gif)"),
        )[0]
        if name:
            self._insert_image_from_path(name)

    def _insert_image_from_path(self, path):
            res = self.parent.resource_edit.add_attach(path)
            self.paste_res(res)

    def get_format_actions(self):
        actions = [
            (QWebPage.ToggleBold,
                ['format-text-bold', 'everpad-text-bold']),
            (QWebPage.ToggleItalic,
                ['format-text-italic', 'everpad-text-italic']),
            (QWebPage.ToggleUnderline,
                ['format-text-underline', 'everpad-text-underline']),
            (QWebPage.ToggleStrikethrough,
                ['format-text-strikethrough', 'everpad-text-strikethrough']),
            (QWebPage.AlignCenter,
                ['format-justify-center', 'everpad-justify-center']),
            (QWebPage.AlignJustified,
                ['format-justify-fill', 'everpad-justify-fill']),
            (QWebPage.AlignLeft,
                ['format-justify-left', 'everpad-justify-left']),
            (QWebPage.AlignRight,
                ['format-justify-right', 'everpad-justify-right']),
            ]
        if self._enable_text_direction_support():
            actions += [
                (QWebPage.SetTextDirectionLeftToRight,
                    ['format-text-direction-ltr', 'everpad-text-direction-ltr']),
                (QWebPage.SetTextDirectionRightToLeft,
                    ['format-text-direction-rtl', 'everpad-text-direction-rtl']),
                ]
        actions += [
            (QWebPage.InsertUnorderedList,
                ['format-list-unordered', 'everpad-list-unordered']),
            (QWebPage.InsertOrderedList,
                ['format-list-ordered', 'everpad-list-ordered']),
            # Don't include 'checkbox' since it looks bad in some default themes
            (self.check_action, ['everpad-checkbox'], True),
            (self.table_action, ['insert-table', 'everpad-insert-table'], True),
            (self.link_action, ['insert-link'], True),
            (self.image_action, ['insert-image'], True),
        ]
        return map(lambda action: self._action_with_icon(*action), actions)

    def paste_res(self, res):
        if res.mime.find('image') == 0:
            preview = 'file://%s' % res.file_path
        else:
            preview = file_icon_path
        self.page.mainFrame().evaluateJavaScript(
            'insertRes("%s", "%s", "%s");' % (
                preview, res.hash, res.mime,
            ),
        )
        self.page_changed()

    def _show_image_dialog(self, res):
        res.w = int(self.page.active_width)
        res.h = int(self.page.active_height)
        dialog = ImagePrefs(res, self.parent)
        if dialog.exec_():
            w, h = dialog.get_size()
            self.page.mainFrame().evaluateJavaScript(
                'changeRes("%s", %d, %d);' % (
                    res.hash, w, h,
                ),
            )
            self.page_changed()

    def in_content(self, res):
        return self.page.mainFrame().evaluateJavaScript(
            'resExist("%s");' % (
                res.hash,
            ),
        )

    def _enable_text_direction_support(self):
        def is_rtl_language(language_code):
            if not language_code:
                return False
            rtl_languages = ['ar', 'fa', 'he', 'ur']
            for lang in rtl_languages:
                if language_code.startswith(lang):
                    return True
            return False

        import locale
        default_language = locale.getdefaultlocale()[0]
        if is_rtl_language(default_language):
            return True
        # If the default language is not a RTL language, go through the preferred list
        # of languages to see if one of them is RTL. Unfortunately, this is platform-specific
        # logic, and I couldn't find a portable way of doing it.
        preferred_languages = os.getenv('LANGUAGE', '').split(':')
        for language in preferred_languages:
            if is_rtl_language(language):
                return True

        return False

    def print_(self):
        """Print note with preview"""
        printer = QPrinter()
        dialog = QPrintPreviewDialog(printer)
        dialog.paintRequested.connect(self.page.view().print_)
        dialog.exec_()

    def email_note(self):
        body = self.page.mainFrame().toPlainText()[
            len(self.title):
        ].strip()
        url = QUrl("mailto:")
        url.addQueryItem("subject", self.title)
        url.addQueryItem("body", body)
        QDesktopServices.openUrl(url)

    def insert_files(self, urls, pos):
        """Not only images"""
        image_extensions = ['.png', '.jpg', '.bmp', '.gif']
        for url in urls:
            if url.scheme() == 'file':
                path = url.path()
                ext = os.path.splitext(path)[1]
                if os.path.exists(path) and ext in image_extensions:
                    self._insert_image_from_path(path)
                else:
                    self.parent.resource_edit.add_attach(path)

########NEW FILE########
__FILENAME__ = resources
from PySide.QtGui import (
    QPixmap, QLabel, QVBoxLayout, QFileDialog,
    QMenu, QFileIconProvider, QWidget,
    QHBoxLayout, QApplication, QMessageBox,
)
from PySide.QtCore import Slot, Qt, QUrl, QFileInfo
from everpad.basetypes import Resource, NONE_ID
from everpad.tools import prepare_file_path
from functools import partial
import subprocess
import magic
import os
import shutil
import hashlib
import urllib


class ResourceItem(QWidget):
    def __init__(self, res):
        QWidget.__init__(self)
        self.res = res
        layout = QVBoxLayout()
        self.setLayout(layout)
        preview = QLabel()
        if 'image' in res.mime:
            pixmap = QPixmap(res.file_path).scaledToWidth(32)

        else:
            info = QFileInfo(res.file_path)
            pixmap = QFileIconProvider().icon(info).pixmap(32, 32)
        preview.setPixmap(pixmap)
        preview.setMask(pixmap.mask())
        preview.setMaximumHeight(32)
        label = QLabel()
        label.setText(res.file_name)
        layout.addWidget(preview)
        layout.addWidget(label)
        layout.setAlignment(Qt.AlignHCenter)
        self.setFixedWidth(64)
        self.setFixedHeight(64)


class ResourceEdit(object):  # TODO: move event to item
    """Abstraction for notebook edit"""

    def __init__(self, parent, widget, label, on_change):
        """Init and connect signals"""
        self.label = label
        self.parent = parent
        self.app = QApplication.instance()
        self.widget = widget
        self.note = None
        self.on_change = on_change
        self._resource_labels = {}
        self._resources = []
        self._res_hash = {}
        self.widget.setLayout(QHBoxLayout())
        self.widget.layout().setAlignment(Qt.AlignLeft)
        self.mime = magic.open(magic.MIME_TYPE)
        self.mime.load()
        if int(self.app.settings.value(
            'note-resources-%d' % self.parent.note.id, 0,
        )):
            self.widget.show()
        self.label.linkActivated.connect(self.label_uri)
        self.label.setContextMenuPolicy(Qt.NoContextMenu)

    def update_label(self):
        self.label.setText(
            self.app.translate('ResourceEdit', '%d attached files: <a href="show">%s</a> / <a href="add">%s</a>'
            ) % (
                len(self._resources), self.app.translate('ResourceEdit', 'show') if self.widget.isHidden()
                else self.app.translate('ResourceEdit', 'hide'),
                self.app.translate('ResourceEdit', 'add another'),
            ),
        )

    @Slot(QUrl)
    def label_uri(self, uri):
        uri = str(uri)
        if uri == 'add':
            self.add()
        elif uri == 'show':
            if self.widget.isHidden():
                self.widget.show()
                visible = 1
            else:
                self.widget.hide()
                visible = 0
            self.app.settings.setValue(
                'note-resources-%d' % self.parent.note.id, visible,
            )
            self.update_label()

    @property
    def resources(self):
        """Get resources"""
        return self._resources

    @resources.setter
    def resources(self, val):
        """Set resources"""
        self._resources = val
        for res in val:
            self._put(res)
        self.update_label()

    def _put(self, res):
        """Put resource on widget"""
        item = ResourceItem(res)
        item.mouseReleaseEvent = partial(self.click, res)
        self.widget.layout().addWidget(item)
        self._resource_labels[res] = item
        self._res_hash[res.hash] = res
        res.in_content = False
        self.update_label()

    def get_by_hash(self, hash):
        return self._res_hash.get(hash)

    def click(self, res, event):
        """Open resource"""
        button = event.button()
        if button == Qt.LeftButton:
            subprocess.Popen(['xdg-open', res.file_path])
        elif button == Qt.RightButton:
            menu = QMenu(self.parent)
            menu.addAction(
                self.app.translate('ResourceEdit', 'Put to Content'), Slot()(partial(
                    self.to_content, res=res,
                )),
            )
            if not self.parent.note_edit.in_content(res):
                menu.addAction(
                    self.app.translate('ResourceEdit', 'Remove Resource'), Slot()(partial(
                        self.remove, res=res,
                    ))
                )
            menu.addAction(
                self.app.translate('ResourceEdit', 'Save As'), Slot()(partial(
                    self.save, res=res,
                ))
            )
            menu.exec_(event.globalPos())

    def to_content(self, res):
        res.in_content = True
        self.parent.note_edit.paste_res(res)

    def remove(self, res):
        """Remove resource"""
        msg_box = QMessageBox(
            QMessageBox.Critical,
            self.app.translate("ResourceEdit", "Delete Resource"),
            self.app.translate("ResourceEdit", "Are you sure want to delete this resource?"),
            QMessageBox.Yes | QMessageBox.No
        )
        ret = msg_box.exec_()
        if ret == QMessageBox.Yes:
            self._resources.remove(res)
            self._resource_labels[res].hide()
            del self._resource_labels[res]
            self.on_change()
            if not self._resources:
                self.widget.hide()
            self.update_label()

    def save(self, res):
        """Save resource"""
        name, filters = QFileDialog.getSaveFileName()
        if name:
            shutil.copyfile(res.file_path, name)

    @Slot()
    def add(self):
        for name in QFileDialog.getOpenFileNames()[0]:
            self.add_attach(name)

    def add_attach(self, name):
        """Add name as an attachment and return the attachment as a Resource
        
        name - a string containing a filename or url that will be attached

        return: the resource object corresponding to the attached object
        """
        dest = os.path.expanduser('~/.everpad/data/%d/' % self.note.id)
        try:
            os.mkdir(dest)
        except OSError:
            pass
        file_name = name.split('/')[-1]
        file_path = prepare_file_path(dest, file_name)
        if os.path.isfile(name):
            shutil.copyfile(name, file_path)
        else:
            with open(file_path, 'w') as res_file:
                res_file.write(urllib.urlopen(name).read())
        res = Resource(
            id=NONE_ID,
            file_path=file_path,
            file_name=file_name,
            mime=self.mime.file(file_path.encode('utf8')),
            hash=hashlib.md5(open(file_path).read()).hexdigest(),
        )
        self._resources.append(res)
        self._put(res)
        self.on_change()
        return res

    def add_all_attach(self, names):
        """Adds all the entries in names as attachments
        
        names - sequence of strings - each string is treated as a filename or url

        No return value
        """
        assert not hasattr(names, "strip"); # Ensure that didn't get
                                            # passed a single string
        for name in names:
            self.add_attach(name);

########NEW FILE########
__FILENAME__ = widgets
from PySide.QtGui import QCompleter, QStringListModel, QApplication
from PySide.QtCore import Slot
from everpad.basetypes import Tag, Notebook
import re


class TagEdit(object):
    """Abstraction for tag edit"""

    def __init__(self, parent, widget, on_change):
        """Init and connect signals"""
        self.parent = parent
        self.app = QApplication.instance()
        self.widget = widget
        self.tags_list = map(lambda tag:
            Tag.from_tuple(tag).name,
            self.app.provider.list_tags(),
        )
        self.completer = QCompleter()
        self.completer_model = QStringListModel()
        self.completer.setModel(self.completer_model)
        self.completer.activated.connect(self.update_completion)
        self.update_completion()
        self.widget.setCompleter(self.completer)
        self.widget.textChanged.connect(Slot()(on_change))
        self.widget.textEdited.connect(self.update_completion)

    @property
    def tags(self):
        """Get tags"""
        # Split on comma and Arabic comma
        # 0x060c is the Arabic comma
        return map(lambda tag: tag.strip(),
            re.split(u',|\u060c', self.widget.text()))

    @tags.setter
    def tags(self, val):
        """Set tags"""
        self.widget.setText(', '.join(val))

    @Slot()
    def update_completion(self):
        """Update completion model with exist tags"""
        orig_text = self.widget.text()
        text = ', '.join(orig_text.replace(', ', ',').split(',')[:-1])
        tags = []
        for tag in self.tags_list:
            if ',' in orig_text:
                if orig_text[-1] not in (',', ' '):
                    tags.append('%s,%s' % (text, tag))
                tags.append('%s, %s' % (text, tag))
            else:
                tags.append(tag)
        if tags != self.completer_model.stringList():
            self.completer_model.setStringList(tags)


class NotebookEdit(object):
    """Abstraction for notebook edit"""

    def __init__(self, parent, widget, on_change):
        """Init and connect signals"""
        self.parent = parent
        self.app = QApplication.instance()
        self.widget = widget
        for notebook_struct in self.app.provider.list_notebooks():
            notebook = Notebook.from_tuple(notebook_struct)
            self.widget.addItem(notebook.name, userData=notebook.id)
        self.widget.currentIndexChanged.connect(Slot()(on_change))

    @property
    def notebook(self):
        """Get notebook"""
        notebook_index = self.widget.currentIndex()
        return self.widget.itemData(notebook_index)

    @notebook.setter
    def notebook(self, val):
        """Set notebook"""
        notebook_index = self.widget.findData(val)
        self.widget.setCurrentIndex(notebook_index)

########NEW FILE########
__FILENAME__ = indicator
import sys
sys.path.insert(0, '../..')
from PySide.QtCore import Slot, QTranslator, QLocale, Signal, QSettings, QT_TRANSLATE_NOOP, QLibraryInfo
from PySide.QtGui import QApplication, QSystemTrayIcon, QMenu, QCursor
from PySide.QtNetwork import QNetworkProxyFactory
from everpad.basetypes import Note, NONE_ID, NONE_VAL, Notebook
from everpad.tools import get_provider, get_pad, print_version, resource_filename
from everpad.pad.editor import Editor
from everpad.pad.management import Management
from everpad.pad.list import List
from everpad.const import (
    STATUS_SYNC, SYNC_STATES, SYNC_STATE_START,
    SYNC_STATE_FINISH, API_VERSION,
    DEFAULT_INDICATOR_LAYOUT,
)
from everpad.specific import get_launcher, get_tray_icon
from functools import partial
from datetime import datetime
import signal
import dbus
import dbus.service
import dbus.mainloop.glib
import argparse
import fcntl
import os
import logging
import getpass


class Indicator(QSystemTrayIcon):
    def __init__(self, *args, **kwargs):
        QSystemTrayIcon.__init__(self, *args, **kwargs)
        self.app = QApplication.instance()
        self.menu = QMenu()
        self.setContextMenu(self.menu)
        self.menu.aboutToShow.connect(self.update)
        self.opened_notes = {}
        self.activated.connect(self._activated)
        self.settings = QSettings('everpad', 'everpad-pad')
        # Configure logger.
        self.logger = logging.getLogger('everpad-indicator')
        self.logger.setLevel(logging.DEBUG)
        fh = logging.FileHandler(
            os.path.expanduser('~/.everpad/logs/everpad.log'))
        fh.setLevel(logging.DEBUG)
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        fh.setFormatter(formatter)
        self.logger.addHandler(fh)

    def _activated(self, reason):
        if reason == QSystemTrayIcon.Trigger:
            self.menu.popup(QCursor().pos())

    def _add_note(self, menu, struct):
        note = Note.from_tuple(struct)
        title = note.title[:40].replace('&', '&&')
        menu.addAction(title, Slot()(
            partial(self.open, note=note)
        ))

    @Slot()
    def update(self):
        self.menu.clear()
        try:
            version = self.app.provider.get_api_version()
        except (  # dbus raise some magic
            dbus.exceptions.UnknownMethodException,
            dbus.exceptions.DBusException,
        ):
            version = -1
        if version != API_VERSION:
            action = self.menu.addAction(
                self.tr('API version missmatch, please restart'),
            )
            action.setEnabled(False)
            if version < API_VERSION:
                handler = self.app.provider.kill
            else:
                handler = partial(os.execlp, 'everpad', '--replace')
            self.menu.addAction(
                self.tr('Restart everpad'), handler,
            )
            return
        if self.app.provider.is_authenticated():
            pin_notes = self.app.provider.find_notes(
                '', dbus.Array([], signature='i'),
                dbus.Array([], signature='i'), 0,
                20, Note.ORDER_UPDATED_DESC, 1,
            )
            sort_by_notebook = bool(int(
                self.app.provider.get_settings_value('sort-by-notebook') or 0))
            has_notes = False
            if not sort_by_notebook:
                notes = self.app.provider.find_notes(
                    '', dbus.Array([], signature='i'),
                    dbus.Array([], signature='i'), 0,
                    20 - len(pin_notes), Note.ORDER_UPDATED_DESC, 0,
                )
                has_notes = bool(notes)
            else:
                notebooks = self.app.provider.list_notebooks()
                notes = {}
                for notebook_struct in notebooks:
                    notebook = Notebook.from_tuple(notebook_struct)
                    _notes = self.app.provider.find_notes('', [notebook.id],
                         dbus.Array([], signature='i'), 0,
                         20 - len(pin_notes), Note.ORDER_UPDATED_DESC, 0,
                    )
                    notes[notebook] = _notes
                    if _notes:
                        has_notes = True
            first_sync = not (
                has_notes or len(pin_notes) or self.app.provider.is_first_synced()
            )
            status_syncing = self.app.provider.get_status() == STATUS_SYNC
            if status_syncing and first_sync:
                sync_label = self.tr('Wait, first sync in progress')
            elif status_syncing and not first_sync:
                sync_label = self.tr('Sync in progress')
            elif not status_syncing and first_sync:
                sync_label = self.tr('Please perform first sync')
            else:
                last_sync = self.app.provider.get_last_sync()
                delta_sync = (
                    datetime.now() - datetime.strptime(last_sync, '%H:%M')
                ).seconds // 60
                if delta_sync == 0:
                    sync_label = self.tr('Last Sync: Just now')
                elif delta_sync == 1:
                    sync_label = self.tr('Last Sync: %s min ago') % delta_sync
                else:
                    sync_label = self.tr('Last Sync: %s mins ago') % delta_sync
            menu_items = {
                'create_note': [self.tr('Create Note'), self.create],
                'all_notes': [self.tr('All Notes'), self.show_all_notes],
                'sync': [sync_label, Slot()(self.app.provider.sync)],
                'pin_notes': pin_notes,
                'notes': notes,
            }
            for item in self.app.settings.value('menu-order', DEFAULT_INDICATOR_LAYOUT):
                if item == 'pin_notes' or item == 'notes':
                    if not first_sync and len(menu_items[item]):
                        self.menu.addSeparator()
                        if item == 'notes' and sort_by_notebook:
                            for notebook in menu_items[item]:
                                sub_menu = self.menu.addMenu(notebook.name)
                                _notes = menu_items[item][notebook]
                                for struct in _notes:
                                    self._add_note(sub_menu, struct)
                        else:
                            for struct in menu_items[item]:
                                self._add_note(self.menu, struct)
                        self.menu.addSeparator()
                else:
                    action = self.menu.addAction(menu_items[item][0], menu_items[item][1])
                    if status_syncing and item == 'sync':
                        action.setEnabled(False)
        self.menu.addSeparator()
        self.menu.addAction(self.tr('Settings and Management'), self.show_management)
        self.menu.addAction(self.tr('Exit'), self.exit)

    def open(self, note, search_term=''):
        self.logger.debug('Opening note: "%s".' % note.title)
        old_note_window = self.opened_notes.get(note.id, None)
        if old_note_window and not getattr(old_note_window, 'closed', True):
            editor = self.opened_notes[note.id]
            # hide and show for bringing to front
            editor.hide()
            editor.show()
        else:
            editor = Editor(note)
            editor.show()
            self.opened_notes[note.id] = editor
        if search_term:
            editor.findbar.set_search_term(search_term)
            editor.findbar.show()
        editor.raise_()
        editor.activateWindow()
        return editor

    @Slot()
    def create(self, attach=None, notebook_id=NONE_ID):
        self.logger.debug('Creating new note.')
        note_struct = Note(  # maybe replace NONE's to somthing better
            id=NONE_ID,
            title=self.tr('New note'),
            content=self.tr("New note content"),
            tags=dbus.Array([], signature='i'),
            notebook=notebook_id,
            created=NONE_VAL,
            updated=NONE_VAL,
            conflict_parent=NONE_VAL,
            conflict_items=dbus.Array([], signature='i'),
            place='',
            share_date=NONE_VAL,
            share_url='',
        ).struct
        note = Note.from_tuple(
            self.app.provider.create_note(note_struct),
        )
        editor = self.open(note)
        if attach:
            editor.resource_edit.add_all_attach(attach)

    @Slot()
    def show_all_notes(self):
        if not hasattr(self, 'list') or getattr(self.list, 'closed', True):
            self.list = List()
            self.list.show()
        else:
            self.list.activateWindow()

    @Slot()
    def show_management(self):
        if not hasattr(self, 'management') or getattr(self.management, 'closed', True):
            self.management = Management()
            self.management.show()
        else:
            self.management.activateWindow()

    @Slot()
    def exit(self):
        self.app.quit()


class PadApp(QApplication):
    data_changed = Signal()

    def __init__(self, *args, **kwargs):
        QApplication.__init__(self, *args, **kwargs)
        self.settings = QSettings('everpad', 'everpad-pad')
        locale = QLocale.system().name()
        self.qtTranslator = QTranslator()
        self.qtTranslator.load("qt_" + locale, QLibraryInfo.location(QLibraryInfo.TranslationsPath))
        self.installTranslator(self.qtTranslator)
        self.appTranslator = QTranslator()
        if not self.appTranslator.load(locale, os.path.join(os.path.dirname(__file__), '../../i18n')):
            self.appTranslator.load(locale, resource_filename('share/everpad/i18n'))
        # This application string can be localized to 'RTL' to switch the application layout
        # direction. See for example i18n/ar_EG.ts
        QT_TRANSLATE_NOOP('QApplication', 'QT_LAYOUT_DIRECTION')
        self.installTranslator(self.appTranslator)
        QNetworkProxyFactory.setUseSystemConfiguration(True)
        self.indicator = Indicator()
        self.update_icon()
        self.indicator.show()

    def update_icon(self):
        is_black = int(self.settings.value('black-icon', 0))
        self.icon = get_tray_icon(is_black)
        self.indicator.setIcon(self.icon)

    def send_notify(self, text):
        self.indicator.showMessage('Everpad', text,
            QSystemTrayIcon.Information)

    def on_sync_state_changed(self, state):
        if int(self.settings.value('launcher-progress', 1)):
            self.launcher.update({
                'progress': float(state + 1) / len(SYNC_STATES),
                'progress-visible': state not in (SYNC_STATE_START, SYNC_STATE_FINISH),
            })

    def on_data_changed(self):
        """Note, notebook or tag changed"""
        self.data_changed.emit()


class EverpadService(dbus.service.Object):
    def __init__(self, *args, **kwargs):
        self.app = QApplication.instance()
        dbus.service.Object.__init__(self, *args, **kwargs)

    @dbus.service.method("com.everpad.App", in_signature='i', out_signature='')
    def open(self, id):
        self.open_with_search_term(id, '')

    @dbus.service.method("com.everpad.App", in_signature='is', out_signature='')
    def open_with_search_term(self, id, search_term):
        note = Note.from_tuple(self.app.provider.get_note(id))
        self.app.indicator.open(note, search_term)

    @dbus.service.method("com.everpad.App", in_signature='', out_signature='')
    def create(self):
        self.app.indicator.create()

    @dbus.service.method("com.everpad.App", in_signature='as', out_signature='')
    def create_wit_attach(self, names):
        self.app.indicator.create(names)

    @dbus.service.method("com.everpad.App", in_signature='', out_signature='')
    def settings(self):
        self.app.indicator.show_management()

    @dbus.service.method("com.everpad.App", in_signature='', out_signature='')
    def all_notes(self):
        self.app.indicator.show_all_notes()

    @dbus.service.method("com.everpad.App", in_signature='', out_signature='')
    def kill(self):
        self.app.quit()


def main():
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    parser = argparse.ArgumentParser()
    parser.add_argument('attachments', type=str, nargs='*', help='attach files to new note')
    parser.add_argument('--open', type=int, help='open note')
    parser.add_argument('--create', action='store_true', help='create new note')
    parser.add_argument('--all-notes', action='store_true', help='show all notes window')
    parser.add_argument('--settings', action='store_true', help='settings and management')
    parser.add_argument('--replace', action='store_true', help='replace already running instance')
    parser.add_argument('--version', '-v', action='store_true', help='show version')
    args = parser.parse_args(sys.argv[1:])
    if args.version:
        print_version()
    if args.replace:
        try:
            pad = get_pad()
            pad.kill()
        except dbus.exceptions.DBusException:
            pass
    fp = open('/tmp/everpad-%s.lock' % getpass.getuser(), 'w')
    try:
        fcntl.lockf(fp, fcntl.LOCK_EX | fcntl.LOCK_NB)
        app = PadApp(sys.argv)
        app.setApplicationName('everpad')
        dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
        session_bus = dbus.SessionBus()
        app.provider = get_provider(session_bus)
        app.provider.connect_to_signal(
            'sync_state_changed',
            app.on_sync_state_changed,
            dbus_interface="com.everpad.provider",
        )
        app.provider.connect_to_signal(
            'data_changed',
            app.on_data_changed,
            dbus_interface="com.everpad.provider",
        )
        app.launcher = get_launcher('application://everpad.desktop', session_bus, '/')
        bus = dbus.service.BusName("com.everpad.App", session_bus)
        service = EverpadService(session_bus, '/EverpadService')
        if args.open:
            app.indicator.open(args.open)
        if args.create:
            app.indicator.create()
        if args.settings:
            app.indicator.show_management()
        if args.attachments:
            app.indicator.create(args.attachments)
        if args.all_notes:
            app.indicator.show_all_notes()
        app.exec_()
    except IOError:
        pad = get_pad()
        if args.open:
            pad.open(args.open)
        if args.create:
            pad.create()
        if args.settings:
            pad.settings()
        if args.attachments:
            pad.create_wit_attach(args.attachments)
        if args.all_notes or len(sys.argv) <= 1:
            pad.all_notes()
        sys.exit(0)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = list
# -*- coding:utf-8 -*-
import sys
sys.path.append('../..')
from PySide.QtGui import (
    QMainWindow, QIcon, QApplication,
    QMessageBox, QMenu, QInputDialog,
    QStandardItemModel, QStandardItem,
    QItemSelection, QKeySequence, QShortcut,
)
from PySide.QtCore import Slot, Qt, QPoint
from everpad.interface.list import Ui_List
from everpad.pad.tools import get_icon
from everpad.basetypes import Notebook, Note, Tag, NONE_ID
import dbus
import datetime


SELECT_NONE = -1


class List(QMainWindow):
    """All Notes dialog"""

    def __init__(self, *args, **kwargs):
        QMainWindow.__init__(self, *args, **kwargs)
        self.app = QApplication.instance()
        self.closed = False
        self.sort_order = None
        self._init_interface()
        self.app.data_changed.connect(self._reload_data)
        self._init_notebooks()
        self._init_tags()
        self._init_notes()

    def _init_interface(self):
        self.ui = Ui_List()
        self.ui.setupUi(self)
        self.setWindowIcon(get_icon())
        self.setWindowTitle(self.tr("Everpad / All Notes"))
        self.ui.newNotebookBtn.setIcon(QIcon.fromTheme('folder-new'))
        self.ui.newNotebookBtn.clicked.connect(self.new_notebook)

        self.ui.newNoteBtn.setIcon(QIcon.fromTheme('document-new'))
        self.ui.newNoteBtn.clicked.connect(self.new_note)

        self.ui.newNoteBtn.setShortcut(QKeySequence(self.tr('Ctrl+n')))
        self.ui.newNotebookBtn.setShortcut(QKeySequence(self.tr('Ctrl+Shift+n')))
        QShortcut(QKeySequence(self.tr('Ctrl+q')), self, self.close)

    def _init_notebooks(self):
        self._current_notebook = None
        self.notebooksModel = QStandardItemModel()
        self.ui.notebooksList.setModel(self.notebooksModel)
        self.ui.notebooksList.selection.connect(self.selection_changed)
        self.ui.notebooksList.setContextMenuPolicy(Qt.CustomContextMenu)
        self.ui.notebooksList.customContextMenuRequested.connect(self.notebook_context_menu)

    def _init_tags(self):
        self._current_tag = None
        self.tagsModel = QStandardItemModel()
        self.ui.tagsList.setModel(self.tagsModel)
        self.ui.tagsList.selection.connect(self.tag_selection_changed)
        self.ui.tagsList.setContextMenuPolicy(Qt.CustomContextMenu)
        self.ui.tagsList.customContextMenuRequested.connect(self.tag_context_menu)

    def _init_notes(self):
        self._current_note = None
        self.notesModel = QStandardItemModel()
        self.notesModel.setHorizontalHeaderLabels(
            [self.tr('Title'), self.tr('Last Updated')])

        self.ui.notesList.setModel(self.notesModel)
        self.ui.notesList.selection.connect(self.note_selection_changed)
        self.ui.notesList.doubleClicked.connect(self.note_dblclicked)
        self.ui.notesList.setContextMenuPolicy(Qt.CustomContextMenu)
        self.ui.notesList.customContextMenuRequested.connect(self.note_context_menu)
        self.ui.notesList.header().sortIndicatorChanged.connect(self.sort_order_updated)

    @Slot(QItemSelection, QItemSelection)
    def selection_changed(self, selected, deselected):
        if len(selected.indexes()):
            self.ui.tagsList.clearSelection()
            self.notebook_selected(selected.indexes()[-1])

    @Slot(QItemSelection, QItemSelection)
    def tag_selection_changed(self, selected, deselected):
        if len(selected.indexes()):
            self.ui.notebooksList.clearSelection()
            self.tag_selected(selected.indexes()[-1])

    @Slot(QItemSelection, QItemSelection)
    def note_selection_changed(self, selected, deselected):
        if len(selected.indexes()):
            self.note_selected(selected.indexes()[-1])

    def showEvent(self, *args, **kwargs):
        super(List, self).showEvent(*args, **kwargs)
        self._reload_data()
        self.readSettings()

    def writeSettings(self):
        self.app.settings.setValue('list-geometry', self.saveGeometry())
        for key, widget in self._getRestorableItems():
            self.app.settings.setValue(key, widget.saveState())

    def _getRestorableItems(self):
        return (
            ('list-splitter-state', self.ui.splitter),
            ('list-header-state', self.ui.notesList.header()),
        )

    def readSettings(self):
        geometry = self.app.settings.value('list-geometry')
        if geometry:
            self.restoreGeometry(geometry)

        for key, widget in self._getRestorableItems():
            state = self.app.settings.value(key)
            if state:
                widget.restoreState(state)

    def closeEvent(self, event):
        self.writeSettings()
        event.ignore()
        self.closed = True
        self.hide()

    @Slot(int, Qt.SortOrder)
    def sort_order_updated(self, logicalIndex, order):
        self.sort_order = (logicalIndex, order.name)
        self.app.settings.setValue('list-notes-sort-order', self.sort_order)

    def note_selected(self, index):
        self._current_note = index

    def notebook_selected(self, index):
        self.notesModel.setRowCount(0)

        item = self.notebooksModel.itemFromIndex(index)
        if hasattr(item, 'notebook'):
            notebook_id = item.notebook.id
        else:
            notebook_id = 0

        self._current_notebook = notebook_id
        self._current_tag = SELECT_NONE

        notebook_filter = [notebook_id] if notebook_id > 0 else dbus.Array([], signature='i')

        if hasattr(item, 'stack'):  # stack selected, retrieve all underlying notebooks
            notebook_filter = []
            for notebook_struct in self.app.provider.list_notebooks():
                notebook = Notebook.from_tuple(notebook_struct)
                if(notebook.stack == item.stack):
                    notebook_filter.append(notebook.id)

        notes = self.app.provider.find_notes(
            '', notebook_filter, dbus.Array([], signature='i'),
            0, 2 ** 31 - 1, Note.ORDER_TITLE, -1,
        )  # fails with sys.maxint in 64

        for note_struct in notes:
            note = Note.from_tuple(note_struct)
            self.notesModel.appendRow(QNoteItemFactory(note).make_items())

        sort_order = self.sort_order
        if sort_order is None:
            sort_order = self.app.settings.value('list-notes-sort-order')

        if sort_order:
            logicalIndex, order = sort_order
            order = Qt.SortOrder.values[order]
            self.ui.notesList.sortByColumn(int(logicalIndex), order)

    def tag_selected(self, index):
        self.notesModel.setRowCount(0)

        item = self.tagsModel.itemFromIndex(index)
        if hasattr(item, 'tag'):
            tag_id = item.tag.id
        else:
            tag_id = 0

        self._current_notebook = SELECT_NONE
        self._current_tag = tag_id

        tag_filter = [tag_id] if tag_id > 0 else dbus.Array([], signature='i')
        notes = self.app.provider.find_notes(
            '', dbus.Array([], signature='i'), tag_filter,
            0, 2 ** 31 - 1, Note.ORDER_TITLE, -1,
        )  # fails with sys.maxint in 64
        for note_struct in notes:
            note = Note.from_tuple(note_struct)
            self.notesModel.appendRow(QNoteItemFactory(note).make_items())

        sort_order = self.sort_order
        if sort_order is None:
            sort_order = self.app.settings.value('list-notes-sort-order')

        if sort_order:
            logicalIndex, order = sort_order
            order = Qt.SortOrder.values[order]
            self.ui.notesList.sortByColumn(int(logicalIndex), order)

    @Slot()
    def note_dblclicked(self, index):
        item = self.notesModel.itemFromIndex(index)
        self.app.indicator.open(item.note)

    @Slot()
    def new_notebook(self, oldStack=''):
        name, status, stack = self._notebook_new_name(self.tr('Create new notebook'), '', oldStack)
        if status:
            notebook_struct = self.app.provider.create_notebook(name, stack)
            notebook = Notebook.from_tuple(notebook_struct)

            self.app.send_notify(self.tr('Notebook "%s" created!') % notebook.name)
            self._reload_notebooks_list(notebook.id)

    @Slot()
    def rename_notebook(self):
        index = self.ui.notebooksList.currentIndex()
        item = self.notebooksModel.itemFromIndex(index)
        notebook = item.notebook
        name, status, stack = self._notebook_new_name(
            self.tr('Rename notebook'), notebook.name, notebook.stack
        )
        if status:
            notebook.name = name
            notebook.stack = stack
            self.app.provider.update_notebook(notebook.struct)
            self.app.send_notify(self.tr('Notebook "%s" renamed!') % notebook.name)
            self._reload_notebooks_list(notebook.id)

    @Slot()
    def remove_notebook(self):
        msg = QMessageBox(
            QMessageBox.Critical,
            self.tr("You are trying to delete a notebook"),
            self.tr("Are you sure want to delete this notebook and its notes?"),
            QMessageBox.Yes | QMessageBox.No
        )
        if msg.exec_() == QMessageBox.Yes:
            index = self.ui.notebooksList.currentIndex()
            item = self.notebooksModel.itemFromIndex(index)
            self.app.provider.delete_notebook(item.notebook.id)
            self.app.send_notify(self.tr('Notebook "%s" deleted!') % item.notebook.name)
            self._reload_notebooks_list()

    @Slot()
    def rename_stack(self):
        index = self.ui.notebooksList.currentIndex()
        item = self.notebooksModel.itemFromIndex(index)
        stack = item.stack
        name, status = self._stack_new_name(
            self.tr('Rename stack'), stack,
        )
        if status:
            # loop notebooks and update stack str
            for notebook_struct in self.app.provider.list_notebooks():
                notebook = Notebook.from_tuple(notebook_struct)
                if(notebook.stack == item.stack):
                    notebook.stack = name
                    self.app.provider.update_notebook(notebook.struct)

            self.app.send_notify(self.tr('Stack "%s" renamed!') % name)
            self._reload_notebooks_list(notebook.id)

    @Slot()
    def remove_stack(self):
        msg = QMessageBox(
            QMessageBox.Critical,
            self.tr("You are trying to delete a stack"),
            self.tr("Are you sure want to delete this stack? Notebooks and notes are preserved."),
            QMessageBox.Yes | QMessageBox.No
        )
        if msg.exec_() == QMessageBox.Yes:
            index = self.ui.notebooksList.currentIndex()
            item = self.notebooksModel.itemFromIndex(index)
            # loop notebooks and remove stack str
            for notebook_struct in self.app.provider.list_notebooks():
                notebook = Notebook.from_tuple(notebook_struct)
                if(notebook.stack == item.stack):
                    print "Clearing one notebook from its stack."
                    notebook.stack = ''
                    self.app.provider.update_notebook(notebook.struct)

            self._reload_notebooks_list()

    @Slot()
    def remove_tag(self):
        msg = QMessageBox(
            QMessageBox.Critical,
            self.tr("You are trying to delete a tag"),
            self.tr("Are you sure want to delete this tag and untag all notes tagged with it?"),
            QMessageBox.Yes | QMessageBox.No
        )
        if msg.exec_() == QMessageBox.Yes:
            index = self.ui.tagsList.currentIndex()
            item = self.tagsModel.itemFromIndex(index)
            self.app.provider.delete_tag(item.tag.id)
            self.app.send_notify(self.tr('Tag "%s" deleted!') % item.tag.name)
            self._reload_tags_list()

    @Slot()
    def new_note(self):
        index = self.ui.notebooksList.currentIndex()
        notebook_id = NONE_ID
        if index.row():
            item = self.notebooksModel.itemFromIndex(index)
            notebook_id = item.notebook.id

        self.app.indicator.create(notebook_id=notebook_id)

    @Slot()
    def edit_note(self):
        index = self.ui.notesList.currentIndex()
        item = self.notesModel.itemFromIndex(index)
        self.app.indicator.open(item.note)

    @Slot()
    def remove_note(self):
        index = self.ui.notesList.currentIndex()
        item = self.notesModel.itemFromIndex(index)
        msgBox = QMessageBox(
            QMessageBox.Critical,
            self.tr("You are trying to delete a note"),
            self.tr('Are you sure want to delete note "%s"?') % item.note.title,
            QMessageBox.Yes | QMessageBox.No
        )
        if msgBox.exec_() == QMessageBox.Yes:
            self.app.provider.delete_note(item.note.id)
            self.app.send_notify(self.tr('Note "%s" deleted!') % item.note.title)
            self.notebook_selected(self.ui.notebooksList.currentIndex())

    @Slot(QPoint)
    def notebook_context_menu(self, pos):
        index = self.ui.notebooksList.currentIndex()
        item = self.notebooksModel.itemFromIndex(index)
        if hasattr(item, 'notebook'):
            menu = QMenu(self.ui.notebooksList)
            menu.addAction(QIcon.fromTheme('gtk-edit'), self.tr('Rename'), self.rename_notebook)
            menu.addAction(QIcon.fromTheme('gtk-delete'), self.tr('Remove'), self.remove_notebook)
            menu.exec_(self.ui.notebooksList.mapToGlobal(pos))
        if hasattr(item, 'stack'):
            menu = QMenu(self.ui.notebooksList)
            menu.addAction(QIcon.fromTheme('gtk-edit'), self.tr('Rename'), self.rename_stack)
            menu.addAction(QIcon.fromTheme('gtk-delete'), self.tr('Remove'), self.remove_stack)
            menu.exec_(self.ui.notebooksList.mapToGlobal(pos))

    @Slot(QPoint)
    def tag_context_menu(self, pos):
        index = self.ui.tagsList.currentIndex()
        item = self.tagsModel.itemFromIndex(index)
        if hasattr(item, 'tag'):
            menu = QMenu(self.ui.tagsList)
            menu.addAction(QIcon.fromTheme('gtk-delete'), self.tr('Remove'), self.remove_tag)
            menu.exec_(self.ui.tagsList.mapToGlobal(pos))

    @Slot(QPoint)
    def note_context_menu(self, pos):
        menu = QMenu(self.ui.notesList)
        menu.addAction(QIcon.fromTheme('gtk-edit'), self.tr('Edit'), self.edit_note)
        menu.addAction(QIcon.fromTheme('gtk-delete'), self.tr('Remove'), self.remove_note)
        menu.exec_(self.ui.notesList.mapToGlobal(pos))

    def _reload_data(self):
        self._reload_notebooks_list(self._current_notebook)
        self._reload_tags_list(self._current_tag)
        self._mark_note_selected(self._current_note)

    def _reload_notebooks_list(self, select_notebook_id=None):
        # TODO could enable selecting an already selected stack
        self.notebooksModel.clear()
        root = QStandardItem(QIcon.fromTheme('user-home'), self.tr('All Notes'))
        self.notebooksModel.appendRow(root)
        selected_item = root

        stacks = {}
        for notebook_struct in self.app.provider.list_notebooks():
            notebook = Notebook.from_tuple(notebook_struct)
            count = self.app.provider.get_notebook_notes_count(notebook.id)
            item = QNotebookItem(notebook, count)

            if(notebook.stack == ''):
                root.appendRow(item)
            else:
                if(notebook.stack not in stacks.keys()):
                    stack = QStandardItem(QIcon.fromTheme('user-home'), notebook.stack)
                    stack.stack = notebook.stack
                    root.appendRow(stack)
                    stacks[notebook.stack] = stack

                stacks[notebook.stack].appendRow(item)

            if select_notebook_id and notebook.id == select_notebook_id:
                selected_item = item

        self.ui.notebooksList.expandAll()

        if selected_item and not select_notebook_id == SELECT_NONE:
            index = self.notebooksModel.indexFromItem(selected_item)
            self.ui.notebooksList.setCurrentIndex(index)
            self.notebook_selected(index)

    def _notebook_new_name(self, title, exclude='', oldStack=''):
        names = map(lambda nb: Notebook.from_tuple(nb).name, self.app.provider.list_notebooks())
        try:
            names.remove(exclude)
        except ValueError:
            pass
        name, status = QInputDialog.getText(self, title, self.tr('Enter notebook name:'), text=exclude)
        while name in names and status:
            message = self.tr('Notebook with this name already exist. Enter notebook name')
            name, status = QInputDialog.getText(self, title, message)
        if status:
            stack, status = QInputDialog.getText(self, title, self.tr('Enter stack name (empty for no stack):'), text=oldStack)
        else:
            stack = oldStack
        return name, status, stack

    def _stack_new_name(self, title, value=''):
        name, status = QInputDialog.getText(self, title, self.tr('Enter stack name:'), text=value)
        return name, status

    def _reload_tags_list(self, select_tag_id=None):
        # TODO nested tags
        self.tagsModel.clear()
        tagRoot = QStandardItem(QIcon.fromTheme('user-home'), self.tr('All Tags'))
        self.tagsModel.appendRow(tagRoot)
        selected_item = tagRoot

        for tag_struct in self.app.provider.list_tags():
            tag = Tag.from_tuple(tag_struct)
            count = self.app.provider.get_tag_notes_count(tag.id)
            item = QTagItem(tag, count)
            tagRoot.appendRow(item)

            if select_tag_id and tag.id == select_tag_id:
                selected_item = item

        self.ui.tagsList.expandAll()
        if selected_item and not select_tag_id == SELECT_NONE:
            index = self.tagsModel.indexFromItem(selected_item)
            self.ui.tagsList.setCurrentIndex(index)
            self.tag_selected(index)

    def _mark_note_selected(self, index):
        if index:
            self.ui.notesList.setCurrentIndex(index)


class QNotebookItem(QStandardItem):
    def __init__(self, notebook, count):
        super(QNotebookItem, self).__init__(QIcon.fromTheme('folder'), '%s (%d)' % (notebook.name, count))
        self.notebook = notebook


class QTagItem(QStandardItem):
    def __init__(self, tag, count):
        super(QTagItem, self).__init__(QIcon.fromTheme('folder'), '%s (%d)' % (tag.name, count))
        self.tag = tag


class QNoteItemFactory(object):
    def __init__(self, note):
        self.note = note

    def make_items(self):
        items = [QStandardItem(unicode(self.note.title)),
                 QStandardItem(unicode(datetime.datetime.fromtimestamp(
                     self.note.updated / 1000.0)))]
        for item in items:
            item.note = self.note
        items[0].setIcon(QIcon.fromTheme('x-office-document'))
        items[1].setEditable(False)

        return items

########NEW FILE########
__FILENAME__ = management
import sys
sys.path.append('../..')
from PySide.QtGui import QDialog, QFont, QApplication, QMessageBox, QCursor, QListWidgetItem, QMenu
from PySide.QtWebKit import QWebPage
from PySide.QtCore import Slot, Qt
from PySide.QtNetwork import QNetworkAccessManager, QSslConfiguration, QSsl
from everpad.interface.management import Ui_Dialog
from everpad.pad.tools import get_icon
from everpad.const import (
    CONSUMER_KEY, CONSUMER_SECRET, HOST,
    DEFAULT_FONT, DEFAULT_FONT_SIZE,
    DEFAULT_INDICATOR_LAYOUT,
)
from everpad import monkey
from everpad.tools import get_proxy_config, resource_filename
import urllib
import urlparse
import oauth2 as oauth
import os
import shutil
from httplib2 import ProxyInfo
from httplib2.socks import PROXY_TYPE_HTTP


def get_oauth_proxy(scheme):
    proxy = get_proxy_config(scheme)
    if proxy is None:
        return None
    proxy = urlparse.urlparse(proxy)
    return ProxyInfo(
        proxy_type=PROXY_TYPE_HTTP,
        proxy_host=proxy.hostname,
        proxy_port=proxy.port,
        proxy_user=proxy.username or None,
        proxy_pass=proxy.password or None,
    )


class TLSNetworkAccessManager(QNetworkAccessManager):
    def createRequest(self, op, request, outgoingData=None):
        conf = QSslConfiguration()
        conf.setProtocol(QSsl.TlsV1)
        request.setSslConfiguration(conf)
        return QNetworkAccessManager.createRequest(self, op, request, outgoingData)


class AuthPage(QWebPage):
    def __init__(self, token, secret, parent, *args, **kwargs):
        QWebPage.__init__(self, *args, **kwargs)
        self.token = token
        self.secret = secret
        self.parent = parent
        manager = TLSNetworkAccessManager(self)
        manager.sslErrors.connect(self.ssl)
        self.setNetworkAccessManager(manager)

    def acceptNavigationRequest(self, frame, request, type):
        url = request.url()
        if 'everpad' in url.host():
            verifier = url.queryItemValue('oauth_verifier')
            token = oauth.Token(self.token, self.secret)
            token.set_verifier(verifier)
            consumer = oauth.Consumer(CONSUMER_KEY, CONSUMER_SECRET)
            client = oauth.Client(consumer, token,
                                  proxy_info=get_oauth_proxy('https'))
            resp, content = client.request('https://%s/oauth' % HOST, 'POST')
            access_token = dict(urlparse.parse_qsl(content))
            self.parent.auth_finished(access_token['oauth_token'])
        return True

    def ssl(self, reply, errors):
        reply.ignoreSslErrors()


class Management(QDialog):
    """Management dialog"""

    def __init__(self, *args, **kwargs):
        QDialog.__init__(self, *args, **kwargs)
        self.app = QApplication.instance()
        self.closed = False
        self.startup_path = os.path.expanduser('~/.config/autostart/')
        if not os.path.exists(self.startup_path):
            os.makedirs(self.startup_path)
        self.startup_file = os.path.join(self.startup_path, 'everpad.desktop')
        self.ui = Ui_Dialog()
        self.ui.setupUi(self)
        self.ui.webView.hide()
        self.setWindowIcon(get_icon())
        for delay in (5, 10, 15, 30):
            self.ui.syncDelayBox.addItem(self.tr('%d minutes') % delay,
                userData=str(delay * 60 * 1000),
            )
        self.ui.syncDelayBox.addItem(self.tr('One hour'), userData='3600000')
        self.ui.syncDelayBox.addItem(self.tr('Manual'), userData='-1')
        active_index = self.ui.syncDelayBox.findData(str(
            self.app.provider.get_sync_delay(),
        ))
        self.ui.syncDelayBox.setCurrentIndex(active_index)
        self.ui.syncDelayBox.currentIndexChanged.connect(self.delay_changed)
        self.ui.tabWidget.currentChanged.connect(self.update_tabs)
        self.ui.authBtn.clicked.connect(self.change_auth)
        self.ui.autoStart.stateChanged.connect(self.auto_start_state)
        self.ui.noteFont.currentFontChanged.connect(self.font_changed)
        self.ui.noteSize.valueChanged.connect(self.font_size_changed)
        self.ui.blackTray.stateChanged.connect(self.tray_changed)
        self.ui.progressCheckBox.stateChanged.connect(self.progress_changed)
        self.layout_list = self.ui.listWidget_indLayout
        self.layout_list.setContextMenuPolicy(Qt.CustomContextMenu)
        self.layout_list.customContextMenuRequested.connect(self.layout_list_contextMenu)
        layout_list_model = self.layout_list.model()
        layout_list_model.layoutChanged.connect(self.save_layout_list)
        self.layout_labels = {
            'create_note': self.tr('Create Note'),
            'pin_notes' : self.tr('Pinned Notes'),
            'all_notes' : self.tr('All Notes'),
            'notes'     : self.tr('Notes'),
            'sync'      : self.tr('Last Sync'),
            }
        self.load_layout_list(self.app.settings.value('menu-order', DEFAULT_INDICATOR_LAYOUT))
        self.ui.searchOnHome.stateChanged.connect(self.search_on_home_changed)
        self.ui.sortByNotebook.stateChanged.connect(self.sort_by_notebook_changed)
        self.ui.buttonBox.clicked.connect(self.close_clicked)
        self.update_tabs()

    def on_default_layout(self):
        self.load_layout_list(DEFAULT_INDICATOR_LAYOUT)
        self.save_layout_list()

    def load_layout_list(self, settings):
        self.layout_list.clear()
        for menu_item in settings:
            font = QFont()
            if menu_item == 'pin_notes' or menu_item == 'notes':
                font.setStyle(QFont.StyleItalic)
            else:
                font.setWeight(QFont.DemiBold)
            item = QListWidgetItem(self.layout_labels[menu_item])
            item.setData(Qt.UserRole, menu_item)
            item.setTextAlignment(Qt.AlignCenter)
            item.setFont(font)
            self.layout_list.addItem(item)

    def layout_list_contextMenu(self, pos):
        menu = QMenu()
        default_action = menu.addAction(self.tr("Reset Layout"))
        default_action.triggered.connect(self.on_default_layout)
        menu.exec_(QCursor.pos())

    def save_layout_list(self):
        all_items = self.layout_list.findItems('*', Qt.MatchWildcard)
        user_settings = []
        for item in all_items:
            user_settings.append(item.data(Qt.UserRole))
        self.app.settings.setValue('menu-order', user_settings)

    @Slot(str)
    def font_size_changed(self, size):
        self.app.settings.setValue('note-font-size', size)

    @Slot(QFont)
    def font_changed(self, font):
        self.app.settings.setValue('note-font-family', font.family())

    @Slot()
    def tray_changed(self):
        if self.ui.blackTray.checkState() == Qt.Unchecked:
            self.app.settings.setValue('black-icon', 0)
        else:
            self.app.settings.setValue('black-icon', 1)
        self.app.update_icon()

    @Slot()
    def progress_changed(self):
        if self.ui.progressCheckBox.checkState() == Qt.Unchecked:
            self.app.settings.setValue('launcher-progress', 0)
        else:
            self.app.settings.setValue('launcher-progress', 1)

    @Slot()
    def search_on_home_changed(self):
        if self.ui.searchOnHome.checkState() == Qt.Unchecked:
            value = '0'
        else:
            value = '1'
        self.app.provider.set_settings_value('search-on-home', value)

    @Slot()
    def sort_by_notebook_changed(self):
        value = ('0' if self.ui.sortByNotebook.checkState() == Qt.Unchecked 
                     else '1')
        self.app.provider.set_settings_value('sort-by-notebook', value)

    @Slot()
    def update_tabs(self):
        if self.app.provider.is_authenticated():
            self.ui.authBtn.setText(self.tr('Remove Authorisation'))
        else:
            self.ui.authBtn.setText(self.tr('Authorise'))
        self.ui.autoStart.setCheckState(Qt.Checked
            if os.path.isfile(self.startup_file)
        else Qt.Unchecked)
        self.ui.noteFont.setCurrentFont(QFont(self.app.settings.value(
            'note-font-family', DEFAULT_FONT,
        )))
        self.ui.noteSize.setValue(int(self.app.settings.value(
            'note-font-size', DEFAULT_FONT_SIZE,
        )))
        self.ui.blackTray.setCheckState(Qt.Checked
            if int(self.app.settings.value('black-icon', 0))
        else Qt.Unchecked)
        self.ui.progressCheckBox.setCheckState(Qt.Checked
            if int(self.app.settings.value('launcher-progress', 1))
        else Qt.Unchecked)
        self.ui.searchOnHome.setCheckState(Qt.Checked
            if int(self.app.provider.get_settings_value('search-on-home') or 1)
        else Qt.Unchecked)
        self.ui.sortByNotebook.setCheckState(Qt.Checked
            if int(self.app.provider.get_settings_value('sort-by-notebook') or 0)
        else Qt.Unchecked)

    @Slot()
    def auto_start_state(self):
        if self.ui.autoStart.checkState() == Qt.Unchecked:
            try:
                os.unlink(self.startup_file)
            except OSError:
                pass
        else:
            shutil.copyfile(
                resource_filename('share/applications/everpad.desktop'),
                self.startup_file,
            )

    @Slot(int)
    def delay_changed(self, index):
        self.app.provider.set_sync_delay(
            int(self.ui.syncDelayBox.itemData(index)),
        )

    @Slot()
    def change_auth(self):
        if self.app.provider.is_authenticated():
            msgBox = QMessageBox(
                QMessageBox.Critical,
                self.tr("You are trying to remove authorisation"),
                self.tr("""
                Are you sure want to remove authoristion?
                It remove all not synced changes!
                """.strip()),
                QMessageBox.Yes | QMessageBox.No
            )
            ret = msgBox.exec_()
            if ret == QMessageBox.Yes:
                self.app.provider.remove_authentication()
                self.update_tabs()
        else:
            self.ui.tabWidget.hide()
            self.ui.webView.show()
            consumer = oauth.Consumer(CONSUMER_KEY, CONSUMER_SECRET)
            client = oauth.Client(consumer, proxy_info=get_oauth_proxy('https'))
            resp, content = client.request(
                'https://%s/oauth?oauth_callback=' % HOST + urllib.quote('http://everpad/'),
            'GET')
            data = dict(urlparse.parse_qsl(content))
            url = 'http://%s/OAuth.action?oauth_token=' % HOST + urllib.quote(data['oauth_token'])
            page = AuthPage(
                data['oauth_token'], data['oauth_token_secret'], self,
            )
            self.ui.webView.setPage(page)
            page.mainFrame().load(url)

    @Slot()
    def close_clicked(self):
        self.close()

    def auth_finished(self, token):
        self.app.provider.authenticate(token)
        self.ui.webView.hide()
        self.ui.tabWidget.show()
        self.update_tabs()

    def closeEvent(self, event):
        event.ignore()
        self.closed = True
        self.hide()

########NEW FILE########
__FILENAME__ = share_note
import sys
sys.path.append('../..')
from PySide.QtGui import QDialog, QApplication
from everpad.basetypes import Note
from everpad.interface.share_note import Ui_ShareNote
from everpad.pad.tools import get_icon


class ShareNoteDialog(QDialog):
    """Share note dialog"""

    def __init__(self, note, *args, **kwargs):
        """init dialog and connect signals"""
        QDialog.__init__(self, *args, **kwargs)
        self.app = QApplication.instance()
        self.canceled = False
        self.ui = Ui_ShareNote()
        self.ui.setupUi(self)
        self.setWindowIcon(get_icon())
        self.note = Note.from_tuple(
            self.app.provider.get_note(note.id),
        )
        self.app.data_changed.connect(self.data_changed)
        self.ui.cancelButton.clicked.connect(self.cancel)
        self.ui.copyButton.clicked.connect(self.copy_url)
        if not self.note.share_url:
            self.start_sharing()
        self.update()

    def start_sharing(self):
        """Start sharing note"""
        self.app.provider.share_note(self.note.id)

    def copy_url(self):
        """Copy sharing url"""
        url = self.ui.shareLink.text()
        self.app.clipboard().setText(url)

    def cancel(self):
        """Cancel sharing note"""
        self.canceled = True
        self.app.provider.stop_sharing_note(self.note.id)
        self.update()

    def data_changed(self):
        """On data changed slot"""
        self.note = Note.from_tuple(
            self.app.provider.get_note(self.note.id),
        )
        self.update()

    def update(self):
        """Update dialog behavior"""
        self.update_title()
        if self.canceled:
            self.render_canceled()
        elif self.note.share_url:
            self.render_shared()
        else:
            self.render_wait()

    def update_title(self):
        """Update dialog title"""
        self.setWindowTitle(self.tr(
            'Everpad / sharing "%s"' % self.note.title,
        ))

    def render_shared(self):
        """Render for already shared note"""
        self.ui.waitText.hide()
        self.ui.sharedWidget.show()
        self.ui.shareLink.setText(self.note.share_url)

    def render_canceled(self):
        """Render for canceled sharing"""
        self.ui.waitText.show()
        self.ui.sharedWidget.hide()
        self.ui.waitText.setText(self.tr('Note sharing canceled'))

    def render_wait(self):
        """Render for wait sharing"""
        self.ui.waitText.show()
        self.ui.sharedWidget.hide()
        self.ui.waitText.setText(self.tr('Sharing in proccess...'))

########NEW FILE########
__FILENAME__ = tools
from PySide.QtGui import QIcon
import os
import sys
from everpad.tools import resource_filename


def get_icon():
    return QIcon.fromTheme('everpad', QIcon('../../everpad.png'))


def get_file_icon_path():
    """
    Get path of icon for file
    foe embedding in html.
    """
    paths = (
        os.path.join(
            os.path.dirname(__file__),
            '../../data/everpad-file.png',
        ),
        resource_filename('share/icons/hicolor/48x48/actions/everpad-file.png'),
        '/usr/local/share/icons/hicolor/48x48/actions/everpad-file.png',
        '/usr/share/icons/hicolor/48x48/actions/everpad-file.png',
    )
    for path in paths:
        if os.path.isfile(path):
            return 'file://%s' % path
file_icon_path = get_file_icon_path()

########NEW FILE########
__FILENAME__ = treeview
from PySide.QtGui import QTreeView, QItemSelection
from PySide.QtCore import Signal


class EverpadTreeView(QTreeView):
    selection = Signal(QItemSelection, QItemSelection)

    def selectionChanged(self, selected, deselected):
        QTreeView.selectionChanged(self, selected, deselected)
        self.selection.emit(selected, deselected)

########NEW FILE########
__FILENAME__ = daemon
from .service import ProviderService
from .sync.agent import SyncThread
from .tools import set_auth_token, get_auth_token, get_db_session
from ..specific import AppClass
from ..tools import print_version
from . import models
from PySide.QtCore import Slot, QSettings
import dbus
import dbus.mainloop.glib
import signal
import fcntl
import os
import getpass
import argparse
import sys
import logging


class ProviderApp(AppClass):

    def __init__(self, verbose, *args, **kwargs):
        AppClass.__init__(self, *args, **kwargs)
        self.settings = QSettings('everpad', 'everpad-provider')
        self.verbose = verbose
        session_bus = dbus.SessionBus()
        self.bus = dbus.service.BusName("com.everpad.Provider", session_bus)
        self.service = ProviderService(session_bus, '/EverpadProvider')
        self.sync_thread = SyncThread()
        self.sync_thread.sync_state_changed.connect(
            Slot(int)(self.service.sync_state_changed),
        )
        self.sync_thread.data_changed.connect(
            Slot()(self.service.data_changed),
        )
        if get_auth_token():
            self.sync_thread.start()
        self.service.qobject.authenticate_signal.connect(
            self.on_authenticated,
        )
        self.service.qobject.remove_authenticate_signal.connect(
            self.on_remove_authenticated,
        )
        self.service.qobject.terminate.connect(self.terminate)
        # Configure logger.
        self.logger = logging.getLogger('everpad-provider')
        self.logger.setLevel(logging.DEBUG)
        fh = logging.FileHandler(
            os.path.expanduser('~/.everpad/logs/everpad-provider.log'))
        fh.setLevel(logging.DEBUG)
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        fh.setFormatter(formatter)
        self.logger.addHandler(fh)
        self.logger.debug('Provider started.')

    @Slot(str)
    def on_authenticated(self, token):
        set_auth_token(token)
        self.sync_thread.start()

    @Slot()
    def on_remove_authenticated(self):
        self.sync_thread.quit()
        self.sync_thread.update_count = 0
        set_auth_token('')
        session = get_db_session()
        session.query(models.Note).delete(
            synchronize_session='fetch',
        )
        session.query(models.Resource).delete(
            synchronize_session='fetch',
        )
        session.query(models.Notebook).delete(
            synchronize_session='fetch',
        )
        session.query(models.Tag).delete(
            synchronize_session='fetch',
        )
        session.commit()

    def log(self, data):
        self.logger.debug(data)
        if self.verbose:
            print data

    @Slot()
    def terminate(self):
        self.sync_thread.quit()
        self.quit()


def _create_dirs(dirs):
    """Create everpad dirs"""
    for path in dirs:
        try:
            os.mkdir(os.path.expanduser(path))
        except OSError:
            continue


def main():
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    _create_dirs(['~/.everpad/', '~/.everpad/data/', '~/.everpad/logs/'])
    parser = argparse.ArgumentParser()
    parser.add_argument('--verbose', action='store_true', help='verbose output')
    parser.add_argument('--version', '-v', action='store_true', help='show version')
    args = parser.parse_args(sys.argv[1:])
    if args.version:
        print_version()
    fp = open('/tmp/everpad-provider-%s.lock' % getpass.getuser(), 'w')
    try:
        fcntl.lockf(fp, fcntl.LOCK_EX | fcntl.LOCK_NB)
        dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
        app = ProviderApp(args.verbose, sys.argv)
        app.exec_()
    except IOError:
        print("everpad-provider already ran")
    except Exception as e:
        app.logger.debug(e)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = exceptions
class TTypeValidationFailed(Exception):
    """TType validation failed"""


########NEW FILE########
__FILENAME__ = models
from BeautifulSoup import BeautifulSoup
from sqlalchemy import Table, Column, Integer, ForeignKey, String, Boolean
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm.exc import NoResultFound
from ..tools import prepare_file_path
from .. import const
import binascii
import os
import urllib
import json
import dbus
import socket


Base = declarative_base()


notetags_table = Table(
    'notetags', Base.metadata,
    Column('note', Integer, ForeignKey('notes.id')),
    Column('tag', Integer, ForeignKey('tags.id'))
)


class Note(Base):
    __tablename__ = 'notes'
    id = Column(Integer, primary_key=True)
    guid = Column(String)
    title = Column(String)
    content = Column(String)
    created = Column(Integer)
    updated = Column(Integer)
    updated_local = Column(Integer)
    notebook_id = Column(Integer, ForeignKey('notebooks.id'))
    notebook = relationship("Notebook", backref='note')
    tags = relationship(
        "Tag",
        secondary=notetags_table,
        backref="notes",
    )
    pinnded = Column(Boolean, default=False)
    resources = relationship("Resource")
    place_id = Column(Integer, ForeignKey('places.id'))
    place = relationship("Place", backref='note')
    action = Column(Integer)
    conflict_parent = relationship("Note", post_update=False)
    conflict_parent_id = Column(
        Integer, ForeignKey('notes.id'), nullable=True,
    )

    # sharing data:
    share_date = Column(Integer)
    share_status = Column(Integer, default=const.SHARE_NONE)
    share_url = Column(String)

    @property
    def tags_dbus(self):
        return map(lambda tag: tag.name, self.tags)

    @tags_dbus.setter
    def tags_dbus(self, val):
        tags = []
        for tag in val:
            if tag and tag != ' ':  # for blank array and other
                try:
                    tags.append(self.session.query(Tag).filter(
                        (Tag.name == tag)
                        & (Tag.action != const.ACTION_DELETE)
                    ).one())
                except NoResultFound:
                    tg = Tag(name=tag, action=const.ACTION_CREATE)
                    self.session.add(tg)
                    tags.append(tg)
        self.tags = tags

    @property
    def notebook_dbus(self):
        if self.notebook:
            return self.notebook.id
        else:
            return self.session.query(Notebook).filter(
                Notebook.default == True,
            ).one().id

    @notebook_dbus.setter
    def notebook_dbus(self, val):
        try:
            self.notebook = self.session.query(Notebook).filter(
                Notebook.id == val,
            ).one()
        except NoResultFound:
            self.notebook = self.session.query(Notebook).filter(
                Notebook.default == True,
            ).one()

    @property
    def place_dbus(self):
        if self.place:
            return self.place.name
        return ''

    @place_dbus.setter
    def place_dbus(self, val):
        if val:
            self.set_place(val, self.session)

    @property
    def conflict_parent_dbus(self):
        if self.conflict_parent_id:
            return self.conflict_parent_id
        return 0

    @conflict_parent_dbus.setter
    def conflict_parent_dbus(self, val):
        pass

    @property
    def conflict_items_dbus(self):
        return map(
            lambda item: item.id,
            self.session.query(Note).filter(
                Note.conflict_parent_id == self.id,
            ).all(),
        ) or dbus.Array([], signature='i')

    @conflict_items_dbus.setter
    def conflict_items_dbus(self, val):
        pass

    @property
    def share_date_dbus(self):
        return self.share_date or 0

    @share_date_dbus.setter
    def share_date_dbus(self, val):
        pass

    @property
    def share_url_dbus(self):
        return self.share_url or ''

    @share_url_dbus.setter
    def share_url_dbus(self, val):
        pass

    def from_api(self, note, session):
        """Fill data from api"""
        soup = BeautifulSoup(note.content.decode('utf8'))
        content = reduce(
            lambda txt, cur: txt + unicode(cur),
            soup.find('en-note').contents, u'',
        )
        self.title = note.title.decode('utf8')
        self.content = content
        self.created = note.created
        self.updated = note.updated
        self.action = const.ACTION_NONE
        if note.notebookGuid:
            self.notebook = session.query(Notebook).filter(
                Notebook.guid == note.notebookGuid,
            ).one()
        if note.tagGuids:
            self.tags = session.query(Tag).filter(
                Tag.guid.in_(note.tagGuids),
            ).all()
        place_name = None
        if getattr(note, 'attributes'):
            if note.attributes.placeName:
                place_name = note.attributes.placeName.decode('utf8')
            elif note.attributes.longitude:
                try:
                    data = json.loads(urllib.urlopen(
                        'http://maps.googleapis.com/maps/api/geocode/json?latlng=%.4f,%.4f&sensor=false' % (
                            note.attributes.latitude,
                            note.attributes.longitude,
                        ),
                    ).read())
                    try:
                        place_name = data['results'][0]['formatted_address']
                    except (IndexError, KeyError):
                        pass
                except socket.error:
                    pass
        if place_name:
            self.set_place(place_name, session)

    def set_place(self, name, session):
        try:
            place = session.query(Place).filter(
                Place.name == name,
            ).one()
        except NoResultFound:
            place = Place(name=name)
            session.add(place)
        self.place = place


class Notebook(Base):
    __tablename__ = 'notebooks'
    id = Column(Integer, primary_key=True)
    guid = Column(String)
    name = Column(String)
    default = Column(Boolean)
    service_created = Column(Integer)
    service_updated = Column(Integer)
    action = Column(Integer)
    stack = Column(String)

    def from_api(self, notebook):
        """Fill data from api"""
        self.name = notebook.name.decode('utf8')
        self.default = notebook.defaultNotebook
        self.service_created = notebook.serviceCreated
        self.service_updated = notebook.serviceUpdated
        self.action = const.ACTION_NONE
        if notebook.stack:
            self.stack = notebook.stack.decode('utf8')

    @property
    def stack_dbus(self):
        if self.stack:
            return self.stack
        return ''

    @stack_dbus.setter
    def stack_dbus(self, val):
        self.stack = val


class Tag(Base):
    __tablename__ = 'tags'
    id = Column(Integer, primary_key=True)
    guid = Column(String)
    name = Column(String)
    action = Column(Integer)

    def from_api(self, tag):
        """Fill data from api"""
        self.name = tag.name.decode('utf8')
        self.action = const.ACTION_NONE


class Resource(Base):
    __tablename__ = 'resources'
    id = Column(Integer, primary_key=True)
    note_id = Column(Integer, ForeignKey('notes.id'))
    file_name = Column(String)
    file_path = Column(String)
    guid = Column(String)
    hash = Column(String)
    mime = Column(String)
    action = Column(Integer)

    def from_api(self, resource):
        """Fill data from api"""
        if resource.attributes.fileName:
            self.file_name = resource.attributes.fileName.decode('utf8')
        else:
            self.file_name = resource.guid.decode('utf8')
        self.hash = binascii.b2a_hex(resource.data.bodyHash)
        self.action = const.ACTION_NONE
        self.mime = resource.mime.decode('utf8')
        path = os.path.expanduser('~/.everpad/data/%s/' % self.note_id)
        try:
            os.mkdir(path)
        except OSError:
            pass
        self.file_path = prepare_file_path(path, self.file_name)
        with open(self.file_path, 'w') as data:
            data.write(resource.data.body)


class Place(Base):
    __tablename__ = 'places'
    id = Column(Integer, primary_key=True)
    name = Column(String)


class Sync(Base):
    __tablename__ = 'sync'
    id = Column(Integer, primary_key=True)
    update_count = Column(Integer)
    last_sync = Column(Integer)

########NEW FILE########
__FILENAME__ = service
from PySide.QtCore import Signal, QObject
from sqlalchemy import or_, and_, func
from sqlalchemy.orm.exc import NoResultFound
from dbus.exceptions import DBusException
from .. import const, basetypes as btype
from ..specific import AppClass
from . import models
from .tools import get_db_session, get_auth_token
import dbus
import dbus.service
import time


class NoteFilterer(object):
    """Create list with wiltered and sorted notes"""

    def __init__(self, session):
        self._filters = []
        self._order = None
        self.session = session

    def by_words(self, words):
        """Add filter by words"""
        if words:
            words = '%' + words.replace(' ', '%').lower() + '%'
            self._filters.append(
                func.lower(models.Note.title).like(words)
                | func.lower(models.Note.content).like(words)
                | models.Note.tags.any(
                    func.lower(models.Tag.name).like(words),
                )
                | models.Note.notebook.has(
                    func.lower(models.Notebook.name).like(words)
                )
            )
        return self

    def by_notebooks(self, notebooks):
        """Add filter by notebooks"""
        if notebooks:
            self._filters.append(
                models.Note.notebook_id.in_(notebooks),
            )
        return self

    def by_tags(self, tags):
        """Add filter by tags"""
        if tags:
            self._filters.append(
                models.Note.tags.any(models.Tag.id.in_(tags)),
            )
        return self

    def by_place(self, place):
        """Add filter by place"""
        if place:
            self._filters.append(
                models.Note.place_id == place,
            )
        return self

    def by_pinnded(self, pinnded):
        """By pinnded status"""
        if pinnded != const.NOT_PINNDED:
            self._filters.append(
                models.Note.pinnded == pinnded,
            )
        return self

    def order_by(self, order):
        """Set ordering"""
        self._order = {
            btype.Note.ORDER_TITLE: models.Note.title,
            btype.Note.ORDER_UPDATED: models.Note.updated,
            btype.Note.ORDER_TITLE_DESC: models.Note.title.desc(),
            btype.Note.ORDER_UPDATED_DESC: models.Note.updated.desc(),
        }[order]
        return self

    def all(self):
        """Get result"""
        return self.session.query(models.Note).filter(and_(
            ~models.Note.action.in_(const.DISABLED_ACTIONS),
            *self._filters
        )).order_by(self._order)


class ProviderServiceQObject(QObject):
    """Signals holder for service"""
    authenticate_signal = Signal(str)
    remove_authenticate_signal = Signal()
    terminate = Signal()


class ProviderService(dbus.service.Object):
    """DBus service for provider"""

    def __init__(self, *args, **kwargs):
        super(ProviderService, self).__init__(*args, **kwargs)
        self.qobject = ProviderServiceQObject()
        self.app = AppClass.instance()

    @property
    def session(self):
        if not hasattr(self, '_session'):
            self._session = get_db_session()
            models.Note.session = self._session   # shit shit
        return self._session

    @property
    def sq(self):
        if not hasattr(self, '_sq'):
            self._sq = self.session.query
        return self._sq

    @dbus.service.method(
        "com.everpad.Provider", in_signature='i',
        out_signature=btype.Note.signature,
    )
    def get_note(self, id):
        """Get nite by id"""
        try:
            note = self.session.query(models.Note).filter(
                (models.Note.id == id)
                & (models.Note.action != const.ACTION_DELETE)
            ).one()

            return btype.Note >> note
        except NoResultFound:
            raise DBusException('models.Note not found')

    @dbus.service.method(
        "com.everpad.Provider", in_signature='s',
        out_signature=btype.Note.signature,
    )
    def get_note_by_guid(self, guid):
        """Get note by guid"""
        try:
            note = self.session.query(models.Note).filter(
                (models.Note.guid == guid)
                & ~models.Note.action.in_(const.DISABLED_ACTIONS)
            ).one()

            return btype.Note >> note
        except NoResultFound:
            raise DBusException('Note not found')

    @dbus.service.method(
        "com.everpad.Provider", in_signature='i',
        out_signature='a{}'.format(btype.Note.signature),
    )
    def get_note_alternatives(self, id):
        """Get note conflict alternatives"""
        notes = self.session.query(models.Note).filter(
            models.Note.conflict_parent_id == id,
        ).all()
        return btype.Note.list >> notes

    @dbus.service.method(
        "com.everpad.Provider", in_signature='saiaiiiii',
        out_signature='a{}'.format(btype.Note.signature),
    )
    def find_notes(
        self, words, notebooks, tags, place,
        limit=const.DEFAULT_LIMIT, order=const.ORDER_UPDATED,
        pinnded=const.NOT_PINNDED,
    ):
        """Find notes by filters"""
        notes = btype.Note.list >> NoteFilterer(self.session)\
            .by_words(words)\
            .by_notebooks(notebooks)\
            .by_tags(tags)\
            .by_place(place)\
            .by_pinnded(pinnded)\
            .order_by(order)\
            .all()\
            .limit(limit)

        return notes

    @dbus.service.method(
        "com.everpad.Provider", in_signature='',
        out_signature='a{}'.format(btype.Notebook.signature),
    )
    def list_notebooks(self):
        """List available notebooks"""
        notebooks = self.session.query(models.Notebook).filter(
            models.Notebook.action != const.ACTION_DELETE,
        ).order_by(models.Notebook.name)

        return btype.Notebook.list >> notebooks

    @dbus.service.method(
        "com.everpad.Provider", in_signature='i',
        out_signature=btype.Notebook.signature,
    )
    def get_notebook(self, id):
        """Get notebook by id"""
        try:
            notebook = self.session.query(models.Notebook).filter(
                (models.Notebook.id == id)
                & (models.Notebook.action != const.ACTION_DELETE)
            ).one()

            return btype.Notebook >> notebook
        except NoResultFound:
            raise DBusException('Notebook does not exist')

    @dbus.service.method(
        "com.everpad.Provider", in_signature='i',
        out_signature='i',
    )
    def get_notebook_notes_count(self, id):
        """Get count of notes in notebook"""
        return self.session.query(models.Note).filter(
            (models.Note.notebook_id == id)
            & ~models.Note.action.in_(const.DISABLED_ACTIONS)
        ).count()

    @dbus.service.method(
        "com.everpad.Provider", in_signature=btype.Notebook.signature,
        out_signature=btype.Notebook.signature,
    )
    def update_notebook(self, notebook_struct):
        """Update notebook"""
        try:
            notebook_btype = btype.Notebook << notebook_struct

            notebook = self.session.query(models.Notebook).filter(
                (models.Notebook.id == notebook_btype.id)
                & (models.Notebook.action != const.ACTION_DELETE)
            ).one()

            if self.session.query(models.Notebook).filter(
                (models.Notebook.id != notebook_btype.id)
                & (models.Notebook.name == notebook_btype.name)
            ).count():
                raise DBusException(
                    'Notebook with this name already exist',
                )

            notebook.action = const.ACTION_CHANGE
            notebook_btype.give_to_obj(notebook)
            self.session.commit()

            self.data_changed()

            return btype.Notebook >> notebook
        except NoResultFound:
            raise DBusException('Notebook does not exist')

    @dbus.service.method(
        "com.everpad.Provider", in_signature='i',
        out_signature='b',
    )
    def delete_notebook(self, id):
        """Delete notebook"""
        try:
            notebook = self.session.query(models.Notebook).filter(
                models.Notebook.id == id,
            ).one()
            notebook.action = const.ACTION_DELETE
            self.session.commit()
            self.data_changed()
            return True
        except NoResultFound:
            raise DBusException('Notebook does not exist')

    @dbus.service.method(
        "com.everpad.Provider", in_signature='',
        out_signature='a{}'.format(btype.Tag.signature),
    )
    def list_tags(self):
        """List all tags"""
        tags = self.session.query(models.Tag).filter(
            models.Tag.action != const.ACTION_DELETE,
        ).order_by(models.Tag.name)

        return btype.Tag.list >> tags

    @dbus.service.method(
        "com.everpad.Provider", in_signature='i',
        out_signature='i',
    )
    def get_tag_notes_count(self, id):
        """Get count of notes with tag"""
        return self.session.query(models.Note).filter(
            models.Note.tags.any(models.Tag.id == id)
            & ~models.Note.action.in_(const.DISABLED_ACTIONS)
        ).count()

    @dbus.service.method(
        "com.everpad.Provider", in_signature='i',
        out_signature='b',
    )
    def delete_tag(self, id):
        """Delete tag"""
        try:
            tag = self.session.query(models.Tag).filter(
                (models.Tag.id == id)
                & (models.Tag.action != const.ACTION_DELETE)
            ).one()

            tag.action = const.ACTION_DELETE

            for note in self.session.query(models.Note).filter(
                models.Note.tags.contains(tag),
            ).all():
                note.tags.remove(tag)

            self.session.commit()
            self.data_changed()
            return True
        except NoResultFound:
            raise DBusException('Tag does not exist')

    @dbus.service.method(
        "com.everpad.Provider", in_signature=btype.Tag.signature,
        out_signature=btype.Tag.signature,
    )
    def update_tag(self, tag_struct):
        """Update tag"""
        try:
            tag_btype = btype.Tag << tag_struct
            tag = self.session.query(models.Tag).filter(
                (models.Tag.id == tag_btype.id)
                & (models.Tag.action != const.ACTION_DELETE)
            ).one()

            if self.session.query(models.Tag).filter(
                (models.Tag.id != tag_btype.id)
                & (models.Tag.name == tag_btype.name)
            ).count():
                raise DBusException(
                    'Tag with this name already exist',
                )

            tag.action = const.ACTION_CHANGE
            tag_btype.give_to_obj(tag)
            self.session.commit()
            self.data_changed()

            return btype.Tag >> tag
        except NoResultFound:
            raise DBusException('Tag does not exist')

    @dbus.service.method(
        "com.everpad.Provider",
        in_signature=btype.Note.signature,
        out_signature=btype.Note.signature,
    )
    def create_note(self, note_struct):
        """Create new note"""
        note = models.Note(
            action=const.ACTION_NOEXSIST,
        )
        note_btype = btype.Note << note_struct
        note_btype.id = None
        note_btype.give_to_obj(note)

        note.updated = int(time.time() * 1000)
        note.created = int(time.time() * 1000)

        self.session.add(note)
        self.session.commit()
        self.data_changed()

        return btype.Note >> note

    @dbus.service.method(
        "com.everpad.Provider",
        in_signature=btype.Note.signature,
        out_signature=btype.Note.signature,
    )
    def update_note(self, note_struct):
        """Update note"""
        note_btype = btype.Note << note_struct

        try:
            note = self.session.query(models.Note).filter(
                (models.Note.id == note_btype.id)
                & (models.Note.action != const.ACTION_DELETE)
            ).one()
        except NoResultFound:
            raise DBusException('Note not found')

        note_btype.give_to_obj(note)

        if note.action == const.ACTION_NOEXSIST:
            note.action = const.ACTION_CREATE
        elif note.action != const.ACTION_CREATE:
            note.action = const.ACTION_CHANGE

        note.updated_local = int(time.time() * 1000)
        self.session.commit()
        self.data_changed()

        return btype.Note >> note

    @dbus.service.method(
        "com.everpad.Provider", in_signature='i',
        out_signature='a{}'.format(btype.Resource.signature),
    )
    def get_note_resources(self, note_id):
        """Get note resources"""
        resources = self.session.query(models.Resource).filter(
            (models.Resource.note_id == note_id)
            & (models.Resource.action != const.ACTION_DELETE)
        )

        return btype.Resource.list >> resources

    @dbus.service.method(
        "com.everpad.Provider",
        in_signature='ia{}'.format(btype.Resource.signature),
        out_signature='{}'.format(btype.Note.signature),
    )
    def update_note_resources(self, note_id, resources_struct):
        """Update note resources"""
        try:
            note = self.session.query(models.Note).filter(
                models.Note.id == note_id,
            ).one()
        except NoResultFound:
            raise DBusException('models.Note not found')

        self.session.query(models.Resource).filter(
            models.Resource.note_id == note.id,
        ).delete()

        for resource_btype in btype.Resource.list << resources_struct:
            resource = models.Resource(
                action=const.ACTION_CREATE,
                note_id=note.id,
            )
            resource_btype.give_to_obj(resource)
            resource.id = None
            self.session.add(resource)

        if note.action != const.ACTION_CREATE:
            note.action = const.ACTION_CHANGE

        self.session.commit()
        self.data_changed()
        return btype.Note >> note

    @dbus.service.method(
        "com.everpad.Provider",
        in_signature='i', out_signature='b',
    )
    def delete_note(self, note_id):
        """Delete note"""
        try:
            note = self.session.query(models.Note).filter(
                models.Note.id == note_id,
            ).one()

            if note.action == const.ACTION_CONFLICT:
                # prevent circular dependency error
                note.conflict_parent_id = None
                note.conflict_parent = []
                self.session.commit()
                self.session.delete(note)
            else:
                note.action = const.ACTION_DELETE

            self.session.commit()
            self.data_changed()
            return True
        except NoResultFound:
            raise DBusException('models.Note not found')

    @dbus.service.method(
        "com.everpad.Provider",
        in_signature='ss',
        out_signature=btype.Notebook.signature,
    )
    def create_notebook(self, name, stack):
        """Create new notebook"""
        if self.session.query(models.Note).filter(
            models.Notebook.name == name,
        ).count():
            raise DBusException(
                'models.Notebook with this name already exist',
            )

        notebook = models.Notebook(
            action=const.ACTION_CREATE,
            name=name, default=False, stack=stack,
        )
        self.session.add(notebook)
        self.session.commit()
        self.data_changed()
        return btype.Notebook >> notebook

    @dbus.service.method(
        "com.everpad.Provider",
        in_signature='s', out_signature='',
    )
    def authenticate(self, token):
        """Authenticate client with token"""
        self.qobject.remove_authenticate_signal.emit()
        self.qobject.authenticate_signal.emit(token)
        if self.app.sync_thread.status != const.STATUS_SYNC:
            self.app.sync_thread.force_sync()
        self.data_changed()

    @dbus.service.method(
        "com.everpad.Provider",
        in_signature='', out_signature='',
    )
    def remove_authentication(self):
        """Remove authentication"""
        self.qobject.remove_authenticate_signal.emit()
        self.data_changed()

    @dbus.service.method(
        "com.everpad.Provider",
        in_signature='', out_signature='b',
    )
    def is_authenticated(self):
        """Check is client authenticated"""
        return bool(get_auth_token())

    @dbus.service.method(
        "com.everpad.Provider",
        in_signature='', out_signature='a%s' % btype.Place.signature,
    )
    def list_places(self):
        """List places"""
        places = self.session.query(models.Place).all()
        return btype.Place.list >> places

    @dbus.service.method(
        "com.everpad.Provider",
        in_signature='i', out_signature='',
    )
    def share_note(self, note_id):
        """Share note"""
        try:
            note = self.session.query(models.Note).filter(
                (models.Note.id == note_id)
                & (models.Note.action != const.ACTION_DELETE)
            ).one()
            note.share_status = const.SHARE_NEED_SHARE
            self.session.commit()
            self.sync()
        except NoResultFound:
            raise DBusException('models.Note not found')

    @dbus.service.method(
        "com.everpad.Provider",
        in_signature='i', out_signature=''
    )
    def stop_sharing_note(self, note_id):
        """Stop sharing note"""
        try:
            note = self.session.query(models.Note).filter(
                (models.Note.id == note_id)
                & (models.Note.action != const.ACTION_DELETE)
            ).one()
            note.share_status = const.SHARE_NEED_STOP
            note.share_url = ''
            self.session.commit()
            self.sync()
        except NoResultFound:
            raise DBusException('models.Note not found')

    @dbus.service.method(
        "com.everpad.Provider",
        in_signature='', out_signature='i',
    )
    def get_status(self):
        """Get sync status"""
        return self.app.sync_thread.status

    @dbus.service.method(
        "com.everpad.Provider",
        in_signature='', out_signature='s',
    )
    def get_last_sync(self):
        """Get last sync date"""
        return self.app.sync_thread.last_sync.strftime('%H:%M')

    @dbus.service.method(
        "com.everpad.Provider",
        in_signature='', out_signature='',
    )
    def sync(self):
        """Preform sync"""
        if self.app.sync_thread.status != const.STATUS_SYNC:
            self.app.sync_thread.force_sync()
        return

    @dbus.service.method(
        "com.everpad.Provider",
        in_signature='i', out_signature='',
    )
    def set_sync_delay(self, delay):
        """Change sync delay"""
        self.app.settings.setValue('sync_delay', str(delay))
        self.app.sync_thread.update_timer()

    @dbus.service.method(
        "com.everpad.Provider",
        in_signature='', out_signature='i',
    )
    def get_sync_delay(self):
        """Get sync delay"""
        return int(self.app.settings.value('sync_delay') or 0)\
            or const.DEFAULT_SYNC_DELAY

    @dbus.service.method(
        "com.everpad.Provider", in_signature='',
        out_signature='b',
    )
    def is_first_synced(self):
        """Check is first sync performed"""
        return bool(self.session.query(models.Notebook).filter(
            (models.Notebook.action != const.ACTION_DELETE)
            & (models.Notebook.default == True)
        ).count())

    @dbus.service.method(
        "com.everpad.Provider", in_signature='',
        out_signature='i',
    )
    def get_api_version(self):
        """Get api version"""
        return const.API_VERSION

    @dbus.service.method(
        "com.everpad.Provider", in_signature='s',
        out_signature='s',
    )
    def get_settings_value(self, name):
        """Get settings value"""
        return self.app.settings.value(name, '')

    @dbus.service.method(
        "com.everpad.Provider", in_signature='ss',
        out_signature='',
    )
    def set_settings_value(self, name, value):
        """Set settings value"""
        self.app.settings.setValue(name, value)
        self.settings_changed(name, value)
        return

    @dbus.service.method(
        "com.everpad.Provider", in_signature='',
    )
    def kill(self):
        """Kill everpad"""
        self.qobject.terminate.emit()
        return

    @dbus.service.signal(
        'com.everpad.provider', signature='i',
    )
    def sync_state_changed(self, state):
        """Emit when sync state changed"""
        return

    @dbus.service.signal(
        'com.everpad.provider', signature='',
    )
    def data_changed(self):
        """Emit when data changed"""
        return

    @dbus.service.signal(
        'com.everpad.provider', signature='ss',
    )
    def settings_changed(self, name, value):
        """Emit when settings changed"""
        return

########NEW FILE########
__FILENAME__ = agent
from PySide import QtCore
from datetime import datetime
from ... import const
from ...specific import AppClass
from .. import tools
from . import note, notebook, tag
from .. import models
import time
import traceback
import socket


class SyncThread(QtCore.QThread):
    """Sync notes with evernote thread"""
    force_sync_signal = QtCore.Signal()
    sync_state_changed = QtCore.Signal(int)
    data_changed = QtCore.Signal()

    def __init__(self, *args, **kwargs):
        """Init default values"""
        QtCore.QThread.__init__(self, *args, **kwargs)
        self.app = AppClass.instance()
        self._init_timer()
        self._init_locks()

    def _init_sync(self):
        """Init sync"""
        self.status = const.STATUS_NONE
        self.last_sync = datetime.now()
        self.sync_state = self.session.query(models.Sync).first()
        if not self.sync_state:
            self.sync_state = models.Sync(
                update_count=0, last_sync=self.last_sync)
            self.session.add(self.sync_state)
            self.session.commit()

    def _init_timer(self):
        """Init timer"""
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self.sync)
        self.update_timer()

    def _init_locks(self):
        """Init locks"""
        self.wait_condition = QtCore.QWaitCondition()
        self.mutex = QtCore.QMutex()

    def update_timer(self):
        """Update sync timer"""
        self.timer.stop()
        delay = int(self.app.settings.value('sync_delay') or 0)
        if not delay:
            delay = const.DEFAULT_SYNC_DELAY

        if delay != const.SYNC_MANUAL:
            self.timer.start(delay)

    def run(self):
        """Run thread"""
        self._init_db()
        self._init_network()
        self._init_sync()
        while True:
            self.mutex.lock()
            self.wait_condition.wait(self.mutex)
            self.perform()
            self.mutex.unlock()
            time.sleep(1)  # prevent cpu eating

    def _init_db(self):
        """Init database"""
        self.session = tools.get_db_session()

    def _init_network(self):
        """Init connection to remote server"""
        while True:
            try:
                self.auth_token = tools.get_auth_token()
                self.note_store = tools.get_note_store(self.auth_token)
                self.user_store = tools.get_user_store(self.auth_token)
                break
            except socket.error:
                time.sleep(30)

    def _need_to_update(self):
        """Check need for update notes"""
        self.app.log('Checking need for update notes.')
        # Try to update_count.
        try:
            update_count = self.note_store.getSyncState(
                self.auth_token).updateCount
        except socket.error, e:
            self.app.log(
                "Couldn't connect to remote server. Got: %s" %
                traceback.format_exc())
            # This is most likely a network failure. Return False so
            # everpad-provider won't lock up and can try to sync up in the
            # next run.
            return False
        #XXX: matsubara probably innefficient as it does a SQL each time it
        # accesses the update_count attr?
        self.app.log("Local update count: %s Remote update count: %s" % (
            self.sync_state.update_count, update_count))
        reason = update_count != self.sync_state.update_count
        self.sync_state.update_count = update_count
        return reason

    def force_sync(self):
        """Start sync"""
        self.timer.stop()
        self.sync()
        self.update_timer()

    @QtCore.Slot()
    def sync(self):
        """Do sync"""
        self.wait_condition.wakeAll()

    def perform(self):
        """Perform all sync"""
        self.app.log("Performing sync")
        self.status = const.STATUS_SYNC
        self.last_sync = datetime.now()
        self.sync_state_changed.emit(const.SYNC_STATE_START)

        need_to_update = self._need_to_update()

        try:
            if need_to_update:
                self.remote_changes()
            self.local_changes()
        except Exception, e:  # maybe log this
            self.session.rollback()
            self._init_db()
            self.app.log(e)
        finally:
            self.sync_state_changed.emit(const.SYNC_STATE_FINISH)
            self.status = const.STATUS_NONE
            self.all_notes = None

        self.data_changed.emit()
        self.app.log("Sync performed.")

    def _get_sync_args(self):
        """Get sync arguments"""
        return self.auth_token, self.session, self.note_store, self.user_store

    def local_changes(self):
        """Send local changes to evernote server"""
        self.app.log('Running local_changes()')
        self.sync_state_changed.emit(const.SYNC_STATE_NOTEBOOKS_LOCAL)
        notebook.PushNotebook(*self._get_sync_args()).push()

        self.sync_state_changed.emit(const.SYNC_STATE_TAGS_LOCAL)
        tag.PushTag(*self._get_sync_args()).push()

        self.sync_state_changed.emit(const.SYNC_STATE_NOTES_LOCAL)
        note.PushNote(*self._get_sync_args()).push()

    def remote_changes(self):
        """Receive remote changes from evernote"""
        self.app.log('Running remote_changes()')
        self.sync_state_changed.emit(const.SYNC_STATE_NOTEBOOKS_REMOTE)
        notebook.PullNotebook(*self._get_sync_args()).pull()

        self.sync_state_changed.emit(const.SYNC_STATE_TAGS_REMOTE)
        tag.PullTag(*self._get_sync_args()).pull()

        self.sync_state_changed.emit(const.SYNC_STATE_NOTES_REMOTE)
        note.PullNote(*self._get_sync_args()).pull()

########NEW FILE########
__FILENAME__ = base
from ...specific import AppClass


class BaseSync(object):
    """Base class for sync"""

    def __init__(self, auth_token, session, note_store, user_store):
        """Set shortcuts"""
        self.auth_token = auth_token
        self.session = session
        self.note_store = note_store
        self.user_store = user_store
        self.app = AppClass.instance()

########NEW FILE########
__FILENAME__ = note
from BeautifulSoup import BeautifulSoup
from sqlalchemy.orm.exc import NoResultFound
from everpad.tools import sanitize
from evernote.edam.error.ttypes import EDAMUserException
from evernote.edam.limits import constants as limits
from evernote.edam.type import ttypes
from evernote.edam.notestore.ttypes import NoteFilter
from ... import const
from .. import models
from .base import BaseSync
import time
import binascii


class ShareNoteMixin(object):
    """Mixin with methods for sharing notes"""

    def _get_shard_id(self):
        """Receive shard id, not cached because can change"""
        return self.user_store.getUser(self.auth_token).shardId

    def _share_note(self, note, share_date=None):
        """Share or receive info about sharing"""
        try:
            share_key = self.note_store.shareNote(self.auth_token, note.guid)
            note.share_url = "https://www.evernote.com/shard/{}/sh/{}/{}".format(
                self._get_shard_id(), note.guid, share_key,
            )
            note.share_date = share_date or int(time.time() * 1000)
            note.share_status = const.SHARE_SHARED
            self.session.commit()
        except EDAMUserException as e:
            note.share_status = const.SHARE_NONE
            self.app.log('Sharing note %s failed' % note.title)
            self.app.log(e)

    def _stop_sharing_note(self, note):
        """Stop sharing note"""
        note.share_status = const.SHARE_NONE
        note.share_date = None
        note.share_url = None
        self.session.commit()


class PushNote(BaseSync, ShareNoteMixin):
    """Push note to remote server"""

    def push(self):
        """Push note to remote server"""
        for note in self.session.query(models.Note).filter(
            ~models.Note.action.in_((
                const.ACTION_NONE, const.ACTION_NOEXSIST, const.ACTION_CONFLICT,
            ))
        ):
            self.app.log('Pushing note "%s" to remote server.' % note.title)
            note_ttype = self._create_ttype(note)

            if note.action == const.ACTION_CREATE:
                self._push_new_note(note, note_ttype)
            elif note.action == const.ACTION_CHANGE:
                self._push_changed_note(note, note_ttype)
            elif note.action == const.ACTION_DELETE:
                self._delete_note(note, note_ttype)

            if note.share_status == const.SHARE_NEED_SHARE:
                self._share_note(note)
            elif note.share_status == const.SHARE_NEED_STOP:
                self._stop_sharing_note(note)

        self.session.commit()

    def _create_ttype(self, note):
        """Create ttype for note"""
        kwargs = dict(
            title=note.title[:limits.EDAM_NOTE_TITLE_LEN_MAX].strip().encode('utf8'),
            content=self._prepare_content(note.content),
            tagGuids=map(
                lambda tag: tag.guid, note.tags,
            ),
            resources=self._prepare_resources(note),
        )

        if note.notebook:
            kwargs['notebookGuid'] = note.notebook.guid

        if note.guid:
            kwargs['guid'] = note.guid

        return ttypes.Note(**kwargs)

    def _prepare_resources(self, note):
        """Prepare note resources"""
        return map(
            lambda resource: ttypes.Resource(
                noteGuid=note.guid,
                data=ttypes.Data(body=open(resource.file_path).read()),
                mime=resource.mime,
                attributes=ttypes.ResourceAttributes(
                    fileName=resource.file_name.encode('utf8'),
                ),
            ), self.session.query(models.Resource).filter(
                (models.Resource.note_id == note.id)
                & (models.Resource.action != const.ACTION_DELETE)
            ),
        )

    def _prepare_content(self, content):
        """Prepare content"""
        enml_content = (u"""
            <!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">
            <en-note>{}</en-note>
        """.format(sanitize(
            html=content[:limits.EDAM_NOTE_CONTENT_LEN_MAX]
        ))).strip().encode('utf8')

        soup = BeautifulSoup(enml_content, selfClosingTags=[
            'img', 'en-todo', 'en-media', 'br', 'hr',
        ])

        return str(soup)

    def _push_new_note(self, note, note_ttype):
        """Push new note to remote"""
        try:
            note_ttype = self.note_store.createNote(self.auth_token, note_ttype)
            note.guid = note_ttype.guid
        except EDAMUserException as e:
            note.action = const.ACTION_NONE
            self.app.log('Push new note "%s" failed.' % note.title)
            self.app.log(e)
        finally:
            note.action = const.ACTION_NONE

    def _push_changed_note(self, note, note_ttype):
        """Push changed note to remote"""
        try:
            self.note_store.updateNote(self.auth_token, note_ttype)
        except EDAMUserException as e:
            self.app.log('Push changed note "%s" failed.' % note.title)
            self.app.log(note_ttype)
            self.app.log(note)
            self.app.log(e)
        finally:
            note.action = const.ACTION_NONE

    def _delete_note(self, note, note_ttype):
        """Delete note"""
        try:
            self.note_store.deleteNote(self.auth_token, note_ttype.guid)
        except EDAMUserException as e:
            self.app.log('Note %s already removed' % note.title)
            self.app.log(e)
        finally:
            self.session.delete(note)


class PullNote(BaseSync, ShareNoteMixin):
    """Pull notes"""

    def __init__(self, *args, **kwargs):
        super(PullNote, self).__init__(*args, **kwargs)
        self._exists = []

    def pull(self):
        """Pull notes from remote server"""
        for note_ttype in self._get_all_notes():
            self.app.log(
                'Pulling note "%s" from remote server.' % note_ttype.title)
            try:
                note = self._update_note(note_ttype)
            except NoResultFound:
                note = self._create_note(note_ttype)
            self._exists.append(note.id)

            self._check_sharing_information(note, note_ttype)

            resource_ids = self._receive_resources(note, note_ttype)
            if resource_ids:
                self._remove_resources(note, resource_ids)

        self.session.commit()
        self._remove_notes()

    def _get_all_notes(self):
        """Iterate all notes"""
        offset = 0

        while True:
            note_list = self.note_store.findNotes(
                self.auth_token, NoteFilter(
                    order=ttypes.NoteSortOrder.UPDATED,
                    ascending=False,
                ), offset, limits.EDAM_USER_NOTES_MAX,
            )

            for note in note_list.notes:
                yield note

            offset = note_list.startIndex + len(note_list.notes)
            if note_list.totalNotes - offset <= 0:
                break

    def _get_full_note(self, note_ttype):
        """Get full note"""
        return self.note_store.getNote(
            self.auth_token, note_ttype.guid,
            True, True, True, True,
        )

    def _create_note(self, note_ttype):
        """Create new note"""
        note_ttype = self._get_full_note(note_ttype)

        note = models.Note(guid=note_ttype.guid)
        note.from_api(note_ttype, self.session)
        self.session.add(note)
        self.session.commit()
        return note

    def _update_note(self, note_ttype):
        """Update changed note"""
        note = self.session.query(models.Note).filter(
            models.Note.guid == note_ttype.guid,
        ).one()

        note_ttype = self._get_full_note(note_ttype)

        if note.updated < note_ttype.updated:
            if note.action == const.ACTION_CHANGE:
                self._create_conflict(note, note_ttype)
            else:
                note.from_api(note_ttype, self.session)
        return note

    def _create_conflict(self, note, note_ttype):
        """Create conflict note"""
        conflict_note = models.Note()
        conflict_note.from_api(note_ttype, self.session)
        conflict_note.guid = ''
        conflict_note.action = const.ACTION_CONFLICT
        conflict_note.conflict_parent_id = note.id
        self.session.add(conflict_note)
        self.session.commit()

    def _remove_notes(self):
        """Remove not exists notes"""
        if self._exists:
            q = ((~models.Note.id.in_(self._exists) |
                ~models.Note.conflict_parent_id.in_(self._exists)) &
                ~models.Note.action.in_((
                    const.ACTION_NOEXSIST, const.ACTION_CREATE,
                    const.ACTION_CHANGE, const.ACTION_CONFLICT)))
        else:
            q = (~models.Note.action.in_((
                    const.ACTION_NOEXSIST, const.ACTION_CREATE,
                    const.ACTION_CHANGE, const.ACTION_CONFLICT)))
        self.session.query(models.Note).filter(q).delete(
            synchronize_session='fetch')
        self.session.commit()

    def _receive_resources(self, note, note_ttype):
        """Receive note resources"""
        resources_ids = []

        for resource_ttype in note_ttype.resources or []:
            try:
                resource = self.session.query(models.Resource).filter(
                    models.Resource.guid == resource_ttype.guid,
                ).one()
                resources_ids.append(resource.id)
                if resource.hash != binascii.b2a_hex(
                    resource_ttype.data.bodyHash,
                ):
                    resource.from_api(resource_ttype)
            except NoResultFound:
                resource = models.Resource(
                    guid=resource_ttype.guid,
                    note_id=note.id,
                )
                resource.from_api(resource_ttype)
                self.session.add(resource)
                self.session.commit()
                resources_ids.append(resource.id)

        return resources_ids

    def _remove_resources(self, note, resources_ids):
        """Remove non exists resources"""
        self.session.query(models.Resource).filter(
            ~models.Resource.id.in_(resources_ids)
            & (models.Resource.note_id == note.id)
        ).delete(synchronize_session='fetch')
        self.session.commit()

    def _check_sharing_information(self, note, note_ttype):
        """Check actual sharing information"""
        if not (
            note_ttype.attributes.shareDate or note.share_status in (
                const.SHARE_NONE, const.SHARE_NEED_SHARE,
            )
        ):
            self._stop_sharing_note(note)
        elif not (
            note_ttype.attributes.shareDate == note.share_date
            or note.share_status in (
                const.SHARE_NEED_SHARE, const.SHARE_NEED_STOP,
            )
        ):
            self._share_note(note, note_ttype.attributes.shareDate)

########NEW FILE########
__FILENAME__ = notebook
from sqlalchemy.orm.exc import NoResultFound
from evernote.edam.error.ttypes import EDAMUserException
from evernote.edam.limits import constants as limits
from evernote.edam.type import ttypes
from ... import const
from ..exceptions import TTypeValidationFailed
from .. import models
from .base import BaseSync
import regex


class PushNotebook(BaseSync):
    """Notebook sync"""

    def push(self):
        """Push notebook changes to server"""
        for notebook in self.session.query(models.Notebook).filter(
            models.Notebook.action != const.ACTION_NONE,
        ):
            self.app.log(
                'Pushing notebook "%s" to remote server.' % notebook.name)

            try:
                notebook_ttype = self._create_ttype(notebook)
            except TTypeValidationFailed:
                self.app.log('notebook %s skipped' % notebook.name)
                notebook.action = const.ACTION_NONE
                continue

            if notebook.action == const.ACTION_CREATE:
                self._push_new_notebook(notebook, notebook_ttype)
            elif notebook.action == const.ACTION_CHANGE:
                self._push_changed_notebook(notebook, notebook_ttype)

        self.session.commit()
        self._merge_duplicates()

    def _create_ttype(self, notebook):
        """Create notebook ttype"""
        kwargs = dict(
            name=notebook.name[
                :limits.EDAM_NOTEBOOK_NAME_LEN_MAX
            ].strip().encode('utf8'),
            defaultNotebook=notebook.default,
        )

        if notebook.stack:
            kwargs['stack'] = notebook.stack[
                :limits.EDAM_NOTEBOOK_STACK_LEN_MAX
            ].strip().encode('utf8')

        if not regex.search(limits.EDAM_NOTEBOOK_NAME_REGEX, notebook.name):
            raise TTypeValidationFailed()

        if notebook.guid:
            kwargs['guid'] = notebook.guid

        return ttypes.Notebook(**kwargs)

    def _push_new_notebook(self, notebook, notebook_ttype):
        """Push new notebook to server"""
        try:
            notebook_ttype = self.note_store.createNotebook(
                self.auth_token, notebook_ttype,
            )
            notebook.guid = notebook_ttype.guid
            notebook.action = const.ACTION_NONE
        except EDAMUserException:
            notebook.action = const.ACTION_DUPLICATE
            self.app.log('Duplicate %s' % notebook_ttype.name)

    def _push_changed_notebook(self, notebook, notebook_ttype):
        """Push changed notebook"""
        try:
            notebook_ttype = self.note_store.updateNotebook(
                self.auth_token, notebook_ttype,
            )
            notebook.action = const.ACTION_NONE
        except EDAMUserException:
            notebook.action = const.ACTION_DUPLICATE
            self.app.log('Duplicate %s' % notebook_ttype.name)

    def _merge_duplicates(self):
        """Merge and remove duplicates"""
        for notebook in self.session.query(models.Notebook).filter(
            models.Notebook.action == const.ACTION_DUPLICATE,
        ):
            try:
                original = self.session.query(models.Notebook).filter(
                    (models.Notebook.action != const.ACTION_DUPLICATE)
                    & (models.Notebook.name == notebook.name)
                ).one()
            except NoResultFound:
                original = self.session.query(models.Notebook).filter(
                    models.Notebook.default == True,
                ).one()

            for note in self.session.query(models.Note).filter(
                models.Note.notebook_id == notebook.id,
            ):
                note.notebook = original

            self.session.delete(notebook)
        self.session.commit()


class PullNotebook(BaseSync):
    """Pull notebook from server"""

    def __init__(self, *args, **kwargs):
        super(PullNotebook, self).__init__(*args, **kwargs)
        self._exists = []

    def pull(self):
        """Receive notebooks from server"""
        for notebook_ttype in self.note_store.listNotebooks(self.auth_token):
            self.app.log(
                'Pulling notebook "%s" from remote server.' % notebook_ttype.name)
            try:
                notebook = self._update_notebook(notebook_ttype)
            except NoResultFound:
                notebook = self._create_notebook(notebook_ttype)
            self._exists.append(notebook.id)

        self.session.commit()
        self._remove_notebooks()

    def _create_notebook(self, notebook_ttype):
        """Create notebook from ttype"""
        notebook = models.Notebook(guid=notebook_ttype.guid)
        notebook.from_api(notebook_ttype)
        self.session.add(notebook)
        self.session.commit()
        return notebook

    def _update_notebook(self, notebook_ttype):
        """Try to update notebook from ttype"""
        notebook = self.session.query(models.Notebook).filter(
            models.Notebook.guid == notebook_ttype.guid,
        ).one()
        if notebook.service_updated < notebook_ttype.serviceUpdated:
            notebook.from_api(notebook_ttype)
        return notebook

    def _remove_notebooks(self):
        """Remove not received notebooks"""
        if self._exists:
            q = (~models.Notebook.id.in_(self._exists)
                & (models.Notebook.action != const.ACTION_CREATE)
                & (models.Notebook.action != const.ACTION_CHANGE))
        else:
            q = ((models.Notebook.action != const.ACTION_CREATE)
                & (models.Notebook.action != const.ACTION_CHANGE))

        self.session.query(models.Notebook).filter(
            q).delete(synchronize_session='fetch')

########NEW FILE########
__FILENAME__ = tag
from sqlalchemy.orm.exc import NoResultFound
from evernote.edam.error.ttypes import EDAMUserException
from evernote.edam.limits import constants as limits
from evernote.edam.type import ttypes
from ... import const
from ..exceptions import TTypeValidationFailed
from .. import models
from .base import BaseSync
import regex


class PushTag(BaseSync):
    """Push tags to server"""

    def push(self):
        """Push tags"""
        for tag in self.session.query(models.Tag).filter(
            models.Tag.action != const.ACTION_NONE,
        ):
            self.app.log('Pushing tag "%s" to remote server.' % tag.name)

            try:
                tag_ttype = self._create_ttype(tag)
            except TTypeValidationFailed:
                tag.action = const.ACTION_NONE
                self.app.log('tag %s skipped' % tag.name)
                continue

            if tag.action == const.ACTION_CREATE:
                self._push_new_tag(tag, tag_ttype)
            elif tag.action == const.ACTION_CHANGE:
                self._push_changed_tag(tag, tag_ttype)

        self.session.commit()

    def _create_ttype(self, tag):
        """Create tag ttype"""
        if not regex.search(limits.EDAM_TAG_NAME_REGEX, tag.name):
            raise TTypeValidationFailed()

        kwargs = dict(
            name=tag.name[:limits.EDAM_TAG_NAME_LEN_MAX].strip().encode('utf8'),
        )

        if tag.guid:
            kwargs['guid'] = tag.guid

        return ttypes.Tag(**kwargs)

    def _push_new_tag(self, tag, tag_ttype):
        """Push new tag"""
        try:
            tag_ttype = self.note_store.createTag(
                self.auth_token, tag_ttype,
            )
            tag.guid = tag_ttype.guid
            tag.action = const.ACTION_NONE
        except EDAMUserException as e:
            self.app.log(e)

    def _push_changed_tag(self, tag, tag_ttype):
        """Push changed tag"""
        try:
            self.note_store.updateTag(
                self.auth_token, tag_ttype,
            )
            tag.action = const.ACTION_NONE
        except EDAMUserException as e:
            self.app.log(e)


class PullTag(BaseSync):
    """Pull tags from server"""

    def __init__(self, *args, **kwargs):
        super(PullTag, self).__init__(*args, **kwargs)
        self._exists = []

    def pull(self):
        """Pull tags from server"""
        for tag_ttype in self.note_store.listTags(self.auth_token):
            self.app.log(
                'Pulling tag "%s" from remote server.' % tag_ttype.name)
            try:
                tag = self._update_tag(tag_ttype)
            except NoResultFound:
                tag = self._create_tag(tag_ttype)
            self._exists.append(tag.id)

        self.session.commit()
        self._remove_tags()

    def _create_tag(self, tag_ttype):
        """Create tag from server"""
        tag = models.Tag(guid=tag_ttype.guid)
        tag.from_api(tag_ttype)
        self.session.add(tag)
        self.session.commit()
        return tag

    def _update_tag(self, tag_ttype):
        """Update tag if exists"""
        tag = self.session.query(models.Tag).filter(
            models.Tag.guid == tag_ttype.guid,
        ).one()
        if tag.name != tag_ttype.name.decode('utf8'):
            tag.from_api(tag_ttype)
        return tag

    def _remove_tags(self):
        """Remove not exist tags"""
        if self._exists:
            q = (~models.Tag.id.in_(self._exists)
                & (models.Tag.action != const.ACTION_CREATE))
        else:
            q = (models.Tag.action != const.ACTION_CREATE)
        self.session.query(models.Tag).filter(q).delete(
            synchronize_session='fetch')

########NEW FILE########
__FILENAME__ = tools
from thrift.protocol import TBinaryProtocol
from thrift.transport import THttpClient
from evernote.edam.userstore import UserStore
from evernote.edam.notestore import NoteStore
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from urlparse import urlparse
from .models import Base
from ..const import HOST, DB_PATH
from ..tools import get_proxy_config
from ..specific import get_keyring
import os


def _nocase_lower(item):
    return unicode(item).lower()


def set_auth_token(token):
    get_keyring().set_password('everpad', 'oauth_token', token)


def get_auth_token():
    return get_keyring().get_password('everpad', 'oauth_token')


def get_db_session(db_path=None):
    if not db_path:
        db_path = os.path.expanduser(DB_PATH)
    engine = create_engine('sqlite:///%s' % db_path)
    Base.metadata.create_all(engine)
    Session = sessionmaker(bind=engine)
    session = Session()
    conn = session.connection()
    conn.connection.create_function('lower', 1, _nocase_lower)
    return session


def get_user_store(auth_token=None):
    if not auth_token:
        auth_token = get_auth_token()
    user_store_uri = "https://" + HOST + "/edam/user"

    user_store_http_client = THttpClient.THttpClient(user_store_uri,
            http_proxy=get_proxy_config(urlparse(user_store_uri).scheme))
    user_store_protocol = TBinaryProtocol.TBinaryProtocol(user_store_http_client)
    return UserStore.Client(user_store_protocol)


def get_note_store(auth_token=None):
    if not auth_token:
        auth_token = get_auth_token()
    user_store = get_user_store(auth_token)
    note_store_url = user_store.getNoteStoreUrl(auth_token)
    note_store_http_client = THttpClient.THttpClient(note_store_url,
            http_proxy=get_proxy_config(urlparse(note_store_url).scheme))
    note_store_protocol = TBinaryProtocol.TBinaryProtocol(note_store_http_client)
    return NoteStore.Client(note_store_protocol)

########NEW FILE########
__FILENAME__ = everpad_runner
from PyKDE4 import plasmascript
from PyKDE4.plasma import Plasma
from PyKDE4.kdeui import KIcon
from html2text import html2text
from everpad.basetypes import Note
from everpad.tools import get_provider, get_pad
import dbus


CREATE = -1
SETTINGS = -2
provider = get_provider()


class EverpadRunner(plasmascript.Runner):

    def match(self, context):
        if not context.isValid():
            return
        query = context.query()
        search = query.__str__()  # PyQt is shit
        if len(search) < 3:
            return
        if search.lower() in 'create note':
            action = Plasma.QueryMatch(self.runner)
            action.setText("Create new note in everpad")
            action.setType(Plasma.QueryMatch.ExactMatch)
            action.setIcon(KIcon("everpad"))
            action.setData(str(CREATE))
            context.addMatch(query, action)
        if search.lower() in 'settings and management':
            action = Plasma.QueryMatch(self.runner)
            action.setText("Open everpad settings")
            action.setType(Plasma.QueryMatch.ExactMatch)
            action.setIcon(KIcon("everpad"))
            action.setData(str(SETTINGS))
            context.addMatch(query, action)
        blank = dbus.Array([], signature='i')
        for note_struct in provider.find_notes(
            search, blank, blank, 0,
            1000, Note.ORDER_TITLE, -1,
        ):
            note = Note.from_tuple(note_struct)
            action = Plasma.QueryMatch(self.runner)
            action.setText(note.title)
            content = html2text(note.content)
            content = content[:200]
            action.setSubtext(content)
            action.setType(Plasma.QueryMatch.ExactMatch)
            action.setIcon(KIcon("everpad"))
            action.setData(str(note.id))
            context.addMatch(query, action)

    def run(self, context, match):
        data = match.data().toInt()[0]
        pad = get_pad()
        if data == CREATE:
            pad.create()
        elif data == SETTINGS:
            pad.settings()
        else:
            pad.open(data)


def CreateRunner(parent):
    return EverpadRunner(parent)

########NEW FILE########
__FILENAME__ = launcher
import dbus
import dbus.service


class UnityLauncher(dbus.service.Object):
    def __init__(self, app_uri, *args, **kwargs):
        self.app_uri = app_uri
        self.data = {}
        dbus.service.Object.__init__(self, *args, **kwargs)

    def update(self, data):
        self.data = data
        self.Update(self.app_uri, data)

    @dbus.service.signal(
        dbus_interface='com.canonical.Unity.LauncherEntry',
        signature=("sa{sv}")
    )
    def Update(self, app_uri, properties):
        return

    @dbus.service.method(
        dbus_interface='com.canonical.Unity.LauncherEntry',
        in_signature="", out_signature="sa{sv}",
    )
    def Query(self):
        return self.app_uri, self.data

########NEW FILE########
__FILENAME__ = lens
import sys
sys.path.insert(0, '..')
from singlet.lens import SingleScopeLens, ListViewCategory
from gi.repository import Gio, Unity, Notify
from singlet.utils import run_lens
from everpad.tools import get_provider, get_pad, resource_filename
from everpad.basetypes import Note, Tag, Notebook, Place, Resource
from everpad.const import API_VERSION
from html2text import html2text
from datetime import datetime
import dbus
import dbus.mainloop.glib
import sys
import os
import gettext
import json


path = os.path.join(os.path.dirname(__file__), '../../../i18n')
if not os.path.isdir(path):
    path =  resource_filename('share/locale/')
gettext.bindtextdomain('everpad', path)
gettext.textdomain('everpad')
_ = gettext.gettext

dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
provider = get_provider()


class EverpadLens(SingleScopeLens):

    class Meta:
        name = 'everpad'
        description = _('Everpad Lens')
        search_hint = _('Search Everpad')
        icon = 'everpad-lens'
        search_on_blank = True
        bus_name = 'net.launchpad.Unity.Lens.EverpadLens'
        bus_path = '/net/launchpad/unity/lens/everpad'

    def __init__(self):
        SingleScopeLens.__init__(self)
        provider.connect_to_signal(
            'data_changed',
            self.update_props,
            dbus_interface="com.everpad.provider",
        )
        provider.connect_to_signal(
            'settings_changed',
            self.settings_changed,
            dbus_interface="com.everpad.provider",
        )
        self.update_props()
        self._scope.connect('preview-uri', self.preview)

    def settings_changed(self, name, value):
        if name == 'search-on-home':
            self.update_props()

    def update_props(self):
        icon = Gio.ThemedIcon.new(resource_filename(
            "share/icons/unity-icon-theme/places/svg/group-recent.svg",
        ))
        tags = Unity.CheckOptionFilter.new('tags', _('Tags'), icon, True)
        for tag_struct in provider.list_tags():
            tag = Tag.from_tuple(tag_struct)
            tags.add_option(str(tag.id), tag.name, icon)
        notebooks = Unity.RadioOptionFilter.new(
            'notebooks', _('Notebooks'), icon, True,
        )
        for notebook_struct in provider.list_notebooks():
            notebook = Notebook.from_tuple(notebook_struct)
            notebooks.add_option(str(notebook.id), notebook.name, icon)
        places = Unity.RadioOptionFilter.new('places', _('Places'), icon, True)
        for place_struct in provider.list_places():
            place = Place.from_tuple(place_struct)
            places.add_option(str(place.id), place.name, icon)
        self._lens.props.filters = [notebooks, tags, places]
        self._lens.props.search_in_global = True

    def can_search_on_home_lens(self):
        return bool(int(provider.get_settings_value('search-on-home') or 1))

    pin_notes = ListViewCategory(_("Pin Notes"), 'everpad-lens')
    all_notes = ListViewCategory(_("All Notes"), 'everpad-lens')

    def search(self, search, results):
        try:
            version = provider.get_api_version()
        except (  # dbus raise some magic
            dbus.exceptions.UnknownMethodException,
            dbus.exceptions.DBusException,
        ):
            version = -1
        if version < API_VERSION:
            dim = datetime.now() - getattr(self, 'last_api_notify', datetime.now())
            if dim.seconds > 600:
                Notify.init("everpad")
                Notify.Notification.new(
                    'everpad',
                     _('Please restart everpad via indicator'),
                '').show()
                self.last_api_notify = datetime.now()
            return
        elif version > API_VERSION:
            sys.exit(0)
        if self.notebook_filter_id:
            notebooks = [self.notebook_filter_id]
        else:
            notebooks = dbus.Array([], signature='i')
        if self.place_filter_id:
            place = self.place_filter_id
        else:
            place = 0
        tags = dbus.Array(self.tag_filter_ids, signature='i')
        for note_struct in provider.find_notes(
            search, notebooks, tags, place,
            1000, Note.ORDER_TITLE, -1,
        ):
            note = Note.from_tuple(note_struct)
            results.append(json.dumps({'id': note.id, 'search': search}),
                'everpad-note', self.pin_notes if note.pinnded else self.all_notes,
                "text/html", note.title, html2text(note.content),
            '')

    def global_search(self, phrase, results):
        if self.can_search_on_home_lens():
            return super(EverpadLens, self).global_search(phrase, results)
        else:
            results.clear()


    def preview(self, scope, uri):
        obj = json.loads(uri)
        note = Note.from_tuple(provider.get_note(obj['id']))
        preview = Unity.GenericPreview.new(
            note.title, html2text(note.content), None,
        )
        edit = Unity.PreviewAction.new("edit", "Edit", None)
        image = None
        for _res in provider.get_note_resources(note.id):
            res = Resource.from_tuple(_res)
            if 'image' in res.mime:
                image = 'file://%s' % res.file_path
        if image:
            preview.props.image_source_uri = image
        edit.connect('activated', self.handle_uri)
        preview.add_action(edit)
        return preview

    def handle_uri(self, scope, uri):
        obj = json.loads(uri)
        get_pad().open_with_search_term(int(obj['id']), obj.get('search', ''))
        return self.hide_dash_response()

    def on_filtering_changed(self, scope):
        tags = scope.get_filter('tags')
        self.tag_filter_ids = map(lambda tag: int(tag.props.id),
            filter(lambda tag: tag.props.active, tags.options))
        notebook = scope.get_filter('notebooks').get_active_option()
        if notebook:
            self.notebook_filter_id = int(notebook.props.id)
        else:
            self.notebook_filter_id = None
        place = scope.get_filter('places').get_active_option()
        if place:
            self.place_filter_id = int(place.props.id)
        else:
            self.place_filter_id = None
        SingleScopeLens.on_filtering_changed(self, scope)


def main():
    run_lens(EverpadLens, sys.argv)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = tools
from functools import wraps, partial
from BeautifulSoup import BeautifulSoup
from HTMLParser import HTMLParser
from everpad.const import API_VERSION, SCHEMA_VERSION, VERSION
import dbus
import re
import sys
import os
import pkg_resources


class InterfaceWrapper(object):
    def __init__(self, get):
        self.__get = get
        self.__load()

    def __load(self):
        self.__interface = self.__get()

    def __getattr__(self, name):
        attr = getattr(self.__interface, name)
        if hasattr(attr, '__call__'):
            attr = self.__reconnect_on_fail(attr, name)
        return attr

    def __reconnect_on_fail(self, fnc, name):
        def wrapper(*args, **kwargs):
            try:
                return fnc(*args, **kwargs)
            except dbus.DBusException:
                self.__load()
                return getattr(self.__interface, name)(*args, **kwargs)
        return wrapper


def wrapper_functor(fnc):
    @wraps(fnc)
    def wrapper(*args, **kwrags):
        return InterfaceWrapper(partial(fnc, *args, **kwrags))
    return wrapper


@wrapper_functor
def get_provider(bus=None):
    if not bus:
        bus = dbus.SessionBus()
    provider = bus.get_object("com.everpad.Provider", '/EverpadProvider')
    return dbus.Interface(provider, "com.everpad.Provider")


@wrapper_functor
def get_pad(bus=None):
    if not bus:
        bus = dbus.SessionBus()
    pad = bus.get_object("com.everpad.App", "/EverpadService")
    return dbus.Interface(pad, "com.everpad.App")


def clean(text):  # from http://stackoverflow.com/questions/1707890/fast-way-to-filter-illegal-xml-unicode-chars-in-python
    illegal_unichrs = [
        (0x00, 0x08), (0x0B, 0x1F), (0x7F, 0x84), (0x86, 0x9F),
        (0xD800, 0xDFFF), (0xFDD0, 0xFDDF), (0xFFFE, 0xFFFF),
        (0x1FFFE, 0x1FFFF), (0x2FFFE, 0x2FFFF), (0x3FFFE, 0x3FFFF),
        (0x4FFFE, 0x4FFFF), (0x5FFFE, 0x5FFFF), (0x6FFFE, 0x6FFFF),
        (0x7FFFE, 0x7FFFF), (0x8FFFE, 0x8FFFF), (0x9FFFE, 0x9FFFF),
        (0xAFFFE, 0xAFFFF), (0xBFFFE, 0xBFFFF), (0xCFFFE, 0xCFFFF),
        (0xDFFFE, 0xDFFFF), (0xEFFFE, 0xEFFFF), (0xFFFFE, 0xFFFFF),
        (0x10FFFE, 0x10FFFF)
    ]

    illegal_ranges = [
        "%s-%s" % (unichr(low), unichr(high))
        for (low, high) in illegal_unichrs
        if low < sys.maxunicode
    ]
    illegal_xml_re = re.compile(u'[%s]' % u''.join(illegal_ranges))
    return illegal_xml_re.sub('', text)


def sanitize(soup=None, html=None):
    _allowed_tags = (
        'a', 'abbr', 'acronym', 'address', 'area', 'b', 'bdo',
        'big', 'blockquote', 'br', 'caption', 'center', 'cite',
        'code', 'col', 'colgroup', 'dd', 'del', 'dfn', 'div',
        'dl', 'dt', 'em', 'font', 'h1', 'h2', 'h3', 'h4', 'h5',
        'h6', 'hr', 'i', 'img', 'ins', 'kbd', 'li', 'map', 'ol',
        'p', 'pre', 'q', 's', 'samp', 'small', 'span', 'strike',
        'strong', 'sub', 'sup', 'table', 'tbody', 'td', 'tfoot',
        'th', 'thead', 'title', 'tr', 'tt', 'u', 'ul', 'var', 'xmp',
        'en-media', 'en-todo', 'en-crypt',
    )
    _disallowed_attrs = (
        'id', 'class', 'onclick', 'ondblclick', 'rel',
        'accesskey', 'data', 'dynsrc', 'tabindex', 'typeof',
        'property',
    )
    _protocols = (
        'http', 'https', 'file', 'evernote',
    )
    if not soup:
        soup = BeautifulSoup(html)
    for tag in soup.findAll(True):
        if tag.name in _allowed_tags:
            for attr in _disallowed_attrs:
                try:
                    del tag[attr]
                except KeyError:
                    pass
            try:
                if not sum(map(
                    lambda proto: tag['href'].find(proto + '://') == 0,
                _protocols)):
                    del tag['href']
            except KeyError:
                pass
        else:
            tag.hidden = True
    return clean(reduce(
         lambda txt, cur: txt + unicode(cur), soup.contents,
    u''))


def html_unescape(html):
    return HTMLParser().unescape(html)


def print_version():
    print 'Everpad version: %s' % VERSION
    print 'API version: %d' % API_VERSION
    print 'Schema version: %d' % SCHEMA_VERSION
    sys.exit(0)


def get_proxy_config(scheme):
    for fmt in ('%s_proxy', '%s_PROXY'):
        proxy = os.environ.get(fmt % scheme)
        if proxy is not None:
            return proxy
    return None


def prepare_file_path(dest, file_name):
    file_path = os.path.join(dest, file_name)
    iteration = 0
    while os.path.isfile(file_path):
        file_path = os.path.join(dest, '%d_%s' % (
            iteration, file_name,
        ))
        iteration += 1
    return file_path


def resource_filename(file_name):
    paths = map(
        lambda path: os.path.join(path, file_name),
        (
            '/opt/extras.ubuntu.com/',
            '/usr/local/',
            '/usr/',
        ),
    )
    for path in paths:
        if os.path.isfile(path):
            return path
    return pkg_resources.resource_filename(
        pkg_resources.Requirement.parse("everpad"), file_name)

########NEW FILE########
__FILENAME__ = install_dbus_services
#!/usr/bin/env python

"""
Install dbus service files in a custom prefix.
This is needed when installing in user directory, as the standard search
path is not aware of the virtualenv.
"""

from __future__ import with_statement
import sys
import os

if len(sys.argv) > 1:
    services_dir = sys.argv[1]
else:
    services_dir = "~/.local/share/dbus-1/services/"

services_dir = os.path.expanduser(services_dir)
if not os.path.isdir(services_dir):
    os.makedirs(services_dir)


service_files = {}

service_files["everpad-app.service"] = """\
[D-BUS Service]
Name=com.everpad.App
Exec={prefix}/bin/everpad
"""

service_files["everpad-provider.service"] = """\
[D-BUS Service]
Name=com.everpad.Provider
Exec={prefix}/bin/everpad-provider
"""

service_files["unity-lens-everpad.service"] = """\
[D-BUS Service]
Name=net.launchpad.Unity.Lens.EverpadLens
Exec={prefix}/bin/everpad-lens
"""

if __name__ == '__main__':
    for filename, filetpl in service_files.iteritems():
        print "Installing {} -> {}".format(filename, services_dir)
        with open(os.path.join(services_dir, filename), 'w') as f:
            f.write(filetpl.format(prefix=sys.prefix))

########NEW FILE########
__FILENAME__ = factories
from everpad.provider import models
from everpad import const
from factory.alchemy import SQLAlchemyModelFactory
import factory


class NotebookFactory(SQLAlchemyModelFactory):
    """Note factory"""
    FACTORY_FOR = models.Notebook

    guid = factory.Sequence(lambda n: 'guid{}'.format(n))
    name = factory.Sequence(lambda n: 'name{}'.format(n))
    default = False
    service_created = factory.Sequence(lambda n: n)
    service_updated = factory.Sequence(lambda n: n)
    action = const.ACTION_NONE
    stack = ''


class TagFactory(SQLAlchemyModelFactory):
    """Tag factory"""
    FACTORY_FOR = models.Tag

    guid = factory.Sequence(lambda n: 'guid{}'.format(n))
    name = factory.Sequence(lambda n: 'name{}'.format(n))
    action = const.ACTION_NONE


class ResourceFactory(SQLAlchemyModelFactory):
    """Resource factory"""
    FACTORY_FOR = models.Resource

    guid = factory.Sequence(lambda n: 'guid{}'.format(n))
    hash = factory.Sequence(lambda n: 'hash{}'.format(n))
    mime = 'text/plain'
    action = const.ACTION_NONE


class NoteFactory(SQLAlchemyModelFactory):
    """Note factory"""
    FACTORY_FOR = models.Note

    guid = factory.Sequence(lambda n: 'guid{}'.format(n))
    title = factory.Sequence(lambda n: 'title{}'.format(n))
    content = factory.Sequence(lambda n: 'content{}'.format(n))
    created = factory.Sequence(lambda n: n)
    updated = factory.Sequence(lambda n: n)
    updated_local = factory.Sequence(lambda n: n)


class PlaceFactory(SQLAlchemyModelFactory):
    """Place factory"""
    FACTORY_FOR = models.Place

    name = factory.Sequence(lambda n: 'name{}'.format(n))


def invoke_session(session):
    """Invoke sqlalchemy sessions"""
    for _factory in (
        NotebookFactory,
        TagFactory,
        ResourceFactory,
        NoteFactory,
        PlaceFactory,
    ):
        _factory.FACTORY_SESSION = session

########NEW FILE########
__FILENAME__ = test_editor
from .. import settings
from mock import MagicMock
from PySide.QtCore import QSettings, Signal, QUrl
from PySide.QtGui import QApplication
from everpad.provider.service import ProviderService
from everpad.provider.tools import get_db_session
from everpad.basetypes import (
    Note, Notebook, Tag, Resource, Place,
    NONE_ID, NONE_VAL,
)
from everpad.provider import models
from everpad.pad.editor import Editor
from everpad.pad.editor.content import set_links
from datetime import datetime
import unittest
import sys
import os


class FakeApp(QApplication):
    data_changed = Signal()

    def update(self, service):
        self.provider = service
        self.settings = QSettings('everpad-test', str(datetime.now()))


app = FakeApp(sys.argv)


CONTENTS = [
    u"<ul><li>23</li><li>567</li></ul>",
    u"<p>123</p>\xa0\xa0ok",
    u"<p>\xa0\xa0123</p><p>\xa0\xa0\xa0\xa0ok</p>",
    u"<p>hello, i'am fat</p>",
    u"<ul><li>1</li><li><ul><li>2</li><li>3</li></ul></li><li>4</li></ul>",
]

CHANGING_CONTENTS = [
    (u"<p>< a b cd</p>", u"<p>&lt; a b cd</p>"),
    (u"> a b cd", u"&gt; a b cd"),
    (u"<p>ok</p><a b cd", u"<p>ok</p>"),
]

TITLES = [
    u"&lt;&lt;ok ok ok",
    ''.join([u"verybigtitle"] * 50),
    u"ok<p asdasd",
]

SET_LINKS = [
    (u"without", u"without"),
    (u"https://github.com/nvbn/", u'<a href="https://github.com/nvbn/">https://github.com/nvbn/</a>'),
    (u"https://github.com/nvbn/ http://ya.ru/", u'<a href="https://github.com/nvbn/">https://github.com/nvbn/</a> <a href="http://ya.ru/">http://ya.ru/</a>'),
    (u"<p>https://github.com/nvbn/</p>", u"<p>https://github.com/nvbn/</p>"),
]


if 'test_editor' in os.environ:
    class EditorTestCase(unittest.TestCase):
        def setUp(self):
            self.service = ProviderService()
            self.service._session = get_db_session()
            models.Note.session = self.service._session
            self.app = app
            self.app.update(self.service)
            notebook = Notebook.from_tuple(
                self.service.create_notebook('test', None),
            )
            self.note = Note.from_tuple(self.service.create_note(Note(
                id=NONE_ID,
                title='New note',
                content="New note content",
                tags=[],
                notebook=notebook.id,
                created=NONE_VAL,
                updated=NONE_VAL,
                place='',
            ).struct))

        def tearDown(self):
            if hasattr(self, 'editor'):
                self.app.data_changed.disconnect(
                    self.editor.init_alternatives,
                )
            del self.app.provider
            del self.app

        def test_content_nochange(self):
            """Test content nochange"""
            self.editor = Editor(self.note)
            self.assertEqual(
                self.editor.note_edit.content,
                "New note content",
            )
            for content in CONTENTS:
                self.editor.note_edit.content = content
                self.assertEqual(
                    self.editor.note_edit.content,
                    content,
                )

        def test_content_changing(self):
            """Test content changing"""
            self.editor = Editor(self.note)
            for prev, current in CHANGING_CONTENTS:
                self.editor.note_edit.content = prev
                self.assertEqual(
                    self.editor.note_edit.content,
                    current,
                )

        def test_title_nochange(self):
            """Test title nochange"""
            self.editor = Editor(self.note)
            self.assertEqual(
                self.editor.note_edit.title,
                "New note",
            )
            for title in TITLES:
                self.editor.note_edit.title = title
                self.assertEqual(
                    self.editor.note_edit.title,
                    title,
                )

        def test_set_links(self):
            """Test set links"""
            for orig, result in SET_LINKS:
                self.assertEqual(
                    set_links(orig), result,
                )

        def test_not_broken_note_links(self):
            """Test content nochange"""
            content = '<a href="evernote:///view/123/123/123/">note link</a>'
            self.note.content = content
            self.editor = Editor(self.note)
            self.assertEqual(
                self.editor.note_edit.content,
                content,
            )

        def test_open_note_links(self):
            """Test open note links"""
            guid = 'guid'
            note = Note(
                id=123,
            )

            self.app.open = MagicMock()
            self.service.get_note_by_guid = MagicMock(
                return_value=note.struct,
            )

            link = "evernote:///view/123/123/{guid}/123/".format(
                guid=guid,
            )
            self.editor = Editor(self.note)
            self.editor.note_edit.link_clicked(QUrl(link))

            self.assertEqual(
                self.service.get_note_by_guid.call_args[0][0], guid,
            )
            self.assertEqual(
                self.app.open.call_args[0][0].id, note.id,
            )
            del self.app.open

########NEW FILE########
__FILENAME__ = test_service
# -*- coding: utf-8 -*-
from .. import settings

from dbus.exceptions import DBusException
from mock import MagicMock
from everpad.provider.service import ProviderService
from everpad.provider.tools import get_db_session
from everpad import const
from everpad.provider import models
import unittest
import dbus
import everpad.basetypes as btype
from .. import factories


class FindTestCase(unittest.TestCase):
    """Find notes method test case"""

    def setUp(self):
        self._create_service()
        self._create_notebooks()
        self._create_notes()

    def _create_notes(self):
        """Create notes"""
        notes = [
            self.service.create_note(btype.Note(
                title='New note',
                content="New note content",
                tags=['ab', 'cd'],
                notebook=self.notebook.id,
                created=const.NONE_VAL,
                updated=const.NONE_VAL,
                place='first',
                pinnded=False,
            ).struct),
            self.service.create_note(btype.Note(
                title='Old note',
                content="Old note content",
                tags=['ef', 'gh'],
                notebook=self.notebook2.id,
                created=const.NONE_VAL,
                updated=const.NONE_VAL,
                place='second',
                pinnded=False,
            ).struct),
            self.service.create_note(btype.Note(
                title='not',
                content="oke",
                tags=['ab', 'gh'],
                notebook=self.notebook.id,
                created=const.NONE_VAL,
                updated=const.NONE_VAL,
                place='second',
                pinnded=True,
            ).struct),
            self.service.create_note(btype.Note(
                title=u'Заметка',
                content=u"Заметка",
                tags=[u'тэг'],
                notebook=self.notebook.id,
                created=const.NONE_VAL,
                updated=const.NONE_VAL,
                place=u'место',
                pinnded=False,
            ).struct),
            self.service.create_note(btype.Note(
                title=u'заметка',
                content=u"заметка",
                tags=[u'тэг'],
                notebook=self.notebook.id,
                created=const.NONE_VAL,
                updated=const.NONE_VAL,
                place=u'место',
                pinnded=False,
            ).struct),
        ]
        self.notes = btype.Note.list << [
            self.service.update_note(note) for note in notes
        ]

    def _create_notebooks(self):
        """Create notebooks"""
        self.notebook =\
            btype.Notebook << self.service.create_notebook('test', None)
        self.notebook2 =\
            btype.Notebook << self.service.create_notebook('test2', None)
        self.notebook3 =\
            btype.Notebook << self.service.create_notebook(u'Блокнот', None)

    def _create_service(self):
        """Create service"""
        self.service = ProviderService()
        self.service._session = get_db_session()
        models.Note.session = self.service._session  # TODO: fix that shit

    def _to_ids(self, items):
        return set(map(lambda item: item.id, items))

    def _find(self, *args, **kwargs):
        return btype.Note.list << self.service.find_notes(*args, **kwargs)

    def test_by_words(self):
        """Test notes find by words"""
        all_notes = self._find(
            'not', dbus.Array([], signature='i'),
            dbus.Array([], signature='i'), 0,
            100, const.ORDER_UPDATED_DESC, -1,
        )
        self.assertItemsEqual(
            self._to_ids(all_notes), self._to_ids(self.notes[:-2]),
        )
        two = self._find(
            'note', dbus.Array([], signature='i'),
            dbus.Array([], signature='i'), 0,
            100, const.ORDER_UPDATED_DESC, -1,
        )
        self.assertItemsEqual(
            self._to_ids(two), self._to_ids(self.notes[:2]),
        )
        blank = self._find(
            'not note', dbus.Array([], signature='i'),
            dbus.Array([], signature='i'), 0,
            100, const.ORDER_UPDATED_DESC, -1,
        )
        self.assertEqual(len(blank), 0)

    def test_by_tags(self):
        """Test note find by tags"""
        tags = btype.Tag.list << self.service.list_tags()
        first_last = self._find(
            '', dbus.Array([], signature='i'),
            [tags[0].id], 0, 100, const.ORDER_UPDATED_DESC, -1,
        )
        self.assertItemsEqual(
            self._to_ids(first_last), [self.notes[0].id, self.notes[2].id],
        )
        second = self._find(
            '', dbus.Array([], signature='i'),
            [tags[2].id], 0, 100,
            const.ORDER_UPDATED_DESC, -1,
        )
        self.assertItemsEqual(
            self._to_ids(second), [self.notes[1].id],
        )
        all_notes = self._find(
            '', dbus.Array([], signature='i'),
            map(lambda tag: tag.id, tags), 0, 100,
            const.ORDER_UPDATED_DESC, -1,
        )
        self.assertItemsEqual(
            self._to_ids(all_notes), self._to_ids(self.notes),
        )

    def test_by_notebooks(self):
        """Test find note by notebooks"""
        all_notebooks = self._find(
            '', self._to_ids([self.notebook, self.notebook2]),
            dbus.Array([], signature='i'), 0,
            100, const.ORDER_UPDATED_DESC, -1,
        )
        self.assertItemsEqual(
            self._to_ids(all_notebooks), self._to_ids(self.notes),
        )
        second = self._find(
            '', [self.notebook2.id],
            dbus.Array([], signature='i'), 0,
            100, const.ORDER_UPDATED_DESC, -1,
        )
        self.assertItemsEqual(
            self._to_ids(second), [self.notes[1].id],
        )

    def test_combine(self):
        """Test find by combination"""
        places = btype.Place.list << self.service.list_places()
        tags = btype.Tag.list << self.service.list_tags()
        first = self._find(
            'new', [self.notebook.id], [tags[0].id], places[0].id,
            100, const.ORDER_UPDATED_DESC, False,
        )
        self.assertItemsEqual(
            self._to_ids(first), [self.notes[0].id],
        )
        last = self._find(
            'oke', [self.notebook.id], [tags[0].id], places[1].id,
            100, const.ORDER_UPDATED_DESC, True,
        )
        self.assertItemsEqual(
            self._to_ids(last), [self.notes[2].id],
        )

    def test_unicode_ignorecase(self):
        """Test unicode ignorecase"""
        all_notes = self._find(
            u'заметка', dbus.Array([], signature='i'),
            dbus.Array([], signature='i'), 0,
            100, const.ORDER_UPDATED_DESC, -1,
        )
        self.assertItemsEqual(
            self._to_ids(all_notes), self._to_ids(self.notes[-2:]),
        )


class MethodsCase(unittest.TestCase):
    """Case for dbus shortcuts"""

    def setUp(self):
        self.service = ProviderService()
        self.session = get_db_session()
        self.service._session = self.session
        models.Note.session = self.session
        self.service.qobject = MagicMock()
        self.service.app = MagicMock()
        self.service.sync = MagicMock()
        factories.invoke_session(self.session)

    def tearDown(self):
        self.session.flush()

    def _create_note(self, **kwargs):
        """Create note"""
        note = factories.NoteFactory.create(
            action=const.ACTION_NONE,
            **kwargs
        )
        self.session.commit()
        return note

    def test_get_note(self):
        """Test get note method"""
        note = self._create_note()
        remote_note = btype.Note << self.service.get_note(note.id)
        self.assertEqual(remote_note.title, note.title)

    def test_get_note_by_guid(self):
        """Test get note method"""
        note = self._create_note(guid='guid')
        remote_note = btype.Note << self.service.get_note_by_guid(note.guid)
        self.assertEqual(remote_note.title, note.title)

    def test_get_note_alternatives(self):
        """Test get note alternatives"""
        note = self._create_note(guid='guid')
        alternative = factories.NoteFactory.create(
            guid='guid',
            action=const.ACTION_CONFLICT,
            conflict_parent_id=note.id,
        )
        self.session.commit()
        remote_notes = btype.Note.list << self.service.get_note_alternatives(
            note.id,
        )
        self.assertEqual(remote_notes[0].id, alternative.id)

    def test_list_notebooks(self):
        """Test list notebooks method"""
        notebooks = factories.NotebookFactory.create_batch(
            10, action=const.ACTION_NONE,
        )
        self.session.commit()
        notebooks = [notebook.id for notebook in notebooks]

        remote_notebooks = btype.Notebook.list << self.service.list_notebooks()
        ids = [notebook.id for notebook in remote_notebooks]

        self.assertItemsEqual(notebooks, ids)

    def test_get_notebook(self):
        """Test get notebook method"""
        notebook = factories.NotebookFactory.create(
            action=const.ACTION_NONE,
        )
        deleted_notebook = factories.NotebookFactory(
            action=const.ACTION_DELETE,
        )
        self.session.commit()

        remote_notebook = btype.Notebook << self.service.get_notebook(
            notebook.id,
        )
        self.assertEqual(notebook.name, remote_notebook.name)

        with self.assertRaises(DBusException):
            self.service.get_notebook(
                deleted_notebook.id,
            )

    def test_get_notebook_notes_count(self):
        """Test get notebook notes count method"""
        notebook = factories.NotebookFactory.create(
            action=const.ACTION_NONE,
        )
        factories.NoteFactory.create_batch(
            10, action=const.ACTION_NONE,
            notebook=notebook,
        )
        self.session.commit()
        self.assertEqual(
            self.service.get_notebook_notes_count(notebook.id), 10,
        )

    def test_update_notebook(self):
        """Test update notebook method"""
        notebook = factories.NotebookFactory.create(
            action=const.ACTION_NONE,
        )
        self.session.commit()
        new_name = 'name'
        notebook_btype = btype.Notebook.from_obj(notebook)
        notebook_btype.name = new_name
        notebook_btype = btype.Notebook << self.service.update_notebook(
            notebook_btype.struct,
        )
        self.assertEqual(notebook_btype.name, new_name)
        self.assertEqual(notebook.name, new_name)

    def test_delete_notebook(self):
        """Test delete notebook"""
        notebook = factories.NotebookFactory.create(
            name='notebook',
            action=const.ACTION_NONE,
        )
        self.session.commit()
        self.service.delete_notebook(notebook.id)
        self.assertEqual(notebook.action, const.ACTION_DELETE)

    def test_list_tags(self):
        """Test list tags"""
        tags = factories.TagFactory.create_batch(
            10, action=const.ACTION_NONE,
        )
        self.session.commit()
        tags = [tag.id for tag in tags]
        remote_tags = btype.Tag.list << self.service.list_tags()
        tags_ids = [tag.id for tag in remote_tags]
        self.assertItemsEqual(tags_ids, tags)

    def test_get_tag_notes_count(self):
        """Test get tag notes count method"""
        tag = factories.TagFactory.create(
            action=const.ACTION_NONE,
        )
        factories.NoteFactory.create_batch(
            10, action=const.ACTION_NONE,
            tags=[tag],
        )
        self.session.commit()
        self.assertEqual(
            self.service.get_tag_notes_count(tag.id), 10,
        )

    def test_delete_tag(self):
        """Test delete tag"""
        tag = factories.TagFactory.create(
            action=const.ACTION_NONE,
        )
        self.session.commit()
        self.service.delete_tag(tag.id)
        self.assertEqual(tag.action, const.ACTION_DELETE)

    def test_update_tag(self):
        """Test update tag method"""
        tag = factories.TagFactory.create(
            action=const.ACTION_NONE,
        )
        self.session.commit()
        new_name = 'name'
        tag_btype = btype.Tag.from_obj(tag)
        tag_btype.name = new_name
        tag_btype = btype.Tag << self.service.update_tag(
            tag_btype.struct,
        )
        self.assertEqual(tag_btype.name, new_name)
        self.assertEqual(tag.name, new_name)

    def test_create_note(self):
        """Test create note"""
        notebook = factories.NotebookFactory.create(default=True)
        self.session.commit()

        title = 'note'
        note_btype = btype.Note(
            title=title,
            tags=[],
            id=const.NONE_ID,
            notebook=notebook.id,
        )

        note_btype = btype.Note << self.service.create_note(
            btype.Note >> note_btype,
        )
        note = self.session.query(models.Note).filter(
            models.Note.id == note_btype.id,
        ).one()

        self.assertEqual(note_btype.title, title)
        self.assertEqual(note.title, title)

    def test_update_note(self):
        """Test update note"""
        notebook = factories.NotebookFactory.create(default=True)
        self.session.commit()

        note = self._create_note(
            notebook_id=notebook.id,
        )

        new_title = 'title'

        note_btype = btype.Note.from_obj(note)
        note_btype.title = new_title

        note_btype = btype.Note << self.service.update_note(
            note_btype.struct,
        )
        note = self.session.query(models.Note).filter(
            models.Note.id == note_btype.id,
        ).one()

        self.assertEqual(note_btype.title, new_title)
        self.assertEqual(note.title, new_title)

    def test_get_note_resources(self):
        """Test get note resources"""
        note = self._create_note()

        resource = factories.ResourceFactory.create(
            file_name='name',
            action=const.ACTION_NONE,
            note_id=note.id,
        )
        self.session.commit()

        resources_btype = btype.Resource.list << self.service.get_note_resources(
            note.id,
        )

        self.assertEqual(resources_btype[0].file_name, resource.file_name)

    def test_update_note_resources(self):
        """Test update note resources"""
        note = self._create_note()

        resource = btype.Resource(
            file_name='test',
        )

        self.service.update_note_resources(
            note.id, btype.Resource.list >> [resource],
        )

        resource = self.session.query(models.Resource).one()
        self.assertEqual(resource.file_name, 'test')

    def test_delete_note(self):
        """Test delete note"""
        note = self._create_note()

        self.service.delete_note(note.id)

        self.assertEqual(note.action, const.ACTION_DELETE)

    def test_create_notebook(self):
        """Test create notebook"""
        notebook_btype =\
            btype.Notebook << self.service.create_notebook('test', 'test')

        notebook = self.session.query(models.Notebook).filter(
            models.Notebook.id == notebook_btype.id,
        ).one()
        self.assertEqual(notebook.name, 'test')

    def test_authenticate(self):
        """Test authenticate"""
        self.service.authenticate('test')
        self.service.qobject\
            .remove_authenticate_signal.emit.assert_called_once_with()
        self.service.qobject\
            .authenticate_signal.emit.assert_called_once_with('test')

    def test_remove_authentication(self):
        """Test remove authentication"""
        self.service.remove_authentication()
        self.service.qobject\
            .remove_authenticate_signal.emit.assert_called_once_with()

    def test_list_places(self):
        """Test list places"""
        places = factories.PlaceFactory.create_batch(10)
        self.session.commit()
        place_ids = [place.id for place in places]
        places_btype = btype.Place.list << self.service.list_places()
        for place_btype in places_btype:
            self.assertIn(place_btype.id, place_ids)

    def test_share_note(self):
        """Test share note"""
        note = self._create_note()

        self.service.share_note(note.id)
        self.assertEqual(note.share_status, const.SHARE_NEED_SHARE)
        self.service.sync.assert_called_once_with()

    def test_stop_sharing_note(self):
        """Test stop sharing note"""
        note = self._create_note(share_status=const.SHARE_SHARED)

        self.service.stop_sharing_note(note.id)
        self.assertEqual(note.share_status, const.SHARE_NEED_STOP)
        self.service.sync.assert_called_once_with()

    def test_is_first_synced(self):
        """Test is first synced"""
        self.assertFalse(self.service.is_first_synced())

########NEW FILE########
__FILENAME__ = test_sync
# -*- coding: utf-8 -*-
from .. import settings
from everpad.provider.sync import note, notebook, tag
from everpad.provider.tools import get_db_session
from everpad.provider import models
from everpad import const
from evernote.edam.type import ttypes
from evernote import edam
from mock import MagicMock
from .. import factories
import unittest
import os


resource_path = os.path.join(os.path.dirname(__file__), '../test.png')


class BaseSyncCase(unittest.TestCase):
    """Base sync case"""
    sync_cls = None

    def setUp(self):
        self._create_db_session()
        self._create_note_store()
        self._create_user_store()
        self._create_sync()

    def tearDown(self):
        self.session.flush()

    def _create_db_session(self):
        """Create database session"""
        self.session = get_db_session()
        factories.invoke_session(self.session)

    def _create_note_store(self):
        """Create note store mock"""
        self.note_store = MagicMock()

    def _create_user_store(self):
        """Create user store mock"""
        self.user_store = MagicMock()

    def _create_sync(self):
        """Create sync object"""
        self.TOKEN = 'TOKEN'
        self.sync = self.sync_cls(
            self.TOKEN,
            self.session,
            self.note_store,
            self.user_store,
        )
        self.sync.app = MagicMock()


class PushNotebookCase(BaseSyncCase):
    """Test notebook sync"""
    sync_cls = notebook.PushNotebook

    def test_push_new_notebook(self):
        """Test push new notebook"""
        notebook = factories.NotebookFactory.create(
            action=const.ACTION_CREATE,
            stack='stack',
        )

        guid = 'guid'
        self.note_store.createNotebook.return_value.guid = guid

        self.sync.push()
        pushed = self.note_store.createNotebook.call_args_list[0][0][1]

        self.assertEqual(pushed.name, notebook.name)
        self.assertEqual(pushed.stack, notebook.stack)

        self.assertEqual(notebook.guid, guid)

    def test_push_changed_notebook(self):
        """Test push changed notebook"""
        notebook = factories.NotebookFactory.create(
            action=const.ACTION_CHANGE,
            stack='123',
        )
        self.sync.push()
        pushed = self.note_store.updateNotebook.call_args_list[0][0][1]
        self.assertEqual(pushed.name, notebook.name)
        self.assertEqual(pushed.stack, notebook.stack)

    def _base_test_push_notebook_duplicates(self, action):
        """Base test push notebook duplicates"""
        notebook = factories.NotebookFactory.create(
            name='name',
            action=action,
        )
        original = factories.NotebookFactory.create(
            name='name',
            action=const.ACTION_NONE,
        )
        factories.NoteFactory.create(
            notebook=notebook,
        )
        factories.NoteFactory.create(
            notebook=original,
        )
        self.sync.push()
        self.assertItemsEqual(
            self.session.query(models.Notebook).all(), [original],
        )
        self.assertEqual(self.session.query(models.Note).filter(
            models.Note.notebook == original
        ).count(), 2)

    def test_duplicates_on_push_new(self):
        """Test duplicates on pushing new notebook"""
        self.note_store.createNotebook.side_effect =\
            edam.error.ttypes.EDAMUserException
        self._base_test_push_notebook_duplicates(const.ACTION_CREATE)

    def test_duplicates_on_push_changed(self):
        """Test duplicates on pushing changed notebook"""
        self.note_store.updateNotebook.side_effect =\
            edam.error.ttypes.EDAMUserException
        self._base_test_push_notebook_duplicates(const.ACTION_CHANGE)


class PullNotebookCase(BaseSyncCase):
    """Test notebook sync"""
    sync_cls = notebook.PullNotebook

    def test_pull_new_notebook(self):
        """Test pull new notebook"""
        notebook_name = 'name'
        self.note_store.listNotebooks.return_value = [
            ttypes.Notebook(name=notebook_name),
        ]
        self.sync.pull()
        notebook = self.session.query(models.Notebook).one()
        self.assertEqual(notebook.name, notebook_name)

    def test_pull_updated_notebook(self):
        """Test pull updated notebook"""
        notebook = factories.NotebookFactory.create(
            service_updated=0,
        )
        notebook_name = 'name*'
        self.note_store.listNotebooks.return_value = [ttypes.Notebook(
            name=notebook_name, guid=notebook.guid, serviceUpdated=1,
        )]
        self.sync.pull()
        self.assertEqual(notebook.name, notebook_name)

    def test_pull_not_updated_notebook(self):
        """Test pull not updated notebook"""
        notebook = factories.NotebookFactory.create(
            service_updated=2,
        )
        notebook_name = 'name*'
        self.note_store.listNotebooks.return_value = [ttypes.Notebook(
            name=notebook_name, guid=notebook.guid, serviceUpdated=1,
        )]
        self.sync.pull()
        self.assertNotEqual(notebook.name, notebook_name)

    def test_delete_after_pull(self):
        """Test delete notebooks after pull"""
        factories.NotebookFactory.create(
            action=const.ACTION_NONE,
        )
        self.note_store.listNotebooks.return_value = []
        self.sync.pull()
        self.assertEqual(self.session.query(models.Notebook).count(), 0)


class PushTagCase(BaseSyncCase):
    """Test tag sync"""
    sync_cls = tag.PushTag

    def test_push_new_tag(self):
        """Test push new tag"""
        guid = 'guid'
        tag = factories.TagFactory.create(
            action=const.ACTION_CREATE,
        )
        self.note_store.createTag.return_value.guid = guid
        self.sync.push()
        self.assertEqual(tag.guid, guid)
        self.assertEqual(
            self.note_store.createTag.call_args_list[0][0][1].name,
            tag.name,
        )

    def test_push_changed_tag(self):
        """Test push changed tag"""
        tag = factories.TagFactory.create(
            action=const.ACTION_CHANGE,
        )
        self.sync.push()
        pushed = self.note_store.updateTag.call_args_list[0][0][1]
        self.assertEqual(pushed.name, tag.name)


class PullTagCase(BaseSyncCase):
    """Test tag sync"""
    sync_cls = tag.PullTag

    def test_pull_new_tag(self):
        """Test pull new tags"""
        tag_name = 'name'
        guid = 'guid'
        self.note_store.listTags.return_value = [ttypes.Tag(
            name=tag_name, guid=guid,
        )]

        self.sync.pull()
        tag = self.session.query(models.Tag).one()

        self.assertEqual(tag.name, tag_name)
        self.assertEqual(tag.guid, guid)

    def test_pull_changed_tag(self):
        """Test pull changed tags"""
        tag = factories.TagFactory.create(
            action=const.ACTION_NONE,
        )
        tag_name = 'name*'
        self.note_store.listTags.return_value = [ttypes.Tag(
            name=tag_name, guid=tag.guid,
        )]
        self.sync.pull()
        self.assertEqual(tag.name, tag_name)

    def test_delete_after_pull(self):
        """Test delete non exists after pull"""
        factories.TagFactory.create(
            action=const.ACTION_NONE,
        )
        self.note_store.listTags.return_value = []
        self.sync.pull()
        self.assertEqual(self.session.query(models.Tag).count(), 0)


class PushNoteCase(BaseSyncCase):
    """Push note case"""
    sync_cls = note.PushNote

    def _create_resources(self, note):
        """Create resources"""
        resource_path = '/tmp/resource'
        with open(resource_path, 'w') as resource_file:
            resource_file.write('test')
        file_name = 'resource'
        factories.ResourceFactory(
            note_id=note.id,
            file_name=file_name,
            file_path=resource_path,
        )
        return file_name

    def test_note_content_formatting(self):
        """Test note content formatting.

        This tests that the content from the Note model object continues the
        same after converting it to a ttype.
        """
        content = """Some
            foo bar
            content."""

        guid = 'guid'
        note = models.Note(
            title='note',
            content=content,
            action=const.ACTION_CREATE,
        )
        self.session.add(note)
        self.session.commit()

        note_ttype = self.sync._create_ttype(note)
        note.from_api(note_ttype, self.session)
        self.assertEqual(note.content, content)

    def test_push_new_note(self):
        """Test push new note"""
        guid = 'guid'
        note = factories.NoteFactory.create(
            action=const.ACTION_CREATE,
        )
        self.session.commit()
        file_name = self._create_resources(note)
        self.note_store.createNote.return_value.guid = guid
        self.sync.push()

        self.assertEqual(note.guid, guid)

        pushed = self.note_store.createNote.call_args_list[0][0][1]

        self.assertEqual(pushed.title, note.title)
        self.assertEqual(pushed.resources[0].attributes.fileName, file_name)

    def test_push_changed_note(self):
        """Test push changed note"""
        note = factories.NoteFactory.create(
            action=const.ACTION_CHANGE,
        )
        self.session.commit()

        file_name = self._create_resources(note)

        self.sync.push()

        pushed = self.note_store.updateNote.call_args_list[0][0][1]

        self.assertEqual(pushed.title, note.title)
        self.assertEqual(pushed.resources[0].attributes.fileName, file_name)

    def test_delete_note(self):
        """Test delete note"""
        note = factories.NoteFactory.create(
            action=const.ACTION_DELETE,
        )
        self.sync.push()
        self.assertEqual(
            self.note_store.deleteNote.call_args_list[0][0][1],
            note.guid,
        )

    def test_push_for_sharing(self):
        """Test push for sharing"""
        note = factories.NoteFactory.create(
            action=const.ACTION_CREATE,
            share_status=const.SHARE_NEED_SHARE,
        )
        self.note_store.createNote.return_value.guid = 'guid'
        self.sync.push()
        self.assertEqual(note.share_status, const.SHARE_SHARED)
        self.assertIsNotNone(note.share_url)

    def test_push_for_stop_sharing(self):
        """Test push for stop sharing"""
        note = factories.NoteFactory.create(
            action=const.ACTION_CREATE,
            share_status=const.SHARE_NEED_STOP,
        )
        self.note_store.createNote.return_value.guid = 'guid'
        self.sync.push()
        self.assertEqual(note.share_status, const.SHARE_NONE)


class PullNoteCase(BaseSyncCase):
    """Pull note case"""
    sync_cls = note.PullNote

    def setUp(self):
        super(PullNoteCase, self).setUp()
        self._create_default_notebook()

    def _create_default_notebook(self):
        """Create default notebook"""
        self.notebook = factories.NotebookFactory.create(
            default=True,
        )

    def _create_remote_note(self, note_title, note_guid):
        """Create remote note"""
        remote_note = ttypes.Note(
            title=note_title,
            guid=note_guid,
            content='<en-note></en-note>',
            notebookGuid=self.notebook.guid,
            attributes=ttypes.NoteAttributes(),
            updated=1,
            resources=[ttypes.Resource(
                guid='file',
                mime='text',
                attributes=ttypes.ResourceAttributes(
                    fileName='file',
                ),
                data=ttypes.Data(
                    body='',
                    bodyHash='',
                ),
            )],
        )

        search_result = MagicMock()
        search_result.totalNotes = 1
        search_result.startIndex = 0
        search_result.notes = [remote_note]
        self.note_store.findNotes.return_value = search_result
        self.note_store.getNote.return_value = remote_note

        return remote_note

    def test_pull_new_note(self):
        """Test pull new note"""
        note_title = 'title'
        note_guid = 'guid'
        self._create_remote_note(note_title, note_guid)

        self.sync.pull()

        note = self.session.query(models.Note).one()

        self.assertEqual(note.guid, note_guid)
        self.assertEqual(note.title, note_title)
        self.assertEqual(self.session.query(models.Resource).count(), 1)

    def test_pull_changed_note(self):
        """Test pull changed note"""
        note = factories.NoteFactory.create(
            updated=0,
        )
        self._create_remote_note(note.title, note.guid)
        self.sync.pull()
        self.assertEqual(note.title, note.title)
        self.assertEqual(self.session.query(models.Resource).count(), 1)

    def test_delete_after_pull(self):
        """Test delete non exists note after pull"""
        note = factories.NoteFactory.create(
            action=const.ACTION_NONE,
        )
        search_result = MagicMock()
        search_result.totalNotes = 0
        search_result.startIndex = 0
        search_result.notes = []
        self.note_store.findNotes.return_value = search_result
        self.sync.pull()
        self.assertEqual(self.session.query(models.Note).count(), 0)

    def test_pull_with_conflict(self):
        """Test pull with conflict"""
        note = factories.NoteFactory.create(
            updated=0,
            action=const.ACTION_CHANGE,
        )
        self.session.add(note)
        self.session.commit()
        self._create_remote_note(note.title, note.guid)
        self.sync.pull()
        self.assertEqual(self.session.query(models.Note).filter(
            models.Note.action == const.ACTION_CONFLICT
        ).count(), 1)

    def test_pull_shared(self):
        """Test pull shared note"""
        note_guid = 'guid'
        note_title = 'title'

        note = self._create_remote_note(note_title, note_guid)
        note.attributes.shareDate = 1

        self.note_store.shareNote = MagicMock()
        self.note_store.shareNote.return_value = 'url'

        self.sync.pull()

        local_note = self.session.query(models.Note).one()

        self.assertEqual(local_note.share_status, const.SHARE_SHARED)

    def test_pull_not_shared(self):
        """Test pull not shared note"""
        note_guid = 'guid'
        note_title = 'title'

        factories.NoteFactory.create(
            title=note_title,
            guid=note_guid,
            updated=0,
            action=const.ACTION_NONE,
            share_status=const.SHARE_SHARED,
        )

        note = self._create_remote_note(note_title, note_guid)
        note.attributes.shareDate = None

        self.sync.pull()

        local_note = self.session.query(models.Note).one()

        self.assertEqual(local_note.share_status, const.SHARE_NONE)

########NEW FILE########
__FILENAME__ = ci_local
HOST = 'sandbox.evernote.com'
CONSUMER_KEY = 'nvbn-1422'
CONSUMER_SECRET = 'c17c0979d0054310'
DB_PATH = ':memory:'
TOKEN = 'S=s1:U=6604d:E=145758f3852:C=13e1dde0c54:P=1cd:A=en-devtoken:V=2:H=d2b720cdb06c99a105f937e669ebfc67'

########NEW FILE########
__FILENAME__ = dist
HOST = 'sandbox.evernote.com'
CONSUMER_KEY = ''
CONSUMER_SECRET = ''
DB_PATH = ':memory:'
TOKEN = ''

########NEW FILE########
__FILENAME__ = test_basetypes
from everpad.basetypes import Tag, DbusSendable
import unittest


class TestBaseTypes(unittest.TestCase):
    def test_signature(self):
        class Fake(DbusSendable):
            fields = (
                ('id', 'i'),
                ('name', 's'),
            )
        self.assertEqual(
            Fake.signature, '(is)',
            'generate signature',
        )

    def test_serialise(self):
        class Fake(object):
            id = 0
            name = '123'
        tag = Tag.from_obj(Fake())
        self.assertEqual(
            tag.struct, (0, '123'),
            'serialise to struct',
        )

    def test_load(self):
        tag = Tag.from_tuple((0, '123'))
        self.assertEqual(
            tag.name, '123',
            'load from struct',
        )

    def test_give(self):
        class Fake(object):
            id = 0
            @property
            def id_dbus(self):
                return self.id

            @id_dbus.setter
            def id_dbus(self, val):
                self.id = val + 12
        tag = Tag.from_tuple((0, '123'))
        obj = Fake()
        tag.give_to_obj(obj)
        self.assertEqual(
            obj.id, 12,
            'give data to object',
        )

########NEW FILE########
__FILENAME__ = TBase
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from thrift.Thrift import *
from thrift.protocol import TBinaryProtocol
from thrift.transport import TTransport

try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None

class TBase(object):
  __slots__ = []

  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
              for key in self.__slots__ ]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True
    
  def __ne__(self, other):
    return not (self == other)
  
  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStruct(self, self.thrift_spec)

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStruct(self, self.thrift_spec)

class TExceptionBase(Exception):
  # old style class so python2.4 can raise exceptions derived from this
  #  This can't inherit from TBase because of that limitation.
  __slots__ = []
  
  __repr__ = TBase.__repr__.im_func
  __eq__ = TBase.__eq__.im_func
  __ne__ = TBase.__ne__.im_func
  read = TBase.read.im_func
  write = TBase.write.im_func
  

########NEW FILE########
__FILENAME__ = TBinaryProtocol
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from TProtocol import *
from struct import pack, unpack

class TBinaryProtocol(TProtocolBase):

  """Binary implementation of the Thrift protocol driver."""

  # NastyHaxx. Python 2.4+ on 32-bit machines forces hex constants to be
  # positive, converting this into a long. If we hardcode the int value
  # instead it'll stay in 32 bit-land.

  # VERSION_MASK = 0xffff0000
  VERSION_MASK = -65536

  # VERSION_1 = 0x80010000
  VERSION_1 = -2147418112

  TYPE_MASK = 0x000000ff

  def __init__(self, trans, strictRead=False, strictWrite=True):
    TProtocolBase.__init__(self, trans)
    self.strictRead = strictRead
    self.strictWrite = strictWrite

  def writeMessageBegin(self, name, type, seqid):
    if self.strictWrite:
      self.writeI32(TBinaryProtocol.VERSION_1 | type)
      self.writeString(name)
      self.writeI32(seqid)
    else:
      self.writeString(name)
      self.writeByte(type)
      self.writeI32(seqid)

  def writeMessageEnd(self):
    pass

  def writeStructBegin(self, name):
    pass

  def writeStructEnd(self):
    pass

  def writeFieldBegin(self, name, type, id):
    self.writeByte(type)
    self.writeI16(id)

  def writeFieldEnd(self):
    pass

  def writeFieldStop(self):
    self.writeByte(TType.STOP);

  def writeMapBegin(self, ktype, vtype, size):
    self.writeByte(ktype)
    self.writeByte(vtype)
    self.writeI32(size)

  def writeMapEnd(self):
    pass

  def writeListBegin(self, etype, size):
    self.writeByte(etype)
    self.writeI32(size)

  def writeListEnd(self):
    pass

  def writeSetBegin(self, etype, size):
    self.writeByte(etype)
    self.writeI32(size)

  def writeSetEnd(self):
    pass

  def writeBool(self, bool):
    if bool:
      self.writeByte(1)
    else:
      self.writeByte(0)

  def writeByte(self, byte):
    buff = pack("!b", byte)
    self.trans.write(buff)

  def writeI16(self, i16):
    buff = pack("!h", i16)
    self.trans.write(buff)

  def writeI32(self, i32):
    buff = pack("!i", i32)
    self.trans.write(buff)

  def writeI64(self, i64):
    buff = pack("!q", i64)
    self.trans.write(buff)

  def writeDouble(self, dub):
    buff = pack("!d", dub)
    self.trans.write(buff)

  def writeString(self, str):
    self.writeI32(len(str))
    self.trans.write(str)

  def readMessageBegin(self):
    sz = self.readI32()
    if sz < 0:
      version = sz & TBinaryProtocol.VERSION_MASK
      if version != TBinaryProtocol.VERSION_1:
        raise TProtocolException(type=TProtocolException.BAD_VERSION, message='Bad version in readMessageBegin: %d' % (sz))
      type = sz & TBinaryProtocol.TYPE_MASK
      name = self.readString()
      seqid = self.readI32()
    else:
      if self.strictRead:
        raise TProtocolException(type=TProtocolException.BAD_VERSION, message='No protocol version header')
      name = self.trans.readAll(sz)
      type = self.readByte()
      seqid = self.readI32()
    return (name, type, seqid)

  def readMessageEnd(self):
    pass

  def readStructBegin(self):
    pass

  def readStructEnd(self):
    pass

  def readFieldBegin(self):
    type = self.readByte()
    if type == TType.STOP:
      return (None, type, 0)
    id = self.readI16()
    return (None, type, id)

  def readFieldEnd(self):
    pass

  def readMapBegin(self):
    ktype = self.readByte()
    vtype = self.readByte()
    size = self.readI32()
    return (ktype, vtype, size)

  def readMapEnd(self):
    pass

  def readListBegin(self):
    etype = self.readByte()
    size = self.readI32()
    return (etype, size)

  def readListEnd(self):
    pass

  def readSetBegin(self):
    etype = self.readByte()
    size = self.readI32()
    return (etype, size)

  def readSetEnd(self):
    pass

  def readBool(self):
    byte = self.readByte()
    if byte == 0:
      return False
    return True

  def readByte(self):
    buff = self.trans.readAll(1)
    val, = unpack('!b', buff)
    return val

  def readI16(self):
    buff = self.trans.readAll(2)
    val, = unpack('!h', buff)
    return val

  def readI32(self):
    buff = self.trans.readAll(4)
    val, = unpack('!i', buff)
    return val

  def readI64(self):
    buff = self.trans.readAll(8)
    val, = unpack('!q', buff)
    return val

  def readDouble(self):
    buff = self.trans.readAll(8)
    val, = unpack('!d', buff)
    return val

  def readString(self):
    len = self.readI32()
    str = self.trans.readAll(len)
    return str


class TBinaryProtocolFactory:
  def __init__(self, strictRead=False, strictWrite=True):
    self.strictRead = strictRead
    self.strictWrite = strictWrite

  def getProtocol(self, trans):
    prot = TBinaryProtocol(trans, self.strictRead, self.strictWrite)
    return prot


class TBinaryProtocolAccelerated(TBinaryProtocol):

  """C-Accelerated version of TBinaryProtocol.

  This class does not override any of TBinaryProtocol's methods,
  but the generated code recognizes it directly and will call into
  our C module to do the encoding, bypassing this object entirely.
  We inherit from TBinaryProtocol so that the normal TBinaryProtocol
  encoding can happen if the fastbinary module doesn't work for some
  reason.  (TODO(dreiss): Make this happen sanely in more cases.)

  In order to take advantage of the C module, just use
  TBinaryProtocolAccelerated instead of TBinaryProtocol.

  NOTE:  This code was contributed by an external developer.
         The internal Thrift team has reviewed and tested it,
         but we cannot guarantee that it is production-ready.
         Please feel free to report bugs and/or success stories
         to the public mailing list.
  """

  pass


class TBinaryProtocolAcceleratedFactory:
  def getProtocol(self, trans):
    return TBinaryProtocolAccelerated(trans)

########NEW FILE########
__FILENAME__ = TCompactProtocol
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from TProtocol import *
from struct import pack, unpack

__all__ = ['TCompactProtocol', 'TCompactProtocolFactory']

CLEAR = 0
FIELD_WRITE = 1
VALUE_WRITE = 2
CONTAINER_WRITE = 3
BOOL_WRITE = 4
FIELD_READ = 5
CONTAINER_READ = 6
VALUE_READ = 7
BOOL_READ = 8

def make_helper(v_from, container):
  def helper(func):
    def nested(self, *args, **kwargs):
      assert self.state in (v_from, container), (self.state, v_from, container)
      return func(self, *args, **kwargs)
    return nested
  return helper
writer = make_helper(VALUE_WRITE, CONTAINER_WRITE)
reader = make_helper(VALUE_READ, CONTAINER_READ)

def makeZigZag(n, bits):
  return (n << 1) ^ (n >> (bits - 1))

def fromZigZag(n):
  return (n >> 1) ^ -(n & 1)

def writeVarint(trans, n):
  out = []
  while True:
    if n & ~0x7f == 0:
      out.append(n)
      break
    else:
      out.append((n & 0xff) | 0x80)
      n = n >> 7
  trans.write(''.join(map(chr, out)))

def readVarint(trans):
  result = 0
  shift = 0
  while True:
    x = trans.readAll(1)
    byte = ord(x)
    result |= (byte & 0x7f) << shift
    if byte >> 7 == 0:
      return result
    shift += 7

class CompactType:
  STOP = 0x00
  TRUE = 0x01
  FALSE = 0x02
  BYTE = 0x03
  I16 = 0x04
  I32 = 0x05
  I64 = 0x06
  DOUBLE = 0x07
  BINARY = 0x08
  LIST = 0x09
  SET = 0x0A
  MAP = 0x0B
  STRUCT = 0x0C

CTYPES = {TType.STOP: CompactType.STOP,
          TType.BOOL: CompactType.TRUE, # used for collection
          TType.BYTE: CompactType.BYTE,
          TType.I16: CompactType.I16,
          TType.I32: CompactType.I32,
          TType.I64: CompactType.I64,
          TType.DOUBLE: CompactType.DOUBLE,
          TType.STRING: CompactType.BINARY,
          TType.STRUCT: CompactType.STRUCT,
          TType.LIST: CompactType.LIST,
          TType.SET: CompactType.SET,
          TType.MAP: CompactType.MAP
          }

TTYPES = {}
for k, v in CTYPES.items():
  TTYPES[v] = k
TTYPES[CompactType.FALSE] = TType.BOOL
del k
del v

class TCompactProtocol(TProtocolBase):
  "Compact implementation of the Thrift protocol driver."

  PROTOCOL_ID = 0x82
  VERSION = 1
  VERSION_MASK = 0x1f
  TYPE_MASK = 0xe0
  TYPE_SHIFT_AMOUNT = 5

  def __init__(self, trans):
    TProtocolBase.__init__(self, trans)
    self.state = CLEAR
    self.__last_fid = 0
    self.__bool_fid = None
    self.__bool_value = None
    self.__structs = []
    self.__containers = []

  def __writeVarint(self, n):
    writeVarint(self.trans, n)

  def writeMessageBegin(self, name, type, seqid):
    assert self.state == CLEAR
    self.__writeUByte(self.PROTOCOL_ID)
    self.__writeUByte(self.VERSION | (type << self.TYPE_SHIFT_AMOUNT))
    self.__writeVarint(seqid)
    self.__writeString(name)
    self.state = VALUE_WRITE

  def writeMessageEnd(self):
    assert self.state == VALUE_WRITE
    self.state = CLEAR

  def writeStructBegin(self, name):
    assert self.state in (CLEAR, CONTAINER_WRITE, VALUE_WRITE), self.state
    self.__structs.append((self.state, self.__last_fid))
    self.state = FIELD_WRITE
    self.__last_fid = 0

  def writeStructEnd(self):
    assert self.state == FIELD_WRITE
    self.state, self.__last_fid = self.__structs.pop()

  def writeFieldStop(self):
    self.__writeByte(0)

  def __writeFieldHeader(self, type, fid):
    delta = fid - self.__last_fid
    if 0 < delta <= 15:
      self.__writeUByte(delta << 4 | type)
    else:
      self.__writeByte(type)
      self.__writeI16(fid)
    self.__last_fid = fid

  def writeFieldBegin(self, name, type, fid):
    assert self.state == FIELD_WRITE, self.state
    if type == TType.BOOL:
      self.state = BOOL_WRITE
      self.__bool_fid = fid
    else:
      self.state = VALUE_WRITE
      self.__writeFieldHeader(CTYPES[type], fid)

  def writeFieldEnd(self):
    assert self.state in (VALUE_WRITE, BOOL_WRITE), self.state
    self.state = FIELD_WRITE

  def __writeUByte(self, byte):
    self.trans.write(pack('!B', byte))

  def __writeByte(self, byte):
    self.trans.write(pack('!b', byte))

  def __writeI16(self, i16):
    self.__writeVarint(makeZigZag(i16, 16))

  def __writeSize(self, i32):
    self.__writeVarint(i32)

  def writeCollectionBegin(self, etype, size):
    assert self.state in (VALUE_WRITE, CONTAINER_WRITE), self.state
    if size <= 14:
      self.__writeUByte(size << 4 | CTYPES[etype])
    else:
      self.__writeUByte(0xf0 | CTYPES[etype])
      self.__writeSize(size)
    self.__containers.append(self.state)
    self.state = CONTAINER_WRITE
  writeSetBegin = writeCollectionBegin
  writeListBegin = writeCollectionBegin

  def writeMapBegin(self, ktype, vtype, size):
    assert self.state in (VALUE_WRITE, CONTAINER_WRITE), self.state
    if size == 0:
      self.__writeByte(0)
    else:
      self.__writeSize(size)
      self.__writeUByte(CTYPES[ktype] << 4 | CTYPES[vtype])
    self.__containers.append(self.state)
    self.state = CONTAINER_WRITE

  def writeCollectionEnd(self):
    assert self.state == CONTAINER_WRITE, self.state
    self.state = self.__containers.pop()
  writeMapEnd = writeCollectionEnd
  writeSetEnd = writeCollectionEnd
  writeListEnd = writeCollectionEnd

  def writeBool(self, bool):
    if self.state == BOOL_WRITE:
        if bool:
            ctype = CompactType.TRUE
        else:
            ctype = CompactType.FALSE
        self.__writeFieldHeader(ctype, self.__bool_fid)
    elif self.state == CONTAINER_WRITE:
       if bool:
           self.__writeByte(CompactType.TRUE)
       else:
           self.__writeByte(CompactType.FALSE)
    else:
      raise AssertionError, "Invalid state in compact protocol"

  writeByte = writer(__writeByte)
  writeI16 = writer(__writeI16)

  @writer
  def writeI32(self, i32):
    self.__writeVarint(makeZigZag(i32, 32))

  @writer
  def writeI64(self, i64):
    self.__writeVarint(makeZigZag(i64, 64))

  @writer
  def writeDouble(self, dub):
    self.trans.write(pack('!d', dub))

  def __writeString(self, s):
    self.__writeSize(len(s))
    self.trans.write(s)
  writeString = writer(__writeString)

  def readFieldBegin(self):
    assert self.state == FIELD_READ, self.state
    type = self.__readUByte()
    if type & 0x0f == TType.STOP:
      return (None, 0, 0)
    delta = type >> 4
    if delta == 0:
      fid = self.__readI16()
    else:
      fid = self.__last_fid + delta
    self.__last_fid = fid
    type = type & 0x0f
    if type == CompactType.TRUE:
      self.state = BOOL_READ
      self.__bool_value = True
    elif type == CompactType.FALSE:
      self.state = BOOL_READ
      self.__bool_value = False
    else:
      self.state = VALUE_READ
    return (None, self.__getTType(type), fid)

  def readFieldEnd(self):
    assert self.state in (VALUE_READ, BOOL_READ), self.state
    self.state = FIELD_READ

  def __readUByte(self):
    result, = unpack('!B', self.trans.readAll(1))
    return result

  def __readByte(self):
    result, = unpack('!b', self.trans.readAll(1))
    return result

  def __readVarint(self):
    return readVarint(self.trans)

  def __readZigZag(self):
    return fromZigZag(self.__readVarint())

  def __readSize(self):
    result = self.__readVarint()
    if result < 0:
      raise TException("Length < 0")
    return result

  def readMessageBegin(self):
    assert self.state == CLEAR
    proto_id = self.__readUByte()
    if proto_id != self.PROTOCOL_ID:
      raise TProtocolException(TProtocolException.BAD_VERSION,
          'Bad protocol id in the message: %d' % proto_id)
    ver_type = self.__readUByte()
    type = (ver_type & self.TYPE_MASK) >> self.TYPE_SHIFT_AMOUNT
    version = ver_type & self.VERSION_MASK
    if version != self.VERSION:
      raise TProtocolException(TProtocolException.BAD_VERSION,
          'Bad version: %d (expect %d)' % (version, self.VERSION))
    seqid = self.__readVarint()
    name = self.__readString()
    return (name, type, seqid)

  def readMessageEnd(self):
    assert self.state == CLEAR
    assert len(self.__structs) == 0

  def readStructBegin(self):
    assert self.state in (CLEAR, CONTAINER_READ, VALUE_READ), self.state
    self.__structs.append((self.state, self.__last_fid))
    self.state = FIELD_READ
    self.__last_fid = 0

  def readStructEnd(self):
    assert self.state == FIELD_READ
    self.state, self.__last_fid = self.__structs.pop()

  def readCollectionBegin(self):
    assert self.state in (VALUE_READ, CONTAINER_READ), self.state
    size_type = self.__readUByte()
    size = size_type >> 4
    type = self.__getTType(size_type)
    if size == 15:
      size = self.__readSize()
    self.__containers.append(self.state)
    self.state = CONTAINER_READ
    return type, size
  readSetBegin = readCollectionBegin
  readListBegin = readCollectionBegin

  def readMapBegin(self):
    assert self.state in (VALUE_READ, CONTAINER_READ), self.state
    size = self.__readSize()
    types = 0
    if size > 0:
      types = self.__readUByte()
    vtype = self.__getTType(types)
    ktype = self.__getTType(types >> 4)
    self.__containers.append(self.state)
    self.state = CONTAINER_READ
    return (ktype, vtype, size)

  def readCollectionEnd(self):
    assert self.state == CONTAINER_READ, self.state
    self.state = self.__containers.pop()
  readSetEnd = readCollectionEnd
  readListEnd = readCollectionEnd
  readMapEnd = readCollectionEnd

  def readBool(self):
    if self.state == BOOL_READ:
      return self.__bool_value == CompactType.TRUE
    elif self.state == CONTAINER_READ:
      return self.__readByte() == CompactType.TRUE
    else:
      raise AssertionError, "Invalid state in compact protocol: %d" % self.state

  readByte = reader(__readByte)
  __readI16 = __readZigZag
  readI16 = reader(__readZigZag)
  readI32 = reader(__readZigZag)
  readI64 = reader(__readZigZag)

  @reader
  def readDouble(self):
    buff = self.trans.readAll(8)
    val, = unpack('!d', buff)
    return val

  def __readString(self):
    len = self.__readSize()
    return self.trans.readAll(len)
  readString = reader(__readString)

  def __getTType(self, byte):
    return TTYPES[byte & 0x0f]


class TCompactProtocolFactory:
  def __init__(self):
    pass

  def getProtocol(self, trans):
    return TCompactProtocol(trans)

########NEW FILE########
__FILENAME__ = TProtocol
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from thrift.Thrift import *

class TProtocolException(TException):

  """Custom Protocol Exception class"""

  UNKNOWN = 0
  INVALID_DATA = 1
  NEGATIVE_SIZE = 2
  SIZE_LIMIT = 3
  BAD_VERSION = 4

  def __init__(self, type=UNKNOWN, message=None):
    TException.__init__(self, message)
    self.type = type

class TProtocolBase:

  """Base class for Thrift protocol driver."""

  def __init__(self, trans):
    self.trans = trans

  def writeMessageBegin(self, name, type, seqid):
    pass

  def writeMessageEnd(self):
    pass

  def writeStructBegin(self, name):
    pass

  def writeStructEnd(self):
    pass

  def writeFieldBegin(self, name, type, id):
    pass

  def writeFieldEnd(self):
    pass

  def writeFieldStop(self):
    pass

  def writeMapBegin(self, ktype, vtype, size):
    pass

  def writeMapEnd(self):
    pass

  def writeListBegin(self, etype, size):
    pass

  def writeListEnd(self):
    pass

  def writeSetBegin(self, etype, size):
    pass

  def writeSetEnd(self):
    pass

  def writeBool(self, bool):
    pass

  def writeByte(self, byte):
    pass

  def writeI16(self, i16):
    pass

  def writeI32(self, i32):
    pass

  def writeI64(self, i64):
    pass

  def writeDouble(self, dub):
    pass

  def writeString(self, str):
    pass

  def readMessageBegin(self):
    pass

  def readMessageEnd(self):
    pass

  def readStructBegin(self):
    pass

  def readStructEnd(self):
    pass

  def readFieldBegin(self):
    pass

  def readFieldEnd(self):
    pass

  def readMapBegin(self):
    pass

  def readMapEnd(self):
    pass

  def readListBegin(self):
    pass

  def readListEnd(self):
    pass

  def readSetBegin(self):
    pass

  def readSetEnd(self):
    pass

  def readBool(self):
    pass

  def readByte(self):
    pass

  def readI16(self):
    pass

  def readI32(self):
    pass

  def readI64(self):
    pass

  def readDouble(self):
    pass

  def readString(self):
    pass

  def skip(self, type):
    if type == TType.STOP:
      return
    elif type == TType.BOOL:
      self.readBool()
    elif type == TType.BYTE:
      self.readByte()
    elif type == TType.I16:
      self.readI16()
    elif type == TType.I32:
      self.readI32()
    elif type == TType.I64:
      self.readI64()
    elif type == TType.DOUBLE:
      self.readDouble()
    elif type == TType.STRING:
      self.readString()
    elif type == TType.STRUCT:
      name = self.readStructBegin()
      while True:
        (name, type, id) = self.readFieldBegin()
        if type == TType.STOP:
          break
        self.skip(type)
        self.readFieldEnd()
      self.readStructEnd()
    elif type == TType.MAP:
      (ktype, vtype, size) = self.readMapBegin()
      for i in range(size):
        self.skip(ktype)
        self.skip(vtype)
      self.readMapEnd()
    elif type == TType.SET:
      (etype, size) = self.readSetBegin()
      for i in range(size):
        self.skip(etype)
      self.readSetEnd()
    elif type == TType.LIST:
      (etype, size) = self.readListBegin()
      for i in range(size):
        self.skip(etype)
      self.readListEnd()

  # tuple of: ( 'reader method' name, is_container boolean, 'writer_method' name )
  _TTYPE_HANDLERS = (
       (None, None, False), # 0 == TType,STOP
       (None, None, False), # 1 == TType.VOID # TODO: handle void?
       ('readBool', 'writeBool', False), # 2 == TType.BOOL
       ('readByte',  'writeByte', False), # 3 == TType.BYTE and I08
       ('readDouble', 'writeDouble', False), # 4 == TType.DOUBLE
       (None, None, False), # 5, undefined
       ('readI16', 'writeI16', False), # 6 == TType.I16
       (None, None, False), # 7, undefined
       ('readI32', 'writeI32', False), # 8 == TType.I32
       (None, None, False), # 9, undefined
       ('readI64', 'writeI64', False), # 10 == TType.I64
       ('readString', 'writeString', False), # 11 == TType.STRING and UTF7
       ('readContainerStruct', 'writeContainerStruct', True), # 12 == TType.STRUCT
       ('readContainerMap', 'writeContainerMap', True), # 13 == TType.MAP
       ('readContainerSet', 'writeContainerSet', True), # 14 == TType.SET
       ('readContainerList', 'writeContainerList', True), # 15 == TType.LIST
       (None, None, False), # 16 == TType.UTF8 # TODO: handle utf8 types?
       (None, None, False)# 17 == TType.UTF16 # TODO: handle utf16 types?
      )

  def readFieldByTType(self, ttype, spec):
    try:
      (r_handler, w_handler, is_container) = self._TTYPE_HANDLERS[ttype]
    except IndexError:
      raise TProtocolException(type=TProtocolException.INVALID_DATA,
                               message='Invalid field type %d' % (ttype))
    if r_handler is None:
      raise TProtocolException(type=TProtocolException.INVALID_DATA,
                               message='Invalid field type %d' % (ttype))
    reader = getattr(self, r_handler)
    if not is_container:
      return reader()
    return reader(spec)

  def readContainerList(self, spec):
    results = []
    ttype, tspec = spec[0], spec[1]
    r_handler = self._TTYPE_HANDLERS[ttype][0]
    reader = getattr(self, r_handler)
    (list_type, list_len) = self.readListBegin()
    if tspec is None:
      # list values are simple types
      for idx in xrange(list_len):
        results.append(reader())
    else:
      # this is like an inlined readFieldByTType
      container_reader = self._TTYPE_HANDLERS[list_type][0]
      val_reader = getattr(self, container_reader)
      for idx in xrange(list_len):
        val = val_reader(tspec)
        results.append(val)
    self.readListEnd()
    return results

  def readContainerSet(self, spec):
    results = set()
    ttype, tspec = spec[0], spec[1]
    r_handler = self._TTYPE_HANDLERS[ttype][0]
    reader = getattr(self, r_handler)
    (set_type, set_len) = self.readSetBegin()
    if tspec is None:
      # set members are simple types
      for idx in xrange(set_len):
        results.add(reader())
    else:
      container_reader = self._TTYPE_HANDLERS[set_type][0]
      val_reader = getattr(self, container_reader)
      for idx in xrange(set_len):
        results.add(val_reader(tspec)) 
    self.readSetEnd()
    return results

  def readContainerStruct(self, spec):
    (obj_class, obj_spec) = spec
    obj = obj_class()
    obj.read(self)
    return obj
  
  def readContainerMap(self, spec):
    results = dict()
    key_ttype, key_spec = spec[0], spec[1]
    val_ttype, val_spec = spec[2], spec[3]
    (map_ktype, map_vtype, map_len) = self.readMapBegin()
    # TODO: compare types we just decoded with thrift_spec and abort/skip if types disagree
    key_reader = getattr(self, self._TTYPE_HANDLERS[key_ttype][0])
    val_reader = getattr(self, self._TTYPE_HANDLERS[val_ttype][0])
    # list values are simple types
    for idx in xrange(map_len):
      if key_spec is None:
        k_val = key_reader()
      else:
        k_val = self.readFieldByTType(key_ttype, key_spec)
      if val_spec is None:
        v_val = val_reader()
      else:
        v_val = self.readFieldByTType(val_ttype, val_spec)
      # this raises a TypeError with unhashable keys types. i.e. d=dict(); d[[0,1]] = 2 fails
      results[k_val] = v_val
    self.readMapEnd()
    return results

  def readStruct(self, obj, thrift_spec):
    self.readStructBegin()
    while True:
      (fname, ftype, fid) = self.readFieldBegin()
      if ftype == TType.STOP:
        break
      try:
        field = thrift_spec[fid]
      except IndexError:
        self.skip(ftype)
      else:
        if field is not None and ftype == field[1]:
          fname = field[2]
          fspec = field[3]
          val = self.readFieldByTType(ftype, fspec)
          setattr(obj, fname, val)
        else:
          self.skip(ftype)
      self.readFieldEnd()
    self.readStructEnd()

  def writeContainerStruct(self, val, spec):
    val.write(self)

  def writeContainerList(self, val, spec):
    self.writeListBegin(spec[0], len(val))
    r_handler, w_handler, is_container  = self._TTYPE_HANDLERS[spec[0]]
    e_writer = getattr(self, w_handler)
    if not is_container:
      for elem in val:
        e_writer(elem)
    else:
      for elem in val:
        e_writer(elem, spec[1])
    self.writeListEnd()

  def writeContainerSet(self, val, spec):
    self.writeSetBegin(spec[0], len(val))
    r_handler, w_handler, is_container = self._TTYPE_HANDLERS[spec[0]]
    e_writer = getattr(self, w_handler)
    if not is_container:
      for elem in val:
        e_writer(elem)
    else:
      for elem in val:
        e_writer(elem, spec[1])
    self.writeSetEnd()

  def writeContainerMap(self, val, spec):
    k_type = spec[0]
    v_type = spec[2]
    ignore, ktype_name, k_is_container = self._TTYPE_HANDLERS[k_type]
    ignore, vtype_name, v_is_container = self._TTYPE_HANDLERS[v_type]
    k_writer = getattr(self, ktype_name)
    v_writer = getattr(self, vtype_name)
    self.writeMapBegin(k_type, v_type, len(val))
    for m_key, m_val in val.iteritems():
      if not k_is_container:
        k_writer(m_key)
      else:
        k_writer(m_key, spec[1])
      if not v_is_container:
        v_writer(m_val)
      else:
        v_writer(m_val, spec[3])
    self.writeMapEnd()

  def writeStruct(self, obj, thrift_spec):
    self.writeStructBegin(obj.__class__.__name__)
    for field in thrift_spec:
      if field is None:
        continue
      fname = field[2]
      val = getattr(obj, fname)
      if val is None:
        # skip writing out unset fields
        continue
      fid = field[0]
      ftype = field[1]
      fspec = field[3]
      # get the writer method for this value
      self.writeFieldBegin(fname, ftype, fid)
      self.writeFieldByTType(ftype, val, fspec)
      self.writeFieldEnd()
    self.writeFieldStop()
    self.writeStructEnd()

  def writeFieldByTType(self, ttype, val, spec):
    r_handler, w_handler, is_container = self._TTYPE_HANDLERS[ttype]
    writer = getattr(self, w_handler)
    if is_container:
      writer(val, spec)
    else:
      writer(val)

class TProtocolFactory:
  def getProtocol(self, trans):
    pass


########NEW FILE########
__FILENAME__ = THttpServer
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

import BaseHTTPServer

from thrift.server import TServer
from thrift.transport import TTransport

class ResponseException(Exception):
  """Allows handlers to override the HTTP response

  Normally, THttpServer always sends a 200 response.  If a handler wants
  to override this behavior (e.g., to simulate a misconfigured or
  overloaded web server during testing), it can raise a ResponseException.
  The function passed to the constructor will be called with the
  RequestHandler as its only argument.
  """
  def __init__(self, handler):
    self.handler = handler


class THttpServer(TServer.TServer):
  """A simple HTTP-based Thrift server

  This class is not very performant, but it is useful (for example) for
  acting as a mock version of an Apache-based PHP Thrift endpoint."""

  def __init__(self, processor, server_address,
      inputProtocolFactory, outputProtocolFactory = None,
      server_class = BaseHTTPServer.HTTPServer):
    """Set up protocol factories and HTTP server.

    See BaseHTTPServer for server_address.
    See TServer for protocol factories."""

    if outputProtocolFactory is None:
      outputProtocolFactory = inputProtocolFactory

    TServer.TServer.__init__(self, processor, None, None, None,
        inputProtocolFactory, outputProtocolFactory)

    thttpserver = self

    class RequestHander(BaseHTTPServer.BaseHTTPRequestHandler):
      def do_POST(self):
        # Don't care about the request path.
        itrans = TTransport.TFileObjectTransport(self.rfile)
        otrans = TTransport.TFileObjectTransport(self.wfile)
        itrans = TTransport.TBufferedTransport(itrans, int(self.headers['Content-Length']))
        otrans = TTransport.TMemoryBuffer()
        iprot = thttpserver.inputProtocolFactory.getProtocol(itrans)
        oprot = thttpserver.outputProtocolFactory.getProtocol(otrans)
        try:
          thttpserver.processor.process(iprot, oprot)
        except ResponseException, exn:
          exn.handler(self)
        else:
          self.send_response(200)
          self.send_header("content-type", "application/x-thrift")
          self.end_headers()
          self.wfile.write(otrans.getvalue())

    self.httpd = server_class(server_address, RequestHander)

  def serve(self):
    self.httpd.serve_forever()

########NEW FILE########
__FILENAME__ = TNonblockingServer
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#
"""Implementation of non-blocking server.

The main idea of the server is reciving and sending requests
only from main thread.

It also makes thread pool server in tasks terms, not connections.
"""
import threading
import socket
import Queue
import select
import struct
import logging

from thrift.transport import TTransport
from thrift.protocol.TBinaryProtocol import TBinaryProtocolFactory

__all__ = ['TNonblockingServer']

class Worker(threading.Thread):
    """Worker is a small helper to process incoming connection."""
    def __init__(self, queue):
        threading.Thread.__init__(self)
        self.queue = queue

    def run(self):
        """Process queries from task queue, stop if processor is None."""
        while True:
            try:
                processor, iprot, oprot, otrans, callback = self.queue.get()
                if processor is None:
                    break
                processor.process(iprot, oprot)
                callback(True, otrans.getvalue())
            except Exception:
                logging.exception("Exception while processing request")
                callback(False, '')

WAIT_LEN = 0
WAIT_MESSAGE = 1
WAIT_PROCESS = 2
SEND_ANSWER = 3
CLOSED = 4

def locked(func):
    "Decorator which locks self.lock."
    def nested(self, *args, **kwargs):
        self.lock.acquire()
        try:
            return func(self, *args, **kwargs)
        finally:
            self.lock.release()
    return nested

def socket_exception(func):
    "Decorator close object on socket.error."
    def read(self, *args, **kwargs):
        try:
            return func(self, *args, **kwargs)
        except socket.error:
            self.close()
    return read

class Connection:
    """Basic class is represented connection.
    
    It can be in state:
        WAIT_LEN --- connection is reading request len.
        WAIT_MESSAGE --- connection is reading request.
        WAIT_PROCESS --- connection has just read whole request and 
            waits for call ready routine.
        SEND_ANSWER --- connection is sending answer string (including length
            of answer).
        CLOSED --- socket was closed and connection should be deleted.
    """
    def __init__(self, new_socket, wake_up):
        self.socket = new_socket
        self.socket.setblocking(False)
        self.status = WAIT_LEN
        self.len = 0
        self.message = ''
        self.lock = threading.Lock()
        self.wake_up = wake_up

    def _read_len(self):
        """Reads length of request.
        
        It's really paranoic routine and it may be replaced by 
        self.socket.recv(4)."""
        read = self.socket.recv(4 - len(self.message))
        if len(read) == 0:
            # if we read 0 bytes and self.message is empty, it means client close 
            # connection
            if len(self.message) != 0:
                logging.error("can't read frame size from socket")
            self.close()
            return
        self.message += read
        if len(self.message) == 4:
            self.len, = struct.unpack('!i', self.message)
            if self.len < 0:
                logging.error("negative frame size, it seems client"\
                    " doesn't use FramedTransport")
                self.close()
            elif self.len == 0:
                logging.error("empty frame, it's really strange")
                self.close()
            else:
                self.message = ''
                self.status = WAIT_MESSAGE

    @socket_exception
    def read(self):
        """Reads data from stream and switch state."""
        assert self.status in (WAIT_LEN, WAIT_MESSAGE)
        if self.status == WAIT_LEN:
            self._read_len()
            # go back to the main loop here for simplicity instead of
            # falling through, even though there is a good chance that
            # the message is already available
        elif self.status == WAIT_MESSAGE:
            read = self.socket.recv(self.len - len(self.message))
            if len(read) == 0:
                logging.error("can't read frame from socket (get %d of %d bytes)" %
                    (len(self.message), self.len))
                self.close()
                return
            self.message += read
            if len(self.message) == self.len:
                self.status = WAIT_PROCESS

    @socket_exception
    def write(self):
        """Writes data from socket and switch state."""
        assert self.status == SEND_ANSWER
        sent = self.socket.send(self.message)
        if sent == len(self.message):
            self.status = WAIT_LEN
            self.message = ''
            self.len = 0
        else:
            self.message = self.message[sent:]

    @locked
    def ready(self, all_ok, message):
        """Callback function for switching state and waking up main thread.
        
        This function is the only function witch can be called asynchronous.
        
        The ready can switch Connection to three states:
            WAIT_LEN if request was oneway.
            SEND_ANSWER if request was processed in normal way.
            CLOSED if request throws unexpected exception.
        
        The one wakes up main thread.
        """
        assert self.status == WAIT_PROCESS
        if not all_ok:
            self.close()
            self.wake_up()
            return
        self.len = ''
        if len(message) == 0:
            # it was a oneway request, do not write answer
            self.message = ''
            self.status = WAIT_LEN
        else:
            self.message = struct.pack('!i', len(message)) + message
            self.status = SEND_ANSWER
        self.wake_up()

    @locked
    def is_writeable(self):
        "Returns True if connection should be added to write list of select."
        return self.status == SEND_ANSWER

    # it's not necessary, but...
    @locked
    def is_readable(self):
        "Returns True if connection should be added to read list of select."
        return self.status in (WAIT_LEN, WAIT_MESSAGE)

    @locked
    def is_closed(self):
        "Returns True if connection is closed."
        return self.status == CLOSED

    def fileno(self):
        "Returns the file descriptor of the associated socket."
        return self.socket.fileno()

    def close(self):
        "Closes connection"
        self.status = CLOSED
        self.socket.close()

class TNonblockingServer:
    """Non-blocking server."""
    def __init__(self, processor, lsocket, inputProtocolFactory=None, 
            outputProtocolFactory=None, threads=10):
        self.processor = processor
        self.socket = lsocket
        self.in_protocol = inputProtocolFactory or TBinaryProtocolFactory()
        self.out_protocol = outputProtocolFactory or self.in_protocol
        self.threads = int(threads)
        self.clients = {}
        self.tasks = Queue.Queue()
        self._read, self._write = socket.socketpair()
        self.prepared = False

    def setNumThreads(self, num):
        """Set the number of worker threads that should be created."""
        # implement ThreadPool interface
        assert not self.prepared, "You can't change number of threads for working server"
        self.threads = num

    def prepare(self):
        """Prepares server for serve requests."""
        self.socket.listen()
        for _ in xrange(self.threads):
            thread = Worker(self.tasks)
            thread.setDaemon(True)
            thread.start()
        self.prepared = True

    def wake_up(self):
        """Wake up main thread.
        
        The server usualy waits in select call in we should terminate one.
        The simplest way is using socketpair.
        
        Select always wait to read from the first socket of socketpair.
        
        In this case, we can just write anything to the second socket from
        socketpair."""
        self._write.send('1')

    def _select(self):
        """Does select on open connections."""
        readable = [self.socket.handle.fileno(), self._read.fileno()]
        writable = []
        for i, connection in self.clients.items():
            if connection.is_readable():
                readable.append(connection.fileno())
            if connection.is_writeable():
                writable.append(connection.fileno())
            if connection.is_closed():
                del self.clients[i]
        return select.select(readable, writable, readable)
        
    def handle(self):
        """Handle requests.
       
        WARNING! You must call prepare BEFORE calling handle.
        """
        assert self.prepared, "You have to call prepare before handle"
        rset, wset, xset = self._select()
        for readable in rset:
            if readable == self._read.fileno():
                # don't care i just need to clean readable flag
                self._read.recv(1024) 
            elif readable == self.socket.handle.fileno():
                client = self.socket.accept().handle
                self.clients[client.fileno()] = Connection(client, self.wake_up)
            else:
                connection = self.clients[readable]
                connection.read()
                if connection.status == WAIT_PROCESS:
                    itransport = TTransport.TMemoryBuffer(connection.message)
                    otransport = TTransport.TMemoryBuffer()
                    iprot = self.in_protocol.getProtocol(itransport)
                    oprot = self.out_protocol.getProtocol(otransport)
                    self.tasks.put([self.processor, iprot, oprot, 
                                    otransport, connection.ready])
        for writeable in wset:
            self.clients[writeable].write()
        for oob in xset:
            self.clients[oob].close()
            del self.clients[oob]

    def close(self):
        """Closes the server."""
        for _ in xrange(self.threads):
            self.tasks.put([None, None, None, None, None])
        self.socket.close()
        self.prepared = False
        
    def serve(self):
        """Serve forever."""
        self.prepare()
        while True:
            self.handle()

########NEW FILE########
__FILENAME__ = TProcessPoolServer
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#


import logging
from multiprocessing import  Process, Value, Condition, reduction

from TServer import TServer
from thrift.transport.TTransport import TTransportException

class TProcessPoolServer(TServer):

    """
    Server with a fixed size pool of worker subprocesses which service requests.
    Note that if you need shared state between the handlers - it's up to you!
    Written by Dvir Volk, doat.com
    """

    def __init__(self, * args):
        TServer.__init__(self, *args)
        self.numWorkers = 10
        self.workers = []
        self.isRunning = Value('b', False)
        self.stopCondition = Condition()
        self.postForkCallback = None

    def setPostForkCallback(self, callback):
        if not callable(callback):
            raise TypeError("This is not a callback!")
        self.postForkCallback = callback

    def setNumWorkers(self, num):
        """Set the number of worker threads that should be created"""
        self.numWorkers = num

    def workerProcess(self):
        """Loop around getting clients from the shared queue and process them."""

        if self.postForkCallback:
            self.postForkCallback()

        while self.isRunning.value == True:
            try:
                client = self.serverTransport.accept()
                self.serveClient(client)
            except (KeyboardInterrupt, SystemExit):
                return 0
            except Exception, x:
                logging.exception(x)

    def serveClient(self, client):
        """Process input/output from a client for as long as possible"""
        itrans = self.inputTransportFactory.getTransport(client)
        otrans = self.outputTransportFactory.getTransport(client)
        iprot = self.inputProtocolFactory.getProtocol(itrans)
        oprot = self.outputProtocolFactory.getProtocol(otrans)

        try:
            while True:
                self.processor.process(iprot, oprot)
        except TTransportException, tx:
            pass
        except Exception, x:
            logging.exception(x)

        itrans.close()
        otrans.close()


    def serve(self):
        """Start a fixed number of worker threads and put client into a queue"""

        #this is a shared state that can tell the workers to exit when set as false
        self.isRunning.value = True

        #first bind and listen to the port
        self.serverTransport.listen()

        #fork the children
        for i in range(self.numWorkers):
            try:
                w = Process(target=self.workerProcess)
                w.daemon = True
                w.start()
                self.workers.append(w)
            except Exception, x:
                logging.exception(x)

        #wait until the condition is set by stop()

        while True:

            self.stopCondition.acquire()
            try:
                self.stopCondition.wait()
                break
            except (SystemExit, KeyboardInterrupt):
		break
            except Exception, x:
                logging.exception(x)

        self.isRunning.value = False

    def stop(self):
        self.isRunning.value = False
        self.stopCondition.acquire()
        self.stopCondition.notify()
        self.stopCondition.release()


########NEW FILE########
__FILENAME__ = TServer
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

import logging
import sys
import os
import traceback
import threading
import Queue

from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol

class TServer:

  """Base interface for a server, which must have a serve method."""

  """ 3 constructors for all servers:
  1) (processor, serverTransport)
  2) (processor, serverTransport, transportFactory, protocolFactory)
  3) (processor, serverTransport,
      inputTransportFactory, outputTransportFactory,
      inputProtocolFactory, outputProtocolFactory)"""
  def __init__(self, *args):
    if (len(args) == 2):
      self.__initArgs__(args[0], args[1],
                        TTransport.TTransportFactoryBase(),
                        TTransport.TTransportFactoryBase(),
                        TBinaryProtocol.TBinaryProtocolFactory(),
                        TBinaryProtocol.TBinaryProtocolFactory())
    elif (len(args) == 4):
      self.__initArgs__(args[0], args[1], args[2], args[2], args[3], args[3])
    elif (len(args) == 6):
      self.__initArgs__(args[0], args[1], args[2], args[3], args[4], args[5])

  def __initArgs__(self, processor, serverTransport,
                   inputTransportFactory, outputTransportFactory,
                   inputProtocolFactory, outputProtocolFactory):
    self.processor = processor
    self.serverTransport = serverTransport
    self.inputTransportFactory = inputTransportFactory
    self.outputTransportFactory = outputTransportFactory
    self.inputProtocolFactory = inputProtocolFactory
    self.outputProtocolFactory = outputProtocolFactory

  def serve(self):
    pass

class TSimpleServer(TServer):

  """Simple single-threaded server that just pumps around one transport."""

  def __init__(self, *args):
    TServer.__init__(self, *args)

  def serve(self):
    self.serverTransport.listen()
    while True:
      client = self.serverTransport.accept()
      itrans = self.inputTransportFactory.getTransport(client)
      otrans = self.outputTransportFactory.getTransport(client)
      iprot = self.inputProtocolFactory.getProtocol(itrans)
      oprot = self.outputProtocolFactory.getProtocol(otrans)
      try:
        while True:
          self.processor.process(iprot, oprot)
      except TTransport.TTransportException, tx:
        pass
      except Exception, x:
        logging.exception(x)

      itrans.close()
      otrans.close()

class TThreadedServer(TServer):

  """Threaded server that spawns a new thread per each connection."""

  def __init__(self, *args, **kwargs):
    TServer.__init__(self, *args)
    self.daemon = kwargs.get("daemon", False)

  def serve(self):
    self.serverTransport.listen()
    while True:
      try:
        client = self.serverTransport.accept()
        t = threading.Thread(target = self.handle, args=(client,))
        t.setDaemon(self.daemon)
        t.start()
      except KeyboardInterrupt:
        raise
      except Exception, x:
        logging.exception(x)

  def handle(self, client):
    itrans = self.inputTransportFactory.getTransport(client)
    otrans = self.outputTransportFactory.getTransport(client)
    iprot = self.inputProtocolFactory.getProtocol(itrans)
    oprot = self.outputProtocolFactory.getProtocol(otrans)
    try:
      while True:
        self.processor.process(iprot, oprot)
    except TTransport.TTransportException, tx:
      pass
    except Exception, x:
      logging.exception(x)

    itrans.close()
    otrans.close()

class TThreadPoolServer(TServer):

  """Server with a fixed size pool of threads which service requests."""

  def __init__(self, *args, **kwargs):
    TServer.__init__(self, *args)
    self.clients = Queue.Queue()
    self.threads = 10
    self.daemon = kwargs.get("daemon", False)

  def setNumThreads(self, num):
    """Set the number of worker threads that should be created"""
    self.threads = num

  def serveThread(self):
    """Loop around getting clients from the shared queue and process them."""
    while True:
      try:
        client = self.clients.get()
        self.serveClient(client)
      except Exception, x:
        logging.exception(x)

  def serveClient(self, client):
    """Process input/output from a client for as long as possible"""
    itrans = self.inputTransportFactory.getTransport(client)
    otrans = self.outputTransportFactory.getTransport(client)
    iprot = self.inputProtocolFactory.getProtocol(itrans)
    oprot = self.outputProtocolFactory.getProtocol(otrans)
    try:
      while True:
        self.processor.process(iprot, oprot)
    except TTransport.TTransportException, tx:
      pass
    except Exception, x:
      logging.exception(x)

    itrans.close()
    otrans.close()

  def serve(self):
    """Start a fixed number of worker threads and put client into a queue"""
    for i in range(self.threads):
      try:
        t = threading.Thread(target = self.serveThread)
        t.setDaemon(self.daemon)
        t.start()
      except Exception, x:
        logging.exception(x)

    # Pump the socket for clients
    self.serverTransport.listen()
    while True:
      try:
        client = self.serverTransport.accept()
        self.clients.put(client)
      except Exception, x:
        logging.exception(x)


class TForkingServer(TServer):

  """A Thrift server that forks a new process for each request"""
  """
  This is more scalable than the threaded server as it does not cause
  GIL contention.

  Note that this has different semantics from the threading server.
  Specifically, updates to shared variables will no longer be shared.
  It will also not work on windows.

  This code is heavily inspired by SocketServer.ForkingMixIn in the
  Python stdlib.
  """

  def __init__(self, *args):
    TServer.__init__(self, *args)
    self.children = []

  def serve(self):
    def try_close(file):
      try:
        file.close()
      except IOError, e:
        logging.warning(e, exc_info=True)


    self.serverTransport.listen()
    while True:
      client = self.serverTransport.accept()
      try:
        pid = os.fork()

        if pid: # parent
          # add before collect, otherwise you race w/ waitpid
          self.children.append(pid)
          self.collect_children()

          # Parent must close socket or the connection may not get
          # closed promptly
          itrans = self.inputTransportFactory.getTransport(client)
          otrans = self.outputTransportFactory.getTransport(client)
          try_close(itrans)
          try_close(otrans)
        else:
          itrans = self.inputTransportFactory.getTransport(client)
          otrans = self.outputTransportFactory.getTransport(client)

          iprot = self.inputProtocolFactory.getProtocol(itrans)
          oprot = self.outputProtocolFactory.getProtocol(otrans)

          ecode = 0
          try:
            try:
              while True:
                self.processor.process(iprot, oprot)
            except TTransport.TTransportException, tx:
              pass
            except Exception, e:
              logging.exception(e)
              ecode = 1
          finally:
            try_close(itrans)
            try_close(otrans)

          os._exit(ecode)

      except TTransport.TTransportException, tx:
        pass
      except Exception, x:
        logging.exception(x)


  def collect_children(self):
    while self.children:
      try:
        pid, status = os.waitpid(0, os.WNOHANG)
      except os.error:
        pid = None

      if pid:
        self.children.remove(pid)
      else:
        break



########NEW FILE########
__FILENAME__ = Thrift
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

import sys

class TType:
  STOP   = 0
  VOID   = 1
  BOOL   = 2
  BYTE   = 3
  I08    = 3
  DOUBLE = 4
  I16    = 6
  I32    = 8
  I64    = 10
  STRING = 11
  UTF7   = 11
  STRUCT = 12
  MAP    = 13
  SET    = 14
  LIST   = 15
  UTF8   = 16
  UTF16  = 17

  _VALUES_TO_NAMES = ( 'STOP',
                      'VOID',
                      'BOOL',
                      'BYTE',
                      'DOUBLE',
                      None,
                      'I16',
                      None,
                      'I32',
                      None,
                       'I64',
                       'STRING',
                       'STRUCT',
                       'MAP',
                       'SET',
                       'LIST',
                       'UTF8',
                       'UTF16' )

class TMessageType:
  CALL  = 1
  REPLY = 2
  EXCEPTION = 3
  ONEWAY = 4

class TProcessor:

  """Base class for procsessor, which works on two streams."""

  def process(iprot, oprot):
    pass

class TException(Exception):

  """Base class for all thrift exceptions."""

  # BaseException.message is deprecated in Python v[2.6,3.0)
  if (2,6,0) <= sys.version_info < (3,0):
    def _get_message(self):
	    return self._message
    def _set_message(self, message):
	    self._message = message
    message = property(_get_message, _set_message)

  def __init__(self, message=None):
    Exception.__init__(self, message)
    self.message = message

class TApplicationException(TException):

  """Application level thrift exceptions."""

  UNKNOWN = 0
  UNKNOWN_METHOD = 1
  INVALID_MESSAGE_TYPE = 2
  WRONG_METHOD_NAME = 3
  BAD_SEQUENCE_ID = 4
  MISSING_RESULT = 5
  INTERNAL_ERROR = 6
  PROTOCOL_ERROR = 7

  def __init__(self, type=UNKNOWN, message=None):
    TException.__init__(self, message)
    self.type = type

  def __str__(self):
    if self.message:
      return self.message
    elif self.type == self.UNKNOWN_METHOD:
      return 'Unknown method'
    elif self.type == self.INVALID_MESSAGE_TYPE:
      return 'Invalid message type'
    elif self.type == self.WRONG_METHOD_NAME:
      return 'Wrong method name'
    elif self.type == self.BAD_SEQUENCE_ID:
      return 'Bad sequence ID'
    elif self.type == self.MISSING_RESULT:
      return 'Missing result'
    else:
      return 'Default (unknown) TApplicationException'

  def read(self, iprot):
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    oprot.writeStructBegin('TApplicationException')
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

########NEW FILE########
__FILENAME__ = httpslib
'''
Replacement of HTTPS client from standart httplib module

workaround of ssl bug: https://bugs.launchpad.net/ubuntu/source/openssl/bug/965371
Copyright (C) http://docs.python.org/license.html

Marat Khayrullin <xmm.dev@gmail.com>
'''

import httplib
import socket
try:
    import ssl
except ImportError:
    pass
else:

    class HTTPSConnection(httplib.HTTPConnection):
        "This class allows communication via SSL."

        default_port = httplib.HTTPS_PORT

        def __init__(self, host, port=None, key_file=None, cert_file=None,
                     strict=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
                     source_address=None):
            httplib.HTTPConnection.__init__(self, host, port, strict, timeout,
                                    source_address)
            self.key_file = key_file
            self.cert_file = cert_file

        def connect(self):
            "Connect to a host on a given (SSL) port."

            sock = socket.create_connection((self.host, self.port),
                                            self.timeout, self.source_address)
            if self._tunnel_host:
                self.sock = sock
                self._tunnel()
            self.sock = ssl.wrap_socket(sock, self.key_file, self.cert_file, ssl_version=ssl.PROTOCOL_TLSv1)

    #__all__.append("HTTPSConnection")

    class HTTPS(httplib.HTTP):
        """Compatibility with 1.5 httplib interface

        Python 1.5.2 did not have an HTTPS class, but it defined an
        interface for sending http requests that is also useful for
        https.
        """

        _connection_class = HTTPSConnection

        def __init__(self, host='', port=None, key_file=None, cert_file=None,
                     strict=None):
            # provide a default host, pass the X509 cert info

            # urf. compensate for bad input.
            if port == 0:
                port = None
            self._setup(self._connection_class(host, port, key_file,
                                               cert_file, strict))

            # we never actually use these for anything, but we keep them
            # here for compatibility with post-1.5.2 CVS.
            self.key_file = key_file
            self.cert_file = cert_file

########NEW FILE########
__FILENAME__ = THttpClient
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

import httplib
import os
import socket
import sys
import urllib
import urlparse
import warnings
from thrift.transport import httpslib  # fix ssl issue
from cStringIO import StringIO

from TTransport import *


class THttpClient(TTransportBase):
  """Http implementation of TTransport base."""

  def __init__(self, uri_or_host, port=None, path=None, http_proxy=None):
    """THttpClient supports two different types constructor parameters.

    THttpClient(host, port, path) - deprecated
    THttpClient(uri)

    Only the second supports https.
    """
    if port is not None:
      warnings.warn(
        "Please use the THttpClient('http://host:port/path') syntax",
        DeprecationWarning,
        stacklevel=2)
      self.host = uri_or_host
      self.port = port
      assert path
      self.path = path
      self.scheme = 'http'
    else:
      parsed = urlparse.urlparse(uri_or_host)
      self.scheme = parsed.scheme
      assert self.scheme in ('http', 'https')
      if self.scheme == 'http':
        self.port = parsed.port or httplib.HTTP_PORT
      elif self.scheme == 'https':
        self.port = parsed.port or httplib.HTTPS_PORT
      self.host = parsed.hostname
      self.path = parsed.path
      if parsed.query:
        self.path += '?%s' % parsed.query
    if http_proxy is not None:
      http_proxy = urlparse.urlparse(http_proxy)
      if http_proxy.scheme == 'http':
        if http_proxy.port is None:
          http_proxy.port = 8080
      else:
        raise ValueError("Unsupported Proxy Scheme, %s" % http_proxy.scheme)
      self.http_proxy = http_proxy
    self.__wbuf = StringIO()
    self.__http = None
    self.__timeout = None
    self.__custom_headers = None

  def open(self):
    http_proxy = getattr(self, 'http_proxy', None)
    if self.scheme == 'http':
      if http_proxy is not None:
        self.__http = httplib.HTTP(self.http_proxy.hostname,
                                   self.http_proxy.port)
      else:
        self.__http = httplib.HTTP(self.host, self.port)
    else:
      if http_proxy is not None:
        self.__http = httpslib.HTTPS(self.http_proxy.hostname,
                                     self.http_proxy.port)
        self.__http._conn.set_tunnel(self.host, self.port)
      else:
        self.__http = httpslib.HTTPS(self.host, self.port)

  def close(self):
    self.__http.close()
    self.__http = None

  def isOpen(self):
    return self.__http is not None

  def setTimeout(self, ms):
    if not hasattr(socket, 'getdefaulttimeout'):
      raise NotImplementedError

    if ms is None:
      self.__timeout = None
    else:
      self.__timeout = ms / 1000.0

  def setCustomHeaders(self, headers):
    self.__custom_headers = headers

  def read(self, sz):
    return self.__http.file.read(sz)

  def write(self, buf):
    self.__wbuf.write(buf)

  def __withTimeout(f):
    def _f(*args, **kwargs):
      orig_timeout = socket.getdefaulttimeout()
      socket.setdefaulttimeout(args[0].__timeout)
      result = f(*args, **kwargs)
      socket.setdefaulttimeout(orig_timeout)
      return result
    return _f

  def flush(self):
    if self.isOpen():
      self.close()
    self.open()

    # Pull data out of buffer
    data = self.__wbuf.getvalue()
    self.__wbuf = StringIO()

    # HTTP request
    if self.scheme == 'http' and self.http_proxy is not None:
      # Instead of using CONNECT semantics for HTTP requests, use standard
      # http proxy full url semantics.
      self.__http.putrequest('POST', 'http://%s:%d%s' %
                             (self.host, self.port, self.path))
    else:
      self.__http.putrequest('POST', self.path)

    # Write headers
    self.__http.putheader('Host', self.host)
    self.__http.putheader('Content-Type', 'application/x-thrift')
    self.__http.putheader('Content-Length', str(len(data)))

    if not self.__custom_headers or 'User-Agent' not in self.__custom_headers:
      user_agent = 'Python/THttpClient'
      script = os.path.basename(sys.argv[0])
      if script:
        user_agent = '%s (%s)' % (user_agent, urllib.quote(script))
      self.__http.putheader('User-Agent', user_agent)

    if self.__custom_headers:
        for key, val in self.__custom_headers.iteritems():
            self.__http.putheader(key, val)

    self.__http.endheaders()

    # Write payload
    self.__http.send(data)

    # Get reply to flush the request
    self.code, self.message, self.headers = self.__http.getreply()

  # Decorate if we know how to timeout
  if hasattr(socket, 'getdefaulttimeout'):
    flush = __withTimeout(flush)

########NEW FILE########
__FILENAME__ = TSocket
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from TTransport import *
import os
import errno
import socket
import sys

class TSocketBase(TTransportBase):
  def _resolveAddr(self):
    if self._unix_socket is not None:
      return [(socket.AF_UNIX, socket.SOCK_STREAM, None, None, self._unix_socket)]
    else:
      return socket.getaddrinfo(self.host, self.port, socket.AF_UNSPEC, socket.SOCK_STREAM, 0, socket.AI_PASSIVE | socket.AI_ADDRCONFIG)

  def close(self):
    if self.handle:
      self.handle.close()
      self.handle = None

class TSocket(TSocketBase):
  """Socket implementation of TTransport base."""

  def __init__(self, host='localhost', port=9090, unix_socket=None):
    """Initialize a TSocket

    @param host(str)  The host to connect to.
    @param port(int)  The (TCP) port to connect to.
    @param unix_socket(str)  The filename of a unix socket to connect to.
                             (host and port will be ignored.)
    """

    self.host = host
    self.port = port
    self.handle = None
    self._unix_socket = unix_socket
    self._timeout = None

  def setHandle(self, h):
    self.handle = h

  def isOpen(self):
    return self.handle is not None

  def setTimeout(self, ms):
    if ms is None:
      self._timeout = None
    else:
      self._timeout = ms/1000.0

    if self.handle is not None:
      self.handle.settimeout(self._timeout)

  def open(self):
    try:
      res0 = self._resolveAddr()
      for res in res0:
        self.handle = socket.socket(res[0], res[1])
        self.handle.settimeout(self._timeout)
        try:
          self.handle.connect(res[4])
        except socket.error, e:
          if res is not res0[-1]:
            continue
          else:
            raise e
        break
    except socket.error, e:
      if self._unix_socket:
        message = 'Could not connect to socket %s' % self._unix_socket
      else:
        message = 'Could not connect to %s:%d' % (self.host, self.port)
      raise TTransportException(type=TTransportException.NOT_OPEN, message=message)

  def read(self, sz):
    try:
      buff = self.handle.recv(sz)
    except socket.error, e:
      if (e.args[0] == errno.ECONNRESET and
          (sys.platform == 'darwin' or sys.platform.startswith('freebsd'))):
        # freebsd and Mach don't follow POSIX semantic of recv
        # and fail with ECONNRESET if peer performed shutdown.
        # See corresponding comment and code in TSocket::read()
        # in lib/cpp/src/transport/TSocket.cpp.
        self.close()
        # Trigger the check to raise the END_OF_FILE exception below.
        buff = ''
      else:
        raise
    if len(buff) == 0:
      raise TTransportException(type=TTransportException.END_OF_FILE, message='TSocket read 0 bytes')
    return buff

  def write(self, buff):
    if not self.handle:
      raise TTransportException(type=TTransportException.NOT_OPEN, message='Transport not open')
    sent = 0
    have = len(buff)
    while sent < have:
      plus = self.handle.send(buff)
      if plus == 0:
        raise TTransportException(type=TTransportException.END_OF_FILE, message='TSocket sent 0 bytes')
      sent += plus
      buff = buff[plus:]

  def flush(self):
    pass

class TServerSocket(TSocketBase, TServerTransportBase):
  """Socket implementation of TServerTransport base."""

  def __init__(self, host=None, port=9090, unix_socket=None):
    self.host = host
    self.port = port
    self._unix_socket = unix_socket
    self.handle = None

  def listen(self):
    res0 = self._resolveAddr()
    for res in res0:
      if res[0] is socket.AF_INET6 or res is res0[-1]:
        break

    # We need remove the old unix socket if the file exists and
    # nobody is listening on it.
    if self._unix_socket:
      tmp = socket.socket(res[0], res[1])
      try:
        tmp.connect(res[4])
      except socket.error, err:
        eno, message = err.args
        if eno == errno.ECONNREFUSED:
          os.unlink(res[4])

    self.handle = socket.socket(res[0], res[1])
    self.handle.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    if hasattr(self.handle, 'settimeout'):
      self.handle.settimeout(None)
    self.handle.bind(res[4])
    self.handle.listen(128)

  def accept(self):
    client, addr = self.handle.accept()
    result = TSocket()
    result.setHandle(client)
    return result

########NEW FILE########
__FILENAME__ = TSSLSocket
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#
import os
import socket
import ssl

from thrift.transport import TSocket
from thrift.transport.TTransport import TTransportException

class TSSLSocket(TSocket.TSocket):
  """
  SSL implementation of client-side TSocket

  This class creates outbound sockets wrapped using the
  python standard ssl module for encrypted connections.
  
  The protocol used is set using the class variable
  SSL_VERSION, which must be one of ssl.PROTOCOL_* and
  defaults to  ssl.PROTOCOL_TLSv1 for greatest security.
  """
  SSL_VERSION = ssl.PROTOCOL_TLSv1

  def __init__(self, host='localhost', port=9090, validate=True, ca_certs=None, unix_socket=None):
    """
    @param validate: Set to False to disable SSL certificate validation entirely.
    @type validate: bool
    @param ca_certs: Filename to the Certificate Authority pem file, possibly a
    file downloaded from: http://curl.haxx.se/ca/cacert.pem  This is passed to
    the ssl_wrap function as the 'ca_certs' parameter.
    @type ca_certs: str
    
    Raises an IOError exception if validate is True and the ca_certs file is
    None, not present or unreadable.
    """
    self.validate = validate
    self.is_valid = False
    self.peercert = None
    if not validate:
      self.cert_reqs = ssl.CERT_NONE
    else:
      self.cert_reqs = ssl.CERT_REQUIRED
    self.ca_certs = ca_certs
    if validate:
      if ca_certs is None or not os.access(ca_certs, os.R_OK):
        raise IOError('Certificate Authority ca_certs file "%s" is not readable, cannot validate SSL certificates.' % (ca_certs))
    TSocket.TSocket.__init__(self, host, port, unix_socket)

  def open(self):
    try:
      res0 = self._resolveAddr()
      for res in res0:
        sock_family, sock_type= res[0:2]
        ip_port = res[4]
        plain_sock = socket.socket(sock_family, sock_type)
        self.handle = ssl.wrap_socket(plain_sock, ssl_version=self.SSL_VERSION,
            do_handshake_on_connect=True, ca_certs=self.ca_certs, cert_reqs=self.cert_reqs) 
        self.handle.settimeout(self._timeout)
        try:
          self.handle.connect(ip_port)
        except socket.error, e:
          if res is not res0[-1]:
            continue
          else:
            raise e
        break
    except socket.error, e:
      if self._unix_socket:
        message = 'Could not connect to secure socket %s' % self._unix_socket
      else:
        message = 'Could not connect to %s:%d' % (self.host, self.port)
      raise TTransportException(type=TTransportException.NOT_OPEN, message=message)
    if self.validate:
      self._validate_cert()

  def _validate_cert(self):
    """internal method to validate the peer's SSL certificate, and to check the
    commonName of the certificate to ensure it matches the hostname we
    used to make this connection.  Does not support subjectAltName records
    in certificates.
    
    raises TTransportException if the certificate fails validation."""
    cert = self.handle.getpeercert()
    self.peercert = cert
    if 'subject' not in cert:
      raise TTransportException(type=TTransportException.NOT_OPEN,
                      message='No SSL certificate found from %s:%s' % (self.host, self.port))
    fields = cert['subject']
    for field in fields:
      # ensure structure we get back is what we expect
      if not isinstance(field, tuple):
        continue
      cert_pair = field[0]
      if len(cert_pair) < 2:
        continue
      cert_key, cert_value = cert_pair[0:2]
      if cert_key != 'commonName':
        continue
      certhost = cert_value
      if certhost == self.host:
        # success, cert commonName matches desired hostname
        self.is_valid = True
        return 
      else:
        raise TTransportException(type=TTransportException.UNKNOWN,
                          message='Host name we connected to "%s" doesn\'t match certificate provided commonName "%s"' % (self.host, certhost))
    raise TTransportException(type=TTransportException.UNKNOWN,
                      message='Could not validate SSL certificate from host "%s".  Cert=%s' % (self.host, cert))

class TSSLServerSocket(TSocket.TServerSocket):
  """
  SSL implementation of TServerSocket

  This uses the ssl module's wrap_socket() method to provide SSL
  negotiated encryption.
  """
  SSL_VERSION = ssl.PROTOCOL_TLSv1

  def __init__(self, host=None, port=9090, certfile='cert.pem', unix_socket=None):
    """Initialize a TSSLServerSocket
    
    @param certfile: The filename of the server certificate file, defaults to cert.pem
    @type certfile: str
    @param host: The hostname or IP to bind the listen socket to, i.e. 'localhost' for only allowing
    local network connections. Pass None to bind to all interfaces.
    @type host: str
    @param port: The port to listen on for inbound connections.
    @type port: int
    """
    self.setCertfile(certfile)
    TSocket.TServerSocket.__init__(self, host, port)

  def setCertfile(self, certfile):
    """Set or change the server certificate file used to wrap new connections.
    
    @param certfile: The filename of the server certificate, i.e. '/etc/certs/server.pem'
    @type certfile: str
    
    Raises an IOError exception if the certfile is not present or unreadable.
    """
    if not os.access(certfile, os.R_OK):
      raise IOError('No such certfile found: %s' % (certfile))
    self.certfile = certfile

  def accept(self):
    plain_client, addr = self.handle.accept()
    try:
      client = ssl.wrap_socket(plain_client, certfile=self.certfile,
                      server_side=True, ssl_version=self.SSL_VERSION)
    except ssl.SSLError, ssl_exc:
      # failed handshake/ssl wrap, close socket to client
      plain_client.close()
      # raise ssl_exc
      # We can't raise the exception, because it kills most TServer derived serve()
      # methods.
      # Instead, return None, and let the TServer instance deal with it in
      # other exception handling.  (but TSimpleServer dies anyway)
      return None 
    result = TSocket.TSocket()
    result.setHandle(client)
    return result

########NEW FILE########
__FILENAME__ = TTransport
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from cStringIO import StringIO
from struct import pack,unpack
from thrift.Thrift import TException

class TTransportException(TException):

  """Custom Transport Exception class"""

  UNKNOWN = 0
  NOT_OPEN = 1
  ALREADY_OPEN = 2
  TIMED_OUT = 3
  END_OF_FILE = 4

  def __init__(self, type=UNKNOWN, message=None):
    TException.__init__(self, message)
    self.type = type

class TTransportBase:

  """Base class for Thrift transport layer."""

  def isOpen(self):
    pass

  def open(self):
    pass

  def close(self):
    pass

  def read(self, sz):
    pass

  def readAll(self, sz):
    buff = ''
    have = 0
    while (have < sz):
      chunk = self.read(sz-have)
      have += len(chunk)
      buff += chunk

      if len(chunk) == 0:
        raise EOFError()

    return buff

  def write(self, buf):
    pass

  def flush(self):
    pass

# This class should be thought of as an interface.
class CReadableTransport:
  """base class for transports that are readable from C"""

  # TODO(dreiss): Think about changing this interface to allow us to use
  #               a (Python, not c) StringIO instead, because it allows
  #               you to write after reading.

  # NOTE: This is a classic class, so properties will NOT work
  #       correctly for setting.
  @property
  def cstringio_buf(self):
    """A cStringIO buffer that contains the current chunk we are reading."""
    pass

  def cstringio_refill(self, partialread, reqlen):
    """Refills cstringio_buf.

    Returns the currently used buffer (which can but need not be the same as
    the old cstringio_buf). partialread is what the C code has read from the
    buffer, and should be inserted into the buffer before any more reads.  The
    return value must be a new, not borrowed reference.  Something along the
    lines of self._buf should be fine.

    If reqlen bytes can't be read, throw EOFError.
    """
    pass

class TServerTransportBase:

  """Base class for Thrift server transports."""

  def listen(self):
    pass

  def accept(self):
    pass

  def close(self):
    pass

class TTransportFactoryBase:

  """Base class for a Transport Factory"""

  def getTransport(self, trans):
    return trans

class TBufferedTransportFactory:

  """Factory transport that builds buffered transports"""

  def getTransport(self, trans):
    buffered = TBufferedTransport(trans)
    return buffered


class TBufferedTransport(TTransportBase,CReadableTransport):

  """Class that wraps another transport and buffers its I/O.

  The implementation uses a (configurable) fixed-size read buffer
  but buffers all writes until a flush is performed.
  """

  DEFAULT_BUFFER = 4096

  def __init__(self, trans, rbuf_size = DEFAULT_BUFFER):
    self.__trans = trans
    self.__wbuf = StringIO()
    self.__rbuf = StringIO("")
    self.__rbuf_size = rbuf_size

  def isOpen(self):
    return self.__trans.isOpen()

  def open(self):
    return self.__trans.open()

  def close(self):
    return self.__trans.close()

  def read(self, sz):
    ret = self.__rbuf.read(sz)
    if len(ret) != 0:
      return ret

    self.__rbuf = StringIO(self.__trans.read(max(sz, self.__rbuf_size)))
    return self.__rbuf.read(sz)

  def write(self, buf):
    self.__wbuf.write(buf)

  def flush(self):
    out = self.__wbuf.getvalue()
    # reset wbuf before write/flush to preserve state on underlying failure
    self.__wbuf = StringIO()
    self.__trans.write(out)
    self.__trans.flush()

  # Implement the CReadableTransport interface.
  @property
  def cstringio_buf(self):
    return self.__rbuf

  def cstringio_refill(self, partialread, reqlen):
    retstring = partialread
    if reqlen < self.__rbuf_size:
      # try to make a read of as much as we can.
      retstring += self.__trans.read(self.__rbuf_size)

    # but make sure we do read reqlen bytes.
    if len(retstring) < reqlen:
      retstring += self.__trans.readAll(reqlen - len(retstring))

    self.__rbuf = StringIO(retstring)
    return self.__rbuf

class TMemoryBuffer(TTransportBase, CReadableTransport):
  """Wraps a cStringIO object as a TTransport.

  NOTE: Unlike the C++ version of this class, you cannot write to it
        then immediately read from it.  If you want to read from a
        TMemoryBuffer, you must either pass a string to the constructor.
  TODO(dreiss): Make this work like the C++ version.
  """

  def __init__(self, value=None):
    """value -- a value to read from for stringio

    If value is set, this will be a transport for reading,
    otherwise, it is for writing"""
    if value is not None:
      self._buffer = StringIO(value)
    else:
      self._buffer = StringIO()

  def isOpen(self):
    return not self._buffer.closed

  def open(self):
    pass

  def close(self):
    self._buffer.close()

  def read(self, sz):
    return self._buffer.read(sz)

  def write(self, buf):
    self._buffer.write(buf)

  def flush(self):
    pass

  def getvalue(self):
    return self._buffer.getvalue()

  # Implement the CReadableTransport interface.
  @property
  def cstringio_buf(self):
    return self._buffer

  def cstringio_refill(self, partialread, reqlen):
    # only one shot at reading...
    raise EOFError()

class TFramedTransportFactory:

  """Factory transport that builds framed transports"""

  def getTransport(self, trans):
    framed = TFramedTransport(trans)
    return framed


class TFramedTransport(TTransportBase, CReadableTransport):

  """Class that wraps another transport and frames its I/O when writing."""

  def __init__(self, trans,):
    self.__trans = trans
    self.__rbuf = StringIO()
    self.__wbuf = StringIO()

  def isOpen(self):
    return self.__trans.isOpen()

  def open(self):
    return self.__trans.open()

  def close(self):
    return self.__trans.close()

  def read(self, sz):
    ret = self.__rbuf.read(sz)
    if len(ret) != 0:
      return ret

    self.readFrame()
    return self.__rbuf.read(sz)

  def readFrame(self):
    buff = self.__trans.readAll(4)
    sz, = unpack('!i', buff)
    self.__rbuf = StringIO(self.__trans.readAll(sz))

  def write(self, buf):
    self.__wbuf.write(buf)

  def flush(self):
    wout = self.__wbuf.getvalue()
    wsz = len(wout)
    # reset wbuf before write/flush to preserve state on underlying failure
    self.__wbuf = StringIO()
    # N.B.: Doing this string concatenation is WAY cheaper than making
    # two separate calls to the underlying socket object. Socket writes in
    # Python turn out to be REALLY expensive, but it seems to do a pretty
    # good job of managing string buffer operations without excessive copies
    buf = pack("!i", wsz) + wout
    self.__trans.write(buf)
    self.__trans.flush()

  # Implement the CReadableTransport interface.
  @property
  def cstringio_buf(self):
    return self.__rbuf

  def cstringio_refill(self, prefix, reqlen):
    # self.__rbuf will already be empty here because fastbinary doesn't
    # ask for a refill until the previous buffer is empty.  Therefore,
    # we can start reading new frames immediately.
    while len(prefix) < reqlen:
      self.readFrame()
      prefix += self.__rbuf.getvalue()
    self.__rbuf = StringIO(prefix)
    return self.__rbuf


class TFileObjectTransport(TTransportBase):
  """Wraps a file-like object to make it work as a Thrift transport."""

  def __init__(self, fileobj):
    self.fileobj = fileobj

  def isOpen(self):
    return True

  def close(self):
    self.fileobj.close()

  def read(self, sz):
    return self.fileobj.read(sz)

  def write(self, buf):
    self.fileobj.write(buf)

  def flush(self):
    self.fileobj.flush()

########NEW FILE########
__FILENAME__ = TTwisted
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#
from zope.interface import implements, Interface, Attribute
from twisted.internet.protocol import Protocol, ServerFactory, ClientFactory, \
    connectionDone
from twisted.internet import defer
from twisted.protocols import basic
from twisted.python import log
from twisted.web import server, resource, http

from thrift.transport import TTransport
from cStringIO import StringIO


class TMessageSenderTransport(TTransport.TTransportBase):

    def __init__(self):
        self.__wbuf = StringIO()

    def write(self, buf):
        self.__wbuf.write(buf)

    def flush(self):
        msg = self.__wbuf.getvalue()
        self.__wbuf = StringIO()
        self.sendMessage(msg)

    def sendMessage(self, message):
        raise NotImplementedError


class TCallbackTransport(TMessageSenderTransport):

    def __init__(self, func):
        TMessageSenderTransport.__init__(self)
        self.func = func

    def sendMessage(self, message):
        self.func(message)


class ThriftClientProtocol(basic.Int32StringReceiver):

    MAX_LENGTH = 2 ** 31 - 1

    def __init__(self, client_class, iprot_factory, oprot_factory=None):
        self._client_class = client_class
        self._iprot_factory = iprot_factory
        if oprot_factory is None:
            self._oprot_factory = iprot_factory
        else:
            self._oprot_factory = oprot_factory

        self.recv_map = {}
        self.started = defer.Deferred()

    def dispatch(self, msg):
        self.sendString(msg)

    def connectionMade(self):
        tmo = TCallbackTransport(self.dispatch)
        self.client = self._client_class(tmo, self._oprot_factory)
        self.started.callback(self.client)

    def connectionLost(self, reason=connectionDone):
        for k,v in self.client._reqs.iteritems():
            tex = TTransport.TTransportException(
                type=TTransport.TTransportException.END_OF_FILE,
                message='Connection closed')
            v.errback(tex)

    def stringReceived(self, frame):
        tr = TTransport.TMemoryBuffer(frame)
        iprot = self._iprot_factory.getProtocol(tr)
        (fname, mtype, rseqid) = iprot.readMessageBegin()

        try:
            method = self.recv_map[fname]
        except KeyError:
            method = getattr(self.client, 'recv_' + fname)
            self.recv_map[fname] = method

        method(iprot, mtype, rseqid)


class ThriftServerProtocol(basic.Int32StringReceiver):

    MAX_LENGTH = 2 ** 31 - 1

    def dispatch(self, msg):
        self.sendString(msg)

    def processError(self, error):
        self.transport.loseConnection()

    def processOk(self, _, tmo):
        msg = tmo.getvalue()

        if len(msg) > 0:
            self.dispatch(msg)

    def stringReceived(self, frame):
        tmi = TTransport.TMemoryBuffer(frame)
        tmo = TTransport.TMemoryBuffer()

        iprot = self.factory.iprot_factory.getProtocol(tmi)
        oprot = self.factory.oprot_factory.getProtocol(tmo)

        d = self.factory.processor.process(iprot, oprot)
        d.addCallbacks(self.processOk, self.processError,
            callbackArgs=(tmo,))


class IThriftServerFactory(Interface):

    processor = Attribute("Thrift processor")

    iprot_factory = Attribute("Input protocol factory")

    oprot_factory = Attribute("Output protocol factory")


class IThriftClientFactory(Interface):

    client_class = Attribute("Thrift client class")

    iprot_factory = Attribute("Input protocol factory")

    oprot_factory = Attribute("Output protocol factory")


class ThriftServerFactory(ServerFactory):

    implements(IThriftServerFactory)

    protocol = ThriftServerProtocol

    def __init__(self, processor, iprot_factory, oprot_factory=None):
        self.processor = processor
        self.iprot_factory = iprot_factory
        if oprot_factory is None:
            self.oprot_factory = iprot_factory
        else:
            self.oprot_factory = oprot_factory


class ThriftClientFactory(ClientFactory):

    implements(IThriftClientFactory)

    protocol = ThriftClientProtocol

    def __init__(self, client_class, iprot_factory, oprot_factory=None):
        self.client_class = client_class
        self.iprot_factory = iprot_factory
        if oprot_factory is None:
            self.oprot_factory = iprot_factory
        else:
            self.oprot_factory = oprot_factory

    def buildProtocol(self, addr):
        p = self.protocol(self.client_class, self.iprot_factory,
            self.oprot_factory)
        p.factory = self
        return p


class ThriftResource(resource.Resource):

    allowedMethods = ('POST',)

    def __init__(self, processor, inputProtocolFactory,
        outputProtocolFactory=None):
        resource.Resource.__init__(self)
        self.inputProtocolFactory = inputProtocolFactory
        if outputProtocolFactory is None:
            self.outputProtocolFactory = inputProtocolFactory
        else:
            self.outputProtocolFactory = outputProtocolFactory
        self.processor = processor

    def getChild(self, path, request):
        return self

    def _cbProcess(self, _, request, tmo):
        msg = tmo.getvalue()
        request.setResponseCode(http.OK)
        request.setHeader("content-type", "application/x-thrift")
        request.write(msg)
        request.finish()

    def render_POST(self, request):
        request.content.seek(0, 0)
        data = request.content.read()
        tmi = TTransport.TMemoryBuffer(data)
        tmo = TTransport.TMemoryBuffer()

        iprot = self.inputProtocolFactory.getProtocol(tmi)
        oprot = self.outputProtocolFactory.getProtocol(tmo)

        d = self.processor.process(iprot, oprot)
        d.addCallback(self._cbProcess, request, tmo)
        return server.NOT_DONE_YET

########NEW FILE########
__FILENAME__ = TZlibTransport
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#
'''
TZlibTransport provides a compressed transport and transport factory
class, using the python standard library zlib module to implement
data compression.
'''

from __future__ import division
import zlib
from cStringIO import StringIO
from TTransport import TTransportBase, CReadableTransport

class TZlibTransportFactory(object):
  '''
  Factory transport that builds zlib compressed transports.
  
  This factory caches the last single client/transport that it was passed
  and returns the same TZlibTransport object that was created.
  
  This caching means the TServer class will get the _same_ transport
  object for both input and output transports from this factory.
  (For non-threaded scenarios only, since the cache only holds one object)
  
  The purpose of this caching is to allocate only one TZlibTransport where
  only one is really needed (since it must have separate read/write buffers),
  and makes the statistics from getCompSavings() and getCompRatio()
  easier to understand.
  '''

  # class scoped cache of last transport given and zlibtransport returned
  _last_trans = None
  _last_z = None

  def getTransport(self, trans, compresslevel=9):
    '''Wrap a transport , trans, with the TZlibTransport
    compressed transport class, returning a new
    transport to the caller.
    
    @param compresslevel: The zlib compression level, ranging
    from 0 (no compression) to 9 (best compression).  Defaults to 9.
    @type compresslevel: int
    
    This method returns a TZlibTransport which wraps the
    passed C{trans} TTransport derived instance.
    '''
    if trans == self._last_trans:
      return self._last_z
    ztrans = TZlibTransport(trans, compresslevel)
    self._last_trans = trans
    self._last_z = ztrans
    return ztrans


class TZlibTransport(TTransportBase, CReadableTransport):
  '''
  Class that wraps a transport with zlib, compressing writes
  and decompresses reads, using the python standard
  library zlib module.
  '''

  # Read buffer size for the python fastbinary C extension,
  # the TBinaryProtocolAccelerated class.
  DEFAULT_BUFFSIZE = 4096

  def __init__(self, trans, compresslevel=9):
    '''
    Create a new TZlibTransport, wrapping C{trans}, another
    TTransport derived object.
    
    @param trans: A thrift transport object, i.e. a TSocket() object.
    @type trans: TTransport
    @param compresslevel: The zlib compression level, ranging
    from 0 (no compression) to 9 (best compression).  Default is 9.
    @type compresslevel: int
    '''
    self.__trans = trans
    self.compresslevel = compresslevel
    self.__rbuf = StringIO()
    self.__wbuf = StringIO()
    self._init_zlib()
    self._init_stats()

  def _reinit_buffers(self):
    '''
    Internal method to initialize/reset the internal StringIO objects
    for read and write buffers.
    '''
    self.__rbuf = StringIO()
    self.__wbuf = StringIO()

  def _init_stats(self):
    '''
    Internal method to reset the internal statistics counters
    for compression ratios and bandwidth savings.
    '''
    self.bytes_in = 0
    self.bytes_out = 0
    self.bytes_in_comp = 0
    self.bytes_out_comp = 0

  def _init_zlib(self):
    '''
    Internal method for setting up the zlib compression and
    decompression objects.
    '''
    self._zcomp_read = zlib.decompressobj()
    self._zcomp_write = zlib.compressobj(self.compresslevel)

  def getCompRatio(self):
    '''
    Get the current measured compression ratios (in,out) from
    this transport.
    
    Returns a tuple of: 
    (inbound_compression_ratio, outbound_compression_ratio)
    
    The compression ratios are computed as:
        compressed / uncompressed

    E.g., data that compresses by 10x will have a ratio of: 0.10
    and data that compresses to half of ts original size will
    have a ratio of 0.5
    
    None is returned if no bytes have yet been processed in
    a particular direction.
    '''
    r_percent, w_percent = (None, None)
    if self.bytes_in > 0:
      r_percent = self.bytes_in_comp / self.bytes_in
    if self.bytes_out > 0:
      w_percent = self.bytes_out_comp / self.bytes_out
    return (r_percent, w_percent)

  def getCompSavings(self):
    '''
    Get the current count of saved bytes due to data
    compression.
    
    Returns a tuple of:
    (inbound_saved_bytes, outbound_saved_bytes)
    
    Note: if compression is actually expanding your
    data (only likely with very tiny thrift objects), then
    the values returned will be negative.
    '''
    r_saved = self.bytes_in - self.bytes_in_comp
    w_saved = self.bytes_out - self.bytes_out_comp
    return (r_saved, w_saved)

  def isOpen(self):
    '''Return the underlying transport's open status'''
    return self.__trans.isOpen()

  def open(self):
    """Open the underlying transport"""
    self._init_stats()
    return self.__trans.open()

  def listen(self):
    '''Invoke the underlying transport's listen() method'''
    self.__trans.listen()

  def accept(self):
    '''Accept connections on the underlying transport'''
    return self.__trans.accept()

  def close(self):
    '''Close the underlying transport,'''
    self._reinit_buffers()
    self._init_zlib()
    return self.__trans.close()

  def read(self, sz):
    '''
    Read up to sz bytes from the decompressed bytes buffer, and
    read from the underlying transport if the decompression
    buffer is empty.
    '''
    ret = self.__rbuf.read(sz)
    if len(ret) > 0:
      return ret
    # keep reading from transport until something comes back
    while True:
      if self.readComp(sz):
        break
    ret = self.__rbuf.read(sz)
    return ret

  def readComp(self, sz):
    '''
    Read compressed data from the underlying transport, then
    decompress it and append it to the internal StringIO read buffer
    '''
    zbuf = self.__trans.read(sz)
    zbuf = self._zcomp_read.unconsumed_tail + zbuf
    buf = self._zcomp_read.decompress(zbuf)
    self.bytes_in += len(zbuf)
    self.bytes_in_comp += len(buf)
    old = self.__rbuf.read()
    self.__rbuf = StringIO(old + buf)
    if len(old) + len(buf) == 0:
      return False
    return True

  def write(self, buf):
    '''
    Write some bytes, putting them into the internal write
    buffer for eventual compression.
    '''
    self.__wbuf.write(buf)

  def flush(self):
    '''
    Flush any queued up data in the write buffer and ensure the
    compression buffer is flushed out to the underlying transport
    '''
    wout = self.__wbuf.getvalue()
    if len(wout) > 0:
      zbuf = self._zcomp_write.compress(wout)
      self.bytes_out += len(wout)
      self.bytes_out_comp += len(zbuf)
    else:
      zbuf = ''
    ztail = self._zcomp_write.flush(zlib.Z_SYNC_FLUSH)
    self.bytes_out_comp += len(ztail)
    if (len(zbuf) + len(ztail)) > 0:
      self.__wbuf = StringIO()
      self.__trans.write(zbuf + ztail)
    self.__trans.flush()

  @property
  def cstringio_buf(self):
    '''Implement the CReadableTransport interface'''
    return self.__rbuf

  def cstringio_refill(self, partialread, reqlen):
    '''Implement the CReadableTransport interface for refill'''
    retstring = partialread
    if reqlen < self.DEFAULT_BUFFSIZE:
      retstring += self.read(self.DEFAULT_BUFFSIZE)
    while len(retstring) < reqlen:
      retstring += self.read(reqlen - len(retstring))
    self.__rbuf = StringIO(retstring)
    return self.__rbuf

########NEW FILE########
__FILENAME__ = TSCons
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from os import path
from SCons.Builder import Builder

def scons_env(env, add=''):
  opath = path.dirname(path.abspath('$TARGET'))
  lstr = 'thrift --gen cpp -o ' + opath + ' ' + add + ' $SOURCE'
  cppbuild = Builder(action = lstr)
  env.Append(BUILDERS = {'ThriftCpp' : cppbuild})

def gen_cpp(env, dir, file):
  scons_env(env)
  suffixes = ['_types.h', '_types.cpp']
  targets = map(lambda s: 'gen-cpp/' + file + s, suffixes)
  return env.ThriftCpp(targets, dir+file+'.thrift')

########NEW FILE########
__FILENAME__ = TSerialization
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.
#

from protocol import TBinaryProtocol
from transport import TTransport

def serialize(thrift_object, protocol_factory = TBinaryProtocol.TBinaryProtocolFactory()):
    transport = TTransport.TMemoryBuffer()
    protocol = protocol_factory.getProtocol(transport)
    thrift_object.write(protocol)
    return transport.getvalue()

def deserialize(base, buf, protocol_factory = TBinaryProtocol.TBinaryProtocolFactory()):
    transport = TTransport.TMemoryBuffer(buf)
    protocol = protocol_factory.getProtocol(transport)
    base.read(protocol)
    return base


########NEW FILE########
