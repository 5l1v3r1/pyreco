__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Django Smartmin documentation build configuration file, created by
# sphinx-quickstart on Mon Jun 20 16:37:41 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Django Smartmin'
copyright = u'2011, Nyaruka Ltd'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
# 
# The short X.Y version.
version = '0.0.3'
# The full version, including alpha/beta/rc tags.
release = '0.0.3'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'sphinxdoc'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'DjangoSmartmindoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'DjangoSmartmin.tex', u'Django Smartmin Documentation',
   u'Nyaruka Ltd', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'ImportTask'
        db.create_table('csv_imports_importtask', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('is_active', self.gf('django.db.models.fields.BooleanField')(default=True)),
            ('created_by', self.gf('django.db.models.fields.related.ForeignKey')(related_name='importtask_creations', to=orm['auth.User'])),
            ('created_on', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('modified_by', self.gf('django.db.models.fields.related.ForeignKey')(related_name='importtask_modifications', to=orm['auth.User'])),
            ('modified_on', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('csv_file', self.gf('django.db.models.fields.files.FileField')(max_length=100)),
            ('model_class', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('import_log', self.gf('django.db.models.fields.TextField')()),
            ('task_id', self.gf('django.db.models.fields.CharField')(max_length=64, null=True)),
        ))
        db.send_create_signal('csv_imports', ['ImportTask'])


    def backwards(self, orm):
        
        # Deleting model 'ImportTask'
        db.delete_table('csv_imports_importtask')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 11, 23, 20, 37, 55, 929727)'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 11, 23, 20, 37, 55, 929625)'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'csv_imports.importtask': {
            'Meta': {'object_name': 'ImportTask'},
            'created_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'importtask_creations'", 'to': "orm['auth.User']"}),
            'created_on': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'csv_file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_log': ('django.db.models.fields.TextField', [], {}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'model_class': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'modified_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'importtask_modifications'", 'to': "orm['auth.User']"}),
            'modified_on': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'task_id': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True'})
        }
    }

    complete_apps = ['csv_imports']

########NEW FILE########
__FILENAME__ = 0002_auto__add_field_importtask_import_params
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'ImportTask.import_params'
        db.add_column('csv_imports_importtask', 'import_params', self.gf('django.db.models.fields.TextField')(null=True, blank=True), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'ImportTask.import_params'
        db.delete_column('csv_imports_importtask', 'import_params')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 11, 23, 20, 38, 40, 746269)'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2012, 11, 23, 20, 38, 40, 746159)'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'csv_imports.importtask': {
            'Meta': {'object_name': 'ImportTask'},
            'created_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'importtask_creations'", 'to': "orm['auth.User']"}),
            'created_on': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'csv_file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'import_log': ('django.db.models.fields.TextField', [], {}),
            'import_params': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'model_class': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'modified_by': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'importtask_modifications'", 'to': "orm['auth.User']"}),
            'modified_on': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'task_id': ('django.db.models.fields.CharField', [], {'max_length': '64', 'null': 'True'})
        }
    }

    complete_apps = ['csv_imports']

########NEW FILE########
__FILENAME__ = models
from django.db import models, transaction
from smartmin import class_from_string
from django.utils import timezone
from django.conf import settings
from celery.result import EagerResult, AsyncResult

from smartmin.models import SmartModel

class ImportTask(SmartModel):
    csv_file = models.FileField(upload_to="csv_imports", verbose_name="Import file", help_text="A comma delimited file of records to import")
    model_class = models.CharField(max_length=255, help_text="The model we are importing for")
    import_params = models.TextField(blank=True, null=True, help_text="JSON blob of form parameters on task creation")
    import_log = models.TextField()
    task_id = models.CharField(null=True, max_length=64)

    def start(self):
        from .tasks import csv_import
        self.log("Queued import at %s" % timezone.now())
        result = csv_import.delay(self.pk)
        self.task_id = result.task_id
        self.save()

    def done(self):
        from .tasks import csv_import
        if self.task_id:
            if getattr(settings, 'CELERY_ALWAYS_EAGER', False):
                result = EagerResult(self.task_id, None, 'SUCCESS')
            else:
                result = AsyncResult(self.task_id)
            return result.ready()

    def status(self):
        from .tasks import csv_import
        status = "PENDING"
        if self.task_id:
            if getattr(settings, 'CELERY_ALWAYS_EAGER', False):
                result = EagerResult(self.task_id, None, 'SUCCESS')
            else:
                result = AsyncResult(self.task_id)
            status = result.state
        return status

    def log(self, message):
        self.import_log += "%s\n" % message
        self.modified_on = timezone.now()
        self.save()


    def __unicode__(self):
        return "%s Import" % class_from_string(self.model_class)._meta.verbose_name.title()

########NEW FILE########
__FILENAME__ = tasks
import StringIO
from smartmin import class_from_string
from django.utils import timezone
from .models import ImportTask
from time import sleep
from distutils.version import StrictVersion
import django

from celery.task import task

@task(track_started=True)
def csv_import(task_id):  #pragma: no cover
    from django.db import transaction

    # there is a possible race condition between this task starting
    # so we have a bit of loop here to fetch the task
    tries = 0
    task = None
    while tries < 5 and not task:
        try:
            task = ImportTask.objects.get(pk=task_id)
        except Exception as e:
            # this object just doesn't exist yet, sleep a bit then try again
            tries+=1
            if tries >= 5:
                raise e
            else:
                sleep(1)

    log = StringIO.StringIO()

    if StrictVersion(django.get_version()) < StrictVersion('1.6'):

        transaction.enter_transaction_management()
        transaction.managed()

        try:
            task.task_id = csv_import.request.id
            task.log("Started import at %s" % timezone.now())
            task.log("--------------------------------")
            task.save()

            transaction.commit()

            model = class_from_string(task.model_class)
            records = model.import_csv(task, log)

            task.log(log.getvalue())
            task.log("Import finished at %s" % timezone.now())
            task.log("%d record(s) added." % len(records))

            transaction.commit()

        except Exception as e:
            transaction.rollback()

            import traceback
            traceback.print_exc(e)

            task.log("\nError: %s\n" % e)
            task.log(log.getvalue())
            transaction.commit()

            raise e

        finally:
            transaction.leave_transaction_management()

    else:

        task.task_id = csv_import.request.id
        task.log("Started import at %s" % timezone.now())
        task.log("--------------------------------")
        task.save()

        try:
            with transaction.atomic():
                model = class_from_string(task.model_class)
                records = model.import_csv(task, log)

                task.log(log.getvalue())
                task.log("Import finished at %s" % timezone.now())
                task.log("%d record(s) added." % len(records))

        except Exception as e:
            import traceback
            traceback.print_exc(e)

            task.log("\nError: %s\n" % e)
            task.log(log.getvalue())

            raise e

    return task

########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""

from django.test import TestCase

class ImportTest(TestCase):
    def test_csv_import(self):
        pass


########NEW FILE########
__FILENAME__ = urls
from smartmin.csv_imports.views import ImportTaskCRUDL

urlpatterns = ImportTaskCRUDL().as_urlpatterns()
########NEW FILE########
__FILENAME__ = views
# Create your views here.
from smartmin import class_from_string
from smartmin.csv_imports.models import ImportTask
from smartmin.views import SmartCRUDL, SmartListView, SmartReadView

class ImportTaskCRUDL(SmartCRUDL):
    model = ImportTask
    actions = ('read', 'list')

    class Read(SmartReadView):
        def derive_refresh(self):
            if self.object.status() in ["PENDING", "RUNNING", "STARTED"]:
                return 2000
            else:
                return 0

    class List(SmartListView):
        fields = ('status', 'type', 'csv_file', 'created_on', 'created_by')
        link_fields = ('csv_file',)

        def get_type(self, obj):
            return class_from_string(obj.model_class)._meta.verbose_name_plural.title()

########NEW FILE########
__FILENAME__ = middleware
from django.http import HttpResponseRedirect, HttpResponse
from django.http import HttpResponse
import sys, StringIO, os
from django.utils import timezone
from django.conf import settings

class AjaxRedirect(object):
    def process_response(self, request, response):
        if request.is_ajax():
            if type(response) == HttpResponseRedirect:
                # This is our own AJAX friend redirect to allow
                # the calling Javascript the opportunity to deal
                # with redirect responses in its own way
                response = HttpResponse(response["Location"])
                response.status_code = 302
        return response

class ProfileMiddleware():
    def __init__(self):
        pass
    
    def process_view(self, request, view, *args, **kwargs):
        import hotshot, hotshot.stats
        
        for item in request.META['QUERY_STRING'].split('&'):
            if item.split('=')[0] == 'profile': # profile in query string
                # catch the output, must happen before stats object is created
                # see https://bugs.launchpad.net/webpy/+bug/133080 for the details
                std_old, std_new = sys.stdout, StringIO.StringIO()
                sys.stdout = std_new

                # now let's do some profiling
                tmpfile = '/tmp/%s' % request.COOKIES['sessionid']
                prof = hotshot.Profile(tmpfile)

                # make a call to the actual view function with the given arguments
                response = prof.runcall(view, request, *args[0], **args[1])
                prof.close()

                # and then statistical reporting
                stats = hotshot.stats.load(tmpfile)
                stats.strip_dirs()
                stats.sort_stats('time')

                # do the output
                stats.print_stats(1.0)

                # restore default output
                sys.stdout = std_old

                # delete file
                os.remove(tmpfile)

                return HttpResponse('<pre>%s</pre>' % std_new.getvalue())

        return None

class TimezoneMiddleware(object):
    def process_request(self, request):
        user_tz = getattr(settings, 'USER_TIME_ZONE', None)

        if user_tz:
            timezone.activate(user_tz)

########NEW FILE########
__FILENAME__ = mixins

# simple mixins that keep you from writing so much code
class PassRequestToFormMixin(object):
    def get_form_kwargs(self):
        kwargs = super(PassRequestToFormMixin, self).get_form_kwargs()
        kwargs['request'] = self.request
        return kwargs

########NEW FILE########
__FILENAME__ = models
import csv
import traceback
import simplejson
from django.db import models
from django.contrib.auth.models import User


class SmartModel(models.Model):
    """
    Useful abstract base class that adds the concept of something being active,
    having a user that created or modified the item and creation and modification
    dates.
    """
    is_active = models.BooleanField(default=True,
                                    help_text="Whether this item is active, use this instead of deleting")

    created_by = models.ForeignKey(User, related_name="%(app_label)s_%(class)s_creations",
                                   help_text="The user which originally created this item")    
    created_on = models.DateTimeField(auto_now_add=True,
                                      help_text="When this item was originally created")

    modified_by = models.ForeignKey(User, related_name="%(app_label)s_%(class)s_modifications",
                                    help_text="The user which last modified this item")
    modified_on = models.DateTimeField(auto_now=True,
                                       help_text="When this item was last modified")

    class Meta:
        abstract = True

    @classmethod
    def prepare_fields(cls, field_dict, import_params=None, user=None):
        return field_dict

    @classmethod
    def create_instance(cls, field_dict):
        return cls.objects.create(**field_dict)

    @classmethod
    def validate_import_header(cls, header):
        return


    @classmethod
    def get_import_file_headers(cls, csv_file):
        filename = csv_file
        from xlrd import open_workbook, XLRDError
            
        headers =[]
        try:
            workbook = open_workbook(filename.name, 'rb')

            records = []

            for sheet in workbook.sheets():

                # read our header
                header = []
                for col in range(sheet.ncols):
                    header.append(unicode(sheet.cell(0, col).value))
                headers = [cls.normalize_value(_).lower() for _ in header]

                #only care for the first sheet
                break
        except XLRDError:
            # our alternative codec, by default we are the crazy windows encoding
            ascii_codec = 'cp1252'

            # read the entire file, look for mac_roman characters
            reader = open(filename.name, "rb")
            for byte in reader.read():
                # these are latin accented characterse in mac_roman, if we see them then our alternative
                # encoding should be mac_roman
                if ord(byte) in [0x81, 0x8d, 0x8f, 0x90, 0x9d]:
                    ascii_codec = 'mac_roman'
                    break
            reader.close()
            
            reader = open(filename.name, "rU")

            def unicode_csv_reader(utf8_data, dialect=csv.excel, **kwargs):
                csv_reader = csv.reader(utf8_data, dialect=dialect, **kwargs)
                for row in csv_reader:
                    encoded = []
                    for cell in row:
                        try:
                            cell = unicode(cell)
                        except:
                            cell = unicode(cell.decode(ascii_codec))

                        encoded.append(cell)
                        
                yield encoded

            reader = unicode_csv_reader(reader)

            # read in our header
            line_number = 0

            header = reader.next()
            line_number += 1
            while header is not None and len(header[0]) > 1 and header[0][0] == "#":
                header = reader.next()
                line_number += 1

            # do some sanity checking to make sure they uploaded the right kind of file
            if len(header) < 1:
                raise Exception("Invalid header for import file")

            # normalize our header names, removing quotes and spaces
            headers = [cls.normalize_value(_).lower() for _ in header]
            
        return headers


    @classmethod
    def import_csv(cls, task, log=None):

        from xlrd import XLRDError
        filename = task.csv_file.file
        user = task.created_by

        import_params = None

        # additional parameters are optional
        if task.import_params:
            try:
                import_params = simplejson.loads(task.import_params)
            except:
                pass

        try:
            records = cls.import_xls(filename, user, import_params, log)
        except XLRDError:
            records = cls.import_raw_csv(filename, user, import_params, log)

        return records

    @classmethod
    def normalize_value(cls, val):
        # remove surrounding whitespace
        val = val.strip()

        # if surrounded by double quotes, remove those
        if val and val[0] == '"' and val[-1] == '"':
            val = val[1:-1]

        # if surrounded by single quotes, remove those
        if val and val[0] == "'" and val[-1] == "'":
            val = val[1:-1]

        return val

    @classmethod
    def import_xls(cls, filename, user, import_params, log=None):
        from xlrd import open_workbook
        workbook = open_workbook(filename.name, 'rb')

        records = []

        for sheet in workbook.sheets():
            # read our header
            header = []
            for col in range(sheet.ncols):
                header.append(unicode(sheet.cell(0, col).value))
            header = [cls.normalize_value(_).lower() for _ in header]

            cls.validate_import_header(header)

            # read our rows
            line_number = 1
            for row in range(sheet.nrows - 1):
                field_values = []
                for col in range(sheet.ncols):
                    field_values.append(unicode(sheet.cell(row + 1, col).value))

                field_values = [cls.normalize_value(_) for _ in field_values]
                field_values = dict(zip(header, field_values))
                field_values['created_by'] = user
                field_values['modified_by'] = user

                try:
                    field_values = cls.prepare_fields(field_values, import_params, user)
                    record = cls.create_instance(field_values)
                    if record:
                        records.append(record)
                except Exception as e:
                    if log:
                        traceback.print_exc(100, log)
                    raise Exception("Line %d: %s\n\n%s" % (line_number, str(e), field_values))
                line_number += 1
            # only care about the first sheet
            break

        return records


    @classmethod
    def import_raw_csv(cls, filename, user, import_params, log=None):
        # our alternative codec, by default we are the crazy windows encoding
        ascii_codec = 'cp1252'

        # read the entire file, look for mac_roman characters
        reader = open(filename.name, "rb")
        for byte in reader.read():
            # these are latin accented characterse in mac_roman, if we see them then our alternative
            # encoding should be mac_roman
            if ord(byte) in [0x81, 0x8d, 0x8f, 0x90, 0x9d]:
                ascii_codec = 'mac_roman'
                break
        reader.close()

        reader = open(filename.name, "rU")

        def unicode_csv_reader(utf8_data, dialect=csv.excel, **kwargs):
            csv_reader = csv.reader(utf8_data, dialect=dialect, **kwargs)
            for row in csv_reader:
                encoded = []
                for cell in row:
                    try:
                        cell = unicode(cell)
                    except:
                        cell = unicode(cell.decode(ascii_codec))

                    encoded.append(cell)

                yield encoded

        reader = unicode_csv_reader(reader)

        # read in our header
        line_number = 0

        header = reader.next()
        line_number += 1
        while header is not None and len(header[0]) > 1 and header[0][0] == "#":
            header = reader.next()
            line_number += 1

        # do some sanity checking to make sure they uploaded the right kind of file
        if len(header) < 1:
            raise Exception("Invalid header for import file")

        # normalize our header names, removing quotes and spaces
        header = [cls.normalize_value(_).lower() for _ in header]

        cls.validate_import_header(header)

        records = []
        for row in reader:
            # trim all our values
            row = [cls.normalize_value(_) for _ in row]

            line_number += 1

            # make sure there are same number of fields
            if len(row) != len(header):
                raise Exception("Line %d: The number of fields for this row is incorrect. Expected %d but found %d." % (line_number, len(header), len(row)))

            field_values = dict(zip(header, row))
            field_values['created_by'] = user
            field_values['modified_by'] = user
            try:
                field_values = cls.prepare_fields(field_values, import_params, user)
                record = cls.create_instance(field_values)
                if record:
                    records.append(record)
            except Exception as e:
                if log:
                    traceback.print_exc(100, log)
                raise Exception("Line %d: %s\n\n%s" % (line_number, str(e), field_values))
        return records

class ActiveManager(models.Manager):
    """
    A manager that only selects items which are still active.
    """
    def get_query_set(self):
        """
        Where the magic happens, we automatically throw on an extra is_active = True to every filter
        """
        return super(ActiveManager, self).get_query_set().filter(is_active=True)

########NEW FILE########
__FILENAME__ = pdf
import StringIO
from django.http import HttpResponse
from django.conf import settings
import os

# Mixin that will change a class based view to render as PDF
#
# Dependencies:
#    - reportlab
#    - html5lib
#    - pisa
#
class PDFMixin(object):

    def render_to_response(self, context, **response_kwargs):
        import ho.pisa as pisa
        response = super(PDFMixin, self).render_to_response(context, **response_kwargs)
        
        # do the actual rendering
        response.render()

        # and get the content
        result = StringIO.StringIO()
            
        # now render with pisa as PDF
        pdf = pisa.pisaDocument(StringIO.StringIO(response.rendered_content.encode("ISO-8859-1")), result, link_callback=fetch_resource)
        if not pdf.err:
            return HttpResponse(result.getvalue(), mimetype='application/pdf')
        return HttpResponse('We had some errors<pre>%s</pre>' % escape(html))

def fetch_resource(uri, rel):
    path = os.path.join(settings.STATICFILES_DIRS[0], uri.replace(settings.STATIC_URL, ""))
    return path


########NEW FILE########
__FILENAME__ = smartmin
from django import template
from datetime import datetime, timedelta
from django.utils import simplejson
from django.template import TemplateSyntaxError
from django.conf import settings
from django.core.urlresolvers import reverse
from django.utils import timezone
import pytz

register = template.Library()

@register.assignment_tag
def get_hostname():
    if settings.HOSTNAME:
        return settings.HOSTNAME
    return "localhost"

@register.simple_tag(takes_context=True)
def get_list_class(context, list):
    """
    Returns the class to use for the passed in list.  We just build something up
    from the object type for the list.
    """
    css = "list_%s_%s" % (list.model._meta.app_label, list.model._meta.module_name)
    return css

def format_datetime(time):
    """
    Formats a date, converting the time to the user timezone if one is specified
    """
    user_time_zone = timezone.get_current_timezone()
    if time.tzinfo is None:
        time = time.replace(tzinfo = pytz.utc)
        user_time_zone = pytz.timezone(getattr(settings, 'USER_TIME_ZONE', 'GMT'))

    time = time.astimezone(user_time_zone)
    return time.strftime("%b %d, %Y %H:%M")

@register.simple_tag(takes_context=True)
def get_value_from_view(context, field):
    """
    Responsible for deriving the displayed value for the passed in 'field'.

    This first checks for a particular method on the ListView, then looks for a method
    on the object, then finally treats it as an attribute.
    """
    view = context['view']
    obj = None
    if 'object' in context:
        obj = context['object']

    value = view.lookup_field_value(context, obj, field)

    # it's a date
    if type(value) == datetime:
        return format_datetime(value)

    return value

@register.simple_tag(takes_context=True)
def get_value(context, obj, field):
    """
    Responsible for deriving the displayed value for the passed in 'field'.

    This first checks for a particular method on the ListView, then looks for a method
    on the object, then finally treats it as an attribute.
    """
    view = context['view']
    value = view.lookup_field_value(context, obj, field)
    if type(value) == datetime:
        return format_datetime(value)

    return value

@register.simple_tag(takes_context=True)
def get_class(context, field, obj=None):
    """
    Looks up the class for this field
    """
    view = context['view']
    return view.lookup_field_class(field, obj, "field_" + field)

@register.simple_tag(takes_context=True)
def get_label(context, field, obj=None):
    """
    Responsible for figuring out the right label for the passed in field.

    The order of precedence is:
       1) if the view has a field_config and a label specified there, use that label
       2) check for a form in the view, if it contains that field, use it's value
    """
    view = context['view']
    return view.lookup_field_label(context, field, obj)

@register.simple_tag(takes_context=True)
def get_field_link(context, field, obj=None):
    """
    Determine what the field link should be for the given field, object pair
    """
    view = context['view']
    return view.lookup_field_link(context, field, obj)

@register.simple_tag(takes_context=True)
def view_as_json(context):
    """
    Returns our view serialized as json
    """
    view = context['view']
    return simplejson.dumps(view.as_json(context))

@register.simple_tag(takes_context=True)
def ssl_url(context, url_name, args=None):
    path = reverse(url_name, args)
    if getattr(settings, 'SESSION_COOKIE_SECURE', False):
        return "https://%s%s" % (settings.HOSTNAME, path)
    else:
        return path

@register.simple_tag(takes_context=True)
def non_ssl_url(context, url_name, args=None):
    path = reverse(url_name, args)
    if settings.HOSTNAME != "localhost":
        return "http://%s%s" % (settings.HOSTNAME, path)
    return path

@register.filter
def field(form, field):
    try:
        return form[field]
    except KeyError:
        return None

@register.filter
def map(string, args):
    return string % args.__dict__

@register.filter
def gmail_time(dtime, now=None):
    if dtime.tzinfo is None:
        dtime = dtime.replace(tzinfo = pytz.utc)
        user_time_zone = pytz.timezone(getattr(settings, 'USER_TIME_ZONE', 'GMT'))
        dtime = dtime.astimezone(user_time_zone)
    else:
        dtime = dtime.astimezone(timezone.get_current_timezone())

    if not now:
        now = timezone.now()

    if now.tzinfo is None:
        now = now.replace(tzinfo = pytz.utc)

    twelve_hours_ago = now - timedelta(hours=12)

    if dtime > twelve_hours_ago:
        return "%d:%s %s" % (int(dtime.strftime("%I")), dtime.strftime("%M"), dtime.strftime("%p").lower())
    elif now.year == dtime.year:
        return "%s %d" % (dtime.strftime("%b"), int(dtime.strftime("%d")))
    else:
        return "%d/%d/%s" % (int(dtime.strftime("%d")), int(dtime.strftime("%m")), dtime.strftime("%y"))

@register.filter
def user_as_string(user):
    first_name = user.first_name if user.first_name and len(user.first_name) > 0 else None
    last_name = user.last_name if user.last_name and len(user.last_name) > 0 else None

    if first_name and last_name:
        return "%s %s" % (first_name, last_name)

    if first_name:
        return first_name
    elif last_name:
        return last_name
    else:
        return user.username

@register.filter
def field_help(view, field):
    """
    Returns the field help for the passed in field
    """
    return view.lookup_field_help(field)

@register.filter
def get(dictionary, key):
    """
    Simple dict lookup using two variables
    """
    if key in dictionary:
        return dictionary[key]
    else:
        return ''

@register.filter
def is_smartobject(obj):
    """
    Returns whether the passed in object is a smart object
    """
    return hasattr(obj, 'is_active')

@register.filter
def field_orderable(view, field):
    """
    Returns whether the passed in field is orderable
    """
    return view.lookup_field_orderable(field)

#
# Woot woot, simple pdb debugging. {% pdb %}
#
class PDBNode(template.Node):
    def render(self, context):
        import pdb; pdb.set_trace()

@register.tag
def pdb(parser, token):
    return PDBNode()

@register.simple_tag(takes_context=True)
def getblock(context, prefix, suffix=None):
    key = prefix
    if suffix:
        key += str(suffix)

    if not 'blocks' in context:
        raise TemplateSyntaxError("setblock/endblock can only be used with SmartView or it's subclasses")

    if key in context['blocks']:
        return context['blocks'][key]
    else:
        return ""

def setblock(parser, token):
    args = token.split_contents()
    if len(args) < 2:
        raise TemplateSyntaxError("setblock tag takes one argument, the name of the block got: [%s]" % ",".join(args))

    key = "".join(args[1:])
        
    nodelist = parser.parse(('endsetblock',))
    parser.delete_first_token()
    return SetBlockNode(key, nodelist)

class SetBlockNode(template.Node):
    def __init__(self, key, nodelist):
        self.key = key
        self.nodelist = nodelist
        
    def render(self, context):
        if not 'blocks' in context:
            raise TemplateSyntaxError("setblock/endblock can only be used with SmartView or it's subclasses")
        
        output = self.nodelist.render(context)
        context['blocks'][self.key] = output
        return ""

# register our tag
setblock = register.tag(setblock)

@register.inclusion_tag('smartmin/field.html', takes_context=True)
def render_field(context, field):
    form = context['form']
    view = context['view']

    readonly_fields = view.derive_readonly()

    # check that this field exists in our form, either as a real field or as a readonly one
    if not field in form.fields and not field in readonly_fields:
        raise TemplateSyntaxError("Error: No field '%s' found in form to render" % field)

    inclusion_context = dict(field = field,
                             form = context['form'],
                             view = context['view'],
                             blocks = context['blocks'])
    if 'object' in context:
        inclusion_context['object'] = context['object']

    return inclusion_context

@register.simple_tag
def active(request, pattern):
    """
    Simple tag let us define a regex for the active navigation tab
    """
    import re
    if re.search(pattern, request.path):
        return 'active'
    return ''

########NEW FILE########
__FILENAME__ = tests
from urlparse import urlparse
from django.contrib.auth.models import Group, User
from django.core.urlresolvers import reverse
from django.test.testcases import TestCase
from django.conf import settings

class SmartminTest(TestCase):

    def fetch_protected(self, url, user, post_data=None, failOnFormValidation=True):
        """
        Fetches the given url. Fails if it can be fetched without first logging in as given user
        """

        # make sure we are logged out before testing permissions
        self.client.logout()

        # can't load if we aren't logged in
        response = self.client.get(url)
        self.assertRedirect(response, reverse("users.user_login"), msg="'%s' loaded without being logged in first" % url)
        self.login(user)

        # but now we can!
        if not post_data:
            response = self.client.get(url)
            self.assertEquals(200, response.status_code)
        else:
            response = self.client.post(url, data=post_data)
            self.assertNotRedirect(response, reverse("users.user_login"), msg="Unexpected redirect to login")

            if failOnFormValidation:
                self.assertNoFormErrors(response, post_data)
                self.assertEquals(302, response.status_code)

        return response

    def assertLoginRedirect(self, response, msg=None):
        self.assertRedirect(response, settings.LOGIN_URL, msg)

    def assertRedirect(self, response, url, msg=None):
        self.assertEquals(302, response.status_code, msg=msg)
        segments = urlparse(response.get('Location', None))
        self.assertEquals(segments.path, url, msg=msg)

    def assertNotRedirect(self, response, url, msg=None):
        if response.status_code == 302:
            segments = urlparse(response.get('Location', None))
            self.assertNotEqual(segments.path, url, msg=msg)

    def create_user(self, username, group_names=[]):
        # Create a user to run our CRUDL tests
        user = User.objects.create_user(username, "%s@nyaruka.com" % username)
        user.set_password(username)
        user.save()
        for group in group_names:
            user.groups.add(Group.objects.get(name=group))
        return user

    def login(self, user):
        self.assertTrue(self.client.login(username=user.username, password=user.username), "Couldn't login as %(user)s / %(user)s" % dict(user=user.username))

    def assertNoFormErrors(self, response, post_data=None):
        if response.status_code == 200 and 'form' in response.context:
            form = response.context['form']

            if not form.is_valid():
                errors = []
                for k,v in form.errors.iteritems():
                    errors.append("%s=%s" % (k,v.as_text()))
                self.fail("Create failed with form errors: %s, Posted: %s" % (",".join(errors), post_data))

class _CRUDLTest(SmartminTest):

    crudl = None
    user = None
    object = None

    def setUp(self):
        self.crudl = None
        self.user = None
        super(_CRUDLTest, self).setUp()

    def getCRUDL(self):
        if self.crudl:
            return self.crudl()
        raise Exception("Must define self.crudl")

    def getUser(self):
        if self.user:
            return self.user
        raise Exception("Must define self.user")

    def getCreatePostData(self):
        raise Exception("Missing method: %s.getCreatePostData()" % self.__class__.__name__)

    def getUpdatePostData(self):
        raise Exception("Missing method: %s.getUpdatePostData()" % self.__class__.__name__)

    def getTestObject(self):
        if self.object:
            return self.object

        if self.getCRUDL().permissions:
            self.login(self.getUser())

        # create our object
        create_page = reverse(self.getCRUDL().url_name_for_action('create'))
        post_data = self.getCreatePostData()
        self.client.post(create_page, data=post_data)

        # find our created object
        self.object = self.getCRUDL().model.objects.get(**post_data)
        return self.object

    def testCreate(self):
        if 'create' not in self.getCRUDL().actions:
            return
        self._do_test_view('create', post_data=self.getCreatePostData())

    def testRead(self):
        if 'read' not in self.getCRUDL().actions:
            return
        self._do_test_view('read', self.getTestObject())

    def testUpdate(self):
        if 'update' not in self.getCRUDL().actions:
            return
        self._do_test_view('update', self.getTestObject(), post_data=self.getUpdatePostData())

    def testDelete(self):
        if 'delete' not in self.getCRUDL().actions:
            return
        object = self.getTestObject()
        self._do_test_view('delete', object, post_data=dict())
        self.assertEquals(0, len(self.getCRUDL().model.objects.filter(pk=object.pk)))

    def testList(self):
        if 'list' not in self.getCRUDL().actions:
            return
        # have at least one object
        self.getTestObject()
        self._do_test_view('list')

    def testCsv(self):
        if 'csv' not in self.getCRUDL().actions:
            return
        # have at least one object
        self.getTestObject()
        self._do_test_view('csv')

    def _do_test_view(self, action=None, object=None, post_data=None, query_string=None):
        if not action:
            import pdb; pdb.set_trace()
            print "testing view %s.%s" % (self.__class__.__name__, action)

        url_name = self.getCRUDL().url_name_for_action(action)
        if object:
            url = reverse(url_name, args=[object.pk])
        else:
            url = reverse(url_name)

        # append our query string if we have one
        if query_string:
            url = "%s?%s" % (url, query_string)

        # make sure we are logged out before testing permissions
        self.client.logout()

        response = self.client.get(url)

        view = self.getCRUDL().view_for_action(action)
        if self.getCRUDL().permissions and view.permission is not None:
            self.assertRedirect(response, reverse("users.user_login"), msg="Page for '%s' loaded without being logged in first" % action)
            self.login(self.getUser())
            response = self.client.get(url)

        fn = "assert%sGet" % action.capitalize()
        self.assertPageGet(action, response)
        if hasattr(self, fn):
            getattr(self, fn)(response)

        if post_data is not None:
            response = self.client.post(url, data=post_data)

            self.assertPagePost(action, response)
            fn = "assert%sPost" % action.capitalize()
            if hasattr(self, fn):
                getattr(self, fn)(response)

        return response

    def assertPageGet(self, action, response):
        if response.status_code == 302:
            self.fail("'%s' resulted in an unexpected redirect to: %s" % (action, response.get('Location')))
        self.assertEquals(200, response.status_code, )

    def assertPagePost(self, action, response):
        self.assertNoFormErrors(response)

########NEW FILE########
__FILENAME__ = middleware
from datetime import datetime

from django.conf import settings
from django.core.urlresolvers import reverse
from django.http import HttpResponseRedirect, HttpResponse
from .models import PasswordHistory
import django.views.static

class ChangePasswordMiddleware:
    """
    Redirects all users to the password change form if we find that a user's
    password is expired.
    """
    def __init__(self):
        self.password_expire = getattr(settings, 'USER_PASSWORD_EXPIRATION', -1)

    def process_view(self, request, view, *args, **kwargs):
        newpassword_path = reverse('users.user_newpassword', args=[0])
        logout_path = reverse('users.user_logout')

        if (self.password_expire < 0 or not request.user.is_authenticated() or 
            view == django.views.static.serve or request.path == newpassword_path or request.path == logout_path):
            return

        if PasswordHistory.is_password_expired(request.user):
            return HttpResponseRedirect(reverse('users.user_newpassword', args=['0']))

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.contrib.auth.models import User
from django.conf import settings
from django.contrib.auth.hashers import check_password
from datetime import timedelta
from django.utils import timezone
import re

def is_password_complex(password):
    has_caps = re.search('[A-Z]+', password)
    has_lower = re.search('[a-z]+', password)
    has_digit = re.search('[0-9]+', password)
    
    if len(password) < 8 or (len(password) < 12 and (not has_caps or not has_lower or not has_digit)):
        return False
    else:
        return True

class RecoveryToken(models.Model):
    user = models.ForeignKey(User)
    token = models.CharField(max_length=32, unique=True, default=None, help_text="token to reset password")
    created_on = models.DateTimeField(auto_now_add=True)

class FailedLogin(models.Model):
    user = models.ForeignKey(User)
    failed_on = models.DateTimeField(auto_now_add=True)

class PasswordHistory(models.Model):
    user = models.ForeignKey(User,
                             help_text="The user that set a password")
    password = models.CharField(max_length=255,
                                help_text="The hash of the password that was set")
    set_on = models.DateTimeField(auto_now_add=True,
                                  help_text="When the password was set")

    @classmethod
    def is_password_repeat(cls, user, password):
        password_window = getattr(settings, 'USER_PASSWORD_REPEAT_WINDOW', -1)
        if password_window <= 0:
            return False

        # check their current password
        if check_password(password, user.password):
            return True

        # get all the passwords in the past year
        window_ago = timezone.now() - timedelta(days=password_window)
        previous_passwords = PasswordHistory.objects.filter(user=user, set_on__gte=window_ago)
        for previous in previous_passwords:
            if check_password(password, previous.password):
                return True

        return False

    @classmethod
    def is_password_expired(cls, user):
        password_expiration = getattr(settings, 'USER_PASSWORD_EXPIRATION', -1)

        if password_expiration <= 0:
            return False

        # get the most recent password change
        last_password = PasswordHistory.objects.filter(user=user).order_by('-set_on')

        last_set = user.date_joined
        if last_password:
            last_set = last_password[0].set_on

        # calculate how long ago our password was set
        today = timezone.now()
        difference = (today - last_set)

        # return whether that is expired
        return difference.days > password_expiration
            



########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url

from .views import *
from django.contrib.auth.views import logout
from django.conf import settings

logout_url = getattr(settings, 'LOGOUT_REDIRECT_URL', None)

urlpatterns = patterns('',
    url(r'^login/$', login, dict(template_name='smartmin/users/login.html'), name="users.user_login"),
    url(r'^logout/$', logout, dict(redirect_field_name='go', next_page=logout_url), name="users.user_logout"),        
)

urlpatterns += UserCRUDL().as_urlpatterns()




########NEW FILE########
__FILENAME__ = views
from django.contrib.auth.models import User, Group
from django.contrib.auth.views import login as django_login
from django import forms
from django.conf import settings
from .models import *
from django.http import HttpResponseRedirect
from django.shortcuts import render_to_response, render
from django.contrib.auth import login, authenticate, REDIRECT_FIELD_NAME
from django.contrib.auth.forms import AuthenticationForm
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.utils.translation import ugettext_lazy as _

from django.shortcuts import render
from django.core.mail import send_mail
import random
import string

from django.utils import timezone
from datetime import timedelta

from django.template import loader, Context
from smartmin.views import *

import re

class UserForm(forms.ModelForm):
    new_password = forms.CharField(label=_("New Password"), widget=forms.PasswordInput)
    groups = forms.ModelMultipleChoiceField(widget=forms.CheckboxSelectMultiple, queryset=Group.objects.all(), required=False)

    def clean_new_password(self):
        password = self.cleaned_data['new_password']

        # if they specified a new password
        if password and not is_password_complex(password):
            raise forms.ValidationError(_("Passwords must have at least 8 characters, including one uppercase, one lowercase and one number"))

        return password

    def save(self, commit=True):
        """
        Overloaded so we can save any new password that is included.
        """
        is_new_user = self.instance.pk is None
        
        user = super(UserForm, self).save(commit)

        # new users should be made active by default
        if is_new_user:
            user.is_active = True

        # if we had a new password set, use it
        new_pass = self.cleaned_data['new_password']
        if new_pass:
            user.set_password(new_pass)
            if commit: user.save()

        return user
    class Meta:
        model = User
        fields = ('username', 'new_password', 'first_name', 'last_name', 'email', 'groups', 'is_active')

class UserUpdateForm(UserForm):
    new_password = forms.CharField(label=_("New Password"), widget=forms.PasswordInput, required=False)

    def clean_new_password(self):
        password = self.cleaned_data['new_password']

        if password and not is_password_complex(password):
            raise forms.ValidationError(_("Passwords must have at least 8 characters, including one uppercase, one lowercase and one number"))

        if password and PasswordHistory.is_password_repeat(self.instance, password):
            raise forms.ValidationError(_("You have used this password before in the past year, please use a new password."))

        return password

class UserProfileForm(UserForm):
    old_password = forms.CharField(label=_("Password"), widget=forms.PasswordInput, required=False)
    new_password = forms.CharField(label=_("New Password"), widget=forms.PasswordInput, required=False)
    confirm_new_password = forms.CharField(label=_("Confirm Password"), widget=forms.PasswordInput, required=False)

    def clean_old_password(self):
        user = self.instance

        if(not user.check_password(self.cleaned_data['old_password'])):
            raise forms.ValidationError(_("Please enter your password to save changes."))

        return self.cleaned_data['old_password']

    def clean_confirm_new_password(self):
        if not 'new_password' in self.cleaned_data:
            return None

        if(not self.cleaned_data['confirm_new_password'] and self.cleaned_data['new_password']):
            raise forms.ValidationError(_("Confirm the new password by filling the this field"))

        if(self.cleaned_data['new_password'] != self.cleaned_data['confirm_new_password']):
            raise forms.ValidationError(_("New password doesn't match with its confirmation"))

        password = self.cleaned_data['new_password']
        if password and not is_password_complex(password):
            raise forms.ValidationError(_("Passwords must have at least 8 characters, including one uppercase, one lowercase and one number"))

        if password and PasswordHistory.is_password_repeat(self.instance, password):
            raise forms.ValidationError(_("You have used this password before in the past year, please use a new password."))

        return self.cleaned_data['new_password']

class UserForgetForm(forms.Form):
    email = forms.EmailField(label=_("Your Email"),)

    def clean_email(self):
        email = self.cleaned_data['email'].strip()

        allow_email_recovery = getattr(settings, 'USER_ALLOW_EMAIL_RECOVERY', True)
        if not allow_email_recovery:
            raise forms.ValidationError(_("E-mail recovery is not supported, please contact the website administrator to reset your password manually."))
        
        return email
    
class SetPasswordForm(UserForm):
    old_password = forms.CharField(label=_("Current Password"), widget=forms.PasswordInput, required=True,
                                   help_text=_("Your current password"))
    new_password = forms.CharField(label=_("New Password"), widget=forms.PasswordInput, required=True,
                                   help_text=_("Your new password."))
    confirm_new_password = forms.CharField(label=_("Confirm new Password"), widget=forms.PasswordInput, required=True,
                                           help_text=_("Confirm your new password."))

    def clean_old_password(self):
        user = self.instance
        if(not user.check_password(self.cleaned_data['old_password'])):
            raise forms.ValidationError(_("Please enter your password to save changes"))

        return self.cleaned_data['old_password']

    def clean_confirm_new_password(self):
        if not 'new_password' in self.cleaned_data:
            return None

        if(not self.cleaned_data['confirm_new_password'] and self.cleaned_data['new_password']):
            raise forms.ValidationError(_("Confirm your new password by entering it here"))

        if(self.cleaned_data['new_password'] != self.cleaned_data['confirm_new_password']):
            raise forms.ValidationError(_("Mismatch between your new password and confirmation, try again"))

        password = self.cleaned_data['new_password']
        if password and not is_password_complex(password):
            raise forms.ValidationError(_("Passwords must have at least 8 characters, including one uppercase, one lowercase and one number"))

        if password and PasswordHistory.is_password_repeat(self.instance, password):
            raise forms.ValidationError(_("You have used this password before in the past year, please use a new password."))

        return self.cleaned_data['new_password']

class UserCRUDL(SmartCRUDL):
    model = User
    permissions = True
    actions = ('create', 'list', 'update', 'profile', 'forget', 'recover', 'expired', 'failed', 'newpassword', 'mimic')

    class List(SmartListView):
        search_fields = ('username__icontains','first_name__icontains', 'last_name__icontains')
        fields = ('username', 'name', 'group', 'last_login')
        link_fields = ('username', 'name')
        default_order = 'username'
        add_button = True
        template_name = "smartmin/users/user_list.html"
        
        def get_context_data(self, **kwargs):
            context = super(UserCRUDL.List, self).get_context_data(**kwargs)
            context['groups'] = Group.objects.all()
            context['group_id'] = int(self.request.REQUEST.get('group_id', 0))
            return context

        def get_group(self, obj):
            return ", ".join([group.name for group in obj.groups.all()])

        def get_queryset(self, **kwargs):
            queryset = super(UserCRUDL.List, self).get_queryset(**kwargs)
            group_id = int(self.request.REQUEST.get('group_id', 0))

            # filter by the group
            if group_id:
                queryset = queryset.filter(groups=group_id)
                
                # Ignore superusers, staff users and anonymous users
            return queryset.filter(id__gte=0).exclude(is_staff=True).exclude(is_superuser=True).exclude(password=None)
        
        def get_name(self, obj):
            return " ".join((obj.first_name, obj.last_name))

    class Create(SmartCreateView):
        form_class = UserForm
        fields = ('username', 'new_password', 'first_name', 'last_name', 'email', 'groups')
        success_message = _("New user created successfully.")

        field_config = {
            'groups': dict(label=_("Groups"), help=_("Users will only get those permissions that are allowed for their group.")),
            'new_password': dict(label=_("Password"), help=_("Set the user's initial password here.")),
        }

        def post_save(self, obj):
            """
            Make sure our groups are up to date
            """
            if 'groups' in self.form.cleaned_data:
                for group in self.form.cleaned_data['groups']:
                    obj.groups.add(group)

            return obj
        
    class Update(SmartUpdateView):
        form_class = UserUpdateForm
        template_name = "smartmin/users/user_update.html"
        success_message = "User saved successfully."
        fields = ('username', 'new_password', 'first_name', 'last_name', 'email', 'groups', 'is_active', 'last_login')
        field_config = {
            'last_login': dict(readonly=True, label=_("Last Login")),
            'is_active': dict(label=_("Is Active"), help=_("Whether this user is allowed to log into the site")),
            'groups': dict(label=_("Groups"), help=_("Users will only get those permissions that are allowed for their group")),
            'new_password': dict(label=_("New Password"), help=_("You can reset the user's password by entering a new password here")),
        }

        def post_save(self, obj):
            """
            Make sure our groups are up to date
            """
            if 'groups' in self.form.cleaned_data:
                obj.groups.clear()
                for group in self.form.cleaned_data['groups']:
                    obj.groups.add(group)

            # if a new password was set, reset our failed logins
            if 'new_password' in self.form.cleaned_data and self.form.cleaned_data['new_password']:
                FailedLogin.objects.filter(user=self.object).delete()
                PasswordHistory.objects.create(user=obj, password=obj.password)

            return obj

    class Profile(SmartUpdateView):
        form_class = UserProfileForm
        success_message = "User profile saved successfully."
        fields = ('username', 'old_password', 'new_password', 'confirm_new_password',
                  'first_name', 'last_name', 'email')
        field_config = {
            'username': dict(readonly=True, label=_("Username")),
            'old_password': dict(label=_("Password"), help=_("Your password")),
            'new_password': dict(label=_("New Password"), help=_("If you want to set a new password, enter it here")),
            'confirm_new_password': dict(label=_("Confirm New Password"), help=_("Confirm your new password")),
        }

        def post_save(self, obj):
            obj = super(UserCRUDL.Profile, self).post_save(obj)
            if 'new_password' in self.form.cleaned_data and self.form.cleaned_data['new_password']:
                FailedLogin.objects.filter(user=self.object).delete()
                PasswordHistory.objects.create(user=obj, password=obj.password)

            return obj

        def get_object(self, queryset=None):
            return self.request.user

        def derive_title(self):
            return _("Edit your profile")

    class Forget(SmartFormView):
        title = _("Password Recovery")
        template_name = '/smartmin/users/user_forget.html'
        form_class = UserForgetForm
        permission = None
        success_message = _("An Email has been sent to your account with further instructions.")
        success_url = "@users.user_login"
        fields = ('email', )

        def form_valid(self, form):
            email = form.cleaned_data['email']
            hostname = getattr(settings, 'HOSTNAME', self.request.get_host())

            col_index = hostname.find(':')
            domain = hostname[:col_index] if col_index > 0 else hostname

            from_email = getattr(settings, 'DEFAULT_FROM_EMAIL', 'website@%s' % domain)

            protocol = 'https' if self.request.is_secure() else 'http'

            user = User.objects.filter(email=email)
            if user:
                user = user[0]

                token = ''.join(random.choice(string.ascii_uppercase + string.digits) for x in range(32))
                RecoveryToken.objects.create(token=token, user=user)
                email_template = loader.get_template('smartmin/users/user_email.txt')
                FailedLogin.objects.filter(user=user).delete()
                context = Context(dict(website=hostname, user=user,
                                       link='%s://%s/users/user/recover/%s/' % (protocol, hostname, token)))
                user.email_user(_("Password Recovery"), email_template.render(context) , from_email)
            else:
                email_template = loader.get_template('smartmin/users/no_user_email.txt')
                context = Context(dict(website=hostname))
                send_mail(_('Password Recovery Request'), email_template.render(context), from_email,
                          [email], fail_silently=False)

            response = super(UserCRUDL.Forget, self).form_valid(form)
            return response

    class Newpassword(SmartUpdateView):
        form_class = SetPasswordForm
        fields = ('old_password', 'new_password', 'confirm_new_password')
        title = _("Pick a new password")
        template_name = 'smartmin/users/user_newpassword.html'
        success_message = _("Your password has successfully been updated, thank you.")

        def get_context_data(self, *args, **kwargs):
            context_data = super(UserCRUDL.Newpassword, self).get_context_data(*args, **kwargs)
            context_data['expire_days'] = getattr(settings, 'USER_PASSWORD_EXPIRATION', -1)
            context_data['window_days'] = getattr(settings, 'USER_PASSWORD_REPEAT_WINDOW', -1)
            return context_data

        def has_permission(self, request, *args, **kwargs):
            return request.user.is_authenticated()

        def get_object(self, queryset=None):
            return self.request.user

        def post_save(self, obj):
            obj = super(UserCRUDL.Newpassword, self).post_save(obj)
            PasswordHistory.objects.create(user=obj, password=obj.password)
            return obj

        def get_success_url(self):
            return settings.LOGIN_REDIRECT_URL

    class Mimic(SmartUpdateView):
        fields = ('id',)

        def derive_success_message(self):
            return _("You are now logged in as %s") % self.object.username

        def pre_process(self, request, *args, **kwargs):
                user = self.get_object()
                login(request, user)
                # After logging in it is important to change the user stored in the session
                # otherwise the user will remain the same
                request.session["_auth_user_id"] = user.id
                return HttpResponseRedirect(settings.LOGIN_REDIRECT_URL)

    class Recover(SmartUpdateView):
        form_class = SetPasswordForm
        permission = None
        success_message = _("Password Updated Successfully. Now you can log in using your new password.")
        success_url = '@users.user_login'
        fields = ('new_password', 'confirm_new_password')
        title = _("Reset your Password")

        @classmethod
        def derive_url_pattern(cls, path, action):
            return r'^%s/%s/(?P<token>\w+)/$' % (path, action)

        def pre_process(self, request, *args, **kwargs):
            token = self.kwargs.get('token')
            validity_time = timezone.now() - timedelta(hours=48)
            recovery_token = RecoveryToken.objects.filter(created_on__gt=validity_time, token=token)
            if not recovery_token:
                messages.info(request, _("Your link has expired for security reasons. Please reinitiate the process by entering your email here."))
                return HttpResponseRedirect(reverse("users.user_forget"))
            return super(UserCRUDL.Recover, self).pre_process(request, args, kwargs)

        def get_object(self, queryset=None):
            token = self.kwargs.get('token')
            recovery_token= RecoveryToken.objects.get(token=token)
            return recovery_token.user
 
        def post_save(self, obj):
            obj = super(UserCRUDL.Recover, self).post_save(obj)
            validity_time = timezone.now() - timedelta(hours=48)
            RecoveryToken.objects.filter(user=obj).delete()
            RecoveryToken.objects.filter(created_on__lt=validity_time).delete()
            PasswordHistory.objects.create(user=obj, password=obj.password)
            return obj

    class Expired(SmartView, TemplateView):
        permission = None
        template_name = 'smartmin/users/user_expired.html'

    class Failed(SmartView, TemplateView):
        permission = None
        template_name = 'smartmin/users/user_failed.html'

        def get_context_data(self, *args, **kwargs):
            context = super(UserCRUDL.Failed, self).get_context_data(*args, **kwargs)

            lockout_timeout = getattr(settings, 'USER_LOCKOUT_TIMEOUT', 10)
            failed_login_limit = getattr(settings, 'USER_FAILED_LOGIN_LIMIT', 5)
            allow_email_recovery = getattr(settings, 'USER_ALLOW_EMAIL_RECOVERY', True)

            context['lockout_timeout'] = lockout_timeout
            context['failed_login_limit'] = failed_login_limit
            context['allow_email_recovery'] = allow_email_recovery
            
            return context

def login(request, template_name='smartmin/users/login.html',
          redirect_field_name=REDIRECT_FIELD_NAME,
          authentication_form=AuthenticationForm,
          current_app=None, extra_context=None):

    lockout_timeout = getattr(settings, 'USER_LOCKOUT_TIMEOUT', 10)
    failed_login_limit = getattr(settings, 'USER_FAILED_LOGIN_LIMIT', 5)
    allow_email_recovery = getattr(settings, 'USER_ALLOW_EMAIL_RECOVERY', True)

    if request.method == "POST":
        if 'username' in request.REQUEST and 'password' in request.REQUEST:
            username = request.REQUEST['username']

            user = User.objects.filter(username=username)

            # this could be a valid login by a user
            if user:
                user = user[0]

                # incorrect password?  create a failed login token
                valid_password = user.check_password(request.REQUEST['password'])
                if not valid_password:
                    FailedLogin.objects.create(user=user)
    
                bad_interval = timezone.now() - timedelta(minutes=lockout_timeout)
                failures = FailedLogin.objects.filter(user=user)

                # if the failures reset after a period of time, then limit our query to that interval
                if lockout_timeout > 0:
                    failures = failures.filter(failed_on__gt=bad_interval)

                # if there are too many failed logins, take them to the failed page
                if len(failures) >= failed_login_limit:
                    return HttpResponseRedirect(reverse('users.user_failed'))

                # delete failed logins if the password is valid
                elif valid_password:
                    FailedLogin.objects.filter(user=user).delete()

    return django_login(request, template_name='smartmin/users/login.html',
                        redirect_field_name=REDIRECT_FIELD_NAME,
                        authentication_form=AuthenticationForm,
                        current_app=None, extra_context=dict(allow_email_recovery=allow_email_recovery))

########NEW FILE########
__FILENAME__ = views
from django.db import models

from django.utils.encoding import force_unicode
from django.views.generic.edit import FormMixin, ModelFormMixin, UpdateView, CreateView, ProcessFormView, FormView
from django.views.generic.base import TemplateView, View
from django.views.generic import DetailView, ListView
import django.forms.models as model_forms
from guardian.utils import get_anonymous_user
from django.utils.http import urlquote
from django.db.models import Q
from django.db import IntegrityError
from django.conf import settings
from django.contrib.auth import REDIRECT_FIELD_NAME
from django.http import HttpResponseRedirect, HttpResponse
from guardian.shortcuts import get_objects_for_user, assign
from django.core.exceptions import ImproperlyConfigured
from django import forms
from django.utils import simplejson
from django.conf.urls import patterns, url
from django.core.urlresolvers import reverse
from django.contrib import messages
from django.contrib.auth.models import User
from django.utils.translation import ugettext_lazy as _

import string
from smartmin.csv_imports.models import ImportTask
import widgets

def smart_url(url, id=None):
    """
    URLs that start with @ are reversed, using the passed in arguments.

    Otherwise a straight % substitution is applied.
    """
    if url.find("@") >= 0:
        (args, value) = url.split('@')

        if args:
            return reverse(value, args=[id])
        else:
            return reverse(value)
    else:
        if id is None:
            return url
        else:
            return url % id

class SmartView(object):
    fields = None
    exclude = None
    field_config = {}
    title = None
    refresh = 0
    template_name = None
    pjax = None

    # set by our CRUDL
    url_name = None

    # if we are part of a CRUDL, we keep a reference to it here, set by CRUDL
    crudl = None

    def __init__(self, *args):
        """
        There are a few variables we want to mantain in the instance, not the
        class.
        """
        self.extra_context = {}
        super(SmartView, self).__init__()

    def derive_title(self):
        """
        Returns the title used on this page.
        """
        return self.title

    @classmethod
    def derive_url_pattern(cls, path, action):
        """
        Returns the URL pattern for this view.
        """
        return r'^%s/%s/$' % (path, action)

    def has_permission(self, request, *args, **kwargs):
        """
        Figures out if the current user has permissions for this view.
        """
        self.kwargs = kwargs
        self.args = args
        self.request = request
        
        if not getattr(self, 'permission', None):
            return True
        else:
            # first check our anonymous permissions
            real_anon = get_anonymous_user()
            has_perm = real_anon.has_perm(self.permission)            

            # if not, then check our real permissions
            if not has_perm:
                has_perm = request.user.has_perm(self.permission)

            # if not, perhaps we have it per object
            if not has_perm:
                has_perm = self.has_object_permission('get_object')

            # if still no luck, check if we have permissions on the parent object
            if not has_perm:
                has_perm = self.has_object_permission('get_parent_object')

            return has_perm

    def has_object_permission(self, getter_name):
        """
        Checks for object level permission for an arbitrary getter
        """
        obj = None
        obj_getter = getattr(self, getter_name, None)

        # get object requires pk
        if getter_name == "get_object" and 'pk' not in self.kwargs:
            return False

        if obj_getter:
            obj = obj_getter()
            if obj:
                return self.request.user.has_perm(getattr(self, 'permission', None), obj)

    def dispatch(self, request, *args, **kwargs):
        """
        Overloaded to check permissions if appropriate
        """
        def wrapper(request, *args, **kwargs):
            if not self.has_permission(request, *args, **kwargs):
                path = urlquote(request.get_full_path())
                login_url = kwargs.pop('login_url', settings.LOGIN_URL)
                redirect_field_name = kwargs.pop('redirect_field_name', REDIRECT_FIELD_NAME)
                return HttpResponseRedirect("%s?%s=%s" % (login_url, redirect_field_name, path))
            else:
                response = self.pre_process(request, *args, **kwargs)
                if not response:
                    return super(SmartView, self).dispatch(request, *args, **kwargs)
                else:
                    return response

        return wrapper(request, *args, **kwargs)

    def pre_process(self, request, *args, **kwargs):
        """
        Gives the view an opportunity to intercept this response and return a different
        response instead.  This can be used to check some precondition for example and to
        redirect the user somewhere else if they are not met.

        Views which wish to use this should return a Response object.
        """
        return None

    def lookup_obj_attribute(self, obj, field):
        """
        Looks for a field's value from the passed in obj.  Note that this will strip
        leading attributes to deal with subelements if possible
        """
        curr_field = field.encode('ascii', 'ignore')
        rest = None

        if field.find('.') >= 0:
            curr_field = field.split('.')[0]
            rest = '.'.join(field.split('.')[1:])

        # next up is the object itself
        obj_field = getattr(obj, curr_field, None)

        # if it is callable, do so
        if obj_field and getattr(obj_field, '__call__', None):
            obj_field = obj_field()

        if obj_field and rest:
            return self.lookup_obj_attribute(obj_field, rest)
        else:
            return obj_field

    def lookup_field_value(self, context, obj, field):
        """
        Looks up the field value for the passed in object and field name.

        Note that this method is actually called from a template, but this provides a hook
        for subclasses to modify behavior if they wish to do so.

        This may be used for example to change the display value of a variable depending on
        other variables within our context.
        """
        # if this isn't a subfield, check the view to see if it has a get_ method
        if field.find('.') == -1:
            # view supercedes all, does it have a 'get_' method for this obj
            view_method = getattr(self, 'get_%s' % field.encode('ascii', 'ignore'), None)
            if view_method:
                return view_method(obj)

        return self.lookup_obj_attribute(obj, field)

    def lookup_field_label(self, context, field, default=None):
        """
        Figures out what the field label should be for the passed in field name.

        Our heuristic is as follows:
            1) we check to see if our field_config has a label specified
            2) if not, then we derive a field value from the field name
        """
        # if this is a subfield, strip off everything but the last field name
        if field.find('.') >= 0:
            return self.lookup_field_label(context, field.split('.')[-1], default)
        
        label = None

        # is there a label specified for this field
        if field in self.field_config and 'label' in self.field_config[field]:
            label = self.field_config[field]['label']

        # if we were given a default, use that
        elif default:
            label = default

        # check our model
        else:
            for model_field in self.model._meta.fields:
                if model_field.name == field:
                    return model_field.verbose_name.title()

        # otherwise, derive it from our field name
        if label is None:
            label = self.derive_field_label(field)

        return label

    def lookup_field_help(self, field, default=None):
        """
        Looks up the help text for the passed in field.
        """
        help = None

        # is there a label specified for this field
        if field in self.field_config and 'help' in self.field_config[field]:
            help = self.field_config[field]['help']

        # if we were given a default, use that
        elif default:
            help = default

        # try to see if there is a description on our model
        elif hasattr(self, 'model'):
            for model_field in self.model._meta.fields:
                if model_field.name == field:
                    help = model_field.help_text
                    break

        return help

    def lookup_field_class(self, field, obj=None, default=None):
        """
        Looks up any additional class we should include when rendering this field
        """
        css = ""

        # is there a class specified for this field
        if field in self.field_config and 'class' in self.field_config[field]:
            css = self.field_config[field]['class']

        # if we were given a default, use that
        elif default:
            css = default

        return css

    def derive_field_label(self, field, obj=None):
        """
        Derives a field label for the passed in field name.
        """
        # replace _'s with ' '
        label = field.replace('_', ' ').title()
        return label

    def derive_field_config(self):
        """
        Derives the field config for this instance.  By default we just use
        self.field_config
        """
        return self.field_config

    def get_template_names(self):
        """
        Returns the name of the template to use to render this request.

        Smartmin provides default templates as fallbacks, so appends it's own templates names to the end
        of whatever list is built by the generic views.

        Subclasses can override this by setting a 'template_name' variable on the class.
        """
        templates = []
        if getattr(self, 'template_name', None):
            templates.append(self.template_name)

        if getattr(self, 'default_template', None):
            templates.append(self.default_template)
        else:
            templates = super(SmartView, self).get_template_names()

        return templates

    def derive_fields(self):
        """
        Default implementation
        """
        fields = []
        if self.fields:
            fields.append(self.fields)

        return fields

    def derive_exclude(self):
        """
        Returns which fields we should exclude
        """
        exclude = []
        if self.exclude:
            exclude += self.exclude

        return exclude

    def derive_refresh(self):
        """
        Returns how many milliseconds before we should refresh
        """
        return self.refresh

    def get_context_data(self, **kwargs):
        """
        We supplement the normal context data by adding our fields and labels.
        """
        context = super(SmartView, self).get_context_data(**kwargs)

        # derive our field config
        self.field_config = self.derive_field_config()

        # add our fields
        self.fields = self.derive_fields()

        # build up our current parameter string, EXCLUSIVE of our page.  These
        # are used to build pagination URLs
        url_params = "?"
        order_params = ""
        for key in self.request.REQUEST.keys():
            if key != 'page' and key != 'pjax' and key[0] != '_':
                for value in self.request.REQUEST.getlist(key):
                    url_params += "%s=%s&" % (key, value)
            elif key == '_order':
                order_params = "&".join(["%s=%s" % (key, _) for _ in self.request.REQUEST.getlist(key)])

        context['url_params'] = url_params
        context['order_params'] = order_params + "&"
        context['pjax'] = self.pjax

        # set our blocks
        context['blocks'] = dict()

        # stuff it all in our context
        context['fields'] = self.fields
        context['view'] = self
        context['field_config'] = self.field_config

        context['title'] = self.derive_title()

        # and any extra context the user specified
        context.update(self.extra_context)

        # by default, our base is 'base.html', but we might be pjax
        base_template = "base.html"
        if 'pjax' in self.request.REQUEST or 'pjax' in self.request.POST:
            base_template = "smartmin/pjax.html"

        if 'HTTP_X_PJAX' in self.request.META:
            base_template = "smartmin/pjax.html"

        context['base_template'] = base_template

        # set our refresh if we have one
        refresh = self.derive_refresh()
        if refresh:
            context['refresh'] = refresh

        return context

    def as_json(self, context):
        """
        Responsible for turning our context into an dict that can then be serialized into an
        JSON response.
        """
        return context

    def render_to_response(self, context, **response_kwargs):
        """
        Overloaded to deal with _format arguments.
        """
        # should we actually render in json?
        if '_format' in self.request.REQUEST and self.request.REQUEST['_format'] == 'json':
          json = self.as_json(context)
          return HttpResponse(simplejson.dumps(json), mimetype='application/javascript')

        # otherwise, return normally
        else:
            return super(SmartView, self).render_to_response(context)

class SmartTemplateView(SmartView, TemplateView):
    pass

class SmartReadView(SmartView, DetailView):
    default_template = 'smartmin/read.html'
    edit_button = False

    field_config = { 'modified_blurb': dict(label="Modified"),
                     'created_blurb': dict(label="Created") }


    def derive_queryset(self):
        return super(SmartReadView, self).get_queryset()

    def get_queryset(self):
        self.queryset = self.derive_queryset()
        return self.queryset

    def derive_title(self):
        """
        By default we just return the string representation of our object
        """
        return str(self.object)

    @classmethod
    def derive_url_pattern(cls, path, action):
        """
        Returns the URL pattern for this view.
        """
        return r'^%s/%s/(?P<pk>\d+)/$' % (path, action)

    def derive_fields(self):
        """
        Derives our fields.  We first default to using our 'fields' variable if available,
        otherwise we figure it out from our object.
        """
        if self.fields:
            return list(self.fields)

        else:
            fields = []
            for field in self.object._meta.fields:
                fields.append(field.name)

            # only exclude?  then remove those items there
            exclude = self.derive_exclude()

            # remove any excluded fields
            fields = [field for field in fields if field not in exclude]

            return fields

    def get_modified_blurb(self, obj):
        return "%s by %s" % (obj.modified_on.strftime("%B %d, %Y at %I:%M %p"), obj.modified_by)

    def get_created_blurb(self, obj):
        return "%s by %s" % (obj.created_on.strftime("%B %d, %Y at %I:%M %p"), obj.created_by)

class SmartDeleteView(SmartView, DetailView, ProcessFormView):
    default_template = 'smartmin/delete_confirm.html'
    name_field = 'name'
    cancel_url = None
    redirect_url = None

    @classmethod
    def derive_url_pattern(cls, path, action):
        """
        Returns the URL pattern for this view.
        """
        return r'^%s/%s/(?P<pk>\d+)/$' % (path, action)

    def get_cancel_url(self):
        if not self.cancel_url:
            raise ImproperlyConfigured("DeleteView must define a cancel_url")

        return smart_url(self.cancel_url, self.object.id)

    def pre_delete(self, obj):
        pass

    def post(self, request, *args, **kwargs):
        self.object = self.get_object()
        self.pre_delete(self.object)
        redirect_url = self.get_redirect_url()
        self.object.delete()

        return HttpResponseRedirect(redirect_url)

    def get_redirect_url(self, **kwargs):
        if not self.redirect_url:
            raise ImproperlyConfigured("DeleteView must define a redirect_url")

        return smart_url(self.redirect_url)

    def get_context_data(self, **kwargs):
        """ Add in the field to use for the name field """
        context = super(SmartDeleteView, self).get_context_data(**kwargs)
        context['name_field'] = self.name_field
        context['cancel_url'] = self.get_cancel_url()
        return context

class SmartListView(SmartView, ListView):
    default_template = 'smartmin/list.html'

    link_url = None
    link_fields = None
    add_button = False
    search_fields = None
    paginate_by = 25
    field_config = { 'is_active': dict(label=''), }
    default_order = None
    select_related = None

    list_permission = None

    @classmethod
    def derive_url_pattern(cls, path, action):
        if action == 'list':
            return r'^%s/$' % (path)
        else:
            return r'^%s/%s/$' % (path, action)

    def derive_search_fields(self):
        """
        Derives our search fields, by default just returning what was set
        """
        return self.search_fields

    def derive_title(self):
        """
        Derives our title from our list
        """
        title = super(SmartListView, self).derive_title()

        if not title:
            return force_unicode(self.model._meta.verbose_name_plural).title()
        else:
            return title

    def derive_link_fields(self, context):
        """
        Used to derive which fields should be linked.  This should return a set() containing
        the names of those fields which should be linkable.
        """
        if not self.link_fields is None:
            return self.link_fields

        else:
            link_fields = set()
            if self.fields:
                for field in self.fields:
                    if field != 'is_active':
                        link_fields.add(field)
                        break

        return link_fields

    def lookup_field_link(self, context, field, obj):
        """
        By default we just return /view/{{ id }}/ for the current object.
        """
        return smart_url(self.link_url, str(obj.id))

    def lookup_field_orderable(self, field):
        """
        Returns whether the passed in field is sortable or not, by default all 'raw' fields, that
        is fields that are part of the model are sortable.
        """
        try:
            self.model._meta.get_field_by_name(field)
            return True
        except:
            # that field doesn't exist, so not sortable
            return False

    def get_context_data(self, **kwargs):
        """
        Add in what fields are linkable
        """
        context = super(SmartListView, self).get_context_data(**kwargs)

        # our linkable fields
        self.link_fields = self.derive_link_fields(context)

        # stuff it all in our context
        context['link_fields'] = self.link_fields

        # our search term if any
        if 'search' in self.request.REQUEST:
            context['search'] = self.request.REQUEST['search']

        # our ordering field if any
        order = self.derive_ordering()
        if order:
            if order[0] == '-':
                context['order'] = order[1:]
                context['order_asc'] = False
            else:
                context['order'] = order
                context['order_asc'] = True

        return context

    def derive_select_related(self):
        return self.select_related

    def derive_queryset(self, **kwargs):
        """
        Derives our queryset.
        """
        # get our parent queryset
        queryset = super(SmartListView, self).get_queryset(**kwargs)

        # apply any filtering
        search_fields = self.derive_search_fields()
        if search_fields and 'search' in self.request.REQUEST:
            terms = self.request.REQUEST['search'].split()

            query = Q(pk__gt=0)
            for term in terms:
                term_query = Q(pk__lt=0)
                for field in search_fields:
                    term_query |= Q(**{ field: term })
                query &= term_query

            queryset = queryset.filter(query)

        # add any select related
        related = self.derive_select_related()
        if related:
            queryset = queryset.select_related(*related)

        # return our queryset
        return queryset

    def get_queryset(self, **kwargs):
        """
        Gets our queryset.  This takes care of filtering if there are any
        fields to filter by.
        """
        queryset = self.derive_queryset(**kwargs)

        # if our list should be filtered by a permission as well, do so
        if self.list_permission:
            # only filter if this user doesn't have a global permission
            if not self.request.user.has_perm(self.list_permission):
                user = self.request.user
                # guardian only behaves with model users
                if settings.ANONYMOUS_USER_ID and user.is_anonymous():
                    user = User.objects.get(pk=settings.ANONYMOUS_USER_ID)
                queryset = queryset.filter(id__in=get_objects_for_user(user, self.list_permission))

        return self.order_queryset(queryset)

    def derive_ordering(self):
        """
        Returns what field should be used for ordering (using a prepended '-' to indicate descending sort).

        If the default order of the queryset should be used, returns None
        """
        if '_order' in self.request.REQUEST:
            return self.request.REQUEST['_order']
        elif self.default_order:
            return self.default_order
        else:
            return None

    def order_queryset(self, queryset):
        """
        Orders the passed in queryset, returning a new queryset in response.  By default uses the _order query
        parameter.
        """
        order = self.derive_ordering()
        
        # if we get our order from the request
        # make sure it is a valid field in the list 
        if '_order' in self.request.REQUEST:
            if order not in self.derive_fields():
                order = None
        

        if order:
            # if our order is a single string, convert to a simple list
            if isinstance(order, (str, unicode)):
                order = (order,)

            queryset = queryset.order_by(*order)

        return queryset

    def derive_fields(self):
        """
        Derives our fields.
        """
        if self.fields:
            return self.fields

        else:
            fields = []
            for field in self.object_list.model._meta.fields:
                if field.name != 'id':
                    fields.append(field.name)
            return fields


    def get_is_active(self, obj):
        """
        Default implementation of get_is_active which returns a simple div so as to
        render a green dot for active items and nothing for inactive ones.

        Users of SmartModel will get this rendering for free.
        """
        if obj.is_active:
            return '<div class="active_icon"></div>'
        else:
            return ''

    def render_to_response(self, context, **response_kwargs):
        """
        Overloaded to deal with _format arguments.
        """
        # is this a select2 format response?
        if self.request.REQUEST.get('_format', 'html') == 'select2':

            results = []
            for obj in context['object_list']:
                result = None
                if hasattr(obj, 'as_select2'):
                    result = obj.as_select2()

                if not result:
                    result = dict(id=obj.pk, text="%s" % obj)

                results.append(result)

            json = dict(results=results, err='nil', more=context['page_obj'].has_next())
            return HttpResponse(simplejson.dumps(json), mimetype='application/javascript')
        # otherwise, return normally
        else:
            return super(SmartListView, self).render_to_response(context)

class SmartCsvView(SmartListView):

    def derive_filename(self):
        filename = getattr(self, 'filename', None)
        if not filename:
            filename = "%s.csv" % self.model._meta.verbose_name.lower()
        return filename

    def render_to_response(self, context, **response_kwargs):
        import csv

        # Create the HttpResponse object with the appropriate CSV header.
        response = HttpResponse(mimetype='text/csv; charset=utf-8')
        response['Content-Disposition'] = 'attachment; filename=%s' % self.derive_filename()

        writer = csv.writer(response, quoting=csv.QUOTE_ALL)
        
        fields = self.derive_fields()

        # build up our header row
        header = []
        for field in fields:
            header.append(unicode(self.lookup_field_label(dict(), field)))
        writer.writerow([s.encode("utf-8") for s in header])

        # then our actual values
        for obj in self.object_list:
            row = []
            for field in fields:
                row.append(unicode(self.lookup_field_value(dict(), obj, field)))
            writer.writerow([s.encode("utf-8") for s in row])

        return response


class SmartXlsView(SmartListView):

    def derive_filename(self):
        filename = getattr(self, 'filename', None)
        if not filename:
            filename = "%s.xls" % self.model._meta.verbose_name.lower()
        return filename

    def render_to_response(self, context, **response_kwargs):

        from xlwt import Workbook
        book = Workbook()
        sheet1 = book.add_sheet(self.derive_title())
        fields = self.derive_fields()

        # build up our header row
        for col in range(len(fields)):
            field = fields[col]
            sheet1.write(0, col, unicode(self.lookup_field_label(dict(), field)))

        # then our actual values
        for row in range(len(self.object_list)):
            obj = self.object_list[row]
            for col in range(len(fields)):
                field = fields[col]
                value = unicode(self.lookup_field_value(dict(), obj, field))
                # skip the header
                sheet1.write(row + 1, col, value)

        # Create the HttpResponse object with the appropriate header.
        response = HttpResponse(mimetype='application/vnd.ms-excel')
        response['Content-Disposition'] = 'attachment; filename=%s' % self.derive_filename()
        book.save(response)
        return response


class SmartFormMixin(object):
    readonly = ()
    field_config = {'modified_blurb': dict(label="Modified"),
                    'created_blurb': dict(label="Created")}
    success_message = None
    submit_button_name = _("Submit")

    def derive_title(self):
        """
        Derives our title from our object
        """
        if not self.title:
            return _("Form")
        else:
            return self.title

    def derive_success_message(self):
        """
        Returns a message to display when this form is successfully saved
        """
        return self.success_message
    
    def get_form(self, form_class):
        """
        Returns an instance of the form to be used in this view.
        """
        self.form = super(SmartFormMixin, self).get_form(form_class)

        fields = list(self.derive_fields())

        # apply our field filtering on our form class
        exclude = self.derive_exclude()
        exclude += self.derive_readonly()

        # remove any excluded fields
        for field in exclude:
            if field in self.form.fields:
                del self.form.fields[field]
            
        if fields is not None:
            # filter out our form fields
            for name, field in self.form.fields.items():
                if not name in fields:
                    del self.form.fields[name]

        # stuff in our referer as the default location for where to return
        location = forms.CharField(widget=forms.widgets.HiddenInput(), required=False)

        if ('HTTP_REFERER' in self.request.META):
            location.initial = self.request.META['HTTP_REFERER']

        # add the location to our form fields
        self.form.fields['loc'] = location

        if fields:
            fields.append('loc')

        # provides a hook to programmatically customize fields before rendering
        for (name, field) in self.form.fields.items():
            field = self.customize_form_field(name, field)
            self.form.fields[name] = field

        return self.form

    def customize_form_field(self, name, field):
        """
        Allows views to customize their form fields.  By default, Smartmin replaces the plain textbox
        date input with it's own DatePicker implementation.
        """
        if isinstance(field, forms.fields.DateField) and isinstance(field.widget, forms.widgets.DateInput):
            field.widget = widgets.DatePickerWidget()

        if isinstance(field, forms.fields.ImageField) and isinstance(field.widget, forms.widgets.ClearableFileInput):
            field.widget = widgets.ImageThumbnailWidget()
        
        return field

    def lookup_field_label(self, context, field, default=None):
        """
        Figures out what the field label should be for the passed in field name.

        We overload this so as to use our form to see if there is label set there.  If so
        then we'll pass that as the default instead of having our parent derive
        the field from the name.
        """
        default = None

        for form_field in self.form:
            if form_field.name == field:
                default = form_field.label
                break

        return super(SmartFormMixin, self).lookup_field_label(context, field, default=default)

    def lookup_field_help(self, field, default=None):
        """
        Looks up the help text for the passed in field.

        This is overloaded so that we can check whether our form has help text set
        explicitely.  If so, we will pass this as the default to our parent function.
        """
        default = None

        for form_field in self.form:
            if form_field.name == field:
                default = form_field.help_text
                break

        return super(SmartFormMixin, self).lookup_field_help(field, default=default)

    def derive_readonly(self):
        """
        Figures out what fields should be readonly.  We iterate our field_config to find all
        that have a readonly of true
        """
        readonly = list(self.readonly)
        for key, value in self.field_config.items():
            if 'readonly' in value and value['readonly']:
                readonly.append(key)

        return readonly

    def derive_fields(self):
        """
        Derives our fields.
        """
        if self.fields is not None:
            fields = list(self.fields)
        else:
            form = self.form
            fields = []
            for field in form:
                fields.append(field.name)

            # this is slightly confusing but we add in readonly fields here because they will still
            # need to be displayed
            readonly = self.derive_readonly()
            if readonly:
                fields += readonly

        # remove any excluded fields
        for exclude in self.derive_exclude():
            if exclude in fields:
                fields.remove(exclude)

        return fields

    def get_form_class(self):
        """
        Returns the form class to use in this view
        """
        form_class = None
        
        if self.form_class:
            form_class = self.form_class

        else:
            if self.model is not None:
                # If a model has been explicitly provided, use it
                model = self.model
            elif hasattr(self, 'object') and self.object is not None:
                # If this view is operating on a single object, use
                # the class of that object
                model = self.object.__class__
            else:
                # Try to get a queryset and extract the model class
                # from that
                model = self.get_queryset().model

            # run time parameters when building our form
            factory_kwargs = self.get_factory_kwargs()
            form_class = model_forms.modelform_factory(model, **factory_kwargs)

        return form_class

    def get_factory_kwargs(self):
        """
        Let's us specify any extra parameters we might want to call for our form factory.
        
        These can include: 'form', 'fields', 'exclude' or 'formfield_callback'
        """
        params = dict()

        exclude = self.derive_exclude()
        exclude += self.derive_readonly()

        if self.fields:
            fields = list(self.fields)
            for ex in exclude:
                if ex in fields:
                    fields.remove(ex)
            
            params['fields'] = fields

        if exclude:
            params['exclude'] = exclude

        return params

    def get_success_url(self):
        """
        By default we use the referer that was stuffed in our
        form when it was created
        """
        if self.success_url:
            # if our smart url references an object, pass that in
            if self.success_url.find('@') > 0:
                return smart_url(self.success_url, self.object.pk)
            else:
                return smart_url(self.success_url, None)
        
        elif 'loc' in self.form.cleaned_data:
            return self.form.cleaned_data['loc']
        
        raise ImproperlyConfigured("No redirect location found, override get_success_url to not use redirect urls")


    def derive_initial(self):
        """
        Returns what initial dict should be passed to our form. By default this is empty.
        """
        return dict()

    def get_form_kwargs(self):
        """
        We override this, using only those fields specified if they are specified.

        Otherwise we include all fields in a standard ModelForm.
        """
        kwargs = super(SmartFormMixin, self).get_form_kwargs()
        kwargs['initial'] = self.derive_initial()
        return kwargs

    def derive_submit_button_name(self):
        """
        Returns the name for our button
        """
        return self.submit_button_name

    def get_context_data(self, **kwargs):
        context = super(SmartFormMixin, self).get_context_data(**kwargs)
        context['submit_button_name'] = self.derive_submit_button_name()
        return context

class SmartFormView(SmartFormMixin, SmartView, FormView):
    default_template = 'smartmin/form.html'

    def form_valid(self, form):
        # plug in our success message
        messages.success(self.request, self.derive_success_message())
        return super(SmartFormView, self).form_valid(form)

class SmartModelFormView(SmartFormMixin, SmartView, ModelFormMixin):
    grant_permissions = None
    javascript_submit = None

    field_config = { 'modified_blurb': dict(label="Modified"),
                     'created_blurb': dict(label="Created") }    

    def derive_title(self):
        """
        Derives our title from our object
        """
        if not self.title:
            return _("Edit %s") % force_unicode(self.model._meta.verbose_name).title()
        else:
            return self.title
    
    def pre_save(self, obj):
        """
        Called before an object is saved away
        """
        return obj

    def save(self, obj):
        """
        Actually does the saving of this object, this is when the object is committed
        """
        self.object.save()
        self.save_m2m()



    def form_valid(self, form):
        self.object = form.save(commit=False)

        try:
            self.object = self.pre_save(self.object)
            self.save(self.object)
            self.object = self.post_save(self.object)
        
            messages.success(self.request, self.derive_success_message())
            if 'HTTP_X_FORMAX' not in self.request.META:
                return HttpResponseRedirect(self.get_success_url())
            else:
                response = self.render_to_response(self.get_context_data(form=form))
                response['REDIRECT'] = self.get_success_url()
                return response

        except IntegrityError as e:
            message = str(e).capitalize()
            errors = self.form._errors.setdefault(forms.forms.NON_FIELD_ERRORS, forms.util.ErrorList())
            errors.append(message)
            return self.render_to_response(self.get_context_data(form=form))

    def save_m2m(self):
        """
        By default saves the form's m2m, can be overridden if a more complicated m2m model exists
        """
        self.form.save_m2m()

    def post_save(self, obj):
        """
        Called after an object is successfully saved
        """
        # if we have permissions to grant, do so
        if self.grant_permissions:
            for permission in self.grant_permissions:
                # if the user doesn't have this permission globally already
                if not self.request.user.has_perm(permission):
                    # then assign it for this object
                    assign(permission, self.request.user, self.object)

        return obj

    def get_context_data(self, **kwargs):
        context = super(SmartModelFormView, self).get_context_data(**kwargs)
        context['javascript_submit'] = self.javascript_submit
        return context

class SmartUpdateView(SmartModelFormView, UpdateView):
    default_template = 'smartmin/update.html'
    exclude = ('created_by', 'modified_by')
    submit_button_name = _("Save Changes")

    # allows you to specify the name of URL to use for a remove link that will automatically be shown
    delete_url = None

    def derive_queryset(self):
        return super(SmartUpdateView, self).get_queryset()

    def get_queryset(self):
        self.queryset = self.derive_queryset()
        return self.queryset

    @classmethod
    def derive_url_pattern(cls, path, action):
        """
        Returns the URL pattern for this view.
        """
        return r'^%s/%s/(?P<pk>\d+)/$' % (path, action)

    def derive_success_message(self):
        # First check whether a default message has been set
        if self.success_message is None:
            return "Your %s has been updated." % self.model._meta.verbose_name
        else:
            return self.success_message

    def pre_save(self, obj):
        # auto populate modified_by if it is present
        if hasattr(obj, 'modified_by_id') and self.request.user.id >= 0:
            obj.modified_by = self.request.user

        return obj

    def get_context_data(self, **kwargs):
        context = super(SmartUpdateView, self).get_context_data(**kwargs)

        if self.delete_url:
            context['delete_url'] = smart_url(self.delete_url, self.object.id)
            
        return context

    def get_modified_blurb(self, obj):
        return "%s by %s" % (obj.modified_on.strftime("%B %d, %Y at %I:%M %p"), obj.modified_by)

    def get_created_blurb(self, obj):
        return "%s by %s" % (obj.created_on.strftime("%B %d, %Y at %I:%M %p"), obj.created_by)

class SmartMultiFormView(SmartView, TemplateView):
    default_template = 'smartmin/multi_form.html'
    forms = {}

    # allows you to specify the name of URL to use for a remove link that will automatically be shown
    delete_url = None

    def get(self, request, *args, **kwargs):
        context = self.get_context_data(**kwargs)

        page_forms = []
        for prefix, form in self.forms.items():
            f = form(prefix=prefix)
            page_forms.append(f)

        context['forms'] = page_forms

        return self.render_to_response(context)

    def post(self, request, *args, **kwargs):
        context = self.get_context_data(**kwargs)

        # process our forms
        page_forms = []
        valid = True
        for prefix, form in self.forms.items():
            f = form(request.POST, prefix=prefix)
            valid = valid and f.is_valid()
            page_forms.append(f)

        if not valid:
            context['forms'] = page_forms
            return self.render_to_response(context)
        else:
            # redirect to success page
            pass

    def get_context_data(self, **kwargs):
        context = super(SmartMultiFormView, self).get_context_data(**kwargs)

        if self.delete_url:
            context['delete_url'] = smart_url(self.delete_url, self.object.id)
            
        return context

class SmartCreateView(SmartModelFormView, CreateView):
    default_template = 'smartmin/create.html'
    exclude = ('created_by', 'modified_by', 'is_active')
    submit_button_name = _("Create")

    def pre_save(self, obj):
        # auto populate created_by if it is present
        if hasattr(obj, 'created_by_id') and self.request.user.id >= 0:
            obj.created_by = self.request.user

        # auto populate modified_by if it is present
        if hasattr(obj, 'modified_by_id') and self.request.user.id >= 0:
            obj.modified_by = self.request.user            

        return obj

    def derive_success_message(self):
        # First check whether a default message has been set
        if self.success_message is None:
            return _("Your new %s has been created.") % self.model._meta.verbose_name
        else:
            return self.success_message

    def derive_title(self):
        """
        Derives our title from our object
        """
        if not self.title:
            return _("Create %s") % force_unicode(self.model._meta.verbose_name).title()
        else:
            return self.title

class SmartCSVImportView(SmartCreateView):
    success_url = 'id@csv_imports.importtask_read'

    fields = ('csv_file',)

    def derive_title(self):
        return _("Import %s") % self.crudl.model._meta.verbose_name_plural.title()

    def pre_save(self, obj):
        obj = super(SmartCSVImportView, self).pre_save(obj)
        obj.model_class = "%s.%s" % (self.crudl.model.__module__, self.crudl.model.__name__)
        return obj

    def post_save(self, task):
        task = super(SmartCSVImportView, self).post_save(task)

        task.import_params = simplejson.dumps(self.form.data)

        # kick off our CSV import
        task.start()

        return task

class SmartCRUDL(object):
    actions = ('create', 'read', 'update', 'delete', 'list')
    model_name = None
    app_name = None
    module_name = None
    path = None
    
    permissions = True

    def __init__(self, model=None, path=None, actions=None):
        # set our model if passed in
        if model:
            self.model = model

        # derive our model name
        if not self.model_name:
            self.model_name = self.model._meta.object_name

        # derive our app name
        if not self.app_name:
            self.app_name = self.model._meta.app_label

        # derive our path from our class name
        if not path and not self.path:
            self.path = self.model_name.lower()

        # derive our module name from our class's module
        if not self.module_name:
            parts = self.__class__.__module__.split(".")
            self.module_name = parts[-2]

            # deal with special case of views subdirectories, we need to go up one more to find the real module
            if self.module_name == 'views' and len(parts) >= 3:
                self.module_name = parts[-3]

        # set our actions if set
        if actions:
            self.actions = actions

    def permission_for_action(self, action):
        """
        Returns the permission to use for the passed in action
        """
        return "%s.%s_%s" % (self.app_name.lower(), self.model_name.lower(), action)

    def template_for_action(self, action):
        """
        Returns the template to use for the passed in action
        """
        return "%s/%s_%s.html" % (self.module_name.lower(), self.model_name.lower(), action)

    def url_name_for_action(self, action):
        """
        Returns the reverse name for this action
        """
        return "%s.%s_%s" % (self.module_name.lower(), self.model_name.lower(), action)        

    def view_for_action(self, action):
        """
        Returns the appropriate view class for the passed in action
        """
        # this turns replace_foo into ReplaceFoo and read into Read
        class_name = "".join([word.capitalize() for word in action.split("_")])
        view = None

        # see if we have a custom class defined for this action
        if hasattr(self, class_name):
            # return that one
            view = getattr(self, class_name)

            # no model set?  set it ourselves
            if not getattr(view, 'model', None):
                view.model = self.model

            # no permission and we are supposed to set them, do so
            if not hasattr(view, 'permission') and self.permissions:
                view.permission = self.permission_for_action(action)

            # set our link URL based on read and update
            if not getattr(view, 'link_url', None):
                if 'read' in self.actions:
                    view.link_url = 'id@%s' % self.url_name_for_action('read')
                elif 'update' in self.actions:
                    view.link_url = 'id@%s' % self.url_name_for_action('update')
                else:
                    view.link_fields = ()

            # set add_button based on existance of Create view if add_button not explicitely set
            if not getattr(view, 'add_button', None) and (action == 'list' and 'create' in self.actions):
                view.add_button = True

            # set edit_button based on existance of Update view if edit_button not explicitely set
            if not getattr(view, 'edit_button', None) and (action == 'read' and 'update' in self.actions):
                view.edit_button = True

            # if update or create, set success url if not set
            if not getattr(view, 'success_url', None) and (action == 'update' or action == 'create'):
                view.success_url = '@%s' % self.url_name_for_action('list')

        # otherwise, use our defaults
        else:
            options = dict(model=self.model)

            # if this is an update or create, and we have a list view, then set the default to that
            if action == 'update' or action == 'create' and 'list' in self.actions:
                options['success_url'] = '@%s' % self.url_name_for_action('list')

            # set permissions if appropriate
            if self.permissions:
                options['permission'] = self.permission_for_action(action)

            if action == 'create':
                view = type("%sCreateView" % self.model_name, (SmartCreateView,),
                    options)

            elif action == 'read':
                if 'update' in self.actions:
                    options['edit_button'] = True

                view = type("%sReadView" % self.model_name, (SmartReadView,),
                    options)

            elif action == 'update':
                if 'delete' in self.actions:
                    options['delete_url'] = 'id@%s' % self.url_name_for_action('delete')

                view = type("%sUpdateView" % self.model_name, (SmartUpdateView,),
                    options)

            elif action == 'delete':
                if 'list' in self.actions:
                    options['cancel_url'] = '@%s' % self.url_name_for_action('list')
                    options['redirect_url'] = '@%s' % self.url_name_for_action('list')

                elif 'update' in self.actions:
                    options['cancel_url'] = '@%s' % self.url_name_for_action('update')

                view = type("%sDeleteView" % self.model_name, (SmartDeleteView,), options)

            elif action == 'list':
                if 'read' in self.actions:
                    options['link_url'] = 'id@%s' % self.url_name_for_action('read')
                elif 'update' in self.actions:
                    options['link_url'] = 'id@%s' % self.url_name_for_action('update')
                else:
                    options['link_fields'] = ()

                if 'create' in self.actions:
                    options['add_button'] = True

                view = type("%sListView" % self.model_name, (SmartListView,),
                    options)

            elif action == 'csv_import':
                options['model'] = ImportTask
                view = type("%sCSVImportView" % self.model_name, (SmartCSVImportView,), options)

        if not view:
            # couldn't find a view?  blow up
            raise Exception("No view found for action: %s" % action)

        # set the url name for this view
        view.url_name = self.url_name_for_action(action)

        # no template set for it?  set one based on our action and app name
        if not getattr(view, 'template_name', None):
            view.template_name = self.template_for_action(action)

        view.crudl = self

        return view

    def pattern_for_view(self, view, action):
        """
        Returns the URL pattern for the passed in action.
        """
        # if this view knows how to define a URL pattern, call that
        if getattr(view, 'derive_url_pattern', None):
            return view.derive_url_pattern(self.path, action)

        # otherwise take our best guess
        else:
            return r'^%s/%s/$' % (self.path, action)            

    def as_urlpatterns(self):
        """
        Creates the appropriate URL patterns for this object.
        """
        urlpatterns = patterns('')
        
        # for each of our actions
        for action in self.actions:
            view_class = self.view_for_action(action)
            view_pattern = self.pattern_for_view(view_class, action)
            name = self.url_name_for_action(action)
            urlpatterns += patterns('', url(view_pattern, view_class.as_view(), name=name))

        return urlpatterns




########NEW FILE########
__FILENAME__ = widgets
from django.forms import fields
from django.forms import widgets
from django.utils.safestring import mark_safe
from django.utils.html import escape, conditional_escape
from django.utils import timezone
from datetime import datetime

class VisibleHiddenWidget(widgets.Widget):

    def render(self, name, value, attrs=None):
        """
        Returns this Widget rendered as HTML, as a Unicode string.

        The 'value' given is not guaranteed to be valid input, so subclass
        implementations should program defensively.
        """
        html = ''
        html += '%s' % value
        html += '<input type="hidden" name="%s" value="%s">' % (escape(name), escape(value))
        return mark_safe(html)


class DatePickerWidget(widgets.Widget):

    def __init__(self, *args, **kwargs):
        super(DatePickerWidget, self).__init__(*args, **kwargs)

    def render(self, name, value, attrs=None):
        """
        Renders this widget as HTML.
        """
        html = ''
        str_value = ""
        if value:
            str_value = "%s %d, %d" % (value.strftime("%B"), value.day, value.year)

        html += '<input type="text" class="datepicker" data-provide="datepicker" name="%s" value="%s" data-date-format="MM d, yyyy" data-date-autoclose="true">' % (escape(name), escape(str_value))
        return mark_safe(html)

    def value_from_datadict(self, data, files, name):
        val = data.get(name)
        
        # try parsing it
        try:
            parsed = datetime.strptime(val, "%B %d, %Y")
            return parsed.date()
        except:
            # invalid format?  say so
            return None

    class Media:
       js = ('js/datepicker.js',)
       css = { 'all': ('css/datepicker.css',) }

class ImageThumbnailWidget(widgets.ClearableFileInput): 

    def __init__(self, thumb_width=75, thumb_height=75): 
        self.width = thumb_width 
        self.height = thumb_height 
        super(ImageThumbnailWidget, self).__init__({}) 

    def render(self, name, value, attrs=None):
        thumb_html = '<table><tr>'
        if value and hasattr(value, "url"): 
            thumb_html += '<td><img src="%s" width="%s" width="%s" /></td>' % (value.url, self.width, self.height) 

        thumb_html += '<td><input type="checkbox" name="%s-clear" /> Clear' % name
        thumb_html += '<input type="file" name="%s" /></td>' % name
        thumb_html += '</tr></table>'

        return mark_safe(unicode('<div class="image-picker">%s</div>' % thumb_html))


########NEW FILE########
__FILENAME__ = models
from django.db import models
from smartmin.models import SmartModel, ActiveManager

class Post(SmartModel):
    title = models.CharField(max_length=128,
                             help_text="The title of this blog post, keep it relevant")
    body = models.TextField(help_text="The body of the post, go crazy")
    order = models.IntegerField(help_text="The order for this post, posts with smaller orders come first")
    tags = models.CharField(max_length=128,
                            help_text="Any tags for this post")


    objects = models.Manager()
    active = ActiveManager()

    @classmethod
    def pre_create_instance(cls, field_dict):
        field_dict['body'] = "Body: %s" % field_dict['body']
        return field_dict

    def __unicode__(self):
        return self.title


class Category(SmartModel):
    name = models.SlugField(max_length=64, unique=True,
                            help_text="The name of this category")


########NEW FILE########
__FILENAME__ = tests
from django.test import TestCase
from django.test.client import Client
from django.core.urlresolvers import reverse
from django.contrib.auth.models import User, Group
from blog.models import Post, Category
from smartmin.management import check_role_permissions
from django.utils import simplejson
from .views import PostCRUDL
from smartmin.views import smart_url
from guardian.shortcuts import assign
import settings

from smartmin.users.models import *
from datetime import date, datetime, timedelta
from django.utils import timezone

class SmartminTest(TestCase):

    def setUp(self):
        self.client = Client()

        # no groups
        self.plain = User.objects.create_user('plain', 'plain@nogroups.com', 'plain')

        # part of the editor group
        self.editor = User.objects.create_user('editor', 'editor@group.com', 'editor')
        self.editor.groups.add(Group.objects.get(name="Editors"))

        # part of the Author group
        self.author = User.objects.create_user('author', 'author@group.com', 'author')
        self.author.groups.add(Group.objects.get(name="Authors"))

        # admin user
        self.superuser = User.objects.create_user('superuser', 'superuser@group.com', 'superuser')
        self.superuser.is_superuser = True
        self.superuser.save()

        self.post = Post.objects.create(title="Test Post", body="This is the body of my first test post", tags="testing_tag", order=0,
                                        created_by=self.author, modified_by=self.author)

    def assertRedirect(self, response, url):
        self.assertEquals(302, response.status_code)
        self.assertTrue(response.get('Location', None).find(reverse('users.user_login')) != -1,
                        "Did not redirect to expected URL, expected: %s, got %s" % (url, response.get('Location', None)))

    def assertNoAccess(self, user, url):
        self.client.login(username=user.username, password=user.username)
        response = self.client.get(url)
        self.assertIsLogin(response)

    def assertHasAccess(self, user, url):
        self.client.login(username=user.username, password=user.username)
        response = self.client.get(url)
        self.assertEquals(200, response.status_code, "User '%s' does not have access to URL: %s" % (user.username, url))

    def assertIsLogin(self, response):
        self.assertRedirect(response, reverse('users.user_login'))

    def test_smart_url(self):
        self.assertEquals(reverse('blog.post_create'), smart_url("@blog.post_create"))
        self.assertEquals(reverse('blog.post_update', args=[self.post.id]), smart_url("id@blog.post_update", self.post.id))
        self.assertEquals(reverse('blog.post_create'), smart_url("/blog/post/create/"))
        self.assertEquals(reverse('blog.post_update', args=[self.post.id]), smart_url("/blog/post/update/%d/", self.post.id))

    def test_permissions(self):
        create_url = reverse('blog.post_create')

        # not logged in, no dice
        response = self.client.get(create_url)
        self.assertIsLogin(response)

        # logged in as editor, still can't create
        self.assertNoAccess(self.plain, create_url)
        self.assertNoAccess(self.editor, create_url)

        # authors and superusers can create posts
        self.assertHasAccess(self.author, create_url)
        self.assertHasAccess(self.superuser, create_url)

        # updating posts 
        update_url = reverse('blog.post_update', args=[self.post.id])

        # if not logged in can't read
        self.client.logout()
        response = self.client.get(update_url)
        self.assertIsLogin(response)

        # plain user can't see it either
        self.assertNoAccess(self.plain, update_url)

        # but editors can, as can authors and superusers
        self.assertHasAccess(self.editor, update_url)
        self.assertHasAccess(self.author, update_url)
        self.assertHasAccess(self.superuser, update_url)

        # now test reading posts
        read_url = reverse('blog.post_read', args=[self.post.id])

        # if not logged in can still read
        self.client.logout()
        response = self.client.get(read_url)
        self.assertEquals(200, response.status_code)

        # everybody else can read too
        self.assertHasAccess(self.plain, read_url)
        self.assertHasAccess(self.editor, read_url)
        self.assertHasAccess(self.author, read_url)
        self.assertHasAccess(self.superuser, read_url)

        # now grant object level permission to update a single post for anonymous user
        self.client.logout()
        anon = User.objects.get(pk=settings.ANONYMOUS_USER_ID)
        assign('blog.post_update', anon, self.post)

        response = self.client.get(update_url)
        self.assertEquals(200, response.status_code)


    def test_create(self):
        self.client.login(username='author', password='author')

        post_data = dict(title="New Post", body="This is a new post", order=1, tags="post")
        response = self.client.post(reverse('blog.post_create'), post_data, follow=True)

        # get the last post
        post = list(Post.objects.all())[-1]

        self.assertEquals("New Post", post.title)
        self.assertEquals("This is a new post", post.body)
        self.assertEquals("post", post.tags)
        self.assertEquals(self.author, post.created_by)
        self.assertEquals(self.author, post.modified_by)

    def test_messaging(self):
        self.client.login(username='author', password='author')

        post_data = dict(title="New Post", body="This is a new post", order=1, tags="post")
        response = self.client.post(reverse('blog.post_create'), post_data, follow=True)

        post = list(Post.objects.all())[-1]

        self.assertEquals(200, response.status_code)
        self.assertContains(response, "Your new post has been created.")

        post_data = dict(title="New Post", body="Updated post content", order=1, tags="post")
        response = self.client.post(reverse('blog.post_update', args=[post.id]), post_data, follow=True)

        self.assertEquals(200, response.status_code)
        self.assertContains(response, "Your blog post has been updated.")

    def test_message_tags(self):
        self.client.login(username='author', password='author')
        messages_url = reverse('blog.post_messages')
        response = self.client.get(messages_url)
        self.assertIn('<div class="alert alert-error">', response.content)
        self.assertIn('<div class="alert alert-success">', response.content)
        self.assertIn('<div class="alert alert-info">', response.content)
        self.assertIn('<div class="alert alert-warning">', response.content)

    def test_template_name(self):
        self.client.login(username='author', password='author')
        response = self.client.get(reverse('blog.post_list'))
        self.assertEquals(['blog/post_list.html', 'smartmin/list.html'], response.template_name)

    def test_ordering(self):
        post1 = Post.objects.create(title="A First Post", body="Post Body", order=3, tags="post",
                                    created_by=self.author, modified_by=self.author)
        post2 = Post.objects.create(title="A Second Post", body="Post Body", order=5, tags="post",
                                    created_by=self.superuser, modified_by=self.superuser)
        post3 = Post.objects.create(title="A Third Post", body="Post Body", order=1, tags="post",
                                    created_by=self.author, modified_by=self.author)
        post4 = Post.objects.create(title="A Fourth Post", body="Post Body", order=3, tags="post",
                                    created_by=self.superuser, modified_by=self.superuser)

        self.client.login(username='author', password='author')

        response = self.client.get(reverse('blog.post_list'))
        posts = response.context['post_list']

        self.assertEquals(post1, posts[0])
        self.assertEquals(post4, posts[1])
        self.assertEquals(post2, posts[2])
        self.assertEquals(post3, posts[3])
        self.assertEquals(self.post, posts[4])

        response = self.client.get(reverse('blog.post_author'))
        posts = response.context['post_list']

        self.assertEquals(self.post, posts[0])
        self.assertEquals(post3, posts[1])
        self.assertEquals(post1, posts[2])
        self.assertEquals(post4, posts[3])
        self.assertEquals(post2, posts[4])

        # get our view as json
        response = self.client.get(reverse('blog.post_list') + "?_format=json")

        # parse the json
        json_list = simplejson.loads(response.content)
        self.assertEquals(5, len(json_list))
        self.assertEquals(post1.title, json_list[0]['title'])

        # ask for select2 format
        response = self.client.get(reverse('blog.post_list') + "?_format=select2")
        select2 = simplejson.loads(response.content)
        self.assertTrue('results' in select2)
        self.assertEquals(5, len(select2['results']))

        
        
    def test_success_url(self):
        self.client.login(username='author', password='author')

        post_data = dict(title="New Post", body="This is a new post", order=1, tags="post")
        response = self.client.post(reverse('blog.post_create'), post_data, follow=True)

        self.assertEquals(reverse('blog.post_list'), response.request['PATH_INFO'])

    def test_submit_button_name(self):
        self.client.login(username='author', password='author')

        response = self.client.get(reverse('blog.post_create'))
        self.assertContains(response, "Create New Post")

    def test_excludes(self):
        self.client.login(username='author', password='author')

        # this view excludes tags with the default form
        response = self.client.get(reverse('blog.post_exclude', args=[self.post.id]))
        self.assertEquals(0, response.content.count('tags'))

        # this view excludes tags included in a custom form
        response = self.client.get(reverse('blog.post_exclude2', args=[self.post.id]))
        self.assertEquals(0, response.content.count('tags'))

    def test_readonly(self):
        self.client.login(username='author', password='author')

        # this view should have our tags field be readonly
        response = self.client.get(reverse('blog.post_readonly', args=[self.post.id]))
        self.assertEquals(1, response.content.count('testing_tag'))
        self.assertEquals(1, response.content.count('Tags'))
        self.assertEquals(0, response.content.count('input id="id_tags"'))

        # this view should also have our tags field be readonly, but it does so on a custom form
        response = self.client.get(reverse('blog.post_readonly2', args=[self.post.id]))
        self.assertEquals(1, response.content.count('testing_tag'))
        self.assertEquals(1, response.content.count('Tags'))
        self.assertEquals(0, response.content.count('input id="id_tags"'))


    def test_integrity_error(self):
        self.client.login(username='author', password='author')

        first_category = Category.objects.create(name="History", created_by=self.author, modified_by=self.author)

        post_data = dict(name="History")
        response = self.client.post(reverse('blog.category_create'), post_data)

        # should get a plain 200
        self.assertEquals(200, response.status_code)

        # should have one error (our integrity error)
        self.assertEquals(1, len(response.context['form'].errors))

    def test_version(self):
        # TODO: for whatever reason coverage refuses to belief this covers the __init__.py in smartmin
        import smartmin
        self.assertEquals('1.4.1', smartmin.__version__)

    def test_management(self):
        authors = Group.objects.get(name="Authors")

        # reduce our permission set to not include categories
        permissions =  ('blog.post.*', 'blog.post.too.many.dots', 'blog.category.not_valid_either', 'blog.', 'blog.foo.*')

        self.assertEquals(16, authors.permissions.all().count())

        # check that they are reassigned
        check_role_permissions(authors, permissions, authors.permissions.all())

        # removing all category actions should bring us to 10
        self.assertEquals(11, authors.permissions.all().count())


    def test_smart_model(self):
        p1 = Post.objects.create(title="First Post", body="First Post body", order=1, tags="first",
                                 created_by=self.author, modified_by=self.author)
        p2 = Post.objects.create(title="Second Post", body="Second Post body", order=1, tags="second",
                                 created_by=self.author, modified_by=self.author)

        self.assertEquals(3, Post.objects.all().count())
        self.assertEquals(3, Post.active.all().count())

        # make p2 inactive
        p2.is_active = False
        p2.save()

        self.assertEquals(3, Post.objects.all().count())
        self.assertEquals(2, Post.active.all().count())

class UserTest(TestCase):

    def setUp(self):
        self.client = Client()
        self.superuser = User.objects.create_user('superuser', 'superuser@group.com', 'superuser')
        self.superuser.is_superuser = True
        self.superuser.save()

       
    def test_crudl(self):
        self.client.login(username='superuser', password='superuser')

        post_data = dict(username='steve',
                         new_password='apple',
                         first_name='Steve',
                         last_name='Jobs',
                         groups=Group.objects.get(name='Administrator').id,
                         email='steve@apple.com')

        response = self.client.post(reverse('users.user_create'), post_data, follow=True)
        self.assertEquals(200, response.status_code)

        # we should have failed due to our password not being long enough
        self.assertTrue('new_password' in response.context['form'].errors)

        # try with a longer password but without our requirements (8 chars)
        post_data['new_password'] = 'password'
        response = self.client.post(reverse('users.user_create'), post_data, follow=True)
        self.assertEquals(200, response.status_code)
        self.assertTrue('new_password' in response.context['form'].errors)

        # try with one capital letter
        post_data['new_password'] = 'Password'
        response = self.client.post(reverse('users.user_create'), post_data, follow=True)
        self.assertEquals(200, response.status_code)
        self.assertTrue('new_password' in response.context['form'].errors)

        # ok, finally with a zero in there too, this one should pass
        post_data['new_password'] = 'Passw0rd'
        response = self.client.post(reverse('users.user_create'), post_data, follow=True)
        self.assertEquals(200, response.status_code)
        self.assertTrue('form' not in response.context)

        # make sure the user was created
        steve = User.objects.get(username='steve')

        # create another user manually, make him inactive
        woz = User.objects.create_user('woz', 'woz@apple.com', 'woz')
        woz.is_active = False
        woz.save()

        # list our users
        response = self.client.get(reverse('users.user_list'))
        users = response.context['user_list']

        # results should be sorted by username
        self.assertEquals(2, len(users))
        self.assertEquals(steve, users[0])
        self.assertEquals(woz, users[1])

        # check our content too
        self.assertContains(response, 'woz')
        self.assertContains(response, 'steve')

        # update steve, put him in a different group and change his password
        post_data['groups'] = Group.objects.get(name='Editors').id
        post_data['new_password'] = 'googleIsNumber1'

        # need is active here or steve will be marked inactive
        post_data['is_active'] = '1'
        post_data['username'] = 'steve'

        response = self.client.post(reverse('users.user_update', args=[steve.id]), post_data, follow=True)
        self.assertEquals(200, response.status_code)
        self.assertTrue('form' not in response.context)

        # check that steve's group changed
        steve = User.objects.get(pk=steve.id)
        groups = steve.groups.all()
        self.assertEquals(1, len(groups))
        self.assertEquals(Group.objects.get(name='Editors'), groups[0])

        # assert steve can login with 'google' now
        self.assertTrue(self.client.login(username='steve', password='googleIsNumber1'))

        # test user profile action
        # logout first
        self.client.logout()

        # login as super user
        self.assertTrue(self.client.login(username='superuser', password='superuser'))

        # as a super user mimic Steve
        response = self.client.post(reverse('users.user_mimic', args=[steve.id]), follow=True)

        # check if the logged in user is steve now
        self.assertEquals(response.context['user'].username, 'steve')
        self.assertEquals(response.request['PATH_INFO'], settings.LOGIN_REDIRECT_URL)

        # now that steve is the one logged in can he mimic woz?
        response = self.client.get(reverse('users.user_mimic', args=[woz.id]), follow=True)
        self.assertEquals(response.request['PATH_INFO'], settings.LOGIN_URL)

        # login as super user
        self.assertTrue(self.client.login(username='superuser', password='superuser'))

        # check is access his profile
        response = self.client.get(reverse('users.user_profile', args=[self.superuser.id]))
        self.assertEquals(200, response.status_code)
        self.assertEquals(reverse('users.user_profile', args=[self.superuser.id]), response.request['PATH_INFO'])

        # create just a plain  user
        plain = User.objects.create_user('plain', 'plain@nogroups.com', 'plain')

        # login as a simple plain user
        self.assertTrue(self.client.login(username='plain', password='plain'))
        
        # check is access his profile, should not since plain users don't have that permission
        response = self.client.get(reverse('users.user_profile', args=[plain.id]))
        self.assertEquals(302, response.status_code)

        # log in as an editor instead
        self.assertTrue(self.client.login(username='steve', password='googleIsNumber1'))
        response = self.client.get(reverse('users.user_profile', args=[steve.id]))
        self.assertEquals(reverse('users.user_profile', args=[steve.id]), response.request['PATH_INFO'])
        
        # check if we are at the right form
        self.assertEquals("UserProfileForm", type(response.context['form']).__name__)

        response = self.client.post(reverse('users.user_profile', args=[steve.id]), {}, follow=True)

        # check which field he have access to
        self.assertEquals(6, len(response.context['form'].visible_fields()))

        # doesn't include readonly fields on post
        self.assertNotIn("username", response.context['form'].fields)

        # check if he can fill a wrong old password
        post_data = dict(old_password="plainwrong", new_password="NewPassword1")
        response = self.client.post(reverse('users.user_profile', args=[steve.id]), post_data)
        self.assertTrue('old_password' in response.context['form'].errors)

        # check if he can mismatch new password and its confirmation
        post_data = dict(old_password="plain", new_password="NewPassword1", confirm_new_password="confirmnewpassword")
        response = self.client.post(reverse('users.user_profile', args=[steve.id]), post_data)

        # check if he can fill old and new password only without the confirm new password
        post_data = dict(old_password="plain", new_password="NewPassword1")
        response = self.client.post(reverse('users.user_profile', args=[steve.id]), post_data)
        self.assertIn("Confirm the new password by filling the this field", response.content)

        # actually change the password
        post_data = dict(old_password="googleIsNumber1", new_password="NewPassword1", confirm_new_password="NewPassword1")
        response = self.client.post(reverse('users.user_profile', args=[steve.id]), post_data)

        # assert new password works
        self.assertTrue(self.client.login(username='steve', password='NewPassword1'))

        # see whether we can change our email without a password
        post_data = dict(email="new@foo.com")
        response = self.client.post(reverse('users.user_profile', args=[steve.id]), post_data)
        self.assertTrue('old_password' in response.context['form'].errors)

        # but with the new password we can
        post_data = dict(email="new@foo.com", old_password='NewPassword1')
        response = self.client.post(reverse('users.user_profile', args=[steve.id]), post_data)
        self.assertTrue(User.objects.get(email='new@foo.com'))

    def test_token(self):
        # create a user user1 with password user1 and email user1@user1.com
        user1 = User.objects.create_user("user1", 'user1@user1.com', 'user1')
 
        # be sure no one is logged in
        self.client.logout()

        # test our user can log in
        self.assertTrue(self.client.login(username='user1', password='user1'))
        self.client.logout()

        # initialise the process of recovering password by clicking the forget
        # password link and fill the form with the email associated with the account
        
        # invalid user 
        forget_url = reverse('users.user_forget')
    
        post_data = dict()
        post_data['email'] = 'nouser@nouser.com'
        
        response = self.client.post(forget_url, post_data, follow=True)
        
        # email form submitted successfully
        self.assertEquals(200, response.status_code)

        # email with valid user
        forget_url = reverse('users.user_forget')

        post_data = dict()
        post_data['email'] = 'user1@user1.com'
        
        response = self.client.post(forget_url, post_data, follow=True)
        
        # email form submitted successfully
        self.assertEquals(200, response.status_code)

        # now there is a token generated
        recovery_token = RecoveryToken.objects.get(user=user1)
        self.assertNotEquals(None,recovery_token.token)

        # still the user can login with usual password and cannot login with the new password test
        self.assertTrue(self.client.login(username='user1', password='user1'))
        self.client.logout()
        self.assertFalse(self.client.login(username='user1', password='user1_newpasswd'))
        self.client.logout()
        # user click the link provided in mail
        
        recover_url = reverse('users.user_recover', args=[recovery_token.token])

        response = self.client.get(recover_url)
        self.assertEquals(200, response.status_code)
        self.assertTrue(response.context['form'])
        self.assertTrue('new_password' in response.context['form'].fields)
        self.assertTrue('confirm_new_password' in response.context['form'].fields)
        
        post_data = dict()
        post_data['new_password'] = 'user1_newpasswd'
        post_data['confirm_new_password'] = ''

        response = self.client.post(recover_url, post_data, follow=True)
        self.assertIn("This field is required.", response.content)

        recover_url = reverse('users.user_recover', args=[recovery_token.token])
        
        response = self.client.get(recover_url)
        self.assertEquals(200, response.status_code)
        self.assertTrue(response.context['form'])
        self.assertTrue('new_password' in response.context['form'].fields)
        self.assertTrue('confirm_new_password' in response.context['form'].fields)

        post_data = dict()
        post_data['new_password'] = 'user1_newpasswd'
        post_data['confirm_new_password'] = 'user1_passwd_dont_match'

        response = self.client.post(recover_url, post_data, follow=True)
        self.assertIn('confirm_new_password', response.context['form'].errors)

        # the token has expired
        token = recovery_token.token
        three_days_ago = timezone.now() - timedelta(days=3)
        recovery_token = RecoveryToken.objects.get(token=token)
        recovery_token.created_on = three_days_ago
        recovery_token.save()

        recover_url = reverse('users.user_recover', args=[recovery_token.token])
        response = self.client.get(recover_url)
        self.assertEquals(302, response.status_code)

        response = self.client.get(recover_url, follow=True)
        self.assertEquals(response.request['PATH_INFO'], forget_url)
        self.assertTrue(response.context['form'])
        self.assertFalse('new_password' in response.context['form'].fields)
        self.assertFalse('confirm_new_password' in response.context['form'].fields)
        self.assertTrue('email' in response.context['form'].fields)

        # valid token
        token = recovery_token.token
        recovery_token = RecoveryToken.objects.get(token=token)
        recovery_token.created_on = timezone.now()
        recovery_token.save()

        # if the token is valid we get a form to fill with new password
        recover_url = reverse('users.user_recover', args=[recovery_token.token])
        
        response = self.client.get(recover_url)
        self.assertEquals(200, response.status_code)
        self.assertTrue(response.context['form'])
        self.assertTrue('new_password' in response.context['form'].fields)
        self.assertTrue('confirm_new_password' in response.context['form'].fields)

        post_data = dict()
        post_data['new_password'] = 'user1_newpasswd'
        post_data['confirm_new_password'] = 'user1_newpasswd'

        response = self.client.post(recover_url, post_data, follow=True)
        # form submitted successfull
        self.assertEquals(200, response.status_code)
        
        # now the user cannot login with the old password but can login with the new one
        self.assertFalse(self.client.login(username='user1', password='user1'))
        self.client.logout()
        self.assertTrue(self.client.login(username='user1', password='user1_newpasswd'))
        self.client.logout()
        self.assertFalse(RecoveryToken.objects.all())
        
        # second click on the link
        recover_url = reverse('users.user_recover', args=[recovery_token.token])
        
        response = self.client.get(recover_url)
        self.assertEquals(302, response.status_code)

        response = self.client.get(recover_url, follow=True)
        self.assertTrue(response.request['PATH_INFO'], forget_url)
        self.assertTrue(response.context['form'])
        self.assertFalse('new_password' in response.context['form'].fields)
        self.assertFalse('confirm_new_password' in response.context['form'].fields)
        self.assertTrue('email' in response.context['form'].fields)

        # if for some unexpeted magic way we post to recover_url the password must not change
        post_data = dict()
        post_data['new_password'] = 'user1_newpasswd_2'
        post_data['confirm_new_password'] = 'user1_newpasswd_2'

        response = self.client.post(recover_url, post_data, follow=True)
        # form submitted successfull
        self.assertEquals(200, response.status_code)
        
        # password must not change
        self.assertFalse(self.client.login(username='user1', password='user1_newpasswd_2'))
        self.client.logout()
        self.assertTrue(self.client.login(username='user1', password='user1_newpasswd'))
        self.client.logout()

    def test_lockout(self):
        # first create a user to use on the test
        user2 = User.objects.create_user("user2", 'user2@user2.com', 'user2')

        #be sure no user os logged in
        self.client.logout()

        # login page
        login_url = reverse('users.user_login')

        post_data = dict()
        post_data['username'] = 'user2'
        post_data['password'] = 'wrongpassword'

        # try to log in four times
        for i in range(4):
            response = self.client.post(login_url,post_data)
            self.assertFalse( response.context['user'].is_authenticated())

        # on the fifth failed login we get redirected
        response = self.client.post(login_url, post_data)
        self.assertEquals(302, response.status_code)

class UserTestCase(TestCase):

    def test_reverse(self):
        # the reverse tag here should be blog.user_list, not auth.user_list, since the 
        # CRUDL objects is defined in the blog app
        response = self.client.get(reverse('blog.user_list'))
        self.assertEquals(200, response.status_code)

        # also make sure the proper template is used (should be /blog/user_list.html)
        self.assertContains(response, "Custom Pre-Content")

class TagTestCase(TestCase):

    def setUp(self):
        self.crudl = PostCRUDL()
        self.list_view = self.crudl.view_for_action('list')()
        self.read_view = self.crudl.view_for_action('read')()

        self.plain = User.objects.create_user('plain', 'plain@nogroups.com', 'plain')

        self.author = User.objects.create_user('author', 'author@group.com', 'author')
        self.author.groups.add(Group.objects.get(name="Authors"))

        self.post = Post.objects.create(title="First Post", body="My First Post", tags="first", order=1,
                                        created_by=self.author, modified_by=self.author)

    def test_value_from_view(self):
        from smartmin.templatetags.smartmin import get_value_from_view
        import pytz

        context = dict(view=self.read_view, object=self.post)
        self.assertEquals(self.post.title, get_value_from_view(context, 'title'))
        local_created = self.post.created_on.replace(tzinfo=pytz.utc).astimezone(pytz.timezone('Africa/Kigali'))
        self.assertEquals(local_created.strftime("%b %d, %Y %H:%M"), get_value_from_view(context, 'created_on'))

    def test_view_as_json(self):
        from smartmin.templatetags.smartmin import view_as_json

        self.list_view.object_list = Post.objects.all()
        context = dict(view=self.list_view)

        foo = view_as_json(context)
        json = simplejson.loads(view_as_json(context))
        self.assertEquals(1, len(json))
        self.assertEquals(self.post.title, json[0]['title'])

    def test_get(self):
        from smartmin.templatetags.smartmin import get

        test_dict = dict(key="value")

        self.assertEquals("value", get(test_dict, 'key'))
        self.assertEquals("", get(test_dict, 'not_there'))

    def test_map(self):
        from smartmin.templatetags.smartmin import map
        self.assertEquals("title: First Post id: 1", map("title: %(title)s id: %(id)d", self.post))

    def test_gmail_time(self):
        import pytz
        from smartmin.templatetags.smartmin import gmail_time

        # given the time as now, should display "Hour:Minutes AM|PM" eg. "5:05 pm"
        now = timezone.now()
        modified_now = now.replace(hour=17, minute=05)
        self.assertEquals("7:05 pm", gmail_time(modified_now))

        # given the time beyond 12 hours ago within the same month, should display "MonthName DayOfMonth" eg. "Jan 2"
        now = now.replace(day=3, month=3, hour=10)
        test_date = now.replace(day=2)
        self.assertEquals(test_date.strftime("%b") + " 2", gmail_time(test_date, now))

        # last month should still be pretty
        test_date = test_date.replace(month=2)
        self.assertEquals(test_date.strftime("%b") + " 2", gmail_time(test_date, now))

        # but a different year is different
        jan_2 = datetime(2012, 01, 02, 17, 05, 00, 00).replace(tzinfo = pytz.utc)
        self.assertEquals("2/1/12", gmail_time(jan_2, now))

    def test_user_as_string(self):
        from smartmin.templatetags.smartmin import user_as_string
        
        # plain user have both first and last names
        self.plain.first_name = "Mr"
        self.plain.last_name = "Chips"
        self.plain.save()
        self.assertEquals("Mr Chips", user_as_string(self.plain))

        # change this user to have firstname as an empty string
        self.plain.first_name = ''
        self.plain.save()
        self.assertEquals("Chips", user_as_string(self.plain))

        # change this user to have lastname as an empty string
        self.plain.last_name = ''
        self.plain.first_name = 'Mr'
        self.plain.save()
        self.assertEquals("Mr", user_as_string(self.plain))

        # change this user to have both first and last being empty strings
        self.plain.last_name = ''
        self.plain.first_name = ''
        self.plain.save()
        self.assertEquals("plain", user_as_string(self.plain))

class UserLockoutTestCase(TestCase):

    def setUp(self):
        self.plain = User.objects.create_user('plain', 'plain@nogroups.com', 'plain')

        self.superuser = User.objects.create_user('superuser', 'superuser@group.com', 'superuser')
        self.superuser.is_superuser = True
        self.superuser.save()

    def testBadLogin(self):
        post_data = dict(email='foo', password='blah')
        response = self.client.post(reverse('users.user_login'), post_data)

        self.assertEquals(200, response.status_code)
        self.assertTrue('username' in response.context['form'].errors)

    def doLockout(self):
        # go to the login page
        response = self.client.get(reverse('users.user_login'))

        # make sure there is no reset link
        self.assertTrue(response.content.find(reverse('users.user_forget')) == -1);

        # also make sure we can't actually do a reset
        post_data = dict(email="nicpottier@gmail.com")
        response = self.client.post(reverse('users.user_forget'), post_data)

        self.assertTrue('email' in response.context['form'].errors)

        # try logging in four times, get account locked
        for i in range(4):
            post_data = dict(username='plain', password='plain2')
            response = self.client.post(reverse('users.user_login'), post_data)
            self.assertTrue(response.context['form'].errors)

        # on the fifth time it should fail
        response = self.client.post(reverse('users.user_login'), post_data, follow=True)
        self.assertFalse(response.context['user'].is_authenticated())
        self.assertTrue(response.content.find(reverse('users.user_forget')) == -1);

        # even with right password, no dice
        post_data = dict(username='plain', password='plain')
        response = self.client.post(reverse('users.user_login'), post_data, follow=True)
        self.assertFalse(response.context['user'].is_authenticated())
        self.assertTrue(response.content.find(reverse('users.user_forget')) == -1);

    def testNoRecovery(self):
        with self.settings(USER_ALLOW_EMAIL_RECOVERY=False):
            self.doLockout()

            post_data = dict(username='plain', password='plain')
            response = self.client.post(reverse('users.user_login'), post_data, follow=True)

            # should say something about 10 minutes
            self.assertContains(response, "10 minutes")

            # move all our lockout events to 11 minutes in the past
            ten_minutes = timedelta(minutes=10)
            for failed in FailedLogin.objects.filter(user=self.plain):
                failed.failed_on = failed.failed_on - ten_minutes
                failed.save()

            # should now be able to log in
            response = self.client.post(reverse('users.user_login'), post_data, follow=True)
            self.assertTrue( response.context['user'].is_authenticated())

    def testNoRecoveryNoTimeout(self):
        with self.settings(USER_ALLOW_EMAIL_RECOVERY=False, USER_LOCKOUT_TIMEOUT=-1):
            # get ourselves locked out
            self.doLockout()

            post_data = dict(lusername='plain', password='plain')
            response = self.client.post(reverse('users.user_login'), post_data, follow=True)

            # should say nothing about 10 minutes
            self.assertTrue(response.content.find("10 minutes") == -1)

            # move all our lockout events to 11 minutes in the past
            ten_minutes = timedelta(minutes=10)
            for failed in FailedLogin.objects.filter(user=self.plain):
                failed.failed_on = failed.failed_on - ten_minutes
                failed.save()

            # should still have no dice on trying to log in
            post_data = dict(username='plain', password='plain')
            response = self.client.post(reverse('users.user_login'), post_data, follow=True)
            self.assertContains(response, "cannot log")
            self.assertTrue(response.content.find(reverse('users.user_forget')) == -1);

            # log in as superuser
            response = self.client.post(reverse('users.user_login'), 
                                        dict(username='superuser', password='superuser'))

            # go edit our 'plain' user
            response = self.client.get(reverse('users.user_update', args=[self.plain.id]))

            # change the password
            post_data = dict(new_password='Password1', username='plain', groups='1', is_active='1')
            response = self.client.post(reverse('users.user_update', args=[self.plain.id]),
                                        post_data)

            # assert our lockouts got cleared
            self.assertFalse(FailedLogin.objects.filter(user=self.plain))

            # the user should be able to log in now
            self.client.logout()

            post_data = dict(username='plain', password='Password1')
            response = self.client.post(reverse('users.user_login'), post_data, follow=True)
            self.assertTrue(response.context['user'].is_authenticated())

class PasswordExpirationTestCase(TestCase):

    def setUp(self):
        self.plain = User.objects.create_user('plain', 'plain@nogroups.com', 'Password1')
        self.plain.groups.add(Group.objects.get(name="Editors"))

    def testNoExpiration(self):
        # create a fake password set 90 days ago
        ninety_days_ago = timezone.now() - timedelta(days=90)
        history = PasswordHistory.objects.create(user=self.plain,
                                                 password="asdfasdf")

        history.set_on = ninety_days_ago
        history.save()

        # log in
        self.client.logout()
        post_data = dict(username='plain', password='Password1')
        response = self.client.post(reverse('users.user_login'), post_data, follow=True)
        self.assertTrue(response.context['user'].is_authenticated())

        # we shouldn't be on a page asking us for a new password
        self.assertFalse('form' in response.context)

    def testPasswordRepeat(self):
        history = PasswordHistory.objects.create(user=self.plain,
                                                 password=self.plain.password)        

        with self.settings(USER_PASSWORD_REPEAT_WINDOW=365):
            self.assertTrue(PasswordHistory.is_password_repeat(self.plain, "Password1"))
            self.assertFalse(PasswordHistory.is_password_repeat(self.plain, "anotherpassword"))

            # move our history into the past
            history.set_on = timezone.now() - timedelta(days=366)
            history.save()

            # still a repeat because it is our current password
            self.assertTrue(PasswordHistory.is_password_repeat(self.plain, "Password1"))

            # change our password under the covers
            self.plain.set_password("my new password")

            # now this one is fine
            self.assertFalse(PasswordHistory.is_password_repeat(self.plain, "Password1"))

        with self.settings(USER_PASSWORD_REPEAT_WINDOW=-1):
            history.set_on = timezone.now()
            history.save()

            self.assertFalse(PasswordHistory.is_password_repeat(self.plain, "Password1"))

    def testExpiration(self):
        with self.settings(USER_PASSWORD_EXPIRATION=60, USER_PASSWORD_REPEAT_WINDOW=365):
            # create a fake password set 90 days ago
            ninety_days_ago = timezone.now() - timedelta(days=90)
            history = PasswordHistory.objects.create(user=self.plain,
                                                     password=self.plain.password)

            history.set_on = ninety_days_ago
            history.save()
            
            # log in
            self.client.logout()
            post_data = dict(username='plain', password='Password1')
            response = self.client.post(reverse('users.user_login'), post_data, follow=True)

            # assert we are being taken to our new password page
            self.assertTrue('form' in response.context)
            self.assertTrue('new_password' in response.context['form'].fields)

            # try to go to a different page
            response = self.client.get(reverse('blog.post_list'), follow=True)

            # redirected again
            self.assertTrue('form' in response.context)
            self.assertTrue('new_password' in response.context['form'].fields)

            # ok, set our new password
            post_data = dict(old_password='Password1', new_password='Password1', confirm_new_password='Password1')
            response = self.client.post(reverse('users.user_newpassword', args=[0]), post_data)

            # we should get a failure that our new password is a repeat
            self.assertTrue('confirm_new_password' in response.context['form'].errors)

            # use a different password
            post_data = dict(old_password='Password1', new_password='Password2', confirm_new_password='Password2')
            response = self.client.post(reverse('users.user_newpassword', args=[0]), post_data)

            # should be redirected to the normal redirect page
            self.assertEquals(302, response.status_code)
            self.assertTrue(response['location'].find(reverse('blog.post_list')) > 0)

            # should now have two password histories
            self.assertEquals(2, PasswordHistory.objects.filter(user=self.plain).count())

            # should be able to log in normally
            self.client.logout()

            post_data = dict(username='plain', password='Password2')
            response = self.client.post(reverse('users.user_login'), post_data)
            
            self.assertEquals(302, response.status_code)
            self.assertTrue(response['location'].find(reverse('blog.post_list')) > 0)

########NEW FILE########
__FILENAME__ = urls
from .views import *

urlpatterns = PostCRUDL().as_urlpatterns()
urlpatterns += CategoryCRUDL().as_urlpatterns()
urlpatterns += UserCRUDL().as_urlpatterns()

########NEW FILE########
__FILENAME__ = views
from smartmin.views import *
from .models import *
from django import forms
from django.contrib.auth.models import User

class ExcludeForm(forms.ModelForm):
    class Meta:
        model = Post
        fields = ('title', 'body', 'order', 'tags')


# We overload a normal CategoryForm to not call the super's clean method. By default
# model forms will check for integrity checks.  We want to force a DB thrown IntegrityError
# so we don't call the super, instead letting smartmin wrap the error
class CategoryForm(forms.ModelForm):
    def clean(self):
        return self.cleaned_data

    class Meta:
        model = Category

# just tests that our reverse and permissions are based on the view.py app, not
# the model app, the template should also be /blog/user_list.html for the List view
class UserCRUDL(SmartCRUDL):
    model = User
    permissions = False
    actions = ('list',)

class CategoryCRUDL(SmartCRUDL):
    model = Category

    class Create(SmartCreateView):
        form_class = CategoryForm

class PostCRUDL(SmartCRUDL):
    model = Post
    actions = ('create', 'read', 'update', 'delete', 'list', 'author',
               'exclude', 'exclude2', 'readonly', 'readonly2', 'messages', 'csv_import')

    class List(SmartListView):
        fields = ('title', 'tags', 'created_on', 'created_by')
        search_fields = ('title__icontains', 'body__icontains')
        default_order = 'title'

        def as_json(self, context):
            items = []
            for obj in self.object_list:
                items.append(dict(title=obj.title,
                                  body=obj.body,
                                  tags=obj.tags))

            return items

    class Author(SmartListView):
        fields = ('title', 'tags', 'created_on', 'created_by')
        default_order = ('created_by__username', 'order')

    class Update(SmartUpdateView):
        success_message = "Your blog post has been updated."

    class Create(SmartCreateView):
        submit_button_name = "Create New Post"

    class Exclude(SmartUpdateView):
        exclude = ('tags',)

    class Exclude2(SmartUpdateView):
        form_class = ExcludeForm
        exclude = ('tags',)

    class Readonly(SmartUpdateView):
        readonly = ('tags',)

    class Readonly2(SmartUpdateView):
        form_class = ExcludeForm
        readonly = ('tags',)

    class Messages(SmartListView):
        def pre_process(self, request, *args, **kwargs):
            messages.error(request,"Error Messages")
            messages.success(request,"Success Messages")
            messages.info(request,"Info Messages")
            messages.warning(request,"Warning Messages")
            messages.debug(request,"Debug Messages")

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
import imp
try:
    imp.find_module('settings') # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n" % __file__)
    sys.exit(1)

import settings

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
# Django settings for proj project.

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'smartmin.db',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'GMT'
USER_TIME_ZONE = 'Africa/Kigali'
USE_TZ = True

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale
USE_L10N = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = ''

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = ''

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# URL prefix for admin static files -- CSS, JavaScript and images.
# Make sure to use a trailing slash.
# Examples: "http://foo.com/static/admin/", "/static/admin/".
ADMIN_MEDIA_PREFIX = '/static/admin/'

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'w4*mtn&nquc57h@$-05gva+2ucq0$tnczy#!d=t4%1&pl!p=jo'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'smartmin.users.middleware.ChangePasswordMiddleware',
    'smartmin.middleware.TimezoneMiddleware',
)

import warnings
warnings.filterwarnings('error', r"DateTimeField received a naive datetime", RuntimeWarning, r'django\.db\.models\.fields')

TEMPLATE_CONTEXT_PROCESSORS = (
    'django.contrib.auth.context_processors.auth',
    'django.core.context_processors.debug',
    'django.core.context_processors.i18n',
    'django.core.context_processors.media',
    'django.core.context_processors.static',    
    'django.contrib.messages.context_processors.messages',
    'django.core.context_processors.request',
)

ROOT_URLCONF = 'urls'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    'django_nose',

    'guardian',
    'smartmin',
    'smartmin.users',

    'blog',

    # Uncomment the next line to enable the admin:
    'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',

    'smartmin.csv_imports',

    'djcelery',
)

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}

AUTHENTICATION_BACKENDS = (
    'django.contrib.auth.backends.ModelBackend', # this is default
    'guardian.backends.ObjectPermissionBackend',
)

# create the smartmin CRUDL permissions on all objects
PERMISSIONS = {
    '*': ('create', # can create an object
          'read',   # can read an object, viewing it's details
          'update', # can update an object
          'delete', # can delete an object,
          'list'),  # can view a list of the objects
    'blog.post': ('author', 'exclude', 'exclude2', 'readonly', 'readonly2', 'messages'),
    'auth.user': ('profile',),

    # invalid content type for test
    'blog.foo': ('nothing',)
}

# permissions for users that aren't logged in
ANONYMOUS_PERMISSIONS = (
    'blog.post_read',
)

# assigns the permissions that each group should have, here creating an Administrator group with 
# authority to create and change users
GROUP_PERMISSIONS = {
    "Administrator": ('auth.user.*',),
    "Editors": ('blog.post_update', 'blog.post_list', 'auth.user_profile'),
    "Authors": ('blog.post.*','blog.category.*'),
}

ANONYMOUS_USER_ID = -1
LOGIN_URL = '/users/login/'
LOGIN_REDIRECT_URL = "/blog/post/"

#-----------------------------------------------------------------------------------
# Django-Nose config
#-----------------------------------------------------------------------------------

TEST_RUNNER = 'django_nose.NoseTestSuiteRunner'

#-----------------------------------------------------------------------------------                                    
# Async tasks with django-celery                                                                                        
#-----------------------------------------------------------------------------------                                    
import djcelery
djcelery.setup_loader()

CELERY_RESULT_BACKEND = 'database'

BROKER_BACKEND = 'redis'
BROKER_HOST = 'localhost'
BROKER_PORT = 6379
BROKER_VHOST = '4'

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import patterns, include, url

# Uncomment the next two lines to enable the admin:
from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
    # Examples:
    # url(r'^$', 'proj.views.home', name='home'),

    url(r'^users/', include('smartmin.users.urls')),
    url(r'^blog/', include('blog.urls')),
    url(r'^csv_imports/', include('smartmin.csv_imports.urls')),

    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    url(r'^admin/', include(admin.site.urls)),
)

########NEW FILE########
