__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# tomahawk documentation build configuration file, created by
# sphinx-quickstart on Fri Dec 30 20:53:56 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import os
import sys

def set_lib_path(file):
    parent, bin_dir = os.path.split(os.path.dirname(os.path.abspath(file)))
    pparent, d = os.path.split(parent)
    if os.path.exists(pparent):
        sys.path.insert(0, pparent)

set_lib_path(__file__)
import tomahawk

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []
#extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'tomahawk'
copyright = tomahawk.__copyright__ + ', ' + tomahawk.__author__

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = tomahawk.__version__
# The full version, including alpha/beta/rc tags.
release = tomahawk.__version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#html_theme = 'sphinxdoc'
try:
    import sphinx_rtd_theme
    html_theme = 'sphinx_rtd_theme'
    html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]
except ImportError:
    html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {
#    "rightsidebar": "true",
#    "relbarbgcolor": "black"
#}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
#html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'tomahawkdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'tomahawk.tex', u'tomahawk Documentation',
   tomahawk.__author__, 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
#man_pages = [
#    ('index', 'tomahawk', u'tomahawk Documentation',
#     [u'Kazuhiro Oinuma'], 1)
#]
authors = ( tomahawk.__author__, u'Kohei Maeda' )
man_pages = [
    ('index', 'tomahawk-all', 'tomahawk manual', authors, 1),
    ('tomahawk', 'tomahawk', 'enables to execute a command to many hosts', authors, 1),
    ('tomahawk-rsync', 'tomahawk-rsync', 'enables to copy files to many hosts', authors, 1),
]

# startdocname, name, description, authors, section) というタプルのリストでなければなりません。それぞれの項目は次のような意味を持ちます。

#startdocname: manページの”ルート”となるドキュメントの名前です。このファイルから参照されたすべてのドキュメントはLaTeXファイルの中のTOCツリーにも含まれるようになります。もしも1つのファイルをマスターにしたmanページにしたい場合には、 master_doc で設定した値をここに指定して下さい。
#name: manページの名前です。これには、スペースや特別な文字を含まない、短い文字列を指定します。この項目は出力ファイル名と、manページの名前(NAMEセクション内)として使用されます。
#description: manページの説明です。これはNAMEセクション内で使用されます。
#author: 著者名の文字列のリスト、もしくは単一の文字列です。manページのAUTHORSセクションを自動的に生成したくない場合には、空の文字列や空の配列を指定することもできます。
#section: manページのセクションです。出力ファイル名や、manページのヘッダー内で使われます。

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'tomahawk', u'tomahawk Documentation',
   tomahawk.__author__, 'tomahawk', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


########NEW FILE########
__FILENAME__ = release
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import sys

print("This script is not executable.")
sys.exit(0)

# version input
# Changes
# tomahawk/constants.py VERSION = '0.2.2'
# upload

from tomahawk.constants import VERSION

new_version = raw_input("Release version [%s]: " % (VERSION))

#tomahawk.

########NEW FILE########
__FILENAME__ = expect
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from six import print_
import pexpect
import os

#/Users/kazuhiro/work/tomahawk/tests/bin/mock_ssh.py', '--prompt=Password: ', '-l', 'kazuhiro', 'localhost', "/bin/sh -c 'uptime'"
dir = os.path.dirname(os.path.abspath(__file__))
program = os.path.join(dir, 'mock_ssh.py')
program_with_options = program + " --prompt='Password: ' -l kazuhiro localhost \"/bin/sh -c 'uptime'\""
child = pexpect.spawn(
    program_with_options,
#    [ '--prompt=Password: ', '-l', 'kazuhiro', 'localhost', "/bin/sh -c 'uptime'" ],
    timeout = 5
)

try:
    index = child.expect([ 'Password: ' ])
    if index == 0:
        print_('OK')
        child.sendline('send test')
    else:
        print_('NG')
except pexpect.EOF:
    print_('EOF')
except pexpect.TIMEOUT:
    print_('TIMEOUT')

########NEW FILE########
__FILENAME__ = mock_ssh
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# A mock program of ssh command.

import argparse
import os
import re
import shlex
import subprocess
import sys

print("argv = " + str(sys.argv))

parser = argparse.ArgumentParser(
    prog = os.path.basename(__file__),
    description = 'A mock program of ssh command.',
    conflict_handler = 'resolve'
)
parser.add_argument(
    'command', metavar='command', nargs='+',
    help='Command executed on remote hosts.',
)
parser.add_argument(
    '-p', '--prompt', metavar='PROMPT_STRING',
    help='Prompt with given string.',
)
parser.add_argument(
    '-c', metavar='CIPHER_SPEC',
    help='Selects the cipher specification for encrypting the session.',
)
parser.add_argument(
    '-l', metavar='LOGIN_NAME',
    help='Specifies the user to log in as on the remote machine.',
)

options = parser.parse_args()
if options.prompt:
    print("before raw_input()")
    input = raw_input(options.prompt)
    #sys.stdin.read()
    print("input = " + input)

# call command
#regexp = re.compile("^/bin/sh -c '(.+)'$")
#for arg in options.command:
#    if regexp.match(arg):
#        exit(subprocess.call(shlex.split(arg)))

########NEW FILE########
__FILENAME__ = test_tomahawk
# -*- coding: utf-8 -*-
from six import print_
#from nose.tools import ok_
import os
import pexpect

#import sys
import utils

# TODO: mock_ssh.py --prompt enabled, so we can test -s -l options.
TOMAHAWK_PATH = os.path.join(utils.get_bin_dir(__file__), 'tomahawk')
TESTS_DIR = os.path.dirname(os.path.abspath(__file__))

def test_06_prompt_sudo_password():
    command = "%s -D --hosts=localhost --prompt-login-password --ssh-user=tomahawk_test uptime" % (TOMAHAWK_PATH)
    child = pexpect.spawn(
        command,
        timeout = 5
    )
    i = child.expect([ pexpect.EOF, pexpect.TIMEOUT, 'Enter a password.+' ])
    if i == 0: # EOF
        print_('EOF')
        print_(child.before)
    elif i == 1: # timeout
        print_('TIMEOUT')
        #ok_(False, 'Failure: ')
        assert True
    elif i == 2:
        child.sendline("tomahawk_test")
        child.expect(pexpect.EOF)
        #ok_(True, "execute (prompt password)")
        assert True


def test_10_confirm_execution_on_production():
    command = '%s --hosts=localhost,localhost uptime' % (TOMAHAWK_PATH)
    env = os.environ
    env['TOMAHAWK_ENV'] = 'production'
    child = pexpect.spawn(
        command,
        timeout = 5,
#        logfile = sys.stdout,
        env = env
    )
    i = child.expect([ pexpect.EOF, pexpect.TIMEOUT, 'Command "uptime" will be executed to 2 hosts.' ])
    if i == 0: # EOF
        print_('EOF')
        print_(child.before)
    elif i == 1: # timeout
        print_('TIMEOUT')
        print_(child.before, child.after)
        #ok_(False, 'Failure: confirm_execution_on_production with "TOMAHAWK_ENV"')
        assert False
    elif i == 2:
        child.sendline('yes')
        child.expect(pexpect.EOF)
        print_(child.before)
        #ok_(True, 'confirm_execution_on_production with "TOMAHAWK_ENV"')
        assert False

########NEW FILE########
__FILENAME__ = test_tomahawk_prompt
# -*- coding: utf-8 -*-
# mock_ssh 'sudo uptime'
# req: GET /expect?command=sudo uptime
# res: 200 Password:
# req: GET /send?s=$xyz&command=sudo uptime
# res: 200 uptime result

pass

########NEW FILE########
__FILENAME__ = test_tomahawk_rsync
#from nose.tools import assert_equal, assert_true
import os
from subprocess import call, PIPE
import utils

TOMAHAWK_RSYNC_PATH = os.path.join(utils.get_bin_dir(__file__), 'tomahawk-rsync')
TMP_DIR = os.path.join(utils.get_home_dir(__file__), 'tmp')
if not os.path.exists(TMP_DIR):
    os.mkdir(TMP_DIR)

env = os.environ
if env.get('TOMAHAWK_ENV') != None:
    del env['TOMAHAWK_ENV']

hello_file = os.path.join(TMP_DIR, 'hello')
hello_file_copied = os.path.join(TMP_DIR, 'hello.copied')
if os.path.exists(hello_file_copied):
    os.remove(hello_file_copied)
handle = open(hello_file, 'w')
handle.write('hello world')
handle.close()

def test_03_mirror_mode_pull():
    for f in ('localhost__hello', '127.0.0.1__hello'):
        path = os.path.join(TMP_DIR, f)
        if os.path.exists(path):
            os.remove(path)

    status = call(
        [ TOMAHAWK_RSYNC_PATH, '--hosts=localhost,127.0.0.1', '--mirror-mode=pull',
          hello_file, TMP_DIR ],
        stdout = PIPE, stderr = PIPE
    )

    assert status == 0
    for f in ('localhost__hello', '127.0.0.1__hello'):
        assert os.path.exists(os.path.join(TMP_DIR, f))

########NEW FILE########
__FILENAME__ = utils
import os

def get_home_dir(file):
    abspath = os.path.abspath(file)
    parent, dir = None, None
    if abspath.find('internal') != -1 or abspath.find('external') != -1:
        parent, dir = os.path.split(os.path.dirname(os.path.dirname(os.path.abspath(file))))
    else:
        parent, dir = os.path.split(os.path.dirname(os.path.abspath(file)))
    return parent

def get_bin_dir(file):
    return os.path.join(get_home_dir(file), 'bin')

########NEW FILE########
__FILENAME__ = test_capture
#import logging
#
#def test_ng(capsys):
#    logging.basicConfig(
#        level = logging.DEBUG)
#    logging.debug("hiho")
#    out, err = capsys.readouterr()
#    assert 1 == 2
#
#def test_ok(capsys):
#    logging.basicConfig(
#        filename = '/tmp/log',
#        level = logging.DEBUG)
#    logging.debug("hiho")
#    out, err = capsys.readouterr()
#    assert 1 == 2

########NEW FILE########
__FILENAME__ = test_command
import argparse
import datetime
import re
import utils

utils.append_home_to_path(__file__)

from tomahawk.command import CommandMain
from tomahawk.constants import TimeoutError
from tomahawk.expect import CommandWithExpect

def test_00_run(monkeypatch):
    EXPECTED = {
        'command': 'uptime',
        'command_output': "0:40  up 1 day,  8:19, 4 users, load averages: 0.00 0.50 1.00",
        'exit_status': 0,
    }
    stdout, stderr = utils.capture_stdout_stderr()

    def mock_parse_args(self, args):
        return utils.create_command_namespace(command = [ EXPECTED['command'] ])
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        return EXPECTED['exit_status'], EXPECTED['command_output']
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = CommandMain('tomahawk')
    status = main.run()
    o = stdout.stop().value()

    assert status == 0
    s = \
"""tomahawk@localhost %% %(command)s
%(command_output)s

""" % EXPECTED
    assert o == s

def test_01_run_error(monkeypatch):
    EXPECTED = {
        'command': 'command_not_found',
        'exit_status': 127,
    }
    stdout, stderr = utils.capture_stdout_stderr()

    def mock_parse_args(self, args):
        return utils.create_command_namespace(command = [ EXPECTED['command'] ])
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        return EXPECTED['exit_status'], "/bin/sh: command_not_found: command not found"
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = CommandMain('tomahawk')
    status = main.run()
    assert status == 1
    assert re.search(r'failed on host', stderr.stop().value())

def test_02_run_timeout(monkeypatch):
    EXPECTED = {
        'command': 'sleep 3',
        'command_output': "/bin/sh: command_not_found: command not found",
    }
    stdout, stderr = utils.capture_stdout_stderr()

    def mock_parse_args(self, args):
        return utils.create_command_namespace(
            command = [ EXPECTED['command'] ], timeout = 1
        )
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        raise TimeoutError()
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = CommandMain('tomahawk')
    status = main.run()
    assert status == 1
    assert re.search(r'timed out on host', stderr.stop().value())

def test_03_run_escape_shell_chars(monkeypatch):
    EXPECTED = {
        'command': 'echo \\\\',
        'command_output': "\\",
        'exit_status': 0,
    }
    stdout, stderr = utils.capture_stdout_stderr()

    def mock_parse_args(self, args):
        return utils.create_command_namespace(
            command = [ EXPECTED['command'] ],
            debug_enabled = True,
        )
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        return EXPECTED['exit_status'], EXPECTED['command_output']
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = CommandMain('tomahawk')
    main.run()
    o = stdout.stop().value().strip()
    assert o == "tomahawk@localhost % echo \\\\\n\\"


def test_04_run_without_user(monkeypatch):
    EXPECTED = {
        'command': 'uptime',
        'command_output': "0:40  up 1 day,  8:19, 4 users, load averages: 0.00 0.50 1.00",
        'exit_status': 0,
    }
    stdout, stderr = utils.capture_stdout_stderr()

    def mock_parse_args(self, args):
        return utils.create_command_namespace(
            command=[EXPECTED['command']],
            ssh_user=None,
            ssh_options='-o User=tomahawk')
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        return EXPECTED['exit_status'], EXPECTED['command_output']
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = CommandMain('tomahawk')
    status = main.run()
    o = stdout.stop().value()

    assert status == 0
    s = \
"""[user]@localhost %% %(command)s
%(command_output)s

""" % EXPECTED
    assert o == s


def test_10_run_option_host_files(monkeypatch):
    EXPECTED = {
        'command': 'echo "hello world"',
        'command_output': "hello world",
    }
    stdout, stderr = utils.capture_stdout_stderr()

    def mock_parse_args(self, args):
        return utils.create_command_namespace(
            command = [ EXPECTED['command'] ],
            hosts = 'localhost,localhost',
        )
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        return 0, EXPECTED['command_output']
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = CommandMain('tomahawk')
    status = main.run()
    assert status == 0
    assert re.search(r'hello world', stdout.stop().value())

def test_20_run_option_continue_on_error(monkeypatch):
    EXPECTED = {
        'command': 'failure_command',
        'command_output': "hello world",
    }
    stdout, stderr = utils.capture_stdout_stderr()

    def mock_parse_args(self, args):
        return utils.create_command_namespace(
            command = [ EXPECTED['command'] ],
            continue_on_error = True,
            hosts = 'localhost,127.0.0.1',
        )
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        return 127, EXPECTED['command_output']
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = CommandMain('tomahawk')
    status = main.run()
    err = stderr.stop().value().strip()
    assert status == 1
    assert len(err.split('\n')) == 3

def test_21_run_option_parallel_continue_on_error(monkeypatch):
    EXPECTED = {
        'command': 'failure_command',
        'command_output': "hello world",
    }
    stdout, stderr = utils.capture_stdout_stderr()
    target_hosts = [
        'localhost', 'localhost', 'localhost', 'localhost',
        '127.0.0.1', '127.0.0.1', '127.0.0.1', '127.0.0.1',
    ]
    def mock_parse_args(self, args):
        return utils.create_command_namespace(
            command = [ EXPECTED['command'] ],
            continue_on_error = True,
            parallel = 2,
            hosts = ','.join(target_hosts),
        )
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        return 127, EXPECTED['command_output']
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = CommandMain('tomahawk')
    status = main.run()
    assert status == 1

    # parse output to collect failure hosts.
    hosts = []
    hosts_start = False
    for line in stderr.stop().value().split('\n'):
        if re.search(r'failed on following hosts', line, re.I):
            hosts_start = True
            continue
        if hosts_start:
            h = line.strip()
            if h != '':
                hosts.append(h)
    assert hosts == target_hosts

def test_30_execute_option_ssh_options(monkeypatch):
    EXPECTED = {
        'command': 'echo "hello world"',
        'command_output': "hello world",
    }
    stdout, stderr = utils.capture_stdout_stderr()

    def mock_parse_args(self, args):
        return utils.create_command_namespace(
            command = [ EXPECTED['command'] ],
            ssh_options = '-c arcfour',
        )
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        return 0, EXPECTED['command_output']
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = CommandMain('tomahawk')
    status = main.run()
    assert status == 0
    assert re.search(EXPECTED['command_output'], stdout.stop().value())

def test_40_output_format(monkeypatch):
    EXPECTED = {
        'command': 'uptime',
        'command_output': r'localhost @ uptime',
    }
    stdout, stderr = utils.capture_stdout_stderr()

    def mock_parse_args(self, args):
        return utils.create_command_namespace(
            command = [ EXPECTED['command'] ],
            output_format = r'${host} @ ${command}',
        )
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        return 0, EXPECTED['command_output']
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = CommandMain('tomahawk')
    status = main.run()
    out = stdout.stop().value().strip()
    assert status == 0
    assert out == EXPECTED['command_output']

def test_41_output_format_newline(monkeypatch):
    """\n new line test"""
    EXPECTED = {
        'command': 'uptime',
        'command_output': "localhost\nuptime",
    }
    stdout, stderr = utils.capture_stdout_stderr()

    def mock_parse_args(self, args):
        return utils.create_command_namespace(
            command = [ EXPECTED['command'] ],
            output_format = r"${host}\n${command}",
        )
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        return 0, EXPECTED['command_output']
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = CommandMain('tomahawk')
    status = main.run()
    assert status == 0
    assert stdout.stop().value().strip() == EXPECTED['command_output']

def test_42_output_format_no_newline(monkeypatch):
    """\\n no new line test"""
    EXPECTED = {
        'command': 'uptime',
        'command_output': r"localhost \\n uptime",
    }
    stdout, stderr = utils.capture_stdout_stderr()

    def mock_parse_args(self, args):
        return utils.create_command_namespace(
            command = [ EXPECTED['command'] ],
            output_format = r'${host} \\n ${command}',
        )
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        return 0, EXPECTED['command_output']
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = CommandMain('tomahawk')
    status = main.run()
    assert status == 0
    assert stdout.stop().value().strip() == EXPECTED['command_output']

def test_50_parallel_adjustment(monkeypatch):
    stdout, stderr = utils.capture_stdout_stderr()

    def mock_parse_args(self, args):
        return utils.create_command_namespace(
            command = [ 'uptime' ], parallel = 10
        )
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        return 0, "mock execute"
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = CommandMain('tomahawk')
    main.run()
    assert main.context.options['parallel'] == 1

def test_60_verify_output_ok(monkeypatch):
    EXPECTED = {
        'command': 'echo "hello world"',
        'command_output': r'hello world',
    }
    stdout, stderr = utils.capture_stdout_stderr()

    def mock_parse_args(self, args):
        return utils.create_command_namespace(
            command = [ EXPECTED['command'] ],
            hosts = 'localhost,127.0.0.1',
            verify_output = True,
        )
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        return 0, EXPECTED['command_output']
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = CommandMain('tomahawk')
    status = main.run()
    out = stdout.stop().value().strip()
    assert status == 0
    assert out == """
tomahawk@localhost % echo "hello world"
hello world

tomahawk@127.0.0.1 % echo "hello world"
hello world

Verified output of all hosts.
""".strip()

def test_61_verify_output_ng(monkeypatch):
    EXPECTED = {
        'command': 'date',
        'command_output': r'hello world',
    }
    stdout, stderr = utils.capture_stdout_stderr()

    def mock_parse_args(self, args):
        return utils.create_command_namespace(
            command = [ EXPECTED['command'] ],
            hosts = 'localhost,127.0.0.1',
            verify_output = True,
        )
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        return 0, str(datetime.datetime.now())
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = CommandMain('tomahawk')
    status = main.run()
    assert status != 0

########NEW FILE########
__FILENAME__ = test_expect
from six import BytesIO

from flexmock import flexmock
import pexpect
import pytest
import utils
utils.append_home_to_path(__file__)

from tomahawk.expect import CommandWithExpect
from tomahawk.constants import TimeoutError

def test_00_execute():
    """Normal"""
    expect_out = BytesIO()
    target = create_object(expect_out)
    expect_out.write(b"hello world\n")
    expect_out.write(b"Connection to localhost closed\n")

    status, output = target.execute()
    assert status == 0
    assert output == "hello world"

def test_01_execute_timeout():
    """Timeout"""
    target = create_object(BytesIO())
    flexmock(utils.MockPexpect) \
        .should_receive('expect') \
        .and_raise(pexpect.TIMEOUT, "Timed out")
    pytest.raises(TimeoutError, target.execute)

def create_object(expect_out):
    command = 'ssh'
    command_args = [ '-t' ]
    expect = utils.MockPexpect(
        command, command_args, logfile = expect_out
    )
    return CommandWithExpect(
        command, command_args, 'password1', 'password2', debug_enabled = True,
        expect = expect, expect_out = expect_out
    )


########NEW FILE########
__FILENAME__ = test_rsync
import argparse
import os
import re
import shutil
import utils

utils.append_home_to_path(__file__)

from tomahawk.rsync import RsyncMain
from tomahawk.constants import TimeoutError
from tomahawk.expect import CommandWithExpect

TESTS_DIR = os.path.dirname(os.path.abspath(__file__))
TMP_DIR = os.path.join(utils.get_home_dir(__file__), 'tmp')
if not os.path.exists(TMP_DIR):
    os.mkdir(TMP_DIR)

env = os.environ
if env.get('TOMAHAWK_ENV') != None:
    del env['TOMAHAWK_ENV']

hello_file = os.path.join(TMP_DIR, 'hello')
hello_file_copied = os.path.join(TMP_DIR, 'hello.copied')
if os.path.exists(hello_file_copied):
    os.remove(hello_file_copied)
handle = open(hello_file, 'w')
handle.write('hello world')
handle.close()

def test_00_run(monkeypatch):
    EXPECTED = {
        'exit_status': 0,
    }
    stdout, stderr = utils.capture_stdout_stderr()

    def mock_parse_args(self, args):
        return utils.create_rsync_namespace(
            source = hello_file,
            destination = hello_file_copied,
        )
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        shutil.copyfile(hello_file, hello_file_copied)
        return EXPECTED['exit_status'], ''
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = RsyncMain('tomahawk-rsync')
    status = main.run()
    assert status == EXPECTED['exit_status']
    assert os.path.exists(hello_file_copied)

def test_01_run_error(monkeypatch):
    EXPECTED = {
        'exit_status': 1,
    }
    stdout, stderr = utils.capture_stdout_stderr()

    def mock_parse_args(self, args):
        return utils.create_rsync_namespace(
            source = 'file_does_not_exist',
            destination = TMP_DIR,
        )
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        shutil.copyfile(hello_file, hello_file_copied)
        return EXPECTED['exit_status'], ''
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = RsyncMain('tomahawk-rsync')
    status = main.run()
    assert status == 1
    assert not os.path.exists(os.path.join(TMP_DIR, 'file_does_not_exist'))

def test_02_run_timeout(monkeypatch):
    EXPECTED = {
        'exit_status': 1,
    }
    stdout, stderr = utils.capture_stdout_stderr()

    def mock_parse_args(self, args):
        return utils.create_rsync_namespace(
            source = 'file_does_not_exist',
            destination = TMP_DIR,
        )
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        raise TimeoutError()
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = RsyncMain('tomahawk-rsync')
    status = main.run()
    err = stderr.stop().value()
    assert status == EXPECTED['exit_status']
    assert re.search(r'timed out on host', err)


def test_03_run_without_user(monkeypatch):
    EXPECTED = {
        'exit_status': 0,
    }
    stdout, stderr = utils.capture_stdout_stderr()

    def mock_parse_args(self, args):
        return utils.create_rsync_namespace(
            source=hello_file,
            destination=hello_file_copied,
            rsync_user=None
        )
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        shutil.copyfile(hello_file, hello_file_copied)
        return EXPECTED['exit_status'], ''
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = RsyncMain('tomahawk-rsync')
    status = main.run()
    assert status == EXPECTED['exit_status']
    assert os.path.exists(hello_file_copied)
    assert not re.search(r'rsync -av.*@', stdout.stop().value()) # test no user on output


def test_10_run_option_rsync_options(monkeypatch):
    EXPECTED = {
        'exit_status': 0,
    }
    stdout, stderr = utils.capture_stdout_stderr()
    hello_file_dry_run = os.path.join(TMP_DIR, 'hello.dry-run')

    def mock_parse_args(self, args):
        return utils.create_rsync_namespace(
            source = hello_file,
            destination = hello_file_copied,
            rsync_options = '-av --dry-run',
        )
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        return EXPECTED['exit_status'], ''
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = RsyncMain('tomahawk-rsync')
    status = main.run()
    assert status == EXPECTED['exit_status']
    assert not os.path.exists(hello_file_dry_run)

def test_11_run_option_mirror_mode_pull(monkeypatch):
    EXPECTED = {
        'exit_status': 0,
    }
    stdout, stderr = utils.capture_stdout_stderr()
    target_files = ( 'localhost__hello', '127.0.0.1__hello' )
    # remove target_files
    for f in target_files:
        path = os.path.join(TMP_DIR, f)
        if os.path.exists(path):
            os.remove(path)

    def mock_parse_args(self, args):
        return utils.create_rsync_namespace(
            source = hello_file,
            destination = TMP_DIR,
            hosts = 'localhost,127.0.0.1',
            mirror_mode = 'pull',
        )
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        for f in target_files:
            shutil.copyfile(hello_file, os.path.join(TMP_DIR, f))
        return EXPECTED['exit_status'], ''
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = RsyncMain('tomahawk-rsync')
    status = main.run()
    assert status == EXPECTED['exit_status']
    for f in target_files:
        assert os.path.exists(os.path.join(TMP_DIR, f))

def test_21_run_option_continue_on_error(monkeypatch):
    EXPECTED = {
        'exit_status': 1,
    }
    stdout, stderr = utils.capture_stdout_stderr()

    def mock_parse_args(self, args):
        return utils.create_rsync_namespace(
            source = hello_file,
            destination = TMP_DIR,
            hosts = 'localhost,127.0.0.1',
            continue_on_error = True,
        )
    monkeypatch.setattr(argparse.ArgumentParser, 'parse_args', mock_parse_args)

    def mock_execute(self):
        return 127, 'error when rsync'
    monkeypatch.setattr(CommandWithExpect, 'execute', mock_execute)

    main = RsyncMain('tomahawk-rsync')
    status = main.run()
    err = stderr.stop().value()
    assert status == EXPECTED['exit_status']
    assert len(err.split('\n')) == 4

########NEW FILE########
__FILENAME__ = test_utils
from six import print_
import os
import utils
utils.append_home_to_path(__file__)

from tomahawk.utils import (
    get_options_from_conf
)

def test_00_get_options_from_conf(tmpdir):
    path = os.path.join(str(tmpdir), 'tomahawk.conf')
    conf = open(path, 'w')
    try:
        conf.write("""
[tomahawk]
options = --verify-output
""".strip())
    finally:
        conf.close()
    conf_options = get_options_from_conf('tomahawk', path)
    assert conf_options == [ '--verify-output' ]

def test_01_get_options_from_conf_no_options(tmpdir):
    path = os.path.join(str(tmpdir), 'tomahawk.conf')
    conf = open(path, 'w')
    try:
        conf.write("""
[tomahawk]
# options = --verify-output
""".strip())
    finally:
        conf.close()
    conf_options = get_options_from_conf('tomahawk', path)
    assert conf_options == []


########NEW FILE########
__FILENAME__ = utils
from six.moves import StringIO
import argparse
import os
import sys

def get_home_dir(file):
    abspath = os.path.abspath(file)
    parent, dir = None, None
    for dir in ( 'internal', 'internal2', 'external' ):
        if abspath.find(dir) != -1:
            return os.path.split(os.path.dirname(os.path.dirname(os.path.abspath(file))))[0]
    return os.path.split(os.path.dirname(os.path.abspath(file)))[0]

def get_bin_dir(file):
    return os.path.join(get_home_dir(file), 'bin')

def append_home_to_path(file):
    sys.path.insert(0, get_home_dir(file))

append_home_to_path(__file__)
from tomahawk.expect import CommandWithExpect
from tomahawk.constants import (
    DEFAULT_TIMEOUT,
    DEFAULT_EXPECT_DELAY,
    DEFAULT_RSYNC_OPTIONS,
)

def create_command_namespace(**kwargs):
    defaults = {
        'command': [ '' ], 'conf': None, 'continue_on_error': None,
        'debug': False, 'deep_debug': False,
        'delay': 0, 'expect_delay': 0.1,
        'hosts': 'localhost', 'profile': False,
        'ssh_user': 'tomahawk', 'timeout': DEFAULT_TIMEOUT
    }
    for k, v in defaults.items():
        kwargs.setdefault(k, v)
    return argparse.Namespace(**kwargs)

def create_rsync_namespace(**kwargs):
    defaults = {
        'source': None, 'destination': None,
        'conf': None, 'continue_on_error': None,
        'debug': False, 'deep_debug': False,
        'delay': 0, 'expect_delay': 0.1,
        'hosts': 'localhost', 'profile': False,
        'rsync_user': 'tomahawk',  'rsync_options': DEFAULT_RSYNC_OPTIONS,
        'timeout': DEFAULT_TIMEOUT,
    }
    for k, v in defaults.items():
        kwargs.setdefault(k, v)
    return argparse.Namespace(**kwargs)

def capture_stdout_stderr():
    o = StdoutCapture()
    e = StderrCapture()
    o.start(), e.start()
    return o, e

class StdoutCapture(object):
    def __init__(self):
        self.captured = StringIO()

    def start(self):
        sys.stdout = self.captured
        return self

    def stop(self):
        sys.stdout = sys.__stdout__
        return self

    def value(self):
        self.captured.flush()
        return self.captured.getvalue()

    def close(self):
        self.captured.close()

#    def __enter__(self):
#        self.start()
#        with StdoutCapture() as c:
#            c.value()
#   c = StdoutCapture()
#   c.__enter__() -> c.start()
#   c.value()
#   c.__exit__() -> c.stop()

class StderrCapture(StdoutCapture):
    def __init__(self):
        super(StderrCapture, self).__init__()

    def start(self):
        sys.stderr = self.captured
        return self

    def stop(self):
        sys.stderr = sys.__stderr__
        return self

class MockPexpect(object):
    def __init__(
        self, command, args = [], timeout = 30, maxread = 2000,
        searchwindowsize = None, logfile = None, cwd = None, env = None
    ):
        self.command = command
        self.args = args
        self.timeout = timeout
        self.maxread = maxread
        self.searchwindowsize = searchwindowsize
        self.logfile = logfile
        self.cwd = cwd
        self.env = env
        self._exitstatus = 0

    def expect(self, pattern, timeout = -1, searchwindowsize = -1):
        #sys.stdout.write("password: ")
        return 0

    def sendline(self, s = ''):
        if self.logfile:
            self.logfile.write(s.encode('utf-8'))
            self.logfile.write('\n'.encode('utf-8'))
        pass

    def send(self, s):
        pass

    def close(self):
        pass

    def get_exitstatus(self):
        return self._exitstatus

    def set_exitstatus(self, exitstatus):
        self._exitstatus = exitstatus

    exitstatus = property(get_exitstatus, set_exitstatus)

class MockCommandWithExpect(CommandWithExpect):
    def __init__(
        self, command, command_args, login_password, sudo_password,
        timeout = DEFAULT_TIMEOUT, expect_delay = DEFAULT_EXPECT_DELAY,
        debug_enabled = False, expect = None,
        expect_out = StringIO()
    ):
        if expect is None:
            expect = MockPexpect(command, command_args, timeout)
        super(MockCommandWithExpect, self).__init__(
            command, command_args, login_password, sudo_password,
            timeout, expect_delay, debug_enabled, expect, expect_out
        )

    def execute(self):
        return 0, ''


########NEW FILE########
__FILENAME__ = base
# -*- coding: utf-8 -*-
import multiprocessing
import os
import re
import platform
from six import print_
import string
import sys

from tomahawk import (
    __version__,
    TimeoutError,
)
from tomahawk.color import (
    create_coloring_object
)
from tomahawk.constants import (
    DEFAULT_TIMEOUT,
    DEFAULT_COMMAND_OUTPUT_FORMAT,
    DEFAULT_EXPECT_DELAY,
    DEFAULT_EXPECT_ENCODING,
    OUTPUT_FORMAT_CONTROLL_CHARS,
)
from tomahawk.log import create_logger
from tomahawk.utils import (
    check_hosts,
    get_options_from_conf,
    read_login_password,
    read_login_password_from_stdin,
    read_sudo_password,
    read_sudo_password_from_stdin
)
class BaseContext(object):
    def __init__(self, options = {}, out = sys.stdout, err = sys.stderr):
        self.options = options
        self.out = out
        self.err = err
        self.arguments, self.source, self.destination = None, None, None

class BaseMain(object):
    def __init__(self, script_path):
        self.script_path = script_path
        self.arg_parser = self.create_argument_parser(script_path)
        self.options = self.arg_parser.parse_args(sys.argv[1:])
        conf_options = None
        if self.options.conf:
            conf_options = get_options_from_conf(
                os.path.basename(script_path),
                self.options.conf
            )
            args = conf_options + sys.argv[1:]
            # Re-parse command line options because conf_options added
            self.options = self.arg_parser.parse_args(args)

        self.log = create_logger(
            None,
            self.options.debug or self.options.deep_debug,
            self.options.deep_debug
        )
        if conf_options:
            self.log.debug("Applying options %s from %s" % (str(conf_options), self.options.conf))

    def run(self):
        try:
            if self.options.profile:
                file = '%s.prof.%d' % (os.path.basename(self.script_path), os.getpid())
                cProfile = __import__('cProfile')
                pstats = __import__('pstats')
                cProfile.runctx("self.do_run()", globals(), locals(), file)
                p = pstats.Stats(file)
                p.strip_dirs()
                p.sort_stats('time', 'calls')
                p.print_stats()
                return 0 # TODO: return exit status
            else:
                return self.do_run()
        except KeyboardInterrupt:
            print_()
            print_('Keyboard interrupt. exiting...')

    def do_run(self):
        raise Exception("This is a template method implemented by sub-class")

    def check_hosts(self):
        return check_hosts(self.options.__dict__, self.log, self.arg_parser.format_usage)

    def confirm_execution_on_production(self, message):
        if os.environ.get('TOMAHAWK_ENV') != 'production':
            return

        input = raw_input(message)
        if input == 'yes':
            print_()
        else:
            print_('Command execution was cancelled.')
            sys.exit(0)

    @classmethod
    def add_common_arguments(cls, parser):
        parser.add_argument(
            '-h', '--hosts', metavar='HOSTS',
            help='DUPLICATED. Use -H. (Will be deleted in v0.8.0)',
        )
        parser.add_argument(
            '-H', '--hosts', metavar='HOSTS',
            help='Host names for sending commands. (splited with ",")',
        )
        parser.add_argument(
            '-f', '--hosts-files', metavar='HOSTS_FILES',
            help='Hosts files which listed host names. (splited with ",")'
        )
        parser.add_argument(
            '-c', '--continue-on-error', action='store_true', default=None,
            help='Command exectuion continues whatever any errors.'
        )
        parser.add_argument(
            '-p', '--parallel', metavar='NUM', type=int, default=1,
            help='Process numbers for parallel command execution. (default: 1)'
        )
        parser.add_argument(
            '-l', '--prompt-login-password', action='store_true',
            help='Prompt a password for ssh authentication.'
        )
        parser.add_argument(
            '--login-password-stdin', action='store_true',
            help='Read a password for ssh authentication from stdin.'
        )
        parser.add_argument(
            '-t', '--timeout', metavar='SECONDS', type=int, default=DEFAULT_TIMEOUT,
            help='Specify expect timeout in seconds. (default: %d)' % (DEFAULT_TIMEOUT)
        )
        parser.add_argument(
            '--expect-encoding', metavar='ENCODING', default=DEFAULT_EXPECT_ENCODING,
            help='Expect encoding for password prompt. (default: %s)' % (DEFAULT_EXPECT_ENCODING)
        )
        parser.add_argument(
            '-d', '--delay', type=int, default=0,
            help='Command delay time in seconds. (default: 0)'
        )
        parser.add_argument(
            '--expect-delay', type=float, default=DEFAULT_EXPECT_DELAY,
            help='Expect delay time in seconds. (default: 0.05)'
        )
        parser.add_argument(
            '-C', '--conf', metavar='FILE', default=None,
            help='Configuration file path.'
        )
        parser.add_argument(
            '-D', '--debug', action='store_true', default=False,
            help='Enable debug output.',
        )
        parser.add_argument(
            '--deep-debug', action='store_true', default=False,
            help='Enable deeper debug output.',
        )
        parser.add_argument(
            '--profile', action='store_true', help='Enable profiling.'
        )
        parser.add_argument(
            '--version', action='version',
            version='%(prog)s ' + __version__
            + ' with Python ' + '.'.join(map(str, sys.version_info[0:3]))
            + ' (' + platform.platform() + ')'
        )
        return parser

class BaseExecutor(object):
    """
    A base class for CommandExecutor, RsyncExecutor
    """
    def __init__(self, context, log, hosts=[], **kwargs):
        """
        Constructor
        
        Args:
        context -- context
        log -- log
        hosts -- target hosts
        """
        self.processes_terminated = False
        if context is None:
            raise RuntimeError('Argument "context" required.')
        if len(hosts) == 0:
            raise RuntimeError('Argument "hosts" length must be > 0')

        options = context.options
        newline = False
        login_password = None
        if 'login_password' in kwargs:
            login_password = kwargs['login_password']
        elif options.get('prompt_login_password'):
            login_password = read_login_password()
            newline = True
        elif options.get('login_password_stdin'):
            login_password = read_login_password_from_stdin()

        sudo_password = None
        if 'sudo_password' in kwargs:
            sudo_password = kwargs['sudo_password']
        elif options.get('prompt_sudo_password'):
            sudo_password = read_sudo_password()
        elif options.get('sudo_password_stdin'):
            sudo_password = read_sudo_password_from_stdin()

        if newline:
            print_()

        self.context = context
        self.log = log
        self.hosts = hosts
        self.login_password = login_password
        self.sudo_password = sudo_password
        self.raise_error = True
        if options.get('continue_on_error'):
            self.raise_error = False
        self.process_pool = multiprocessing.Pool(processes = options.get('parallel', 1))

    def process_async_results(
        self,
        async_results,
        create_output,
        create_timeout_message,
        create_timeout_raise_error_message,
        create_failure_message,
        create_failure_raise_error_message,
        create_failure_last_message,
    ):
        out, err = self.context.out, self.context.err
        color = create_coloring_object(out)
        options = self.context.options
        hosts_count = len(self.hosts)
        finished = 0
        error_hosts_count = 0
        output_format_template = string.Template(self.output_format(options.get('output_format', DEFAULT_COMMAND_OUTPUT_FORMAT)))
        timeout = options.get('timeout', DEFAULT_TIMEOUT)
        error_prefix = color.red(color.bold('[error]')) # insert newline for error messages

        execution_info = {}
        # Main loop continues until all processes are done
        while finished < hosts_count:
            for dict in async_results:
                host = dict['host']
                command = dict['command']
                async_result = dict['async_result']
                if not async_result.ready():
                    continue

                exit_status = 1
                command_output = ''
                timeout_detail = None
                try:
                    exit_status, command_output = async_result.get(timeout = timeout)
                    self.log.debug("host = %s, exit_status = %d" % (host, exit_status))
                except (TimeoutError, multiprocessing.TimeoutError):
                    error = sys.exc_info()[1]
                    timeout_detail = str(error)
                    execution_info[host] = { 'timeout': 1 }
                async_results.remove(dict)
                finished += 1

                output = create_output(color, output_format_template, command, host, exit_status, command_output)
                execution_info[host] = {
                    'exit_status': exit_status,
                    'command_output': command_output,
                    'timeout': False,
                }
                if command_output == '':
                    # if command_output is empty, chomp last newline character for ugly output
                    output = re.sub(os.linesep + r'\Z', '', output)

                if exit_status == 0:
                    print_(output, file=out)
                elif timeout_detail is not None:
                    print_('%s %s\n' % (
                        error_prefix,
                        create_timeout_message(color, output, timeout)
                    ), file=out)
                    execution_info[host]['timeout'] = True
                    error_hosts_count += 1
                    if self.raise_error:
                        print_('%s %s\n' % (
                            error_prefix,
                            create_timeout_raise_error_message(color, command, host, timeout)
                        ), file=err)
                        return 1
                else:
                    print_('%s %s\n' % (
                        error_prefix,
                        create_failure_message(color, output, exit_status)
                    ), file=out)
                    error_hosts_count += 1
                    if self.raise_error:
                        print_('%s %s' % (
                            error_prefix,
                            create_failure_raise_error_message(color, command, host)
                        ), file=err)
                        return 1
        
        # Free process pool
        self.terminate_processes()

        if error_hosts_count > 0:
            hosts = ''
            for h in self.hosts:
                if execution_info[h]['exit_status'] != 0:
                    hosts += '  %s\n' % (h)
            hosts = hosts.rstrip()
            print_('%s %s' % (
                error_prefix,
                create_failure_last_message(color, command, hosts)
            ), file=err)
            return 1

        if options.get('verify_output'):
            has_different_output = False
            prev_output = None
            hosts = ''
            for h in self.hosts:
                output = execution_info[h]['command_output']
                self.log.debug("host: '%s', prev_output: '%s', output = '%s'" % (h, prev_output, output))
                if prev_output != None and output != prev_output:
                    hosts += '  %s\n' % (h)
                    has_different_output = True
                prev_output = output
            hosts = hosts.rstrip()

            if has_different_output:
                print_("%s Detected different command output on following hosts.\n%s" \
                    % (color.red(error_prefix), hosts), file=err)
                return 3
            else:
                print_(color.green('Verified output of all hosts.'), file=out)

        return 0

    def output_format(self, format):
        seq = []
        prev, prev_prev = None, None
        for char in format:
            controll_char = OUTPUT_FORMAT_CONTROLL_CHARS.get(char)
            if controll_char and prev == '\\' and prev_prev == '\\':
                pass
            elif controll_char and prev == '\\':
                seq.pop(len(seq) - 1)
                seq.append(controll_char)
                prev_prev = prev
                prev = char
                continue

            seq.append(char)
            prev_prev = prev
            prev = char

        return ''.join(seq)

    def terminate_processes(self):
        if hasattr(self, 'process_pool') and not self.processes_terminated:
            #self.process_pool.close()
            self.log.debug("terminating processes")
            self.process_pool.terminate()
            self.process_pool.join()
            self.processes_terminated = True

    def __del__(self):
        self.terminate_processes()

########NEW FILE########
__FILENAME__ = bootstrap
import os
import sys

def set_lib_path(file):
    parent, bin_dir = os.path.split(os.path.dirname(os.path.abspath(file)))
    for dir in ('lib', ''):
        path = os.path.join(parent, dir)
        if os.path.exists(path):
            sys.path.insert(0, path)
    return parent, bin_dir

########NEW FILE########
__FILENAME__ = color
# -*- coding: utf-8 -*-
# This code is stolen from pssh-2.2.2

def create_coloring_object(stream):
    if has_colors(stream):
        return ColoringEnabled()
    else:
        return ColoringDisabled()

class ColoringDisabled(object):
    def bold(self, string): return string
    def red(self, string): return string
    def green(self, string): return string
    def yellow(self, string): return string
    def blue(self, string): return string
    def magenta(self, string): return string
    def cyan(self, string): return string
    def white(self, string): return string

class ColoringEnabled(ColoringDisabled):
    def bold(self, string): return bold(string)
    def red(self, string): return red(string)
    def green(self, string): return green(string)
    def yellow(self, string): return yellow(string)
    def blue(self, string): return blue(string)
    def magenta(self, string): return magenta(string)
    def cyan(self, string): return cyan(string)
    def white(self, string): return white(string)

def with_color(string, fg, bg=49):
    '''Given foreground/background ANSI color codes, return a string that,
    when printed, will format the supplied string using the supplied colors.
    '''
    return "\x1b[%dm\x1b[%dm%s\x1b[39m\x1b[49m" % (fg, bg, string)

def bold(string):
    '''Returns a string that, when printed, will display the supplied string
    in ANSI bold.
    '''
    return "\x1b[1m%s\x1b[22m" % string

def red(string): return with_color(string, 31) # Red
def green(string): return with_color(string, 32) # Green
def yellow(string): return with_color(string, 33) # Yellow
def blue(string): return with_color(string, 34) # Blue
def magenta(string): return with_color(string, 35) # Magenta
def cyan(string): return with_color(string, 36) # Cyan
def white(string): return with_color(string, 37) # White

#following from Python cookbook, #475186
def has_colors(stream):
    '''Returns boolean indicating whether or not the supplied stream supports
    ANSI color.
    '''
    try:
        if hasattr(stream, 'isatty'):
            if stream.isatty():
                return True
            else:
                return False
#        import curses
#        curses.setupterm()
#        return curses.tigetnum('colors') > 2
    except:
        # guess false in case of error
        return False

########NEW FILE########
__FILENAME__ = command
# -*- coding: utf-8 -*-
import argparse
import getpass
import os
import signal
import sys
import time

from tomahawk.base import BaseContext, BaseExecutor, BaseMain
from tomahawk.color import (
    create_coloring_object
)
from tomahawk.constants import (
    DEFAULT_COMMAND_OUTPUT_FORMAT
)
from tomahawk.expect import CommandWithExpect
from tomahawk.utils import (
    shutdown_by_signal,
    check_required_command
)

class CommandContext(BaseContext):
    """
    Command context
    """
    def __init__(self, arguments, options, out, err):
        super(CommandContext, self).__init__(options, out, err)
        self.arguments = arguments

class CommandMain(BaseMain):
    """
    Main class for tomahawk
    """

    def __init__(self, file):
        # setup self.log, self.arg_parser, self.options
        super(CommandMain, self).__init__(file)
        self.log.debug("options = " + str(self.options))
        self.log.debug("arguments = " + str(self.options.command))

    def do_run(self):
        self.context = CommandContext(
            self.options.command,
            self.options.__dict__,
            sys.stdout,
            sys.stderr
        )
        check_required_command('ssh')
        hosts = self.check_hosts()

        color = create_coloring_object(sys.stdout)
        # prompt when production environment
        self.confirm_execution_on_production(
            'Command "%s" will be executed to %s hosts. Are you sure? [yes/NO]: '
            % (color.green(' '.join(self.context.arguments)), color.green(len(hosts)))
        )

        executor = CommandExecutor(self.context, self.log, hosts)
        return executor.execute(self.context.arguments)

    @classmethod
    def create_argument_parser(cls, file):
        parser = argparse.ArgumentParser(
            prog = os.path.basename(file),
            description = "A simple command executor for many hosts.",
            conflict_handler = 'resolve'
        )
        parser.add_argument(
            'command', metavar='command', nargs='*',
            help='Command executed on remote hosts.',
        )
        parser.add_argument(
            '--ssh', default='ssh', help='ssh program. (default: "ssh")'
        )
        parser.add_argument(
            '-u', '--ssh-user', help='ssh user.'
        )
        parser.add_argument(
            '-o', '--ssh-options', help='ssh options.'
        )
        parser.add_argument(
            '-s', '--prompt-sudo-password', action='store_true',
            help='Prompt a password for sudo.'
        )
        parser.add_argument(
            '--sudo-password-stdin', action='store_true',
            help='Read a password for sudo from stdin.'
        )
        parser.add_argument(
            '-F', '--output-format', default=DEFAULT_COMMAND_OUTPUT_FORMAT,
            help="Command output format. (default: '%s')" % (DEFAULT_COMMAND_OUTPUT_FORMAT.replace('%', '%%').replace('\n', '\\n'))
        )
        parser.add_argument(
            '-V', '--verify-output', action='store_true',
            help="Verify command output of all hosts."
        )
        cls.add_common_arguments(parser)
        return parser

def _command(
    command, command_args, login_password, sudo_password,
    timeout, expect_delay, debug_enabled):
    """
    Execute a command.
    """
    # Trap SIGINT(Ctrl-C) to quit executing a command
    signal.signal(signal.SIGINT, shutdown_by_signal)

    try:
        return CommandWithExpect(
            command, command_args, login_password, sudo_password,
            timeout, expect_delay, debug_enabled
        ).execute()
    except:
        from traceback import print_tb
        print("""%s: %s""" % (sys.exc_info()[0], sys.exc_info()[1]))
        print_tb(sys.exc_info()[2])
        raise

class CommandExecutor(BaseExecutor):
    """
    Execute commands.

    Args:
    commands -- commands to execute.
    
    Returns: when rsync succeeds, return 0. When errors, return 1
    """
    def execute(self, commands):
        if len(commands) == 0:
            raise RuntimeError("[error] Too few arguments")

        options = self.context.options
        #ssh = options.get('ssh') or 'ssh'
        
        ssh_user = options.get('ssh_user') or ''
        ssh_options = ''
        if options.get('ssh_options'):
            ssh_options = options['ssh_options'] + ' '
        if ssh_user:
            ssh_options += '-l ' + ssh_user
        if ssh_options.find('-T') == -1:
            # if '-T' isn't specified, turn 'pseudo-tty allocation' on
            ssh_options += ' -t'

        async_results = []
        for host in self.hosts:
            for command in commands:
                command_args = []
                for option in ssh_options.split(' '):
                    #  remove left and right whitespaces
                    option = option.strip()
                    if len(option) > 0:
                        command_args.append(option)

                command_args.append(host)
                # Escape shell special chars
                c = command.replace('\\', '\\\\') \
                        .replace('"', '\"') \
                        .replace('$', '\$') \
                        .replace('`', '\`')

                # execute a command with shell because we want to use pipe(|) and so on.
                command_args.extend([ '/bin/sh', '-c', '"%s"' % (c) ])

                # host, command, ssh_user, ssh_option, login_password, sudo_password
                async_result = self.process_pool.apply_async(
                    _command,
                    ( 'ssh', command_args, self.login_password, self.sudo_password,
                      options['timeout'], options['expect_delay'], options['debug'] ),
                )
                async_results.append({ 'host': host, 'command': command, 'async_result': async_result })

                if options['delay'] != 0:
                    time.sleep(options['delay'])

        #######################
        # callbacks
        #######################
        def create_output(color, output_format_template, command, host, exit_status, command_output):
            c = command
            if exit_status == 0:
                c = color.green(command)
            return output_format_template.safe_substitute({
                'user': ssh_user or '[user]',
                'host': host,
                'command': c,
                'output': command_output,
            })

        def create_timeout_message(color, output, timeout):
            output += 'Command timed out after %d seconds' % (options['timeout'])
            return output

        def create_timeout_raise_error_message(color, command, host, timeout):
            return 'Command "%s" timed out on host "%s" after %d seconds' \
                % (command, host, timeout)

        def create_failure_message(color, output, exit_status):
            output += 'Command failed ! (status = %d)' % exit_status
            return output

        def create_failure_raise_error_message(color, command, host):
            return 'Command "%s" failed on host "%s"' % (command, host)

        def create_failure_last_message(color, command, hosts):
            return 'Command "%s" failed on following hosts\n%s' % (command, hosts)

        # Call BaseExectuor#process_async_results with callbacks
        return self.process_async_results(
            async_results,
            create_output,
            create_timeout_message,
            create_timeout_raise_error_message,
            create_failure_message,
            create_failure_raise_error_message,
            create_failure_last_message
        )

########NEW FILE########
__FILENAME__ = constants
DEFAULT_TIMEOUT = 10
DEFAULT_EXPECT_DELAY = 0.05
DEFAULT_EXPECT_ENCODING = 'utf-8'
DEFAULT_COMMAND_OUTPUT_FORMAT = '${user}@${host} % ${command}\n${output}\n'
DEFAULT_RSYNC_OUTPUT_FORMAT = '% ${command}\n${output}\n'
DEFAULT_RSYNC_OPTIONS = '-av'
OUTPUT_FORMAT_CONTROLL_CHARS = {
    'r': '\r',
    'n': '\n',
    't': '\t',
}

# TODO: should rename to tomahawk_common ?
class TimeoutError(RuntimeError):
    """Timeout error of command execution."""
    pass

class CommandError(RuntimeError):
    """Command execution error."""
    pass

class FatalError(RuntimeError):
    """A fatal error in tomahawk."""
    pass

########NEW FILE########
__FILENAME__ = expect
# -*- coding: utf-8 -*-
from six import print_, reraise
from six import BytesIO, StringIO
from six import b, u

import pexpect
import re
import sys
import time
from tomahawk.constants import (
    DEFAULT_TIMEOUT,
    DEFAULT_EXPECT_DELAY,
    CommandError,
    TimeoutError
)
from tomahawk.log import create_logger

class CommandWithExpect(object):

    """
    A command executor through expect.
    """
    def __init__(
        self, command, command_args, login_password, sudo_password,
        timeout = DEFAULT_TIMEOUT, expect_delay = DEFAULT_EXPECT_DELAY,
        debug_enabled = False, expect = None, expect_out = None
    ):
        self.login_password = login_password
        self.sudo_password = sudo_password
        self.timeout = timeout
        self.expect_delay = expect_delay
        self.log = create_logger(None, debug_enabled)
        self.expect_patterns = [
            b('^Enter passphrase.+'),
            b('[Pp]assword.*:'),
            u('パスワード').encode('utf-8'), # TODO: japanese character expected as utf-8
        ]
        if expect_out is None:
            #expect_out = StringIO()
            expect_out = BytesIO()
        if expect is None:
            self.expect = pexpect.spawn(
                command,
                command_args,
                timeout = timeout,
                logfile = expect_out
            )
        else:
            self.expect = expect
        self.expect_out = expect_out
        self.log.debug("command = %s, command_args = %s" % (command, str(command_args)))

    def execute(self):
        """
        Execute a command with expect.
        
        Returns: command result status, output string
        """
        try:
            index = self.expect.expect(self.expect_patterns)
            self.log.debug("expect index = %d" % (index))
            password = self.login_password or self.sudo_password
            if index in (0, 1, 2):
                if password is None:
                    self.log.debug("Password is None")
                    #print_('[error] Password is empty. Use -l or -s', file=stderr)
                    raise CommandError("Password is empty. Use -l/--prompt-login-password or --login-password-stdin.")

                if index == 0:
                    self.expect.sendline(self.login_password) # for ssh passphrase
                else:
                    self.expect.sendline(password)
                index2 = self.expect.expect(self.expect_patterns)
                self.log.debug("expect index2 = %d" % (index2))
                if index2 == 0:
                    self.expect.sendline(self.login_password) # for ssh passphrase
                else:
                    self.expect.sendline(password)
                self.expect.expect(pexpect.EOF)
            if index == 3:
                self.log.debug("expect.EOF")
        except pexpect.TIMEOUT:
            self.log.debug("expect.TIMEOUT")
            # TODO: test
            #self.expect.close()
            raise TimeoutError("Execution is timed out after %d seconds" % (self.timeout))
        except pexpect.EOF:
            self.log.debug("expect.EOF")
        except CommandError:
            e = sys.exc_info()[1]
            #raise(e, None, sys.exc_info()[2])
            reraise(*sys.exc_info())
        return self.get_status_and_output(self.expect, self.expect_out)

    def get_status_and_output(self, child, expect_out):
        # Need a litte bit sleep because of failure of expect
        time.sleep(self.expect_delay)
        child.close()
        self.log.debug("child closed.")

        exit_status = child.exitstatus
        if exit_status is None:
            exit_status = 1
        self.log.debug("exit_status = %d" % exit_status)

        output_lines = []
        expect_regexs = [ re.compile(p.decode('utf-8')) for p in self.expect_patterns ]
        expect_regexs.append(re.compile('Connection to .* closed'))

        passwords = []
        if self.login_password:
            passwords.append(self.login_password)
        if self.sudo_password:
            passwords.append(self.sudo_password)
        #print("--- bytes ---")
        #print(expect_out.getvalue())
        lines = expect_out.getvalue().decode("utf-8").split('\n')
        #for line in expect_out.getvalue().split('\n'):
        for line in lines:
            line = line.strip('\r\n')
            if line == '' or line in passwords:
                continue

            for password in passwords:
                # for debug output
                if line == password:
                    line = line.replace(password, len(password) * '*')
            self.log.debug("line = " + line)

            append = True
            for regex in expect_regexs:
                if regex.search(line):
                    append = False
                    continue
            if append:
                output_lines.append(line)

        output_text = '\n'.join(output_lines)
        self.log.debug("output_text = " + output_text)

        return exit_status, output_text

########NEW FILE########
__FILENAME__ = log
import logging
import sys

def create_logger(file_path = None, debug_enabled = False, deep_debug_enabled = False):
    level = logging.INFO
    if debug_enabled:
        level = logging.DEBUG
    if deep_debug_enabled:
        format = "[%(levelname)s] %(filename)s:%(lineno)d %(message)s"
    else:
        format = "[%(levelname)s] %(message)s"

    kwargs = { 'level': level, 'format': format }
    if file_path:
        kwargs['filename'] = file_path
    else:
        kwargs['stream'] = sys.stdout
    logging.basicConfig(**kwargs)
    return logging

########NEW FILE########
__FILENAME__ = rsync
# -*- coding: utf-8 -*-
import argparse
import getpass
import os
import signal
import sys
import time

from tomahawk.base import BaseContext, BaseMain, BaseExecutor
from tomahawk.color import (
    create_coloring_object
)
from tomahawk.constants import (
    DEFAULT_RSYNC_OUTPUT_FORMAT,
    DEFAULT_RSYNC_OPTIONS,
)
from tomahawk.expect import CommandWithExpect
from tomahawk.utils import (
    shutdown_by_signal,
    check_required_command
)

class RsyncContext(BaseContext):
    """
    """
    def __init__(self, source, destination, options, out, err):
        super(RsyncContext, self).__init__(options, out, err)
        self.source = source
        self.destination = destination

class RsyncMain(BaseMain):
    """
    Main class for tomahawk-rsync
    """

    def __init__(self, file):
        super(RsyncMain, self).__init__(file)
        self.log.debug("options = " + str(self.options))
        self.log.debug(
            "source = %s, destination = %s" % \
             (str(self.options.source), str(self.options.destination))
        )

    def do_run(self):
        self.context = RsyncContext(
            self.options.source,
            self.options.destination,
            self.options.__dict__,
            sys.stdout,
            sys.stderr
        )
        check_required_command('rsync')
        hosts = self.check_hosts()

        rsync_command = 'rsync %s %s %s' % (
            self.context.options['rsync_options'],
            self.context.source,
            self.context.destination
        )
        color = create_coloring_object(sys.stdout)
        # prompt when production environment
        self.confirm_execution_on_production(
            'Rsync command "%s" will be executed %s hosts. Are you sure? [yes/NO]: '
            % (color.green(rsync_command), color.green(len(hosts)))
        )

        executor = RsyncExecutor(self.context, self.log, hosts)
        return executor.execute(self.context.source, self.context.destination)

    @classmethod
    def create_argument_parser(cls, file):
        parser = argparse.ArgumentParser(
            prog = os.path.basename(file),
            description = "A simple rsync executor for many hosts.",
            conflict_handler = 'resolve'
        )
        parser.add_argument(
            'source', metavar='source', help='source',
        )
        parser.add_argument(
            'destination', metavar='destination', help='destination',
        )
        parser.add_argument(
            '-u', '--rsync-user', help='rsync user.'
        )
        parser.add_argument(
            '-o', '--rsync-options', default=DEFAULT_RSYNC_OPTIONS,
            help='rsync options. (default: "-avz")'
        )
        parser.add_argument(
            '-m', '--mirror-mode',
            help='"push" or "pull". "pull" means copy files remote -> local (default: "push")'
        )
        parser.add_argument(
            '-F', '--output-format', default=DEFAULT_RSYNC_OUTPUT_FORMAT,
            help="rsync command output format. (default: '%s')" % (DEFAULT_RSYNC_OUTPUT_FORMAT.replace('%', '%%').replace('\n', '\\n'))
        )
#       parser.add_argument(
#           '-a', '--append-host-suffix', action='store_true', default=True,
#           help='Append host name to destination file/dir (only when "--mirror-mode=pull").'
#       )
        cls.add_common_arguments(parser)
        return parser


def _rsync(command, login_password, timeout, expect_delay, debug_enabled):
    """
    Execute rsync
    """
    # Trap SIGINT(Ctrl-C) to quit executing a command
    signal.signal(signal.SIGINT, shutdown_by_signal)

    try:
        return CommandWithExpect(
            command, [], login_password, None,
            timeout, expect_delay, debug_enabled
        ).execute()
    except:
        from traceback import print_tb
        print("""%s: %s""" % (sys.exc_info()[0], sys.exc_info()[1]))
        print_tb(sys.exc_info()[2])
        raise


class RsyncExecutor(BaseExecutor):
    """
    Execute rsync.
    
    Args:
    source -- source file/dir
    destination -- destination file/dir
    
    Returns: when rsync succeeds, return 0. When errors, return 1
    """
    def execute(self, source, destination):
        if source is None:
            raise RuntimeError('1st argument "source" must not be None')
        if destination is None:
            raise RuntimeError('2nd argument "destination" must not be None')

        options = self.context.options
        rsync_user = options.get('rsync_user') or ''
        rsync_options = options.get('rsync_options') or DEFAULT_RSYNC_OPTIONS
        mirror_mode = options.get('mirror_mode') or 'push'
        if mirror_mode not in ('push', 'pull'):
            raise RuntimeError('Invalid mirror_mode: ' + mirror_mode)

        rsync_template = ''
        if mirror_mode == 'push':
            if rsync_user:
                rsync_template = 'rsync %s %s %s@%%s:%s' % (
                    rsync_options, source,
                    rsync_user or '[user]', destination)
            else:
                rsync_template = 'rsync %s %s %%s:%s' % (
                    rsync_options, source, destination)
        else:
            if rsync_user:
                rsync_template = 'rsync %s %s@%%s:%s %%s' % (
                    rsync_options, rsync_user, source)
            else:
                rsync_template = 'rsync %s %%s:%s %%s' % (
                    rsync_options, source)

        async_results = []
        for host in self.hosts:
            c = None
            if mirror_mode == 'push':
                c = rsync_template % (host)
            else: # pull
                dest = destination
                if os.path.exists(destination):
                    if os.path.isdir(destination):
                        # if destination is a directory, gets a source filename and appends a host suffix
                        file_name = os.path.basename(source)
                        if not destination.endswith('/'):
                            dest += '/'
                        dest += '%s__%s' % (host, file_name)
                    else:
                        # if destination is a file, simply appends a host suffix
                        dest = host + '__' + dest
                else:
                     # if file doesn't exist
                    source_name = os.path.basename(source)
                    if source.endswith('/'):
                        os.path.basename(source[0:len(source)-1])
                    dest += host + '__' + source_name
                c = rsync_template % (host, dest)
            
            self.log.debug('command = "%s"' % (c))

            async_result = self.process_pool.apply_async(
                _rsync,
                ( c, self.login_password, options['timeout'], options['expect_delay'], options['debug'] )
            )
            async_results.append({ 'host': host, 'command': c, 'async_result': async_result })

            if options['delay'] != 0:
                time.sleep(options['delay'])

        ###########################
        # callbacks
        ###########################
        def create_output(color, output_format_template, command, host, exit_status, command_output):
            c = command
            if exit_status == 0:
                c = color.green(command)
            return output_format_template.safe_substitute({
                'host': host,
                'command': c,
                'output': command_output,
            })

        def create_timeout_message(color, output, timeout):
            output += 'rsync timed out after %d seconds' % (options['timeout'])
            return output

        def create_timeout_raise_error_message(color, command, host, timeout):
            return '"%s" timed out on host "%s" after %d seconds.' % (c, host, timeout)

        def create_failure_message(color, output, exit_status):
            output += 'rsync failed ! (status = %d)' % exit_status
            return output

        def create_failure_raise_error_message(color, command, host):
            return '"%s" failed on host "%s"' % (command, host)

        def create_failure_last_message(color, command, hosts):
            rsync = None
            if mirror_mode == 'push':
                rsync = rsync_template % ('REMOTE_HOST')
            else:
                rsync = rsync_template % ('REMOTE_HOST', 'LOCAL')
            return '"%s" failed on following hosts\n%s' % (rsync, hosts)

        # Call BaseExectuor#process_async_results with callbacks
        return self.process_async_results(
            async_results,
            create_output,
            create_timeout_message,
            create_timeout_raise_error_message,
            create_failure_message,
            create_failure_raise_error_message,
            create_failure_last_message
        )


########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-
from six import print_
from six.moves import configparser

#import ConfigParser
from getpass import getpass, getuser
import os
import sys
import shlex

def shutdown_by_signal(signum, frame):
    print_()
    print_('Shutting down by signal %d.' % signum)
    # TODO: this function called twice
    sys.exit(signum)

def read_login_password():
    password = None
    while True:
        password = getpass("Enter a password for ssh authentication: ")
        if len(password) > 0:
            return password

def read_login_password_from_stdin():
    for line in sys.stdin:
        return line.rstrip()

def read_sudo_password():
    password = None
    while True:
        password = getpass("Enter a password for sudo: ")
        if len(password) > 0:
            return password

def read_sudo_password_from_stdin():
    for line in sys.stdin:
        return line.rstrip()

def get_run_user():
    return getuser()

def get_options_from_conf(command, conf_path):
    if not os.path.exists(conf_path):
        return []
    parser = configparser.ConfigParser()
    try:
        parser.read(conf_path)
        value = parser.get(command, 'options')
        if not value:
            return []
        return shlex.split(value.strip())
    except configparser.NoOptionError:
        e = sys.exc_info()[1]
        # ConfigParser.NoOptionError: No option 'options' in section: 'tomahawk'
        print_('[WARNING] %s. in "%s"' % (e, conf_path), file=sys.stderr)
        return []

def check_hosts(options, log, usage_func):
    if options.get('hosts') is not None and options.get('hosts_files') is not None:
        print_('Cannot specify both options --hosts and --hosts-files.', file=sys.stderr)
        print_(usage_func(), file=sys.stderr)
        sys.exit(1)

    # initialize target hosts with --hosts or --hosts-files
    hosts = []
    # TODO: \, escape handling
    # regexp: [^\\],
    if options.get('hosts'):
        list = options['hosts'].split(',')
        for host in list:
            host.strip()
            hosts.append(host)
    elif options.get('hosts_files'):
        list = options['hosts_files'].split(',')
        for file in list:
            try:
                for line in open(file):
                    host = line.strip()
                    if host == '' or host.startswith('#'):
                        continue
                    hosts.append(host)
            except IOError:
                e = sys.exc_info()[1]
                print_('Failed to open "%s". (%s)' % (file, e), file=sys.stderr)
                sys.exit(4)
    else:
        print_('Specify -H/--hosts or -f/--hosts-files option.', file=sys.stderr)
        print_(usage_func(), file=sys.stderr)
        sys.exit(1)

    # Adjust parallel execution numbers with count of hosts
    parallel = options.get('parallel', 1)
    if len(hosts) < parallel:
        options['parallel'] = len(hosts)
    
    return hosts

def get_home_dir(file):
    abspath = os.path.abspath(file)
    parent, dir = None, None
    if abspath.find('internal') != -1 or abspath.find('external') != -1:
        parent, dir = os.path.split(os.path.dirname(os.path.dirname(os.path.abspath(file))))
    else:
        parent, dir = os.path.split(os.path.dirname(os.path.abspath(file)))
    return parent

def check_required_command(command):
    def is_executable(path):
        return os.path.exists(path) and os.access(path, os.X_OK)

    dir, name = os.path.split(command)
    if dir and is_executable(command):
        return
    else:
        for dir in os.environ['PATH'].split(os.pathsep):
            exe = os.path.join(dir, command)
            if is_executable(exe):
                return
    print_('Program "%s" is not executable. Check installation.' % (command), file=sys.stderr)
    sys.exit(1)

########NEW FILE########
