The basic idea for all of these plots is that you should be able to do `ppl.{plot_command}(ax, x, y)` instead of `plt.{plot_command}(x, y)`. I haven't figured yet how to completely inherit `Axes` and such from `matplotlib`, because it is a huge, very complicated piece of code. But hopefully that functionality will be in future releases :)

# `plot` (lines, e.g. time series) with a `legend`

For data where the `x` and `y` are ordered, like by time or distance, use `ppl.plot`, similar to how you'd use `plt.plot` or `ax.plot` from `matplotlib`. Except instead of `plt.plot(x, y)` or `ax.plot(x, y)`, do `ppl.plot(ax, x, y)`.

```python
import prettyplotlib as ppl
import numpy as np

# prettyplotlib imports
import matplotlib.pyplot as plt
import matplotlib as mpl
from prettyplotlib import brewer2mpl

# Set the random seed for consistency
np.random.seed(12)

fig, ax = plt.subplots(1)

# Show the whole color range
for i in range(8):
    y = np.random.normal(size=1000).cumsum()
    x = np.arange(1000)

    # For now, you need to specify both x and y :(
    # Still figuring out how to specify just one
    ppl.plot(ax, x, y, label=str(i), linewidth=0.75)

ppl.legend(ax)

fig.savefig('plot_prettyplotlib_default.png')
```
![Default line plotting](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/plot_prettyplotlib_default.png)


# `legend` parameters

If you want to move the legend to somewhere else, use the arguments you'd normally use for `legend()`, e.g. `loc='lower right', ncol=4`:

```python
ppl.legend(ax, loc='lower left', ncol=4)
```

The full code is here:

```python
import prettyplotlib as ppl
import numpy as np

# prettyplotlib imports
import matplotlib.pyplot as plt
import matplotlib as mpl
from prettyplotlib import brewer2mpl

# Set the random seed for consistency
np.random.seed(12)

fig, ax = plt.subplots(1)

# Show the whole color range
for i in range(8):
    y = np.random.normal(size=1000).cumsum()
    x = np.arange(1000)

    # For now, you need to specify both x and y :(
    # Still figuring out how to specify just one
    ppl.plot(ax, x, y, label=str(i))

ppl.legend(ax, loc='lower left', ncol=4)

fig.savefig('plot_prettyplotlib_legend_lower_left.png')
```
![Legend parameters](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/plot_prettyplotlib_legend_lower_left.png)

# `fill_between` (area between two lines)

This is for when you want to show the area between two lines,
like you have timeseries of two stocks and want to show their difference.

```python
import prettyplotlib as ppl

# prettyplotlib imports
import matplotlib.pyplot as plt
import matplotlib as mpl
from prettyplotlib import brewer2mpl

# Set the random seed for consistency
np.random.seed(12)

fig, ax = plt.subplots(1)

# Show the whole color range
for i in range(8):
    y1 = np.random.normal(size=1000).cumsum()
    y2 = np.random.normal(size=1000).cumsum()
    x = np.arange(1000)

    ppl.fill_between(x, y1, y2, label=str(i))

ppl.legend()

fig.savefig('fill_between_prettyplotlib_default.png')
```
![fill_between](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/fill_between_prettyplotlib_default.png)

# `fill_betweenx` (area between two lines, fill between x values)

This is for when you want to show the area between two lines,
like you have timeseries of two stocks and want to show their difference.

```python
import prettyplotlib as ppl

# prettyplotlib imports
import matplotlib.pyplot as plt
import matplotlib as mpl
from prettyplotlib import brewer2mpl

# Set the random seed for consistency
np.random.seed(12)

fig, ax = plt.subplots(1)

# Show the whole color range
for i in range(8):
    y1 = np.random.normal(size=1000).cumsum()
    y2 = np.random.normal(size=1000).cumsum()
    x = np.arange(1000)

    ppl.fill_betweenx(x, y1, y2, label=str(i))

ax = ppl.legend()

fig.savefig('fill_between_prettyplotlib_default.png')
```
![fill_betweenx](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/fill_betweenx_prettyplotlib_default.png)

# `scatter` (points)

This is for less structured data than `plot`, like if you have two samples X and Y, and gene expression for each one, and you want to see how the expression of the same gene is for the two samples. :)

```python
import prettyplotlib as ppl
import numpy as np

# This is "import matplotlib.pyplot as plt" from the prettyplotlib library
import matplotlib.pyplot as plt

# This is "import matplotlib as mpl" from the prettyplotlib library
import matplotlib as mpl

# Set the random seed for consistency
np.random.seed(12)

fig, ax = plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    ppl.scatter(ax, x, y, label=str(i))

ppl.legend(ax)

ax.set_title('prettyplotlib `scatter` example\nshowing default color cycle and scatter params')
fig.savefig('scatter_prettyplotlib_default.png')
```
![Default scatter plot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_prettyplotlib_default.png)

## Back to `matplotlib`-style scatterplots

If you ***really*** want to change all the parameters I worked so hard on, you can:

```python
import prettyplotlib as ppl
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
from prettyplotlib import brewer2mpl

# Set the random seed for consistency
np.random.seed(12)

fig, ax = plt.subplots(1)

#mpl.rcParams['axis.color_cycle'] = ['blue']

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    ax.scatter(x, y, label=str(i), facecolor='blue', edgecolor='black', linewidth=1)

# Get back the top and right axes lines ("spines")
spines_to_remove = ['top', 'right']
for spine in spines_to_remove:
    ax.spines[spine].set_visible(True)

# Get back the ticks. The position of the numbers is informative enough of
# the position of the value.
ax.xaxis.set_ticks_position('both')
ax.yaxis.set_ticks_position('both')

# For all the spines, make their line thicker and return them to be black
all_spines = ['top', 'left', 'bottom', 'right']
for spine in all_spines:
    ax.spines[spine].set_linewidth(1.0)
    ax.spines[spine].set_color('black')

# Change the labels back to black
ax.xaxis.label.set_color('black')
ax.yaxis.label.set_color('black')

# Change the axis title also back to black
ax.title.set_color('black')

# Remove the line around the legend box, and instead fill it with a light grey
# Also only use one point for the scatterplot legend because the user will
# get the idea after just one, they don't need three.
ax.legend()

ax.set_title('prettyplotlib `scatter` example\nshowing default color cycle and scatter params')
fig.savefig('scatter_prettyplotlib_back_to_matplotlib_default.png')
```

![Default scatter plot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_prettyplotlib_back_to_matplotlib_default.png)

# `bar`

This plot is great for categorical data, unrelated quantities such as number of cats, oranges, and computers per household.

```python
import prettyplotlib as ppl
import numpy as np
import matplotlib.pyplot as plt

fig, ax = plt.subplots(1)

np.random.seed(14)

ppl.bar(ax, np.arange(10), np.abs(np.random.randn(10)))
fig.savefig('bar_prettyplotlib_default.png')
```

![Default bar plot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_prettyplotlib_default.png)

## `bar` with a white grid to "erase" and yet add information!

If you supply the command `grid="y"`, where the `"y"` indicates I want the grid coming out of the y-axis at certain `y=...` values, aka perpendicular to the y-axis, you will get a white grid drawn over your data. It's almost like adding ticks, but since it's "erasing", it increases the data-ink ratio.

```python
import prettyplotlib as ppl
import numpy as np
import matplotlib.pyplot as plt

fig, ax = plt.subplots(1)

np.random.seed(14)

# 'y' for make a grid based on where the major ticks are on the y-axis
ppl.bar(ax, np.arange(10), np.abs(np.random.randn(10)), grid='y')
fig.savefig('bar_prettyplotlib_grid.png')
```

![Bar plot with white grid](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_prettyplotlib_grid.png)

## `bar` with value annotation on each bar

If you say `annotate=True` in the `ppl.bar` command, then the value of the number on top of the bar plot will be added.

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
import numpy as np
import string

fig, ax = plt.subplots(1)
np.random.seed(14)
n = 10
ppl.bar(ax, np.arange(n), np.abs(np.random.randn(n)), annotate=True, grid='y')
fig.savefig('bar_prettyplotlib_grid_annotated.png')
```
![Bar plot with white grid](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_prettyplotlib_grid_annotated.png)


### `bar` correctly annotates negative values

If you happen to have negative values in your bar plot, the annotation on them will correctly appear underneath them. Also, the x-axis line will be moved up to the `y=0` mark, instead of staying at the bottom.

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt

fig, axes = plt.subplots(nrows=4, figsize=(6,8))

# This is the order we want to plot them, too
nucleotides = ['C', 'G', 'A', 'T']

colors = {nucleotide: ppl.colors.set2[i] for i, nucleotide in enumerate(nucleotides)}

entire_strand = {'C':427419, 'G':413241, 'A':491488, 'T':491363}
reverse_half = {'C': 219518, 'G':201634, 'A':243963, 'T':246641}
forward_half = {'C': 207901, 'G':211607, 'A':247525, 'T':244722}
skew = {nucleotide: forward_half[nucleotide] - reverse_half[nucleotide] for nucleotide in nucleotides}

strands = {'Entire strand':entire_strand,
            'Reverse half-strand':reverse_half,
            'Forward half-strand':forward_half,
            'Forward - Reverse':skew}

# The order that we want to plot the strand data in:
strand_names_ordered = ['Entire strand', 'Forward half-strand', 'Reverse half-strand', 'Forward - Reverse']

left = range(len(nucleotides))
for ax, strand_name in zip(axes, strand_names_ordered):
    strand_data = strands[strand_name]
    ppl.bar(ax, left=left,
            height=[strand_data[nucleotide] for nucleotide in nucleotides],
            annotate=True,
            xticklabels=nucleotides,
            grid='y',
            color=[colors[nucleotide] for nucleotide in nucleotides])
    ax.set_title(strand_name)

# Tell matplotlib to smartly lay out our figure
fig.tight_layout()
```
![Bar plot with white grid](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/prettyplotlib_bar_nucleotide_counts.png)




### `bar` with arbitrary annotation

If you don't like the way `prettyplotlib` formats the numbers on top of the bars, or you just want to label with something else, you can supply your own numbers or strings by giving an iterable (like a list of strings or numbers) to `annotate`:

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
import numpy as np
import string

fig, ax = plt.subplots(1)
np.random.seed(14)
n = 10
ppl.bar(ax, np.arange(n), np.abs(np.random.randn(n)),
        annotate=range(n,2*n), grid='y', xticklabels=string.uppercase[:n])
fig.savefig('bar_prettyplotlib_grid_annotated_user_labeled.png')
```
![Bar plot with white grid, with arbitrary annotation](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_prettyplotlib_grid_annotated_user.png)

## `bar` with each bar labeled on x-axis

If you supply `xticklabels` as an argument to `plt.bar`, this will label each bar with this xlabel.

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
import numpy as np
import string

fig, ax = plt.subplots(1)
np.random.seed(14)
n = 10
ppl.bar(ax, np.arange(n), np.abs(np.random.randn(n)), annotate=True, xticklabels=string.uppercase[:n], grid='y')
fig.savefig('bar_prettyplotlib_grid_annotated_labeled.png')
```

![Bar plot with white grid, x-axis labeled and each bar annotated](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_prettyplotlib_grid_annotated_labeled.png)

## `bar` and `barh` with colormap

If you want to color the bars according to thier height, you should either use `cmap=True` or you specify the colormap on your own `cmap=your_cmap`:

```python
import prettyplotlib as ppl
from pylab import savefig, show, figure, subplot
from numpy import array, e
from scipy import optimize
from scipy.misc import factorial 
# prettyplotlib imports
import brewer2mpl

func    = lambda p, x: p[0]*pow(p[1],x)*pow(e,-p[1])/factorial(x)
N       = range(40)

Set2 = brewer2mpl.get_map('Paired', 'qualitative', 8).mpl_colormap

figure(figsize=(12,10))
subplot(2,2,1)
ppl.bar(N, func(array([0.9,14.8]),N),  cmap=True)
subplot(2,2,2)
ppl.barh(N, func(array([0.9,14.8]),N),  cmap=True)
subplot(2,2,3)
ppl.bar(N, func(array([0.9,14.8]),N),  cmap=Set2)
subplot(2,2,4)
ppl.barh(N, func(array([0.9,14.8]),N),  cmap=Set2)

#show()
savefig('bar_prettyplotlib_colormap.png')
```

# `hist`

If you have a large number of values and you're curious about the distribution of values within the data, `hist` is the function for you!

Right now, sideways histograms (with `orientation=horizontal`) aren't working in my `matplotlib` so they are untested.

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
import numpy as np

np.random.seed(12)

fig, ax = plt.subplots(1)

ppl.hist(ax, np.random.randn(1000))
fig.savefig('hist_prettyplotlib_default.png')
```
![Histogram](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/hist_prettyplotlib_default.png)

## `hist` with a white grid to "erase" and yet add information!

Like with `bar`, you can add a white grid with `grid="y"`, where the `"y"` indicates I want the grid coming out of the y-axis at certain `y=...` values, aka perpendicular to the y-axis.

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
import numpy as np

np.random.seed(12)

fig, ax = plt.subplots(1)

# 'y' for the 'y' axis. Could also add a grid over the 'x' axis.
ppl.hist(ax, np.random.randn(1000), grid='y')
fig.savefig('hist_prettyplotlib_grid.png')
```
![Histogram with white grid](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/hist_prettyplotlib_grid.png)

# `boxplot`

If you have several things you'd like to compare distributions with, the `boxplot` can be very nice.

```python
import prettyplotlib as ppl
import numpy as np
import matplotlib.pyplot as plt

np.random.seed(10)

data = np.random.randn(8, 4)
labels = ['A', 'B', 'C', 'D']

fig, ax = plt.subplots()
ppl.boxplot(ax, data, xticklabels=labels)
fig.savefig('boxplot_prettyplotlib_default.png')
```
![Boxplot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/boxplot_prettyplotlib_default.png)

# `pcolormesh` (heatmaps)

Because `matplotlib` took the color scheme from MATLAB, it inherited the ubiquitous and every-distorting rainbow color map:

![Boxplot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_matplotlib_default.png)

How can you tell what values are positive and negative, at a glance? it's impossible without heavy scrutiny and switching back and forth between the figure and the colorbar. Indeed, there have been studies stating that [*"the rainbow colormap is universally inferior to all other colormaps"*](http://www.jwave.vt.edu/~rkriz/Projects/create_color_table/color_07.pdf)

So `prettyplotlib` makes a beautiful default colormap. Notice that this syntax is different from all others, because you must supply `fig` as well to plot the `colormap`, the scale which shows what color corresponds to what value.

```
ppl.pcolormesh(fig, ax, np.random.randn(10,10))
```

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.random.randn(10,10))
fig.savefig('pcolormesh_prettyplotlib_default.png')
```
![Heatmap](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_default.png)


## `pcolormesh`: auto-detect positive/negative/both data

Notice that the above plot has both blue and red colors, and on the colorbar to the right you see there are both positive and negative values. If you have only positive or only negative values, `prettyplotlib` will auto-detect this and adjust the colormap accordingly.

### `pcolormesh`: positive-only data

For positive data, the colors default to red, with larger numbers darker and smaller numbers lighter.

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.abs(np.random.randn(10,10)))
fig.savefig('pcolormesh_prettyplotlib_positive.png')
```
![Heatmap: positive values only](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_positive.png)


### `pcolormesh`: negative-only data

For negative data, the colormap defaults to blues, with more negative (smaller) values darker blue, and larger values (closer to zero) as lighter blue.

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, -np.abs(np.random.randn(10,10)))
fig.savefig('pcolormesh_prettyplotlib_negative.png')
```
![Heatmap: negative values only](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_negative.png)

## `pcolormesh` with labels

It can be a pain in the neck to figure out how to put row and column labels directly onto a `pcolormesh` heatmap. Thankfully, `prettyplotlib` will accept `xticklabels` and `yticklabels` arguments, like this:

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
import numpy as np
import string

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.random.randn(10,10),
               xticklabels=string.uppercase[:10],
               yticklabels=string.lowercase[-10:])
fig.savefig('pcolormesh_prettyplotlib_labels.png')
```
![Heatmap: negative values only, with labels](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_labels.png)

## `pcolormesh`: custom colormaps

If you'd like to use your own colormaps, go ahead!

### `pcolormesh`: custom diverging colormaps

If your data has both positive and negative values, a diverging colormap is an excellent choice as it will highlight the differences between positive and negative, and the zero values. The diverging colormap `PRGn` or Purple and Green is pretty nice. I usually use this website to look up the colormaps: [Every Colorbrewer Scale](http://bl.ocks.org/mbostock/5577023)

Just import `brewer2mpl` from `prettyplotlib` and specify your colormap. The main lines to change are:

```python
from prettyplotlib import brewer2mpl
...
green_purple = brewer2mpl.get_map('PRGn', 'diverging', 11).mpl_colormap
...
ppl.pcolormesh(...,
               cmap=green_purple)
```
Here is the full code:
```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
from prettyplotlib import brewer2mpl
import numpy as np
import string

green_purple = brewer2mpl.get_map('PRGn', 'diverging', 11).mpl_colormap

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.random.randn(10,10),
               xticklabels=string.uppercase[:10],
               yticklabels=string.lowercase[-10:],
               cmap=green_purple)
fig.savefig('pcolormesh_prettyplotlib_labels_other_cmap_diverging.png')
```
![Heatmap: custom diverging colormap](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_labels_other_cmap_diverging.png)

### `pcolormesh`: custom sequential colormaps

Or, if you have positive-only or negative-only data, a sequential colormap like this Red-Purple one is great. The command is similar to the diverging colormaps:

```python
from prettyplotlib import brewer2mpl
...
red_purple = brewer2mpl.get_map('RdPu', 'Sequential', 9).mpl_colormap
...
ppl.pcolormesh(...,
               cmap=red_purple)
```

Here is the full code.

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
from prettyplotlib import brewer2mpl
import numpy as np
import string

red_purple = brewer2mpl.get_map('RdPu', 'Sequential', 9).mpl_colormap

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.abs(np.random.randn(10,10)),
               xticklabels=string.uppercase[:10],
               yticklabels=string.lowercase[-10:],
               cmap=red_purple)
fig.savefig('pcolormesh_prettyplotlib_labels_other_cmap_sequential.png')
```

![Heatmap: custom colormap with positive data, sequential colormap](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_labels_other_cmap_sequential.png)

## `pcolormesh`: log scaling

Finally, if you'd like to supply some special commands for `pcolormesh` like log scaling, you can do that too!

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
from prettyplotlib import brewer2mpl
import numpy as np
import string
from matplotlib.colors import LogNorm

red_purple = brewer2mpl.get_map('RdPu', 'Sequential', 9).mpl_colormap

fig, ax = plt.subplots(1)

np.random.seed(10)

x = np.abs(np.random.randn(10,10))
ppl.pcolormesh(fig, ax, x,
               xticklabels=string.uppercase[:10],
               yticklabels=string.lowercase[-10:],
               cmap=red_purple,
               norm=LogNorm(vmin=x.min().min(), vmax=x.max().max()))
fig.savefig('pcolormesh_prettyplotlib_labels_lognorm.png')
```
![Heatmap: log-normalized custom colormap with positive data, sequential colormap](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_labels_lognorm.png)


## `pcolormesh`: recenter divergent values

If you have a divergent colormap but you want the white zero value to be
something else, you can supply `center_value` as a keyword argument to
`pcolormesh` to recenter the data.

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
from prettyplotlib import brewer2mpl
import numpy as np
import string

green_purple = brewer2mpl.get_map('PRGn', 'diverging', 11).mpl_colormap

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.random.randn(10,10),
               xticklabels=string.uppercase[:10],
               yticklabels=string.lowercase[-10:],
               cmap=green_purple, center_value=2)
fig.savefig('pcolormesh_prettyplotlib_labels_other_cmap_diverging_center_value.png')
```
![Heatmap: custom diverging colormap](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_labels_other_cmap_diverging_center_value.png)

And now the 'zero' value is 2! So it's white at 2. Looks like most of the
data is below there..


# `prettyplotlib.pcolormesh`: Improving heatmaps in `matplotlib`

## Both positive and negative values

The default `matplotlib` `pcolormesh` heatmaps use a rainbow colormap, which has
been known to mislead data visualization. Specifically, [*"the rainbow color map
is universally inferior to all other color maps"*](http://www.jwave.vt.edu/~rkri
z/Projects/create_color_table/color_07.pdf). Unfortunately, `matplotlib` took
its default colors from MATLAB, and there the default is also rainbow.

In[1]:

```
import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots(1)

np.random.seed(10)

#ax.pcolor(np.random.randn((10,10)))
#ax.pcolor(np.random.randn(10), np.random.randn(10))
p = ax.pcolormesh(np.random.randn(10,10))
fig.colorbar(p)
fig.savefig('pcolormesh_matplotlib_default.png')
```



[!image]()


Using the same zero-centered randomly distributed gaussian distribution, we can
plot it using `prettplotlib` with a few modifications:

    ppl.pcolormesh(fig, ax, np.random.randn(10,10))

You'll notice that the "hot" (large, positive) color is still red, and the
"cold" (small, negative) color is still blue, but the in between colors are
gradations of red and blue, so it's easier to tell the difference between
values.

In[2]:

```
import prettyplotlib as ppl
from prettyplotlib import plt
import numpy as np

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.random.randn(10,10))
fig.savefig('pcolormesh_prettyplotlib_default.png')
```



[!image]()


You may have noticed similar changes as were made in `prettyplotlib.scatter`,
where axis lines were removed, and blacks were changed to almost black.

## Only positive (or negative) values

If your data is only positive (or negative), `matplotlib` does nothing to change
the color scale. It's still a rainbow, but look at the colorbar, the range is
different (0 to 1 instead of -2 to +2)

In[3]:

```
import prettyplotlib as ppl
from prettyplotlib import plt
import numpy as np

fig, ax = plt.subplots(1)

np.random.seed(10)

p = ax.pcolormesh(np.random.uniform(size=(10,10)))
fig.colorbar(p)
fig.savefig('pcolormesh_matplotlib_positive_default.png')
```



[!image]()


If your data is only positive or negative, then `prettyplotlib` will auto-detect
this and use a single-color colormap. The default for positive data is the
`reds` colormap.

In[4]:

```
import prettyplotlib as ppl
from prettyplotlib import plt
import numpy as np

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.abs(np.random.randn(10,10)))
fig.savefig('pcolormesh_prettyplotlib_positive.png')
```



[!image]()


And the default for negative data is the `blues` colormap.

In[5]:

```
import prettyplotlib as ppl
from prettyplotlib import plt
import numpy as np

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, -np.abs(np.random.randn(10,10)))
fig.savefig('pcolormesh_prettyplotlib_negative.png')
```



[!image]()


Plus you can add $x$- and $y$-ticklabels directly!

Normally, when you add $x$- and $y$-ticklables on `pcolormesh` in `matplotlib`,
they're not centered on the blocks, and you have to do a lot of annoying work
just getting a label on each box. You have to specify the xticks explicitly,
since you want to label each box.

    xticks = range(10)
    yticks = range(10)

    xticklabels=string.uppercase[:10]
    yticklabels=string.lowercase[-10:]

    ax.set_xticks(xticks)
    ax.set_xticklabels(xticklabels)

    ax.set_yticks(yticks)
    ax.set_yticklabels(yticklabels)


In[6]:

```
import prettyplotlib as ppl
from prettyplotlib import plt
import numpy as np
import string

fig, ax = plt.subplots(1)

np.random.seed(10)

p = ax.pcolormesh(np.abs(np.random.randn(10,10)))
fig.colorbar(p)

xticks = range(10)
yticks = range(10)

xticklabels=string.uppercase[:10]
yticklabels=string.lowercase[-10:]

ax.set_xticks(xticks)
ax.set_xticklabels(xticklabels)

ax.set_yticks(yticks)
ax.set_yticklabels(yticklabels)


fig.savefig('pcolormesh_matplotlib_positive_labels.png')
```



[!image]()


But `prettyplotlib.pcolormesh` assumes that you want the `xticklabels` and
`yticklabels` on each block, and makes it easy to specify.

    ppl.pcolormesh(fig, ax, np.random.uniform(size=(10,10)),
                   xticklabels=string.uppercase[:10],
                   yticklabels=string.lowercase[-10:])

In[11]:

```
import prettyplotlib as ppl
from prettyplotlib import plt
import numpy as np
import string

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.random.randn(10,10), 
               xticklabels=string.uppercase[:10], 
               yticklabels=string.lowercase[-10:])
fig.savefig('pcolormesh_prettyplotlib_labels.png')
```



[!image]()


Or pick your own colormap! The diverging colormap `PRGn` or Purple and Green is
pretty nice. I usually use this website to look up the colormaps: [Every
Colorbrewer Scale](http://bl.ocks.org/mbostock/5577023)

In[25]:

```
import prettyplotlib as ppl
from prettyplotlib import plt
from prettyplotlib import brewer2mpl
import numpy as np
import string

green_purple = brewer2mpl.get_map('PRGn', 'diverging', 11).mpl_colormap

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.random.randn(10,10), 
               xticklabels=string.uppercase[:10], 
               yticklabels=string.lowercase[-10:],
               cmap=green_purple)
fig.savefig('pcolormesh_prettyplotlib_labels_other_cmap_diverging.png')
```



[!image]()


Or if you want your own colormap for positive-only data:

In[24]:

```
import prettyplotlib as ppl
from prettyplotlib import plt
from prettyplotlib import brewer2mpl
import numpy as np
import string

red_purple = brewer2mpl.get_map('RdPu', 'Sequential', 9).mpl_colormap

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.abs(np.random.randn(10,10)),
               xticklabels=string.uppercase[:10], 
               yticklabels=string.lowercase[-10:],
               cmap=red_purple)
fig.savefig('pcolormesh_prettyplotlib_labels_other_cmap_sequential.png')
```



[!image]()


Plus, this will take the usual parameters of `pcolormesh` like if you want to
rescale your data to log-scale:

    from matplotlib.colors import LogNorm
    ...
    ppl.pcolormesh(..., norm=LogNorm(vmin=x.min().min(), vmax=x.max().max()))

In[23]:

```
import prettyplotlib as ppl
from prettyplotlib import plt
from prettyplotlib import brewer2mpl
import numpy as np
import string
from matplotlib.colors import LogNorm

red_purple = brewer2mpl.get_map('RdPu', 'Sequential', 9).mpl_colormap

fig, ax = plt.subplots(1)

np.random.seed(10)

x = np.abs(np.random.randn(10,10))
ppl.pcolormesh(fig, ax, x,
               xticklabels=string.uppercase[:10], 
               yticklabels=string.lowercase[-10:],
               cmap=red_purple, 
               norm=LogNorm(vmin=x.min().min(), vmax=x.max().max()))
fig.savefig('pcolormesh_prettyplotlib_labels_lognorm.png')
```



[!image]()


And now you can easily make beautiful heatmaps!


# `prettyplotlib.scatter`: A motivating example

The default `matplotlib` color cycle is not pretty to look at ... It was taken
from MATLAB's color cycle.

Need to do the `matplotlib` example first because `prettyplotlib` changes the
default color cycle to a nicer one, from
[ColorBrewer](http://bl.ocks.org/mbostock/5577023)'s Set2. What's even worse is
that if you just do a `scatter` plot, then it doesn't cycle at all...

In[1]:

```
import matplotlib.pyplot as mpl_plt
# Set the random seed for consistency
np.random.seed(12)

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    ax.scatter(x, y, label=str(i))
ax.legend()
    
ax.set_title('prettyplotlib `scatter` example\nshowing default matplotlib `scatter`')
fig.savefig('scatter_matplotlib_default.png')
```



[!image]()


## Before `prettyplotlib`: how to make nice plots

Now I'm going to take you through ALL the steps I used to take to make nice
looking plots.



First, change the colors with `brewer2mpl`:

    # Get "Set2" colors from ColorBrewer (all colorbrewer scales:
http://bl.ocks.org/mbostock/5577023)
    set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors
    ...
    color = set2[i]
    ax.scatter(x, y, label=str(i), facecolor=color)

In[2]:

```
import matplotlib.pyplot as mpl_plt
import brewer2mpl

# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors

# Set the random seed for consistency
np.random.seed(12)

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    color = set2[i]
    ax.scatter(x, y, label=str(i), color=color)
    
fig.savefig('scatter_matplotlib_improved_01_changed_colors.png')
```



[!image]()


This looks nice, almost like an impressionist painting, but it's still hard to
see overlaps here. So let's fill the symbols with `0.5` opacity using
`alpha=0.5`.

    ax.scatter(x, y, label=str(i), color=color, alpha=0.5)

In[3]:

```
import matplotlib.pyplot as mpl_plt
import brewer2mpl

# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors

# Set the random seed for consistency
np.random.seed(12)

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    color = set2[i]
    ax.scatter(x, y, label=str(i), color=color, alpha=0.5)
    
fig.savefig('scatter_matplotlib_improved_02_added_alpha.png')
```



[!image]()


This is still pretty lovely and impressionist-y but I still didn't like that it
was hard to see when the dots overlapped. So let's add a black outline, and
specify that `color` is just the `facecolor`:

    ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor='black',
facecolor=color)

In[4]:

```
import matplotlib.pyplot as mpl_plt
import brewer2mpl

# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors

# Set the random seed for consistency
np.random.seed(12)

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    color = set2[i]
    ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor='black', facecolor=color)
    
fig.savefig('scatter_matplotlib_improved_03_added_outline.png')
```



[!image]()


Ack, but those lines are too thick ... let's think them down to `linewidth=0.15`

    ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor='black',
facecolor=color, linewidth=0.15)

In[5]:

```
import matplotlib.pyplot as mpl_plt
import brewer2mpl

# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors

# Set the random seed for consistency
np.random.seed(12)

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    color = set2[i]
    ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor='black', facecolor=color, linewidth=0.15)
fig.savefig('scatter_matplotlib_improved_04_thinned_outline.png')
```



[!image]()


*Now* we're getting somewhere. This looks very lovely. Don't you want to just
cuddle up with that cute plot?

What are those top and right axes lines really doing for us? They're boxing the
data in, but we can do that with our eyes from the other axis lines. So let's
remove the top and right axis lines using `ax.spines`:

    # Remove top and right axes lines ("spines")
    spines_to_remove = ['top', 'right']
    for spine in spines_to_remove:
        ax.spines[spine].set_visible(False)

In[6]:

```
import matplotlib.pyplot as mpl_plt
import brewer2mpl

# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors

# Set the random seed for consistency
np.random.seed(12)

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    color = set2[i]
    ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor='black', facecolor=color, linewidth=0.15)

# Remove top and right axes lines ("spines")
spines_to_remove = ['top', 'right']
for spine in spines_to_remove:
    ax.spines[spine].set_visible(False)
fig.savefig('scatter_matplotlib_improved_05_removed_top_right_spines.png')
```



[!image]()


Oops, but we still have the ticks on the top and right axes. We'll need to get
rid of them. Actually, why don't we just get rid of all ticks altogether? We can
tell by the position of the number where it indicates, so we don't need an
additional tick.

    # Get rid of ticks. The position of the numbers is informative enough of
    # the position of the value.
    ax.xaxis.set_ticks_position('none')
    ax.yaxis.set_ticks_position('none')

In[7]:

```
import matplotlib.pyplot as mpl_plt
import brewer2mpl

# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors

# Set the random seed for consistency
np.random.seed(12)

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    color = set2[i]
    ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor='black', facecolor=color, linewidth=0.15)

# Remove top and right axes lines ("spines")
spines_to_remove = ['top', 'right']
for spine in spines_to_remove:
    ax.spines[spine].set_visible(False)

# Get rid of ticks. The position of the numbers is informative enough of
# the position of the value.
ax.xaxis.set_ticks_position('none')
ax.yaxis.set_ticks_position('none')
fig.savefig('scatter_matplotlib_improved_06_removed_ticks.png')
```



[!image]()


Ahh, much better. But we won't stop there. Now we'll tweak the remaining pieces
of the figure. For the rest of the spines, let's thin the line down to `0.5`
points instead of the default `1.0` points. Also, we'll change it from pure
black to a slightly lighter dark grey. Here they are side by side:

In[8]:

```
fig, axes = plt.subplots(2)
axes[0].set_axis_bgcolor('black')
axes[1].set_axis_bgcolor('#262626')
```



[!image]()


So not a *huge* difference, and the dark grey still looks pretty black, but it's
[a little more pleasant on the eyes](http://ianstormtaylor.com/design-tip-never-
use-black/) to use a dark grey instead of black. There's very few things in
nature that are truly black. Just look at shadows! They're just dark grey, or
blue, or red or purple. But I digress. Back to plotting libraries...

To change the $x$-axis and $y$-axis line colors, and the outlines of the scatter
sybmols from black to dark grey, we'll do:

    # For remaining spines, thin out their line and change the black to a
slightly off-black dark grey
    almost_black = '#262626'
    ...
        ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor='black',
facecolor=color, linewidth=0.15)`
    ...
    spines_to_keep = ['bottom', 'left']
    for spine in spines_to_keep:
        ax.spines[spine].set_linewidth(0.5)
        ax.spines[spine].set_color(almost_black)

In[9]:

```
import matplotlib.pyplot as mpl_plt
import brewer2mpl

# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors

# Set the random seed for consistency
np.random.seed(12)

# Save a nice dark grey as a variable
almost_black = '#262626'

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    color = set2[i]
    ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor=almost_black, facecolor=color, linewidth=0.15)

# Remove top and right axes lines ("spines")
spines_to_remove = ['top', 'right']
for spine in spines_to_remove:
    ax.spines[spine].set_visible(False)

# Get rid of ticks. The position of the numbers is informative enough of
# the position of the value.
ax.xaxis.set_ticks_position('none')
ax.yaxis.set_ticks_position('none')

# For remaining spines, thin out their line and change the black to a slightly off-black dark grey
spines_to_keep = ['bottom', 'left']
for spine in spines_to_keep:
    ax.spines[spine].set_linewidth(0.5)
    ax.spines[spine].set_color(almost_black)
fig.savefig('scatter_matplotlib_improved_07_axis_black_to_almost_black.png')
```



[!image]()


This is nice. But if you look closely, the tick labels are still black :(  We
have to change them separately, using

    # Change the labels to the off-black
    ax.xaxis.label.set_color(almost_black)
    ax.yaxis.label.set_color(almost_black)

And while we're at it, let's add a title and make it dark grey too.

    # Change the axis title to off-black
    ax.title.set_color(almost_black)

    ax.set_title('prettyplotlib `scatter` example\nshowing improved matplotlib
`scatter`')

In[10]:

```
import matplotlib.pyplot as mpl_plt
import brewer2mpl

# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors

# Set the random seed for consistency
np.random.seed(12)

# Save a nice dark grey as a variable
almost_black = '#262626'

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    color = set2[i]
    ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor=almost_black, facecolor=color, linewidth=0.15)

# Remove top and right axes lines ("spines")
spines_to_remove = ['top', 'right']
for spine in spines_to_remove:
    ax.spines[spine].set_visible(False)

# Get rid of ticks. The position of the numbers is informative enough of
# the position of the value.
ax.xaxis.set_ticks_position('none')
ax.yaxis.set_ticks_position('none')

# For remaining spines, thin out their line and change the black to a slightly off-black dark grey
spines_to_keep = ['bottom', 'left']
for spine in spines_to_keep:
    ax.spines[spine].set_linewidth(0.5)
    ax.spines[spine].set_color(almost_black)

# Change the labels to the off-black
ax.xaxis.label.set_color(almost_black)
ax.yaxis.label.set_color(almost_black)

# Change the axis title to off-black
ax.title.set_color(almost_black)

ax.set_title('prettyplotlib `scatter` example\nshowing improved matplotlib `scatter`')
fig.savefig('scatter_matplotlib_improved_08_labels_black_to_almost_black.png')
```



[!image]()


If you remember in the original example, we also had an axis legend, using

    ax.legend()

In[11]:

```
import matplotlib.pyplot as mpl_plt
import brewer2mpl

# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors

# Set the random seed for consistency
np.random.seed(12)

# Save a nice dark grey as a variable
almost_black = '#262626'

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    color = set2[i]
    ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor=almost_black, facecolor=color, linewidth=0.15)

# Remove top and right axes lines ("spines")
spines_to_remove = ['top', 'right']
for spine in spines_to_remove:
    ax.spines[spine].set_visible(False)

# Get rid of ticks. The position of the numbers is informative enough of
# the position of the value.
ax.xaxis.set_ticks_position('none')
ax.yaxis.set_ticks_position('none')

# For remaining spines, thin out their line and change the black to a slightly off-black dark grey
almost_black = '#262626'
spines_to_keep = ['bottom', 'left']
for spine in spines_to_keep:
    ax.spines[spine].set_linewidth(0.5)
    ax.spines[spine].set_color(almost_black)

# Change the labels to the off-black
ax.xaxis.label.set_color(almost_black)
ax.yaxis.label.set_color(almost_black)

# Change the axis title to off-black
ax.title.set_color(almost_black)

ax.legend()
    
ax.set_title('prettyplotlib `scatter` example\nshowing improved matplotlib `scatter`')
fig.savefig('scatter_matplotlib_improved_09_ugly_legend.png')
```



[!image]()


There are many things I don't like about this legend.

1. First of all, why does it have such a thick border line? What does that
really add to our interpretation of the legend? The black line is so thick that
it distracts from what we're trying to portray - which label goes with which
color.
2. Why does it show three points? Does this legend think I'm dumb and can't
figure out which symbol goes with which label after one iteration, so it does it
three times?
3. Finally, the legend labels are pure black. Maybe you notice it too, after
comparing to $x$-axis and $y$-axis lines and labels.

We'll accomplish these three things using this code:

    # Remove the line around the legend box, and instead fill it with a light
grey
    # Also only use one point for the scatterplot legend because the user will
    # get the idea after just one, they don't need three.
    light_grey = np.array([float(248)/float(255)]*3)
    legend = ax.legend(frameon=True, scatterpoints=1, fontcolor=almost_black)
    rect = legend.get_frame()
    rect.set_facecolor(light_grey)
    rect.set_linewidth(0.0)

    # Change the legend label colors to almost black, too
    texts = legend.texts
    for t in texts:
        t.set_color(almost_black)

In[12]:

```
import matplotlib.pyplot as mpl_plt
import brewer2mpl

# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors

# Set the random seed for consistency
np.random.seed(12)

# Save a nice dark grey as a variable
almost_black = '#262626'

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    color = set2[i]
    ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor=almost_black, facecolor=color, linewidth=0.15)

# Remove top and right axes lines ("spines")
spines_to_remove = ['top', 'right']
for spine in spines_to_remove:
    ax.spines[spine].set_visible(False)

# Get rid of ticks. The position of the numbers is informative enough of
# the position of the value.
ax.xaxis.set_ticks_position('none')
ax.yaxis.set_ticks_position('none')

# For remaining spines, thin out their line and change the black to a slightly off-black dark grey
almost_black = '#262626'
spines_to_keep = ['bottom', 'left']
for spine in spines_to_keep:
    ax.spines[spine].set_linewidth(0.5)
    ax.spines[spine].set_color(almost_black)

# Change the labels to the off-black
ax.xaxis.label.set_color(almost_black)
ax.yaxis.label.set_color(almost_black)

# Change the axis title to off-black
ax.title.set_color(almost_black)

# Remove the line around the legend box, and instead fill it with a light grey
# Also only use one point for the scatterplot legend because the user will 
# get the idea after just one, they don't need three.
light_grey = np.array([float(248)/float(255)]*3)
legend = ax.legend(frameon=True, scatterpoints=1)
rect = legend.get_frame()
rect.set_facecolor(light_grey)
rect.set_linewidth(0.0)

# Change the legend label colors to almost black, too
texts = legend.texts
for t in texts:
    t.set_color(almost_black)

    
ax.set_title('prettyplotlib `scatter` example\nshowing improved matplotlib `scatter`')
fig.savefig('scatter_matplotlib_improved_10_pretty_legend.png')
```



[!image]()


Aaaaaaaaaaand I got tired of doing all those steps, EVERY time. So I wrote
[`prettyplotlib`](http://github.com/olgabot/prettyplotlib). Here's an
illustratitive example of how awesome `prettyplotlib` is, and how it will save
all the time you spent agonizing over making your `matplotlib` plots beautiful.

In[13]:

```
import prettyplotlib as ppl

# This is "import matplotlib.pyplot as plt" from the prettyplotlib library
from prettyplotlib import plt

# This is "import matplotlib as mpl" from the prettyplotlib library
from prettyplotlib import mpl

# Set the random seed for consistency
np.random.seed(12)

fig, ax = plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    ppl.scatter(ax, x, y, label=str(i))
    
ppl.legend(ax)
    
ax.set_title('prettyplotlib `scatter` example\nshowing default color cycle and scatter params')
fig.savefig('scatter_prettyplotlib_default.png')
```



[!image]()


The only commands that were different from the very first example with
matplotlib are:

    ppl.scatter(ax, x, y, label=str(i), facecolor='none')

instead of:

    ax.scatter(x, y, label=str(i))

And a different legend command:

    ppl.legend(ax)

instead of:

    ax.legend()

If you ***really*** want to get the original matplotlib style back in
prettyplotlib, you can do:

In[2]:

```
import prettyplotlib as ppl
from prettyplotlib import plt
from prettyplotlib import mpl
from prettyplotlib import brewer2mpl

# Set the random seed for consistency
np.random.seed(12)

fig, ax = plt.subplots(1)

#mpl.rcParams['axis.color_cycle'] = ['blue']

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    ax.scatter(x, y, label=str(i), facecolor='blue', edgecolor='black', linewidth=1)
    
# Get back the top and right axes lines ("spines")
spines_to_remove = ['top', 'right']
for spine in spines_to_remove:
    ax.spines[spine].set_visible(True)
    
# Get back the ticks. The position of the numbers is informative enough of
# the position of the value.
ax.xaxis.set_ticks_position('both')
ax.yaxis.set_ticks_position('both')

# For all the spines, make their line thicker and return them to be black
all_spines = ['top', 'left', 'bottom', 'right']
for spine in all_spines:
    ax.spines[spine].set_linewidth(1.0)
    ax.spines[spine].set_color('black')

# Change the labels back to black
ax.xaxis.label.set_color('black')
ax.yaxis.label.set_color('black')

# Change the axis title also back to black
ax.title.set_color('black')

# Remove the line around the legend box, and instead fill it with a light grey
# Also only use one point for the scatterplot legend because the user will 
# get the idea after just one, they don't need three.
ax.legend()
    
ax.set_title('prettyplotlib `scatter` example\nrevert everything back to default matplotlib parameters')
fig.savefig('scatter_prettyplotlib_back_to_matplotlib_default.png')
```



[!image]()



[!image]()


Notice that the default calls of `ax.scatter` and `ax.legend` do the usual
thing. This is important, because for `prettyplotlib` to work, you'll need to
use a syntax that's different from the usual `matplotlib` one:  `ppl.scatter(ax,
x, y...)` instead of `ax.scatter(x, y, ...)`


## That's all, folks!

That's my introduction to `prettyplotlib` and why you need it. There are similar
examples for the other functions, but this one for `ppl.scatter` is the most
extensive.

README.md
[![Build Status](https://travis-ci.org/olgabot/prettyplotlib.png?branch=master)](https://travis-ci.org/olgabot/prettyplotlib)

prettyplotlib
=============

Python matplotlib-enhancer library which painlessly creates beautiful default `matplotlib`
 plots. Inspired by [Edward Tufte](http://www.edwardtufte.com/tufte/)'s work on information design and [Cynthia Brewer](http://www.personal.psu.edu/cab38/)'s work on [color perception](http://colorbrewer2.org/).

I truly believe that scientific progress is impeded when improper data visualizations are used. I spent a lot of time tweaking my figures to make them more understandable, and realized the scientific world could be a better place if the default parameters for plotting libraries followed recent advances in information design research. And thus `prettyplotlib` was born.

Requirements:

* [`matplotlib`](http://matplotlib.org/). Can be installed via `pip install matplotlib` or `easy_install matplotlib`
* [`brewer2mpl`](https://github.com/jiffyclub/brewer2mpl). Can be installed via `pip install brewer2mpl` or `easy_install brewer2mpl`

## Comparison to `matplotlib`

<table>
  <tr height="207" valign="top">
    <td><code>matplotlib</code> default <code>plot</code><br><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/plot_matplotlib_default.png" height="202"></td>
    <td><code>prettyplotlib</code> default <code>plot</code><br><a href=https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#plot-lines-eg-time-series-with-a-legend"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/plot_prettyplotlib_default.png" height="202"></a></td>
  </tr>
  <tr height="207" valign="top">
    <td><code>matplotlib</code> default <code>scatter</code><br><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_matplotlib_default.png" height="202"></td>
    <td><code>prettyplotlib</code> default <code>scatter</code><br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#scatter-points"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_prettyplotlib_default.png" height="202"></a></td>
  </tr>
  <tr height="207" valign="top">
    <td><code>matplotlib</code> default <code>bar</code><br><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_matplotlib_default.png" height="202"></td>
    <td><code>prettyplotlib</code> default <code>bar</code><br><a href=https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#bar><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_prettyplotlib_default.png" height="202"></a></td>
  </tr>
  <tr height="207" valign="top">
    <td><code>matplotlib</code> default <code>hist</code><br><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/hist_matplotlib_default.png" height="202"></td>
    <td><code>prettyplotlib</code> default <code>hist</code><br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#hist"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/hist_prettyplotlib_default.png" height="202"></a></td>
</tr>
  <tr height="207" valign="top">
    <td><code>matplotlib</code> default <code>hist</code><br>with grid<br><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/hist_matplotlib_grid.png" height="202"></td>
    <td><code>prettyplotlib</code> default <code>hist</code><br>with grid<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#back-to-matplotlib-style-scatterplots"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/hist_prettyplotlib_grid.png" height="202"></a></td>
</tr>
  <tr height="207" valign="top">
    <td><code>matplotlib</code> default <code>boxplot</code><br><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/boxplot_matplotlib_default.png" height="202"></td>
    <td><code>prettyplotlib</code> default <code>boxplot</code><br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#boxplot"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/boxplot_prettyplotlib_default.png" height="202"></a></td>
  </tr>
<tr height="207" valign="top">
    <td><code>matplotlib</code> default <code>pcolormesh</code><br>positive and negative data<br><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_matplotlib_default.png" height="202"></td>
    <td><code>prettyplotlib</code> default <code>pcolormesh</code><br>positive and negative data<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#pcolormesh-heatmaps"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_default.png" height="202"></a></td>
  </tr>
  </tr>  <tr height="207" valign="top">
    <td><code>matplotlib</code> default <code>pcolormesh</code><br>positive data only<br><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_matplotlib_positive_default.png" height="202"></td>
    <td><code>prettyplotlib</code> default <code>pcolormesh</code><br>positive data only<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#pcolormesh-positive-only-data"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_positive.png" height="202"></a></td>
  </tr>
  </tr>  <tr height="207" valign="top">
    <td><code>matplotlib pcolormesh</code><br> negative-valued data with labels<br><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_matplotlib_negative_labels.png" height="202"></td>
    <td><code>prettyplotlib pcolormesh</code><br> negative-valued data with labels<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#pcolormesh-positive-only-data"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_negative_labels.png" height="202"></a></td>
  </tr>
</table>

### Quotes

_"Dis ain't no **ugly**plotlib"_ - Anonymous

prettyplotlib
=============

Python matplotlib-enhancer library which painlessly creates beautiful
default ``matplotlib`` plots. Inspired by `Edward
Tufte <http://www.edwardtufte.com/tufte/>`__'s work on information
design and `Cynthia Brewer <http://www.personal.psu.edu/cab38/>`__'s
work on `color perception <http://colorbrewer2.org/>`__.

I truly believe that scientific progress is impeded when improper data
visualizations are used. I spent a lot of time tweaking my figures to
make them more understandable, and realized the scientific world could
be a better place if the default parameters for plotting libraries
followed recent advances in information design research. And thus
``prettyplotlib`` was born.

Requirements:

-  `matplotlib <http://matplotlib.org/>`__. Can be installed via
   ``pip install matplotlib`` or ``easy_install matplotlib``
-  `brewer2mpl <https://github.com/jiffyclub/brewer2mpl>`__. Can be
   installed via ``pip install brewer2mpl`` or
   ``easy_install brewer2mpl``

Comparison to ``matplotlib``
----------------------------
.. image:: https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/plot_matplotlib_default.png
:width: 45%
.. image:: https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/plot_prettyplotlib_default.png
:target: https://github.com/olgabot/prettyplotlib/wiki/exampleswith-code#plot-lines-eg-time-series-with-a-legend"
   :width: 45%

.. image:: https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_matplotlib_default.png
:width: 45%
.. image:: https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_prettyplotlib_default.png
:target: https://github.com/olgabot/prettyplotlib/wiki/exampleswith-code#scatter-points
   :width: 45%

.. image:: https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_matplotlib_default.png
:width: 45%
.. image:: https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_prettyplotlib_default.png
:target: https://github.com/olgabot/prettyplotlib/wiki/exampleswith-code#bar
   :width: 45%

.. image:: https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/hist_matplotlib_default.png
:width: 45%
.. image:: https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/hist_prettyplotlib_default.png
:target: https://github.com/olgabot/prettyplotlib/wiki/exampleswith-code#hist
   :width: 45%

.. image:: https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/hist_matplotlib_grid.png
:width: 45%
.. image:: https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/hist_prettyplotlib_grid.png
:target: https://github.com/olgabot/prettyplotlib/wiki/exampleswith-code#back-to-matplotlib-style-scatterplots
   :width: 45%

.. image:: https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/boxplot_matplotlib_default.png
:width: 45%
.. image:: https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/boxplot_prettyplotlib_default.png
:target: https://github.com/olgabot/prettyplotlib/wiki/exampleswith-code#boxplot
   :width: 45%

.. image:: https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_matplotlib_default.png
:width: 45%
.. image:: https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_default.png
:target: https://github.com/olgabot/prettyplotlib/wiki/exampleswith-code#pcolormesh-heatmaps
   :width: 45%

.. image:: https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_matplotlib_positive_default.png
:width: 45%
.. image:: https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_positive.png
:target: https://github.com/olgabot/prettyplotlib/wiki/exampleswith-code#pcolormesh-positive-only-data
   :width: 45%

.. image:: https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_matplotlib_negative_labels.png
:width: 45%
.. image:: https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_negative_labels.png
:target: https://github.com/olgabot/prettyplotlib/wiki/exampleswith-code#pcolormesh-positive-only-data
   :width: 45%

Quotes
~~~~~~

*"Dis ain't no **ugly**\ plotlib"* - Anonymous

.. |Build Status| image:: https://travis-ci.org/olgabot/prettyplotlib.png?branch=master
:target: https://travis-ci.org/olgabot/prettyplotlib
The basic idea for all of these plots is that you should be able to do `ppl.{plot_command}(ax, x, y)` instead of `plt.{plot_command}(x, y)`. I haven't figured yet how to completely inherit `Axes` and such from `matplotlib`, because it is a huge, very complicated piece of code. But hopefully that functionality will be in future releases :)

# `plot` (lines, e.g. time series) with a `legend`

For data where the `x` and `y` are ordered, like by time or distance, use `ppl.plot`, similar to how you'd use `plt.plot` or `ax.plot` from `matplotlib`. Except instead of `plt.plot(x, y)` or `ax.plot(x, y)`, do `ppl.plot(ax, x, y)`. 

```python
import prettyplotlib as ppl
import numpy as np

# prettyplotlib imports 
import matplotlib.pyplot as plt
import matplotlib as mpl
from prettyplotlib import brewer2mpl

# Set the random seed for consistency
np.random.seed(12)

fig, ax = plt.subplots(1)

# Show the whole color range
for i in range(8):
    y = np.random.normal(size=1000).cumsum()
    x = np.arange(1000)

    # For now, you need to specify both x and y :(
    # Still figuring out how to specify just one
    ppl.plot(ax, x, y, label=str(i), linewidth=0.75)
    
ppl.legend(ax)

fig.savefig('plot_prettyplotlib_default.png')
```
![Default line plotting](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/plot_prettyplotlib_default.png)


# `legend` parameters

If you want to move the legend to somewhere else, use the arguments you'd normally use for `legend()`, e.g. `loc='lower right', ncol=4`:

```python
ppl.legend(ax, loc='lower left', ncol=4)
```

The full code is here:

```python
import prettyplotlib as ppl
import numpy as np

# prettyplotlib imports 
import matplotlib.pyplot as plt
import matplotlib as mpl
from prettyplotlib import brewer2mpl

# Set the random seed for consistency
np.random.seed(12)

fig, ax = plt.subplots(1)

# Show the whole color range
for i in range(8):
    y = np.random.normal(size=1000).cumsum()
    x = np.arange(1000)

    # For now, you need to specify both x and y :(
    # Still figuring out how to specify just one
    ppl.plot(ax, x, y, label=str(i))
    
ppl.legend(ax, loc='lower left', ncol=4)

fig.savefig('plot_prettyplotlib_legend_lower_left.png')
```
![Legend parameters](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/plot_prettyplotlib_legend_lower_left.png)

# `fill_between` (area between two lines)

This is for when you want to show the area between two lines,
like you have timeseries of two stocks and want to show their difference.

```python
import prettyplotlib as ppl

# prettyplotlib imports
import matplotlib.pyplot as plt
import matplotlib as mpl
from prettyplotlib import brewer2mpl

# Set the random seed for consistency
np.random.seed(12)

fig, ax = plt.subplots(1)

# Show the whole color range
for i in range(8):
    y1 = np.random.normal(size=1000).cumsum()
    y2 = np.random.normal(size=1000).cumsum()
    x = np.arange(1000)

    ppl.fill_between(x, y1, y2, label=str(i))

ppl.legend()

fig.savefig('fill_between_prettyplotlib_default.png')
```
![fill_between](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/fill_between_prettyplotlib_default.png)

# `fill_betweenx` (area between two lines, fill between x values)

This is for when you want to show the area between two lines,
like you have timeseries of two stocks and want to show their difference.

```python
import prettyplotlib as ppl

# prettyplotlib imports
import matplotlib.pyplot as plt
import matplotlib as mpl
from prettyplotlib import brewer2mpl

# Set the random seed for consistency
np.random.seed(12)

fig, ax = plt.subplots(1)

# Show the whole color range
for i in range(8):
    y1 = np.random.normal(size=1000).cumsum()
    y2 = np.random.normal(size=1000).cumsum()
    x = np.arange(1000)

    ppl.fill_betweenx(x, y1, y2, label=str(i))

ax = ppl.legend()

fig.savefig('fill_between_prettyplotlib_default.png')
```
![fill_betweenx](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/fill_betweenx_prettyplotlib_default.png)

# `scatter` (points)

This is for less structured data than `plot`, like if you have two samples X and Y, and gene expression for each one, and you want to see how the expression of the same gene is for the two samples. :)

```python
import prettyplotlib as ppl
import numpy as np

# This is "import matplotlib.pyplot as plt" from the prettyplotlib library
import matplotlib.pyplot as plt

# This is "import matplotlib as mpl" from the prettyplotlib library
import matplotlib as mpl

# Set the random seed for consistency
np.random.seed(12)

fig, ax = plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    ppl.scatter(ax, x, y, label=str(i))
    
ppl.legend(ax)
    
ax.set_title('prettyplotlib `scatter` example\nshowing default color cycle and scatter params')
fig.savefig('scatter_prettyplotlib_default.png')
```
![Default scatter plot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_prettyplotlib_default.png)

## Back to `matplotlib`-style scatterplots

If you ***really*** want to change all the parameters I worked so hard on, you can:

```python
import prettyplotlib as ppl
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
from prettyplotlib import brewer2mpl

# Set the random seed for consistency
np.random.seed(12)

fig, ax = plt.subplots(1)

#mpl.rcParams['axis.color_cycle'] = ['blue']

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    ax.scatter(x, y, label=str(i), facecolor='blue', edgecolor='black', linewidth=1)
    
# Get back the top and right axes lines ("spines")
spines_to_remove = ['top', 'right']
for spine in spines_to_remove:
    ax.spines[spine].set_visible(True)
    
# Get back the ticks. The position of the numbers is informative enough of
# the position of the value.
ax.xaxis.set_ticks_position('both')
ax.yaxis.set_ticks_position('both')

# For all the spines, make their line thicker and return them to be black
all_spines = ['top', 'left', 'bottom', 'right']
for spine in all_spines:
    ax.spines[spine].set_linewidth(1.0)
    ax.spines[spine].set_color('black')

# Change the labels back to black
ax.xaxis.label.set_color('black')
ax.yaxis.label.set_color('black')

# Change the axis title also back to black
ax.title.set_color('black')

# Remove the line around the legend box, and instead fill it with a light grey
# Also only use one point for the scatterplot legend because the user will 
# get the idea after just one, they don't need three.
ax.legend()
    
ax.set_title('prettyplotlib `scatter` example\nshowing default color cycle and scatter params')
fig.savefig('scatter_prettyplotlib_back_to_matplotlib_default.png')
```

![Default scatter plot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_prettyplotlib_back_to_matplotlib_default.png)

# `bar`

This plot is great for categorical data, unrelated quantities such as number of cats, oranges, and computers per household.

```python
import prettyplotlib as ppl
import numpy as np
import matplotlib.pyplot as plt

fig, ax = plt.subplots(1)

np.random.seed(14)

ppl.bar(ax, np.arange(10), np.abs(np.random.randn(10)))
fig.savefig('bar_prettyplotlib_default.png')
```

![Default bar plot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_prettyplotlib_default.png)

## `bar` with a white grid to "erase" and yet add information!

If you supply the command `grid="y"`, where the `"y"` indicates I want the grid coming out of the y-axis at certain `y=...` values, aka perpendicular to the y-axis, you will get a white grid drawn over your data. It's almost like adding ticks, but since it's "erasing", it increases the data-ink ratio.

```python
import prettyplotlib as ppl
import numpy as np
import matplotlib.pyplot as plt

fig, ax = plt.subplots(1)

np.random.seed(14)

# 'y' for make a grid based on where the major ticks are on the y-axis
ppl.bar(ax, np.arange(10), np.abs(np.random.randn(10)), grid='y')
fig.savefig('bar_prettyplotlib_grid.png')
```

![Bar plot with white grid](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_prettyplotlib_grid.png)

## `bar` with value annotation on each bar

If you say `annotate=True` in the `ppl.bar` command, then the value of the number on top of the bar plot will be added.

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
import numpy as np
import string

fig, ax = plt.subplots(1)
np.random.seed(14)
n = 10
ppl.bar(ax, np.arange(n), np.abs(np.random.randn(n)), annotate=True, grid='y')
fig.savefig('bar_prettyplotlib_grid_annotated.png')
```
![Bar plot with white grid](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_prettyplotlib_grid_annotated.png)


### `bar` correctly annotates negative values

If you happen to have negative values in your bar plot, the annotation on them will correctly appear underneath them. Also, the x-axis line will be moved up to the `y=0` mark, instead of staying at the bottom.

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt

fig, axes = plt.subplots(nrows=4, figsize=(6,8))

# This is the order we want to plot them, too
nucleotides = ['C', 'G', 'A', 'T']

colors = {nucleotide: ppl.set2[i] for i, nucleotide in enumerate(nucleotides)}

entire_strand = {'C':427419, 'G':413241, 'A':491488, 'T':491363}
reverse_half = {'C': 219518, 'G':201634, 'A':243963, 'T':246641}
forward_half = {'C': 207901, 'G':211607, 'A':247525, 'T':244722}
skew = {nucleotide: forward_half[nucleotide] - reverse_half[nucleotide] for nucleotide in nucleotides}

strands = {'Entire strand':entire_strand, 
            'Reverse half-strand':reverse_half, 
            'Forward half-strand':forward_half,
            'Forward - Reverse':skew}

# The order that we want to plot the strand data in:
strand_names_ordered = ['Entire strand', 'Forward half-strand', 'Reverse half-strand', 'Forward - Reverse']

left = range(len(nucleotides))
for ax, strand_name in zip(axes, strand_names_ordered):
    strand_data = strands[strand_name]
    ppl.bar(ax, left=left, 
            height=[strand_data[nucleotide] for nucleotide in nucleotides], 
            annotate=True, 
            xticklabels=nucleotides, 
            grid='y', 
            color=[colors[nucleotide] for nucleotide in nucleotides])
    ax.set_title(strand_name)
    
# Tell matplotlib to smartly lay out our figure
fig.tight_layout()
```
![Bar plot with white grid](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_nucleotide_counts.png)




### `bar` with arbitrary annotation

If you don't like the way `prettyplotlib` formats the numbers on top of the bars, or you just want to label with something else, you can supply your own numbers or strings by giving an iterable (like a list of strings or numbers) to `annotate`:

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
import numpy as np
import string

fig, ax = plt.subplots(1)
np.random.seed(14)
n = 10
ppl.bar(ax, np.arange(n), np.abs(np.random.randn(n)),
        annotate=range(n,2*n), grid='y', xticklabels=string.uppercase[:n])
fig.savefig('bar_prettyplotlib_grid_annotated_user_labeled.png')
```
![Bar plot with white grid, with arbitrary annotation](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_prettyplotlib_grid_annotated_user.png)

## `bar` with each bar labeled on x-axis

If you supply `xticklabels` as an argument to `plt.bar`, this will label each bar with this xlabel.

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
import numpy as np
import string

fig, ax = plt.subplots(1)
np.random.seed(14)
n = 10
ppl.bar(ax, np.arange(n), np.abs(np.random.randn(n)), annotate=True, xticklabels=string.uppercase[:n], grid='y')
fig.savefig('bar_prettyplotlib_grid_annotated_labeled.png')
```

![Bar plot with white grid, x-axis labeled and each bar annotated](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_prettyplotlib_grid_annotated_labeled.png)


# `hist`

If you have a large number of values and you're curious about the distribution of values within the data, `hist` is the function for you!

Right now, sideways histograms (with `orientation=horizontal`) aren't working in my `matplotlib` so they are untested.

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
import numpy as np

np.random.seed(12)

fig, ax = plt.subplots(1)

ppl.hist(ax, np.random.randn(1000))
fig.savefig('hist_prettyplotlib_default.png')
```
![Histogram](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/hist_prettyplotlib_default.png)

## `hist` with a white grid to "erase" and yet add information!

Like with `bar`, you can add a white grid with `grid="y"`, where the `"y"` indicates I want the grid coming out of the y-axis at certain `y=...` values, aka perpendicular to the y-axis.

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
import numpy as np

np.random.seed(12)

fig, ax = plt.subplots(1)

# 'y' for the 'y' axis. Could also add a grid over the 'x' axis.
ppl.hist(ax, np.random.randn(1000), grid='y')
fig.savefig('hist_prettyplotlib_grid.png')
```
![Histogram with white grid](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/hist_prettyplotlib_grid.png)

# `boxplot`

If you have several things you'd like to compare distributions with, the `boxplot` can be very nice.

```python
import prettyplotlib as ppl
import numpy as np
import matplotlib as mpl

np.random.seed(10)

data = np.random.randn(8, 4)
labels = ['A', 'B', 'C', 'D']

fig, ax = plt.subplots()
ppl.boxplot(ax, data, xticklabels=labels)
fig.savefig('boxplot_prettyplotlib_default.png')
```
![Boxplot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/boxplot_prettyplotlib_default.png)

# `pcolormesh` (heatmaps)

Because `matplotlib` took the color scheme from MATLAB, it inherited the ubiquitous and every-distorting rainbow color map:

![Boxplot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_matplotlib_default.png)

How can you tell what values are positive and negative, at a glance? it's impossible without heavy scrutiny and switching back and forth between the figure and the colorbar. Indeed, there have been studies stating that [*"the rainbow colormap is universally inferior to all other colormaps"*](http://www.jwave.vt.edu/~rkriz/Projects/create_color_table/color_07.pdf)

So `prettyplotlib` makes a beautiful default colormap. Notice that this syntax is different from all others, because you must supply `fig` as well to plot the `colormap`, the scale which shows what color corresponds to what value.

```
ppl.pcolormesh(fig, ax, np.random.randn(10,10))
```

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.random.randn(10,10))
fig.savefig('pcolormesh_prettyplotlib_default.png')
```
![Heatmap](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_default.png)


## `pcolormesh`: auto-detect positive/negative/both data

Notice that the above plot has both blue and red colors, and on the colorbar to the right you see there are both positive and negative values. If you have only positive or only negative values, `prettyplotlib` will auto-detect this and adjust the colormap accordingly.

### `pcolormesh`: positive-only data

For positive data, the colors default to red, with larger numbers darker and smaller numbers lighter.

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.abs(np.random.randn(10,10)))
fig.savefig('pcolormesh_prettyplotlib_positive.png')
```
![Heatmap: positive values only](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_positive.png)


### `pcolormesh`: negative-only data

For negative data, the colormap defaults to blues, with more negative (smaller) values darker blue, and larger values (closer to zero) as lighter blue.

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, -np.abs(np.random.randn(10,10)))
fig.savefig('pcolormesh_prettyplotlib_negative.png')
```
![Heatmap: negative values only](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_negative.png)

## `pcolormesh` with labels

It can be a pain in the neck to figure out how to put row and column labels directly onto a `pcolormesh` heatmap. Thankfully, `prettyplotlib` will accept `xticklabels` and `yticklabels` arguments, like this:

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
import numpy as np
import string

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.random.randn(10,10), 
               xticklabels=string.uppercase[:10], 
               yticklabels=string.lowercase[-10:])
fig.savefig('pcolormesh_prettyplotlib_labels.png')
```
![Heatmap: negative values only, with labels](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_labels.png)

## `pcolormesh`: custom colormaps

If you'd like to use your own colormaps, go ahead!

### `pcolormesh`: custom diverging colormaps

If your data has both positive and negative values, a diverging colormap is an excellent choice as it will highlight the differences between positive and negative, and the zero values. The diverging colormap `PRGn` or Purple and Green is pretty nice. I usually use this website to look up the colormaps: [Every Colorbrewer Scale](http://bl.ocks.org/mbostock/5577023)

Just import `brewer2mpl` from `prettyplotlib` and specify your colormap. The main lines to change are:

```python
from prettyplotlib import brewer2mpl
...
green_purple = brewer2mpl.get_map('PRGn', 'diverging', 11).mpl_colormap
...
ppl.pcolormesh(...,
               cmap=green_purple)
```
Here is the full code:
```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
from prettyplotlib import brewer2mpl
import numpy as np
import string

green_purple = brewer2mpl.get_map('PRGn', 'diverging', 11).mpl_colormap

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.random.randn(10,10), 
               xticklabels=string.uppercase[:10], 
               yticklabels=string.lowercase[-10:],
               cmap=green_purple)
fig.savefig('pcolormesh_prettyplotlib_labels_other_cmap_diverging.png')
```
![Heatmap: custom diverging colormap](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_labels_other_cmap_diverging.png)

### `pcolormesh`: custom sequential colormaps

Or, if you have positive-only or negative-only data, a sequential colormap like this Red-Purple one is great. The command is similar to the diverging colormaps:

```python
from prettyplotlib import brewer2mpl
...
red_purple = brewer2mpl.get_map('RdPu', 'Sequential', 9).mpl_colormap
...
ppl.pcolormesh(...,
               cmap=red_purple)
```

Here is the full code.

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
from prettyplotlib import brewer2mpl
import numpy as np
import string

red_purple = brewer2mpl.get_map('RdPu', 'Sequential', 9).mpl_colormap

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.abs(np.random.randn(10,10)),
               xticklabels=string.uppercase[:10], 
               yticklabels=string.lowercase[-10:],
               cmap=red_purple)
fig.savefig('pcolormesh_prettyplotlib_labels_other_cmap_sequential.png')
```

![Heatmap: custom colormap with positive data, sequential colormap](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_labels_other_cmap_sequential.png)

## `pcolormesh`: log scaling

Finally, if you'd like to supply some special commands for `pcolormesh` like log scaling, you can do that too!

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
from prettyplotlib import brewer2mpl
import numpy as np
import string
from matplotlib.colors import LogNorm

red_purple = brewer2mpl.get_map('RdPu', 'Sequential', 9).mpl_colormap

fig, ax = plt.subplots(1)

np.random.seed(10)

x = np.abs(np.random.randn(10,10))
ppl.pcolormesh(fig, ax, x,
               xticklabels=string.uppercase[:10], 
               yticklabels=string.lowercase[-10:],
               cmap=red_purple, 
               norm=LogNorm(vmin=x.min().min(), vmax=x.max().max()))
fig.savefig('pcolormesh_prettyplotlib_labels_lognorm.png')
```
![Heatmap: log-normalized custom colormap with positive data, sequential colormap](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_labels_lognorm.png)


## `pcolormesh`: recenter divergent values

If you have a divergent colormap but you want the white zero value to be
something else, you can supply `center_value` as a keyword argument to
`pcolormesh` to recenter the data.

```python
import prettyplotlib as ppl
import matplotlib.pyplot as plt
from prettyplotlib import brewer2mpl
import numpy as np
import string

green_purple = brewer2mpl.get_map('PRGn', 'diverging', 11).mpl_colormap

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.random.randn(10,10), 
               xticklabels=string.uppercase[:10], 
               yticklabels=string.lowercase[-10:],
               cmap=green_purple, center_value=2)
fig.savefig('pcolormesh_prettyplotlib_labels_other_cmap_diverging_center_value.png')
```
![Heatmap: custom diverging colormap](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_labels_other_cmap_diverging_center_value.png)

And now the 'zero' value is 2! So it's white at 2. Looks like most of the
data is below there..

## `plot`
<table>
  <tr height="207" valign="top">
    <td>Line plots<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#plot-lines-eg-time-series-with-a-legend"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/plot_prettyplotlib_default.png" width="202"></a></td>
    <td>Line plots with modified legend<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#legend-parameters"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/plot_prettyplotlib_legend_lower_left.png" width="202"></a></td>
  </tr>
</table>
## `scatter`
<table>
  <tr height="207" valign="top">
    <td>Scatterplot<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#scatter-points"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_prettyplotlib_default.png" width="202"></a></td>
    <td>Back to matplotlib defaults...<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#back-to-matplotlib-style-scatterplots"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_prettyplotlib_back_to_matplotlib_default.png" width="202"></a></td>
  </tr>
</table>
## `bar`

<table>
  <tr height="207" valign="top">
    <td>Bar plot<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#bar"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_prettyplotlib_default.png" width="202"></a></td>
    <td>Bar plot with white grid<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#bar-with-a-white-grid-to-erase-and-yet-add-information"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_prettyplotlib_grid.png" width="202"></a></td>
    <td>Bar plot with annotation<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#bar-with-value-annotation-on-each-bar"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_prettyplotlib_grid_annotated.png" width="202"></a></td>
    <td>Bar plot with arbitrary annotation<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#bar-with-arbitrary-annotation"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_prettyplotlib_grid_annotated_user_labeled.png" width="202"></a></td>
  </tr>
  <tr height="207" valign="top">
    <td>Annotated bar plot with negative values<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#bar-correctly-annotates-negative-values"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_nucleotide_counts.png" width="202"></a></td>
    <td>Bar plot with labels<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#bar-with-each-bar-labeled-on-x-axis"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/bar_prettyplotlib_grid_annotated_labeled.png" width="202"></a></td>
  </tr>
</table>

## `hist`

If you have a large number of values and you're curious about the distribution of values within the data, `hist` is the function for you!

<table>
  <tr height="207" valign="top">
    <td>Histogram<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#hist"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/hist_prettyplotlib_default.png" width="202"></a></td>
    <td>Histogram with a white grid<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#back-to-matplotlib-style-scatterplots"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/hist_prettyplotlib_grid.png" width="202"></a></td>
  </tr>
</table>


## `boxplot`

If you have several categories, and each category has a distribution you'd like to compare to others, `boxplot` may be a nice way to visualize these distributions and their differences.

<table>
  <tr height="207" valign="top">
    <td>Box plot<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#boxplot"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/boxplot_prettyplotlib_default.png" width="202"></a></td>
  </tr>
</table>

## `pcolormesh`

If you have a 2d matrix and you'd like to visualize which values are larger or smaller than others, a heatmap via `pcolormesh` may be nice.

<table>
  <tr height="207" valign="top">
    <td>Heatmap with both positive and negative values<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#pcolormesh-heatmaps"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_default.png" width="202"></a></td>
    <td>Heatmap with only positive values<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#pcolormesh-positive-only-data"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_positive.png" width="202"></a></td>
    <td>Heatmap with only negative values<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#pcolormesh-negative-only-data"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_negative.png" width="202"></a></td>
    <td>Heatmap with x- and y-labels<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#pcolormesh-with-labels"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_labels.png" width="202"></a></td>
  </tr>
  <tr height="207" valign="top">
    <td>Heatmap with custom colormap<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#pcolormesh-custom-diverging-colormaps"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_labels_other_cmap_diverging.png" width="202"></a></td>
    <td>Positive-only heatmap with custom colormap<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#pcolormesh-custom-sequential-colormaps"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_labels_other_cmap_sequential.png" width="202"></a></td>
    <td>Log-scaled heatmap<br><a href="https://github.com/olgabot/prettyplotlib/wiki/Examples-with-code#pcolormesh-log-scaling"><img src="https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_labels_lognorm.png" width="202"></a></td>
  </tr>
</table>

# `prettyplotlib.scatter`

The default `matplotlib` color cycle is not pretty to look at. What's even worse is
that if you just do a `scatter` plot, then it doesn't cycle at all through any values

```python
import matplotlib.pyplot as mpl_plt
# Set the random seed for consistency
np.random.seed(12)

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    ax.scatter(x, y, label=str(i))
ax.legend()
    
ax.set_title('prettyplotlib `scatter` example\nshowing default matplotlib `scatter`')
fig.savefig('scatter_matplotlib_default.png')
```

![Matplotlib default scatterplot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_matplotlib_default.png)

## Before `prettyplotlib`: how to make nice plots

Now I'm going to take you through ALL the steps I used to take to make nice
looking plots.

First, change the colors with `brewer2mpl`:

```python
# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors
...
color = set2[i]
ax.scatter(x, y, label=str(i), facecolor=color)
```

The full code is,

```python
import matplotlib.pyplot as mpl_plt
import brewer2mpl

# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors

# Set the random seed for consistency
np.random.seed(12)

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    color = set2[i]
    ax.scatter(x, y, label=str(i), color=color)
    
fig.savefig('scatter_matplotlib_improved_01_changed_colors.png')
```

![Matplotlib scatter improved 01: changed colors](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_matplotlib_improved_01_changed_colors.png)


This looks nice, almost like an impressionist painting, but it's still hard to
see overlaps here. So let's fill the symbols with `0.5` opacity using
`alpha=0.5`.

```python
ax.scatter(x, y, label=str(i), color=color, alpha=0.5)
```

The full code is,

```python
import matplotlib.pyplot as mpl_plt
import brewer2mpl

# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors

# Set the random seed for consistency
np.random.seed(12)

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    color = set2[i]
    ax.scatter(x, y, label=str(i), color=color, alpha=0.5)
    
fig.savefig('scatter_matplotlib_improved_02_added_alpha.png')
```
![Matplotlib scatter improved 02: added alpha](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_matplotlib_improved_02_added_alpha.png)

This is still pretty lovely and impressionist-y but I still didn't like that it
was hard to see when the dots overlapped. So let's add a black outline, and
specify that `color` is just the `facecolor`:

```python
ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor='black',
facecolor=color)
```

The full code is,

```python
import matplotlib.pyplot as mpl_plt
import brewer2mpl

# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors

# Set the random seed for consistency
np.random.seed(12)

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    color = set2[i]
    ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor='black', facecolor=color)
    
fig.savefig('scatter_matplotlib_improved_03_added_outline.png')
```

![Matplotlib scatter improved 03: added black outline](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_matplotlib_improved_03_added_outline.png)

Ack, but those lines are too thick ... let's think them down to `linewidth=0.15`

```python
ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor='black',
facecolor=color, linewidth=0.15)
```

The full code is,
```python
import matplotlib.pyplot as mpl_plt
import brewer2mpl

# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors

# Set the random seed for consistency
np.random.seed(12)

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    color = set2[i]
    ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor='black', facecolor=color, linewidth=0.15)
fig.savefig('scatter_matplotlib_improved_04_thinned_outline.png')
```

![Matplotlib scatter improved 04: thinned out black outline](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_matplotlib_improved_04_thinned_outline.png)


*Now* we're getting somewhere. This looks very lovely. Don't you want to just
cuddle up with that cute plot?

What are those top and right axes lines really doing for us? They're boxing the
data in, but we can do that with our eyes from the other axis lines. So let's
remove the top and right axis lines using `ax.spines`:

```python
# Remove top and right axes lines ("spines")
spines_to_remove = ['top', 'right']
for spine in spines_to_remove:
ax.spines[spine].set_visible(False)
```

The full code is,

```python
import matplotlib.pyplot as mpl_plt
import brewer2mpl

# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors

# Set the random seed for consistency
np.random.seed(12)

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    color = set2[i]
    ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor='black', facecolor=color, linewidth=0.15)

# Remove top and right axes lines ("spines")
spines_to_remove = ['top', 'right']
for spine in spines_to_remove:
    ax.spines[spine].set_visible(False)
fig.savefig('scatter_matplotlib_improved_05_removed_top_right_spines.png')
```
![Matplotlib scatter improved 05: removed top and right axis lines](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_matplotlib_improved_05_removed_top_right_spines.png)


Oops, but we still have the ticks on the top and right axes. We'll need to get
rid of them. Actually, why don't we just get rid of all ticks altogether? We can
tell by the position of the number where it indicates, so we don't need an
additional tick.

```python
# Get rid of ticks. The position of the numbers is informative enough of
# the position of the value.
ax.xaxis.set_ticks_position('none')
ax.yaxis.set_ticks_position('none')
```

Here's the full code:
```python
import matplotlib.pyplot as mpl_plt
import brewer2mpl

# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors

# Set the random seed for consistency
np.random.seed(12)

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    color = set2[i]
    ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor='black', facecolor=color, linewidth=0.15)

# Remove top and right axes lines ("spines")
spines_to_remove = ['top', 'right']
for spine in spines_to_remove:
    ax.spines[spine].set_visible(False)

# Get rid of ticks. The position of the numbers is informative enough of
# the position of the value.
ax.xaxis.set_ticks_position('none')
ax.yaxis.set_ticks_position('none')
fig.savefig('scatter_matplotlib_improved_06_removed_ticks.png')
```
![Matplotlib scatter improved 06: removed tick marks](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_matplotlib_improved_06_removed_ticks.png)


Ahh, much better. But we won't stop there. Now we'll tweak the remaining pieces
of the figure. For the rest of the spines, let's thin the line down to `0.5`
points instead of the default `1.0` points. Also, we'll change it from pure
black to a slightly lighter dark grey. Here they are side by side:

```python
fig, axes = plt.subplots(2)
axes[0].set_axis_bgcolor('black')
axes[0].text(0.5, 0.5, 'black', color='white', fontsize=24, va='center', ha='center')
axes[1].set_axis_bgcolor('#262626')
axes[1].text(0.5, 0.5, 'almost black', fontsize=24, color='white', va='center', ha='center')
fig.savefig('black_vs_almost_black.png')
```
![Matplotlib scatter improved 06: removed tick marks](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/black_vs_almost_black.png)

So not a *huge* difference, and the dark grey still looks pretty black, but it's
[a little more pleasant on the eyes](http://ianstormtaylor.com/design-tip-never-use-black/)
to use a dark grey instead of black. There's very few things in
nature that are truly black. Just look at shadows! They're just dark grey, or
blue, or red or purple. But I digress. Back to plotting libraries...

To change the x-axis and y-axis line colors, and the outlines of the scatter
symbols from black to dark grey, we'll do:

```python
# For remaining spines, thin out their line and change the black to a slightly off-black dark grey
almost_black = '#262626'
...
ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor='black', facecolor=color, linewidth=0.15)
...
spines_to_keep = ['bottom', 'left']
for spine in spines_to_keep:
    ax.spines[spine].set_linewidth(0.5)
    ax.spines[spine].set_color(almost_black)
```
The full code is,
```python
import matplotlib.pyplot as mpl_plt
import brewer2mpl

# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors

# Set the random seed for consistency
np.random.seed(12)

# Save a nice dark grey as a variable
almost_black = '#262626'

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    color = set2[i]
    ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor=almost_black, facecolor=color, linewidth=0.15)

# Remove top and right axes lines ("spines")
spines_to_remove = ['top', 'right']
for spine in spines_to_remove:
    ax.spines[spine].set_visible(False)

# Get rid of ticks. The position of the numbers is informative enough of
# the position of the value.
ax.xaxis.set_ticks_position('none')
ax.yaxis.set_ticks_position('none')

# For remaining spines, thin out their line and change the black to a slightly off-black dark grey
spines_to_keep = ['bottom', 'left']
for spine in spines_to_keep:
    ax.spines[spine].set_linewidth(0.5)
    ax.spines[spine].set_color(almost_black)
fig.savefig('scatter_matplotlib_improved_07_axis_black_to_almost_black.png')
```
![Matplotlib scatter improved 07: changed axis lines from black to almost black](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_matplotlib_improved_07_axis_black_to_almost_black.png)


This is nice. But if you look closely, the tick labels are still black :(  We
have to change them separately, using

```python
# Change the labels to the off-black
ax.xaxis.label.set_color(almost_black)
ax.yaxis.label.set_color(almost_black)
```

And while we're at it, let's add a title and make it dark grey too.

```python
# Change the axis title to off-black
ax.title.set_color(almost_black)

ax.set_title('prettyplotlib `scatter` example\nshowing improved matplotlib `scatter`')
```

The full code is,
```python
import matplotlib.pyplot as mpl_plt
import brewer2mpl

# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors

# Set the random seed for consistency
np.random.seed(12)

# Save a nice dark grey as a variable
almost_black = '#262626'

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    color = set2[i]
    ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor=almost_black, facecolor=color, linewidth=0.15)

# Remove top and right axes lines ("spines")
spines_to_remove = ['top', 'right']
for spine in spines_to_remove:
    ax.spines[spine].set_visible(False)

# Get rid of ticks. The position of the numbers is informative enough of
# the position of the value.
ax.xaxis.set_ticks_position('none')
ax.yaxis.set_ticks_position('none')

# For remaining spines, thin out their line and change the black to a slightly off-black dark grey
spines_to_keep = ['bottom', 'left']
for spine in spines_to_keep:
    ax.spines[spine].set_linewidth(0.5)
    ax.spines[spine].set_color(almost_black)

# Change the labels to the off-black
ax.xaxis.label.set_color(almost_black)
ax.yaxis.label.set_color(almost_black)

# Change the axis title to off-black
ax.title.set_color(almost_black)

ax.set_title('prettyplotlib `scatter` example\nshowing improved matplotlib `scatter`')
fig.savefig('scatter_matplotlib_improved_08_labels_black_to_almost_black.png')
```

![Matplotlib scatter improved 08: changed labels to almost black](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_matplotlib_improved_08_labels_black_to_almost_black.png)


If you remember in the original example, we also had an axis legend, using

```python
ax.legend()
```

So let's add it to this code, too.

```python
import matplotlib.pyplot as mpl_plt
import brewer2mpl

# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors

# Set the random seed for consistency
np.random.seed(12)

# Save a nice dark grey as a variable
almost_black = '#262626'

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    color = set2[i]
    ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor=almost_black, facecolor=color, linewidth=0.15)

# Remove top and right axes lines ("spines")
spines_to_remove = ['top', 'right']
for spine in spines_to_remove:
    ax.spines[spine].set_visible(False)

# Get rid of ticks. The position of the numbers is informative enough of
# the position of the value.
ax.xaxis.set_ticks_position('none')
ax.yaxis.set_ticks_position('none')

# For remaining spines, thin out their line and change the black to a slightly off-black dark grey
almost_black = '#262626'
spines_to_keep = ['bottom', 'left']
for spine in spines_to_keep:
    ax.spines[spine].set_linewidth(0.5)
    ax.spines[spine].set_color(almost_black)

# Change the labels to the off-black
ax.xaxis.label.set_color(almost_black)
ax.yaxis.label.set_color(almost_black)

# Change the axis title to off-black
ax.title.set_color(almost_black)

ax.legend()
    
ax.set_title('prettyplotlib `scatter` example\nshowing improved matplotlib `scatter`')
fig.savefig('scatter_matplotlib_improved_09_ugly_legend.png')
```

![Matplotlib scatter improved 09: added ugly legend](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_matplotlib_improved_09_ugly_legend.png)

There are many things I don't like about this legend.

1. First of all, why does it have such a thick border line? What does that
really add to our interpretation of the legend? The black line is so thick that
it distracts from what we're trying to portray - which label goes with which
color.
2. Why does it show three points? Does this legend think I'm dumb and can't
figure out which symbol goes with which label after one iteration, so it does it
three times?
3. Finally, the legend labels are pure black. Maybe you notice it too, after
comparing to x-axis and y-axis lines and labels.

We'll accomplish these three things using this code:

```python
# Remove the line around the legend box, and instead fill it with a light grey
# Also only use one point for the scatterplot legend because the user will
# get the idea after just one, they don't need three.
light_grey = np.array([float(248)/float(255)]*3)
legend = ax.legend(frameon=True, scatterpoints=1, fontcolor=almost_black)
rect = legend.get_frame()
rect.set_facecolor(light_grey)
rect.set_linewidth(0.0)

# Change the legend label colors to almost black, too
texts = legend.texts
for t in texts:
    t.set_color(almost_black)
```

Now our code is pretty huge ...

```python
import matplotlib.pyplot as mpl_plt
import brewer2mpl

# Get "Set2" colors from ColorBrewer (all colorbrewer scales: http://bl.ocks.org/mbostock/5577023)
set2 = brewer2mpl.get_map('Set2', 'qualitative', 8).mpl_colors

# Set the random seed for consistency
np.random.seed(12)

# Save a nice dark grey as a variable
almost_black = '#262626'

fig, ax = mpl_plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    color = set2[i]
    ax.scatter(x, y, label=str(i), alpha=0.5, edgecolor=almost_black, facecolor=color, linewidth=0.15)

# Remove top and right axes lines ("spines")
spines_to_remove = ['top', 'right']
for spine in spines_to_remove:
    ax.spines[spine].set_visible(False)

# Get rid of ticks. The position of the numbers is informative enough of
# the position of the value.
ax.xaxis.set_ticks_position('none')
ax.yaxis.set_ticks_position('none')

# For remaining spines, thin out their line and change the black to a slightly off-black dark grey
almost_black = '#262626'
spines_to_keep = ['bottom', 'left']
for spine in spines_to_keep:
    ax.spines[spine].set_linewidth(0.5)
    ax.spines[spine].set_color(almost_black)

# Change the labels to the off-black
ax.xaxis.label.set_color(almost_black)
ax.yaxis.label.set_color(almost_black)

# Change the axis title to off-black
ax.title.set_color(almost_black)

# Remove the line around the legend box, and instead fill it with a light grey
# Also only use one point for the scatterplot legend because the user will 
# get the idea after just one, they don't need three.
light_grey = np.array([float(248)/float(255)]*3)
legend = ax.legend(frameon=True, scatterpoints=1)
rect = legend.get_frame()
rect.set_facecolor(light_grey)
rect.set_linewidth(0.0)

# Change the legend label colors to almost black, too
texts = legend.texts
for t in texts:
    t.set_color(almost_black)

    
ax.set_title('prettyplotlib `scatter` example\nshowing improved matplotlib `scatter`')
fig.savefig('scatter_matplotlib_improved_10_pretty_legend.png')
```

![Matplotlib scatter improved 10: beautiful legend](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_matplotlib_improved_10_pretty_legend.png)


Aaaaaaaaaaand I got tired of doing all those steps, EVERY time I wanted to make a simple scatterplot. So I wrote
[`prettyplotlib`](http://github.com/olgabot/prettyplotlib). Here's an
illustrative example of how awesome `prettyplotlib` is, and how it will save
all the time you spent agonizing over making your `matplotlib` plots beautiful.

```python
import prettyplotlib as ppl

# This is "import matplotlib.pyplot as plt" from the prettyplotlib library
from prettyplotlib import plt

# This is "import matplotlib as mpl" from the prettyplotlib library
from prettyplotlib import mpl

# Set the random seed for consistency
np.random.seed(12)

fig, ax = plt.subplots(1)

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    ppl.scatter(ax, x, y, label=str(i))
    
ppl.legend(ax)
    
ax.set_title('prettyplotlib `scatter` example\nshowing default color cycle and scatter params')
fig.savefig('scatter_prettyplotlib_default.png')
```

![Matplotlib scatter improved 10: beautiful legend](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_prettyplotlib_default.png)

The only commands that were different from the very first example with
matplotlib are:

```python
ppl.scatter(ax, x, y, label=str(i), facecolor='none')
```

instead of:

```python
ax.scatter(x, y, label=str(i))
```

And a different legend command:

```python
ppl.legend(ax)
```

instead of:

```python
ax.legend()
```

If you ***really*** want to get the original matplotlib style back in
prettyplotlib, you can do:

```python
import prettyplotlib as ppl
from prettyplotlib import plt
from prettyplotlib import mpl
from prettyplotlib import brewer2mpl

# Set the random seed for consistency
np.random.seed(12)

fig, ax = plt.subplots(1)

#mpl.rcParams['axis.color_cycle'] = ['blue']

# Show the whole color range
for i in range(8):
    x = np.random.normal(loc=i, size=1000)
    y = np.random.normal(loc=i, size=1000)
    ax.scatter(x, y, label=str(i), facecolor='blue', edgecolor='black', linewidth=1)
    
# Get back the top and right axes lines ("spines")
spines_to_remove = ['top', 'right']
for spine in spines_to_remove:
    ax.spines[spine].set_visible(True)
    
# Get back the ticks. The position of the numbers is informative enough of
# the position of the value.
ax.xaxis.set_ticks_position('both')
ax.yaxis.set_ticks_position('both')

# For all the spines, make their line thicker and return them to be black
all_spines = ['top', 'left', 'bottom', 'right']
for spine in all_spines:
    ax.spines[spine].set_linewidth(1.0)
    ax.spines[spine].set_color('black')

# Change the labels back to black
ax.xaxis.label.set_color('black')
ax.yaxis.label.set_color('black')

# Change the axis title also back to black
ax.title.set_color('black')

# Remove the line around the legend box, and instead fill it with a light grey
# Also only use one point for the scatterplot legend because the user will 
# get the idea after just one, they don't need three.
ax.legend()
    
ax.set_title('prettyplotlib `scatter` example\nrevert everything back to default matplotlib parameters')
fig.savefig('scatter_prettyplotlib_back_to_matplotlib_default.png')
```

![Matplotlib scatter improved 10: beautiful legend](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/scatter_prettyplotlib_back_to_matplotlib_default.png)

Notice that the default calls of `ax.scatter` and `ax.legend` do the usual
thing. This is important, because for `prettyplotlib` to work, you'll need to
use a syntax that's different from the usual `matplotlib` one:  `ppl.scatter(ax,
x, y...)` instead of `ax.scatter(x, y, ...)`



# `prettyplotlib.pcolormesh`: Improving heatmaps in `matplotlib`

## Both positive and negative values

The default `matplotlib` `pcolormesh` heatmaps use a rainbow colormap, which has
been known to mislead data visualization. Specifically, [*"the rainbow color map
is universally inferior to all other color maps"*](http://www.sv.vt.edu/~rkriz/Projects/create_color_table/color_07.pdf).
Unfortunately, `matplotlib` took its default colors from MATLAB,
and there the default is also rainbow.


```python
import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots(1)

np.random.seed(10)

#ax.pcolor(np.random.randn((10,10)))
#ax.pcolor(np.random.randn(10), np.random.randn(10))
p = ax.pcolormesh(np.random.randn(10,10))
fig.colorbar(p)
fig.savefig('pcolormesh_matplotlib_default.png')
```
![Matplotlib default scatterplot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_matplotlib_default.png)

Using the same zero-centered randomly distributed gaussian distribution, we can
plot it using `prettyplotlib` with a few modifications in syntax:

```python
ppl.pcolormesh(fig, ax, np.random.randn(10,10))
```

You'll notice that the "hot" (large, positive) color is still red, and the
"cold" (small, negative) color is still blue, but the in between colors are
gradations of red and blue, so it's easier to tell the difference between
values.

```python
import prettyplotlib as ppl
from prettyplotlib import plt
import numpy as np

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.random.randn(10,10))
fig.savefig('pcolormesh_prettyplotlib_default.png')
```
![Matplotlib default scatterplot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_default.png)


You may have also noticed similar changes as were made in `prettyplotlib.scatter`,
where axis lines were removed, and blacks were changed to almost black.

## Only positive (or negative) values

If your data is only positive (or negative), `matplotlib` does nothing to change
the color scale. It's still a rainbow, but look at the colorbar, the range is
different (0 to 1 instead of -2 to +2)

```python
import prettyplotlib as ppl
from prettyplotlib import plt
import numpy as np

fig, ax = plt.subplots(1)

np.random.seed(10)

p = ax.pcolormesh(np.random.uniform(size=(10,10)))
fig.colorbar(p)
fig.savefig('pcolormesh_matplotlib_positive_default.png')
```

![Matplotlib default scatterplot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_matplotlib_positive_default.png)

If your data is only positive or negative, then `prettyplotlib` will auto-detect
this and use a single-color colormap. The default for positive data is the
`reds` colormap.

```python
import prettyplotlib as ppl
from prettyplotlib import plt
import numpy as np

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.abs(np.random.randn(10,10)))
fig.savefig('pcolormesh_prettyplotlib_positive.png')
```

![Matplotlib default scatterplot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_positive.png)


And the default for negative data is the `blues` colormap.

```python
import prettyplotlib as ppl
from prettyplotlib import plt
import numpy as np

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, -np.abs(np.random.randn(10,10)))
fig.savefig('pcolormesh_prettyplotlib_negative.png')
```
![Matplotlib default scatterplot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_negative.png)

Plus you can add x- and y-ticklabels directly!

Normally, when you add x- and y-ticklabels on `pcolormesh` in `matplotlib`,
they're not centered on the blocks, and you have to do a lot of annoying work
just getting a label on each box. You have to specify the xticks explicitly,
since you want to label each box.

```python
xticks = range(10)
yticks = range(10)

xticklabels=string.uppercase[:10]
yticklabels=string.lowercase[-10:]

ax.set_xticks(xticks)
ax.set_xticklabels(xticklabels)

ax.set_yticks(yticks)
ax.set_yticklabels(yticklabels)
```

The full, `matplotlib` code is:

```python
import prettyplotlib as ppl
from prettyplotlib import plt
import numpy as np
import string

fig, ax = plt.subplots(1)

np.random.seed(10)

p = ax.pcolormesh(np.abs(np.random.randn(10,10)))
fig.colorbar(p)

xticks = range(10)
yticks = range(10)

xticklabels=string.uppercase[:10]
yticklabels=string.lowercase[-10:]

ax.set_xticks(xticks)
ax.set_xticklabels(xticklabels)

ax.set_yticks(yticks)
ax.set_yticklabels(yticklabels)


fig.savefig('pcolormesh_matplotlib_positive_labels.png')
```
![Matplotlib default scatterplot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_matplotlib_positive_labels.png)


But `prettyplotlib.pcolormesh` assumes that you want the `xticklabels` and
`yticklabels` on each block, and makes it easy to specify.

```python
ppl.pcolormesh(fig, ax, np.random.uniform(size=(10,10)),
               xticklabels=string.uppercase[:10],
               yticklabels=string.lowercase[-10:])
```

The full `prettyplotlib` code is,

```python
import prettyplotlib as ppl
from prettyplotlib import plt
import numpy as np
import string

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.random.randn(10,10), 
               xticklabels=string.uppercase[:10], 
               yticklabels=string.lowercase[-10:])
fig.savefig('pcolormesh_prettyplotlib_labels.png')
```

![Matplotlib default scatterplot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_labels.png)


Or pick your own colormap! The diverging colormap `PRGn` or Purple and Green is
pretty nice. I usually use this website to look up the colormaps: [Every
Colorbrewer Scale](http://bl.ocks.org/mbostock/5577023) (hover over the colors to get the name of the colormap)

```python
import prettyplotlib as ppl
from prettyplotlib import plt
from prettyplotlib import brewer2mpl
import numpy as np
import string

green_purple = brewer2mpl.get_map('PRGn', 'diverging', 11).mpl_colormap

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.random.randn(10,10), 
               xticklabels=string.uppercase[:10], 
               yticklabels=string.lowercase[-10:],
               cmap=green_purple)
fig.savefig('pcolormesh_prettyplotlib_labels_other_cmap_diverging.png')
```
![Matplotlib default scatterplot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_labels_other_cmap_diverging.png)



Or if you want your own colormap for positive-only data:


```python
import prettyplotlib as ppl
from prettyplotlib import plt
from prettyplotlib import brewer2mpl
import numpy as np
import string

red_purple = brewer2mpl.get_map('RdPu', 'Sequential', 9).mpl_colormap

fig, ax = plt.subplots(1)

np.random.seed(10)

ppl.pcolormesh(fig, ax, np.abs(np.random.randn(10,10)),
               xticklabels=string.uppercase[:10], 
               yticklabels=string.lowercase[-10:],
               cmap=red_purple)
fig.savefig('pcolormesh_prettyplotlib_labels_other_cmap_sequential.png')
```
![Matplotlib default scatterplot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_labels_other_cmap_sequential.png)

Plus, this will take the usual parameters of `pcolormesh` like if you want to
rescale your data to log-scale:

```python
from matplotlib.colors import LogNorm
...
ppl.pcolormesh(..., norm=LogNorm(vmin=x.min().min(), vmax=x.max().max()))
```

The full `prettyplotlib` code is,

```python
import prettyplotlib as ppl
from prettyplotlib import plt
from prettyplotlib import brewer2mpl
import numpy as np
import string
from matplotlib.colors import LogNorm

red_purple = brewer2mpl.get_map('RdPu', 'Sequential', 9).mpl_colormap

fig, ax = plt.subplots(1)

np.random.seed(10)

x = np.abs(np.random.randn(10,10))
ppl.pcolormesh(fig, ax, x,
               xticklabels=string.uppercase[:10], 
               yticklabels=string.lowercase[-10:],
               cmap=red_purple, 
               norm=LogNorm(vmin=x.min().min(), vmax=x.max().max()))
fig.savefig('pcolormesh_prettyplotlib_labels_lognorm.png')
```

![Matplotlib default scatterplot](https://raw.github.com/olgabot/prettyplotlib/master/ipython_notebooks/pcolormesh_prettyplotlib_labels_lognorm.png)


And now you can easily make beautiful heatmaps!

# That's all, folks!

That's my introduction to `prettyplotlib` and why you need it. There are similar
examples for the other functions, but these ones for `ppl.scatter` and `ppl.pcolormesh` are the most
extensive.

