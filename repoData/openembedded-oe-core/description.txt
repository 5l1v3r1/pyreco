2012/03/30 - Mark Hatle <mark.hatle@windriver.com>
 - Initial Revision

The ARM architecture definitions are split among a number of files.
The primary definitions for the variables are handled by the core
arch-arm.inc file.

TUNE_ARCH is set to either "arm" or "armeb" depending on the value
of the existence of the "bigendian" feature in a given tune.

A small set of ARM specific variables have been defined to allow 
TUNE_PKGARCH to be automatically defined.  Optimized tunings must NOT 
change the definiton of TUNE_PKGARCH.  TUNE_PKGACH_tune-<tune> will be 
ignored.  The format of the package arch is enforced by the TUNE_PKGARCH
default.  The format must be of the form:
<armversion>[t][e][hf][b][-vfp][-neon]

TUNE_PKGARCH is defined as:
${ARMPKGARCH}${ARMPKGSFX_THUMB}${ARMPKGSFX_DSP}${ARMPKGSFX_EABI}${ARMPKGSFX_ENDIAN}${ARMPKGSFX_FPU}

ARMPKGARCH - This is the core package arch component specified by each 
tuning.  This is the primary identifier of a tuning.  Usual values are:
arm, armv4, armv5, armv6, armv7a, etc.

ARMPKGSFX_THUMB - This is the thumb specific suffix.  Curently it is 
defined in feature-arm-thumb.inc.

ARMPKGSFX_DSP - This is the DSP specific suffix.  Currently this is set 
to 'e' when on armv5 and the dsp feature is enabled.

ARMPKGSFX_EABI - This is the eabi specific suffix.  There are currently 
two defined ABIs specificed, standard EABI and Hard Float (VFP) EABI.  
When the callconvention-hard is enabled, "hf" is specified, otherwise it 
is blank.

ARMPKGSFX_ENDIAN - This is the endian specific suffix.  It is defined in 
the core arch-arm.inc file.

ARMPKGSFX_FPU - This is the FPU specific suffix.  The suffix indicates 
specific FPU optimizations.  'vfp' and 'neon' are both defined.

2012/03/30 - Mark Hatle <mark.hatle@windriver.com>
  - Initial Version

MIPS currently defines 12 ABIs.  Combinations of:
 *) Big/Little Endian
 *) Hardware/Software Floating Point
 *) o32, n32, n64 ABI

TUNE_ARCH, the GNU canonical arch, is defined as:

mips${MIPSPKGSFX_BYTE}${MIPSPKGSFX_ENDIAN}

The package arch is defined in such a way to generated a standard naming
scheme.  The scheme is: <mips variant>[-nf][-n32]

TUNE_PKGARCH is defined as:

${MIPSPKGSFX_VARIANT_tune-${DEFAULTTUNE}}${MIPSPKGSFX_FPU}${MIPSPKGSFX_ABI}

The following is a list of MIPS specific variables:

MIPSPKGSFX_BYTE - This is defined as either blank and "64" for MIPS64 CPUs.

MIPSPKGSFX_ENDIAN - For bigendian hardware this is blank, otherwise it's
defined as "el".

MIPSPKGSFX_VARIANT_tune-<tune> - In the default tunings it is set to the
same value as TUNE_ARCH.  In custom, optimized tunings, the value should
be modified to more precisely describe the tuning.

MIPSPKGSFX_FPU - The value is set to "" or "-nf", where "-nf" indicates 
that the tune is using a non-floating point ABI.

MIPSPKGSFX_ABI - This is used to specify an alternative ABI when the previous
values are not enough to distringuish the package.  "-n32" is added when
building for N32 ABI.

2012/03/30 - Mark Hatle <mark.hatle@windriver.com>
  - Initial revision

There are 4 primary PowerPC ABIs.
# *) Hard/Soft Floating Point
# *) 32-bit/64-bit

TUNE_ARCH is defined as either "powerpc" or "powerpc64" based on the m32 
or m64 feature.

May of the PowerPC package archictures are based on legacy Linux names.
However, a general naming scheme should be similar to: ppc[64][<family>][-nf].
(Note: the default package architectures are "powerpc" and "powerpc64".)

TUNE_PKGARCH is defined as TUNE_PKGARCH_tune-${DEFAULTTUNE}.  All 
PowerPC tunings are required to define TUNE_PKGARCH_tune-<tune>.


2012/03/30 - Mark Hatle <mark.hatle@windriver.com>
 - Initial Revision


Introduction
============
The individual CPU, and ABI tunings are contained in this directory.  A
number of local and global variables are used to control the way the
tunings are setup and how they work together to specify an optimized
configuration.

The following is brief summary of the generic components that are used
in these tunings.

AVAILTUNES - This is a list of all of the tuning definitions currently
available in the system.  Not all tunes in this list may be compatible
with the machine configuration, or each other in a multilib
configuration.  Each tuning file can add to this list using "+=", but
should never replace the list using "=".

DEFAULTTUNE - This specifies the tune to use for a particular build.
Each tune should specify a reasonable default, which can be overriden by
a machine or multilib configuration.  The specified tune must be listed
in the AVAILTUNES.

TUNEVALID[feature] - The <feature> is defined with a human readable
explanation for what it does.  All architectural, cpu, abi, etc tuning
features must be defined using TUNEVALID.

TUNECONFLICTS[feature] - A list of features which conflict with <feature>.
New sanity checks will try to reject combinations in which a single
tuning ends up with features which conflict with each other.

TUNE_FEATURES - This is automatically defined as TUNE_FEATURES_tune-<tune>.
See TUNE_FEATURES_tune-<tune> for more information.

TUNE_FEATURES_tune-<tune> - Specify the features used to describe a
specific tune.  This is a list of features that a tune support, each
feature must be in the TUNEVALID list.  Note: the tune and a given
feature name may be the same, but they have different purposes.  Only
features may be used to change behavior, while tunes are used to
describe an overall set of features.

ABIEXTENSION - An ABI extension may be specified by a specific feature
or other tuning setting, such as TARGET_FPU.  Any ABI extensions either
need to be defined in the architectures base arch file, i.e.
ABIEXTENSION = "eabi" in the arm case, or appended to in specific tune
files with a ".=".  Spaces are not allowed in this variable.

TUNE_CCARGS - Setup the cflags based on the TUNE_FEATURES settings.
These should be additive when defined using "+=".  All items in this
list should be dynamic! i.e.
${@bb.utils.contains("TUNE_FEATURES", "feature", "cflag", "!cflag", d)}

TUNE_ARCH - The GNU canonical arch for a specific architecture.  i.e.
arm, armeb, mips, mips64, etc.  This value is used by bitbake to setup
configure. TUNE_ARCH definitions are specific to a given architecture.
They may be a single static definition, or may be dynamically adjusted.
See each architecture's README for details for that CPU family.

TUNE_PKGARCH - The package architecture used by the packaging systems to
define the architecture, abi and tuning of a particular package.
Similarly to TUNE_ARCH, the definition of TUNE_PKGARCH is specific to
each architecture. See each architectures README for details for that
CPU family.

PACKAGE_EXTRA_ARCHS - Lists all runtime compatible package
architectures.  By default this is equal to
PACKAGE_EXTRA_ARCHS_tune-<tune>.  If an architecture deviates from the
default it will be listed in the architecture README.

PACKAGE_EXTRA_ARCHS_tune-<tune> - List all of the package architectures
that are compatible with this specific tune.  The package arch of this
tune must be in the list.

TARGET_FPU - The FPU setting for a given tune, hard (generate floating
point instructions), soft (generate internal gcc calls), "other"
architecture specific floating point.  This is synchronized with the
compiler and other toolchain items.  This should be dynamically
configured in the same way that TUNE_CCARGS is.

BASE_LIB_tune-<tune> - The "/lib" location for a specific ABI.  This is
used in a multilib configuration to place the libraries in the correct,
non-conflicting locations.


Best Practice
=============
The tune infrastructure is designed to be hierarchical. When writing a
new tune file for a "fast-forward" CPU architecture (one that supports
everything from a previous generation), it is recommended to require the
previous generation tune file and specify PACKAGE_EXTRA_ARCHS using the
previous generation's override and appending the new tune. Note that
only one previous tune file should be included to avoid mutiple includes
of the base arch which could lead to a broken configuration due to
multiple prepend and append assignments.

For example, for x86, there is a common x86/arch-x86.inc which is
included in the base i586 tune file. The core2 tune builds
on that, and corei7 builds on core2.

2012/03/30 - Mark Hatle <mark.hatle@windriver.com>
 - Initial Revision

Both big endian and little endian are defined for SH.

Experimental -- SH tunings have not been validated.

The TUNE_ARCH is defined as ${TUNE_ARCH_tune-${DEFAULTTUNE}}.

The TUNE_PKGARCH is defind as ${TUNE_PKGARCH_tune-${DEFAULTTUNE}}.


2012/03/30 - Mark Hatle <mark.hatle@windriver.com>
 - Initial version

Most of the items for the X86 architectures are defined in the single
arch-x86 file.

Three ABIs are define, m32, mx32 and m64.

The following is the list of X86 specific variables:

X86ARCH32 - This is the 32-bit architecture GNU canonical arch, TUNE_ARCH.

X86ARCH64 - This is the 64-bit architecture GNU canonical arch, TUNE_ARCH.

The TUNE_PKGARCH is defined as follows:

TUNE_PKGARCH = ${TUNE_PKGARCH_tune-${DEFAULTTUNE}}

The package architecture for 32-bit targets is historical and generally
set to to match the core compatible processor type, i.e. i386.

For 64-bit architectures, the architecture is expected to end in '_64'.

If the x32 ABI is used, then the _64 is further extended with a '_x32'.

Files in the deploy directory will not be re-created automatically if you
delete them. If you do delete a file, you will need to run:

  bitbake -c clean TARGET
  bitbake TARGET

where TARGET is the name of the appropriate package or target e.g.
"virtual/kernel" for the kernel, an image, etc.

The files are pulled verbatim from glibc 2.5 and then patched to allow
standalone compilation of ldconfig.

Richard Purdie
OpenedHand Ltd.

Upgraded the ldconfig recipe to eglibc 2.12.1
Nitin A Kamble <nitin.a.kamble@intel.com> 2011/03/29

The recipes-rt recipes provide package and image recipes for using and testing
the PREEMPT_RT kernel. The core-image-rt*.bb images are minimal images with
a couple extra packages, including rt-tests. In order to build the image with
the linux-yocto-rt kernel, be sure to include the following line in your
local.conf, bblayers.conf, or your $MACHINE.conf.

PREFERRED_PROVIDER_virtual/kernel = "linux-yocto-rt"

If you are creating a new BSP which should use linux-yocto-rt by default,
use the line above in the $MACHINE.conf in your BSP layer, and specify the
following in a linux-yocto-rt bbappend recipe:

COMPATIBLE_MACHINE_$MACHINE = $MACHINE

This layer is intended as test layer, used by scripts/oe-selftest
and it's probably a mistake to include it in your builds (unless you
want to run the script).

OpenEmbedded-Core
=================

OpenEmbedded-Core is a layer containing the core metadata for current versions
of OpenEmbedded. It is distro-less (can build a functional image with
DISTRO = "nodistro") and contains only emulated machine support.

For information about OpenEmbedded, see the OpenEmbedded website:
    http://www.openembedded.org/

The Yocto Project has extensive documentation about OE including a reference manual
which can be found at:
    http://yoctoproject.org/documentation



			    PYBOOTCHARTGUI
			   ----------------

pybootchartgui is a tool (now included as part of bootchart2) for
visualization and analysis of the GNU/Linux boot process. It renders
the output of the boot-logger tool bootchart (see
http://www.bootchart.org/) to either the screen or files of various
formats. Bootchart collects information about the processes, their
dependencies, and resource consumption during boot of a GNU/Linux
system. The pybootchartgui tools visualizes the process tree and
overall resource utilization.

pybootchartgui is a port of the visualization part of bootchart from
Java to Python and Cairo.

Adapted from the bootchart-documentation:

  The CPU and disk statistics are used to render stacked area and line
  charts. The process information is used to create a Gantt chart
  showing process dependency, states and CPU usage.

  A typical boot sequence consists of several hundred processes. Since
  it is difficult to visualize such amount of data in a comprehensible
  way, tree pruning is utilized. Idle background processes and
  short-lived processes are removed. Similar processes running in
  parallel are also merged together.

  Finally, the performance and dependency charts are rendered as a
  single image to either the screen or in PNG, PDF or SVG format.


To get help for pybootchartgui, run

$ pybootchartgui --help

This code was originally hosted at:
	http://code.google.com/p/pybootchartgui/

This directory contains Various useful scripts for working with OE builds

Using OE images with QEMU
=========================

OE-Core can generate qemu bootable kernels and images with can be used 
on a desktop system. The scripts currently support booting ARM, MIPS, PowerPC
and x86 (32 and 64 bit) images. The scripts can be used within the OE build 
system or externaly.

The runqemu script is run as: 

   runqemu <machine> <zimage> <filesystem>

where:

   <machine> is the machine/architecture to use (qemuarm/qemumips/qemuppc/qemux86/qemux86-64)
   <zimage> is the path to a kernel (e.g. zimage-qemuarm.bin)
   <filesystem> is the path to an ext2 image (e.g. filesystem-qemuarm.ext2) or an nfs directory
   
If <machine> isn't specified, the script will try to detect the machine name 
from the name of the <zimage> file.

If <filesystem> isn't specified, nfs booting will be assumed.

When used within the build system, it will default to qemuarm, ext2 and the last kernel and 
core-image-sato-sdk image built by the build system. If an sdk image isn't present it will look
for sato and minimal images.

Full usage instructions can be seen by running the command with no options specified.


Notes
=====

 - The scripts run qemu using sudo. Change perms on /dev/net/tun to 
   run as non root. The runqemu-gen-tapdevs script can also be used by
   root to prepopulate the appropriate network devices.
 - You can access the host computer at 192.168.7.1 within the image.
 - Your qemu system will be accessible as 192.16.7.2.
 - The script extracts the root filesystem specified under pseudo and sets up a userspace
   NFS server to share the image over by default meaning the filesystem can be accessed by
   both the host and guest systems.


